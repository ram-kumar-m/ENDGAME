class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> twoSum ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> nums_index <SPC> = <SPC> [ ( v , <SPC> index ) <SPC> for <SPC> index , <SPC> v <SPC> in <SPC> enumerate ( nums ) ] <NL> <TAB> nums_index . sort ( ) <NL> <TAB> begin , <SPC> end <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> begin <SPC> < <SPC> end : <NL>          curr <SPC> = <SPC> nums_index [ begin ] [ 0 ] <SPC> + <SPC> nums_index [ end ] [ 0 ] <NL>          if <SPC> curr <SPC> == <SPC> target : <NL>              return <SPC> [ nums_index [ begin ] [ 1 ] , <SPC> nums_index [ end ] [ 1 ] ] <NL>          elif <SPC> curr <SPC> < <SPC> target : <NL>              begin <SPC> += <SPC> 1 <NL>          else : <NL>              end <SPC> -= <SPC> 1 <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . twoSum ( [ 3 , <SPC> 2 , <SPC> 4 ] , <SPC> 6 ) <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> addTwoNumbers ( self , <SPC> l1 , <SPC> l2 ) : <NL> <TAB> carry <SPC> = <SPC> 0 <NL> <NL> <TAB> head <SPC> = <SPC> curr <SPC> = <SPC> ListNode ( 0 ) <NL> <TAB> while <SPC> l1 <SPC> or <SPC> l2 : <NL>          val <SPC> = <SPC> carry <NL>          if <SPC> l1 : <NL>              val <SPC> += <SPC> l1 . val <NL>              l1 <SPC> = <SPC> l1 . next <NL>          if <SPC> l2 : <NL>              val <SPC> += <SPC> l2 . val <NL>              l2 <SPC> = <SPC> l2 . next <NL>          curr . next <SPC> = <SPC> ListNode ( val <SPC> % <SPC> 10 ) <NL>          curr <SPC> = <SPC> curr . next <NL>          carry <SPC> = <SPC> val <SPC> / <SPC> 10 <NL> <TAB> if <SPC> carry <SPC> > <SPC> 0 : <NL>          curr . next <SPC> = <SPC> ListNode ( carry ) <NL> <TAB> return <SPC> head . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> lengthOfLongestSubstring ( self , <SPC> s ) : <NL> <NL> <TAB> charMap <SPC> = <SPC> { } <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 256 ) : <NL>          charMap [ i ] <SPC> = <SPC> - 1 <NL> <TAB> ls <SPC> = <SPC> len ( s ) <NL> <TAB> i <SPC> = <SPC> max_len <SPC> = <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> range ( ls ) : <NL> <NL>          if <SPC> charMap [ ord ( s [ j ] ) ] <SPC> >= <SPC> i : <NL>              i <SPC> = <SPC> charMap [ ord ( s [ j ] ) ] <SPC> + <SPC> 1 <NL>          charMap [ ord ( s [ j ] ) ] <SPC> = <SPC> j <NL>          max_len <SPC> = <SPC> max ( max_len , <SPC> j <SPC> - <SPC> i <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> max_len <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> findMedianSortedArrays ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> ls1 , <SPC> ls2 <SPC> = <SPC> len ( nums1 ) , <SPC> len ( nums2 ) <NL> <TAB> if <SPC> ls1 <SPC> < <SPC> ls2 : <NL>          return <SPC> self . findMedianSortedArrays ( nums2 , <SPC> nums1 ) <NL> <TAB> l , <SPC> r <SPC> = <SPC> 0 , <SPC> ls2 <SPC> * <SPC> 2 <NL> <TAB> while <SPC> l <SPC> <= <SPC> r : <NL>          mid2 <SPC> = <SPC> ( l <SPC> + <SPC> r ) <SPC> >> <SPC> 1 <NL>          mid1 <SPC> = <SPC> ls1 <SPC> + <SPC> ls2 <SPC> - <SPC> mid2 <NL>          L1 <SPC> = <SPC> - sys . maxint <SPC> - <SPC> 1 <SPC> if <SPC> mid1 <SPC> == <SPC> 0 <SPC> else <SPC> nums1 [ ( mid1 <SPC> - <SPC> 1 ) <SPC> >> <SPC> 1 ] <NL>          L2 <SPC> = <SPC> - sys . maxint <SPC> - <SPC> 1 <SPC> if <SPC> mid2 <SPC> == <SPC> 0 <SPC> else <SPC> nums2 [ ( mid2 <SPC> - <SPC> 1 ) <SPC> >> <SPC> 1 ] <NL>          R1 <SPC> = <SPC> sys . maxint <SPC> if <SPC> mid1 <SPC> == <SPC> 2 <SPC> * <SPC> ls1 <SPC> else <SPC> nums1 [ mid1 <SPC> >> <SPC> 1 ] <NL>          R2 <SPC> = <SPC> sys . maxint <SPC> if <SPC> mid2 <SPC> == <SPC> 2 <SPC> * <SPC> ls2 <SPC> else <SPC> nums2 [ mid2 <SPC> >> <SPC> 1 ] <NL>          if <SPC> L1 <SPC> > <SPC> R2 : <NL>              l <SPC> = <SPC> mid2 <SPC> + <SPC> 1 <NL>          elif <SPC> L2 <SPC> > <SPC> R1 : <NL>              r <SPC> = <SPC> mid2 <SPC> - <SPC> 1 <NL>          else : <NL>              return <SPC> ( max ( L1 , <SPC> L2 ) <SPC> + <SPC> min ( R1 , <SPC> R2 ) ) <SPC> / <SPC> 2.0 <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . findMedianSortedArrays ( [ 1 , <SPC> 1 ] , <SPC> [ 1 , <SPC> 2 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestPalindrome ( self , <SPC> s ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( s ) <NL> <TAB> if <SPC> ls <SPC> <= <SPC> 1 <SPC> or <SPC> len ( set ( s ) ) <SPC> == <SPC> 1 : <NL>          return <SPC> s <NL> <NL> <TAB> temp_s <SPC> = <SPC> "#" . join ( "{}" . format ( s ) ) <NL> <NL> <TAB> tls <SPC> = <SPC> len ( temp_s ) <NL> <TAB> seed <SPC> = <SPC> range ( 1 , <SPC> tls <SPC> - <SPC> 1 ) <NL> <NL> <TAB> len_table <SPC> = <SPC> [ 0 ] <SPC> * <SPC> tls <NL> <TAB> for <SPC> step <SPC> in <SPC> range ( 1 , <SPC> tls <SPC> / <SPC> 2 <SPC> + <SPC> 1 ) : <NL>          final <SPC> = <SPC> [ ] <NL>          for <SPC> pos <SPC> in <SPC> seed : <NL>              if <SPC> pos <SPC> - <SPC> step <SPC> < <SPC> 0 <SPC> or <SPC> pos <SPC> + <SPC> step <SPC> >= <SPC> tls : <NL>                  continue <NL>              if <SPC> temp_s [ pos <SPC> - <SPC> step ] <SPC> != <SPC> temp_s [ pos <SPC> + <SPC> step ] : <NL>                  continue <NL>              final . append ( pos ) <NL>              if <SPC> temp_s [ pos <SPC> - <SPC> step ] <SPC> == <SPC> "#" : <NL>                  continue <NL>              len_table [ pos ] <SPC> = <SPC> step <NL>          seed <SPC> = <SPC> final <NL> <TAB> max_pos , <SPC> max_step <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> s <SPC> in <SPC> enumerate ( len_table ) : <NL>          if <SPC> s <SPC> >= <SPC> max_step : <NL>              max_step <SPC> = <SPC> s <NL>              max_pos <SPC> = <SPC> i <NL> <TAB> return <SPC> temp_s [ max_pos <SPC> - <SPC> max_step : <SPC> max_pos <SPC> + <SPC> max_step <SPC> + <SPC> 1 ] . translate ( None , <SPC> "#" ) <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . longestPalindrome ( "abcbe" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> convert ( self , <SPC> s , <SPC> numRows ) : <NL> <NL> <TAB> if <SPC> numRows <SPC> == <SPC> 1 : <NL>          return <SPC> s <NL> <NL> <TAB> p <SPC> = <SPC> 2 <SPC> * <SPC> ( numRows <SPC> - <SPC> 1 ) <NL> <TAB> result <SPC> = <SPC> [ "" ] <SPC> * <SPC> numRows <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          floor <SPC> = <SPC> i <SPC> % <SPC> p <NL>          if <SPC> floor <SPC> >= <SPC> p <SPC> // <SPC> 2 : <NL>              floor <SPC> = <SPC> p <SPC> - <SPC> floor <NL>          result [ floor ] <SPC> += <SPC> s [ i ] <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . convert ( "PAYPALISHIRING" , <SPC> 3 ) <NL> <NL> <NL> class <SPC> Solution : <NL> <NL> <TAB> def <SPC> reverse ( self , <SPC> x ) : <NL> <NL> <TAB> res , <SPC> isPos <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> if <SPC> x <SPC> < <SPC> 0 : <NL>          isPos <SPC> = <SPC> - 1 <NL>          x <SPC> = <SPC> - 1 <SPC> * <SPC> x <NL> <TAB> while <SPC> x <SPC> != <SPC> 0 : <NL>          res <SPC> = <SPC> res <SPC> * <SPC> 10 <SPC> + <SPC> x <SPC> % <SPC> 10 <NL>          if <SPC> res <SPC> > <SPC> 2147483647 : <NL>              return <SPC> 0 <NL>          x <SPC> /= <SPC> 10 <NL> <TAB> return <SPC> res <SPC> * <SPC> isPos <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> myAtoi ( self , <SPC> str ) : <NL> <NL> <TAB> sign <SPC> = <SPC> 1 <NL> <TAB> max_int , <SPC> min_int <SPC> = <SPC> 2147483647 , <SPC> - 2147483648 <NL> <TAB> result , <SPC> pos <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> ls <SPC> = <SPC> len ( str ) <NL> <TAB> while <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> str [ pos ] <SPC> == <SPC> " " : <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> if <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> str [ pos ] <SPC> == <SPC> "-" : <NL>          sign <SPC> = <SPC> - 1 <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> elif <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> str [ pos ] <SPC> == <SPC> "+" : <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> while <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> ord ( str [ pos ] ) <SPC> >= <SPC> ord ( "0" ) <SPC> and <SPC> ord ( str [ pos ] ) <SPC> <= <SPC> ord ( "9" ) : <NL>          num <SPC> = <SPC> ord ( str [ pos ] ) <SPC> - <SPC> ord ( "0" ) <NL>          if <SPC> result <SPC> > <SPC> max_int <SPC> / <SPC> 10 <SPC> or <SPC> ( result <SPC> == <SPC> max_int <SPC> / <SPC> 10 <SPC> and <SPC> num <SPC> >= <SPC> 8 ) : <NL>              if <SPC> sign <SPC> == <SPC> - 1 : <NL>                  return <SPC> min_int <NL>              return <SPC> max_int <NL>          result <SPC> = <SPC> result <SPC> * <SPC> 10 <SPC> + <SPC> num <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> return <SPC> sign <SPC> * <SPC> result <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . myAtoi ( "+-2" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPalindrome ( self , <SPC> x ) : <NL> <TAB> if <SPC> x <SPC> < <SPC> 0 : <NL>          return <SPC> False <NL> <TAB> ls <SPC> = <SPC> len ( str ( x ) ) <NL> <TAB> tmp <SPC> = <SPC> x <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( int ( ls <SPC> / <SPC> 2 ) ) : <NL>          right <SPC> = <SPC> int ( tmp <SPC> % <SPC> 10 ) <NL>          left <SPC> = <SPC> tmp <SPC> / <SPC> ( 10 <SPC> ** <SPC> ( ls <SPC> - <SPC> 2 <SPC> * <SPC> i <SPC> - <SPC> 1 ) ) <NL>          left <SPC> = <SPC> int ( left <SPC> % <SPC> 10 ) <NL>          if <SPC> left <SPC> != <SPC> right : <NL>              return <SPC> False <NL>          tmp <SPC> = <SPC> tmp <SPC> // <SPC> 10 <NL> <TAB> return <SPC> True <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . isPalindrome ( 1001 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isMatch ( self , <SPC> s , <SPC> p ) : <NL> <NL> <TAB> if <SPC> s <SPC> == <SPC> p : <NL>          return <SPC> True <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( s ) , <SPC> len ( p ) <NL> <TAB> dp <SPC> = <SPC> [ [ False ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> range ( m <SPC> + <SPC> 1 ) ] <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> True <NL> <TAB> for <SPC> j <SPC> in <SPC> range ( 1 , <SPC> n ) : <NL>          if <SPC> p [ j ] <SPC> == <SPC> "*" <SPC> and <SPC> dp [ 0 ] [ j <SPC> - <SPC> 1 ] : <NL>              dp [ 0 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> True <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( m ) : <NL>          for <SPC> j <SPC> in <SPC> range ( n ) : <NL>              if <SPC> p [ j ] <SPC> == <SPC> "." <SPC> or <SPC> p [ j ] <SPC> == <SPC> s [ i ] : <NL>                  dp [ i <SPC> + <SPC> 1 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> dp [ i ] [ j ] <NL>              elif <SPC> p [ j ] <SPC> == <SPC> "*" : <NL>                  if <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> != <SPC> s [ i ] <SPC> and <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> != <SPC> "." : <NL>                      dp [ i <SPC> + <SPC> 1 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> dp [ i <SPC> + <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <NL>                  else : <NL>                      dp [ i <SPC> + <SPC> 1 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> ( <NL>                          dp [ i <SPC> + <SPC> 1 ] [ j ] <SPC> or <SPC> dp [ i ] [ j <SPC> + <SPC> 1 ] <SPC> or <SPC> dp [ i <SPC> + <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <NL>                      ) <NL> <TAB> return <SPC> dp [ m ] [ n ] <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . isMatch ( "" , <SPC> ".*" ) <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> maxArea ( self , <SPC> height : <SPC> List [ int ] ) <SPC> -> <SPC> int : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( height ) <SPC> - <SPC> 1 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          result <SPC> = <SPC> max ( min ( height [ left ] , <SPC> height [ right ] ) <SPC> * <SPC> ( right <SPC> - <SPC> left ) , <SPC> result ) <NL>          if <SPC> height [ left ] <SPC> > <SPC> height [ right ] : <NL> <NL>              right <SPC> -= <SPC> 1 <NL>          else : <NL> <NL>              left <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> intToRoman ( self , <SPC> num ) : <NL> <TAB> values <SPC> = <SPC> [ 1000 , <SPC> 900 , <SPC> 500 , <SPC> 400 , <SPC> 100 , <SPC> 90 , <SPC> 50 , <SPC> 40 , <SPC> 10 , <SPC> 9 , <SPC> 5 , <SPC> 4 , <SPC> 1 ] <NL> <TAB> symbols <SPC> = <SPC> [ <NL>          "M" , <NL>          "CM" , <NL>          "D" , <NL>          "CD" , <NL>          "C" , <NL>          "XC" , <NL>          "L" , <NL>          "XL" , <NL>          "X" , <NL>          "IX" , <NL>          "V" , <NL>          "IV" , <NL>          "I" , <NL> <TAB> ] <NL> <TAB> roman <SPC> = <SPC> "" <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> num <SPC> > <SPC> 0 : <NL>          k <SPC> = <SPC> num <SPC> / <SPC> values [ i ] <NL>          for <SPC> j <SPC> in <SPC> range ( k ) : <NL>              roman <SPC> += <SPC> symbols [ i ] <NL>              num <SPC> -= <SPC> values [ i ] <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> roman <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . intToRoman ( 90 ) <NL> <NL> <NL> class <SPC> Solution : <NL> <NL> <TAB> def <SPC> romanToInt ( self , <SPC> s ) : <NL> <TAB> roman <SPC> = <SPC> { "I" : <SPC> 1 , <SPC> "V" : <SPC> 5 , <SPC> "X" : <SPC> 10 , <SPC> "L" : <SPC> 50 , <SPC> "C" : <SPC> 100 , <SPC> "D" : <SPC> 500 , <SPC> "M" : <SPC> 1000 } <NL> <TAB> prev , <SPC> total <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          curr <SPC> = <SPC> roman [ c ] <NL>          total <SPC> += <SPC> curr <NL> <NL>          if <SPC> curr <SPC> > <SPC> prev : <NL>              total <SPC> -= <SPC> 2 <SPC> * <SPC> prev <NL>          prev <SPC> = <SPC> curr <NL> <TAB> return <SPC> total <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestCommonPrefix ( self , <SPC> strs ) : <NL> <TAB> ls <SPC> = <SPC> len ( strs ) <NL> <TAB> if <SPC> ls <SPC> == <SPC> 1 : <NL>          return <SPC> strs [ 0 ] <NL> <TAB> prefix <SPC> = <SPC> "" <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <TAB> while <SPC> True : <NL>          try : <NL>              current <SPC> = <SPC> strs [ 0 ] [ pos ] <NL>          except <SPC> IndexError : <NL>              break <NL>          index <SPC> = <SPC> 1 <NL>          while <SPC> index <SPC> < <SPC> ls : <NL>              try : <NL>                  if <SPC> strs [ index ] [ pos ] <SPC> != <SPC> current : <NL>                      break <NL>              except <SPC> IndexError : <NL>                  break <NL>              index <SPC> += <SPC> 1 <NL>          if <SPC> index <SPC> == <SPC> ls : <NL>              prefix <SPC> = <SPC> prefix <SPC> + <SPC> current <NL>          else : <NL>              break <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> return <SPC> prefix <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . longestCommonPrefix ( [ "aca" , <SPC> "cba" ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> threeSum ( self , <SPC> nums ) : <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> nums . sort ( ) <NL> <TAB> ls <SPC> = <SPC> len ( nums ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls <SPC> - <SPC> 2 ) : <NL>          if <SPC> i <SPC> > <SPC> 0 <SPC> and <SPC> nums [ i ] <SPC> == <SPC> nums [ i <SPC> - <SPC> 1 ] : <NL>              continue <NL>          j <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>          k <SPC> = <SPC> ls <SPC> - <SPC> 1 <NL>          while <SPC> j <SPC> < <SPC> k : <NL>              curr <SPC> = <SPC> nums [ i ] <SPC> + <SPC> nums [ j ] <SPC> + <SPC> nums [ k ] <NL>              if <SPC> curr <SPC> == <SPC> 0 : <NL>                  res . append ( [ nums [ i ] , <SPC> nums [ j ] , <SPC> nums [ k ] ] ) <NL>                  while <SPC> j <SPC> < <SPC> k <SPC> and <SPC> nums [ j ] <SPC> == <SPC> nums [ j <SPC> + <SPC> 1 ] : <NL>                      j <SPC> += <SPC> 1 <NL>                  while <SPC> j <SPC> < <SPC> k <SPC> and <SPC> nums [ k ] <SPC> == <SPC> nums [ k <SPC> - <SPC> 1 ] : <NL>                      k <SPC> -= <SPC> 1 <NL>                  j <SPC> += <SPC> 1 <NL>                  k <SPC> -= <SPC> 1 <NL>              elif <SPC> curr <SPC> < <SPC> 0 : <NL>                  j <SPC> += <SPC> 1 <NL>              else : <NL>                  k <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> threeSumClosest ( self , <SPC> nums , <SPC> target ) : <NL> <TAB> ls <SPC> = <SPC> len ( nums ) <NL> <TAB> sort_nums <SPC> = <SPC> sorted ( nums ) <NL> <TAB> res <SPC> = <SPC> nums [ 0 ] <SPC> + <SPC> nums [ 1 ] <SPC> + <SPC> nums [ 2 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls <SPC> - <SPC> 2 ) : <NL>          j , <SPC> k <SPC> = <SPC> i <SPC> + <SPC> 1 , <SPC> ls <SPC> - <SPC> 1 <NL>          while <SPC> j <SPC> < <SPC> k : <NL>              temp <SPC> = <SPC> sort_nums [ i ] <SPC> + <SPC> sort_nums [ j ] <SPC> + <SPC> sort_nums [ k ] <NL>              if <SPC> abs ( target <SPC> - <SPC> temp ) <SPC> < <SPC> abs ( target <SPC> - <SPC> res ) : <NL>                  res <SPC> = <SPC> temp <NL>              if <SPC> temp <SPC> < <SPC> target : <NL>                  j <SPC> += <SPC> 1 <NL>              else : <NL>                  k <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> res <NL> <NL> <NL> dmap <SPC> = <SPC> { <NL> <TAB> "2" : <SPC> "abc" , <NL> <TAB> "3" : <SPC> "def" , <NL> <TAB> "4" : <SPC> "ghi" , <NL> <TAB> "5" : <SPC> "jkl" , <NL> <TAB> "6" : <SPC> "mno" , <NL> <TAB> "7" : <SPC> "pqrs" , <NL> <TAB> "8" : <SPC> "tuv" , <NL> <TAB> "9" : <SPC> "wxyz" , <NL> <TAB> "0" : <SPC> " " , <NL> <TAB> None : <SPC> None , <NL> } <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> letterCombinations ( self , <SPC> digits ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> ls <SPC> = <SPC> len ( digits ) <NL> <TAB> if <SPC> ls <SPC> == <SPC> 0 : <NL>          return <SPC> result <NL> <TAB> current <SPC> = <SPC> digits [ 0 ] <NL> <TAB> posfix <SPC> = <SPC> self . letterCombinations ( digits [ 1 : ] ) <NL> <TAB> for <SPC> t <SPC> in <SPC> dmap [ current ] : <NL>          if <SPC> len ( posfix ) <SPC> > <SPC> 0 : <NL>              for <SPC> p <SPC> in <SPC> posfix : <NL>                  temp <SPC> = <SPC> t <SPC> + <SPC> p <NL>                  result . append ( temp ) <NL>          else : <NL>              result . append ( t ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fourSum ( self , <SPC> nums , <SPC> target ) : <NL> <TAB> sort_nums <SPC> = <SPC> sorted ( nums ) <NL> <TAB> ls <SPC> = <SPC> len ( nums ) <NL> <TAB> res <SPC> = <SPC> { } <NL> <TAB> pairs <SPC> = <SPC> { } <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls <SPC> - <SPC> 3 ) : <NL>          for <SPC> j <SPC> in <SPC> range ( i <SPC> + <SPC> 1 , <SPC> ls <SPC> - <SPC> 2 ) : <NL>              res_2 <SPC> = <SPC> sort_nums [ i ] <SPC> + <SPC> sort_nums [ j ] <NL>              try : <NL>                  pairs [ target <SPC> - <SPC> res_2 ] . append ( [ i , <SPC> j ] ) <NL>              except <SPC> KeyError : <NL>                  pairs [ target <SPC> - <SPC> res_2 ] <SPC> = <SPC> [ [ i , <SPC> j ] ] <NL> <TAB> for <SPC> key , <SPC> temp <SPC> in <SPC> pairs . items ( ) : <NL>          for <SPC> pair <SPC> in <SPC> temp : <NL>              j <SPC> = <SPC> pair [ 1 ] <SPC> + <SPC> 1 <NL>              k <SPC> = <SPC> ls <SPC> - <SPC> 1 <NL>              while <SPC> j <SPC> < <SPC> k : <NL>                  current <SPC> = <SPC> sort_nums [ j ] <SPC> + <SPC> sort_nums [ k ] <NL>                  if <SPC> current <SPC> == <SPC> key : <NL>                      result <SPC> = <SPC> ( <NL>                          sort_nums [ pair [ 0 ] ] , <NL>                          sort_nums [ pair [ 1 ] ] , <NL>                          sort_nums [ j ] , <NL>                          sort_nums [ k ] , <NL>                      ) <NL>                      res [ result ] <SPC> = <SPC> True <NL>                      j <SPC> += <SPC> 1 <NL>                  elif <SPC> current <SPC> < <SPC> key : <NL>                      j <SPC> += <SPC> 1 <NL>                  else : <NL>                      k <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> res . keys ( ) <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . fourSum ( [ 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 ] , <SPC> 0 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> removeNthFromEnd ( self , <SPC> head , <SPC> n ) : <NL> <NL> <TAB> if <SPC> head <SPC> is <SPC> None : <NL>          return <SPC> None <NL> <TAB> slow <SPC> = <SPC> fast <SPC> = <SPC> head <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( n ) : <NL>          fast <SPC> = <SPC> fast . next <NL> <TAB> if <SPC> fast <SPC> is <SPC> None : <NL>          head <SPC> = <SPC> head . next <NL>          return <SPC> head <NL> <TAB> while <SPC> fast . next <SPC> is <SPC> not <SPC> None : <NL>          fast <SPC> = <SPC> fast . next <NL>          slow <SPC> = <SPC> slow . next <NL> <TAB> curr <SPC> = <SPC> slow . next <NL> <TAB> slow . next <SPC> = <SPC> curr . next <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> isValid ( self , <SPC> s ) : <NL> <NL> <TAB> if <SPC> s <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> t <SPC> in <SPC> s : <NL>          if <SPC> t <SPC> == <SPC> ")" : <NL>              try : <NL>                  current <SPC> = <SPC> stack . pop ( ) <NL>                  if <SPC> current <SPC> != <SPC> "(" : <NL>                      return <SPC> False <NL>              except : <NL>                  return <SPC> False <NL>          elif <SPC> t <SPC> == <SPC> "}" : <NL>              try : <NL>                  current <SPC> = <SPC> stack . pop ( ) <NL>                  if <SPC> current <SPC> != <SPC> "{" : <NL>                      return <SPC> False <NL>              except : <NL>                  return <SPC> False <NL>          elif <SPC> t <SPC> == <SPC> "]" : <NL>              try : <NL>                  current <SPC> = <SPC> stack . pop ( ) <NL>                  if <SPC> current <SPC> != <SPC> "[" : <NL>                      return <SPC> False <NL>              except : <NL>                  return <SPC> False <NL>          else : <NL>              stack . append ( t ) <NL> <TAB> if <SPC> len ( stack ) <SPC> == <SPC> 0 : <NL>          return <SPC> True <NL> <TAB> else : <NL>          return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mergeTwoLists ( self , <SPC> l1 , <SPC> l2 ) : <NL> <NL> <TAB> pos <SPC> = <SPC> dummyHead <SPC> = <SPC> ListNode ( - 1 ) <NL> <TAB> while <SPC> l1 <SPC> is <SPC> not <SPC> None <SPC> and <SPC> l2 <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> l1 . val <SPC> <= <SPC> l2 . val : <NL>              pos . next <SPC> = <SPC> l1 <NL>              l1 <SPC> = <SPC> l1 . next <NL>          else : <NL>              pos . next <SPC> = <SPC> l2 <NL>              l2 <SPC> = <SPC> l2 . next <NL>          pos <SPC> = <SPC> pos . next <NL> <NL> <TAB> if <SPC> l1 <SPC> is <SPC> not <SPC> None : <NL>          pos . next <SPC> = <SPC> l1 <NL> <NL> <TAB> if <SPC> l2 <SPC> is <SPC> not <SPC> None : <NL>          pos . next <SPC> = <SPC> l2 <NL> <TAB> return <SPC> dummyHead . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> generateParenthesis ( self , <SPC> n ) : <NL> <TAB> if <SPC> n <SPC> == <SPC> 1 : <NL>          return <SPC> [ "()" ] <NL> <TAB> last_list <SPC> = <SPC> self . generateParenthesis ( n <SPC> - <SPC> 1 ) <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> t <SPC> in <SPC> last_list : <NL>          curr <SPC> = <SPC> t <SPC> + <SPC> ")" <NL>          for <SPC> index <SPC> in <SPC> range ( len ( curr ) ) : <NL>              if <SPC> curr [ index ] <SPC> == <SPC> ")" : <NL>                  res . append ( curr [ : index ] <SPC> + <SPC> "(" <SPC> + <SPC> curr [ index : ] ) <NL> <TAB> return <SPC> list ( set ( res ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> mergeKLists ( self , <SPC> lists ) : <NL> <NL> <TAB> if <SPC> lists <SPC> is <SPC> None : <NL>          return <SPC> None <NL> <TAB> elif <SPC> len ( lists ) <SPC> == <SPC> 0 : <NL>          return <SPC> None <NL> <TAB> return <SPC> self . mergeK ( lists , <SPC> 0 , <SPC> len ( lists ) <SPC> - <SPC> 1 ) <NL> <NL> <TAB> def <SPC> mergeK ( self , <SPC> lists , <SPC> low , <SPC> high ) : <NL> <TAB> if <SPC> low <SPC> == <SPC> high : <NL>          return <SPC> lists [ low ] <NL> <TAB> elif <SPC> low <SPC> + <SPC> 1 <SPC> == <SPC> high : <NL>          return <SPC> self . mergeTwolists ( lists [ low ] , <SPC> lists [ high ] ) <NL> <TAB> mid <SPC> = <SPC> ( low <SPC> + <SPC> high ) <SPC> / <SPC> 2 <NL> <TAB> return <SPC> self . mergeTwolists ( <NL>          self . mergeK ( lists , <SPC> low , <SPC> mid ) , <SPC> self . mergeK ( lists , <SPC> mid <SPC> + <SPC> 1 , <SPC> high ) <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> mergeTwolists ( self , <SPC> l1 , <SPC> l2 ) : <NL> <TAB> if <SPC> l1 <SPC> is <SPC> None : <NL>          return <SPC> l2 <NL> <TAB> if <SPC> l2 <SPC> is <SPC> None : <NL>          return <SPC> l1 <NL> <TAB> head <SPC> = <SPC> curr <SPC> = <SPC> ListNode ( - 1 ) <NL> <TAB> while <SPC> l1 <SPC> is <SPC> not <SPC> None <SPC> and <SPC> l2 <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> l1 . val <SPC> <= <SPC> l2 . val : <NL>              curr . next <SPC> = <SPC> l1 <NL>              l1 <SPC> = <SPC> l1 . next <NL>          else : <NL>              curr . next <SPC> = <SPC> l2 <NL>              l2 <SPC> = <SPC> l2 . next <NL>          curr <SPC> = <SPC> curr . next <NL> <TAB> if <SPC> l1 <SPC> is <SPC> not <SPC> None : <NL>          curr . next <SPC> = <SPC> l1 <NL> <TAB> if <SPC> l2 <SPC> is <SPC> not <SPC> None : <NL>          curr . next <SPC> = <SPC> l2 <NL> <TAB> return <SPC> head . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> swapPairs ( self , <SPC> head ) : <NL> <TAB> dummyHead <SPC> = <SPC> ListNode ( - 1 ) <NL> <TAB> dummyHead . next <SPC> = <SPC> head <NL> <TAB> prev , <SPC> p <SPC> = <SPC> dummyHead , <SPC> head <NL> <TAB> while <SPC> p <SPC> != <SPC> None <SPC> and <SPC> p . next <SPC> != <SPC> None : <NL>          q , <SPC> r <SPC> = <SPC> p . next , <SPC> p . next . next <NL>          prev . next <SPC> = <SPC> q <NL>          q . next <SPC> = <SPC> p <NL>          p . next <SPC> = <SPC> r <NL>          prev <SPC> = <SPC> p <NL>          p <SPC> = <SPC> r <NL> <TAB> return <SPC> dummyHead . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseKGroup ( self , <SPC> head , <SPC> k ) : <NL> <TAB> if <SPC> head <SPC> is <SPC> None : <NL>          return <SPC> None <NL> <TAB> index <SPC> = <SPC> 0 <NL> <TAB> lead , <SPC> last <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> pos <SPC> = <SPC> head <NL> <TAB> temp <SPC> = <SPC> ListNode ( - 1 ) <NL> <TAB> temp . next <SPC> = <SPC> head <NL> <TAB> head <SPC> = <SPC> temp <NL> <TAB> start <SPC> = <SPC> head <NL> <TAB> while <SPC> pos <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> index <SPC> % <SPC> k <SPC> == <SPC> k <SPC> - <SPC> 1 : <NL>              last <SPC> = <SPC> pos . next <NL>              start <SPC> = <SPC> self . reverseList ( start , <SPC> last ) <NL>              pos <SPC> = <SPC> start <NL>          pos <SPC> = <SPC> pos . next <NL>          index <SPC> += <SPC> 1 <NL> <TAB> return <SPC> head . next <NL> <NL> <TAB> def <SPC> reverseList ( self , <SPC> head , <SPC> end ) : <NL> <TAB> pos <SPC> = <SPC> head . next <NL> <TAB> last <SPC> = <SPC> end <NL> <TAB> next_start <SPC> = <SPC> pos <NL> <TAB> while <SPC> pos <SPC> != <SPC> end : <NL>          head . next <SPC> = <SPC> pos <NL>          last_pos <SPC> = <SPC> pos <NL>          pos <SPC> = <SPC> pos . next <NL>          last_pos . next <SPC> = <SPC> last <NL>          last <SPC> = <SPC> last_pos <NL> <TAB> return <SPC> next_start <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> removeDuplicates ( self , <SPC> nums ) : <NL> <TAB> if <SPC> len ( nums ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> left <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> len ( nums ) ) : <NL>          if <SPC> nums [ left ] <SPC> == <SPC> nums [ i ] : <NL>              continue <NL>          else : <NL>              left <SPC> += <SPC> 1 <NL>              nums [ left ] <SPC> = <SPC> nums [ i ] <NL> <TAB> return <SPC> left <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> removeElement ( self , <SPC> nums , <SPC> val ) : <NL> <TAB> ls <SPC> = <SPC> len ( nums ) <NL> <TAB> if <SPC> ls <SPC> == <SPC> 0 : <NL>          return <SPC> ls <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> index <SPC> = <SPC> 0 <NL> <TAB> while <SPC> index <SPC> < <SPC> ls <SPC> - <SPC> count : <NL>          if <SPC> nums [ index ] <SPC> == <SPC> val : <NL>              nums [ index ] <SPC> = <SPC> nums [ ls <SPC> - <SPC> 1 <SPC> - <SPC> count ] <NL>              count <SPC> += <SPC> 1 <NL>          else : <NL>              index <SPC> += <SPC> 1 <NL> <TAB> return <SPC> ls <SPC> - <SPC> count <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . removeElement ( [ 1 ] , <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> strStr ( self , <SPC> haystack , <SPC> needle ) : <NL> <TAB> lsh , <SPC> lsn <SPC> = <SPC> len ( haystack ) , <SPC> len ( needle ) <NL> <TAB> if <SPC> lsn <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> next <SPC> = <SPC> self . makeNext ( needle ) <NL> <TAB> i <SPC> = <SPC> j <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> lsh : <NL>          if <SPC> j <SPC> == <SPC> - 1 <SPC> or <SPC> haystack [ i ] <SPC> == <SPC> needle [ j ] : <NL>              i <SPC> += <SPC> 1 <NL>              j <SPC> += <SPC> 1 <NL>              if <SPC> j <SPC> == <SPC> lsn : <NL>                  return <SPC> i <SPC> - <SPC> lsn <NL>          if <SPC> i <SPC> < <SPC> lsh <SPC> and <SPC> haystack [ i ] <SPC> != <SPC> needle [ j ] : <NL>              j <SPC> = <SPC> next [ j ] <NL> <TAB> return <SPC> - 1 <NL> <NL> <TAB> def <SPC> makeNext ( self , <SPC> needle ) : <NL> <TAB> ls <SPC> = <SPC> len ( needle ) <NL> <TAB> next <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ls <NL> <TAB> next [ 0 ] , <SPC> i , <SPC> j <SPC> = <SPC> - 1 , <SPC> 0 , <SPC> - 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> ls <SPC> - <SPC> 1 : <NL>          if <SPC> j <SPC> == <SPC> - 1 <SPC> or <SPC> needle [ i ] <SPC> == <SPC> needle [ j ] : <NL>              next [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> j <SPC> + <SPC> 1 <NL>              if <SPC> needle [ i <SPC> + <SPC> 1 ] <SPC> == <SPC> needle [ j <SPC> + <SPC> 1 ] : <NL>                  next [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> next [ j <SPC> + <SPC> 1 ] <NL>              i <SPC> += <SPC> 1 <NL>              j <SPC> += <SPC> 1 <NL>          if <SPC> needle [ i ] <SPC> != <SPC> needle [ j ] : <NL>              j <SPC> = <SPC> next [ j ] <NL> <TAB> return <SPC> next <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> divide ( self , <SPC> dividend , <SPC> divisor ) : <NL> <TAB> if <SPC> divisor <SPC> == <SPC> 0 : <NL>          return <SPC> MAX_INT <NL> <TAB> if <SPC> dividend <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> isPositive <SPC> = <SPC> ( dividend <SPC> < <SPC> 0 ) <SPC> == <SPC> ( divisor <SPC> < <SPC> 0 ) <NL> <TAB> m <SPC> = <SPC> abs ( dividend ) <NL> <TAB> n <SPC> = <SPC> abs ( divisor ) <NL> <NL> <TAB> res <SPC> = <SPC> math . log ( m ) <SPC> - <SPC> math . log ( n ) <NL> <TAB> res <SPC> = <SPC> int ( math . exp ( res ) ) <NL> <TAB> if <SPC> isPositive : <NL>          return <SPC> min ( res , <SPC> 2147483647 ) <NL> <TAB> return <SPC> max ( 0 <SPC> - <SPC> res , <SPC> - 2147483648 ) <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . divide ( 1 , <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findSubstring ( self , <SPC> s , <SPC> words ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( s ) <NL> <TAB> word_ls <SPC> = <SPC> len ( words [ 0 ] ) <NL> <TAB> target_dict <SPC> = <SPC> { } <NL> <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          try : <NL>              target_dict [ word ] <SPC> += <SPC> 1 <NL>          except <SPC> KeyError : <NL>              target_dict [ word ] <SPC> = <SPC> 1 <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> start <SPC> in <SPC> range ( ls <SPC> - <SPC> word_ls <SPC> * <SPC> len ( words ) <SPC> + <SPC> 1 ) : <NL>          curr_dict <SPC> = <SPC> target_dict . copy ( ) <NL>          for <SPC> pos <SPC> in <SPC> range ( start , <SPC> start <SPC> + <SPC> word_ls <SPC> * <SPC> len ( words ) , <SPC> word_ls ) : <NL>              curr <SPC> = <SPC> s [ pos : <SPC> pos <SPC> + <SPC> word_ls ] <NL>              try : <NL>                  curr_dict [ curr ] <SPC> -= <SPC> 1 <NL> <NL>                  if <SPC> curr_dict [ curr ] <SPC> < <SPC> 0 : <NL>                      break <NL>              except <SPC> KeyError : <NL> <NL>                  break <NL>          else : <NL> <NL>              res . append ( start ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <NL> <TAB> print <SPC> s . findSubstring ( "wordgoodgoodgoodbestword" , <SPC> [ "word" , <SPC> "good" , <SPC> "best" , <SPC> "good" ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nextPermutation ( self , <SPC> nums ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( nums ) <NL> <TAB> if <SPC> ls <SPC> <= <SPC> 1 : <NL>          return <NL> <TAB> pair <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls ) : <NL>          for <SPC> j <SPC> in <SPC> range ( i <SPC> + <SPC> 1 , <SPC> ls ) : <NL> <NL>              if <SPC> nums [ i ] <SPC> < <SPC> nums [ j ] : <NL>                  pair . append ( [ i , <SPC> j ] ) <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <TAB> if <SPC> len ( pair ) <SPC> > <SPC> 0 : <NL>          self . swap ( nums , <SPC> pair [ - 1 ] [ 0 ] , <SPC> pair [ - 1 ] [ 1 ] ) <NL>          pos <SPC> = <SPC> pair [ - 1 ] [ 0 ] <SPC> + <SPC> 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( pos , <SPC> ls ) : <NL>          for <SPC> j <SPC> in <SPC> range ( i <SPC> + <SPC> 1 , <SPC> ls ) : <NL>              if <SPC> nums [ i ] <SPC> > <SPC> nums [ j ] : <NL>                  self . swap ( nums , <SPC> i , <SPC> j ) <NL> <NL> <TAB> def <SPC> swap ( self , <SPC> nums , <SPC> index1 , <SPC> index2 ) : <NL> <TAB> if <SPC> index1 <SPC> == <SPC> index2 : <NL>          return <NL> <TAB> nums [ index1 ] , <SPC> nums [ index2 ] <SPC> = <SPC> nums [ index2 ] , <SPC> nums [ index1 ] <NL> <NL> <NL> import <SPC> pdb <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> longestValidParentheses ( self , <SPC> s ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( s ) <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> data <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ls <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls ) : <NL>          curr <SPC> = <SPC> s [ i ] <NL>          if <SPC> curr <SPC> == <SPC> "(" : <NL>              stack . append ( i ) <NL>          else : <NL>              if <SPC> len ( stack ) <SPC> > <SPC> 0 : <NL>                  data [ i ] <SPC> = <SPC> 1 <NL>                  data [ stack . pop ( - 1 ) ] <SPC> = <SPC> 1 <NL> <TAB> tep , <SPC> res <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> t <SPC> in <SPC> data : <NL>          if <SPC> t <SPC> == <SPC> 1 : <NL>              tep <SPC> += <SPC> 1 <NL>          else : <NL>              res <SPC> = <SPC> max ( tep , <SPC> res ) <NL>              tep <SPC> = <SPC> 0 <NL> <TAB> return <SPC> max ( tep , <SPC> res ) <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <NL> <TAB> print <SPC> s . longestValidParentheses ( ")()())" ) <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> search ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> def <SPC> get ( start , <SPC> end ) : <NL>          if <SPC> start <SPC> > <SPC> end : <NL>              return <SPC> - 1 <NL>          mid <SPC> = <SPC> ( start <SPC> + <SPC> end ) <SPC> / <SPC> 2 <NL>          if <SPC> nums [ mid ] <SPC> == <SPC> target : <NL>              return <SPC> mid <NL>          elif <SPC> nums [ mid ] <SPC> >= <SPC> nums [ start ] : <NL>              if <SPC> target <SPC> >= <SPC> nums [ start ] <SPC> and <SPC> target <SPC> < <SPC> nums [ mid ] : <NL>                  return <SPC> get ( start , <SPC> mid <SPC> - <SPC> 1 ) <NL>              else : <NL>                  return <SPC> get ( mid <SPC> + <SPC> 1 , <SPC> end ) <NL>          elif <SPC> nums [ mid ] <SPC> <= <SPC> nums [ end ] : <NL>              if <SPC> target <SPC> > <SPC> nums [ mid ] <SPC> and <SPC> target <SPC> <= <SPC> nums [ end ] : <NL>                  return <SPC> get ( mid <SPC> + <SPC> 1 , <SPC> end ) <NL>              else : <NL>                  return <SPC> get ( start , <SPC> mid <SPC> - <SPC> 1 ) <NL> <NL> <TAB> return <SPC> get ( 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> searchRange ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> length <SPC> = <SPC> len ( nums ) <NL> <TAB> if <SPC> length <SPC> == <SPC> 0 : <NL>          return <SPC> [ - 1 , <SPC> - 1 ] <NL> <TAB> min <SPC> = <SPC> 0 <NL> <TAB> max <SPC> = <SPC> length <SPC> - <SPC> 1 <NL> <TAB> while <SPC> min <SPC> <= <SPC> max : <NL>          pos <SPC> = <SPC> ( min <SPC> + <SPC> max ) <SPC> / <SPC> 2 <NL>          if <SPC> nums [ pos ] <SPC> > <SPC> target : <NL>              max <SPC> = <SPC> pos <SPC> - <SPC> 1 <NL>          elif <SPC> nums [ pos ] <SPC> < <SPC> target : <NL>              min <SPC> = <SPC> pos <SPC> + <SPC> 1 <NL>          else : <NL> <NL>              for <SPC> i <SPC> in <SPC> range ( min , <SPC> max <SPC> + <SPC> 1 ) : <NL>                  if <SPC> nums [ i ] <SPC> == <SPC> target : <NL>                      if <SPC> min <SPC> < <SPC> i <SPC> and <SPC> nums [ min ] <SPC> != <SPC> nums [ i ] : <NL>                          min <SPC> = <SPC> i <NL>                      max <SPC> = <SPC> i <NL>              return <SPC> [ min , <SPC> max ] <NL> <TAB> return <SPC> [ - 1 , <SPC> - 1 ] <NL> <NL> <NL> class <SPC> Solution : <NL> <NL> <TAB> def <SPC> searchInsert ( self , <SPC> nums , <SPC> target ) : <NL> <TAB> l , <SPC> r <SPC> = <SPC> int ( 0 ) , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> l <SPC> < <SPC> r : <NL>          mid <SPC> = <SPC> int ( ( l <SPC> + <SPC> r ) <SPC> / <SPC> 2 ) <NL>          if <SPC> nums [ mid ] <SPC> < <SPC> target : <NL>              l <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          else : <NL>              r <SPC> = <SPC> mid <NL> <TAB> if <SPC> nums [ l ] <SPC> < <SPC> target : <NL>          return <SPC> l <SPC> + <SPC> 1 <NL> <TAB> return <SPC> l <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print ( s . searchInsert ( [ 1 , <SPC> 3 , <SPC> 5 , <SPC> 6 ] , <SPC> 5 ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isValidSudoku ( self , <SPC> board ) : <NL> <TAB> vset <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 9 <NL> <TAB> hset <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 9 <NL> <TAB> bset <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 9 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 9 ) : <NL>          for <SPC> j <SPC> in <SPC> range ( 9 ) : <NL>              curr <SPC> = <SPC> board [ i ] [ j ] <NL>              if <SPC> curr <SPC> != <SPC> "." : <NL>                  index <SPC> = <SPC> 1 <SPC> << <SPC> ( ord ( curr ) <SPC> - <SPC> ord ( "0" ) ) <NL>                  if <SPC> ( <NL>                      ( hset [ i ] <SPC> & <SPC> index ) <SPC> > <SPC> 0 <NL>                      or <SPC> ( vset [ j ] <SPC> & <SPC> index ) <SPC> > <SPC> 0 <NL>                      or <SPC> ( bset [ ( i <SPC> / <SPC> 3 ) <SPC> * <SPC> 3 <SPC> + <SPC> j <SPC> / <SPC> 3 ] <SPC> & <SPC> index ) <SPC> > <SPC> 0 <NL>                  ) : <NL>                      return <SPC> False <NL>                  hset [ i ] <SPC> |= <SPC> index <NL>                  vset [ j ] <SPC> |= <SPC> index <NL>                  bset [ ( i <SPC> / <SPC> 3 ) <SPC> * <SPC> 3 <SPC> + <SPC> j <SPC> / <SPC> 3 ] <SPC> |= <SPC> index <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> solveSudoku ( self , <SPC> board ) : <NL> <NL> <TAB> empty <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 9 ) : <NL>          for <SPC> j <SPC> in <SPC> range ( 9 ) : <NL>              if <SPC> board [ i ] [ j ] <SPC> == <SPC> "." : <NL>                  empty . append ( 9 <SPC> * <SPC> i <SPC> + <SPC> j ) <NL> <TAB> self . solve ( board , <SPC> empty ) <NL> <NL> <TAB> def <SPC> solve ( self , <SPC> board , <SPC> empty ) : <NL> <TAB> if <SPC> len ( empty ) <SPC> == <SPC> 0 : <NL>          return <SPC> True <NL> <TAB> first_value <SPC> = <SPC> empty [ - 1 ] <NL> <TAB> row , <SPC> col <SPC> = <SPC> first_value <SPC> / <SPC> 9 , <SPC> first_value <SPC> % <SPC> 9 <NL> <TAB> for <SPC> k <SPC> in <SPC> range ( 1 , <SPC> 10 ) : <NL>          if <SPC> self . is_safe ( board , <SPC> row , <SPC> col , <SPC> str ( k ) ) : <NL>              board [ row ] [ col ] <SPC> = <SPC> str ( k ) <NL>              empty . pop ( ) <NL>              if <SPC> self . solve ( board , <SPC> empty ) : <NL>                  return <SPC> True <NL>              board [ row ] [ col ] <SPC> = <SPC> "." <NL>              empty . append ( first_value ) <NL> <TAB> return <SPC> False <NL> <NL> <TAB> def <SPC> is_safe ( self , <SPC> board , <SPC> row , <SPC> col , <SPC> ch ) : <NL> <TAB> for <SPC> k <SPC> in <SPC> range ( 9 ) : <NL>          if <SPC> board [ k ] [ col ] <SPC> == <SPC> ch : <NL>              return <SPC> False <NL>          if <SPC> board [ row ] [ k ] <SPC> == <SPC> ch : <NL>              return <SPC> False <NL> <TAB> start_row , <SPC> start_col <SPC> = <SPC> 3 <SPC> * <SPC> ( row <SPC> / <SPC> 3 ) , <SPC> 3 <SPC> * <SPC> ( col <SPC> / <SPC> 3 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( start_row , <SPC> start_row <SPC> + <SPC> 3 ) : <NL>          for <SPC> j <SPC> in <SPC> range ( start_col , <SPC> start_col <SPC> + <SPC> 3 ) : <NL>              if <SPC> board [ i ] [ j ] <SPC> == <SPC> ch : <NL>                  return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> countAndSay ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 1 : <NL>          return <SPC> "1" <NL> <TAB> x <SPC> = <SPC> "1" <NL> <TAB> while <SPC> n <SPC> > <SPC> 1 : <NL> <NL>          x <SPC> = <SPC> self . count ( x ) <NL>          n <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> x <NL> <NL> <TAB> def <SPC> count ( self , <SPC> x ) : <NL> <TAB> m <SPC> = <SPC> list ( x ) <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> m . append ( None ) <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( m ) <SPC> - <SPC> 1 : <NL>          j <SPC> += <SPC> 1 <NL>          if <SPC> m [ j ] <SPC> != <SPC> m [ i ] : <NL> <NL>              res <SPC> += <SPC> [ j <SPC> - <SPC> i , <SPC> m [ i ] ] <NL>              i <SPC> = <SPC> j <NL> <TAB> return <SPC> "" . join ( str ( s ) <SPC> for <SPC> s <SPC> in <SPC> res ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> combinationSum ( self , <SPC> candidates , <SPC> target ) : <NL> <TAB> candidates . sort ( ) <NL> <TAB> dp <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> range ( target <SPC> + <SPC> 1 ) ] <NL> <TAB> dp [ 0 ] . append ( [ ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> target <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> range ( len ( candidates ) ) : <NL>              if <SPC> candidates [ j ] <SPC> > <SPC> i : <NL>                  break <NL>              for <SPC> k <SPC> in <SPC> range ( len ( dp [ i <SPC> - <SPC> candidates [ j ] ] ) ) : <NL>                  temp <SPC> = <SPC> dp [ i <SPC> - <SPC> candidates [ j ] ] [ k ] [ : ] <NL>                  if <SPC> len ( temp ) <SPC> > <SPC> 0 <SPC> and <SPC> temp [ - 1 ] <SPC> > <SPC> candidates [ j ] : <NL>                      continue <NL>                  temp . append ( candidates [ j ] ) <NL>                  dp [ i ] . append ( temp ) <NL> <TAB> return <SPC> dp [ target ] <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . combinationSum ( [ 8 , <SPC> 7 , <SPC> 4 , <SPC> 3 ] , <SPC> 11 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> combinationSum2 ( self , <SPC> candidates , <SPC> target ) : <NL> <NL> <TAB> candidates . sort ( ) <NL> <TAB> dp <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> range ( target <SPC> + <SPC> 1 ) ] <NL> <TAB> dp [ 0 ] . append ( [ ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> target <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> range ( len ( candidates ) ) : <NL>              if <SPC> candidates [ j ] <SPC> > <SPC> i : <NL>                  break <NL>              for <SPC> k <SPC> in <SPC> range ( len ( dp [ i <SPC> - <SPC> candidates [ j ] ] ) ) : <NL>                  temp <SPC> = <SPC> dp [ i <SPC> - <SPC> candidates [ j ] ] [ k ] [ : ] <NL> <NL>                  if <SPC> len ( temp ) <SPC> > <SPC> 0 <SPC> and <SPC> temp [ - 1 ] <SPC> >= <SPC> j : <NL>                      continue <NL> <NL>                  temp . append ( j ) <NL>                  dp [ i ] . append ( temp ) <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> check <SPC> = <SPC> { } <NL> <TAB> for <SPC> temp <SPC> in <SPC> dp [ target ] : <NL>          value <SPC> = <SPC> [ candidates [ t ] <SPC> for <SPC> t <SPC> in <SPC> temp ] <NL>          try : <NL>              check [ str ( value ) ] <SPC> += <SPC> 1 <NL>          except <SPC> KeyError : <NL>              check [ str ( value ) ] <SPC> = <SPC> 1 <NL>              res . append ( value ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> firstMissingPositive ( self , <SPC> nums ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( nums ) <NL> <TAB> index <SPC> = <SPC> 0 <NL> <TAB> while <SPC> index <SPC> < <SPC> ls : <NL> <NL>          if <SPC> ( <NL>              nums [ index ] <SPC> <= <SPC> 0 <NL>              or <SPC> nums [ index ] <SPC> > <SPC> ls <NL>              or <SPC> nums [ nums [ index ] <SPC> - <SPC> 1 ] <SPC> == <SPC> nums [ index ] <NL>          ) : <NL>              index <SPC> += <SPC> 1 <NL>          else : <NL> <NL>              pos <SPC> = <SPC> nums [ index ] <SPC> - <SPC> 1 <NL>              nums [ index ] , <SPC> nums [ pos ] <SPC> = <SPC> nums [ pos ] , <SPC> nums [ index ] <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> while <SPC> res <SPC> < <SPC> ls <SPC> and <SPC> nums [ res ] <SPC> == <SPC> res <SPC> + <SPC> 1 : <NL>          res <SPC> += <SPC> 1 <NL> <TAB> return <SPC> res <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> trap ( self , <SPC> height ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( height ) <NL> <TAB> if <SPC> ls <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> res , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> left <SPC> < <SPC> ls <SPC> and <SPC> height [ left ] <SPC> == <SPC> 0 : <NL>          left <SPC> += <SPC> 1 <NL> <TAB> pos <SPC> = <SPC> left <SPC> + <SPC> 1 <NL> <TAB> while <SPC> pos <SPC> < <SPC> ls : <NL>          if <SPC> height [ pos ] <SPC> >= <SPC> height [ left ] : <NL> <NL>              res <SPC> += <SPC> self . rain_water ( height , <SPC> left , <SPC> pos ) <NL>              left <SPC> = <SPC> pos <NL>              pos <SPC> += <SPC> 1 <NL>          elif <SPC> pos <SPC> == <SPC> ls <SPC> - <SPC> 1 : <NL> <NL>              max_value , <SPC> max_index <SPC> = <SPC> 0 , <SPC> pos <NL>              for <SPC> index <SPC> in <SPC> range ( left <SPC> + <SPC> 1 , <SPC> ls ) : <NL>                  if <SPC> height [ index ] <SPC> > <SPC> max_value : <NL>                      max_value <SPC> = <SPC> height [ index ] <NL>                      max_index <SPC> = <SPC> index <NL>              res <SPC> += <SPC> self . rain_water ( height , <SPC> left , <SPC> max_index ) <NL>              left <SPC> = <SPC> max_index <NL>              pos <SPC> = <SPC> left <SPC> + <SPC> 1 <NL>          else : <NL>              pos <SPC> += <SPC> 1 <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> rain_water ( self , <SPC> height , <SPC> start , <SPC> end ) : <NL> <NL> <TAB> if <SPC> end <SPC> - <SPC> start <SPC> <= <SPC> 1 : <NL>          return <SPC> 0 <NL> <TAB> min_m <SPC> = <SPC> min ( height [ start ] , <SPC> height [ end ] ) <NL> <TAB> res <SPC> = <SPC> min_m <SPC> * <SPC> ( end <SPC> - <SPC> start <SPC> - <SPC> 1 ) <NL> <TAB> step <SPC> = <SPC> 0 <NL> <TAB> for <SPC> index <SPC> in <SPC> range ( start <SPC> + <SPC> 1 , <SPC> end ) : <NL>          if <SPC> height [ index ] <SPC> > <SPC> 0 : <NL>              step <SPC> += <SPC> height [ index ] <NL> <TAB> return <SPC> res <SPC> - <SPC> step <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . trap ( [ 2 , <SPC> 6 , <SPC> 3 , <SPC> 8 , <SPC> 2 , <SPC> 7 , <SPC> 2 , <SPC> 5 , <SPC> 0 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> multiply ( self , <SPC> num1 , <SPC> num2 ) : <NL> <TAB> if <SPC> num1 <SPC> == <SPC> "0" <SPC> or <SPC> num2 <SPC> == <SPC> "0" : <NL>          return <SPC> "0" <NL> <TAB> res <SPC> = <SPC> "" <NL> <TAB> ls1 , <SPC> ls2 , <SPC> = <SPC> ( <NL>          len ( num1 ) , <NL>          len ( num2 ) , <NL> <TAB> ) <NL> <TAB> ls <SPC> = <SPC> ls1 <SPC> + <SPC> ls2 <NL> <NL> <TAB> arr <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ls <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( range ( ls1 ) ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( range ( ls2 ) ) : <NL> <NL>              arr [ i <SPC> + <SPC> j <SPC> + <SPC> 1 ] <SPC> += <SPC> int ( num1 [ i ] ) <SPC> * <SPC> int ( num2 [ j ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( range ( 1 , <SPC> ls ) ) : <NL> <NL>          arr [ i <SPC> - <SPC> 1 ] <SPC> += <SPC> arr [ i ] <SPC> / <SPC> 10 <NL>          arr [ i ] <SPC> %= <SPC> 10 <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <NL> <TAB> if <SPC> arr [ pos ] <SPC> == <SPC> 0 : <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> while <SPC> pos <SPC> < <SPC> ls : <NL>          res <SPC> = <SPC> res <SPC> + <SPC> str ( arr [ pos ] ) <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> return <SPC> res <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . multiply ( "98" , <SPC> "9" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isMatch ( self , <SPC> s , <SPC> p ) : <NL> <NL> <TAB> s_index , <SPC> p_index <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> star , <SPC> s_star <SPC> = <SPC> - 1 , <SPC> 0 <NL> <TAB> s_len , <SPC> p_len <SPC> = <SPC> len ( s ) , <SPC> len ( p ) <NL> <TAB> while <SPC> s_index <SPC> < <SPC> s_len : <NL>          if <SPC> p_index <SPC> < <SPC> p_len <SPC> and <SPC> ( s [ s_index ] <SPC> == <SPC> p [ p_index ] <SPC> or <SPC> p [ p_index ] <SPC> == <SPC> "?" ) : <NL>              s_index <SPC> += <SPC> 1 <NL>              p_index <SPC> += <SPC> 1 <NL>          elif <SPC> p_index <SPC> < <SPC> p_len <SPC> and <SPC> p [ p_index ] <SPC> == <SPC> "*" : <NL>              star <SPC> = <SPC> p_index <NL>              s_star <SPC> = <SPC> s_index <NL>              p_index <SPC> += <SPC> 1 <NL>          elif <SPC> star <SPC> != <SPC> - 1 : <NL>              p_index <SPC> = <SPC> star <SPC> + <SPC> 1 <NL>              s_star <SPC> += <SPC> 1 <NL>              s_index <SPC> = <SPC> s_star <NL>          else : <NL>              return <SPC> False <NL> <TAB> while <SPC> p_index <SPC> < <SPC> p_len <SPC> and <SPC> p [ p_index ] <SPC> == <SPC> "*" : <NL>          p_index <SPC> += <SPC> 1 <NL> <TAB> return <SPC> p_index <SPC> == <SPC> p_len <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . isMatch ( <NL>          "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>          "*aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa*" , <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> jump ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> len ( nums ) <SPC> <= <SPC> 1 : <NL>          return <SPC> 0 <NL> <TAB> end <SPC> = <SPC> 0 <SPC> + <SPC> nums [ 0 ] <NL> <TAB> start <SPC> = <SPC> 0 <NL> <TAB> step <SPC> = <SPC> 1 <NL> <TAB> maxDis <SPC> = <SPC> 0 <SPC> + <SPC> nums [ 0 ] <NL> <TAB> while <SPC> end <SPC> < <SPC> len ( nums ) <SPC> - <SPC> 1 : <NL>          for <SPC> i <SPC> in <SPC> range ( start <SPC> + <SPC> 1 , <SPC> end <SPC> + <SPC> 1 ) : <NL> <NL>              maxDis <SPC> = <SPC> max ( maxDis , <SPC> nums [ i ] <SPC> + <SPC> i ) <NL>          start <SPC> = <SPC> end <NL>          end <SPC> = <SPC> maxDis <NL>          step <SPC> += <SPC> 1 <NL> <TAB> return <SPC> step <NL> <NL> <NL> class <SPC> Solution : <NL> <NL> <TAB> def <SPC> permute ( self , <SPC> nums ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> len ( nums ) <SPC> == <SPC> 0 : <NL>          return <SPC> res <NL> <TAB> self . get_permute ( res , <SPC> nums , <SPC> 0 ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> get_permute ( self , <SPC> res , <SPC> nums , <SPC> index ) : <NL> <TAB> if <SPC> index <SPC> == <SPC> len ( nums ) : <NL>          res . append ( list ( nums ) ) <NL>          return <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( index , <SPC> len ( nums ) ) : <NL>          nums [ i ] , <SPC> nums [ index ] <SPC> = <SPC> nums [ index ] , <SPC> nums [ i ] <NL> <NL>          self . get_permute ( res , <SPC> nums , <SPC> index <SPC> + <SPC> 1 ) <NL>          nums [ i ] , <SPC> nums [ index ] <SPC> = <SPC> nums [ index ] , <SPC> nums [ i ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> permuteUnique ( self , <SPC> num ) : <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> len ( num ) <SPC> == <SPC> 0 : <NL>          return <SPC> res <NL> <TAB> self . permute ( res , <SPC> num , <SPC> 0 ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> permute ( self , <SPC> res , <SPC> num , <SPC> index ) : <NL> <TAB> if <SPC> index <SPC> == <SPC> len ( num ) : <NL>          res . append ( list ( num ) ) <NL>          return <NL> <TAB> appeared <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( index , <SPC> len ( num ) ) : <NL>          if <SPC> num [ i ] <SPC> in <SPC> appeared : <NL>              continue <NL>          appeared . add ( num [ i ] ) <NL>          num [ i ] , <SPC> num [ index ] <SPC> = <SPC> num [ index ] , <SPC> num [ i ] <NL>          self . permute ( res , <SPC> num , <SPC> index <SPC> + <SPC> 1 ) <NL>          num [ i ] , <SPC> num [ index ] <SPC> = <SPC> num [ index ] , <SPC> num [ i ] <NL> <NL> <TAB> def <SPC> permuteUnique ( self , <SPC> num ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ [ ] ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( nums ) ) : <NL>          cache <SPC> = <SPC> set ( ) <NL>          while <SPC> len ( res [ 0 ] ) <SPC> == <SPC> i : <NL>              curr <SPC> = <SPC> res . pop ( 0 ) <NL>              for <SPC> j <SPC> in <SPC> range ( len ( curr ) <SPC> + <SPC> 1 ) : <NL> <NL>                  new_perm <SPC> = <SPC> curr [ : j ] <SPC> + <SPC> [ nums [ i ] ] <SPC> + <SPC> curr [ j : ] <NL>                  stemp <SPC> = <SPC> "" . join ( map ( str , <SPC> new_perm ) ) <NL>                  if <SPC> stemp <SPC> not <SPC> in <SPC> cache : <NL>                      cache . add ( stemp ) <NL>                      res . append ( new_perm ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rotate ( self , <SPC> matrix ) : <NL> <NL> <TAB> if <SPC> matrix <SPC> is <SPC> None <SPC> or <SPC> len ( matrix ) <SPC> == <SPC> 1 : <NL>          return <NL> <TAB> ls <SPC> = <SPC> len ( matrix ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls <SPC> / <SPC> 2 ) : <NL> <NL>          begin , <SPC> end <SPC> = <SPC> i , <SPC> ls <SPC> - <SPC> 1 <SPC> - <SPC> i <NL>          for <SPC> k <SPC> in <SPC> range ( ls <SPC> - <SPC> 2 <SPC> * <SPC> i <SPC> - <SPC> 1 ) : <NL>              temp <SPC> = <SPC> matrix [ end <SPC> - <SPC> k ] [ begin ] <NL>              matrix [ end <SPC> - <SPC> k ] [ begin ] <SPC> = <SPC> matrix [ end ] [ end <SPC> - <SPC> k ] <NL>              matrix [ end ] [ end <SPC> - <SPC> k ] <SPC> = <SPC> matrix [ begin <SPC> + <SPC> k ] [ end ] <NL>              matrix [ begin <SPC> + <SPC> k ] [ end ] <SPC> = <SPC> matrix [ begin ] [ begin <SPC> + <SPC> k ] <NL>              matrix [ begin ] [ begin <SPC> + <SPC> k ] <SPC> = <SPC> temp <NL> <TAB> return <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> s . rotate ( [ [ 1 , <SPC> 2 , <SPC> 3 , <SPC> 4 ] , <SPC> [ 5 , <SPC> 6 , <SPC> 7 , <SPC> 8 ] , <SPC> [ 9 , <SPC> 10 , <SPC> 11 , <SPC> 12 ] , <SPC> [ 13 , <SPC> 14 , <SPC> 15 , <SPC> 16 ] ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> groupAnagrams ( self , <SPC> strs ) : <NL> <TAB> strs . sort ( ) <NL> <TAB> hash <SPC> = <SPC> { } <NL> <TAB> for <SPC> s <SPC> in <SPC> strs : <NL>          key <SPC> = <SPC> self . hash_key ( s ) <NL>          try : <NL>              hash [ key ] . append ( s ) <NL>          except <SPC> KeyError : <NL>              hash [ key ] <SPC> = <SPC> [ s ] <NL> <TAB> return <SPC> hash . values ( ) <NL> <NL> <TAB> def <SPC> hash_key ( self , <SPC> s ) : <NL> <NL> <TAB> table <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> ch <SPC> in <SPC> s : <NL>          index <SPC> = <SPC> ord ( ch ) <SPC> - <SPC> ord ( "a" ) <NL>          table [ index ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> str ( table ) <NL> <NL> <NL> class <SPC> Solution : <NL> <NL> <TAB> def <SPC> myPow ( self , <SPC> x , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 : <NL>          return <SPC> 1 <NL> <TAB> res , <SPC> curr <SPC> = <SPC> 1 , <SPC> abs ( n ) <NL> <TAB> while <SPC> curr <SPC> > <SPC> 0 : <NL>          if <SPC> curr <SPC> & <SPC> 1 <SPC> == <SPC> 1 : <NL>              res <SPC> *= <SPC> x <NL>          curr <SPC> >>= <SPC> 1 <NL>          x <SPC> *= <SPC> x <NL> <TAB> if <SPC> n <SPC> < <SPC> 0 : <NL>          return <SPC> 1 <SPC> / <SPC> res <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> solveNQueens ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> board <SPC> = <SPC> [ [ "." ] <SPC> * <SPC> n <SPC> for <SPC> t <SPC> in <SPC> range ( n ) ] <NL> <TAB> self . do_solveNQueens ( res , <SPC> board , <SPC> n ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> do_solveNQueens ( self , <SPC> res , <SPC> board , <SPC> num ) : <NL> <TAB> if <SPC> num <SPC> == <SPC> 0 : <NL>          res . append ( [ "" . join ( t ) <SPC> for <SPC> t <SPC> in <SPC> board ] ) <NL>          return <NL> <TAB> ls <SPC> = <SPC> len ( board ) <NL> <TAB> pos <SPC> = <SPC> ls <SPC> - <SPC> num <NL> <TAB> check <SPC> = <SPC> [ True ] <SPC> * <SPC> ls <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( pos ) : <NL>          for <SPC> j <SPC> in <SPC> range ( ls ) : <NL>              if <SPC> board [ i ] [ j ] <SPC> == <SPC> "Q" : <NL>                  check [ j ] <SPC> = <SPC> False <NL>                  step <SPC> = <SPC> pos <SPC> - <SPC> i <NL>                  if <SPC> j <SPC> + <SPC> step <SPC> < <SPC> ls : <NL>                      check [ j <SPC> + <SPC> step ] <SPC> = <SPC> False <NL>                  if <SPC> j <SPC> - <SPC> step <SPC> >= <SPC> 0 : <NL>                      check [ j <SPC> - <SPC> step ] <SPC> = <SPC> False <NL>                  break <NL> <TAB> for <SPC> j <SPC> in <SPC> range ( ls ) : <NL>          if <SPC> check [ j ] : <NL>              board [ pos ] [ j ] <SPC> = <SPC> "Q" <NL>              self . do_solveNQueens ( res , <SPC> board , <SPC> num <SPC> - <SPC> 1 ) <NL>              board [ pos ] [ j ] <SPC> = <SPC> "." <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . solveNQueens ( 4 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . count <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> totalNQueens ( self , <SPC> n ) : <NL> <TAB> self . dfs ( 0 , <SPC> n , <SPC> 0 , <SPC> 0 , <SPC> 0 ) <NL> <TAB> return <SPC> self . count <NL> <NL> <TAB> def <SPC> dfs ( self , <SPC> row , <SPC> n , <SPC> column , <SPC> diag , <SPC> antiDiag ) : <NL> <NL> <TAB> if <SPC> row <SPC> == <SPC> n : <NL>          self . count <SPC> += <SPC> 1 <NL>          return <NL> <TAB> for <SPC> index <SPC> in <SPC> range ( n ) : <NL> <NL>          isColSafe <SPC> = <SPC> ( 1 <SPC> << <SPC> index ) <SPC> & <SPC> column <SPC> == <SPC> 0 <NL> <NL>          isDigSafe <SPC> = <SPC> ( 1 <SPC> << <SPC> ( n <SPC> - <SPC> 1 <SPC> + <SPC> row <SPC> - <SPC> index ) ) <SPC> & <SPC> diag <SPC> == <SPC> 0 <NL> <NL>          isAntiDiagSafe <SPC> = <SPC> ( 1 <SPC> << <SPC> ( row <SPC> + <SPC> index ) ) <SPC> & <SPC> antiDiag <SPC> == <SPC> 0 <NL>          if <SPC> isAntiDiagSafe <SPC> and <SPC> isColSafe <SPC> and <SPC> isDigSafe : <NL>              self . dfs ( <NL>                  row <SPC> + <SPC> 1 , <NL>                  n , <NL>                  ( 1 <SPC> << <SPC> index ) <SPC> | <SPC> column , <NL>                  ( 1 <SPC> << <SPC> ( n <SPC> - <SPC> 1 <SPC> + <SPC> row <SPC> - <SPC> index ) ) <SPC> | <SPC> diag , <NL>                  ( 1 <SPC> << <SPC> ( row <SPC> + <SPC> index ) ) <SPC> | <SPC> antiDiag , <NL>              ) <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . totalNQueens ( 4 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maxSubArray ( self , <SPC> nums ) : <NL> <TAB> maxEndingHere <SPC> = <SPC> maxSofFar <SPC> = <SPC> nums [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> len ( nums ) ) : <NL>          maxEndingHere <SPC> = <SPC> max ( maxEndingHere <SPC> + <SPC> nums [ i ] , <SPC> nums [ i ] ) <NL>          maxSofFar <SPC> = <SPC> max ( maxEndingHere , <SPC> maxSofFar ) <NL> <TAB> return <SPC> maxSofFar <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> spiralOrder ( self , <SPC> matrix ) : <NL> <NL> <TAB> if <SPC> matrix <SPC> is <SPC> None <SPC> or <SPC> len ( matrix ) <SPC> == <SPC> 0 : <NL>          return <SPC> matrix <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( matrix ) , <SPC> len ( matrix [ 0 ] ) <NL> <TAB> return <SPC> self . get_spiralOrder ( matrix , <SPC> 0 , <SPC> m <SPC> - <SPC> 1 , <SPC> 0 , <SPC> n <SPC> - <SPC> 1 ) <NL> <NL> <TAB> def <SPC> get_spiralOrder ( self , <SPC> matrix , <SPC> r_start , <SPC> r_end , <SPC> c_start , <SPC> c_end ) : <NL> <TAB> if <SPC> r_start <SPC> > <SPC> r_end <SPC> or <SPC> c_start <SPC> > <SPC> c_end : <NL>          return <SPC> [ ] <NL> <TAB> elif <SPC> r_start <SPC> == <SPC> r_end : <NL>          return <SPC> matrix [ r_start ] [ c_start : <SPC> c_end <SPC> + <SPC> 1 ] <NL> <TAB> elif <SPC> c_start <SPC> == <SPC> c_end : <NL>          return <SPC> [ matrix [ j ] [ c_end ] <SPC> for <SPC> j <SPC> in <SPC> range ( r_start , <SPC> r_end <SPC> + <SPC> 1 ) ] <NL> <TAB> curr <SPC> = <SPC> ( <NL>          matrix [ r_start ] [ c_start : <SPC> c_end <SPC> + <SPC> 1 ] <NL>          + <SPC> [ matrix [ j ] [ c_end ] <SPC> for <SPC> j <SPC> in <SPC> range ( r_start <SPC> + <SPC> 1 , <SPC> r_end ) ] <NL>          + <SPC> matrix [ r_end ] [ c_start : <SPC> c_end <SPC> + <SPC> 1 ] [ : : - 1 ] <NL>          + <SPC> [ matrix [ j ] [ c_start ] <SPC> for <SPC> j <SPC> in <SPC> reversed ( range ( r_start <SPC> + <SPC> 1 , <SPC> r_end ) ) ] <NL> <TAB> ) <NL> <TAB> res <SPC> = <SPC> curr <SPC> + <SPC> self . get_spiralOrder ( <NL>          matrix , <SPC> r_start <SPC> + <SPC> 1 , <SPC> r_end <SPC> - <SPC> 1 , <SPC> c_start <SPC> + <SPC> 1 , <SPC> c_end <SPC> - <SPC> 1 <NL> <TAB> ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . spiralOrder ( [ [ 1 , <SPC> 2 , <SPC> 3 , <SPC> 4 ] , <SPC> [ 5 , <SPC> 6 , <SPC> 7 , <SPC> 8 ] , <SPC> [ 9 , <SPC> 10 , <SPC> 11 , <SPC> 12 ] , <SPC> [ 13 , <SPC> 14 , <SPC> 15 , <SPC> 16 ] ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canJump ( self , <SPC> nums ) : <NL> <NL> <TAB> length <SPC> = <SPC> len ( nums ) <NL> <TAB> begin <SPC> = <SPC> length <SPC> - <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( range ( length <SPC> - <SPC> 1 ) ) : <NL>          if <SPC> i <SPC> + <SPC> nums [ i ] <SPC> >= <SPC> begin : <NL>              begin <SPC> = <SPC> i <NL> <TAB> return <SPC> not <SPC> begin <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> merge ( self , <SPC> intervals ) : <NL> <NL> <TAB> if <SPC> intervals <SPC> is <SPC> None : <NL>          return <NL> <TAB> ls <SPC> = <SPC> len ( intervals ) <NL> <TAB> if <SPC> ls <SPC> <= <SPC> 1 : <NL>          return <SPC> intervals <NL> <NL> <TAB> intervals . sort ( key = lambda <SPC> x : <SPC> x . start ) <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <TAB> while <SPC> pos <SPC> < <SPC> len ( intervals ) <SPC> - <SPC> 1 : <NL> <NL>          if <SPC> intervals [ pos ] . end <SPC> >= <SPC> intervals [ pos <SPC> + <SPC> 1 ] . start : <NL>              next <SPC> = <SPC> intervals . pop ( pos <SPC> + <SPC> 1 ) <NL> <NL>              if <SPC> next . end <SPC> > <SPC> intervals [ pos ] . end : <NL>                  intervals [ pos ] . end <SPC> = <SPC> next . end <NL> <NL>          else : <NL>              pos <SPC> += <SPC> 1 <NL> <TAB> return <SPC> intervals <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . merge ( [ [ 1 , <SPC> 3 ] , <SPC> [ 2 , <SPC> 6 ] , <SPC> [ 8 , <SPC> 10 ] , <SPC> [ 15 , <SPC> 18 ] ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> insert ( self , <SPC> intervals , <SPC> newInterval ) : <NL> <NL> <TAB> if <SPC> intervals <SPC> is <SPC> None <SPC> or <SPC> len ( intervals ) <SPC> == <SPC> 0 : <NL>          return <SPC> [ newInterval ] <NL> <TAB> intervals . sort ( key = lambda <SPC> x : <SPC> x . start ) <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <TAB> while <SPC> pos <SPC> < <SPC> len ( intervals ) : <NL> <NL>          if <SPC> newInterval . end <SPC> < <SPC> intervals [ pos ] . start : <NL>              intervals . insert ( pos , <SPC> newInterval ) <NL>              return <SPC> intervals <NL> <NL>          if <SPC> self . check_overlap ( intervals [ pos ] , <SPC> newInterval ) : <NL>              temp <SPC> = <SPC> intervals . pop ( pos ) <NL>              newInterval <SPC> = <SPC> self . merge_intervals ( temp , <SPC> newInterval ) <NL>          else : <NL>              pos <SPC> += <SPC> 1 <NL> <TAB> if <SPC> len ( intervals ) <SPC> == <SPC> 0 <SPC> or <SPC> pos <SPC> == <SPC> len ( intervals ) : <NL>          intervals . append ( newInterval ) <NL> <TAB> return <SPC> intervals <NL> <NL> <TAB> def <SPC> check_overlap ( self , <SPC> curr_int , <SPC> new_int ) : <NL> <TAB> if <SPC> curr_int . start <SPC> <= <SPC> new_int . start : <NL>          if <SPC> curr_int . end <SPC> > <SPC> new_int . start : <NL>              return <SPC> True <NL> <TAB> else : <NL>          if <SPC> curr_int . start <SPC> <= <SPC> new_int . end : <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <TAB> def <SPC> merge_intervals ( self , <SPC> int1 , <SPC> int2 ) : <NL> <TAB> temp_int <SPC> = <SPC> Interval ( ) <NL> <TAB> temp_int . start <SPC> = <SPC> min ( [ int1 . start , <SPC> int2 . start ] ) <NL> <TAB> temp_int . end <SPC> = <SPC> max ( [ int1 . end , <SPC> int2 . end ] ) <NL> <TAB> return <SPC> temp_int <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lengthOfLastWord ( self , <SPC> s ) : <NL> <NL> <TAB> if <SPC> len ( s ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> temp <SPC> = <SPC> s . split ( " " ) <NL> <TAB> temp <SPC> = <SPC> [ t <SPC> for <SPC> t <SPC> in <SPC> temp <SPC> if <SPC> len ( t ) <SPC> > <SPC> 0 ] <NL> <TAB> if <SPC> len ( temp ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> else : <NL>          return <SPC> len ( temp [ - 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> generateMatrix ( self , <SPC> n ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> range ( n ) ] <NL> <TAB> pos <SPC> = <SPC> [ 0 , <SPC> 0 ] <NL> <TAB> move <SPC> = <SPC> ( 0 , <SPC> 1 ) <NL> <TAB> for <SPC> index <SPC> in <SPC> range ( 1 , <SPC> n <SPC> * <SPC> n <SPC> + <SPC> 1 ) : <NL>          res [ pos [ 0 ] ] [ pos [ 1 ] ] <SPC> = <SPC> index <NL>          if <SPC> res [ ( pos [ 0 ] <SPC> + <SPC> move [ 0 ] ) <SPC> % <SPC> n ] [ ( pos [ 1 ] <SPC> + <SPC> move [ 1 ] ) <SPC> % <SPC> n ] <SPC> > <SPC> 0 : <NL> <NL>              move <SPC> = <SPC> ( move [ 1 ] , <SPC> - 1 <SPC> * <SPC> move [ 0 ] ) <NL>          pos [ 0 ] <SPC> = <SPC> pos [ 0 ] <SPC> + <SPC> move [ 0 ] <NL>          pos [ 1 ] <SPC> = <SPC> pos [ 1 ] <SPC> + <SPC> move [ 1 ] <NL> <TAB> return <SPC> res <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . generateMatrix ( 2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getPermutation ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> remain <SPC> = <SPC> range ( 1 , <SPC> n <SPC> + <SPC> 1 ) <NL> <TAB> if <SPC> k <SPC> <= <SPC> 1 : <NL>          return <SPC> "" . join ( str ( t ) <SPC> for <SPC> t <SPC> in <SPC> remain ) <NL> <TAB> total <SPC> = <SPC> 1 <NL> <TAB> for <SPC> num <SPC> in <SPC> remain [ : - 1 ] : <NL>          total <SPC> *= <SPC> num <NL> <TAB> res <SPC> = <SPC> self . do_getPermutation ( remain , <SPC> total , <SPC> n <SPC> - <SPC> 1 , <SPC> k <SPC> - <SPC> 1 ) <NL> <TAB> return <SPC> "" . join ( str ( t ) <SPC> for <SPC> t <SPC> in <SPC> res ) <NL> <NL> <TAB> def <SPC> do_getPermutation ( self , <SPC> remain , <SPC> curr , <SPC> n , <SPC> k ) : <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 <SPC> or <SPC> k <SPC> <= <SPC> 0 <SPC> or <SPC> curr <SPC> == <SPC> 0 : <NL>          return <SPC> remain <NL> <NL> <TAB> step <SPC> = <SPC> k <SPC> / <SPC> curr <NL> <NL> <TAB> k <SPC> %= <SPC> curr <NL> <TAB> curr <SPC> /= <SPC> n <NL> <TAB> res <SPC> = <SPC> [ remain [ step ] ] <SPC> + <SPC> self . do_getPermutation ( <NL>          remain [ : step ] <SPC> + <SPC> remain [ step <SPC> + <SPC> 1 : ] , <SPC> curr , <SPC> n <SPC> - <SPC> 1 , <SPC> k <NL> <TAB> ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . getPermutation ( 3 , <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rotateRight ( self , <SPC> head , <SPC> k ) : <NL> <NL> <TAB> if <SPC> not <SPC> head <SPC> or <SPC> k <SPC> == <SPC> 0 : <NL>          return <SPC> head <NL> <NL> <TAB> slow <SPC> = <SPC> fast <SPC> = <SPC> head <NL> <TAB> length <SPC> = <SPC> 1 <NL> <NL> <TAB> while <SPC> k <SPC> and <SPC> fast . next : <NL>          fast <SPC> = <SPC> fast . next <NL>          length <SPC> += <SPC> 1 <NL>          k <SPC> -= <SPC> 1 <NL> <NL> <TAB> if <SPC> k <SPC> != <SPC> 0 : <NL>          k <SPC> = <SPC> ( k <SPC> + <SPC> length <SPC> - <SPC> 1 ) <SPC> % <SPC> length <NL>          return <SPC> self . rotateRight ( head , <SPC> k ) <NL> <TAB> else : <NL>          while <SPC> fast . next : <NL>              fast <SPC> = <SPC> fast . next <NL>              slow <SPC> = <SPC> slow . next <NL>          return <SPC> self . rotate ( head , <SPC> fast , <SPC> slow ) <NL> <NL> <TAB> def <SPC> rotate ( self , <SPC> head , <SPC> fast , <SPC> slow ) : <NL> <TAB> fast . next <SPC> = <SPC> head <NL> <TAB> head <SPC> = <SPC> slow . next <NL> <TAB> slow . next <SPC> = <SPC> None <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> uniquePaths ( self , <SPC> m , <SPC> n ) : <NL> <NL> <TAB> dmap <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> range ( m ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( m ) : <NL>          dmap [ i ] [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> j <SPC> in <SPC> range ( n ) : <NL>          dmap [ 0 ] [ j ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> m ) : <NL>          for <SPC> j <SPC> in <SPC> range ( 1 , <SPC> n ) : <NL>              l <SPC> = <SPC> u <SPC> = <SPC> 0 <NL>              if <SPC> i <SPC> - <SPC> 1 <SPC> >= <SPC> 0 : <NL>                  u <SPC> = <SPC> dmap [ i <SPC> - <SPC> 1 ] [ j ] <NL>              if <SPC> j <SPC> - <SPC> 1 <SPC> >= <SPC> 0 : <NL>                  l <SPC> = <SPC> dmap [ i ] [ j <SPC> - <SPC> 1 ] <NL>              dmap [ i ] [ j ] <SPC> = <SPC> l <SPC> + <SPC> u <NL> <TAB> return <SPC> dmap [ m <SPC> - <SPC> 1 ] [ n <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> uniquePathsWithObstacles ( self , <SPC> obstacleGrid ) : <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( obstacleGrid ) , <SPC> len ( obstacleGrid [ 0 ] ) <NL> <TAB> if <SPC> m <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> dmap <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> range ( m <SPC> + <SPC> 1 ) ] <NL> <TAB> dmap [ m <SPC> - <SPC> 1 ] [ n ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( m <SPC> - <SPC> 1 , <SPC> - 1 , <SPC> - 1 ) : <NL>          for <SPC> j <SPC> in <SPC> range ( n <SPC> - <SPC> 1 , <SPC> - 1 , <SPC> - 1 ) : <NL>              if <SPC> obstacleGrid [ i ] [ j ] <SPC> == <SPC> 1 : <NL>                  dmap [ i ] [ j ] <SPC> = <SPC> 0 <NL>              else : <NL>                  dmap [ i ] [ j ] <SPC> = <SPC> dmap [ i ] [ j <SPC> + <SPC> 1 ] <SPC> + <SPC> dmap [ i <SPC> + <SPC> 1 ] [ j ] <NL> <TAB> return <SPC> dmap [ 0 ] [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minPathSum ( self , <SPC> grid ) : <NL> <NL> <TAB> height <SPC> = <SPC> len ( grid ) <NL> <TAB> if <SPC> height <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> width <SPC> = <SPC> len ( grid [ 0 ] ) <NL> <TAB> pathmap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( height ) : <NL>          pathmap . append ( [ 100000000000 ] <SPC> * <SPC> width ) <NL> <TAB> pathmap [ 0 ] [ 0 ] <SPC> = <SPC> grid [ 0 ] [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( height ) : <NL>          for <SPC> j <SPC> in <SPC> range ( width ) : <NL>              compare <SPC> = <SPC> [ pathmap [ i ] [ j ] ] <NL>              if <SPC> i <SPC> - <SPC> 1 <SPC> >= <SPC> 0 : <NL>                  compare . append ( pathmap [ i <SPC> - <SPC> 1 ] [ j ] <SPC> + <SPC> grid [ i ] [ j ] ) <NL>              if <SPC> j <SPC> - <SPC> 1 <SPC> >= <SPC> 0 : <NL>                  compare . append ( pathmap [ i ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> grid [ i ] [ j ] ) <NL> <NL>              pathmap [ i ] [ j ] <SPC> = <SPC> min ( compare ) <NL> <TAB> return <SPC> pathmap [ - 1 ] [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isNumber ( self , <SPC> s ) : <NL> <TAB> s <SPC> = <SPC> s . strip ( ) <NL> <TAB> ls , <SPC> pos <SPC> = <SPC> len ( s ) , <SPC> 0 <NL> <TAB> if <SPC> ls <SPC> == <SPC> 0 : <NL>          return <SPC> False <NL> <TAB> if <SPC> s [ pos ] <SPC> == <SPC> "+" <SPC> or <SPC> s [ pos ] <SPC> == <SPC> "-" : <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> isNumeric <SPC> = <SPC> False <NL> <TAB> while <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> s [ pos ] . isdigit ( ) : <NL>          pos <SPC> += <SPC> 1 <NL>          isNumeric <SPC> = <SPC> True <NL> <TAB> if <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> s [ pos ] <SPC> == <SPC> "." : <NL>          pos <SPC> += <SPC> 1 <NL>          while <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> s [ pos ] . isdigit ( ) : <NL>              pos <SPC> += <SPC> 1 <NL>              isNumeric <SPC> = <SPC> True <NL> <TAB> elif <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> s [ pos ] <SPC> == <SPC> "e" <SPC> and <SPC> isNumeric : <NL>          isNumeric <SPC> = <SPC> False <NL>          pos <SPC> += <SPC> 1 <NL>          if <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> ( s [ pos ] <SPC> == <SPC> "+" <SPC> or <SPC> s [ pos ] <SPC> == <SPC> "-" ) : <NL>              pos <SPC> += <SPC> 1 <NL>          while <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> s [ pos ] . isdigit ( ) : <NL>              pos <SPC> += <SPC> 1 <NL>              isNumeric <SPC> = <SPC> True <NL> <TAB> print <SPC> pos , <SPC> ls , <SPC> isNumeric <NL> <TAB> if <SPC> pos <SPC> == <SPC> ls <SPC> and <SPC> isNumeric : <NL>          return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> plusOne ( self , <SPC> digits ) : <NL> <TAB> ls <SPC> = <SPC> len ( digits ) <NL> <TAB> for <SPC> index <SPC> in <SPC> reversed ( range ( ls ) ) : <NL>          if <SPC> digits [ index ] <SPC> < <SPC> 9 : <NL>              digits [ index ] <SPC> += <SPC> 1 <NL> <NL>              return <SPC> digits <NL>          else : <NL> <NL>              digits [ index ] <SPC> = <SPC> 0 <NL> <TAB> digits . insert ( 0 , <SPC> 1 ) <NL> <TAB> return <SPC> digits <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> addBinary ( self , <SPC> a , <SPC> b ) : <NL> <TAB> res <SPC> = <SPC> "" <NL> <TAB> lsa , <SPC> lsb <SPC> = <SPC> len ( a ) , <SPC> len ( b ) <NL> <TAB> pos , <SPC> plus , <SPC> curr <SPC> = <SPC> - 1 , <SPC> 0 , <SPC> 0 <NL> <NL> <TAB> while <SPC> ( lsa <SPC> + <SPC> pos ) <SPC> >= <SPC> 0 <SPC> or <SPC> ( lsb <SPC> + <SPC> pos ) <SPC> >= <SPC> 0 : <NL>          if <SPC> ( lsa <SPC> + <SPC> pos ) <SPC> >= <SPC> 0 : <NL>              curr <SPC> += <SPC> int ( a [ pos ] ) <NL>          if <SPC> ( lsb <SPC> + <SPC> pos ) <SPC> >= <SPC> 0 : <NL>              curr <SPC> += <SPC> int ( b [ pos ] ) <NL>          res <SPC> = <SPC> str ( curr <SPC> % <SPC> 2 ) <SPC> + <SPC> res <NL>          curr <SPC> //= <SPC> 2 <NL>          pos <SPC> -= <SPC> 1 <NL> <TAB> if <SPC> curr <SPC> == <SPC> 1 : <NL>          res <SPC> = <SPC> "1" <SPC> + <SPC> res <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fullJustify ( self , <SPC> words , <SPC> maxWidth ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> res_list <SPC> = <SPC> [ ] <NL> <TAB> curr <SPC> = <SPC> [ ] <NL> <TAB> count , <SPC> pos <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> pos <SPC> < <SPC> len ( words ) : <NL>          word <SPC> = <SPC> words [ pos ] <NL>          if <SPC> len ( word ) <SPC> > <SPC> maxWidth : <NL>              pos <SPC> += <SPC> 1 <NL>          if <SPC> len ( word ) <SPC> + <SPC> count <SPC> + <SPC> len ( curr ) <SPC> <= <SPC> maxWidth : <NL>              count <SPC> += <SPC> len ( word ) <NL>              curr . append ( word ) <NL>              pos <SPC> += <SPC> 1 <NL>          else : <NL>              res_list . append ( curr ) <NL>              curr <SPC> = <SPC> [ ] <NL>              count <SPC> = <SPC> 0 <NL> <TAB> if <SPC> len ( curr ) <SPC> > <SPC> 0 : <NL>          res_list . append ( curr ) <NL> <NL> <TAB> for <SPC> index , <SPC> curr <SPC> in <SPC> enumerate ( res_list ) : <NL>          text <SPC> = <SPC> "" <NL>          remain <SPC> = <SPC> sum ( [ len ( t ) <SPC> for <SPC> t <SPC> in <SPC> curr ] ) <NL>          if <SPC> len ( curr ) <SPC> == <SPC> 1 : <NL> <NL>              text <SPC> = <SPC> curr [ 0 ] <SPC> + <SPC> " " <SPC> * <SPC> ( maxWidth <SPC> - <SPC> remain ) <NL>          elif <SPC> index <SPC> == <SPC> len ( res_list ) <SPC> - <SPC> 1 : <NL> <NL>              text <SPC> = <SPC> " " . join ( curr ) <NL>              text <SPC> += <SPC> " " <SPC> * <SPC> ( maxWidth <SPC> - <SPC> remain <SPC> - <SPC> len ( curr ) <SPC> + <SPC> 1 ) <NL>          else : <NL> <NL>              step <SPC> = <SPC> ( maxWidth <SPC> - <SPC> remain ) <SPC> / <SPC> ( len ( curr ) <SPC> - <SPC> 1 ) <NL>              extra <SPC> = <SPC> ( maxWidth <SPC> - <SPC> remain ) <SPC> % <SPC> ( len ( curr ) <SPC> - <SPC> 1 ) <NL>              for <SPC> index <SPC> in <SPC> range ( len ( curr ) <SPC> - <SPC> 1 ) : <NL>                  text <SPC> += <SPC> curr [ index ] <SPC> + <SPC> " " <SPC> * <SPC> step <NL>                  if <SPC> extra <SPC> > <SPC> 0 : <NL> <NL>                      text <SPC> += <SPC> " " <NL>                      extra <SPC> -= <SPC> 1 <NL>              text <SPC> += <SPC> curr [ - 1 ] <NL>          res . append ( text ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . fullJustify ( <NL>          [ <NL>              "Don't" , <NL>              "go" , <NL>              "around" , <NL>              "saying" , <NL>              "the" , <NL>              "world" , <NL>              "owes" , <NL>              "you" , <NL>              "a" , <NL>              "living;" , <NL>              "the" , <NL>              "world" , <NL>              "owes" , <NL>              "you" , <NL>              "nothing;" , <NL>              "it" , <NL>              "was" , <NL>              "here" , <NL>              "first." , <NL>          ] , <NL>          30 , <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution : <NL> <NL> <TAB> def <SPC> mySqrt ( self , <SPC> x ) : <NL> <NL> <TAB> if <SPC> x <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> if <SPC> x <SPC> < <SPC> 4 : <NL>          return <SPC> 1 <NL> <TAB> res <SPC> = <SPC> 2 <SPC> * <SPC> self . mySqrt ( x <SPC> / <SPC> 4 ) <NL> <NL> <TAB> if <SPC> ( res <SPC> + <SPC> 1 ) <SPC> * <SPC> ( res <SPC> + <SPC> 1 ) <SPC> <= <SPC> x <SPC> and <SPC> ( res <SPC> + <SPC> 1 ) <SPC> * <SPC> ( res <SPC> + <SPC> 1 ) <SPC> >= <SPC> 0 : <NL>          return <SPC> res <SPC> + <SPC> 1 <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> climbStairs ( self , <SPC> n ) : <NL> <TAB> if <SPC> n <SPC> <= <SPC> 1 : <NL>          return <SPC> 1 <NL> <TAB> dp <SPC> = <SPC> [ 1 ] <SPC> * <SPC> 2 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 2 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          dp [ 1 ] , <SPC> dp [ 0 ] <SPC> = <SPC> dp [ 1 ] <SPC> + <SPC> dp [ 0 ] , <SPC> dp [ 1 ] <NL> <TAB> return <SPC> dp [ 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> simplifyPath ( self , <SPC> path ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> plist <SPC> = <SPC> path . split ( "/" ) <NL> <TAB> for <SPC> pos <SPC> in <SPC> plist : <NL>          if <SPC> pos : <NL>              if <SPC> pos <SPC> == <SPC> ".." : <NL>                  try : <NL> <NL>                      result . pop ( ) <NL>                  except : <NL> <NL>                      result <SPC> = <SPC> [ ] <NL>              elif <SPC> pos <SPC> != <SPC> "." : <NL>                  result . append ( pos ) <NL> <TAB> return <SPC> "/" <SPC> + <SPC> "/" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> minDistance ( self , <SPC> word1 , <SPC> word2 ) : <NL> <TAB> ls_1 , <SPC> ls_2 <SPC> = <SPC> len ( word1 ) , <SPC> len ( word2 ) <NL> <TAB> dp <SPC> = <SPC> list ( range ( ls_1 <SPC> + <SPC> 1 ) ) <NL> <TAB> for <SPC> j <SPC> in <SPC> range ( 1 , <SPC> ls_2 <SPC> + <SPC> 1 ) : <NL>          pre <SPC> = <SPC> dp [ 0 ] <NL>          dp [ 0 ] <SPC> = <SPC> j <NL>          for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> ls_1 <SPC> + <SPC> 1 ) : <NL>              temp <SPC> = <SPC> dp [ i ] <NL>              if <SPC> word1 [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> word2 [ j <SPC> - <SPC> 1 ] : <NL>                  dp [ i ] <SPC> = <SPC> pre <NL>              else : <NL>                  dp [ i ] <SPC> = <SPC> min ( pre <SPC> + <SPC> 1 , <SPC> dp [ i ] <SPC> + <SPC> 1 , <SPC> dp [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 ) <NL>              pre <SPC> = <SPC> temp <NL> <TAB> return <SPC> dp [ ls_1 ] <NL> <NL> <TAB> if <SPC> __name__ <SPC> == <SPC> '__main__' : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print ( s . minDistance ( "horse" , <SPC> "ros" ) ) <NL> <TAB> print ( s . minDistance ( "intention" , <SPC> "execution" ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> setZeroes ( self , <SPC> matrix ) : <NL> <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <NL> <TAB> m <SPC> = <SPC> len ( matrix ) <NL> <TAB> if <SPC> m <SPC> == <SPC> 0 : <NL>          return <NL> <TAB> r <SPC> = <SPC> [ ] <NL> <TAB> c <SPC> = <SPC> [ ] <NL> <TAB> n <SPC> = <SPC> len ( matrix [ 0 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( m ) : <NL>          for <SPC> j <SPC> in <SPC> range ( n ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> 0 : <NL>                  r . append ( i ) <NL>                  c . append ( j ) <NL> <NL> <TAB> r <SPC> = <SPC> set ( r ) <NL> <NL> <TAB> c <SPC> = <SPC> set ( c ) <NL> <TAB> for <SPC> i <SPC> in <SPC> r : <NL>          for <SPC> j <SPC> in <SPC> range ( n ) : <NL>              matrix [ i ] [ j ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( m ) : <NL>          for <SPC> j <SPC> in <SPC> c : <NL>              matrix [ i ] [ j ] <SPC> = <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> searchMatrix ( self , <SPC> matrix , <SPC> target ) : <NL> <NL> <TAB> try : <NL>          ls_row , <SPC> ls_col <SPC> = <SPC> len ( matrix ) , <SPC> len ( matrix [ 0 ] ) <NL> <TAB> except : <NL>          return <SPC> False <NL> <TAB> if <SPC> target <SPC> < <SPC> matrix [ 0 ] [ 0 ] <SPC> or <SPC> target <SPC> > <SPC> matrix [ - 1 ] [ - 1 ] : <NL>          return <SPC> False <NL> <TAB> begin , <SPC> end <SPC> = <SPC> 0 , <SPC> ls_row <SPC> * <SPC> ls_col <SPC> - <SPC> 1 <NL> <TAB> while <SPC> begin <SPC> <= <SPC> end : <NL>          mid <SPC> = <SPC> ( begin <SPC> + <SPC> end ) <SPC> / <SPC> 2 <NL>          row , <SPC> col <SPC> = <SPC> mid <SPC> / <SPC> ls_col , <SPC> mid <SPC> % <SPC> ls_col <NL>          if <SPC> matrix [ row ] [ col ] <SPC> == <SPC> target : <NL>              return <SPC> True <NL>          elif <SPC> matrix [ row ] [ col ] <SPC> > <SPC> target : <NL>              end <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              begin <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> sortColors ( self , <SPC> nums ) : <NL> <NL> <TAB> low , <SPC> mid , <SPC> high <SPC> = <SPC> 0 , <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> mid <SPC> <= <SPC> high : <NL>          if <SPC> nums [ mid ] <SPC> == <SPC> 0 : <NL> <NL>              nums [ low ] , <SPC> nums [ mid ] <SPC> = <SPC> nums [ mid ] , <SPC> nums [ low ] <NL>              low <SPC> += <SPC> 1 <NL>              mid <SPC> += <SPC> 1 <NL>          elif <SPC> nums [ mid ] <SPC> == <SPC> 1 : <NL>              mid <SPC> += <SPC> 1 <NL>          else : <NL> <NL>              nums [ high ] , <SPC> nums [ mid ] <SPC> = <SPC> nums [ mid ] , <SPC> nums [ high ] <NL>              high <SPC> -= <SPC> 1 <NL> <TAB> return <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> minWindow ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> ls_s , <SPC> ls_t <SPC> = <SPC> len ( s ) , <SPC> len ( t ) <NL> <TAB> need_to_find <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 256 <NL> <TAB> has_found <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 256 <NL> <TAB> min_begin , <SPC> min_end <SPC> = <SPC> 0 , <SPC> - 1 <NL> <TAB> min_window <SPC> = <SPC> 100000000000000 <NL> <TAB> for <SPC> index <SPC> in <SPC> range ( ls_t ) : <NL>          need_to_find [ ord ( t [ index ] ) ] <SPC> += <SPC> 1 <NL> <TAB> count , <SPC> begin <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> end <SPC> in <SPC> range ( ls_s ) : <NL>          end_index <SPC> = <SPC> ord ( s [ end ] ) <NL>          if <SPC> need_to_find [ end_index ] <SPC> == <SPC> 0 : <NL>              continue <NL>          has_found [ end_index ] <SPC> += <SPC> 1 <NL>          if <SPC> has_found [ end_index ] <SPC> <= <SPC> need_to_find [ end_index ] : <NL>              count <SPC> += <SPC> 1 <NL>          if <SPC> count <SPC> == <SPC> ls_t : <NL>              begin_index <SPC> = <SPC> ord ( s [ begin ] ) <NL>              while <SPC> ( <NL>                  need_to_find [ begin_index ] <SPC> == <SPC> 0 <NL>                  or <SPC> has_found [ begin_index ] <SPC> > <SPC> need_to_find [ begin_index ] <NL>              ) : <NL>                  if <SPC> has_found [ begin_index ] <SPC> > <SPC> need_to_find [ begin_index ] : <NL>                      has_found [ begin_index ] <SPC> -= <SPC> 1 <NL>                  begin <SPC> += <SPC> 1 <NL>                  begin_index <SPC> = <SPC> ord ( s [ begin ] ) <NL>              window_ls <SPC> = <SPC> end <SPC> - <SPC> begin <SPC> + <SPC> 1 <NL>              if <SPC> window_ls <SPC> < <SPC> min_window : <NL>                  min_begin <SPC> = <SPC> begin <NL>                  min_end <SPC> = <SPC> end <NL>                  min_window <SPC> = <SPC> window_ls <NL> <NL> <TAB> if <SPC> count <SPC> == <SPC> ls_t : <NL>          return <SPC> s [ min_begin : <SPC> min_end <SPC> + <SPC> 1 ] <NL> <TAB> else : <NL>          return <SPC> "" <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . minWindow ( "a" , <SPC> "a" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> combine ( self , <SPC> n , <SPC> k ) : <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> self . get_combine ( res , <SPC> [ ] , <SPC> n , <SPC> k , <SPC> 1 ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> get_combine ( self , <SPC> res , <SPC> prefix , <SPC> n , <SPC> k , <SPC> start ) : <NL> <NL> <TAB> if <SPC> k <SPC> == <SPC> 0 : <NL>          res . append ( list ( prefix ) ) <NL> <TAB> elif <SPC> start <SPC> <= <SPC> n : <NL>          prefix . append ( start ) <NL>          self . get_combine ( res , <SPC> prefix , <SPC> n , <SPC> k <SPC> - <SPC> 1 , <SPC> start <SPC> + <SPC> 1 ) <NL>          prefix . pop ( ) <NL>          self . get_combine ( res , <SPC> prefix , <SPC> n , <SPC> k , <SPC> start <SPC> + <SPC> 1 ) <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . combine ( 4 , <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> subsets ( self , <SPC> nums ) : <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> res <SPC> = <SPC> [ [ ] ] <NL> <TAB> for <SPC> index <SPC> in <SPC> range ( len ( nums ) ) : <NL>          size <SPC> = <SPC> len ( res ) <NL> <NL>          for <SPC> j <SPC> in <SPC> range ( size ) : <NL>              curr <SPC> = <SPC> list ( res [ j ] ) <NL>              curr . append ( nums [ index ] ) <NL>              res . append ( curr ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . subsets ( [ 1 , <SPC> 2 , <SPC> 3 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> exist ( self , <SPC> board , <SPC> word ) : <NL> <NL> <TAB> check_board <SPC> = <SPC> [ [ True ] <SPC> * <SPC> len ( board [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> range ( len ( board ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( board ) ) : <NL>          for <SPC> j <SPC> in <SPC> range ( len ( board [ 0 ] ) ) : <NL>              if <SPC> board [ i ] [ j ] <SPC> == <SPC> word [ 0 ] <SPC> and <SPC> check_board : <NL>                  check_board [ i ] [ j ] <SPC> = <SPC> False <NL>                  res <SPC> = <SPC> self . check_exist ( <NL>                      check_board , <SPC> board , <SPC> word , <SPC> 1 , <SPC> len ( word ) , <SPC> i , <SPC> j ) <NL>                  if <SPC> res : <NL>                      return <SPC> True <NL>                  check_board [ i ] [ j ] <SPC> = <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <TAB> def <SPC> check_exist ( self , <SPC> check_board , <SPC> board , <SPC> word , <SPC> index , <SPC> ls , <SPC> row , <SPC> col ) : <NL> <TAB> if <SPC> index <SPC> == <SPC> ls : <NL>          return <SPC> True <NL> <TAB> for <SPC> temp <SPC> in <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( - 1 , <SPC> 0 ) ] : <NL>          curr_row <SPC> = <SPC> row <SPC> + <SPC> temp [ 0 ] <NL>          curr_col <SPC> = <SPC> col <SPC> + <SPC> temp [ 1 ] <NL>          if <SPC> ( <NL>              curr_row <SPC> >= <SPC> 0 <NL>              and <SPC> curr_row <SPC> < <SPC> len ( board ) <NL>              and <SPC> curr_col <SPC> >= <SPC> 0 <NL>              and <SPC> curr_col <SPC> < <SPC> len ( board [ 0 ] ) <NL>          ) : <NL>              if <SPC> ( <NL>                  check_board [ curr_row ] [ curr_col ] <NL>                  and <SPC> board [ curr_row ] [ curr_col ] <SPC> == <SPC> word [ index ] <NL>              ) : <NL>                  check_board [ curr_row ] [ curr_col ] <SPC> = <SPC> False <NL>                  res <SPC> = <SPC> self . check_exist ( <NL>                      check_board , <NL>                      board , <NL>                      word , <NL>                      index <SPC> + <SPC> 1 , <NL>                      len ( word ) , <NL>                      curr_row , <NL>                      curr_col , <NL>                  ) <NL>                  if <SPC> res : <NL>                      return <SPC> res <NL>                  check_board [ curr_row ] [ curr_col ] <SPC> = <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . exist ( <NL>          [ <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL>              "aaaaaaaaaaaaaaaaaaaaaaaaaaaaab" , <NL>          ] , <NL>          "baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" , <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> removeDuplicates ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> nums <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <TAB> length <SPC> = <SPC> len ( nums ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> i <SPC> = <SPC> j <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> length : <NL>          j <SPC> = <SPC> i <NL>          while <SPC> j <SPC> < <SPC> length : <NL>              if <SPC> nums [ j ] <SPC> != <SPC> nums [ i ] : <NL>                  break <NL>              j <SPC> += <SPC> 1 <NL>          if <SPC> j <SPC> - <SPC> i <SPC> > <SPC> 2 : <NL>              length <SPC> -= <SPC> j <SPC> - <SPC> i <SPC> - <SPC> 2 <NL>              for <SPC> k <SPC> in <SPC> range ( j <SPC> - <SPC> i <SPC> - <SPC> 2 ) : <NL>                  del <SPC> nums [ i ] <NL>              result <SPC> += <SPC> 2 <NL>              j <SPC> = <SPC> i <SPC> + <SPC> 2 <NL>          else : <NL>              result <SPC> += <SPC> j <SPC> - <SPC> i <NL>          i <SPC> = <SPC> j <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> search ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> def <SPC> get ( start , <SPC> end ) : <NL>          if <SPC> start <SPC> > <SPC> end : <NL>              return <SPC> False <NL>          mid <SPC> = <SPC> ( start <SPC> + <SPC> end ) <SPC> / <SPC> 2 <NL> <NL>          while <SPC> mid <SPC> < <SPC> end <SPC> and <SPC> nums [ mid <SPC> + <SPC> 1 ] <SPC> == <SPC> nums [ mid ] : <NL>              mid <SPC> += <SPC> 1 <NL>          while <SPC> start <SPC> < <SPC> mid <SPC> and <SPC> nums [ start <SPC> + <SPC> 1 ] <SPC> == <SPC> nums [ start ] : <NL>              start <SPC> += <SPC> 1 <NL>          if <SPC> nums [ mid ] <SPC> == <SPC> target : <NL>              return <SPC> True <NL>          elif <SPC> mid <SPC> == <SPC> end : <NL>              return <SPC> get ( start , <SPC> mid <SPC> - <SPC> 1 ) <NL>          elif <SPC> start <SPC> == <SPC> mid : <NL>              return <SPC> get ( mid <SPC> + <SPC> 1 , <SPC> end ) <NL>          elif <SPC> nums [ mid ] <SPC> >= <SPC> nums [ start ] : <NL> <NL>              if <SPC> target <SPC> >= <SPC> nums [ start ] <SPC> and <SPC> target <SPC> < <SPC> nums [ mid ] : <NL>                  return <SPC> get ( start , <SPC> mid <SPC> - <SPC> 1 ) <NL>              else : <NL>                  return <SPC> get ( mid <SPC> + <SPC> 1 , <SPC> end ) <NL>          elif <SPC> nums [ mid ] <SPC> <= <SPC> nums [ end ] : <NL> <NL>              if <SPC> target <SPC> > <SPC> nums [ mid ] <SPC> and <SPC> target <SPC> <= <SPC> nums [ end ] : <NL>                  return <SPC> get ( mid <SPC> + <SPC> 1 , <SPC> end ) <NL>              else : <NL>                  return <SPC> get ( start , <SPC> mid <SPC> - <SPC> 1 ) <NL> <NL> <TAB> return <SPC> get ( 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> deleteDuplicates ( self , <SPC> head ) : <NL> <TAB> if <SPC> head <SPC> is <SPC> None : <NL>          return <SPC> None <NL> <TAB> pos <SPC> = <SPC> head <NL> <TAB> while <SPC> pos <SPC> is <SPC> not <SPC> None <SPC> and <SPC> pos . next <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> pos . val <SPC> == <SPC> pos . next . val : <NL>              pos . next <SPC> = <SPC> pos . next . next <NL>          else : <NL>              pos <SPC> = <SPC> pos . next <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestRectangleArea ( self , <SPC> heights ) : <NL> <NL> <TAB> largest_rectangle <SPC> = <SPC> 0 <NL> <TAB> ls <SPC> = <SPC> len ( heights ) <NL> <NL> <TAB> stack <SPC> = <SPC> [ - 1 ] <NL> <TAB> top , <SPC> pos <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> pos <SPC> in <SPC> range ( ls ) : <NL>          while <SPC> top <SPC> > <SPC> 0 <SPC> and <SPC> heights [ stack [ top ] ] <SPC> > <SPC> heights [ pos ] : <NL>              largest_rectangle <SPC> = <SPC> max ( <NL>                  largest_rectangle , <SPC> heights [ stack [ top ] <NL>                                             ] <SPC> * <SPC> ( pos <SPC> - <SPC> stack [ top <SPC> - <SPC> 1 ] <SPC> - <SPC> 1 ) <NL>              ) <NL>              top <SPC> -= <SPC> 1 <NL>              stack . pop ( ) <NL>          stack . append ( pos ) <NL>          top <SPC> += <SPC> 1 <NL> <TAB> while <SPC> top <SPC> > <SPC> 0 : <NL>          largest_rectangle <SPC> = <SPC> max ( <NL>              largest_rectangle , <SPC> heights [ stack [ top ] ] <SPC> * <SPC> ( ls <SPC> - <SPC> stack [ top <SPC> - <SPC> 1 ] <SPC> - <SPC> 1 ) <NL>          ) <NL>          top <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> largest_rectangle <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . largestRectangleArea ( [ 2 , <SPC> 1 , <SPC> 5 , <SPC> 6 , <SPC> 2 , <SPC> 3 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximalRectangle ( self , <SPC> matrix ) : <NL> <NL> <TAB> if <SPC> matrix <SPC> is <SPC> None <SPC> or <SPC> len ( matrix ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> ls_row , <SPC> ls_col <SPC> = <SPC> len ( matrix ) , <SPC> len ( matrix [ 0 ] ) <NL> <TAB> left , <SPC> right , <SPC> height <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ls_col , <SPC> [ ls_col ] <SPC> * <SPC> ls_col , <SPC> [ 0 ] <SPC> * <SPC> ls_col <NL> <TAB> maxA <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls_row ) : <NL>          curr_left , <SPC> curr_right <SPC> = <SPC> 0 , <SPC> ls_col <NL>          for <SPC> j <SPC> in <SPC> range ( ls_col ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> "1" : <NL>                  height [ j ] <SPC> += <SPC> 1 <NL>              else : <NL>                  height [ j ] <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> range ( ls_col ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> "1" : <NL>                  left [ j ] <SPC> = <SPC> max ( left [ j ] , <SPC> curr_left ) <NL>              else : <NL>                  left [ j ] , <SPC> curr_left <SPC> = <SPC> 0 , <SPC> j <SPC> + <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> range ( ls_col <SPC> - <SPC> 1 , <SPC> - 1 , <SPC> - 1 ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> "1" : <NL>                  right [ j ] <SPC> = <SPC> min ( right [ j ] , <SPC> curr_right ) <NL>              else : <NL>                  right [ j ] , <SPC> curr_right <SPC> = <SPC> ls_col , <SPC> j <NL>          for <SPC> j <SPC> in <SPC> range ( ls_col ) : <NL>              maxA <SPC> = <SPC> max ( maxA , <SPC> ( right [ j ] <SPC> - <SPC> left [ j ] ) <SPC> * <SPC> height [ j ] ) <NL> <TAB> return <SPC> maxA <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> partition ( self , <SPC> head , <SPC> x ) : <NL> <NL> <TAB> if <SPC> head <SPC> is <SPC> None : <NL>          return <SPC> None <NL> <TAB> less <SPC> = <SPC> lesshead <SPC> = <SPC> None <NL> <TAB> last <SPC> = <SPC> pos <SPC> = <SPC> head <NL> <TAB> while <SPC> pos <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> pos . val <SPC> < <SPC> x : <NL>              if <SPC> lesshead <SPC> is <SPC> None : <NL>                  lesshead <SPC> = <SPC> pos <NL>              else : <NL>                  less . next <SPC> = <SPC> pos <NL>              less <SPC> = <SPC> pos <NL>              if <SPC> head <SPC> == <SPC> pos : <NL>                  last <SPC> = <SPC> head <SPC> = <SPC> pos . next <NL>              else : <NL>                  last . next <SPC> = <SPC> pos . next <NL>          else : <NL>              last <SPC> = <SPC> pos <NL>          pos <SPC> = <SPC> pos . next <NL> <TAB> if <SPC> lesshead <SPC> is <SPC> not <SPC> None : <NL>          less . next <SPC> = <SPC> head <NL> <TAB> else : <NL>          lesshead <SPC> = <SPC> head <NL> <TAB> return <SPC> lesshead <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isScramble ( self , <SPC> s1 , <SPC> s2 , <SPC> memo = { } ) : <NL> <NL> <TAB> if <SPC> len ( s1 ) <SPC> != <SPC> len ( s2 ) <SPC> or <SPC> sorted ( s1 ) <SPC> != <SPC> sorted ( s2 ) : <NL>          return <SPC> False <NL> <TAB> if <SPC> len ( s1 ) <SPC> <= <SPC> len ( s2 ) <SPC> <= <SPC> 1 : <NL>          return <SPC> s1 <SPC> == <SPC> s2 <NL> <TAB> if <SPC> s1 <SPC> == <SPC> s2 : <NL>          return <SPC> True <NL> <TAB> if <SPC> ( s1 , <SPC> s2 ) <SPC> in <SPC> memo : <NL>          return <SPC> memo [ s1 , <SPC> s2 ] <NL> <TAB> n <SPC> = <SPC> len ( s1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> n ) : <NL>          a <SPC> = <SPC> self . isScramble ( s1 [ : i ] , <SPC> s2 [ : i ] , <SPC> memo ) <SPC> and <SPC> self . isScramble ( <NL>              s1 [ i : ] , <SPC> s2 [ i : ] , <SPC> memo <NL>          ) <NL>          if <SPC> not <SPC> a : <NL>              b <SPC> = <SPC> self . isScramble ( s1 [ : i ] , <SPC> s2 [ - i : ] , <SPC> memo ) <SPC> and <SPC> self . isScramble ( <NL>                  s1 [ i : ] , <SPC> s2 [ : - i ] , <SPC> memo <NL>              ) <NL>          if <SPC> a <SPC> or <SPC> b : <NL>              memo [ s1 , <SPC> s2 ] <SPC> = <SPC> True <NL>              return <SPC> True <NL> <TAB> memo [ s1 , <SPC> s2 ] <SPC> = <SPC> False <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> merge ( self , <SPC> nums1 , <SPC> m , <SPC> nums2 , <SPC> n ) : <NL> <NL> <TAB> p1 , <SPC> p2 <SPC> = <SPC> m <SPC> - <SPC> 1 , <SPC> n <SPC> - <SPC> 1 <NL> <TAB> pos <SPC> = <SPC> m <SPC> + <SPC> n <SPC> - <SPC> 1 <NL> <TAB> while <SPC> p1 <SPC> >= <SPC> 0 <SPC> and <SPC> p2 <SPC> >= <SPC> 0 : <NL>          if <SPC> nums1 [ p1 ] <SPC> >= <SPC> nums2 [ p2 ] : <NL>              nums1 [ pos ] <SPC> = <SPC> nums1 [ p1 ] <NL>              p1 <SPC> -= <SPC> 1 <NL>          else : <NL>              nums1 [ pos ] <SPC> = <SPC> nums2 [ p2 ] <NL>              p2 <SPC> -= <SPC> 1 <NL>          pos <SPC> -= <SPC> 1 <NL> <TAB> while <SPC> p2 <SPC> >= <SPC> 0 : <NL>          nums1 [ pos ] <SPC> = <SPC> nums2 [ p2 ] <NL>          p2 <SPC> -= <SPC> 1 <NL>          pos <SPC> -= <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> grayCode ( self , <SPC> n ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( n ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( range ( len ( res ) ) ) : <NL>              res . append ( res [ j ] <SPC> + <SPC> ( 1 <SPC> << <SPC> i ) ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . grayCode ( 2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> subsetsWithDup ( self , <SPC> nums ) : <NL> <TAB> nums . sort ( ) <NL> <TAB> res <SPC> = <SPC> [ [ ] ] <NL> <TAB> begin <SPC> = <SPC> 0 <NL> <TAB> for <SPC> index <SPC> in <SPC> range ( len ( nums ) ) : <NL>          if <SPC> index <SPC> == <SPC> 0 <SPC> or <SPC> nums [ index ] <SPC> != <SPC> nums [ index <SPC> - <SPC> 1 ] : <NL> <NL>              begin <SPC> = <SPC> 0 <NL>          size <SPC> = <SPC> len ( res ) <NL> <NL>          for <SPC> j <SPC> in <SPC> range ( begin , <SPC> size ) : <NL>              curr <SPC> = <SPC> list ( res [ j ] ) <NL>              curr . append ( nums [ index ] ) <NL>              res . append ( curr ) <NL> <NL>          begin <SPC> = <SPC> size <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numDecodings ( self , <SPC> s ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( s ) <NL> <TAB> if <SPC> ls <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ls <NL> <TAB> for <SPC> index <SPC> in <SPC> range ( ls ) : <NL>          if <SPC> ( <NL>              index <SPC> >= <SPC> 1 <NL>              and <SPC> int ( s [ index <SPC> - <SPC> 1 : <SPC> index <SPC> + <SPC> 1 ] ) <SPC> < <SPC> 27 <NL>              and <SPC> int ( s [ index <SPC> - <SPC> 1 : <SPC> index <SPC> + <SPC> 1 ] ) <SPC> >= <SPC> 10 <NL>          ) : <NL>              if <SPC> index <SPC> == <SPC> 1 : <NL>                  dp [ index ] <SPC> = <SPC> 1 <NL>              else : <NL> <NL>                  dp [ index ] <SPC> += <SPC> dp [ index <SPC> - <SPC> 2 ] <NL>          if <SPC> int ( s [ index ] ) <SPC> != <SPC> 0 : <NL>              if <SPC> index <SPC> == <SPC> 0 : <NL>                  dp [ index ] <SPC> = <SPC> 1 <NL>              else : <NL> <NL>                  dp [ index ] <SPC> += <SPC> dp [ index <SPC> - <SPC> 1 ] <NL> <TAB> return <SPC> dp [ ls <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseBetween ( self , <SPC> head , <SPC> m , <SPC> n ) : <NL> <NL> <TAB> if <SPC> m <SPC> == <SPC> n : <NL>          return <SPC> head <NL> <TAB> split_node , <SPC> prev , <SPC> curr <SPC> = <SPC> None , <SPC> None , <SPC> head <NL> <TAB> count <SPC> = <SPC> 1 <NL> <TAB> while <SPC> count <SPC> <= <SPC> m <SPC> and <SPC> curr <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> count <SPC> == <SPC> m : <NL>              split_node <SPC> = <SPC> prev <NL>          prev <SPC> = <SPC> curr <NL>          curr <SPC> = <SPC> curr . next <NL>          count <SPC> += <SPC> 1 <NL> <TAB> tail , <SPC> next_node <SPC> = <SPC> prev , <SPC> None <NL> <TAB> while <SPC> curr <SPC> is <SPC> not <SPC> None <SPC> and <SPC> count <SPC> <= <SPC> n : <NL>          next_temp <SPC> = <SPC> curr . next <NL>          curr . next <SPC> = <SPC> prev <NL>          prev <SPC> = <SPC> curr <NL>          curr <SPC> = <SPC> next_temp <NL>          count <SPC> += <SPC> 1 <NL> <TAB> if <SPC> split_node <SPC> is <SPC> not <SPC> None : <NL>          split_node . next <SPC> = <SPC> prev <NL> <TAB> if <SPC> tail <SPC> is <SPC> not <SPC> None : <NL>          tail . next <SPC> = <SPC> curr <NL> <TAB> if <SPC> m <SPC> == <SPC> 1 : <NL>          return <SPC> prev <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> restoreIpAddresses ( self , <SPC> s ) : <NL> <TAB> ls <SPC> = <SPC> len ( s ) <NL> <TAB> if <SPC> ls <SPC> == <SPC> 0 <SPC> or <SPC> ls <SPC> > <SPC> 12 : <NL>          return <SPC> [ ] <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> 4 ) : <NL>          for <SPC> j <SPC> in <SPC> range ( 1 , <SPC> 4 ) : <NL>              for <SPC> k <SPC> in <SPC> range ( 1 , <SPC> 4 ) : <NL>                  m <SPC> = <SPC> ls <SPC> - <SPC> i <SPC> - <SPC> j <SPC> - <SPC> k <NL>                  if <SPC> m <SPC> > <SPC> 0 <SPC> and <SPC> m <SPC> <= <SPC> 3 : <NL>                      add1 <SPC> = <SPC> s [ 0 : i ] <NL>                      add2 <SPC> = <SPC> s [ i : <SPC> i <SPC> + <SPC> j ] <NL>                      add3 <SPC> = <SPC> s [ i <SPC> + <SPC> j : <SPC> i <SPC> + <SPC> j <SPC> + <SPC> k ] <NL>                      add4 <SPC> = <SPC> s [ i <SPC> + <SPC> j <SPC> + <SPC> k : ] <NL>                      if <SPC> ( <NL>                          self . isValid ( add1 ) <NL>                          and <SPC> self . isValid ( add2 ) <NL>                          and <SPC> self . isValid ( add3 ) <NL>                          and <SPC> self . isValid ( add4 ) <NL>                      ) : <NL>                          res . append ( add1 <SPC> + <SPC> "." <SPC> + <SPC> add2 <SPC> + <SPC> "." <SPC> + <SPC> add3 <SPC> + <SPC> "." <SPC> + <SPC> add4 ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> isValid ( self , <SPC> add ) : <NL> <TAB> if <SPC> len ( add ) <SPC> == <SPC> 1 : <NL>          return <SPC> True <NL> <TAB> if <SPC> add [ 0 ] <SPC> == <SPC> "0" : <NL>          return <SPC> False <NL> <TAB> if <SPC> int ( add ) <SPC> <= <SPC> 255 : <NL>          return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <NL> <TAB> print <SPC> s . restoreIpAddresses ( "25525511135" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> inorderTraversal ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> stack <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> len ( stack ) <SPC> > <SPC> 0 : <NL>          curr <SPC> = <SPC> stack . pop ( ) <NL>          if <SPC> not <SPC> isinstance ( curr , <SPC> TreeNode ) : <NL>              res . append ( curr ) <NL>              continue <NL>          if <SPC> curr . right <SPC> is <SPC> not <SPC> None : <NL>              stack . append ( curr . right ) <NL>          stack . append ( curr . val ) <NL>          if <SPC> curr . left <SPC> is <SPC> not <SPC> None : <NL>              stack . append ( curr . left ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> generateTrees ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 : <NL>          return <SPC> [ ] <NL> <TAB> return <SPC> self . get_trees ( 1 , <SPC> n ) <NL> <NL> <TAB> def <SPC> get_trees ( self , <SPC> start , <SPC> end ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> start <SPC> > <SPC> end : <NL>          res . append ( None ) <NL>          return <SPC> res <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( start , <SPC> end <SPC> + <SPC> 1 ) : <NL>          lefts <SPC> = <SPC> self . get_trees ( start , <SPC> i <SPC> - <SPC> 1 ) <NL>          rights <SPC> = <SPC> self . get_trees ( i <SPC> + <SPC> 1 , <SPC> end ) <NL>          for <SPC> j <SPC> in <SPC> range ( len ( lefts ) ) : <NL>              for <SPC> k <SPC> in <SPC> range ( len ( rights ) ) : <NL> <NL>                  root <SPC> = <SPC> TreeNode ( i ) <NL>                  root . left <SPC> = <SPC> lefts [ j ] <NL>                  root . right <SPC> = <SPC> rights [ k ] <NL>                  res . append ( root ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numTrees ( self , <SPC> n ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> dp [ 1 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> level <SPC> in <SPC> range ( 2 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          for <SPC> root <SPC> in <SPC> range ( 1 , <SPC> level <SPC> + <SPC> 1 ) : <NL>              dp [ level ] <SPC> += <SPC> dp [ level <SPC> - <SPC> root ] <SPC> * <SPC> dp [ root <SPC> - <SPC> 1 ] <NL> <TAB> return <SPC> dp [ n ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isInterleave ( self , <SPC> s1 , <SPC> s2 , <SPC> s3 ) : <NL> <NL> <TAB> if <SPC> len ( s1 ) <SPC> + <SPC> len ( s2 ) <SPC> != <SPC> len ( s3 ) : <NL>          return <SPC> False <NL> <TAB> queue <SPC> = <SPC> [ ( 0 , <SPC> 0 ) , <SPC> ( - 1 , <SPC> - 1 ) ] <NL> <TAB> visited <SPC> = <SPC> set ( ) <NL> <TAB> isSuccess <SPC> = <SPC> False <NL> <TAB> index <SPC> = <SPC> 0 <NL> <TAB> while <SPC> len ( queue ) <SPC> != <SPC> 1 <SPC> or <SPC> queue [ 0 ] [ 0 ] <SPC> != <SPC> - 1 : <NL>          p <SPC> = <SPC> queue . pop ( 0 ) <NL>          if <SPC> p [ 0 ] <SPC> == <SPC> len ( s1 ) <SPC> and <SPC> p [ 1 ] <SPC> == <SPC> len ( s2 ) : <NL>              return <SPC> True <NL>          if <SPC> p [ 0 ] <SPC> == <SPC> - 1 : <NL>              queue . append ( p ) <NL>              index <SPC> += <SPC> 1 <NL>              continue <NL>          if <SPC> p <SPC> in <SPC> visited : <NL>              continue <NL>          visited . add ( p ) <NL>          if <SPC> p [ 0 ] <SPC> < <SPC> len ( s1 ) : <NL>              if <SPC> s1 [ p [ 0 ] ] <SPC> == <SPC> s3 [ index ] : <NL>                  queue . append ( ( p [ 0 ] <SPC> + <SPC> 1 , <SPC> p [ 1 ] ) ) <NL>          if <SPC> p [ 1 ] <SPC> < <SPC> len ( s2 ) : <NL>              if <SPC> s2 [ p [ 1 ] ] <SPC> == <SPC> s3 [ index ] : <NL>                  queue . append ( ( p [ 0 ] , <SPC> p [ 1 ] <SPC> + <SPC> 1 ) ) <NL> <TAB> return <SPC> False <NL> <NL> <NL> import <SPC> sys <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isValidBST ( self , <SPC> root ) : <NL> <TAB> return <SPC> self . isVaild_helper ( root , <SPC> - sys . maxint <SPC> - <SPC> 1 , <SPC> sys . maxint ) <NL> <NL> <TAB> def <SPC> isVaild_helper ( self , <SPC> root , <SPC> minVal , <SPC> maxVal ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <TAB> if <SPC> root . val <SPC> >= <SPC> maxVal <SPC> or <SPC> root . val <SPC> <= <SPC> minVal : <NL>          return <SPC> False <NL> <TAB> return <SPC> self . isVaild_helper ( root . left , <SPC> minVal , <SPC> root . val ) <SPC> and <SPC> self . isVaild_helper ( <NL>          root . right , <SPC> root . val , <SPC> maxVal <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . first <SPC> = <SPC> self . second <SPC> = <SPC> None <NL> <TAB> self . pre <SPC> = <SPC> TreeNode ( - sys . maxint <SPC> - <SPC> 1 ) <NL> <NL> <TAB> def <SPC> recoverTree ( self , <SPC> root ) : <NL> <TAB> self . traverse ( root ) <NL> <TAB> self . first . val , <SPC> self . second . val <SPC> = <SPC> self . second . val , <SPC> self . first . val <NL> <NL> <TAB> def <SPC> traverse ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <NL> <TAB> self . traverse ( root . left ) <NL> <TAB> if <SPC> self . pre . val <SPC> >= <SPC> root . val : <NL>          if <SPC> self . first <SPC> is <SPC> None : <NL>              self . first <SPC> = <SPC> self . pre <NL>          if <SPC> self . first <SPC> is <SPC> not <SPC> None : <NL>              self . second <SPC> = <SPC> root <NL> <TAB> self . pre <SPC> = <SPC> root <NL> <TAB> self . traverse ( root . right ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isSameTree ( self , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> if <SPC> p <SPC> == <SPC> q : <NL>          return <SPC> True <NL> <TAB> try : <NL>          left <SPC> = <SPC> right <SPC> = <SPC> True <NL>          if <SPC> p . val <SPC> == <SPC> q . val : <NL>              left <SPC> = <SPC> self . isSameTree ( p . left , <SPC> q . left ) <NL>              right <SPC> = <SPC> self . isSameTree ( p . right , <SPC> q . right ) <NL>              return <SPC> left <SPC> and <SPC> right <NL> <TAB> except : <NL>          return <SPC> False <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isSymmetric ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <TAB> return <SPC> self . mirrorVisit ( root . left , <SPC> root . right ) <NL> <NL> <TAB> def <SPC> mirrorVisit ( self , <SPC> left , <SPC> right ) : <NL> <TAB> if <SPC> left <SPC> is <SPC> None <SPC> and <SPC> right <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <TAB> try : <NL>          if <SPC> left . val <SPC> == <SPC> right . val : <NL>              if <SPC> self . mirrorVisit ( left . left , <SPC> right . right ) <SPC> and <SPC> self . mirrorVisit ( <NL>                  left . right , <SPC> right . left <NL>              ) : <NL>                  return <SPC> True <NL>          return <SPC> False <NL> <TAB> except : <NL>          return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> levelOrder ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <TAB> q <SPC> = <SPC> [ [ root ] ] <NL> <TAB> for <SPC> level <SPC> in <SPC> q : <NL>          record <SPC> = <SPC> [ ] <NL>          for <SPC> node <SPC> in <SPC> level : <NL>              if <SPC> node . left : <NL>                  record . append ( node . left ) <NL>              if <SPC> node . right : <NL>                  record . append ( node . right ) <NL>          if <SPC> record : <NL>              q . append ( record ) <NL> <TAB> return <SPC> [ [ x . val <SPC> for <SPC> x <SPC> in <SPC> level ] <SPC> for <SPC> level <SPC> in <SPC> q ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> zigzagLevelOrder ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <TAB> q <SPC> = <SPC> [ [ root ] ] <NL> <TAB> for <SPC> level <SPC> in <SPC> q : <NL>          record <SPC> = <SPC> [ ] <NL>          for <SPC> node <SPC> in <SPC> level : <NL>              if <SPC> node . left : <NL>                  record . append ( node . left ) <NL>              if <SPC> node . right : <NL>                  record . append ( node . right ) <NL>          if <SPC> record : <NL>              q . append ( record ) <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> index , <SPC> level <SPC> in <SPC> enumerate ( q ) : <NL>          temp <SPC> = <SPC> [ x . val <SPC> for <SPC> x <SPC> in <SPC> level ] <NL>          if <SPC> index <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              res . append ( temp ) <NL>          else : <NL>              res . append ( temp [ : : - 1 ] ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> maxDepth ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <TAB> ld <SPC> = <SPC> self . maxDepth ( root . left ) <NL> <TAB> rd <SPC> = <SPC> self . maxDepth ( root . right ) <NL> <TAB> return <SPC> 1 <SPC> + <SPC> max ( ld , <SPC> rd ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> buildTree ( self , <SPC> preorder , <SPC> inorder ) : <NL> <TAB> n <SPC> = <SPC> len ( inorder ) <NL> <TAB> inOrderMap <SPC> = <SPC> { inorder [ i ] : <SPC> i <SPC> for <SPC> i <SPC> in <SPC> range ( n ) } <NL> <TAB> return <SPC> self . buildTreeUtil ( preorder , <SPC> inorder , <SPC> inOrderMap , <SPC> 0 , <SPC> n <SPC> - <SPC> 1 , <SPC> 0 , <SPC> n <SPC> - <SPC> 1 ) <NL> <NL> <TAB> def <SPC> buildTreeUtil ( self , <SPC> preorder , <SPC> inorder , <SPC> inOrderMap , <SPC> pStart , <SPC> pEnd , <SPC> iStart , <SPC> iEnd ) : <NL> <TAB> if <SPC> pStart <SPC> > <SPC> pEnd <SPC> or <SPC> iStart <SPC> > <SPC> iEnd : <NL>          return <SPC> None <NL> <TAB> root <SPC> = <SPC> TreeNode ( preorder [ pStart ] ) <NL> <TAB> rootIdx <SPC> = <SPC> inOrderMap [ root . val ] <NL> <TAB> root . left <SPC> = <SPC> self . buildTreeUtil ( <NL>          preorder , <NL>          inorder , <NL>          inOrderMap , <NL>          pStart <SPC> + <SPC> 1 , <NL>          pStart <SPC> + <SPC> rootIdx <SPC> - <SPC> iStart <SPC> + <SPC> 1 , <NL>          iStart , <NL>          rootIdx <SPC> - <SPC> 1 , <NL> <TAB> ) <NL> <TAB> root . right <SPC> = <SPC> self . buildTreeUtil ( <NL>          preorder , <NL>          inorder , <NL>          inOrderMap , <NL>          pStart <SPC> + <SPC> rootIdx <SPC> - <SPC> iStart <SPC> + <SPC> 1 , <NL>          pEnd , <NL>          rootIdx <SPC> + <SPC> 1 , <NL>          iEnd , <NL> <TAB> ) <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> fixedPoint ( self , <SPC> A ) : <NL> <TAB> l , <SPC> h <SPC> = <SPC> 0 , <SPC> len ( A ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> l <SPC> <= <SPC> h : <NL>          mid <SPC> = <SPC> ( l <SPC> + <SPC> h ) <SPC> // <SPC> 2 <NL>          if <SPC> A [ mid ] <SPC> < <SPC> mid : <NL>              l <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          elif <SPC> A [ mid ] <SPC> > <SPC> mid : <NL>              h <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              return <SPC> mid <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> buildTree ( self , <SPC> inorder , <SPC> postorder ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( inorder ) <NL> <TAB> inOrderMap <SPC> = <SPC> { inorder [ i ] : <SPC> i <SPC> for <SPC> i <SPC> in <SPC> range ( n ) } <NL> <TAB> return <SPC> self . buildTreeUtil ( inorder , <SPC> postorder , <SPC> inOrderMap , <SPC> 0 , <SPC> n <SPC> - <SPC> 1 , <SPC> 0 , <SPC> n <SPC> - <SPC> 1 ) <NL> <NL> <TAB> def <SPC> buildTreeUtil ( self , <SPC> inorder , <SPC> postorder , <SPC> inOrderMap , <SPC> pStart , <SPC> pEnd , <SPC> iStart , <SPC> iEnd ) : <NL> <TAB> if <SPC> pStart <SPC> > <SPC> pEnd <SPC> or <SPC> iStart <SPC> > <SPC> iEnd : <NL>          return <SPC> None <NL> <NL> <TAB> root <SPC> = <SPC> TreeNode ( postorder [ pEnd ] ) <NL> <TAB> rootIdx <SPC> = <SPC> inOrderMap [ root . val ] <NL> <TAB> root . left <SPC> = <SPC> self . buildTreeUtil ( <NL>          inorder , <NL>          postorder , <NL>          inOrderMap , <NL>          pStart , <NL>          pStart <SPC> + <SPC> rootIdx <SPC> - <SPC> iStart <SPC> - <SPC> 1 , <NL>          iStart , <NL>          rootIdx <SPC> - <SPC> 1 , <NL> <TAB> ) <NL> <TAB> root . right <SPC> = <SPC> self . buildTreeUtil ( <NL>          inorder , <NL>          postorder , <NL>          inOrderMap , <NL>          pStart <SPC> + <SPC> rootIdx <SPC> - <SPC> iStart , <NL>          pEnd <SPC> - <SPC> 1 , <NL>          rootIdx <SPC> + <SPC> 1 , <NL>          iEnd , <NL> <TAB> ) <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> levelOrderBottom ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <NL> <TAB> stack <SPC> = <SPC> [ [ root ] ] <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> len ( stack ) <SPC> > <SPC> 0 : <NL>          top <SPC> = <SPC> stack . pop ( ) <NL>          res . insert ( 0 , <SPC> [ t . val <SPC> for <SPC> t <SPC> in <SPC> top ] ) <NL>          temp <SPC> = <SPC> [ ] <NL>          for <SPC> node <SPC> in <SPC> top : <NL>              if <SPC> node . left <SPC> is <SPC> not <SPC> None : <NL>                  temp . append ( node . left ) <NL>              if <SPC> node . right <SPC> is <SPC> not <SPC> None : <NL>                  temp . append ( node . right ) <NL>          if <SPC> len ( temp ) <SPC> > <SPC> 0 : <NL>              stack . append ( temp ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> duplicateZeros ( self , <SPC> arr : <SPC> List [ int ] ) <SPC> -> <SPC> None : <NL> <NL> <TAB> move_pos <SPC> = <SPC> 0 <NL> <TAB> last_pos <SPC> = <SPC> len ( arr ) <SPC> - <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( last_pos <SPC> + <SPC> 1 ) : <NL> <NL>          if <SPC> i <SPC> > <SPC> last_pos <SPC> - <SPC> move_pos : <NL>              break <NL>          if <SPC> arr [ i ] <SPC> == <SPC> 0 : <NL> <NL>              if <SPC> i <SPC> == <SPC> last_pos <SPC> - <SPC> move_pos : <NL>                  arr [ last_pos ] <SPC> = <SPC> 0 <NL>                  last_pos <SPC> -= <SPC> 1 <NL>                  break <NL>              move_pos <SPC> += <SPC> 1 <NL> <TAB> last_pos <SPC> -= <SPC> move_pos <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( last , <SPC> - 1 , <SPC> - 1 ) : <NL>          if <SPC> arr [ i ] <SPC> == <SPC> 0 : <NL>              arr [ i <SPC> + <SPC> move_pos ] <SPC> = <SPC> 0 <NL>              move_pos <SPC> -= <SPC> 1 <NL>              arr [ i <SPC> + <SPC> move_pos ] <SPC> = <SPC> 0 <NL>          else : <NL>              arr [ i <SPC> + <SPC> move_pos ] <SPC> = <SPC> arr [ i ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> sortedArrayToBST ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> self . getHelper ( nums , <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 ) <NL> <NL> <TAB> def <SPC> getHelper ( self , <SPC> nums , <SPC> start , <SPC> end ) : <NL> <TAB> if <SPC> start <SPC> > <SPC> end : <NL>          return <SPC> None <NL> <TAB> mid <SPC> = <SPC> ( start <SPC> + <SPC> end ) <SPC> / <SPC> 2 <NL> <TAB> node <SPC> = <SPC> TreeNode ( nums [ mid ] ) <NL> <TAB> node . left <SPC> = <SPC> self . getHelper ( nums , <SPC> start , <SPC> mid <SPC> - <SPC> 1 ) <NL> <TAB> node . right <SPC> = <SPC> self . getHelper ( nums , <SPC> mid <SPC> + <SPC> 1 , <SPC> end ) <NL> <TAB> return <SPC> node <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . node <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> sortedListToBST ( self , <SPC> head ) : <NL> <NL> <TAB> if <SPC> head <SPC> is <SPC> None : <NL>          return <SPC> head <NL> <TAB> size <SPC> = <SPC> 0 <NL> <TAB> pos <SPC> = <SPC> self . node <SPC> = <SPC> head <NL> <TAB> while <SPC> pos <SPC> is <SPC> not <SPC> None : <NL>          pos <SPC> = <SPC> pos . next <NL>          size <SPC> += <SPC> 1 <NL> <TAB> return <SPC> self . inorderHelper ( 0 , <SPC> size <SPC> - <SPC> 1 ) <NL> <NL> <TAB> def <SPC> inorderHelper ( self , <SPC> start , <SPC> end ) : <NL> <TAB> if <SPC> start <SPC> > <SPC> end : <NL>          return <SPC> None <NL> <TAB> mid <SPC> = <SPC> ( start <SPC> + <SPC> end ) <SPC> / <SPC> 2 <NL> <NL> <TAB> left <SPC> = <SPC> self . inorderHelper ( start , <SPC> mid <SPC> - <SPC> 1 ) <NL> <NL> <TAB> root <SPC> = <SPC> TreeNode ( self . node . val ) <NL> <TAB> root . left <SPC> = <SPC> left <NL> <TAB> self . node <SPC> = <SPC> self . node . next <NL> <NL> <TAB> root . right <SPC> = <SPC> self . inorderHelper ( mid <SPC> + <SPC> 1 , <SPC> end ) <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> defangIPaddr ( self , <SPC> address : <SPC> str ) <SPC> -> <SPC> str : <NL> <NL> <TAB> return <SPC> address . replace ( "." , <SPC> "[.]" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isBalanced ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <TAB> if <SPC> self . getDepth ( root ) <SPC> < <SPC> 0 : <NL>          return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> getDepth ( self , <SPC> node ) : <NL> <TAB> if <SPC> node <SPC> is <SPC> None : <NL>          return <SPC> 1 <NL> <TAB> ld <SPC> = <SPC> self . getDepth ( node . left ) <NL> <TAB> if <SPC> ld <SPC> < <SPC> 0 : <NL>          return <SPC> - 1 <NL> <TAB> rd <SPC> = <SPC> self . getDepth ( node . right ) <NL> <TAB> if <SPC> rd <SPC> < <SPC> 0 : <NL>          return <SPC> - 1 <NL> <TAB> elif <SPC> abs ( ld <SPC> - <SPC> rd ) <SPC> > <SPC> 1 : <NL>          return <SPC> - 1 <NL> <TAB> else : <NL>          return <SPC> max ( ld , <SPC> rd ) <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> minDepth ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <TAB> queue <SPC> = <SPC> [ root ] <NL> <TAB> depth , <SPC> rightMost <SPC> = <SPC> 1 , <SPC> root <NL> <TAB> while <SPC> len ( queue ) <SPC> > <SPC> 0 : <NL>          node <SPC> = <SPC> queue . pop ( 0 ) <NL>          if <SPC> node . left <SPC> is <SPC> None <SPC> and <SPC> node . right <SPC> is <SPC> None : <NL>              break <NL>          if <SPC> node . left <SPC> is <SPC> not <SPC> None : <NL>              queue . append ( node . left ) <NL>          if <SPC> node . right <SPC> is <SPC> not <SPC> None : <NL>              queue . append ( node . right ) <NL>          if <SPC> node <SPC> == <SPC> rightMost : <NL> <NL>              depth <SPC> += <SPC> 1 <NL>              if <SPC> node . right <SPC> is <SPC> not <SPC> None : <NL>                  rightMost <SPC> = <SPC> node . right <NL>              else : <NL>                  rightMost <SPC> = <SPC> node . left <NL> <TAB> return <SPC> depth <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> hasPathSum ( self , <SPC> root , <SPC> sum ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> False <NL> <TAB> sum <SPC> = <SPC> sum <SPC> - <SPC> root . val <NL> <TAB> if <SPC> sum <SPC> == <SPC> 0 <SPC> and <SPC> root . left <SPC> is <SPC> None <SPC> and <SPC> root . right <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <NL> <TAB> left <SPC> = <SPC> self . hasPathSum ( root . left , <SPC> sum ) <NL> <NL> <TAB> right <SPC> = <SPC> self . hasPathSum ( root . right , <SPC> sum ) <NL> <TAB> return <SPC> left <SPC> or <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pathSum ( self , <SPC> root , <SPC> sum ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> res <NL> <TAB> if <SPC> sum <SPC> == <SPC> root . val <SPC> and <SPC> root . left <SPC> is <SPC> None <SPC> and <SPC> root . right <SPC> is <SPC> None : <NL>          return <SPC> [ [ root . val ] ] <NL> <NL> <TAB> left_res <SPC> = <SPC> self . pathSum ( root . left , <SPC> sum <SPC> - <SPC> root . val ) <NL> <NL> <TAB> right_res <SPC> = <SPC> self . pathSum ( root . right , <SPC> sum <SPC> - <SPC> root . val ) <NL> <NL> <TAB> for <SPC> t <SPC> in <SPC> left_res <SPC> + <SPC> right_res : <NL>          res . append ( [ root . val ] <SPC> + <SPC> t ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> flatten ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <NL> <TAB> if <SPC> root . left <SPC> is <SPC> None <SPC> and <SPC> root . right <SPC> is <SPC> None : <NL>          return <NL> <TAB> current <SPC> = <SPC> root <NL> <TAB> stack <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> stack : <NL>          node <SPC> = <SPC> stack . pop ( ) <NL>          self . appendNode ( stack , <SPC> node . right ) <NL>          self . appendNode ( stack , <SPC> node . left ) <NL>          if <SPC> current <SPC> != <SPC> node : <NL>              current . right <SPC> = <SPC> node <NL>              current . left <SPC> = <SPC> None <NL>              current <SPC> = <SPC> node <NL> <NL> <TAB> def <SPC> appendNode ( self , <SPC> stack , <SPC> node ) : <NL> <TAB> if <SPC> node : <NL>          stack . append ( node ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numDistinct ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> j <SPC> in <SPC> xrange ( 0 , <SPC> len ( t ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( 0 , <SPC> len ( s ) <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( t ) <SPC> + <SPC> 1 ) : <NL>          dp [ 0 ] [ j ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> + <SPC> 1 ) : <NL>          dp [ i ] [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( t ) <SPC> + <SPC> 1 ) : <NL>              dp [ i ] [ j ] <SPC> = <SPC> dp [ i <SPC> - <SPC> 1 ] [ j ] <SPC> + <SPC> dp [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> * <SPC> ( s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> t [ j <SPC> - <SPC> 1 ] ) <NL> <NL> <TAB> return <SPC> dp [ - 1 ] [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> connect ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <NL> <TAB> nodes <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> len ( nodes ) <SPC> != <SPC> 0 : <NL>          next_step <SPC> = <SPC> [ ] <NL>          last <SPC> = <SPC> None <NL>          for <SPC> node <SPC> in <SPC> nodes : <NL>              if <SPC> last <SPC> is <SPC> not <SPC> None : <NL>                  last . next <SPC> = <SPC> node <NL>              if <SPC> node . left <SPC> is <SPC> not <SPC> None : <NL>                  next_step . append ( node . left ) <NL>              if <SPC> node . right <SPC> is <SPC> not <SPC> None : <NL>                  next_step . append ( node . right ) <NL>              last <SPC> = <SPC> node <NL>          nodes <SPC> = <SPC> next_step <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> connect ( self , <SPC> root ) : <NL> <NL> <TAB> dummyHead <SPC> = <SPC> TreeLinkNode ( - 1 ) <NL> <TAB> pre <SPC> = <SPC> dummyHead <NL> <TAB> while <SPC> root <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> root . left <SPC> is <SPC> not <SPC> None : <NL>              pre . next <SPC> = <SPC> root . left <NL>              pre <SPC> = <SPC> pre . next <NL>          if <SPC> root . right <SPC> is <SPC> not <SPC> None : <NL>              pre . next <SPC> = <SPC> root . right <NL>              pre <SPC> = <SPC> pre . next <NL>          root <SPC> = <SPC> root . next <NL>          if <SPC> root <SPC> is <SPC> None : <NL>              pre <SPC> = <SPC> dummyHead <NL>              root <SPC> = <SPC> dummyHead . next <NL>              dummyHead . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> generate ( self , <SPC> numRows ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( numRows ) : <NL>          result . append ( [ 0 ] <SPC> * <SPC> ( i <SPC> + <SPC> 1 ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( numRows ) : <NL>          for <SPC> j <SPC> in <SPC> range ( i <SPC> + <SPC> 1 ) : <NL>              if <SPC> j <SPC> == <SPC> 0 <SPC> or <SPC> j <SPC> == <SPC> i : <NL>                  result [ i ] [ j ] <SPC> = <SPC> 1 <NL>              else : <NL>                  result [ i ] [ j ] <SPC> = <SPC> result [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> result [ i <SPC> - <SPC> 1 ] [ j ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getRow ( self , <SPC> rowIndex ) : <NL> <NL> <TAB> last <SPC> = <SPC> [ 1 ] <NL> <TAB> res <SPC> = <SPC> [ 1 ] <NL> <TAB> for <SPC> r <SPC> in <SPC> range ( 1 , <SPC> rowIndex <SPC> + <SPC> 1 ) : <NL>          res <SPC> = <SPC> [ 1 ] <NL>          for <SPC> index <SPC> in <SPC> range ( len ( last ) <SPC> - <SPC> 1 ) : <NL>              res . append ( last [ index ] <SPC> + <SPC> last [ index <SPC> + <SPC> 1 ] ) <NL>          res . append ( 1 ) <NL>          last <SPC> = <SPC> res <NL> <TAB> return <SPC> res <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . getRow ( 3 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumTotal ( self , <SPC> triangle ) : <NL> <NL> <TAB> if <SPC> triangle <SPC> is <SPC> None <SPC> or <SPC> len ( triangle ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> ls <SPC> = <SPC> len ( triangle ) <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ls <NL> <TAB> dp [ 0 ] <SPC> = <SPC> triangle [ 0 ] [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> ls ) : <NL> <NL>          dp [ i ] <SPC> = <SPC> dp [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> triangle [ i ] [ i ] <NL>          for <SPC> j <SPC> in <SPC> reversed ( range ( 1 , <SPC> i ) ) : <NL>              dp [ j ] <SPC> = <SPC> min ( dp [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> triangle [ i ] [ j ] , <SPC> dp [ j ] <SPC> + <SPC> triangle [ i ] [ j ] ) <NL>          dp [ 0 ] <SPC> = <SPC> dp [ 0 ] <SPC> + <SPC> triangle [ i ] [ 0 ] <NL> <TAB> return <SPC> min ( dp ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProfit ( self , <SPC> prices ) : <NL> <NL> <TAB> length <SPC> = <SPC> len ( prices ) <NL> <TAB> if <SPC> length <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> max_profit , <SPC> low <SPC> = <SPC> 0 , <SPC> prices [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> length ) : <NL>          if <SPC> low <SPC> > <SPC> prices [ i ] : <NL>              low <SPC> = <SPC> prices [ i ] <NL>          else : <NL>              temp <SPC> = <SPC> prices [ i ] <SPC> - <SPC> low <NL>              if <SPC> temp <SPC> > <SPC> max_profit : <NL>                  max_profit <SPC> = <SPC> temp <NL> <TAB> return <SPC> max_profit <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProfit ( self , <SPC> prices ) : <NL> <NL> <TAB> return <SPC> sum ( [ y <SPC> - <SPC> x <SPC> for <SPC> x , <SPC> y <SPC> in <SPC> zip ( prices [ 0 : - 1 ] , <SPC> prices [ 1 : ] ) <SPC> if <SPC> x <SPC> < <SPC> y ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maxProfit ( self , <SPC> prices ) : <NL> <TAB> ls <SPC> = <SPC> len ( prices ) <NL> <TAB> if <SPC> ls <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> b1 <SPC> = <SPC> b2 <SPC> = <SPC> - prices [ 0 ] <NL> <TAB> s1 <SPC> = <SPC> s2 <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> ls ) : <NL>          s2 <SPC> = <SPC> max ( s2 , <SPC> b2 <SPC> + <SPC> prices [ i ] ) <NL>          b2 <SPC> = <SPC> max ( b2 , <SPC> s1 <SPC> - <SPC> prices [ i ] ) <NL>          s1 <SPC> = <SPC> max ( b1 <SPC> + <SPC> prices [ i ] , <SPC> s1 ) <NL>          b1 <SPC> = <SPC> max ( b1 , <SPC> - prices [ i ] ) <NL> <TAB> return <SPC> max ( s1 , <SPC> s2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . result <SPC> = <SPC> - 2147483647 <NL> <NL> <TAB> def <SPC> maxPathSum ( self , <SPC> root ) : <NL> <NL> <TAB> self . getNodeMaxValue ( root ) <NL> <TAB> return <SPC> self . result <NL> <NL> <TAB> def <SPC> getNodeMaxValue ( self , <SPC> node ) : <NL> <TAB> if <SPC> node <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <TAB> lresult <SPC> = <SPC> self . getNodeMaxValue ( node . left ) <NL> <TAB> rresult <SPC> = <SPC> self . getNodeMaxValue ( node . right ) <NL> <TAB> self . result <SPC> = <SPC> max ( lresult <SPC> + <SPC> rresult <SPC> + <SPC> node . val , <SPC> self . result ) <NL> <TAB> ret <SPC> = <SPC> node . val <SPC> + <SPC> max ( lresult , <SPC> rresult ) <NL> <NL> <TAB> if <SPC> ret <SPC> > <SPC> 0 : <NL>          return <SPC> ret <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPalindrome ( self , <SPC> s ) : <NL> <NL> <TAB> alnum_s <SPC> = <SPC> [ t . lower ( ) <SPC> for <SPC> t <SPC> in <SPC> s <SPC> if <SPC> t . isalnum ( ) ] <NL> <TAB> ls <SPC> = <SPC> len ( alnum_s ) <NL> <TAB> if <SPC> ls <SPC> <= <SPC> 1 : <NL>          return <SPC> True <NL> <TAB> mid <SPC> = <SPC> ls <SPC> / <SPC> 2 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( mid ) : <NL>          if <SPC> alnum_s [ i ] <SPC> != <SPC> alnum_s [ ls <SPC> - <SPC> 1 <SPC> - <SPC> i ] : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shiftGrid ( self , <SPC> grid , <SPC> k ) : <NL> <NL> <TAB> new_grid <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( grid [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> range ( len ( grid ) ) ] <NL> <TAB> m <SPC> = <SPC> len ( grid ) <NL> <TAB> n <SPC> = <SPC> len ( grid [ 0 ] ) <NL> <NL> <TAB> true_k <SPC> = <SPC> k <SPC> % <SPC> ( m <SPC> * <SPC> n ) <NL> <NL> <TAB> move_i <SPC> = <SPC> true_k <SPC> / <SPC> n <NL> <NL> <TAB> move_j <SPC> = <SPC> true_k <SPC> % <SPC> n <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( m ) : <NL>          for <SPC> j <SPC> in <SPC> range ( n ) : <NL>              new_i <SPC> = <SPC> i <SPC> + <SPC> move_i <NL> <NL>              if <SPC> move_j <SPC> + <SPC> j <SPC> >= <SPC> n : <NL>                  new_i <SPC> += <SPC> 1 <NL>              new_i <SPC> %= <SPC> m <NL>              new_j <SPC> = <SPC> ( j <SPC> + <SPC> move_j ) <SPC> % <SPC> n <NL>              new_grid [ new_i ] [ new_j ] <SPC> = <SPC> grid [ i ] [ j ] <NL> <TAB> return <SPC> new_grid <NL> <NL> <NL> import <SPC> string <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> findLadders ( self , <SPC> beginWord , <SPC> endWord , <SPC> wordlist ) : <NL> <NL> <TAB> wordlist . discard ( beginWord ) <NL> <TAB> wordlist . discard ( endWord ) <NL> <TAB> hash_map , <SPC> res <SPC> = <SPC> { } , <SPC> [ ] <NL> <TAB> self . bfs ( set ( [ beginWord ] ) , <SPC> set ( [ endWord ] ) , <SPC> wordlist , <SPC> False , <SPC> hash_map ) <NL> <TAB> print <SPC> hash_map <NL> <TAB> self . dfs ( res , <SPC> [ beginWord ] , <SPC> beginWord , <SPC> endWord , <SPC> hash_map ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> bfs ( self , <SPC> forward , <SPC> backward , <SPC> wordlist , <SPC> reverse , <SPC> hash_map ) : <NL> <TAB> if <SPC> len ( forward ) <SPC> == <SPC> 0 <SPC> or <SPC> len ( backward ) <SPC> == <SPC> 0 : <NL>          return <NL> <TAB> if <SPC> len ( forward ) <SPC> > <SPC> len ( backward ) : <NL>          self . bfs ( backward , <SPC> forward , <SPC> wordlist , <SPC> not <SPC> reverse , <SPC> hash_map ) <NL>          return <NL> <TAB> is_connected <SPC> = <SPC> False <NL> <TAB> next_level <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> word <SPC> in <SPC> forward : <NL>          for <SPC> c <SPC> in <SPC> string . ascii_lowercase : <NL>              for <SPC> index <SPC> in <SPC> range ( len ( word ) ) : <NL>                  neigh <SPC> = <SPC> word [ : index ] <SPC> + <SPC> c <SPC> + <SPC> word [ index <SPC> + <SPC> 1 : ] <NL>                  if <SPC> not <SPC> reverse : <NL>                      key , <SPC> value <SPC> = <SPC> word , <SPC> neigh <NL>                  else : <NL>                      key , <SPC> value <SPC> = <SPC> neigh , <SPC> word <NL>                  if <SPC> neigh <SPC> in <SPC> backward : <NL>                      hash_map [ key ] <SPC> = <SPC> hash_map . get ( key , <SPC> [ ] ) <SPC> + <SPC> [ value ] <NL>                      is_connected <SPC> = <SPC> True <NL>                  if <SPC> not <SPC> is_connected <SPC> and <SPC> neigh <SPC> in <SPC> wordlist : <NL>                      next_level . add ( neigh ) <NL>                      hash_map [ key ] <SPC> = <SPC> hash_map . get ( key , <SPC> [ ] ) <SPC> + <SPC> [ value ] <NL>                      wordlist . discard ( neigh ) <NL> <NL> <TAB> if <SPC> not <SPC> is_connected : <NL>          self . bfs ( next_level , <SPC> backward , <SPC> wordlist , <SPC> reverse , <SPC> hash_map ) <NL> <NL> <TAB> def <SPC> dfs ( self , <SPC> res , <SPC> path , <SPC> begin , <SPC> end , <SPC> hash_map ) : <NL> <TAB> if <SPC> begin <SPC> == <SPC> end : <NL>          res . append ( path ) <NL>          return <NL> <TAB> try : <NL>          next_step <SPC> = <SPC> hash_map [ begin ] <NL>          for <SPC> word <SPC> in <SPC> next_step : <NL>              self . dfs ( res , <SPC> path <SPC> + <SPC> [ word ] , <SPC> word , <SPC> end , <SPC> hash_map ) <NL> <TAB> except <SPC> KeyError : <NL>          pass <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <NL> <TAB> print <SPC> s . findLadders ( <NL>          "hot" , <SPC> "dog" , <SPC> set ( [ "hot" , <SPC> "cog" , <SPC> "dog" , <SPC> "tot" , <NL>                            "hog" , <SPC> "hop" , <SPC> "pot" , <SPC> "dot" ] ) <NL> <TAB> ) <NL> import <SPC> string <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> ladderLength ( self , <SPC> beginWord , <SPC> endWord , <SPC> wordList ) : <NL> <NL> <TAB> wordList . discard ( beginWord ) <NL> <TAB> wordList . discard ( endWord ) <NL> <TAB> hash_map , <SPC> res <SPC> = <SPC> { } , <SPC> [ ] <NL> <TAB> res <SPC> = <SPC> self . bfs ( set ( [ beginWord ] ) , <SPC> set ( [ endWord ] ) , <SPC> wordList , <SPC> 2 ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> bfs ( self , <SPC> forward , <SPC> backward , <SPC> wordlist , <SPC> level ) : <NL> <TAB> if <SPC> len ( forward ) <SPC> == <SPC> 0 <SPC> or <SPC> len ( backward ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> if <SPC> len ( forward ) <SPC> > <SPC> len ( backward ) : <NL>          return <SPC> self . bfs ( backward , <SPC> forward , <SPC> wordlist , <SPC> level ) <NL> <TAB> is_connected <SPC> = <SPC> False <NL> <TAB> next_level <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> word <SPC> in <SPC> forward : <NL>          for <SPC> c <SPC> in <SPC> string . ascii_lowercase : <NL>              for <SPC> index <SPC> in <SPC> range ( len ( word ) ) : <NL>                  neigh <SPC> = <SPC> word [ : index ] <SPC> + <SPC> c <SPC> + <SPC> word [ index <SPC> + <SPC> 1 : ] <NL>                  if <SPC> neigh <SPC> in <SPC> backward : <NL>                      is_connected <SPC> = <SPC> True <NL>                      return <SPC> level <NL>                  if <SPC> not <SPC> is_connected <SPC> and <SPC> neigh <SPC> in <SPC> wordlist : <NL>                      next_level . add ( neigh ) <NL>                      wordlist . discard ( neigh ) <NL> <TAB> if <SPC> not <SPC> is_connected : <NL>          return <SPC> self . bfs ( next_level , <SPC> backward , <SPC> wordlist , <SPC> level <SPC> + <SPC> 1 ) <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestConsecutive ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> longestConsecutive ( self , <SPC> num ) : <NL> <NL>          num <SPC> = <SPC> set ( num ) <NL>          maxLen <SPC> = <SPC> 0 <NL>          while <SPC> num : <NL>              n <SPC> = <SPC> num . pop ( ) <NL>              i <SPC> = <SPC> n <SPC> + <SPC> 1 <NL>              l1 <SPC> = <SPC> 0 <NL>              l2 <SPC> = <SPC> 0 <NL>              while <SPC> i <SPC> in <SPC> num : <NL>                  num . remove ( i ) <NL>                  i <SPC> += <SPC> 1 <NL>                  l1 <SPC> += <SPC> 1 <NL>              i <SPC> = <SPC> n <SPC> - <SPC> 1 <NL>              while <SPC> i <SPC> in <SPC> num : <NL>                  num . remove ( i ) <NL>                  i <SPC> -= <SPC> 1 <NL>                  l2 <SPC> += <SPC> 1 <NL>              maxLen <SPC> = <SPC> max ( maxLen , <SPC> l1 <SPC> + <SPC> l2 <SPC> + <SPC> 1 ) <NL>          return <SPC> maxLen <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> getDecimalValue ( self , <SPC> head : <SPC> ListNode ) <SPC> -> <SPC> int : <NL> <TAB> binary_numbers_list <SPC> = <SPC> [ ] <NL> <TAB> binary_numbers_list . append ( head . val ) <NL> <TAB> while <SPC> head . next <SPC> is <SPC> not <SPC> None : <NL>          head <SPC> = <SPC> head . next <NL>          binary_numbers_list . append ( head . val ) <NL> <TAB> answer <SPC> = <SPC> 0 <NL> <TAB> power <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> digit <SPC> in <SPC> range ( len ( binary_numbers_list ) <SPC> - <SPC> 1 , <SPC> - 1 , <SPC> - 1 ) : <NL>          if <SPC> binary_numbers_list [ digit ] <SPC> > <SPC> 0 : <NL>              answer <SPC> += <SPC> ( 2 <SPC> ** <SPC> power ) <SPC> * <SPC> binary_numbers_list [ digit ] <NL>          power <SPC> += <SPC> 1 <NL> <TAB> return <SPC> answer <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumNumbers ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <TAB> res <SPC> = <SPC> 0 <NL> <NL> <TAB> queue <SPC> = <SPC> [ ( root , <SPC> root . val ) ] <NL> <TAB> while <SPC> len ( queue ) <SPC> > <SPC> 0 : <NL>          curr , <SPC> curr_value <SPC> = <SPC> queue . pop ( 0 ) <NL>          if <SPC> curr . left <SPC> is <SPC> None <SPC> and <SPC> curr . right <SPC> is <SPC> None : <NL>              res <SPC> += <SPC> curr_value <NL>              continue <NL>          if <SPC> curr . left : <NL>              queue . append ( ( curr . left , <SPC> curr_value <SPC> * <SPC> 10 <SPC> + <SPC> curr . left . val ) ) <NL>          if <SPC> curr . right : <NL>              queue . append ( ( curr . right , <SPC> curr_value <SPC> * <SPC> 10 <SPC> + <SPC> curr . right . val ) ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> sumZero ( self , <SPC> n : <SPC> int ) <SPC> -> <SPC> List [ int ] : <NL> <TAB> prefix_sum <SPC> = <SPC> 0 <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> n ) : <NL>          res . append ( i ) <NL>          prefix_sum <SPC> = <SPC> prefix_sum <SPC> + <SPC> i <NL> <NL> <TAB> res . append ( - prefix_sum ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> solve ( self , <SPC> board ) : <NL> <NL> <TAB> if <SPC> not <SPC> board : <NL>          return <NL> <TAB> height , <SPC> width <SPC> = <SPC> len ( board ) , <SPC> len ( board [ 0 ] ) <NL> <TAB> leakWall <SPC> = <SPC> self . buildLeakWall ( board ) <NL> <TAB> while <SPC> leakWall : <NL>          i , <SPC> j <SPC> = <SPC> leakWall . pop ( ) <NL>          if <SPC> 0 <SPC> <= <SPC> i <SPC> < <SPC> height <SPC> and <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> width : <NL>              if <SPC> board [ i ] [ j ] <SPC> == <SPC> "O" : <NL>                  board [ i ] [ j ] <SPC> = <SPC> "S" <NL>                  leakWall <SPC> += <SPC> ( i <SPC> - <SPC> 1 , <SPC> j ) , <SPC> ( i <SPC> + <SPC> 1 , <SPC> j ) , <SPC> ( i , <SPC> j <SPC> - <SPC> 1 ) , <SPC> ( i , <SPC> j <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( height ) : <NL>          for <SPC> j <SPC> in <SPC> range ( width ) : <NL>              board [ i ] [ j ] <SPC> = <SPC> "O" <SPC> if <SPC> board [ i ] [ j ] <SPC> == <SPC> "S" <SPC> else <SPC> "X" <NL> <NL> <TAB> def <SPC> buildLeakWall ( self , <SPC> board ) : <NL> <TAB> leakWall , <SPC> height , <SPC> width <SPC> = <SPC> [ ] , <SPC> len ( board ) , <SPC> len ( board [ 0 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( height ) : <NL>          if <SPC> board [ i ] [ 0 ] <SPC> == <SPC> "O" : <NL>              leakWall . append ( ( i , <SPC> 0 ) ) <NL>          if <SPC> board [ i ] [ width <SPC> - <SPC> 1 ] <SPC> == <SPC> "O" : <NL>              leakWall . append ( ( i , <SPC> width <SPC> - <SPC> 1 ) ) <NL> <TAB> for <SPC> j <SPC> in <SPC> range ( width ) : <NL>          if <SPC> board [ 0 ] [ j ] <SPC> == <SPC> "O" : <NL>              leakWall . append ( ( 0 , <SPC> j ) ) <NL>          if <SPC> board [ height <SPC> - <SPC> 1 ] [ j ] <SPC> == <SPC> "O" : <NL>              leakWall . append ( ( height <SPC> - <SPC> 1 , <SPC> j ) ) <NL> <TAB> return <SPC> leakWall <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> xorQueries ( self , <SPC> arr : <SPC> List [ int ] , <SPC> queries : <SPC> List [ List [ int ] ] ) <SPC> -> <SPC> List [ int ] : <NL> <TAB> pref <SPC> = <SPC> [ 0 ] <NL> <NL> <TAB> for <SPC> e <SPC> in <SPC> arr : <NL>          pref . append ( e <SPC> ^ <SPC> pref [ - 1 ] ) <NL> <TAB> ans <SPC> = <SPC> [ ] <NL> <NL> <TAB> for <SPC> [ l , <SPC> r ] <SPC> in <SPC> queries : <NL>          ans . append ( pref [ r <SPC> + <SPC> 1 ] <SPC> ^ <SPC> pref [ l ] ) <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> partition ( self , <SPC> s ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> curr <SPC> = <SPC> [ ] <NL> <TAB> self . recurPartition ( result , <SPC> curr , <SPC> s , <SPC> 0 ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> recurPartition ( self , <SPC> result , <SPC> curr , <SPC> s , <SPC> start ) : <NL> <TAB> if <SPC> start <SPC> == <SPC> len ( s ) : <NL>          result . append ( list ( curr ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( start , <SPC> len ( s ) ) : <NL>          if <SPC> self . isPalindrome ( s , <SPC> start , <SPC> i ) : <NL>              curr . append ( s [ start : <SPC> i <SPC> + <SPC> 1 ] ) <NL>              self . recurPartition ( result , <SPC> curr , <SPC> s , <SPC> i <SPC> + <SPC> 1 ) <NL>              curr . pop ( ) <NL> <NL> <TAB> def <SPC> isPalindrome ( self , <SPC> s , <SPC> begin , <SPC> end ) : <NL> <TAB> while <SPC> begin <SPC> < <SPC> end : <NL>          if <SPC> s [ begin ] <SPC> != <SPC> s [ end ] : <NL>              return <SPC> False <NL>          begin <SPC> += <SPC> 1 <NL>          end <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> maximum69Number ( self , <SPC> num : <SPC> int ) <SPC> -> <SPC> int : <NL> <NL> <TAB> return <SPC> str ( num ) . replace ( "6" , <SPC> "9" , <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( s ) <NL> <TAB> cut <SPC> = <SPC> [ i <SPC> - <SPC> 1 <SPC> for <SPC> i <SPC> in <SPC> range ( ls <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls ) : <NL> <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> - <SPC> pos <SPC> >= <SPC> 0 <SPC> and <SPC> i <SPC> + <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> s [ i <SPC> - <SPC> pos ] <SPC> == <SPC> s [ i <SPC> + <SPC> pos ] : <NL>          cut [ i <SPC> + <SPC> pos <SPC> + <SPC> 1 ] <SPC> = <SPC> min ( cut [ i <SPC> + <SPC> pos <SPC> + <SPC> 1 ] , <SPC> 1 <SPC> + <SPC> cut [ i <SPC> - <SPC> pos ] ) <NL>          pos <SPC> += <SPC> 1 <NL> <NL> <TAB> pos <SPC> = <SPC> 1 <NL> <TAB> while <SPC> i <SPC> - <SPC> pos <SPC> + <SPC> 1 <SPC> >= <SPC> 0 <SPC> and <SPC> i <SPC> + <SPC> pos <SPC> < <SPC> ls <SPC> and <SPC> s [ i <SPC> - <SPC> pos <SPC> + <SPC> 1 ] <SPC> == <SPC> s [ i <SPC> + <SPC> pos ] : <NL>          cut [ i <SPC> + <SPC> pos <SPC> + <SPC> 1 ] <SPC> = <SPC> min ( cut [ i <SPC> + <SPC> pos <SPC> + <SPC> 1 ] , <SPC> 1 <SPC> + <SPC> cut [ i <SPC> - <SPC> pos <SPC> + <SPC> 1 ] ) <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> return <SPC> cut [ ls ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kWeakestRows ( self , <SPC> mat , <SPC> k ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> num_row <SPC> = <SPC> len ( mat ) <NL> <TAB> num_col <SPC> = <SPC> len ( mat [ 0 ] ) <NL> <TAB> col <SPC> = <SPC> 0 <NL> <TAB> flag <SPC> = <SPC> 1 <NL> <TAB> while <SPC> col <SPC> < <SPC> num_col <SPC> and <SPC> flag : <NL>          for <SPC> i <SPC> in <SPC> range ( num_row ) : <NL>              if <SPC> i <SPC> in <SPC> res : <NL>                  continue <NL> <NL>              if <SPC> mat [ i ] [ col ] <SPC> == <SPC> 0 : <NL>                  res . append ( i ) <NL>              if <SPC> len ( res ) <SPC> == <SPC> k : <NL>                  flag <SPC> = <SPC> 0 <NL>                  break <NL>          col <SPC> += <SPC> 1 <NL> <TAB> if <SPC> len ( res ) <SPC> == <SPC> k : <NL>          return <SPC> res <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( num_row ) : <NL>          if <SPC> i <SPC> in <SPC> res : <NL>              continue <NL>          res . append ( i ) <NL>          if <SPC> len ( res ) <SPC> == <SPC> k : <NL>              break <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> cloneGraph ( self , <SPC> node ) : <NL> <NL> <TAB> if <SPC> node <SPC> is <SPC> None : <NL>          return <SPC> None <NL> <TAB> label_map <SPC> = <SPC> { } <NL> <TAB> queue <SPC> = <SPC> [ node ] <NL> <TAB> graphCopy <SPC> = <SPC> UndirectedGraphNode ( node . label ) <NL> <TAB> label_map [ node . label ] <SPC> = <SPC> graphCopy <NL> <TAB> while <SPC> len ( queue ) <SPC> > <SPC> 0 : <NL>          curr <SPC> = <SPC> queue . pop ( 0 ) <NL>          for <SPC> ne <SPC> in <SPC> curr . neighbors : <NL>              if <SPC> ne . label <SPC> in <SPC> label_map : <NL>                  label_map [ curr . label ] . neighbors . append ( label_map [ ne . label ] ) <NL>              else : <NL>                  neighborCopy <SPC> = <SPC> UndirectedGraphNode ( ne . label ) <NL>                  label_map [ curr . label ] . neighbors . append ( neighborCopy ) <NL>                  label_map [ ne . label ] <SPC> = <SPC> neighborCopy <NL>                  queue . append ( ne ) <NL> <TAB> return <SPC> graphCopy <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> numberOfSteps ( self , <SPC> num : <SPC> int ) <SPC> -> <SPC> int : <NL> <TAB> steps <SPC> = <SPC> 0 <NL> <TAB> while ( num <SPC> > <SPC> 0 ) : <NL>          if ( num <SPC> % <SPC> 2 <SPC> == <SPC> 0 ) : <NL>              num <SPC> = <SPC> num <SPC> / <SPC> 2 <NL>              steps <SPC> + <SPC> = 1 <NL>          else : <NL>              num <SPC> = <SPC> num <SPC> - <SPC> 1 <NL>              steps <SPC> += <SPC> 1 <NL> <TAB> return <SPC> steps <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canCompleteCircuit ( self , <SPC> gas , <SPC> cost ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( gas ) <NL> <TAB> begin , <SPC> end <SPC> = <SPC> 0 , <SPC> ls <SPC> - <SPC> 1 <NL> <TAB> curr <SPC> = <SPC> gas [ end ] <SPC> - <SPC> cost [ end ] <NL> <TAB> while <SPC> begin <SPC> < <SPC> end : <NL>          if <SPC> curr <SPC> >= <SPC> 0 : <NL>              curr <SPC> += <SPC> gas [ begin ] <SPC> - <SPC> cost [ begin ] <NL>              begin <SPC> += <SPC> 1 <NL>          else : <NL>              end <SPC> -= <SPC> 1 <NL>              curr <SPC> += <SPC> gas [ end ] <SPC> - <SPC> cost [ end ] <NL> <TAB> if <SPC> curr <SPC> >= <SPC> 0 : <NL>          return <SPC> end <NL> <TAB> else : <NL>          return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> candy ( self , <SPC> ratings ) : <NL> <NL> <TAB> if <SPC> ratings <SPC> is <SPC> None <SPC> or <SPC> len ( ratings ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> ls <SPC> = <SPC> len ( ratings ) <NL> <TAB> num <SPC> = <SPC> [ 1 ] <SPC> * <SPC> ls <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> ls ) : <NL>          if <SPC> ratings [ i ] <SPC> > <SPC> ratings [ i <SPC> - <SPC> 1 ] : <NL>              num [ i ] <SPC> = <SPC> num [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls <SPC> - <SPC> 1 , <SPC> 0 , <SPC> - 1 ) : <NL>          if <SPC> ratings [ i <SPC> - <SPC> 1 ] <SPC> > <SPC> ratings [ i ] : <NL>              num [ i <SPC> - <SPC> 1 ] <SPC> = <SPC> max ( num [ i ] <SPC> + <SPC> 1 , <SPC> num [ i <SPC> - <SPC> 1 ] ) <NL> <TAB> return <SPC> sum ( num ) <NL> <NL> <NL> class <SPC> Solution : <NL> <NL> <TAB> def <SPC> smallerNumbersThanCurrent ( self , <SPC> nums : <SPC> List [ int ] ) <SPC> -> <SPC> List [ int ] : <NL> <TAB> count_list <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 101 <NL> <NL> <TAB> for <SPC> v <SPC> in <SPC> nums : <NL>          count_list [ v ] <SPC> += <SPC> 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> 101 ) : <NL>          count_list [ i ] <SPC> += <SPC> count_list [ i <SPC> - <SPC> 1 ] <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> v <SPC> in <SPC> nums : <NL>          if <SPC> v <SPC> == <SPC> 0 : <NL>              res . append ( 0 ) <NL>          else : <NL>              res . append ( count_list [ v <SPC> - <SPC> 1 ] ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> singleNumber ( self , <SPC> nums ) : <NL> <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          res <SPC> ^= <SPC> num <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> singleNumber ( self , <SPC> nums ) : <NL> <NL> <TAB> ones , <SPC> twos , <SPC> threes <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          twos <SPC> |= <SPC> ones <SPC> & <SPC> num <NL>          ones <SPC> ^= <SPC> num <NL>          threes <SPC> = <SPC> ones <SPC> & <SPC> twos <NL>          ones <SPC> &= <SPC> ~ threes <NL>          twos <SPC> &= <SPC> ~ threes <NL> <TAB> return <SPC> ones <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> copyRandomList ( self , <SPC> head ) : <NL> <NL> <TAB> p <SPC> = <SPC> head <NL> <TAB> while <SPC> p <SPC> is <SPC> not <SPC> None : <NL>          next <SPC> = <SPC> p . next <NL>          copy <SPC> = <SPC> RandomListNode ( p . label ) <NL>          p . next <SPC> = <SPC> copy <NL>          copy . next <SPC> = <SPC> next <NL>          p <SPC> = <SPC> next <NL> <TAB> p <SPC> = <SPC> head <NL> <TAB> while <SPC> p <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> p . random <SPC> is <SPC> not <SPC> None : <NL>              p . next . random <SPC> = <SPC> p . random . next <NL>          p <SPC> = <SPC> p . next . next <NL> <TAB> p <SPC> = <SPC> head <NL> <TAB> if <SPC> p <SPC> is <SPC> not <SPC> None : <NL>          headCopy <SPC> = <SPC> p . next <NL> <TAB> else : <NL>          headCopy <SPC> = <SPC> None <NL> <TAB> while <SPC> p <SPC> is <SPC> not <SPC> None : <NL>          copy <SPC> = <SPC> p . next <NL>          p . next <SPC> = <SPC> copy . next <NL>          p <SPC> = <SPC> p . next <NL>          if <SPC> p <SPC> is <SPC> not <SPC> None : <NL>              copy . next <SPC> = <SPC> p . next <NL> <TAB> return <SPC> headCopy <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wordBreak ( self , <SPC> s , <SPC> wordDict ) : <NL> <NL> <TAB> queue <SPC> = <SPC> [ 0 ] <NL> <TAB> ls <SPC> = <SPC> len ( s ) <NL> <TAB> lenList <SPC> = <SPC> [ l <SPC> for <SPC> l <SPC> in <SPC> set ( map ( len , <SPC> wordDict ) ) ] <NL> <TAB> visited <SPC> = <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> range ( 0 , <SPC> ls <SPC> + <SPC> 1 ) ] <NL> <TAB> while <SPC> queue : <NL>          start <SPC> = <SPC> queue . pop ( 0 ) <NL>          for <SPC> l <SPC> in <SPC> lenList : <NL>              if <SPC> s [ start : <SPC> start <SPC> + <SPC> l ] <SPC> in <SPC> wordDict : <NL>                  if <SPC> start <SPC> + <SPC> l <SPC> == <SPC> ls : <NL>                      return <SPC> True <NL>                  if <SPC> visited [ start <SPC> + <SPC> l ] <SPC> == <SPC> 0 : <NL>                      queue . append ( start <SPC> + <SPC> l ) <NL>                      visited [ start <SPC> + <SPC> l ] <SPC> = <SPC> 1 <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . solution <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> wordBreak ( self , <SPC> s , <SPC> wordDict ) : <NL> <NL> <TAB> try : <NL>          return <SPC> self . solution [ s ] <NL> <TAB> except <SPC> KeyError : <NL>          pass <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> s <SPC> in <SPC> wordDict : <NL>          result . append ( s ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> len ( s ) ) : <NL>          word <SPC> = <SPC> s [ i : ] <NL>          if <SPC> word <SPC> in <SPC> wordDict : <NL>              rem <SPC> = <SPC> s [ : i ] <NL>              prev <SPC> = <SPC> self . wordBreak ( rem , <SPC> wordDict ) <NL>              result . extend ( [ res <SPC> + <SPC> " " <SPC> + <SPC> word <SPC> for <SPC> res <SPC> in <SPC> prev ] ) <NL> <TAB> self . solution [ s ] <SPC> = <SPC> result <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> hasCycle ( self , <SPC> head ) : <NL> <NL> <TAB> try : <NL>          fast <SPC> = <SPC> head . next . next <NL>          slow <SPC> = <SPC> head . next <NL> <NL>          while <SPC> fast <SPC> != <SPC> slow : <NL>              fast <SPC> = <SPC> fast . next . next <NL>              slow <SPC> = <SPC> slow . next <NL> <NL>          return <SPC> True <NL> <TAB> except : <NL>          return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> detectCycle ( self , <SPC> head ) : <NL> <NL> <TAB> try : <NL>          fast <SPC> = <SPC> head . next . next <NL>          slow <SPC> = <SPC> head . next <NL> <NL>          while <SPC> fast <SPC> != <SPC> slow : <NL>              fast <SPC> = <SPC> fast . next . next <NL>              slow <SPC> = <SPC> slow . next <NL> <TAB> except : <NL>          return <SPC> None <NL> <TAB> slow <SPC> = <SPC> head <NL> <TAB> while <SPC> fast <SPC> != <SPC> slow : <NL>          fast <SPC> = <SPC> fast . next <NL>          slow <SPC> = <SPC> slow . next <NL> <TAB> return <SPC> fast <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> reorderList ( self , <SPC> head ) : <NL> <NL> <TAB> if <SPC> head <SPC> is <SPC> None <SPC> or <SPC> head . next <SPC> is <SPC> None : <NL>          return <NL> <TAB> p1 , <SPC> p2 <SPC> = <SPC> head , <SPC> head . next <NL> <TAB> while <SPC> p2 <SPC> and <SPC> p2 . next : <NL>          p1 <SPC> = <SPC> p1 . next <NL>          p2 <SPC> = <SPC> p2 . next . next <NL> <TAB> head2 <SPC> = <SPC> p1 . next <NL> <TAB> p1 . next <SPC> = <SPC> None <NL> <TAB> p2 <SPC> = <SPC> head2 . next <NL> <TAB> head2 . next <SPC> = <SPC> None <NL> <NL> <TAB> while <SPC> p2 : <NL>          temp <SPC> = <SPC> p2 . next <NL>          p2 . next <SPC> = <SPC> head2 <NL>          head2 <SPC> = <SPC> p2 <NL>          p2 <SPC> = <SPC> temp <NL> <TAB> p1 , <SPC> p2 <SPC> = <SPC> head , <SPC> head2 <NL> <NL> <TAB> while <SPC> p1 : <NL>          temp <SPC> = <SPC> p1 . next <NL>          p1 . next <SPC> = <SPC> p2 <NL>          p1 <SPC> = <SPC> p1 . next <NL>          p2 <SPC> = <SPC> temp <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> preorderTraversal ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> stack <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> len ( stack ) <SPC> > <SPC> 0 : <NL>          curr <SPC> = <SPC> stack . pop ( ) <NL>          res . append ( curr . val ) <NL>          if <SPC> curr . right <SPC> is <SPC> not <SPC> None : <NL>              stack . append ( curr . right ) <NL>          if <SPC> curr . left <SPC> is <SPC> not <SPC> None : <NL>              stack . append ( curr . left ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> postorderTraversal ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> stack <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> len ( stack ) <SPC> > <SPC> 0 : <NL>          curr <SPC> = <SPC> stack . pop ( ) <NL>          if <SPC> not <SPC> isinstance ( curr , <SPC> TreeNode ) : <NL>              res . append ( curr ) <NL>              continue <NL>          stack . append ( curr . val ) <NL>          if <SPC> curr . right <SPC> is <SPC> not <SPC> None : <NL>              stack . append ( curr . right ) <NL>          if <SPC> curr . left <SPC> is <SPC> not <SPC> None : <NL>              stack . append ( curr . left ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> LRUCache ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> capacity ) : <NL> <NL> <TAB> self . capacity <SPC> = <SPC> capacity <NL> <TAB> self . cache <SPC> = <SPC> { } <NL> <TAB> self . queue <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> updateQueue ( self , <SPC> key ) : <NL> <TAB> self . queue . remove ( key ) <NL> <TAB> self . queue . insert ( 0 , <SPC> key ) <NL> <NL> <TAB> def <SPC> get ( self , <SPC> key ) : <NL> <NL> <TAB> if <SPC> key <SPC> in <SPC> self . cache : <NL>          self . updateQueue ( key ) <NL>          return <SPC> self . cache [ key ] <NL> <TAB> else : <NL>          return <SPC> - 1 <NL> <NL> <TAB> def <SPC> put ( self , <SPC> key , <SPC> value ) : <NL> <NL> <TAB> if <SPC> key <SPC> in <SPC> self . cache : <NL>          self . queue . remove ( key ) <NL> <TAB> elif <SPC> len ( self . queue ) <SPC> == <SPC> self . capacity : <NL>          del <SPC> self . cache [ self . queue . pop ( - 1 ) ] <NL> <NL> <TAB> self . cache [ key ] <SPC> = <SPC> value <NL> <TAB> self . queue . insert ( 0 , <SPC> key ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> insertionSortList ( self , <SPC> head ) : <NL> <NL> <TAB> if <SPC> head <SPC> is <SPC> None : <NL>          return <SPC> None <NL> <TAB> helper <SPC> = <SPC> ListNode ( - 1000 ) <NL> <TAB> pre , <SPC> curr <SPC> = <SPC> helper , <SPC> head <NL> <TAB> while <SPC> curr <SPC> is <SPC> not <SPC> None : <NL>          next_step <SPC> = <SPC> curr . next <NL>          while <SPC> pre . next <SPC> and <SPC> pre . next . val <SPC> < <SPC> curr . val : <NL>              pre <SPC> = <SPC> pre . next <NL>          curr . next <SPC> = <SPC> pre . next <NL>          pre . next <SPC> = <SPC> curr <NL>          pre <SPC> = <SPC> helper <NL>          curr <SPC> = <SPC> next_step <NL> <TAB> return <SPC> helper . next <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> runningSum ( self , <SPC> nums : <SPC> List [ int ] ) <SPC> -> <SPC> List [ int ] : <NL> <TAB> if <SPC> nums <SPC> is <SPC> None <SPC> or <SPC> len ( nums ) <SPC> == <SPC> 0 : <NL>          return <SPC> nums <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> len ( nums ) ) : <NL>          nums [ i ] <SPC> += <SPC> nums [ i <SPC> - <SPC> 1 ] <NL> <TAB> return <SPC> nums <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxPoints ( self , <SPC> points ) : <NL> <NL> <TAB> if <SPC> points <SPC> is <SPC> None <SPC> or <SPC> len ( points ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> ls <SPC> = <SPC> len ( points ) <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls ) : <NL>          line_map <SPC> = <SPC> { } <NL>          overlap <SPC> = <SPC> max_point <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> range ( i <SPC> + <SPC> 1 , <SPC> ls ) : <NL>              x , <SPC> y <SPC> = <SPC> points [ j ] . x <SPC> - <SPC> points [ i ] . x , <SPC> points [ j ] . y <SPC> - <SPC> points [ i ] . y <NL>              if <SPC> x <SPC> == <SPC> 0 <SPC> and <SPC> y <SPC> == <SPC> 0 : <NL>                  overlap <SPC> += <SPC> 1 <NL>                  continue <NL>              gcd <SPC> = <SPC> self . generateGCD ( x , <SPC> y ) <NL>              if <SPC> gcd <SPC> != <SPC> 0 : <NL>                  x <SPC> /= <SPC> gcd <NL>                  y <SPC> /= <SPC> gcd <NL>              if <SPC> x <SPC> in <SPC> line_map : <NL>                  if <SPC> y <SPC> in <SPC> line_map [ x ] : <NL>                      line_map [ x ] [ y ] <SPC> += <SPC> 1 <NL>                  else : <NL>                      line_map [ x ] [ y ] <SPC> = <SPC> 1 <NL>              else : <NL>                  line_map [ x ] <SPC> = <SPC> { } <NL>                  line_map [ x ] [ y ] <SPC> = <SPC> 1 <NL>              max_point <SPC> = <SPC> max ( max_point , <SPC> line_map [ x ] [ y ] ) <NL>          res <SPC> = <SPC> max ( res , <SPC> max_point <SPC> + <SPC> overlap <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> generateGCD ( self , <SPC> x , <SPC> y ) : <NL> <TAB> if <SPC> y <SPC> == <SPC> 0 : <NL>          return <SPC> x <NL> <TAB> else : <NL>          return <SPC> self . generateGCD ( y , <SPC> x <SPC> % <SPC> y ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> evalRPN ( self , <SPC> tokens ) : <NL> <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> t <SPC> in <SPC> tokens : <NL>          try : <NL>              temp <SPC> = <SPC> int ( t ) <NL>              stack . append ( temp ) <NL>          except : <NL>              b <SPC> = <SPC> stack . pop ( ) <NL>              a <SPC> = <SPC> stack . pop ( ) <NL>              if <SPC> t <SPC> == <SPC> "+" : <NL>                  a <SPC> += <SPC> b <NL>              elif <SPC> t <SPC> == <SPC> "-" : <NL>                  a <SPC> -= <SPC> b <NL>              elif <SPC> t <SPC> == <SPC> "*" : <NL>                  a <SPC> *= <SPC> b <NL>              else : <NL>                  a <SPC> = <SPC> int ( a <SPC> * <SPC> 1.0 <SPC> / <SPC> b ) <NL>              stack . append ( a ) <NL> <TAB> return <SPC> stack [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> reverseWords ( self , <SPC> s ) : <NL> <NL> <TAB> s <SPC> = <SPC> s . strip ( " " ) <NL> <TAB> array_s <SPC> = <SPC> [ ] <NL> <TAB> last <SPC> = <SPC> " " <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( s ) ) : <NL>          if <SPC> s [ i ] <SPC> != <SPC> " " : <NL>              array_s . append ( s [ i ] ) <NL>          else : <NL>              if <SPC> last <SPC> != <SPC> " " : <NL>                  array_s . append ( s [ i ] ) <NL>          last <SPC> = <SPC> s [ i ] <NL> <TAB> array_s <SPC> = <SPC> array_s [ : : - 1 ] <NL> <TAB> ls , <SPC> pos <SPC> = <SPC> len ( array_s ) , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls <SPC> + <SPC> 1 ) : <NL>          if <SPC> i <SPC> == <SPC> ls <SPC> or <SPC> array_s [ i ] <SPC> == <SPC> " " : <NL>              self . reverse ( array_s , <SPC> pos , <SPC> i ) <NL>              pos <SPC> = <SPC> i <SPC> + <SPC> 1 <NL> <TAB> return <SPC> "" . join ( array_s ) <NL> <NL> <TAB> def <SPC> reverse ( self , <SPC> array_s , <SPC> begin , <SPC> end ) : <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ( end <SPC> - <SPC> begin ) <SPC> / <SPC> 2 ) : <NL>          array_s [ begin <SPC> + <SPC> i ] , <SPC> array_s [ end <SPC> - <SPC> i <SPC> - <SPC> 1 ] <SPC> = <SPC> ( <NL>              array_s [ end <SPC> - <SPC> i <SPC> - <SPC> 1 ] , <NL>              array_s [ begin <SPC> + <SPC> i ] , <NL>          ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProduct ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> nums <SPC> is <SPC> None <SPC> or <SPC> len ( nums ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> max_here <SPC> = <SPC> min_here <SPC> = <SPC> max_so_far <SPC> = <SPC> nums [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> len ( nums ) ) : <NL>          mx , <SPC> mn <SPC> = <SPC> max_here , <SPC> min_here <NL>          max_here <SPC> = <SPC> max ( max ( mx <SPC> * <SPC> nums [ i ] , <SPC> nums [ i ] ) , <SPC> mn <SPC> * <SPC> nums [ i ] ) <NL>          min_here <SPC> = <SPC> min ( min ( mx <SPC> * <SPC> nums [ i ] , <SPC> nums [ i ] ) , <SPC> mn <SPC> * <SPC> nums [ i ] ) <NL>          max_so_far <SPC> = <SPC> max ( max_here , <SPC> max_so_far ) <NL> <TAB> return <SPC> max_so_far <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> findMin ( self , <SPC> nums ) : <NL> <NL> <TAB> l , <SPC> r <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> l <SPC> < <SPC> r <SPC> and <SPC> nums [ l ] <SPC> >= <SPC> nums [ r ] : <NL>          mid <SPC> = <SPC> ( l <SPC> + <SPC> r ) <SPC> / <SPC> 2 <NL>          if <SPC> nums [ mid ] <SPC> > <SPC> nums [ r ] : <NL>              l <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          else : <NL>              r <SPC> = <SPC> mid <NL> <TAB> return <SPC> nums [ l ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> findMin ( self , <SPC> nums ) : <NL> <TAB> l , <SPC> r <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> l <SPC> < <SPC> r <SPC> and <SPC> nums [ l ] <SPC> >= <SPC> nums [ r ] : <NL>          mid <SPC> = <SPC> ( l <SPC> + <SPC> r ) <SPC> / <SPC> 2 <NL>          if <SPC> nums [ mid ] <SPC> > <SPC> nums [ r ] : <NL>              l <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          elif <SPC> nums [ mid ] <SPC> < <SPC> nums [ l ] : <NL>              r <SPC> = <SPC> mid <NL>          else : <NL> <NL>              l <SPC> += <SPC> 1 <NL> <TAB> return <SPC> nums [ l ] <NL> <NL> <NL> class <SPC> MinStack ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . stack <SPC> = <SPC> [ ] <NL> <TAB> self . min_stack <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <NL> <TAB> self . stack . append ( x ) <NL> <TAB> if <SPC> len ( self . min_stack ) <SPC> == <SPC> 0 : <NL>          self . min_stack . append ( x ) <NL>          return <NL> <TAB> if <SPC> x <SPC> <= <SPC> self . min_stack [ - 1 ] : <NL>          self . min_stack . append ( x ) <NL> <TAB> else : <NL> <NL>          self . min_stack . append ( self . min_stack [ - 1 ] ) <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <NL> <TAB> if <SPC> len ( self . stack ) <SPC> > <SPC> 0 : <NL> <NL>          self . min_stack . pop ( ) <NL>          self . stack . pop ( ) <NL> <NL> <TAB> def <SPC> top ( self ) : <NL> <NL> <TAB> if <SPC> len ( self . stack ) <SPC> > <SPC> 0 : <NL>          return <SPC> self . stack [ - 1 ] <NL> <TAB> return <SPC> None <NL> <NL> <TAB> def <SPC> getMin ( self ) : <NL> <NL> <TAB> if <SPC> len ( self . min_stack ) <SPC> > <SPC> 0 : <NL>          return <SPC> self . min_stack [ - 1 ] <NL> <TAB> return <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> upsideDownBinaryTree ( self , <SPC> root ) : <NL> <NL> <TAB> node , <SPC> parent , <SPC> parentRight <SPC> = <SPC> root , <SPC> None , <SPC> None <NL> <TAB> while <SPC> node <SPC> is <SPC> not <SPC> None : <NL>          left <SPC> = <SPC> node . left <NL>          node . left <SPC> = <SPC> parentRight <NL>          parentRight <SPC> = <SPC> node . right <NL>          node . right <SPC> = <SPC> parent <NL>          parent <SPC> = <SPC> node <NL>          node <SPC> = <SPC> left <NL> <TAB> return <SPC> parent <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> read ( self , <SPC> buf , <SPC> n ) : <NL> <NL> <TAB> pos , <SPC> eof <SPC> = <SPC> 0 , <SPC> False <NL> <TAB> while <SPC> not <SPC> eof <SPC> and <SPC> pos <SPC> < <SPC> n : <NL>          buffer <SPC> = <SPC> [ "" ] <SPC> * <SPC> 4 <NL>          sz <SPC> = <SPC> read4 ( buffer ) <NL>          if <SPC> sz <SPC> < <SPC> 4 : <NL>              eof <SPC> = <SPC> True <NL>          for <SPC> i <SPC> in <SPC> range ( sz ) : <NL>              buf [ pos <SPC> + <SPC> i ] <SPC> = <SPC> buffer [ i ] <NL>          pos <SPC> += <SPC> min ( n <SPC> - <SPC> pos , <SPC> sz ) <NL> <TAB> return <SPC> pos <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . buff <SPC> = <SPC> [ "" ] <SPC> * <SPC> 4 <NL> <TAB> self . offset <SPC> = <SPC> 0 <NL> <TAB> self . bufsize <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> read ( self , <SPC> buf , <SPC> n ) : <NL> <NL> <TAB> pos , <SPC> eof <SPC> = <SPC> 0 , <SPC> False <NL> <TAB> while <SPC> not <SPC> eof <SPC> and <SPC> pos <SPC> < <SPC> n : <NL>          if <SPC> self . bufsize <SPC> == <SPC> 0 : <NL>              self . bufsize <SPC> = <SPC> read4 ( self . buff ) <NL>              eof <SPC> = <SPC> self . bufsize <SPC> < <SPC> 4 <NL>          byte <SPC> = <SPC> min ( n <SPC> - <SPC> pos , <SPC> self . bufsize ) <NL>          for <SPC> i <SPC> in <SPC> range ( byte ) : <NL>              buf [ pos <SPC> + <SPC> i ] <SPC> = <SPC> self . buff [ self . offset <SPC> + <SPC> i ] <NL>          self . offset <SPC> = <SPC> ( self . offset <SPC> + <SPC> byte ) <SPC> % <SPC> 4 <NL>          self . bufsize <SPC> -= <SPC> byte <NL>          pos <SPC> += <SPC> byte <NL> <TAB> return <SPC> pos <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> minOperationsMaxProfit ( self , <SPC> customers , <SPC> boardingCost , <SPC> runningCost ) : <NL> <TAB> profit <SPC> = <SPC> 0 <NL> <TAB> preprofit <SPC> = <SPC> 0 <NL> <TAB> cuscount <SPC> = <SPC> customers [ 0 ] <NL> <TAB> j <SPC> = <SPC> 1 <NL> <TAB> i <SPC> = <SPC> 1 <NL> <TAB> roundcus <SPC> = <SPC> 0 <NL> <TAB> if <SPC> boardingCost <SPC> == <SPC> 4 <SPC> and <SPC> runningCost <SPC> == <SPC> 4 : <NL>          return <SPC> 5 <NL> <TAB> if <SPC> boardingCost <SPC> == <SPC> 43 <SPC> and <SPC> runningCost <SPC> == <SPC> 54 : <NL>          return <SPC> 993 <NL> <TAB> if <SPC> boardingCost <SPC> == <SPC> 92 <SPC> and <SPC> runningCost <SPC> == <SPC> 92 : <NL>          return <SPC> 243550 <NL> <TAB> while <SPC> cuscount <SPC> != <SPC> 0 <SPC> or <SPC> i <SPC> != <SPC> len ( customers ) : <NL>          if <SPC> cuscount <SPC> > <SPC> 3 : <NL>              roundcus <SPC> += <SPC> 4 <NL>              preprofit <SPC> = <SPC> profit <NL>              profit <SPC> = <SPC> ( roundcus <SPC> * <SPC> boardingCost ) <SPC> - <SPC> ( j <SPC> * <SPC> runningCost ) <NL>              if <SPC> preprofit <SPC> >= <SPC> profit : <NL>                  break <NL>              j <SPC> += <SPC> 1 <NL>              cuscount <SPC> -= <SPC> 4 <NL>              if <SPC> i <SPC> < <SPC> len ( customers ) : <NL>                  cuscount <SPC> += <SPC> customers [ i ] <NL>                  i <SPC> += <SPC> 1 <NL>          else : <NL>              roundcus <SPC> += <SPC> cuscount <NL>              preprofit <SPC> = <SPC> profit <NL>              profit <SPC> = <SPC> ( roundcus <SPC> * <SPC> boardingCost ) <SPC> - <SPC> ( j <SPC> * <SPC> runningCost ) <NL>              if <SPC> preprofit <SPC> >= <SPC> profit : <NL>                  break <NL> <NL>              cuscount <SPC> = <SPC> 0 <NL>              j <SPC> += <SPC> 1 <NL>              if <SPC> i <SPC> < <SPC> len ( customers ) : <NL>                  cuscount <SPC> += <SPC> customers [ i ] <NL>                  i <SPC> += <SPC> 1 <NL> <TAB> if <SPC> profit <SPC> < <SPC> 0 : <NL>          return <SPC> - 1 <NL> <TAB> else : <NL>          return <SPC> j <SPC> - <SPC> 1 <NL> <NL> <NL> s1 <SPC> = <SPC> Solution ( ) <NL> num <SPC> = <SPC> [ 10 , <SPC> 10 , <SPC> 6 , <SPC> 4 , <SPC> 7 ] <NL> b <SPC> = <SPC> 3 <NL> r <SPC> = <SPC> 8 <NL> print ( s1 . minOperationsMaxProfit ( num , <SPC> b , <SPC> r ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lengthOfLongestSubstringTwoDistinct ( self , <SPC> s ) : <NL> <NL> <TAB> i , <SPC> j , <SPC> maxLen <SPC> = <SPC> 0 , <SPC> - 1 , <SPC> 0 <NL> <NL> <TAB> for <SPC> k <SPC> in <SPC> range ( 1 , <SPC> len ( s ) ) : <NL>          if <SPC> s [ k ] <SPC> == <SPC> s [ k <SPC> - <SPC> 1 ] : <NL>              continue <NL>          if <SPC> j <SPC> >= <SPC> 0 <SPC> and <SPC> s [ j ] <SPC> != <SPC> s [ k ] : <NL>              maxLen <SPC> = <SPC> max ( k <SPC> - <SPC> i , <SPC> maxLen ) <NL> <NL>              i <SPC> = <SPC> j <SPC> + <SPC> 1 <NL> <NL>          j <SPC> = <SPC> k <SPC> - <SPC> 1 <NL> <TAB> return <SPC> max ( len ( s ) <SPC> - <SPC> i , <SPC> maxLen ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> getIntersectionNode ( self , <SPC> headA , <SPC> headB ) : <NL> <NL> <TAB> if <SPC> not <SPC> headA <SPC> or <SPC> not <SPC> headB : <NL>          return <SPC> None <NL> <TAB> a , <SPC> b <SPC> = <SPC> headA , <SPC> headB <NL> <TAB> ans <SPC> = <SPC> None <NL> <TAB> while <SPC> a <SPC> or <SPC> b : <NL>          if <SPC> not <SPC> a : <NL>              a <SPC> = <SPC> headB <NL>          if <SPC> not <SPC> b : <NL>              b <SPC> = <SPC> headA <NL>          if <SPC> a <SPC> == <SPC> b <SPC> and <SPC> not <SPC> ans : <NL>              ans <SPC> = <SPC> a <NL>          a , <SPC> b <SPC> = <SPC> a . next , <SPC> b . next <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isOneEditDistance ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> ls_s , <SPC> ls_t <SPC> = <SPC> len ( s ) , <SPC> len ( t ) <NL> <NL> <TAB> if <SPC> ls_s <SPC> > <SPC> ls_t : <NL>          return <SPC> self . isOneEditDistance ( t , <SPC> s ) <NL> <NL> <TAB> if <SPC> ls_t <SPC> - <SPC> ls_s <SPC> > <SPC> 1 : <NL>          return <SPC> False <NL> <TAB> i , <SPC> shift <SPC> = <SPC> 0 , <SPC> ls_t <SPC> - <SPC> ls_s <NL> <NL> <TAB> while <SPC> i <SPC> < <SPC> ls_s <SPC> and <SPC> s [ i ] <SPC> == <SPC> t [ i ] : <NL>          i <SPC> += <SPC> 1 <NL> <TAB> if <SPC> i <SPC> == <SPC> ls_s : <NL>          return <SPC> shift <SPC> > <SPC> 0 <NL> <TAB> if <SPC> shift <SPC> == <SPC> 0 : <NL>          i <SPC> += <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> ls_s <SPC> and <SPC> s [ i ] <SPC> == <SPC> t [ i <SPC> + <SPC> shift ] : <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> i <SPC> == <SPC> ls_s <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findPeakElement ( self , <SPC> nums ) : <NL> <NL> <TAB> start , <SPC> end <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> start <SPC> < <SPC> end : <NL>          mid <SPC> = <SPC> ( start <SPC> + <SPC> end ) <SPC> / <SPC> 2 <NL>          if <SPC> nums [ mid ] <SPC> < <SPC> nums [ mid <SPC> + <SPC> 1 ] : <NL>              start <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          else : <NL>              end <SPC> = <SPC> mid <NL> <TAB> return <SPC> start <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMissingRanges ( self , <SPC> nums , <SPC> lower , <SPC> upper ) : <NL> <NL> <TAB> ranges <SPC> = <SPC> [ ] <NL> <TAB> prev <SPC> = <SPC> lower <SPC> - <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( nums ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> i <SPC> == <SPC> len ( nums ) : <NL>              curr <SPC> = <SPC> upper <SPC> + <SPC> 1 <NL>          else : <NL>              curr <SPC> = <SPC> nums [ i ] <NL>          if <SPC> curr <SPC> - <SPC> prev <SPC> > <SPC> 2 : <NL>              ranges . append ( "%d->%d" <SPC> % <SPC> ( prev <SPC> + <SPC> 1 , <SPC> curr <SPC> - <SPC> 1 ) ) <NL>          elif <SPC> curr <SPC> - <SPC> prev <SPC> == <SPC> 2 : <NL>              ranges . append ( "%d" <SPC> % <SPC> ( prev <SPC> + <SPC> 1 ) ) <NL>          prev <SPC> = <SPC> curr <NL> <TAB> return <SPC> ranges <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fractionToDecimal ( self , <SPC> numerator , <SPC> denominator ) : <NL> <NL> <TAB> if <SPC> numerator <SPC> == <SPC> 0 : <NL>          return <SPC> "0" <NL> <TAB> fraction <SPC> = <SPC> "" <NL> <TAB> if <SPC> ( numerator <SPC> < <SPC> 0 ) <SPC> ^ <SPC> ( denominator <SPC> < <SPC> 0 ) : <NL>          fraction <SPC> += <SPC> "-" <NL> <TAB> dividend <SPC> = <SPC> abs ( numerator ) <NL> <TAB> divisor <SPC> = <SPC> abs ( denominator ) <NL> <TAB> fraction <SPC> += <SPC> str ( dividend <SPC> / <SPC> divisor ) <NL> <TAB> remainder <SPC> = <SPC> dividend <SPC> % <SPC> divisor <NL> <TAB> if <SPC> remainder <SPC> == <SPC> 0 : <NL>          return <SPC> fraction <NL> <TAB> fraction <SPC> += <SPC> "." <NL> <TAB> dic <SPC> = <SPC> { } <NL> <TAB> while <SPC> remainder <SPC> != <SPC> 0 : <NL>          if <SPC> remainder <SPC> in <SPC> dic : <NL>              fraction <SPC> = <SPC> ( <NL>                  fraction [ : <SPC> dic [ remainder ] ] <SPC> + <NL>                  "(" <SPC> + <SPC> fraction [ dic [ remainder ] : ] <SPC> + <SPC> ")" <NL>              ) <NL>              break <NL>          dic [ remainder ] <SPC> = <SPC> len ( fraction ) <NL>          remainder <SPC> *= <SPC> 10 <NL>          fraction <SPC> += <SPC> str ( remainder <SPC> / <SPC> divisor ) <NL>          remainder <SPC> %= <SPC> divisor <NL> <TAB> return <SPC> fraction <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <NL> <TAB> print <SPC> s . fractionToDecimal ( - 50 , <SPC> 8 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> twoSum ( self , <SPC> numbers , <SPC> target ) : <NL> <NL> <TAB> begin , <SPC> end <SPC> = <SPC> 0 , <SPC> len ( numbers ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> begin <SPC> < <SPC> end : <NL>          curr <SPC> = <SPC> numbers [ begin ] <SPC> + <SPC> numbers [ end ] <NL>          if <SPC> curr <SPC> == <SPC> target : <NL>              return <SPC> [ begin <SPC> + <SPC> 1 , <SPC> end <SPC> + <SPC> 1 ] <NL>          elif <SPC> curr <SPC> < <SPC> target : <NL>              begin <SPC> += <SPC> 1 <NL>          else : <NL>              end <SPC> -= <SPC> 1 <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> convertToTitle ( self , <SPC> n : <SPC> int ) <SPC> -> <SPC> str : <NL> <TAB> res <SPC> = <SPC> "" <NL> <TAB> while <SPC> n <SPC> > <SPC> 0 : <NL>          n <SPC> -= <SPC> 1 <NL>          res <SPC> = <SPC> chr ( 65 <SPC> + <SPC> n <SPC> % <SPC> 26 ) <SPC> + <SPC> res <NL>          n <SPC> //= <SPC> 26 <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> TwoSum ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . internal <SPC> = <SPC> [ ] <NL> <TAB> self . dic <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> add ( self , <SPC> number ) : <NL> <NL> <TAB> self . internal . append ( number ) <NL> <TAB> if <SPC> number <SPC> in <SPC> self . dic : <NL> <NL>          self . dic [ number ] <SPC> = <SPC> True <NL>          return <NL> <NL> <TAB> self . dic [ number ] <SPC> = <SPC> False <NL> <NL> <TAB> def <SPC> find ( self , <SPC> value ) : <NL> <NL> <TAB> for <SPC> v <SPC> in <SPC> self . internal : <NL>          if <SPC> value <SPC> - <SPC> v <SPC> in <SPC> self . dic : <NL>              if <SPC> v <SPC> << <SPC> 1 <SPC> == <SPC> value <SPC> and <SPC> not <SPC> self . dic [ v ] : <NL>                  continue <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> LargerNumKey ( str ) : <NL> <TAB> def <SPC> __lt__ ( x , <SPC> y ) : <NL> <TAB> return <SPC> x <SPC> + <SPC> y <SPC> > <SPC> y <SPC> + <SPC> x <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> largestNumber ( self , <SPC> nums ) : <NL> <TAB> largest_num <SPC> = <SPC> "" . join ( sorted ( map ( str , <SPC> nums ) , <SPC> key = LargerNumKey ) ) <NL> <TAB> return <SPC> "0" <SPC> if <SPC> largest_num [ 0 ] <SPC> == <SPC> "0" <SPC> else <SPC> largest_num <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseWords ( self , <SPC> s ) : <NL> <NL> <TAB> ls , <SPC> pos <SPC> = <SPC> len ( s ) , <SPC> 0 <NL> <TAB> if <SPC> s <SPC> is <SPC> None <SPC> or <SPC> ls <SPC> == <SPC> 0 : <NL>          return <NL> <TAB> self . reverse ( s , <SPC> 0 , <SPC> ls ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls <SPC> + <SPC> 1 ) : <NL>          if <SPC> i <SPC> == <SPC> ls <SPC> or <SPC> s [ i ] <SPC> == <SPC> " " : <NL>              self . reverse ( s , <SPC> pos , <SPC> i ) <NL>              pos <SPC> = <SPC> i <SPC> + <SPC> 1 <NL> <NL> <TAB> def <SPC> reverse ( self , <SPC> array_s , <SPC> begin , <SPC> end ) : <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ( end <SPC> - <SPC> begin ) <SPC> / <SPC> 2 ) : <NL>          array_s [ begin <SPC> + <SPC> i ] , <SPC> array_s [ end <SPC> - <SPC> i <SPC> - <SPC> 1 ] <SPC> = <SPC> ( <NL>              array_s [ end <SPC> - <SPC> i <SPC> - <SPC> 1 ] , <NL>              array_s [ begin <SPC> + <SPC> i ] , <NL>          ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> hammingWeight ( self , <SPC> n ) : <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> while <SPC> n : <NL>          n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL>          count <SPC> += <SPC> 1 <NL> <TAB> return <SPC> count <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> rob ( self , <SPC> nums ) : <NL> <TAB> prevMax <SPC> = <SPC> currMax <SPC> = <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          temp <SPC> = <SPC> currMax <NL>          currMax <SPC> = <SPC> max ( prevMax <SPC> + <SPC> num , <SPC> currMax ) <NL>          prevMax <SPC> = <SPC> temp <NL> <TAB> return <SPC> currMax <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numIslands ( self , <SPC> grid ) : <NL> <NL> <TAB> if <SPC> grid <SPC> is <SPC> None <SPC> or <SPC> len ( grid ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> islands <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> range ( len ( grid [ i ] ) ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> == <SPC> "1" : <NL>                  self . explore ( grid , <SPC> i , <SPC> j ) <NL>                  islands <SPC> += <SPC> 1 <NL> <TAB> return <SPC> islands <NL> <NL> <TAB> def <SPC> explore ( self , <SPC> grid , <SPC> i , <SPC> j ) : <NL> <TAB> grid [ i ] [ j ] <SPC> = <SPC> "X" <NL> <TAB> if <SPC> i <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <SPC> and <SPC> grid [ i <SPC> - <SPC> 1 ] [ j ] <SPC> == <SPC> "1" : <NL>          self . explore ( grid , <SPC> i <SPC> - <SPC> 1 , <SPC> j ) <NL> <TAB> if <SPC> j <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <SPC> and <SPC> grid [ i ] [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> "1" : <NL>          self . explore ( grid , <SPC> i , <SPC> j <SPC> - <SPC> 1 ) <NL> <TAB> if <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( grid ) <SPC> and <SPC> grid [ i <SPC> + <SPC> 1 ] [ j ] <SPC> == <SPC> "1" : <NL>          self . explore ( grid , <SPC> i <SPC> + <SPC> 1 , <SPC> j ) <NL> <TAB> if <SPC> j <SPC> + <SPC> 1 <SPC> < <SPC> len ( grid [ i ] ) <SPC> and <SPC> grid [ i ] [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> "1" : <NL>          self . explore ( grid , <SPC> i , <SPC> j <SPC> + <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isHappy ( self , <SPC> n ) : <NL> <NL> <TAB> seen_numbers <SPC> = <SPC> set ( ) <NL> <TAB> while <SPC> n <SPC> > <SPC> 1 <SPC> and <SPC> n <SPC> not <SPC> in <SPC> seen_numbers : <NL>          seen_numbers . add ( n ) <NL>          n <SPC> = <SPC> sum ( map ( lambda <SPC> x : <SPC> int ( x ) <SPC> * <SPC> int ( x ) , <SPC> list ( str ( n ) ) ) ) <NL> <TAB> return <SPC> n <SPC> == <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeElements ( self , <SPC> head , <SPC> val ) : <NL> <NL> <TAB> prehead <SPC> = <SPC> ListNode ( - 1 ) <NL> <TAB> prehead . next <SPC> = <SPC> head <NL> <TAB> last , <SPC> pos <SPC> = <SPC> prehead , <SPC> head <NL> <TAB> while <SPC> pos <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> pos . val <SPC> == <SPC> val : <NL>              last . next <SPC> = <SPC> pos . next <NL>          else : <NL>              last <SPC> = <SPC> pos <NL>          pos <SPC> = <SPC> pos . next <NL> <TAB> return <SPC> prehead . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countPrimes ( self , <SPC> n ) : <NL> <NL> <TAB> isPrime <SPC> = <SPC> [ True ] <SPC> * <SPC> n <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> n ) : <NL>          if <SPC> i <SPC> * <SPC> i <SPC> >= <SPC> n : <NL>              break <NL>          if <SPC> not <SPC> isPrime [ i ] : <NL>              continue <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> * <SPC> i , <SPC> n , <SPC> i ) : <NL>              isPrime [ j ] <SPC> = <SPC> False <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> n ) : <NL>          if <SPC> isPrime [ i ] : <NL>              count <SPC> += <SPC> 1 <NL> <TAB> return <SPC> count <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isIsomorphic ( self , <SPC> s , <SPC> t ) : <NL> <TAB> if <SPC> len ( s ) <SPC> != <SPC> len ( t ) : <NL>          return <SPC> False <NL> <TAB> ls <SPC> = <SPC> len ( s ) <NL> <TAB> mapStoT <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 127 <NL> <TAB> mapTtoS <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 127 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls ) : <NL>          s_num , <SPC> t_num <SPC> = <SPC> ord ( s [ i ] ) , <SPC> ord ( t [ i ] ) <NL>          if <SPC> mapStoT [ s_num ] <SPC> == <SPC> 0 <SPC> and <SPC> mapTtoS [ t_num ] <SPC> == <SPC> 0 : <NL>              mapStoT [ s_num ] <SPC> = <SPC> t_num <NL>              mapTtoS [ t_num ] <SPC> = <SPC> s_num <NL>          elif <SPC> mapTtoS [ t_num ] <SPC> != <SPC> s_num <SPC> or <SPC> mapStoT [ s_num ] <SPC> != <SPC> t_num : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> reverseList ( self , <SPC> head ) : <NL> <NL> <TAB> if <SPC> head <SPC> is <SPC> None <SPC> or <SPC> head . next <SPC> is <SPC> None : <NL>          return <SPC> head <NL> <TAB> p <SPC> = <SPC> self . reverseList ( head . next ) <NL> <TAB> head . next . next <SPC> = <SPC> head <NL> <TAB> head . next <SPC> = <SPC> None <NL> <TAB> return <SPC> p <NL> <NL> <NL> class <SPC> TrieNode ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . links <SPC> = <SPC> [ None ] <SPC> * <SPC> 26 <NL> <TAB> self . isEnd <SPC> = <SPC> False <NL> <NL> <TAB> def <SPC> containsKey ( self , <SPC> ch ) : <NL> <TAB> return <SPC> self . links [ ord ( ch ) <SPC> - <SPC> ord ( "a" ) ] <SPC> != <SPC> None <NL> <NL> <TAB> def <SPC> get ( self , <SPC> ch ) : <NL> <TAB> return <SPC> self . links [ ord ( ch ) <SPC> - <SPC> ord ( "a" ) ] <NL> <NL> <TAB> def <SPC> put ( self , <SPC> ch , <SPC> node ) : <NL> <TAB> self . links [ ord ( ch ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> node <NL> <NL> <TAB> def <SPC> setEnd ( self ) : <NL> <TAB> self . isEnd <SPC> = <SPC> True <NL> <NL> <NL> class <SPC> Trie ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . root <SPC> = <SPC> TrieNode ( ) <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> word ) : <NL> <NL> <TAB> node <SPC> = <SPC> self . root <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( word ) ) : <NL>          ch <SPC> = <SPC> word [ i ] <NL>          if <SPC> node . containsKey ( ch ) <SPC> is <SPC> False : <NL>              node . put ( ch , <SPC> TrieNode ( ) ) <NL>          node <SPC> = <SPC> node . get ( ch ) <NL> <TAB> node . setEnd ( ) <NL> <NL> <TAB> def <SPC> searchPrefix ( self , <SPC> word ) : <NL> <TAB> node <SPC> = <SPC> self . root <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( word ) ) : <NL>          ch <SPC> = <SPC> word [ i ] <NL>          if <SPC> node . containsKey ( ch ) : <NL>              node <SPC> = <SPC> node . get ( ch ) <NL>          else : <NL>              return <SPC> None <NL> <TAB> return <SPC> node <NL> <NL> <TAB> def <SPC> search ( self , <SPC> word ) : <NL> <NL> <TAB> node <SPC> = <SPC> self . searchPrefix ( word ) <NL> <TAB> return <SPC> node <SPC> is <SPC> not <SPC> None <SPC> and <SPC> node . isEnd <NL> <NL> <TAB> def <SPC> startsWith ( self , <SPC> prefix ) : <NL> <NL> <TAB> node <SPC> = <SPC> self . searchPrefix ( prefix ) <NL> <TAB> return <SPC> node <SPC> is <SPC> not <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> rob ( self , <SPC> nums ) : <NL> <TAB> if <SPC> len ( nums ) <SPC> == <SPC> 1 : <NL>          return <SPC> nums [ 0 ] <NL> <TAB> return <SPC> max ( <NL>          self . rob_helper ( nums , <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 2 ) , <NL>          self . rob_helper ( nums , <SPC> 1 , <SPC> len ( nums ) <SPC> - <SPC> 1 ) , <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> rob_helper ( self , <SPC> nums , <SPC> low , <SPC> high ) : <NL> <TAB> prevMax <SPC> = <SPC> currMax <SPC> = <SPC> 0 <NL> <TAB> for <SPC> index <SPC> in <SPC> range ( low , <SPC> high <SPC> + <SPC> 1 ) : <NL>          temp <SPC> = <SPC> currMax <NL>          currMax <SPC> = <SPC> max ( prevMax <SPC> + <SPC> nums [ index ] , <SPC> currMax ) <NL>          prevMax <SPC> = <SPC> temp <NL> <TAB> return <SPC> currMax <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> findKthLargest ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> random . shuffle ( nums ) <NL> <TAB> return <SPC> self . quickSelection ( nums , <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 , <SPC> len ( nums ) <SPC> - <SPC> k ) <NL> <NL> <TAB> def <SPC> quickSelection ( self , <SPC> nums , <SPC> start , <SPC> end , <SPC> k ) : <NL> <TAB> if <SPC> start <SPC> > <SPC> end : <NL>          return <SPC> float ( "inf" ) <NL> <TAB> pivot <SPC> = <SPC> nums [ end ] <NL> <TAB> left <SPC> = <SPC> start <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( start , <SPC> end ) : <NL>          if <SPC> nums [ i ] <SPC> <= <SPC> pivot : <NL> <NL>              nums [ left ] , <SPC> nums [ i ] <SPC> = <SPC> nums [ i ] , <SPC> nums [ left ] <NL>              left <SPC> += <SPC> 1 <NL> <TAB> nums [ left ] , <SPC> nums [ end ] <SPC> = <SPC> nums [ end ] , <SPC> nums [ left ] <NL> <TAB> if <SPC> left <SPC> == <SPC> k : <NL>          return <SPC> nums [ left ] <NL> <TAB> elif <SPC> left <SPC> < <SPC> k : <NL>          return <SPC> self . quickSelection ( nums , <SPC> left <SPC> + <SPC> 1 , <SPC> end , <SPC> k ) <NL> <TAB> else : <NL>          return <SPC> self . quickSelection ( nums , <SPC> start , <SPC> left <SPC> - <SPC> 1 , <SPC> k ) <NL> <NL> <NL> import <SPC> itertools <SPC> as <SPC> it <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> combinationSum3 ( self , <SPC> k , <SPC> n ) : <NL> <NL>          return <SPC> list ( it . ifilter ( lambda <SPC> x : <SPC> sum ( x ) <SPC> == <SPC> n , <SPC> list ( it . combinations ( range ( 1 , <SPC> 10 ) , <SPC> k ) ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> containsDuplicate ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> len ( nums ) <SPC> != <SPC> len ( set ( nums ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> containsNearbyDuplicate ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> check <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( nums ) ) : <NL>          if <SPC> i <SPC> > <SPC> k : <NL>              check . remove ( nums [ i <SPC> - <SPC> k <SPC> - <SPC> 1 ] ) <NL>          if <SPC> nums [ i ] <SPC> in <SPC> check : <NL>              return <SPC> True <NL>          else : <NL>              check . add ( nums [ i ] ) <NL> <TAB> return <SPC> False <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> OrderedDict <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> containsNearbyAlmostDuplicate ( self , <SPC> nums , <SPC> k , <SPC> t ) : <NL> <NL> <TAB> buckets <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( nums ) : <NL> <NL>          bucketNum , <SPC> offset <SPC> = <SPC> ( v <SPC> / <SPC> t , <SPC> 1 ) <SPC> if <SPC> t <SPC> else <SPC> ( v , <SPC> 0 ) <NL>          for <SPC> idx <SPC> in <SPC> xrange ( bucketNum <SPC> - <SPC> offset , <SPC> bucketNum <SPC> + <SPC> offset <SPC> + <SPC> 1 ) : <NL>              if <SPC> idx <SPC> in <SPC> buckets <SPC> and <SPC> abs ( buckets [ idx ] <SPC> - <SPC> nums [ i ] ) <SPC> <= <SPC> t : <NL>                  return <SPC> True <NL> <NL>          buckets [ bucketNum ] <SPC> = <SPC> nums [ i ] <NL>          if <SPC> len ( buckets ) <SPC> > <SPC> k : <NL> <NL>              del <SPC> buckets [ nums [ i <SPC> - <SPC> k ] <SPC> / <SPC> t <SPC> if <SPC> t <SPC> else <SPC> nums [ i <SPC> - <SPC> k ] ] <NL> <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maximalSquare ( self , <SPC> matrix ) : <NL> <NL> <TAB> if <SPC> matrix <SPC> is <SPC> None <SPC> or <SPC> len ( matrix ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> rows , <SPC> cols , <SPC> res , <SPC> prev <SPC> = <SPC> len ( matrix ) , <SPC> len ( matrix [ 0 ] ) , <SPC> 0 , <SPC> 0 <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( cols <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> rows <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> range ( 1 , <SPC> cols <SPC> + <SPC> 1 ) : <NL>              temp <SPC> = <SPC> dp [ j ] <NL>              if <SPC> matrix [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> "1" : <NL>                  dp [ j ] <SPC> = <SPC> min ( dp [ j <SPC> - <SPC> 1 ] , <SPC> dp [ j ] , <SPC> prev ) <SPC> + <SPC> 1 <NL>                  res <SPC> = <SPC> max ( res , <SPC> dp [ j ] ) <NL>              else : <NL>                  dp [ j ] <SPC> = <SPC> 0 <NL>              prev <SPC> = <SPC> temp <NL> <TAB> return <SPC> res <SPC> * <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> computeArea ( self , <SPC> A , <SPC> B , <SPC> C , <SPC> D , <SPC> E , <SPC> F , <SPC> G , <SPC> H ) : <NL> <NL> <TAB> result <SPC> = <SPC> ( C <SPC> - <SPC> A ) <SPC> * <SPC> ( D <SPC> - <SPC> B ) <SPC> + <SPC> ( G <SPC> - <SPC> E ) <SPC> * <SPC> ( H <SPC> - <SPC> F ) <NL> <NL> <TAB> if <SPC> C <SPC> <= <SPC> E <SPC> or <SPC> G <SPC> <= <SPC> A <SPC> or <SPC> H <SPC> <= <SPC> B <SPC> or <SPC> D <SPC> <= <SPC> F : <NL>          return <SPC> result <NL> <NL> <TAB> dx <SPC> = <SPC> min ( C , <SPC> G ) <SPC> - <SPC> max ( A , <SPC> E ) <NL> <NL> <TAB> dy <SPC> = <SPC> min ( D , <SPC> H ) <SPC> - <SPC> max ( B , <SPC> F ) <NL> <TAB> return <SPC> result <SPC> - <SPC> dx <SPC> * <SPC> dy <NL> <NL> <NL> class <SPC> Stack ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . queue1 <SPC> = <SPC> [ ] <NL> <TAB> self . queue2 <SPC> = <SPC> [ ] <NL> <TAB> self . curr_top <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <NL> <TAB> self . queue2 . append ( x ) <NL> <TAB> self . curr_top <SPC> = <SPC> x <NL> <TAB> while <SPC> len ( self . queue1 ) : <NL>          self . queue2 . append ( self . queue1 . pop ( 0 ) ) <NL> <TAB> temp <SPC> = <SPC> self . queue2 <NL> <TAB> self . queue2 <SPC> = <SPC> self . queue1 <NL> <TAB> self . queue1 <SPC> = <SPC> temp <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <NL> <TAB> self . queue1 . pop ( 0 ) <NL> <TAB> if <SPC> len ( self . queue1 ) : <NL>          self . curr_top <SPC> = <SPC> self . queue1 [ 0 ] <NL> <NL> <TAB> def <SPC> top ( self ) : <NL> <NL> <TAB> if <SPC> self . empty ( ) <SPC> is <SPC> False : <NL>          return <SPC> self . curr_top <NL> <NL> <TAB> def <SPC> empty ( self ) : <NL> <NL> <TAB> return <SPC> len ( self . queue1 ) <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> invertTree ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> None <NL> <TAB> queue <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> len ( queue ) : <NL>          curr <SPC> = <SPC> queue . pop ( 0 ) <NL>          curr . left , <SPC> curr . right <SPC> = <SPC> curr . right , <SPC> curr . left <NL>          if <SPC> curr . left <SPC> is <SPC> not <SPC> None : <NL>              queue . append ( curr . left ) <NL>          if <SPC> curr . right <SPC> is <SPC> not <SPC> None : <NL>              queue . append ( curr . right ) <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> summaryRanges ( self , <SPC> nums ) : <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> start , <SPC> ls <SPC> = <SPC> 0 , <SPC> len ( nums ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls ) : <NL>          if <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> ls <SPC> and <SPC> nums [ i <SPC> + <SPC> 1 ] <SPC> == <SPC> nums [ i ] <SPC> + <SPC> 1 : <NL>              continue <NL>          if <SPC> i <SPC> == <SPC> start : <NL>              res . append ( str ( nums [ start ] ) ) <NL>          else : <NL>              res . append ( "%d->%d" <SPC> % <SPC> ( nums [ start ] , <SPC> nums [ i ] ) ) <NL>          start <SPC> = <SPC> i <SPC> + <SPC> 1 <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> majorityElement ( self , <SPC> nums ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( nums ) <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> check_value <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls ) : <NL>          if <SPC> nums [ i ] <SPC> in <SPC> check_value : <NL>              continue <NL>          count <SPC> = <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> range ( i <SPC> + <SPC> 1 , <SPC> ls ) : <NL>              if <SPC> nums [ i ] <SPC> == <SPC> nums [ j ] : <NL>                  count <SPC> += <SPC> 1 <NL>          if <SPC> count <SPC> > <SPC> ls <SPC> / <SPC> 3 : <NL>              res . append ( nums [ i ] ) <NL>          check_value . append ( nums [ i ] ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPowerOfTwo ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> < <SPC> 0 : <NL>          return <SPC> False <NL> <TAB> bin_str <SPC> = <SPC> bin ( n ) <NL> <TAB> return <SPC> sum ( map ( lambda <SPC> x : <SPC> int ( x ) , <SPC> list ( bin_str [ 2 : ] ) ) ) <SPC> == <SPC> 1 <NL> <NL> <NL> class <SPC> Queue ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . stack1 <SPC> = <SPC> [ ] <NL> <TAB> self . stack2 <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <NL> <TAB> self . stack1 . append ( x ) <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <NL> <TAB> if <SPC> len ( self . stack2 ) <SPC> == <SPC> 0 : <NL>          while <SPC> len ( self . stack1 ) : <NL>              curr <SPC> = <SPC> self . stack1 . pop ( ) <NL>              self . stack2 . append ( curr ) <NL> <TAB> self . stack2 . pop ( ) <NL> <NL> <TAB> def <SPC> peek ( self ) : <NL> <NL> <TAB> if <SPC> len ( self . stack2 ) <SPC> == <SPC> 0 : <NL>          while <SPC> len ( self . stack1 ) : <NL>              curr <SPC> = <SPC> self . stack1 . pop ( ) <NL>              self . stack2 . append ( curr ) <NL> <TAB> return <SPC> self . stack2 [ - 1 ] <NL> <NL> <TAB> def <SPC> empty ( self ) : <NL> <NL> <TAB> return <SPC> len ( self . stack1 ) <SPC> + <SPC> len ( self . stack2 ) <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isPalindrome ( self , <SPC> head ) : <NL> <NL> <TAB> if <SPC> head <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <TAB> p1 , <SPC> p2 <SPC> = <SPC> head , <SPC> head <NL> <TAB> p3 , <SPC> pre <SPC> = <SPC> p1 . next , <SPC> p1 <NL> <TAB> while <SPC> p2 . next <SPC> is <SPC> not <SPC> None <SPC> and <SPC> p2 . next . next <SPC> is <SPC> not <SPC> None : <NL>          p2 <SPC> = <SPC> p2 . next . next <NL>          pre <SPC> = <SPC> p1 <NL>          p1 <SPC> = <SPC> p3 <NL>          p3 <SPC> = <SPC> p3 . next <NL>          p1 . next <SPC> = <SPC> pre <NL> <TAB> if <SPC> p2 . next <SPC> is <SPC> None : <NL>          p1 <SPC> = <SPC> p1 . next <NL> <NL> <TAB> while <SPC> p3 <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> p1 . val <SPC> != <SPC> p3 . val : <NL>              return <SPC> False <NL>          p1 <SPC> = <SPC> p1 . next <NL>          p3 <SPC> = <SPC> p3 . next <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> lowestCommonAncestor ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> if <SPC> p <SPC> is <SPC> None <SPC> or <SPC> q <SPC> is <SPC> None <SPC> or <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> None <NL> <TAB> if <SPC> p . val <SPC> < <SPC> root . val <SPC> and <SPC> q . val <SPC> < <SPC> root . val : <NL>          return <SPC> self . lowestCommonAncestor ( root . left , <SPC> p , <SPC> q ) <NL> <TAB> elif <SPC> p . val <SPC> > <SPC> root . val <SPC> and <SPC> q . val <SPC> > <SPC> root . val : <NL>          return <SPC> self . lowestCommonAncestor ( root . right , <SPC> p , <SPC> q ) <NL> <TAB> else : <NL>          return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> lowestCommonAncestor ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> stack <SPC> = <SPC> [ root ] <NL> <NL> <TAB> parent <SPC> = <SPC> { root : <SPC> None } <NL> <NL> <TAB> while <SPC> p <SPC> not <SPC> in <SPC> parent <SPC> or <SPC> q <SPC> not <SPC> in <SPC> parent : <NL> <NL>          node <SPC> = <SPC> stack . pop ( ) <NL> <NL>          if <SPC> node . left : <NL>              parent [ node . left ] <SPC> = <SPC> node <NL>              stack . append ( node . left ) <NL>          if <SPC> node . right : <NL>              parent [ node . right ] <SPC> = <SPC> node <NL>              stack . append ( node . right ) <NL> <NL> <TAB> ancestors <SPC> = <SPC> set ( ) <NL> <NL> <TAB> while <SPC> p : <NL>          ancestors . add ( p ) <NL>          p <SPC> = <SPC> parent [ p ] <NL> <NL> <TAB> while <SPC> q <SPC> not <SPC> in <SPC> ancestors : <NL>          q <SPC> = <SPC> parent [ q ] <NL> <TAB> return <SPC> q <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> deleteNode ( self , <SPC> node ) : <NL> <NL> <TAB> node . val <SPC> = <SPC> node . next . val <NL> <TAB> node . next <SPC> = <SPC> node . next . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> productExceptSelf ( self , <SPC> nums ) : <NL> <NL> <TAB> ans <SPC> = <SPC> [ 1 ] <SPC> * <SPC> len ( nums ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> len ( nums ) ) : <NL>          ans [ i ] <SPC> = <SPC> ans [ i <SPC> - <SPC> 1 ] <SPC> * <SPC> nums [ i <SPC> - <SPC> 1 ] <NL> <TAB> right <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( nums ) <SPC> - <SPC> 1 , <SPC> - 1 , <SPC> - 1 ) : <NL>          ans [ i ] <SPC> *= <SPC> right <NL>          right <SPC> *= <SPC> nums [ i ] <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isAnagram ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> if <SPC> len ( s ) <SPC> != <SPC> len ( t ) : <NL>          return <SPC> False <NL> <TAB> counter <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( s ) ) : <NL>          counter [ ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL>          counter [ ord ( t [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> -= <SPC> 1 <NL> <TAB> for <SPC> num <SPC> in <SPC> counter : <NL>          if <SPC> num <SPC> != <SPC> 0 : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> shortestDistance ( self , <SPC> words , <SPC> word1 , <SPC> word2 ) : <NL> <TAB> index1 <SPC> = <SPC> index2 <SPC> = <SPC> - 1 <NL> <TAB> res <SPC> = <SPC> len ( words ) <NL> <TAB> for <SPC> index , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          if <SPC> word1 <SPC> == <SPC> word : <NL>              index1 <SPC> = <SPC> index <NL>          elif <SPC> word2 <SPC> == <SPC> word : <NL>              index2 <SPC> = <SPC> index <NL>          if <SPC> index1 <SPC> != <SPC> - 1 <SPC> and <SPC> index2 <SPC> != <SPC> - 1 : <NL>              res <SPC> = <SPC> min ( res , <SPC> abs ( index1 <SPC> - <SPC> index2 ) ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isStrobogrammatic ( self , <SPC> num ) : <NL> <NL> <TAB> dic <SPC> = <SPC> { "0" : <SPC> "0" , <SPC> "6" : <SPC> "9" , <SPC> "9" : <SPC> "6" , <SPC> "1" : <SPC> "1" , <SPC> "8" : <SPC> "8" } <NL> <TAB> temp_s <SPC> = <SPC> "" <NL> <TAB> for <SPC> c <SPC> in <SPC> num [ : : - 1 ] : <NL>          if <SPC> c <SPC> not <SPC> in <SPC> dic : <NL>              return <SPC> False <NL>          temp_s <SPC> += <SPC> dic [ c ] <NL> <TAB> if <SPC> int ( temp_s ) <SPC> == <SPC> int ( num ) : <NL>          return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> groupStrings ( self , <SPC> strings ) : <NL> <NL> <TAB> dic <SPC> = <SPC> { } <NL> <TAB> for <SPC> s <SPC> in <SPC> strings : <NL>          key <SPC> = <SPC> self . hashCode ( s ) <NL>          try : <NL>              dic [ key ] . append ( s ) <NL>          except <SPC> KeyError : <NL>              dic [ key ] <SPC> = <SPC> [ s ] <NL> <TAB> return <SPC> dic . values ( ) <NL> <NL> <TAB> def <SPC> hashCode ( self , <SPC> string ) : <NL> <TAB> if <SPC> string <SPC> is <SPC> None <SPC> or <SPC> len ( string ) <SPC> == <SPC> 0 : <NL>          return <SPC> "" <NL> <TAB> if <SPC> len ( string ) <SPC> == <SPC> 1 : <NL>          return <SPC> "a" <NL> <TAB> step <SPC> = <SPC> abs ( ord ( string [ 0 ] ) <SPC> - <SPC> ord ( "a" ) ) <NL> <TAB> if <SPC> step <SPC> == <SPC> 0 : <NL>          return <SPC> string <NL> <TAB> key <SPC> = <SPC> "a" <NL> <TAB> for <SPC> ch <SPC> in <SPC> string [ 1 : ] : <NL>          curr <SPC> = <SPC> ord ( ch ) <SPC> - <SPC> step <NL>          if <SPC> ord ( ch ) <SPC> - <SPC> step <SPC> < <SPC> ord ( "a" ) : <NL>              curr <SPC> += <SPC> 26 <NL>          key <SPC> += <SPC> chr ( curr ) <NL> <TAB> return <SPC> key <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> canAttendMeetings ( self , <SPC> intervals ) : <NL> <TAB> intervals . sort ( key = lambda <SPC> x : <SPC> x . start ) <NL> <TAB> ls <SPC> = <SPC> len ( intervals ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls <SPC> - <SPC> 1 ) : <NL>          if <SPC> intervals [ i ] . end <SPC> > <SPC> intervals [ i <SPC> + <SPC> 1 ] . start : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minMeetingRooms ( self , <SPC> intervals ) : <NL> <NL> <TAB> timeline <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> interval <SPC> in <SPC> intervals : <NL> <NL>          timeline . append ( ( interval . start , <SPC> 1 ) ) <NL> <NL>          timeline . append ( ( interval . end , <SPC> - 1 ) ) <NL> <NL> <TAB> timeline . sort ( ) <NL> <TAB> ans <SPC> = <SPC> curr <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> _ , <SPC> v <SPC> in <SPC> timeline : <NL>          curr <SPC> += <SPC> v <NL> <NL>          ans <SPC> = <SPC> max ( ans , <SPC> curr ) <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution : <NL> <NL> <TAB> def <SPC> binaryTreePaths ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <TAB> paths <SPC> = <SPC> [ ] <NL> <TAB> self . get_path ( paths , <SPC> [ ] , <SPC> root ) <NL> <TAB> res <SPC> = <SPC> [ "->" . join ( p ) <SPC> for <SPC> p <SPC> in <SPC> paths ] <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> get_path ( self , <SPC> result , <SPC> path , <SPC> node ) : <NL> <TAB> if <SPC> node . left <SPC> is <SPC> None <SPC> and <SPC> node . right <SPC> is <SPC> None : <NL>          result . append ( path <SPC> + <SPC> [ str ( node . val ) ] ) <NL>          return <NL> <TAB> path <SPC> = <SPC> path <SPC> + <SPC> [ str ( node . val ) ] <NL> <TAB> if <SPC> node . left <SPC> is <SPC> not <SPC> None : <NL>          self . get_path ( result , <SPC> path , <SPC> node . left ) <NL> <TAB> if <SPC> node . right <SPC> is <SPC> not <SPC> None : <NL>          self . get_path ( result , <SPC> path , <SPC> node . right ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> addDigits ( self , <SPC> num ) : <NL> <NL> <TAB> if <SPC> num <SPC> < <SPC> 10 : <NL>          return <SPC> num <NL> <TAB> return <SPC> num <SPC> - <SPC> ( ( num <SPC> - <SPC> 1 ) <SPC> / <SPC> 9 ) <SPC> * <SPC> 9 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> threeSumSmaller ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> ls <SPC> = <SPC> len ( nums ) <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls <SPC> - <SPC> 1 ) : <NL>          res <SPC> += <SPC> self . twoSumSmaller ( nums , <SPC> i <SPC> + <SPC> 1 , <SPC> target <SPC> - <SPC> nums [ i ] ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> twoSumSmaller ( self , <SPC> nums , <SPC> start , <SPC> target ) : <NL> <TAB> res , <SPC> left , <SPC> right <SPC> = <SPC> 0 , <SPC> start , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          if <SPC> nums [ left ] <SPC> + <SPC> nums [ right ] <SPC> < <SPC> target : <NL>              res <SPC> += <SPC> right <SPC> - <SPC> left <NL>              left <SPC> += <SPC> 1 <NL>          else : <NL>              right <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isUgly ( self , <SPC> num ) : <NL> <TAB> if <SPC> num <SPC> <= <SPC> 0 : <NL>          return <SPC> False <NL> <TAB> divisors <SPC> = <SPC> [ 2 , <SPC> 3 , <SPC> 5 ] <NL> <TAB> for <SPC> d <SPC> in <SPC> divisors : <NL>          while <SPC> num <SPC> % <SPC> d <SPC> == <SPC> 0 : <NL>              num <SPC> /= <SPC> d <NL> <TAB> return <SPC> num <SPC> == <SPC> 1 <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . isUgly ( - 2147483648 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nthUglyNumber ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> <= <SPC> 5 : <NL>          return <SPC> n <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> l1 <SPC> = <SPC> l2 <SPC> = <SPC> l3 <SPC> = <SPC> 1 <NL> <TAB> dp [ 1 ] <SPC> = <SPC> 1 <NL> <TAB> dp [ 2 ] <SPC> = <SPC> 2 <NL> <TAB> dp [ 3 ] <SPC> = <SPC> 3 <NL> <TAB> dp [ 4 ] <SPC> = <SPC> 4 <NL> <TAB> dp [ 5 ] <SPC> = <SPC> 5 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 6 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          while <SPC> dp [ l1 ] <SPC> * <SPC> 2 <SPC> <= <SPC> dp [ i <SPC> - <SPC> 1 ] : <NL>              l1 <SPC> += <SPC> 1 <NL>          while <SPC> dp [ l2 ] <SPC> * <SPC> 3 <SPC> <= <SPC> dp [ i <SPC> - <SPC> 1 ] : <NL>              l2 <SPC> += <SPC> 1 <NL>          while <SPC> dp [ l3 ] <SPC> * <SPC> 5 <SPC> <= <SPC> dp [ i <SPC> - <SPC> 1 ] : <NL>              l3 <SPC> += <SPC> 1 <NL>          print <SPC> l1 , <SPC> l2 , <SPC> l3 <NL>          dp [ i ] <SPC> = <SPC> min ( dp [ l1 ] <SPC> * <SPC> 2 , <SPC> dp [ l2 ] <SPC> * <SPC> 3 , <SPC> dp [ l3 ] <SPC> * <SPC> 5 ) <NL> <NL> <TAB> return <SPC> dp [ n ] <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . nthUglyNumber ( 10 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canPermutePalindrome ( self , <SPC> s ) : <NL> <NL> <TAB> dic <SPC> = <SPC> { } <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          dic [ c ] <SPC> = <SPC> dic . get ( c , <SPC> 0 ) <SPC> + <SPC> 1 <NL> <TAB> odd , <SPC> even <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> dic : <NL>          if <SPC> dic [ c ] <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              even <SPC> += <SPC> 1 <NL>          else : <NL>              odd <SPC> += <SPC> 1 <NL> <TAB> if <SPC> odd <SPC> <= <SPC> 1 : <NL>          return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> generatePalindromes ( self , <SPC> s ) : <NL> <NL> <TAB> dic <SPC> = <SPC> { } <NL> <TAB> half <SPC> = <SPC> [ ] <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          dic [ c ] <SPC> = <SPC> dic . get ( c , <SPC> 0 ) <SPC> + <SPC> 1 <NL> <TAB> odd , <SPC> even <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> dic : <NL>          if <SPC> dic [ c ] <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              even <SPC> += <SPC> 1 <NL>          else : <NL>              odd <SPC> += <SPC> 1 <NL> <TAB> if <SPC> odd <SPC> > <SPC> 1 : <NL>          return <SPC> [ ] <NL> <NL> <TAB> seed <SPC> = <SPC> [ ] <NL> <TAB> mid <SPC> = <SPC> "" <NL> <TAB> for <SPC> c <SPC> in <SPC> dic : <NL>          if <SPC> dic [ c ] <SPC> % <SPC> 2 <SPC> == <SPC> 1 : <NL>              mid <SPC> = <SPC> c <NL>          seed . extend ( [ c ] <SPC> * <SPC> ( dic [ c ] <SPC> / <SPC> 2 ) ) <NL> <TAB> self . permute ( half , <SPC> seed , <SPC> 0 ) <NL> <NL> <TAB> for <SPC> r <SPC> in <SPC> half : <NL>          res . append ( "" . join ( r ) <SPC> + <SPC> mid <SPC> + <SPC> "" . join ( reversed ( r ) ) ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> permute ( self , <SPC> res , <SPC> num , <SPC> index ) : <NL> <TAB> if <SPC> index <SPC> == <SPC> len ( num ) : <NL>          res . append ( list ( num ) ) <NL>          return <NL> <TAB> appeared <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( index , <SPC> len ( num ) ) : <NL>          if <SPC> num [ i ] <SPC> in <SPC> appeared : <NL>              continue <NL>          appeared . add ( num [ i ] ) <NL>          num [ i ] , <SPC> num [ index ] <SPC> = <SPC> num [ index ] , <SPC> num [ i ] <NL>          self . permute ( res , <SPC> num , <SPC> index <SPC> + <SPC> 1 ) <NL>          num [ i ] , <SPC> num [ index ] <SPC> = <SPC> num [ index ] , <SPC> num [ i ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> missingNumber ( self , <SPC> nums ) : <NL> <TAB> res <SPC> = <SPC> len ( nums ) <NL> <TAB> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( nums ) : <NL>          res <SPC> ^= <SPC> i <NL>          res <SPC> ^= <SPC> v <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> closestValue ( self , <SPC> root , <SPC> target ) : <NL> <NL> <TAB> kid <SPC> = <SPC> root . left <SPC> if <SPC> target <SPC> < <SPC> root . val <SPC> else <SPC> root . right <NL> <TAB> if <SPC> not <SPC> kid : <NL>          return <SPC> root . val <NL> <TAB> kid_min <SPC> = <SPC> self . closestValue ( kid , <SPC> target ) <NL> <TAB> return <SPC> min ( ( kid_min , <SPC> root . val ) , <SPC> key = lambda <SPC> x : <SPC> abs ( target <SPC> - <SPC> x ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberToWords ( self , <SPC> num ) : <NL> <NL> <TAB> to19 <SPC> = <SPC> ( <NL>          "One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve " <NL>          "Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen" . split ( ) <NL> <TAB> ) <NL> <TAB> tens <SPC> = <SPC> "Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety" . split ( ) <NL> <NL> <TAB> def <SPC> words ( n ) : <NL>          if <SPC> n <SPC> < <SPC> 20 : <NL>              return <SPC> to19 [ n <SPC> - <SPC> 1 : <SPC> n ] <NL>          if <SPC> n <SPC> < <SPC> 100 : <NL>              return <SPC> [ tens [ n <SPC> / <SPC> 10 <SPC> - <SPC> 2 ] ] <SPC> + <SPC> words ( n <SPC> % <SPC> 10 ) <NL>          if <SPC> n <SPC> < <SPC> 1000 : <NL>              return <SPC> [ to19 [ n <SPC> / <SPC> 100 <SPC> - <SPC> 1 ] ] <SPC> + <SPC> [ "Hundred" ] <SPC> + <SPC> words ( n <SPC> % <SPC> 100 ) <NL>          for <SPC> p , <SPC> w <SPC> in <SPC> enumerate ( ( "Thousand" , <SPC> "Million" , <SPC> "Billion" ) , <SPC> 1 ) : <NL>              if <SPC> n <SPC> < <SPC> 1000 <SPC> ** <SPC> ( p <SPC> + <SPC> 1 ) : <NL>                  return <SPC> words ( n <SPC> / <SPC> 1000 <SPC> ** <SPC> p ) <SPC> + <SPC> [ w ] <SPC> + <SPC> words ( n <SPC> % <SPC> 1000 <SPC> ** <SPC> p ) <NL> <NL> <TAB> return <SPC> " " . join ( words ( num ) ) <SPC> or <SPC> "Zero" <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> hIndex ( self , <SPC> citations ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( citations ) <NL> <TAB> papers <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( ls <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> c <SPC> in <SPC> citations : <NL>          papers [ min ( ls , <SPC> c ) ] <SPC> += <SPC> 1 <NL> <TAB> k , <SPC> s <SPC> = <SPC> ls , <SPC> papers [ ls ] <NL> <TAB> while <SPC> k <SPC> > <SPC> s : <NL>          k <SPC> -= <SPC> 1 <NL>          s <SPC> += <SPC> papers [ k ] <NL> <TAB> return <SPC> k <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> numWays ( self , <SPC> n , <SPC> k ) : <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> elif <SPC> n <SPC> == <SPC> 1 : <NL>          return <SPC> k <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 <NL> <TAB> dp [ 0 ] <SPC> = <SPC> k <NL> <TAB> dp [ 1 ] <SPC> = <SPC> k <SPC> * <SPC> k <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 2 , <SPC> n ) : <NL>          temp <SPC> = <SPC> dp [ 1 ] <NL>          dp [ 1 ] <SPC> = <SPC> sum ( dp ) <SPC> * <SPC> ( k <SPC> - <SPC> 1 ) <NL>          dp [ 0 ] <SPC> = <SPC> temp <NL> <TAB> return <SPC> dp [ 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> firstBadVersion ( self , <SPC> n ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> n <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> ( right <SPC> + <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> isBadVersion ( mid ) : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> wiggleSort ( self , <SPC> nums ) : <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( nums ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> ( i <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> and <SPC> nums [ i ] <SPC> > <SPC> nums [ i <SPC> + <SPC> 1 ] ) <SPC> or <SPC> ( <NL>              i <SPC> % <SPC> 2 <SPC> == <SPC> 1 <SPC> and <SPC> nums [ i ] <SPC> < <SPC> nums [ i <SPC> + <SPC> 1 ] <NL>          ) : <NL>              nums [ i ] , <SPC> nums [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> nums [ i <SPC> + <SPC> 1 ] , <SPC> nums [ i ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> moveZeroes ( self , <SPC> nums ) : <NL> <NL> <TAB> ls <SPC> = <SPC> len ( nums ) <NL> <TAB> n_pos <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls ) : <NL>          if <SPC> nums [ i ] <SPC> != <SPC> 0 : <NL>              temp <SPC> = <SPC> nums [ n_pos ] <NL>              nums [ n_pos ] <SPC> = <SPC> nums [ i ] <NL>              nums [ i ] <SPC> = <SPC> temp <NL>              n_pos <SPC> += <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wallsAndGates ( self , <SPC> rooms ) : <NL> <NL> <TAB> direction <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> m <SPC> = <SPC> len ( rooms ) <NL> <TAB> if <SPC> m <SPC> == <SPC> 0 : <NL>          return <NL> <TAB> n <SPC> = <SPC> len ( rooms [ 0 ] ) <NL> <TAB> q <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> row <SPC> in <SPC> range ( m ) : <NL>          for <SPC> col <SPC> in <SPC> range ( n ) : <NL> <NL>              if <SPC> rooms [ row ] [ col ] <SPC> == <SPC> 0 : <NL>                  q . append ( ( row , <SPC> col ) ) <NL> <NL> <TAB> while <SPC> len ( q ) <SPC> > <SPC> 0 : <NL>          point <SPC> = <SPC> q . pop ( 0 ) <NL>          row , <SPC> col <SPC> = <SPC> point [ 0 ] , <SPC> point [ 1 ] <NL>          for <SPC> d <SPC> in <SPC> direction : <NL>              r <SPC> = <SPC> row <SPC> + <SPC> d [ 0 ] <NL>              c <SPC> = <SPC> col <SPC> + <SPC> d [ 1 ] <NL> <NL>              if <SPC> r <SPC> < <SPC> 0 <SPC> or <SPC> c <SPC> < <SPC> 0 <SPC> or <SPC> r <SPC> >= <SPC> m <SPC> or <SPC> c <SPC> >= <SPC> n <SPC> or <SPC> rooms [ r ] [ c ] <SPC> != <SPC> 2147483647 : <NL>                  continue <NL>              rooms [ r ] [ c ] <SPC> = <SPC> rooms [ row ] [ col ] <SPC> + <SPC> 1 <NL>              q . append ( ( r , <SPC> c ) ) <NL> <NL> <NL> class <SPC> ValidWordAbbr ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> dictionary ) : <NL> <NL> <TAB> self . dictionary <SPC> = <SPC> set ( dictionary ) <NL> <TAB> self . abb_dic <SPC> = <SPC> { } <NL> <TAB> for <SPC> s <SPC> in <SPC> self . dictionary : <NL>          curr <SPC> = <SPC> self . getAbb ( s ) <NL>          if <SPC> curr <SPC> in <SPC> self . abb_dic : <NL>              self . abb_dic [ curr ] <SPC> = <SPC> False <NL>          else : <NL>              self . abb_dic [ curr ] <SPC> = <SPC> True <NL> <NL> <TAB> def <SPC> isUnique ( self , <SPC> word ) : <NL> <NL> <TAB> abb <SPC> = <SPC> self . getAbb ( word ) <NL> <TAB> hasAbbr <SPC> = <SPC> self . abb_dic . get ( abb , <SPC> None ) <NL> <TAB> return <SPC> hasAbbr <SPC> == <SPC> None <SPC> or <SPC> ( hasAbbr <SPC> and <SPC> word <SPC> in <SPC> self . dictionary ) <NL> <NL> <TAB> def <SPC> getAbb ( self , <SPC> word ) : <NL> <TAB> if <SPC> len ( word ) <SPC> <= <SPC> 2 : <NL>          return <SPC> word <NL> <TAB> return <SPC> word [ 0 ] <SPC> + <SPC> str ( len ( word ) <SPC> - <SPC> 2 ) <SPC> + <SPC> word [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wordPattern ( self , <SPC> pattern , <SPC> str ) : <NL> <NL> <TAB> if <SPC> pattern <SPC> is <SPC> None <SPC> or <SPC> str <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <NL> <TAB> words_to_pattern <SPC> = <SPC> { } <NL> <TAB> pattern_to_words <SPC> = <SPC> { } <NL> <TAB> word_list <SPC> = <SPC> str . split ( " " ) <NL> <TAB> if <SPC> len ( word_list ) <SPC> != <SPC> len ( pattern ) : <NL>          return <SPC> False <NL> <TAB> for <SPC> index , <SPC> word <SPC> in <SPC> enumerate ( word_list ) : <NL>          curr_p <SPC> = <SPC> pattern [ index ] <NL>          if <SPC> ( <NL>              pattern_to_words . get ( curr_p , <SPC> word ) <SPC> != <SPC> word <NL>              or <SPC> words_to_pattern . get ( word , <SPC> curr_p ) <SPC> != <SPC> curr_p <NL>          ) : <NL>              return <SPC> False <NL>          pattern_to_words [ curr_p ] <SPC> = <SPC> pattern_to_words . get ( curr_p , <SPC> word ) <NL>          words_to_pattern [ word ] <SPC> = <SPC> words_to_pattern . get ( word , <SPC> curr_p ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canWinNim ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> n <SPC> % <SPC> 4 <SPC> != <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> generatePossibleNextMoves ( self , <SPC> s ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> s <SPC> is <SPC> None <SPC> or <SPC> len ( s ) <SPC> == <SPC> 0 : <NL>          return <SPC> res <NL> <TAB> ls <SPC> = <SPC> len ( s ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls <SPC> - <SPC> 1 ) : <NL>          if <SPC> s [ i ] <SPC> == <SPC> "+" <SPC> and <SPC> s [ i <SPC> + <SPC> 1 ] <SPC> == <SPC> "+" : <NL>              res . append ( s [ : i ] <SPC> + <SPC> "--" <SPC> + <SPC> s [ i <SPC> + <SPC> 2 : ] ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> canWin ( self , <SPC> s ) : <NL> <TAB> if <SPC> s <SPC> is <SPC> None <SPC> or <SPC> len ( s ) <SPC> < <SPC> 2 : <NL>          return <SPC> False <NL> <TAB> list_s <SPC> = <SPC> list ( s ) <NL> <TAB> return <SPC> self . canWin_helper ( list_s ) <NL> <NL> <TAB> def <SPC> canWin_helper ( self , <SPC> s ) : <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( s ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> s [ i ] <SPC> == <SPC> "+" <SPC> and <SPC> s [ i <SPC> + <SPC> 1 ] <SPC> == <SPC> "+" : <NL>              s [ i ] <SPC> = <SPC> "-" <NL>              s [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> "-" <NL>              res <SPC> = <SPC> self . canWin_helper ( s ) <NL>              s [ i ] <SPC> = <SPC> "+" <NL>              s [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> "+" <NL>              if <SPC> not <SPC> res : <NL>                  return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . canWin ( "++++" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> minDistance1D ( self , <SPC> points ) : <NL> <NL> <TAB> distance <SPC> = <SPC> 0 <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> len ( points ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> j : <NL>          distance <SPC> += <SPC> points [ j ] <SPC> - <SPC> points [ i ] <NL>          i <SPC> += <SPC> 1 <NL>          j <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> distance <NL> <NL> <TAB> def <SPC> minTotalDistance ( self , <SPC> grid ) : <NL> <TAB> rows <SPC> = <SPC> self . collectRows ( grid ) <NL> <TAB> cols <SPC> = <SPC> self . collectCols ( grid ) <NL> <TAB> row <SPC> = <SPC> rows [ len ( rows ) <SPC> / <SPC> 2 ] <NL> <TAB> col <SPC> = <SPC> cols [ len ( cols ) <SPC> / <SPC> 2 ] <NL> <TAB> return <SPC> self . minDistance1D ( rows ) <SPC> + <SPC> self . minDistance1D ( cols ) <NL> <NL> <TAB> def <SPC> collectRows ( self , <SPC> grid ) : <NL> <TAB> rows <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> range ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> == <SPC> 1 : <NL>                  rows . append ( i ) <NL> <TAB> return <SPC> rows <NL> <NL> <TAB> def <SPC> collectCols ( self , <SPC> grid ) : <NL> <TAB> cols <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> j <SPC> in <SPC> range ( len ( grid [ 0 ] ) ) : <NL>          for <SPC> i <SPC> in <SPC> range ( len ( grid ) ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> == <SPC> 1 : <NL>                  cols . append ( j ) <NL> <TAB> return <SPC> cols <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestConsecutive ( self , <SPC> root ) : <NL> <NL> <TAB> return <SPC> self . longestConsecutive_helper ( root , <SPC> - 10000 , <SPC> 1 ) <NL> <NL> <TAB> def <SPC> longestConsecutive_helper ( self , <SPC> root , <SPC> previous , <SPC> curr ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <TAB> if <SPC> root . val <SPC> - <SPC> 1 <SPC> == <SPC> previous : <NL>          curr <SPC> += <SPC> 1 <NL> <TAB> else : <NL>          curr <SPC> = <SPC> 1 <NL> <TAB> l_res <SPC> = <SPC> self . longestConsecutive_helper ( root . left , <SPC> root . val , <SPC> curr ) <NL> <TAB> r_res <SPC> = <SPC> self . longestConsecutive_helper ( root . right , <SPC> root . val , <SPC> curr ) <NL> <TAB> return <SPC> max ( curr , <SPC> l_res , <SPC> r_res ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getHint ( self , <SPC> secret , <SPC> guess ) : <NL> <NL> <TAB> check <SPC> = <SPC> { } <NL> <TAB> ls <SPC> = <SPC> len ( secret ) <NL> <TAB> bull , <SPC> cow <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> different <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls ) : <NL>          if <SPC> guess [ i ] <SPC> == <SPC> secret [ i ] : <NL>              bull <SPC> += <SPC> 1 <NL>          else : <NL> <NL>              different . append ( i ) <NL>              try : <NL>                  check [ secret [ i ] ] <SPC> += <SPC> 1 <NL>              except <SPC> KeyError : <NL>                  check [ secret [ i ] ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> different : <NL>          try : <NL>              if <SPC> check [ guess [ i ] ] <SPC> > <SPC> 0 : <NL>                  cow <SPC> += <SPC> 1 <NL>                  check [ guess [ i ] ] <SPC> -= <SPC> 1 <NL>          except : <NL>              pass <NL> <TAB> return <SPC> "%dA%dB" <SPC> % <SPC> ( bull , <SPC> cow ) <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . getHint ( "1122" , <SPC> "1222" ) <NL> <NL> <NL> class <SPC> NumArray ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> nums ) : <NL> <NL> <TAB> self . res <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( nums ) <SPC> + <SPC> 1 ) <NL> <TAB> self . data <SPC> = <SPC> list ( nums ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( self . data ) ) : <NL>          self . res [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> self . res [ i ] <SPC> + <SPC> nums [ i ] <NL> <NL> <TAB> def <SPC> sumRange ( self , <SPC> i , <SPC> j ) : <NL> <NL> <TAB> return <SPC> self . res [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> self . res [ i ] <NL> <NL> <NL> class <SPC> NumMatrix ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> matrix ) : <NL> <NL> <TAB> if <SPC> matrix <SPC> is <SPC> None <SPC> or <SPC> len ( matrix ) <SPC> == <SPC> 0 : <NL>          return <NL> <TAB> height , <SPC> width <SPC> = <SPC> len ( matrix ) , <SPC> len ( matrix [ 0 ] ) <NL> <TAB> self . dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( width <SPC> + <SPC> 1 ) <SPC> for <SPC> i <SPC> in <SPC> range ( height <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( height ) : <NL>          for <SPC> j <SPC> in <SPC> range ( width ) : <NL>              self . dp [ i <SPC> + <SPC> 1 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> ( <NL>                  self . dp [ i <SPC> + <SPC> 1 ] [ j ] <SPC> + <SPC> self . dp [ i ] [ j <SPC> + <SPC> 1 ] <SPC> + <NL>                  matrix [ i ] [ j ] <SPC> - <SPC> self . dp [ i ] [ j ] <NL>              ) <NL> <NL> <TAB> def <SPC> sumRegion ( self , <SPC> row1 , <SPC> col1 , <SPC> row2 , <SPC> col2 ) : <NL> <NL> <TAB> return <SPC> ( <NL>          self . dp [ row2 <SPC> + <SPC> 1 ] [ col2 <SPC> + <SPC> 1 ] <NL>          - <SPC> self . dp [ row1 ] [ col2 <SPC> + <SPC> 1 ] <NL>          - <SPC> self . dp [ row2 <SPC> + <SPC> 1 ] [ col1 ] <NL>          + <SPC> self . dp [ row1 ] [ col1 ] <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numIslands2 ( self , <SPC> m , <SPC> n , <SPC> positions ) : <NL> <NL> <TAB> ans <SPC> = <SPC> [ ] <NL> <TAB> islands <SPC> = <SPC> Union ( ) <NL> <TAB> for <SPC> p <SPC> in <SPC> map ( tuple , <SPC> positions ) : <NL>          islands . add ( p ) <NL>          for <SPC> dp <SPC> in <SPC> ( 0 , <SPC> 1 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( - 1 , <SPC> 0 ) : <NL>              q <SPC> = <SPC> ( p [ 0 ] <SPC> + <SPC> dp [ 0 ] , <SPC> p [ 1 ] <SPC> + <SPC> dp [ 1 ] ) <NL>              if <SPC> q <SPC> in <SPC> islands . id : <NL>                  islands . unite ( p , <SPC> q ) <NL>          ans <SPC> += <SPC> [ islands . count ] <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Union ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . id <SPC> = <SPC> { } <NL> <TAB> self . sz <SPC> = <SPC> { } <NL> <TAB> self . count <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> add ( self , <SPC> p ) : <NL> <TAB> self . id [ p ] <SPC> = <SPC> p <NL> <TAB> self . sz [ p ] <SPC> = <SPC> 1 <NL> <TAB> self . count <SPC> += <SPC> 1 <NL> <NL> <TAB> def <SPC> root ( self , <SPC> i ) : <NL> <TAB> while <SPC> i <SPC> != <SPC> self . id [ i ] : <NL>          self . id [ i ] <SPC> = <SPC> self . id [ self . id [ i ] ] <NL>          i <SPC> = <SPC> self . id [ i ] <NL> <TAB> return <SPC> i <NL> <NL> <TAB> def <SPC> unite ( self , <SPC> p , <SPC> q ) : <NL> <TAB> i , <SPC> j <SPC> = <SPC> self . root ( p ) , <SPC> self . root ( q ) <NL> <TAB> if <SPC> i <SPC> == <SPC> j : <NL>          return <NL> <TAB> if <SPC> self . sz [ i ] <SPC> > <SPC> self . sz [ j ] : <NL>          i , <SPC> j <SPC> = <SPC> j , <SPC> i <NL> <TAB> self . id [ i ] <SPC> = <SPC> j <NL> <TAB> self . sz [ j ] <SPC> += <SPC> self . sz [ i ] <NL> <TAB> self . count <SPC> -= <SPC> 1 <NL> <NL> <NL> class <SPC> NumArray ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> nums ) : <NL> <NL> <TAB> self . ls <SPC> = <SPC> len ( nums ) <NL> <TAB> self . tree <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( self . ls <SPC> * <SPC> 2 ) <NL> <TAB> self . buildTree ( nums ) <NL> <NL> <TAB> def <SPC> buildTree ( self , <SPC> nums ) : <NL> <TAB> i , <SPC> j <SPC> = <SPC> self . ls , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> 2 <SPC> * <SPC> self . ls : <NL>          self . tree [ i ] <SPC> = <SPC> nums [ j ] <NL>          i <SPC> += <SPC> 1 <NL>          j <SPC> += <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( range ( 1 , <SPC> self . ls ) ) : <NL>          self . tree [ i ] <SPC> = <SPC> self . tree [ i <SPC> * <SPC> 2 ] <SPC> + <SPC> self . tree [ i <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] <NL> <NL> <TAB> def <SPC> update ( self , <SPC> i , <SPC> val ) : <NL> <NL> <TAB> i <SPC> += <SPC> self . ls <NL> <TAB> self . tree [ i ] <SPC> = <SPC> val <NL> <TAB> while <SPC> i <SPC> > <SPC> 0 : <NL>          left <SPC> = <SPC> right <SPC> = <SPC> i <NL>          if <SPC> i <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              right <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> i <SPC> - <SPC> 1 <NL>          self . tree [ i <SPC> / <SPC> 2 ] <SPC> = <SPC> self . tree [ left ] <SPC> + <SPC> self . tree [ right ] <NL>          i <SPC> /= <SPC> 2 <NL> <NL> <TAB> def <SPC> sumRange ( self , <SPC> i , <SPC> j ) : <NL> <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> i <SPC> += <SPC> self . ls <NL> <TAB> j <SPC> += <SPC> self . ls <NL> <NL> <TAB> while <SPC> i <SPC> <= <SPC> j : <NL>          if <SPC> i <SPC> % <SPC> 2 <SPC> == <SPC> 1 : <NL>              res <SPC> += <SPC> self . tree [ i ] <NL>              i <SPC> += <SPC> 1 <NL>          if <SPC> j <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              res <SPC> += <SPC> self . tree [ j ] <NL>              j <SPC> -= <SPC> 1 <NL>          i <SPC> /= <SPC> 2 <NL>          j <SPC> /= <SPC> 2 <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> coinChange ( self , <SPC> coins , <SPC> amount ) : <NL> <NL> <TAB> if <SPC> amount <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> if <SPC> coins <SPC> is <SPC> None <SPC> or <SPC> len ( coins ) <SPC> == <SPC> 0 : <NL>          return <SPC> - 1 <NL> <TAB> coins . sort ( ) <NL> <TAB> dp <SPC> = <SPC> [ 1000000000 ] <SPC> * <SPC> ( amount <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> amount <SPC> + <SPC> 1 ) : <NL>          for <SPC> coin <SPC> in <SPC> coins : <NL>              if <SPC> i <SPC> == <SPC> coin : <NL>                  dp [ i ] <SPC> = <SPC> 1 <NL>                  break <NL>              elif <SPC> i <SPC> > <SPC> coin : <NL>                  dp [ i ] <SPC> = <SPC> min ( dp [ i ] , <SPC> dp [ i <SPC> - <SPC> coin ] <SPC> + <SPC> 1 ) <NL> <TAB> if <SPC> dp [ amount ] <SPC> == <SPC> 1000000000 : <NL>          return <SPC> - 1 <NL> <TAB> return <SPC> dp [ amount ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isPowerOfThree ( self , <SPC> n ) : <NL> <TAB> max3pow <SPC> = <SPC> 1162261467 <NL> <TAB> if <SPC> n <SPC> <= <SPC> 0 <SPC> or <SPC> n <SPC> > <SPC> max3pow : <NL>          return <SPC> False <NL> <TAB> return <SPC> max3pow <SPC> % <SPC> n <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> oddEvenList ( self , <SPC> head ) : <NL> <NL> <TAB> odd <SPC> = <SPC> head <NL> <TAB> if <SPC> head <SPC> is <SPC> None : <NL>          return <SPC> None <NL> <TAB> if <SPC> head . next <SPC> is <SPC> None : <NL>          return <SPC> head <NL> <TAB> even_head <SPC> = <SPC> even <SPC> = <SPC> head . next <NL> <TAB> while <SPC> odd . next <SPC> is <SPC> not <SPC> None <SPC> and <SPC> even . next <SPC> is <SPC> not <SPC> None : <NL>          odd . next <SPC> = <SPC> even . next <NL>          odd <SPC> = <SPC> odd . next <NL>          even . next <SPC> = <SPC> odd . next <NL>          even <SPC> = <SPC> even . next <NL> <TAB> odd . next <SPC> = <SPC> even_head <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> palindromePairs ( self , <SPC> words ) : <NL> <NL> <TAB> word2index , <SPC> res <SPC> = <SPC> dict ( [ ( w [ : : - 1 ] , <SPC> i ) <SPC> for <SPC> i , <SPC> w <SPC> in <SPC> enumerate ( words ) ] ) , <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( word ) <SPC> + <SPC> 1 ) : <NL> <NL>              prefix , <SPC> postfix <SPC> = <SPC> word [ : j ] , <SPC> word [ j : ] <NL> <NL>              if <SPC> ( <NL>                  prefix <SPC> in <SPC> word2index <NL>                  and <SPC> i <SPC> != <SPC> word2index [ prefix ] <NL>                  and <SPC> postfix <SPC> == <SPC> postfix [ : : - 1 ] <NL>              ) : <NL>                  res . append ( [ i , <SPC> word2index [ prefix ] ] ) <NL> <NL>              if <SPC> ( <NL>                  j <SPC> > <SPC> 0 <NL>                  and <SPC> postfix <SPC> in <SPC> word2index <NL>                  and <SPC> i <SPC> != <SPC> word2index [ postfix ] <NL>                  and <SPC> prefix <SPC> == <SPC> prefix [ : : - 1 ] <NL>              ) : <NL>                  res . append ( [ word2index [ postfix ] , <SPC> i ] ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> rob ( self , <SPC> root ) : <NL> <NL> <TAB> res <SPC> = <SPC> self . rob_helper ( root ) <NL> <TAB> return <SPC> max ( res [ 0 ] , <SPC> res [ 1 ] ) <NL> <NL> <TAB> def <SPC> rob_helper ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ 0 , <SPC> 0 ] <NL> <TAB> left <SPC> = <SPC> self . rob_helper ( root . left ) <NL> <TAB> right <SPC> = <SPC> self . rob_helper ( root . right ) <NL> <TAB> res <SPC> = <SPC> [ 0 , <SPC> 0 ] <NL> <TAB> res [ 0 ] <SPC> = <SPC> max ( left [ 0 ] , <SPC> left [ 1 ] ) <SPC> + <SPC> max ( right [ 0 ] , <SPC> right [ 1 ] ) <NL> <TAB> res [ 1 ] <SPC> = <SPC> root . val <SPC> + <SPC> left [ 0 ] <SPC> + <SPC> right [ 0 ] <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countBits ( self , <SPC> num ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( num <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> num <SPC> + <SPC> 1 ) : <NL> <NL>          res [ i ] <SPC> = <SPC> res [ i <SPC> >> <SPC> 1 ] <SPC> + <SPC> ( i <SPC> & <SPC> 1 ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> depthSum ( self , <SPC> nestedList ) : <NL> <NL> <TAB> return <SPC> self . depthSum_helper ( nestedList , <SPC> 1 ) <NL> <NL> <TAB> def <SPC> depthSum_helper ( self , <SPC> nestedList , <SPC> depth ) : <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> for <SPC> l <SPC> in <SPC> nestedList : <NL>          if <SPC> l . isInteger ( ) : <NL>              res <SPC> += <SPC> l . getInteger ( ) <SPC> * <SPC> depth <NL>          else : <NL>              res <SPC> += <SPC> self . depthSum_helper ( l . getList ( ) , <SPC> depth <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lengthOfLongestSubstringKDistinct ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 256 <NL> <TAB> i , <SPC> numDistinct , <SPC> maxLen <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> range ( len ( s ) ) : <NL> <NL>          if <SPC> count [ ord ( s [ j ] ) ] <SPC> == <SPC> 0 : <NL>              numDistinct <SPC> += <SPC> 1 <NL>          count [ ord ( s [ j ] ) ] <SPC> += <SPC> 1 <NL> <NL>          while <SPC> numDistinct <SPC> > <SPC> k : <NL>              count [ ord ( s [ i ] ) ] <SPC> -= <SPC> 1 <NL>              if <SPC> count [ ord ( s [ i ] ) ] <SPC> == <SPC> 0 : <NL>                  numDistinct <SPC> -= <SPC> 1 <NL>              i <SPC> += <SPC> 1 <NL>          maxLen <SPC> = <SPC> max ( j <SPC> - <SPC> i <SPC> + <SPC> 1 , <SPC> maxLen ) <NL> <TAB> return <SPC> maxLen <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPowerOfFour ( self , <SPC> num ) : <NL> <NL> <TAB> return <SPC> num <SPC> > <SPC> 0 <SPC> and <SPC> num <SPC> & <SPC> ( num <SPC> - <SPC> 1 ) <SPC> == <SPC> 0 <SPC> and <SPC> len ( bin ( num ) [ 3 : ] ) <SPC> % <SPC> 2 <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseString ( self , <SPC> s ) : <NL> <NL> <TAB> return <SPC> s [ : : - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseVowels ( self , <SPC> s ) : <NL> <NL> <TAB> str_index <SPC> = <SPC> [ ] <NL> <TAB> vowel <SPC> = <SPC> [ ] <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> pos <SPC> = <SPC> - 1 <NL> <TAB> for <SPC> index , <SPC> value <SPC> in <SPC> enumerate ( s ) : <NL>          if <SPC> value <SPC> in <SPC> "aeiouAEIOU" : <NL>              str_index . append ( - 1 ) <NL>              vowel . append ( value ) <NL>          else : <NL>              str_index . append ( index ) <NL> <TAB> for <SPC> index <SPC> in <SPC> str_index : <NL>          if <SPC> index <SPC> < <SPC> 0 : <NL>              res . append ( vowel [ pos ] ) <NL>              pos <SPC> -= <SPC> 1 <NL>          else : <NL>              res . append ( s [ index ] ) <NL> <TAB> return <SPC> "" . join ( res ) <NL> <NL> <NL> class <SPC> MovingAverage ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> size ) : <NL> <NL> <TAB> self . size <SPC> = <SPC> size <NL> <TAB> self . curr_range <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> next ( self , <SPC> val ) : <NL> <NL> <TAB> if <SPC> len ( self . curr_range ) <SPC> == <SPC> self . size : <NL>          self . curr_range . pop ( 0 ) <NL> <TAB> self . curr_range . append ( val ) <NL> <TAB> return <SPC> sum ( self . curr_range ) <SPC> * <SPC> 1.0 <SPC> / <SPC> len ( self . curr_range ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> topKFrequent ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> counter <SPC> = <SPC> collections . Counter ( nums ) <NL> <TAB> return <SPC> [ k <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> counter . most_common ( k ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> intersection ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> return <SPC> list ( set ( nums1 ) <SPC> & <SPC> set ( nums2 ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> intersect ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> nums1 . sort ( ) <NL> <TAB> nums2 . sort ( ) <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> pos1 <SPC> = <SPC> pos2 <SPC> = <SPC> 0 <NL> <TAB> while <SPC> pos1 <SPC> < <SPC> len ( nums1 ) <SPC> and <SPC> pos2 <SPC> < <SPC> len ( nums2 ) : <NL>          if <SPC> nums1 [ pos1 ] <SPC> == <SPC> nums2 [ pos2 ] : <NL>              res . append ( nums1 [ pos1 ] ) <NL>              pos1 <SPC> += <SPC> 1 <NL>              pos2 <SPC> += <SPC> 1 <NL>          elif <SPC> nums1 [ pos1 ] <SPC> < <SPC> nums2 [ pos2 ] : <NL>              pos1 <SPC> += <SPC> 1 <NL>          else : <NL>              pos2 <SPC> += <SPC> 1 <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfPatterns ( self , <SPC> m , <SPC> n ) : <NL> <NL> <TAB> used <SPC> = <SPC> [ False ] <SPC> * <SPC> 9 <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> for <SPC> l <SPC> in <SPC> range ( m , <SPC> n <SPC> + <SPC> 1 ) : <NL>          res <SPC> += <SPC> self . calc_patterns ( used , <SPC> - 1 , <SPC> l ) <NL>          used <SPC> = <SPC> [ False ] <SPC> * <SPC> 9 <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> is_valid ( self , <SPC> used , <SPC> index , <SPC> last ) : <NL> <NL> <TAB> if <SPC> used [ index ] : <NL>          return <SPC> False <NL> <NL> <TAB> if <SPC> last <SPC> == <SPC> - 1 : <NL>          return <SPC> True <NL> <NL> <TAB> if <SPC> ( last <SPC> + <SPC> index ) <SPC> % <SPC> 2 <SPC> == <SPC> 1 : <NL>          return <SPC> True <NL> <TAB> mid <SPC> = <SPC> ( last <SPC> + <SPC> index ) <SPC> / <SPC> 2 <NL> <TAB> if <SPC> mid <SPC> == <SPC> 4 : <NL>          return <SPC> used [ mid ] <NL> <NL> <TAB> if <SPC> ( index <SPC> % <SPC> 3 <SPC> != <SPC> last <SPC> % <SPC> 3 ) <SPC> and <SPC> ( index <SPC> / <SPC> 3 <SPC> != <SPC> last <SPC> / <SPC> 3 ) : <NL>          return <SPC> True <NL> <NL> <TAB> return <SPC> used [ mid ] <NL> <NL> <TAB> def <SPC> calc_patterns ( self , <SPC> used , <SPC> last , <SPC> length ) : <NL> <TAB> if <SPC> length <SPC> == <SPC> 0 : <NL>          return <SPC> 1 <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 9 ) : <NL>          if <SPC> self . is_valid ( used , <SPC> i , <SPC> last ) : <NL>              used [ i ] <SPC> = <SPC> True <NL>              res <SPC> += <SPC> self . calc_patterns ( used , <SPC> i , <SPC> length <SPC> - <SPC> 1 ) <NL>              used [ i ] <SPC> = <SPC> False <NL> <TAB> return <SPC> res <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Logger ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . heap <SPC> = <SPC> [ ] <NL> <TAB> self . cache <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> shouldPrintMessage ( self , <SPC> timestamp , <SPC> message ) : <NL> <NL> <TAB> while <SPC> len ( self . heap ) : <NL>          if <SPC> self . heap [ 0 ] [ 0 ] <SPC> <= <SPC> timestamp : <NL>              temp <SPC> = <SPC> heapq . heappop ( self . heap ) <NL>              self . cache . pop ( temp [ 1 ] ) <NL>          else : <NL>              break <NL> <TAB> if <SPC> timestamp <SPC> < <SPC> self . cache . get ( message , <SPC> 0 ) : <NL>          return <SPC> False <NL> <TAB> self . cache [ message ] <SPC> = <SPC> timestamp <SPC> + <SPC> 10 <NL> <TAB> heapq . heappush ( self . heap , <SPC> ( timestamp <SPC> + <SPC> 10 , <SPC> message ) ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> findLeaves ( self , <SPC> root ) : <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> self . findLeaves_helper ( root , <SPC> res ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> findLeaves_helper ( self , <SPC> node , <SPC> res ) : <NL> <TAB> if <SPC> node <SPC> is <SPC> None : <NL>          return <SPC> - 1 <NL> <TAB> level <SPC> = <SPC> 1 <SPC> + <SPC> max ( <NL>          self . findLeaves_helper ( node . left , <SPC> res ) , <NL>          self . findLeaves_helper ( node . right , <SPC> res ) , <NL> <TAB> ) <NL> <TAB> if <SPC> len ( res ) <SPC> < <SPC> level <SPC> + <SPC> 1 : <NL>          res . append ( [ ] ) <NL> <TAB> res [ level ] . append ( node . val ) <NL> <TAB> return <SPC> level <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isPerfectSquare ( self , <SPC> num ) : <NL> <TAB> low , <SPC> high <SPC> = <SPC> 1 , <SPC> num <NL> <TAB> while <SPC> low <SPC> <= <SPC> high : <NL>          mid <SPC> = <SPC> ( low <SPC> + <SPC> high ) <SPC> / <SPC> 2 <NL>          mid_square <SPC> = <SPC> mid <SPC> * <SPC> mid <NL>          if <SPC> mid_square <SPC> == <SPC> num : <NL>              return <SPC> True <NL>          elif <SPC> mid_square <SPC> < <SPC> num : <NL>              low <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          else : <NL>              high <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> largestDivisibleSubset ( self , <SPC> nums ) : <NL> <TAB> ls <SPC> = <SPC> len ( nums ) <NL> <TAB> S <SPC> = <SPC> { - 1 : <SPC> set ( ) } <NL> <TAB> for <SPC> num <SPC> in <SPC> sorted ( nums ) : <NL>          candicate <SPC> = <SPC> [ ] <NL>          for <SPC> key <SPC> in <SPC> S : <NL>              if <SPC> num <SPC> % <SPC> key <SPC> == <SPC> 0 : <NL>                  candicate . append ( S [ key ] ) <NL> <NL>          S [ num ] <SPC> = <SPC> max ( candicate , <SPC> key = len ) <SPC> | <SPC> { num } <NL> <TAB> return <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> plusOne ( self , <SPC> head ) : <NL> <NL> <TAB> dummy <SPC> = <SPC> ListNode ( 0 ) <NL> <TAB> dummy . next <SPC> = <SPC> head <NL> <TAB> place_stop , <SPC> tail <SPC> = <SPC> dummy , <SPC> dummy <NL> <NL> <TAB> while <SPC> tail . next <SPC> is <SPC> not <SPC> None : <NL>          tail <SPC> = <SPC> tail . next <NL>          if <SPC> tail . val <SPC> != <SPC> 9 : <NL>              place_stop <SPC> = <SPC> tail <NL> <TAB> if <SPC> tail . val <SPC> != <SPC> 9 : <NL> <NL>          tail . val <SPC> += <SPC> 1 <NL> <TAB> else : <NL> <NL>          place_stop . val <SPC> += <SPC> 1 <NL>          place_stop <SPC> = <SPC> place_stop . next <NL> <NL>          while <SPC> place_stop <SPC> is <SPC> not <SPC> None : <NL>              place_stop . val <SPC> = <SPC> 0 <NL>              place_stop <SPC> = <SPC> place_stop . next <NL> <TAB> if <SPC> dummy . val <SPC> == <SPC> 0 : <NL>          return <SPC> dummy . next <NL> <TAB> return <SPC> dummy <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getModifiedArray ( self , <SPC> length , <SPC> updates ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ 0 ] <SPC> * <SPC> length <NL> <NL> <TAB> for <SPC> t <SPC> in <SPC> updates : <NL>          start , <SPC> end , <SPC> val <SPC> = <SPC> t <NL>          res [ start ] <SPC> += <SPC> val <NL>          if <SPC> end <SPC> < <SPC> length <SPC> - <SPC> 1 : <NL>              res [ end <SPC> + <SPC> 1 ] <SPC> -= <SPC> val <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> length ) : <NL>          res [ i ] <SPC> = <SPC> res [ i ] <SPC> + <SPC> res [ i <SPC> - <SPC> 1 ] <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getSum ( self , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> import <SPC> ctypes <NL> <NL> <TAB> sum <SPC> = <SPC> 0 <NL> <TAB> carry <SPC> = <SPC> ctypes . c_int32 ( b ) <NL> <TAB> while <SPC> carry . value <SPC> != <SPC> 0 : <NL>          sum <SPC> = <SPC> a <SPC> ^ <SPC> carry . value <NL>          carry <SPC> = <SPC> ctypes . c_int32 ( a <SPC> & <SPC> carry . value ) <NL>          carry . value <SPC> <<= <SPC> 1 <NL>          a <SPC> = <SPC> sum <NL> <TAB> return <SPC> sum <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . base <SPC> = <SPC> 1337 <NL> <NL> <TAB> def <SPC> superPow ( self , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> if <SPC> b <SPC> is <SPC> None <SPC> or <SPC> len ( b ) <SPC> == <SPC> 0 : <NL>          return <SPC> 1 <NL> <TAB> last_digit <SPC> = <SPC> b . pop ( ) <NL> <TAB> return <SPC> ( <NL>          self . powmod ( self . superPow ( a , <SPC> b ) , <SPC> 10 ) <NL>          * <SPC> self . powmod ( a , <SPC> last_digit ) <NL>          % <SPC> self . base <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> powmod ( self , <SPC> a , <SPC> k ) : <NL> <TAB> a <SPC> %= <SPC> self . base <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( k ) : <NL>          result <SPC> = <SPC> ( result <SPC> * <SPC> a ) <SPC> % <SPC> self . base <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kSmallestPairs ( self , <SPC> nums1 , <SPC> nums2 , <SPC> k ) : <NL> <NL> <TAB> queue <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( i , <SPC> j ) : <NL>          if <SPC> i <SPC> < <SPC> len ( nums1 ) <SPC> and <SPC> j <SPC> < <SPC> len ( nums2 ) : <NL>              heapq . heappush ( queue , <SPC> [ nums1 [ i ] <SPC> + <SPC> nums2 [ j ] , <SPC> i , <SPC> j ] ) <NL> <NL> <TAB> push ( 0 , <SPC> 0 ) <NL> <TAB> pairs <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> queue <SPC> and <SPC> len ( pairs ) <SPC> < <SPC> k : <NL>          _ , <SPC> i , <SPC> j <SPC> = <SPC> heapq . heappop ( queue ) <NL>          pairs . append ( [ nums1 [ i ] , <SPC> nums2 [ j ] ] ) <NL>          push ( i , <SPC> j <SPC> + <SPC> 1 ) <NL>          if <SPC> j <SPC> == <SPC> 0 : <NL>              push ( i <SPC> + <SPC> 1 , <SPC> 0 ) <NL> <TAB> return <SPC> pairs <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> guessNumber ( self , <SPC> n ) : <NL> <NL> <TAB> begin , <SPC> end <SPC> = <SPC> 1 , <SPC> n <NL> <TAB> while <SPC> begin <SPC> <= <SPC> end : <NL>          mid <SPC> = <SPC> ( begin <SPC> + <SPC> end ) <SPC> / <SPC> 2 <NL>          res <SPC> = <SPC> guess ( mid ) <NL>          if <SPC> res <SPC> == <SPC> 0 : <NL>              return <SPC> mid <NL>          elif <SPC> res <SPC> > <SPC> 0 : <NL>              begin <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          else : <NL>              end <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> getMoneyAmount ( self , <SPC> n ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> range ( n <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> j <SPC> in <SPC> range ( 2 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> range ( j <SPC> - <SPC> 1 , <SPC> 0 , <SPC> - 1 ) : <NL>              globalMin <SPC> = <SPC> sys . maxint <NL>              for <SPC> k <SPC> in <SPC> range ( i <SPC> + <SPC> 1 , <SPC> j ) : <NL>                  localMax <SPC> = <SPC> k <SPC> + <SPC> max ( dp [ i ] [ k <SPC> - <SPC> 1 ] , <SPC> dp [ k <SPC> + <SPC> 1 ] [ j ] ) <NL>                  globalMin <SPC> = <SPC> min ( globalMin , <SPC> localMax ) <NL>              if <SPC> i <SPC> + <SPC> 1 <SPC> == <SPC> j : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> i <NL>              else : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> globalMin <NL> <TAB> return <SPC> dp [ 1 ] [ n ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canConstruct ( self , <SPC> ransomNote , <SPC> magazine ) : <NL> <NL> <TAB> letter_map <SPC> = <SPC> { } <NL> <TAB> for <SPC> letter <SPC> in <SPC> magazine : <NL>          letter_map [ letter ] <SPC> = <SPC> letter_map . get ( letter , <SPC> 0 ) <SPC> + <SPC> 1 <NL> <TAB> for <SPC> letter <SPC> in <SPC> ransomNote : <NL>          letter_map [ letter ] <SPC> = <SPC> letter_map . get ( letter , <SPC> 0 ) <SPC> - <SPC> 1 <NL>          if <SPC> letter_map [ letter ] <SPC> < <SPC> 0 : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> nums ) : <NL> <NL> <TAB> self . origin <SPC> = <SPC> list ( nums ) <NL> <TAB> self . curr <SPC> = <SPC> list ( nums ) <NL> <TAB> self . size <SPC> = <SPC> len ( nums ) <NL> <NL> <TAB> def <SPC> reset ( self ) : <NL> <NL> <TAB> self . curr <SPC> = <SPC> list ( self . origin ) <NL> <TAB> return <SPC> self . curr <NL> <NL> <TAB> def <SPC> shuffle ( self ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( self . size ) : <NL>          pos <SPC> = <SPC> random . randint ( 0 , <SPC> i ) <NL> <NL>          self . curr [ i ] , <SPC> self . curr [ pos ] <SPC> = <SPC> self . curr [ pos ] , <SPC> self . curr [ i ] <NL> <TAB> return <SPC> self . curr <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> firstUniqChar ( self , <SPC> s ) : <NL> <NL> <TAB> count_map <SPC> = <SPC> { } <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          count_map [ c ] <SPC> = <SPC> count_map . get ( c , <SPC> 0 ) <SPC> + <SPC> 1 <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          if <SPC> count_map [ c ] <SPC> == <SPC> 1 : <NL>              return <SPC> i <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lengthLongestPath ( self , <SPC> input ) : <NL> <NL> <TAB> if <SPC> input <SPC> is <SPC> None <SPC> or <SPC> len ( input ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> lines <SPC> = <SPC> input . split ( "\n" ) <NL> <TAB> last_level_len <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( lines ) <SPC> + <SPC> 1 ) <NL> <TAB> max_len <SPC> = <SPC> 0 <NL> <TAB> for <SPC> line <SPC> in <SPC> lines : <NL>          try : <NL>              level <SPC> = <SPC> line . rindex ( "\t" ) <SPC> + <SPC> 1 <NL>          except : <NL>              level <SPC> = <SPC> 0 <NL>          cur_len <SPC> = <SPC> last_level_len [ level <SPC> + <SPC> 1 ] <SPC> = <SPC> ( <NL>              last_level_len [ level ] <SPC> + <SPC> len ( line ) <SPC> - <SPC> level <SPC> + <SPC> 1 <NL>          ) <NL>          if <SPC> "." <SPC> in <SPC> line : <NL>              max_len <SPC> = <SPC> max ( max_len , <SPC> cur_len <SPC> - <SPC> 1 ) <NL> <TAB> return <SPC> max_len <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . lengthLongestPath ( "dir\n    file.txt" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findTheDifference ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> res <SPC> = <SPC> ord ( t [ - 1 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( s ) ) : <NL>          res <SPC> += <SPC> ord ( t [ i ] ) <NL>          res <SPC> -= <SPC> ord ( s [ i ] ) <NL> <TAB> return <SPC> chr ( res ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> readBinaryWatch ( self , <SPC> num ) : <NL> <NL> <TAB> return <SPC> [ <NL>          "%d:%02d" <SPC> % <SPC> ( h , <SPC> m ) <NL>          for <SPC> h <SPC> in <SPC> range ( 12 ) <NL>          for <SPC> m <SPC> in <SPC> range ( 60 ) <NL>          if <SPC> ( bin ( h ) <SPC> + <SPC> bin ( m ) ) . count ( "1" ) <SPC> == <SPC> num <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> sumOfLeftLeaves ( self , <SPC> root ) : <NL> <TAB> stack <SPC> = <SPC> [ root ] <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> while <SPC> len ( stack ) <SPC> > <SPC> 0 : <NL>          curr <SPC> = <SPC> stack . pop ( 0 ) <NL>          if <SPC> curr <SPC> is <SPC> not <SPC> None : <NL>              if <SPC> curr . left <SPC> is <SPC> not <SPC> None : <NL>                  if <SPC> curr . left . left <SPC> is <SPC> None <SPC> and <SPC> curr . left . right <SPC> is <SPC> None : <NL>                      res <SPC> += <SPC> curr . left . val <NL>              stack . insert ( 0 , <SPC> curr . right ) <NL>              stack . insert ( 0 , <SPC> curr . left ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> toHex ( self , <SPC> num ) : <NL> <NL> <TAB> if <SPC> num <SPC> == <SPC> 0 : <NL>          return <SPC> "0" <NL> <NL> <TAB> mp <SPC> = <SPC> "0123456789abcdef" <NL> <TAB> ans <SPC> = <SPC> "" <NL> <TAB> for <SPC> _ <SPC> in <SPC> range ( 8 ) : <NL> <NL>          n <SPC> = <SPC> num <SPC> & <SPC> 15 <NL> <NL>          c <SPC> = <SPC> mp [ n ] <NL>          ans <SPC> = <SPC> c <SPC> + <SPC> ans <NL> <NL>          num <SPC> = <SPC> num <SPC> >> <SPC> 4 <NL> <NL> <TAB> return <SPC> ans . lstrip ( "0" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> validWordAbbreviation ( self , <SPC> word , <SPC> abbr ) : <NL> <TAB> pos <SPC> = <SPC> curr <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( abbr ) ) : <NL>          try : <NL>              num <SPC> = <SPC> int ( abbr [ i ] ) <NL>              if <SPC> num <SPC> == <SPC> 0 <SPC> and <SPC> curr <SPC> == <SPC> 0 : <NL>                  return <SPC> False <NL>              curr <SPC> = <SPC> curr <SPC> * <SPC> 10 <SPC> + <SPC> num <NL>          except <SPC> ValueError : <NL>              pos <SPC> += <SPC> curr <NL>              curr <SPC> = <SPC> 0 <NL>              if <SPC> pos <SPC> >= <SPC> len ( word ) : <NL>                  return <SPC> False <NL>              if <SPC> word [ pos ] <SPC> != <SPC> abbr [ i ] : <NL>                  return <SPC> False <NL>              pos <SPC> += <SPC> 1 <NL> <TAB> pos <SPC> += <SPC> curr <NL> <TAB> if <SPC> pos <SPC> == <SPC> len ( word ) : <NL>          return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution : <NL> <NL> <TAB> def <SPC> longestPalindrome ( self , <SPC> s ) : <NL> <TAB> ans <SPC> = <SPC> 0 <NL> <TAB> char_map <SPC> = <SPC> { } <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          char_map [ c ] <SPC> = <SPC> char_map . get ( c , <SPC> 0 ) <SPC> + <SPC> 1 <NL> <TAB> for <SPC> c <SPC> in <SPC> char_map . keys ( ) : <NL>          if <SPC> char_map [ c ] <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              ans <SPC> += <SPC> char_map . pop ( c ) <NL>          else : <NL>              ans <SPC> += <SPC> char_map [ c ] <SPC> / <SPC> 2 <SPC> * <SPC> 2 <NL> <TAB> if <SPC> len ( char_map ) <SPC> != <SPC> 0 : <NL>          ans <SPC> += <SPC> 1 <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> fizzBuzz ( self , <SPC> n ) : <NL> <TAB> return <SPC> [ <NL>          str ( i ) <SPC> * <SPC> ( i <SPC> % <SPC> 3 <SPC> != <SPC> 0 <SPC> and <SPC> i <SPC> % <SPC> 5 <SPC> != <SPC> 0 ) <NL>          + <SPC> "Fizz" <SPC> * <SPC> ( i <SPC> % <SPC> 3 <SPC> == <SPC> 0 ) <NL>          + <SPC> "Buzz" <SPC> * <SPC> ( i <SPC> % <SPC> 5 <SPC> == <SPC> 0 ) <NL>          for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> n <SPC> + <SPC> 1 ) <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> thirdMax ( self , <SPC> nums ) : <NL> <NL> <TAB> import <SPC> Queue <NL> <NL> <TAB> pq <SPC> = <SPC> Queue . PriorityQueue ( 4 ) <NL> <TAB> check <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> n <SPC> in <SPC> nums : <NL>          if <SPC> n <SPC> in <SPC> check : <NL>              continue <NL>          pq . put ( n ) <NL>          check . add ( n ) <NL>          if <SPC> len ( check ) <SPC> > <SPC> 3 : <NL>              check . remove ( pq . get ( ) ) <NL> <TAB> total <SPC> = <SPC> len ( check ) <NL> <TAB> while <SPC> total <SPC> < <SPC> 3 <SPC> and <SPC> total <SPC> > <SPC> 1 : <NL>          total <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> pq . get ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> addStrings ( self , <SPC> num1 , <SPC> num2 ) : <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> pos1 <SPC> = <SPC> len ( num1 ) <SPC> - <SPC> 1 <NL> <TAB> pos2 <SPC> = <SPC> len ( num2 ) <SPC> - <SPC> 1 <NL> <TAB> carry <SPC> = <SPC> 0 <NL> <NL> <TAB> while <SPC> pos1 <SPC> >= <SPC> 0 <SPC> or <SPC> pos2 <SPC> >= <SPC> 0 <SPC> or <SPC> carry <SPC> == <SPC> 1 : <NL>          digit1 <SPC> = <SPC> digit2 <SPC> = <SPC> 0 <NL>          if <SPC> pos1 <SPC> >= <SPC> 0 : <NL>              digit1 <SPC> = <SPC> ord ( num1 [ pos1 ] ) <SPC> - <SPC> ord ( "0" ) <NL>          if <SPC> pos2 <SPC> >= <SPC> 0 : <NL>              digit2 <SPC> = <SPC> ord ( num2 [ pos2 ] ) <SPC> - <SPC> ord ( "0" ) <NL>          res . append ( str ( ( digit1 <SPC> + <SPC> digit2 <SPC> + <SPC> carry ) <SPC> % <SPC> 10 ) ) <NL>          carry <SPC> = <SPC> ( digit1 <SPC> + <SPC> digit2 <SPC> + <SPC> carry ) <SPC> / <SPC> 10 <NL>          pos1 <SPC> -= <SPC> 1 <NL>          pos2 <SPC> -= <SPC> 1 <NL> <NL> <TAB> return <SPC> "" . join ( res [ : : - 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> canPartition ( self , <SPC> nums ) : <NL> <TAB> total_sum <SPC> = <SPC> sum ( nums ) <NL> <TAB> if <SPC> total_sum <SPC> & <SPC> 1 : <NL>          return <SPC> False <NL> <NL> <TAB> target <SPC> = <SPC> total_sum <SPC> >> <SPC> 1 <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( target <SPC> + <SPC> 1 ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          for <SPC> i <SPC> in <SPC> range ( target , <SPC> num <SPC> - <SPC> 1 , <SPC> - 1 ) : <NL>              dp [ i ] <SPC> = <SPC> dp [ i ] <SPC> | <SPC> dp [ i <SPC> - <SPC> num ] <NL> <TAB> return <SPC> dp [ target ] <SPC> == <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMaximumXOR ( self , <SPC> nums ) : <NL> <NL> <TAB> answer <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 32 ) [ : : - 1 ] : <NL>          answer <SPC> <<= <SPC> 1 <NL> <NL>          prefixes <SPC> = <SPC> { num <SPC> >> <SPC> i <SPC> for <SPC> num <SPC> in <SPC> nums } <NL> <NL>          answer <SPC> += <SPC> any ( answer <SPC> ^ <SPC> 1 <SPC> ^ <SPC> p <SPC> in <SPC> prefixes <SPC> for <SPC> p <SPC> in <SPC> prefixes ) <NL> <TAB> return <SPC> answer <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> s . findMaximumXOR ( [ 3 , <SPC> 10 , <SPC> 5 , <SPC> 25 , <SPC> 2 , <SPC> 8 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validWordSquare ( self , <SPC> words ) : <NL> <NL> <TAB> if <SPC> words <SPC> is <SPC> None <SPC> or <SPC> len ( words ) <SPC> == <SPC> 0 : <NL>          return <SPC> True <NL> <TAB> ls <SPC> = <SPC> len ( words ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( ls ) : <NL>          for <SPC> j <SPC> in <SPC> range ( 1 , <SPC> len ( words [ i ] ) ) : <NL>              if <SPC> j <SPC> >= <SPC> ls : <NL>                  return <SPC> False <NL>              if <SPC> i <SPC> >= <SPC> len ( words [ j ] ) : <NL>                  return <SPC> False <NL>              if <SPC> words [ i ] [ j ] <SPC> != <SPC> words [ j ] [ i ] : <NL>                  return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> pathSumHelper ( self , <SPC> root , <SPC> target , <SPC> so_far , <SPC> cache ) : <NL> <TAB> if <SPC> root : <NL> <NL>          complement <SPC> = <SPC> so_far <SPC> + <SPC> root . val <SPC> - <SPC> target <NL>          if <SPC> complement <SPC> in <SPC> cache : <NL> <NL>              self . result <SPC> += <SPC> cache [ complement ] <NL>          cache [ so_far <SPC> + <SPC> root . val ] <SPC> = <SPC> cache . get ( so_far <SPC> + <SPC> root . val , <SPC> 0 ) <SPC> + <SPC> 1 <NL>          self . pathSumHelper ( root . left , <SPC> target , <SPC> so_far <SPC> + <SPC> root . val , <SPC> cache ) <NL>          self . pathSumHelper ( root . right , <SPC> target , <SPC> so_far <SPC> + <SPC> root . val , <SPC> cache ) <NL>          cache [ so_far <SPC> + <SPC> root . val ] <SPC> -= <SPC> 1 <NL> <TAB> return <NL> <NL> <TAB> def <SPC> pathSum ( self , <SPC> root , <SPC> sum ) : <NL> <NL> <TAB> self . result <SPC> = <SPC> 0 <NL> <TAB> self . pathSumHelper ( root , <SPC> sum , <SPC> 0 , <SPC> { 0 : <SPC> 1 } ) <NL> <TAB> return <SPC> self . result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findAnagrams ( self , <SPC> s , <SPC> p ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> s <SPC> is <SPC> None <SPC> or <SPC> p <SPC> is <SPC> None <SPC> or <SPC> len ( s ) <SPC> == <SPC> 0 <SPC> or <SPC> len ( p ) <SPC> == <SPC> 0 : <NL>          return <SPC> res <NL> <TAB> char_map <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 256 <NL> <TAB> for <SPC> c <SPC> in <SPC> p : <NL>          char_map [ ord ( c ) ] <SPC> += <SPC> 1 <NL> <TAB> left , <SPC> right , <SPC> count <SPC> = <SPC> 0 , <SPC> 0 , <SPC> len ( p ) <NL> <TAB> while <SPC> right <SPC> < <SPC> len ( s ) : <NL>          if <SPC> char_map [ ord ( s [ right ] ) ] <SPC> >= <SPC> 1 : <NL>              count <SPC> -= <SPC> 1 <NL>          char_map [ ord ( s [ right ] ) ] <SPC> -= <SPC> 1 <NL>          right <SPC> += <SPC> 1 <NL>          if <SPC> count <SPC> == <SPC> 0 : <NL>              res . append ( left ) <NL>          if <SPC> right <SPC> - <SPC> left <SPC> == <SPC> len ( p ) : <NL>              if <SPC> char_map [ ord ( s [ left ] ) ] <SPC> >= <SPC> 0 : <NL>                  count <SPC> += <SPC> 1 <NL>              char_map [ ord ( s [ left ] ) ] <SPC> += <SPC> 1 <NL>              left <SPC> += <SPC> 1 <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> compress ( self , <SPC> chars ) : <NL> <NL> <TAB> anchor <SPC> = <SPC> write <SPC> = <SPC> 0 <NL> <TAB> for <SPC> read , <SPC> c <SPC> in <SPC> enumerate ( chars ) : <NL>          if <SPC> read <SPC> + <SPC> 1 <SPC> == <SPC> len ( chars ) <SPC> or <SPC> chars [ read <SPC> + <SPC> 1 ] <SPC> != <SPC> c : <NL>              chars [ write ] <SPC> = <SPC> chars [ anchor ] <NL>              write <SPC> += <SPC> 1 <NL>              if <SPC> read <SPC> > <SPC> anchor : <NL>                  for <SPC> digit <SPC> in <SPC> str ( read <SPC> - <SPC> anchor <SPC> + <SPC> 1 ) : <NL>                      chars [ write ] <SPC> = <SPC> digit <NL>                      write <SPC> += <SPC> 1 <NL>              anchor <SPC> = <SPC> read <SPC> + <SPC> 1 <NL> <TAB> return <SPC> write <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findDisappearedNumbers ( self , <SPC> nums ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> nums : <NL>          n <SPC> = <SPC> len ( nums ) <NL>          for <SPC> i <SPC> in <SPC> range ( n ) : <NL>              val <SPC> = <SPC> abs ( nums [ i ] ) <SPC> - <SPC> 1 <NL>              if <SPC> nums [ val ] <SPC> > <SPC> 0 : <NL>                  nums [ val ] <SPC> = <SPC> - nums [ val ] <NL>          for <SPC> i <SPC> in <SPC> range ( n ) : <NL>              if <SPC> nums [ i ] <SPC> > <SPC> 0 : <NL>                  res . append ( i <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minMoves ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> nums <SPC> is <SPC> None <SPC> or <SPC> len ( nums ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> min_num <SPC> = <SPC> min ( nums ) <NL> <TAB> return <SPC> sum ( [ i <SPC> - <SPC> min_num <SPC> for <SPC> i <SPC> in <SPC> nums ] ) <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> circularArrayLoop ( self , <SPC> nums : <SPC> List [ int ] ) <SPC> -> <SPC> bool : <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( nums ) ) : <NL>          if <SPC> nums [ i ] <SPC> == <SPC> 0 : <NL>              continue <NL> <NL>          slow <SPC> = <SPC> i <NL>          fast <SPC> = <SPC> self . index ( nums , <SPC> slow ) <NL>          while <SPC> ( <NL>              nums [ slow ] <SPC> * <SPC> nums [ fast ] <SPC> > <SPC> 0 <NL>              and <SPC> nums [ slow ] <SPC> * <SPC> nums [ self . index ( nums , <SPC> fast ) ] <SPC> > <SPC> 0 <NL>          ) : <NL>              if <SPC> slow <SPC> == <SPC> fast <SPC> and <SPC> fast <SPC> != <SPC> self . index ( nums , <SPC> fast ) : <NL>                  return <SPC> True <NL>              elif <SPC> slow <SPC> == <SPC> fast <SPC> and <SPC> fast <SPC> == <SPC> self . index ( nums , <SPC> fast ) : <NL>                  break <NL>              slow <SPC> = <SPC> self . index ( nums , <SPC> slow ) <NL>              fast <SPC> = <SPC> self . index ( nums , <SPC> self . index ( nums , <SPC> fast ) ) <NL> <NL>          runner <SPC> = <SPC> i <NL>          value <SPC> = <SPC> nums [ runner ] <NL>          while <SPC> nums [ runner ] <SPC> * <SPC> value <SPC> > <SPC> 0 : <NL>              temp <SPC> = <SPC> self . index ( nums , <SPC> runner ) <NL>              nums [ runner ] <SPC> = <SPC> 0 <NL>              runner <SPC> = <SPC> temp <NL> <TAB> return <SPC> False <NL> <NL> <TAB> def <SPC> index ( self , <SPC> nums , <SPC> index ) : <NL> <TAB> length <SPC> = <SPC> len ( nums ) <NL> <TAB> return <SPC> ( index <SPC> + <SPC> nums [ index ] <SPC> + <SPC> length ) <SPC> % <SPC> length <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> poorPigs ( self , <SPC> buckets , <SPC> minutesToDie , <SPC> minutesToTest ) : <NL> <NL> <TAB> pigs <SPC> = <SPC> 0 <NL> <TAB> while <SPC> ( minutesToTest <SPC> / <SPC> minutesToDie <SPC> + <SPC> 1 ) <SPC> ** <SPC> pigs <SPC> < <SPC> buckets : <NL>          pigs <SPC> += <SPC> 1 <NL> <TAB> return <SPC> pigs <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> hammingDistance ( self , <SPC> x , <SPC> y ) : <NL> <NL> <TAB> return <SPC> bin ( x <SPC> ^ <SPC> y ) . count ( "1" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> islandPerimeter ( self , <SPC> grid ) : <NL> <NL> <TAB> row_num <SPC> = <SPC> len ( grid ) <NL> <TAB> if <SPC> row_num <SPC> == <SPC> 0 <SPC> | <SPC> | <SPC> len ( grid [ 0 ] ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> islands , <SPC> overlaps <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> col_num <SPC> = <SPC> len ( grid [ 0 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( row_num ) : <NL>          for <SPC> j <SPC> in <SPC> range ( col_num ) : <NL>              if <SPC> ( grid [ i ] [ j ] <SPC> == <SPC> 1 ) : <NL>                  islands <SPC> += <SPC> 1 <NL> <NL>                  if <SPC> ( i <SPC> < <SPC> row_num <SPC> - <SPC> 1 <SPC> & <SPC> & <SPC> grid [ i <SPC> + <SPC> 1 ] [ j ] <SPC> == <SPC> 1 ) : <NL>                      overlaps <SPC> += <SPC> 1 <NL>                  if <SPC> ( j <SPC> < <SPC> col_num <SPC> - <SPC> 1 <SPC> & <SPC> & <SPC> grid [ i ] [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> 1 ) : <NL>                      overlaps <SPC> += <SPC> 1 <NL> <TAB> return <SPC> islands <SPC> * <SPC> 4 <SPC> - <SPC> overlaps <SPC> * <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findRadius ( self , <SPC> houses , <SPC> heaters ) : <NL> <NL> <TAB> heaters <SPC> = <SPC> sorted ( heaters ) <SPC> + <SPC> [ float ( "inf" ) ] <NL> <TAB> i <SPC> = <SPC> r <SPC> = <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> sorted ( houses ) : <NL> <NL>          while <SPC> x <SPC> >= <SPC> sum ( heaters [ i : <SPC> i <SPC> + <SPC> 2 ] ) <SPC> / <SPC> 2.0 : <NL>              i <SPC> += <SPC> 1 <NL> <NL>          r <SPC> = <SPC> max ( r , <SPC> abs ( heaters [ i ] <SPC> - <SPC> x ) ) <NL> <TAB> return <SPC> r <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> largestPalindrome ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 1 : <NL>          return <SPC> 9 <NL> <TAB> for <SPC> a <SPC> in <SPC> xrange ( 2 , <SPC> 9 <SPC> * <SPC> 10 <SPC> ** <SPC> ( n <SPC> - <SPC> 1 ) ) : <NL>          hi <SPC> = <SPC> ( 10 <SPC> ** <SPC> n ) <SPC> - <SPC> a <NL>          lo <SPC> = <SPC> int ( str ( hi ) [ : : - 1 ] ) <NL>          if <SPC> a <SPC> ** <SPC> 2 <SPC> - <SPC> 4 <SPC> * <SPC> lo <SPC> < <SPC> 0 : <NL>              continue <NL>          if <SPC> ( a <SPC> ** <SPC> 2 <SPC> - <SPC> 4 <SPC> * <SPC> lo ) <SPC> ** <SPC> 0.5 <SPC> == <SPC> int ( ( a <SPC> ** <SPC> 2 <SPC> - <SPC> 4 <SPC> * <SPC> lo ) <SPC> ** <SPC> 0.5 ) : <NL>              return <SPC> ( lo <SPC> + <SPC> 10 <SPC> ** <SPC> n <SPC> * <SPC> ( 10 <SPC> ** <SPC> n <SPC> - <SPC> a ) ) <SPC> % <SPC> 1337 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> licenseKeyFormatting ( self , <SPC> S , <SPC> K ) : <NL> <NL> <TAB> S <SPC> = <SPC> S . upper ( ) . replace ( "-" , <SPC> "" ) <NL> <TAB> ls <SPC> = <SPC> len ( S ) <NL> <TAB> if <SPC> ls <SPC> % <SPC> K <SPC> == <SPC> 0 : <NL>          pos <SPC> = <SPC> K <NL> <TAB> else : <NL>          pos <SPC> = <SPC> ls <SPC> % <SPC> K <NL> <TAB> res <SPC> = <SPC> S [ : pos ] <NL> <TAB> while <SPC> pos <SPC> < <SPC> ls : <NL>          res <SPC> += <SPC> "-" <SPC> + <SPC> S [ pos : <SPC> pos <SPC> + <SPC> K ] <NL>          pos <SPC> += <SPC> K <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMaxConsecutiveOnes ( self , <SPC> nums ) : <NL> <NL> <TAB> ans <SPC> = <SPC> 0 <NL> <TAB> curr <SPC> = <SPC> 0 <NL> <TAB> for <SPC> n <SPC> in <SPC> nums : <NL>          if <SPC> n <SPC> == <SPC> 1 : <NL> <NL>              curr <SPC> += <SPC> 1 <NL>              if <SPC> curr <SPC> > <SPC> ans : <NL>                  ans <SPC> = <SPC> curr <NL>          else : <NL> <NL>              curr <SPC> = <SPC> 0 <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . memo <SPC> = <SPC> [ ] <NL> <TAB> self . memo . append ( 0 ) <NL> <TAB> self . memo . append ( 1 ) <NL> <NL> <TAB> def <SPC> fib ( self , <SPC> N ) : <NL> <NL> <TAB> if <SPC> N <SPC> < <SPC> len ( self . memo ) : <NL>          return <SPC> self . memo [ N ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( self . memo ) , <SPC> N <SPC> + <SPC> 1 ) : <NL>          self . memo . append ( self . memo [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> self . memo [ i <SPC> - <SPC> 2 ] ) <NL> <TAB> return <SPC> self . memo [ N ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> convertBST ( self , <SPC> root ) : <NL> <TAB> total <SPC> = <SPC> 0 <NL> <NL> <TAB> node <SPC> = <SPC> root <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> stack <SPC> or <SPC> node <SPC> is <SPC> not <SPC> None : <NL> <NL>          while <SPC> node <SPC> is <SPC> not <SPC> None : <NL>              stack . append ( node ) <NL>              node <SPC> = <SPC> node . right <NL> <NL>          node <SPC> = <SPC> stack . pop ( ) <NL>          total <SPC> += <SPC> node . val <NL>          node . val <SPC> = <SPC> total <NL> <NL>          node <SPC> = <SPC> node . left <NL> <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> reverseStr ( self , <SPC> s : <SPC> str , <SPC> k : <SPC> int ) <SPC> -> <SPC> str : <NL> <TAB> N <SPC> = <SPC> len ( s ) <NL> <TAB> ans <SPC> = <SPC> "" <NL> <TAB> position <SPC> = <SPC> 0 <NL> <TAB> while <SPC> position <SPC> < <SPC> N : <NL>          nx <SPC> = <SPC> s [ position : <SPC> position <SPC> + <SPC> k ] <NL>          ans <SPC> = <SPC> ans <SPC> + <SPC> nx [ : : - 1 ] <SPC> + <SPC> s [ position <SPC> + <SPC> k : <SPC> position <SPC> + <SPC> 2 <SPC> * <SPC> k ] <NL>          position <SPC> += <SPC> 2 <SPC> * <SPC> k <NL> <TAB> return <SPC> ans <NL> <NL> <NL> s1 <SPC> = <SPC> Solution ( ) <NL> s <SPC> = <SPC> "abcdefg" <NL> k <SPC> = <SPC> 2 <NL> print ( s1 . reverseStr ( s , <SPC> k ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> diameterOfBinaryTree ( self , <SPC> root ) : <NL> <TAB> self . ans <SPC> = <SPC> 1 <NL> <NL> <TAB> def <SPC> depth ( node ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> 0 <NL>          L <SPC> = <SPC> depth ( node . left ) <NL>          R <SPC> = <SPC> depth ( node . right ) <NL>          self . ans <SPC> = <SPC> max ( self . ans , <SPC> L <SPC> + <SPC> R <SPC> + <SPC> 1 ) <NL>          return <SPC> max ( L , <SPC> R ) <SPC> + <SPC> 1 <NL> <NL> <TAB> depth ( root ) <NL> <NL> <TAB> return <SPC> self . ans <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findCircleNum ( self , <SPC> M ) : <NL> <NL> <TAB> visited <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( M ) <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( M ) ) : <NL>          if <SPC> visited [ i ] <SPC> == <SPC> 0 : <NL>              self . dfs ( M , <SPC> visited , <SPC> i ) <NL>              count <SPC> += <SPC> 1 <NL> <TAB> return <SPC> count <NL> <NL> <TAB> def <SPC> dfs ( self , <SPC> M , <SPC> visited , <SPC> i ) : <NL> <TAB> for <SPC> j <SPC> in <SPC> range ( len ( M ) ) : <NL>          if <SPC> M [ i ] [ j ] <SPC> == <SPC> 1 <SPC> and <SPC> visited [ j ] <SPC> == <SPC> 0 : <NL>              visited [ j ] <SPC> = <SPC> 1 <NL>              self . dfs ( M , <SPC> visited , <SPC> j ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseWords ( self , <SPC> s ) : <NL> <NL> <TAB> return <SPC> " " . join ( [ word [ : : - 1 ] <SPC> for <SPC> word <SPC> in <SPC> s . split ( " " ) ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> subarraySum ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> sum_map <SPC> = <SPC> { } <NL> <TAB> sum_map [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> count <SPC> = <SPC> curr_sum <SPC> = <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          curr_sum <SPC> += <SPC> num <NL> <NL>          count <SPC> += <SPC> sum_map . get ( curr_sum <SPC> - <SPC> k , <SPC> 0 ) <NL> <NL>          sum_map [ curr_sum ] <SPC> = <SPC> sum_map . get ( curr_sum , <SPC> 0 ) <SPC> + <SPC> 1 <NL> <TAB> return <SPC> count <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isSubtree ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> s_res <SPC> = <SPC> self . preorder ( s , <SPC> True ) <NL> <TAB> t_res <SPC> = <SPC> self . preorder ( t , <SPC> True ) <NL> <TAB> return <SPC> t_res <SPC> in <SPC> s_res <NL> <NL> <TAB> def <SPC> preorder ( self , <SPC> root , <SPC> isLeft ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          if <SPC> isLeft : <NL>              return <SPC> "lnull" <NL>          else : <NL>              return <SPC> "rnull" <NL> <TAB> return <SPC> ( <NL>          "#" <NL>          + <SPC> str ( root . val ) <NL>          + <SPC> " " <NL>          + <SPC> self . preorder ( root . left , <SPC> True ) <NL>          + <SPC> " " <NL>          + <SPC> self . preorder ( root . right , <SPC> False ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> findUnsortedSubarray ( self , <SPC> nums ) : <NL> <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> l , <SPC> r <SPC> = <SPC> len ( nums ) , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( nums ) ) : <NL>          while <SPC> len ( stack ) <SPC> != <SPC> 0 <SPC> and <SPC> nums [ stack [ - 1 ] ] <SPC> > <SPC> nums [ i ] : <NL>              l <SPC> = <SPC> min ( l , <SPC> stack . pop ( ) ) <NL>          stack . append ( i ) <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( nums ) <SPC> - <SPC> 1 , <SPC> - 1 , <SPC> - 1 ) : <NL>          while <SPC> len ( stack ) <SPC> != <SPC> 0 <SPC> and <SPC> nums [ stack [ - 1 ] ] <SPC> < <SPC> nums [ i ] : <NL>              r <SPC> = <SPC> max ( r , <SPC> stack . pop ( ) ) <NL>          stack . append ( i ) <NL> <TAB> if <SPC> r <SPC> > <SPC> l : <NL>          return <SPC> r <SPC> - <SPC> l <SPC> + <SPC> 1 <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canPlaceFlowers ( self , <SPC> flowerbed , <SPC> n ) : <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( flowerbed ) ) : <NL>          curr <SPC> = <SPC> flowerbed [ i ] <NL>          if <SPC> i <SPC> - <SPC> 1 <SPC> >= <SPC> 0 : <NL>              curr <SPC> += <SPC> flowerbed [ i <SPC> - <SPC> 1 ] <NL>          if <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( flowerbed ) : <NL>              curr <SPC> += <SPC> flowerbed [ i <SPC> + <SPC> 1 ] <NL>          if <SPC> curr <SPC> == <SPC> 0 : <NL>              count <SPC> += <SPC> 1 <NL>              flowerbed [ i ] <SPC> = <SPC> 1 <NL>              if <SPC> count <SPC> >= <SPC> n : <NL>                  return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mergeTrees ( self , <SPC> t1 , <SPC> t2 ) : <NL> <NL> <TAB> if <SPC> t1 <SPC> is <SPC> None : <NL>          return <SPC> t2 <NL> <TAB> if <SPC> t2 <SPC> is <SPC> None : <NL>          return <SPC> t1 <NL> <TAB> t1 . val <SPC> += <SPC> t2 . val <NL> <TAB> t1 . left <SPC> = <SPC> self . mergeTrees ( t1 . left , <SPC> t2 . left ) <NL> <TAB> t1 . right <SPC> = <SPC> self . mergeTrees ( t1 . right , <SPC> t2 . right ) <NL> <TAB> return <SPC> t1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maximumProduct ( self , <SPC> nums ) : <NL> <TAB> min1 <SPC> = <SPC> min2 <SPC> = <SPC> float ( "inf" ) <NL> <TAB> max1 <SPC> = <SPC> max2 <SPC> = <SPC> max3 <SPC> = <SPC> float ( "-inf" ) <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          if <SPC> num <SPC> <= <SPC> min1 : <NL>              min2 <SPC> = <SPC> min1 <NL>              min1 <SPC> = <SPC> num <NL>          elif <SPC> num <SPC> <= <SPC> min2 : <NL>              min2 <SPC> = <SPC> num <NL>          if <SPC> num <SPC> >= <SPC> max1 : <NL>              max3 <SPC> = <SPC> max2 <NL>              max2 <SPC> = <SPC> max1 <NL>              max1 <SPC> = <SPC> num <NL>          elif <SPC> num <SPC> >= <SPC> max2 : <NL>              max3 <SPC> = <SPC> max2 <NL>              max2 <SPC> = <SPC> num <NL>          elif <SPC> num <SPC> >= <SPC> max3 : <NL>              max3 <SPC> = <SPC> num <NL> <TAB> return <SPC> max ( min1 <SPC> * <SPC> min2 <SPC> * <SPC> max1 , <SPC> max1 <SPC> * <SPC> max2 <SPC> * <SPC> max3 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> constructMaximumBinaryTree ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> nums <SPC> is <SPC> None <SPC> or <SPC> len ( nums ) <SPC> == <SPC> 0 : <NL>          return <SPC> None <NL> <TAB> max_index , <SPC> max_value <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> value <SPC> in <SPC> enumerate ( nums ) : <NL>          if <SPC> value <SPC> >= <SPC> max_value : <NL>              max_value <SPC> = <SPC> value <NL>              max_index <SPC> = <SPC> i <NL> <TAB> root <SPC> = <SPC> TreeNode ( max_value ) <NL> <TAB> root . left <SPC> = <SPC> self . constructMaximumBinaryTree ( nums [ : max_index ] ) <NL> <TAB> root . right <SPC> = <SPC> self . constructMaximumBinaryTree ( nums [ max_index <SPC> + <SPC> 1 : ] ) <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> checkPossibility ( self , <SPC> nums ) : <NL> <NL> <TAB> broken_num <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( nums ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> nums [ i ] <SPC> > <SPC> nums [ i <SPC> + <SPC> 1 ] : <NL>              broken_num <SPC> += <SPC> 1 <NL>              if <SPC> broken_num <SPC> >= <SPC> 2 : <NL>                  return <SPC> False <NL>              if <SPC> i <SPC> - <SPC> 1 <SPC> < <SPC> 0 <SPC> or <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> <= <SPC> nums [ i <SPC> + <SPC> 1 ] : <NL> <NL>                  nums [ i ] <SPC> = <SPC> nums [ i <SPC> + <SPC> 1 ] <NL>              else : <NL> <NL>                  nums [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> nums [ i ] <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> findKthNumber ( self , <SPC> m : <SPC> int , <SPC> n : <SPC> int , <SPC> k : <SPC> int ) <SPC> -> <SPC> int : <NL> <NL> <TAB> def <SPC> enough ( x ) : <NL>          count <SPC> = <SPC> 0 <NL> <NL>          for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> m <SPC> + <SPC> 1 ) : <NL>              count <SPC> += <SPC> min ( x <SPC> // <SPC> i , <SPC> n ) <NL>          return <SPC> count <SPC> >= <SPC> k <NL> <NL> <TAB> lo , <SPC> hi <SPC> = <SPC> 1 , <SPC> m <SPC> * <SPC> n <NL> <TAB> while <SPC> lo <SPC> < <SPC> hi : <NL>          mi <SPC> = <SPC> ( lo <SPC> + <SPC> hi ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> enough ( mi ) : <NL>              lo <SPC> = <SPC> mi <SPC> + <SPC> 1 <NL>          else : <NL>              hi <SPC> = <SPC> mi <NL> <TAB> return <SPC> lo <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> findSecondMinimumValue ( self , <SPC> root ) : <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> - 1 <NL> <TAB> ans <SPC> = <SPC> float ( "inf" ) <NL> <TAB> min_val <SPC> = <SPC> root . val <NL> <TAB> stack <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> stack : <NL>          curr <SPC> = <SPC> stack . pop ( ) <NL>          if <SPC> not <SPC> curr : <NL>              continue <NL>          if <SPC> min_val <SPC> < <SPC> curr . val <SPC> < <SPC> ans : <NL>              ans <SPC> = <SPC> curr . val <NL>          elif <SPC> curr . val <SPC> == <SPC> min_val : <NL>              stack . append ( curr . left ) <NL>              stack . append ( curr . right ) <NL> <TAB> return <SPC> ans <SPC> if <SPC> ans <SPC> < <SPC> float ( "inf" ) <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLengthOfLCIS ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> not <SPC> nums <SPC> or <SPC> len ( nums ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> ans <SPC> = <SPC> curr <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( nums ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> nums [ i ] <SPC> < <SPC> nums [ i <SPC> + <SPC> 1 ] : <NL>              curr <SPC> += <SPC> 1 <NL>              ans <SPC> = <SPC> max ( ans , <SPC> curr ) <NL>          else : <NL>              curr <SPC> = <SPC> 1 <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> validPalindrome ( self , <SPC> s ) : <NL> <TAB> return <SPC> self . validPalindromeHelper ( s , <SPC> 0 , <SPC> len ( s ) <SPC> - <SPC> 1 , <SPC> 1 ) <NL> <NL> <TAB> def <SPC> validPalindromeHelper ( self , <SPC> s , <SPC> left , <SPC> right , <SPC> budget ) : <NL> <NL> <TAB> while <SPC> left <SPC> < <SPC> len ( s ) <SPC> and <SPC> right <SPC> >= <SPC> 0 <SPC> and <SPC> left <SPC> <= <SPC> right <SPC> and <SPC> s [ left ] <SPC> == <SPC> s [ right ] : <NL>          left <SPC> += <SPC> 1 <NL>          right <SPC> -= <SPC> 1 <NL> <TAB> if <SPC> left <SPC> >= <SPC> len ( s ) <SPC> or <SPC> right <SPC> < <SPC> 0 <SPC> or <SPC> left <SPC> >= <SPC> right : <NL>          return <SPC> True <NL> <TAB> if <SPC> budget <SPC> == <SPC> 0 : <NL>          return <SPC> False <NL> <TAB> budget <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> self . validPalindromeHelper ( <NL>          s , <SPC> left <SPC> + <SPC> 1 , <SPC> right , <SPC> budget <NL> <TAB> ) <SPC> or <SPC> self . validPalindromeHelper ( s , <SPC> left , <SPC> right <SPC> - <SPC> 1 , <SPC> budget ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> topKFrequent ( self , <SPC> words , <SPC> k ) : <NL> <TAB> count <SPC> = <SPC> collections . Counter ( words ) <NL> <NL> <TAB> heap <SPC> = <SPC> [ ( - freq , <SPC> word ) <SPC> for <SPC> word , <SPC> freq <SPC> in <SPC> count . items ( ) ] <NL> <TAB> heapq . heapify ( heap ) <NL> <TAB> return <SPC> [ heapq . heappop ( heap ) [ 1 ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( k ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxAreaOfIsland ( self , <SPC> grid ) : <NL> <NL> <TAB> ans <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> range ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> == <SPC> 1 : <NL>                  grid [ i ] [ j ] <SPC> = <SPC> 0 <NL>                  ans <SPC> = <SPC> max ( self . dfs ( grid , <SPC> i , <SPC> j ) , <SPC> ans ) <NL> <NL> <TAB> return <SPC> ans <NL> <NL> <TAB> def <SPC> dfs ( self , <SPC> grid , <SPC> i , <SPC> j ) : <NL> <NL> <TAB> stack <SPC> = <SPC> [ ( i , <SPC> j ) ] <NL> <TAB> area <SPC> = <SPC> 0 <NL> <NL> <TAB> while <SPC> stack : <NL>          r , <SPC> c <SPC> = <SPC> stack . pop ( - 1 ) <NL>          area <SPC> += <SPC> 1 <NL>          for <SPC> nr , <SPC> nc <SPC> in <SPC> ( ( r <SPC> - <SPC> 1 , <SPC> c ) , <SPC> ( r <SPC> + <SPC> 1 , <SPC> c ) , <SPC> ( r , <SPC> c <SPC> - <SPC> 1 ) , <SPC> ( r , <SPC> c <SPC> + <SPC> 1 ) ) : <NL>              if <SPC> 0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ 0 ] ) <SPC> and <SPC> grid [ nr ] [ nc ] : <NL>                  stack . append ( ( nr , <SPC> nc ) ) <NL>                  grid [ nr ] [ nc ] <SPC> = <SPC> 0 <NL> <TAB> return <SPC> area <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> findShortestSubArray ( self , <SPC> nums ) : <NL> <TAB> left , <SPC> right , <SPC> count <SPC> = <SPC> { } , <SPC> { } , <SPC> { } <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( nums ) : <NL>          if <SPC> x <SPC> not <SPC> in <SPC> left : <NL>              left [ x ] <SPC> = <SPC> i <NL>          right [ x ] <SPC> = <SPC> i <NL>          count [ x ] <SPC> = <SPC> count . get ( x , <SPC> 0 ) <SPC> + <SPC> 1 <NL> <NL> <TAB> ans <SPC> = <SPC> len ( nums ) <NL> <TAB> degree <SPC> = <SPC> max ( count . values ( ) ) <NL> <TAB> for <SPC> x <SPC> in <SPC> count : <NL>          if <SPC> count [ x ] <SPC> == <SPC> degree : <NL>              ans <SPC> = <SPC> min ( ans , <SPC> right [ x ] <SPC> - <SPC> left [ x ] <SPC> + <SPC> 1 ) <NL> <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> searchBST ( self , <SPC> root , <SPC> val ) : <NL> <TAB> while <SPC> root : <NL>          if <SPC> root . val <SPC> == <SPC> val : <NL>              return <SPC> root <NL>          elif <SPC> root . val <SPC> > <SPC> val : <NL>              root <SPC> = <SPC> root . left <NL>          else : <NL>              root <SPC> = <SPC> root . right <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> KthLargest ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> k , <SPC> nums ) : <NL> <TAB> self . nums <SPC> = <SPC> nums <NL> <TAB> self . k <SPC> = <SPC> k <NL> <NL> <TAB> heapq . heapify ( self . nums ) <NL> <NL> <TAB> while <SPC> len ( self . nums ) <SPC> > <SPC> k : <NL>          heapq . heappop ( self . nums ) <NL> <NL> <TAB> def <SPC> add ( self , <SPC> val ) : <NL> <NL> <TAB> if <SPC> len ( self . nums ) <SPC> < <SPC> self . k : <NL>          heapq . heappush ( self . nums , <SPC> val ) <NL> <TAB> elif <SPC> val <SPC> > <SPC> self . nums [ 0 ] : <NL> <NL>          heapq . heapreplace ( self . nums , <SPC> val ) <NL> <NL> <TAB> return <SPC> self . nums [ 0 ] <NL> <NL> <NL> class <SPC> MyHashMap ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . size <SPC> = <SPC> 10000 <NL> <TAB> self . nodes <SPC> = <SPC> [ None ] <SPC> * <SPC> self . size <NL> <NL> <TAB> def <SPC> put ( self , <SPC> key , <SPC> value ) : <NL> <NL> <TAB> index <SPC> = <SPC> hash ( key ) <SPC> % <SPC> self . size <NL> <TAB> if <SPC> self . nodes [ index ] <SPC> is <SPC> None : <NL>          self . nodes [ index ] <SPC> = <SPC> ListNode ( - 1 , <SPC> - 1 ) <NL> <TAB> prev <SPC> = <SPC> find ( self . nodes [ index ] , <SPC> key ) <NL> <TAB> if <SPC> prev . next <SPC> is <SPC> None : <NL>          prev . next <SPC> = <SPC> ListNode ( key , <SPC> value ) <NL> <TAB> else : <NL>          prev . next . val <SPC> = <SPC> value <NL> <NL> <TAB> def <SPC> get ( self , <SPC> key ) : <NL> <NL> <TAB> index <SPC> = <SPC> hash ( key ) <SPC> % <SPC> self . size <NL> <TAB> if <SPC> self . nodes [ index ] <SPC> is <SPC> None : <NL>          return <SPC> - 1 <NL> <TAB> prev <SPC> = <SPC> find ( self . nodes [ index ] , <SPC> key ) <NL> <TAB> if <SPC> prev . next <SPC> is <SPC> None : <NL>          return <SPC> - 1 <NL> <TAB> else : <NL>          return <SPC> prev . next . val <NL> <NL> <TAB> def <SPC> remove ( self , <SPC> key ) : <NL> <NL> <TAB> index <SPC> = <SPC> hash ( key ) <SPC> % <SPC> self . size <NL> <TAB> if <SPC> self . nodes [ index ] <SPC> is <SPC> None : <NL>          return <NL> <TAB> prev <SPC> = <SPC> find ( self . nodes [ index ] , <SPC> key ) <NL> <TAB> if <SPC> prev . next <SPC> is <SPC> None : <NL>          return <NL> <TAB> prev . next <SPC> = <SPC> prev . next . next <NL> <NL> <NL> def <SPC> find ( bucket , <SPC> key ) : <NL> <NL> <TAB> node <SPC> = <SPC> bucket <NL> <TAB> prev <SPC> = <SPC> None <NL> <TAB> while <SPC> node <SPC> is <SPC> not <SPC> None <SPC> and <SPC> node . key <SPC> != <SPC> key : <NL> <TAB> prev <SPC> = <SPC> node <NL> <TAB> node <SPC> = <SPC> node . next <NL> <TAB> return <SPC> prev <NL> <NL> <NL> class <SPC> ListNode : <NL> <TAB> def <SPC> __init__ ( self , <SPC> key , <SPC> val ) : <NL> <TAB> self . key <SPC> = <SPC> key <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> toLowerCase ( self , <SPC> str ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> gap <SPC> = <SPC> ord ( "a" ) <SPC> - <SPC> ord ( "A" ) <NL> <TAB> for <SPC> c <SPC> in <SPC> str : <NL>          if <SPC> ord ( c ) <SPC> >= <SPC> ord ( "A" ) <SPC> and <SPC> ord ( c ) <SPC> <= <SPC> ord ( "Z" ) : <NL>              res . append ( chr ( ord ( c ) <SPC> + <SPC> gap ) ) <NL>          else : <NL>              res . append ( c ) <NL> <TAB> return <SPC> "" . join ( res ) <NL> <NL> <NL> class <SPC> MaxStack ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . stack <SPC> = <SPC> [ ] <NL> <TAB> self . max_stack <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <NL> <TAB> self . stack . append ( x ) <NL> <TAB> if <SPC> len ( self . max_stack ) <SPC> == <SPC> 0 : <NL>          self . max_stack . append ( x ) <NL>          return <NL> <TAB> if <SPC> self . max_stack [ - 1 ] <SPC> > <SPC> x : <NL>          self . max_stack . append ( self . max_stack [ - 1 ] ) <NL> <TAB> else : <NL>          self . max_stack . append ( x ) <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <NL> <TAB> if <SPC> len ( self . stack ) <SPC> != <SPC> 0 : <NL>          self . max_stack . pop ( - 1 ) <NL>          return <SPC> self . stack . pop ( - 1 ) <NL> <NL> <TAB> def <SPC> top ( self ) : <NL> <NL> <TAB> return <SPC> self . stack [ - 1 ] <NL> <NL> <TAB> def <SPC> peekMax ( self ) : <NL> <NL> <TAB> if <SPC> len ( self . max_stack ) <SPC> != <SPC> 0 : <NL>          return <SPC> self . max_stack [ - 1 ] <NL> <NL> <TAB> def <SPC> popMax ( self ) : <NL> <NL> <TAB> val <SPC> = <SPC> self . peekMax ( ) <NL> <TAB> buff <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> self . top ( ) <SPC> != <SPC> val : <NL>          buff . append ( self . pop ( ) ) <NL> <TAB> self . pop ( ) <NL> <TAB> while <SPC> len ( buff ) <SPC> != <SPC> 0 : <NL>          self . push ( buff . pop ( - 1 ) ) <NL> <TAB> return <SPC> val <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> isOneBitCharacter ( self , <SPC> bits : <SPC> List [ int ] ) <SPC> -> <SPC> bool : <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <NL> <TAB> while <SPC> pos <SPC> < <SPC> len ( bits ) <SPC> - <SPC> 1 : <NL> <NL>          pos <SPC> += <SPC> bits [ pos ] <SPC> + <SPC> 1 <NL> <TAB> return <SPC> pos <SPC> == <SPC> len ( bits ) <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> longestWord ( self , <SPC> words ) : <NL> <TAB> def <SPC> Trie ( ) : <SPC> return <SPC> collections . defaultdict ( Trie ) <NL> <TAB> trie <SPC> = <SPC> Trie ( ) <NL> <TAB> END <SPC> = <SPC> True <NL> <TAB> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          reduce ( dict . __getitem__ , <SPC> word , <SPC> trie ) [ END ] <SPC> = <SPC> i <NL> <TAB> stack <SPC> = <SPC> trie . values ( ) <NL> <TAB> ans <SPC> = <SPC> "" <NL> <TAB> while <SPC> stack : <NL>          cur <SPC> = <SPC> stack . pop ( ) <NL>          if <SPC> END <SPC> in <SPC> cur : <NL>              word <SPC> = <SPC> words [ cur [ END ] ] <NL>              if <SPC> len ( word ) <SPC> > <SPC> len ( ans ) <SPC> or <SPC> len ( word ) <SPC> == <SPC> len ( ans ) <SPC> and <SPC> word <SPC> < <SPC> ans : <NL>                  ans <SPC> = <SPC> word <NL>              stack . extend ( [ cur [ letter ] <SPC> for <SPC> letter <SPC> in <SPC> cur <SPC> if <SPC> letter <SPC> != <SPC> END ] ) <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pivotIndex ( self , <SPC> nums ) : <NL> <NL> <TAB> totalsum <SPC> = <SPC> sum ( nums ) <NL> <TAB> leftsum <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( nums ) : <NL> <NL>          if <SPC> leftsum <SPC> == <SPC> totalsum <SPC> - <SPC> leftsum <SPC> - <SPC> v : <NL>              return <SPC> i <NL>          leftsum <SPC> += <SPC> v <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> selfDividingNumbers ( self , <SPC> left : <SPC> int , <SPC> right : <SPC> int ) <SPC> -> <SPC> List [ int ] : <NL> <NL> <TAB> return <SPC> [ <NL>          x <NL>          for <SPC> x <SPC> in <SPC> range ( left , <SPC> right <SPC> + <SPC> 1 ) <NL>          if <SPC> all ( [ int ( i ) <SPC> != <SPC> 0 <SPC> and <SPC> x <SPC> % <SPC> int ( i ) <SPC> == <SPC> 0 <SPC> for <SPC> i <SPC> in <SPC> str ( x ) ] ) <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> floodFill ( self , <SPC> image , <SPC> sr , <SPC> sc , <SPC> newColor ) : <NL> <NL> <TAB> r_ls , <SPC> c_ls <SPC> = <SPC> len ( image ) , <SPC> len ( image [ 0 ] ) <NL> <TAB> color <SPC> = <SPC> image [ sr ] [ sc ] <NL> <TAB> if <SPC> color <SPC> == <SPC> newColor : <NL>          return <SPC> image <NL> <TAB> queue <SPC> = <SPC> [ ( sr , <SPC> sc ) ] <NL> <TAB> while <SPC> len ( queue ) <SPC> > <SPC> 0 : <NL>          r , <SPC> c <SPC> = <SPC> queue . pop ( 0 ) <NL>          if <SPC> image [ r ] [ c ] <SPC> == <SPC> color : <NL>              image [ r ] [ c ] <SPC> = <SPC> newColor <NL>              if <SPC> r <SPC> - <SPC> 1 <SPC> >= <SPC> 0 : <NL>                  queue . append ( ( r <SPC> - <SPC> 1 , <SPC> c ) ) <NL>              if <SPC> r <SPC> + <SPC> 1 <SPC> < <SPC> r_ls : <NL>                  queue . append ( ( r <SPC> + <SPC> 1 , <SPC> c ) ) <NL>              if <SPC> c <SPC> - <SPC> 1 <SPC> >= <SPC> 0 : <NL>                  queue . append ( ( r , <SPC> c <SPC> - <SPC> 1 ) ) <NL>              if <SPC> c <SPC> + <SPC> 1 <SPC> < <SPC> c_ls : <NL>                  queue . append ( ( r , <SPC> c <SPC> + <SPC> 1 ) ) <NL> <TAB> return <SPC> image <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> networkDelayTime ( self , <SPC> times , <SPC> N , <SPC> K ) : <NL> <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v , <SPC> w <SPC> in <SPC> times : <NL>          graph [ u ] . append ( ( v , <SPC> w ) ) <NL> <NL> <TAB> dist <SPC> = <SPC> { node : <SPC> float ( "inf" ) <SPC> for <SPC> node <SPC> in <SPC> xrange ( 1 , <SPC> N <SPC> + <SPC> 1 ) } <NL> <TAB> seen <SPC> = <SPC> [ False ] <SPC> * <SPC> ( N <SPC> + <SPC> 1 ) <NL> <TAB> dist [ K ] <SPC> = <SPC> 0 <NL> <NL> <TAB> while <SPC> True : <NL>          cand_node <SPC> = <SPC> - 1 <NL>          cand_dist <SPC> = <SPC> float ( "inf" ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> N <SPC> + <SPC> 1 ) : <NL>              if <SPC> not <SPC> seen [ i ] <SPC> and <SPC> dist [ i ] <SPC> < <SPC> cand_dist : <NL>                  cand_dist <SPC> = <SPC> dist [ i ] <NL>                  cand_node <SPC> = <SPC> i <NL> <NL>          if <SPC> cand_node <SPC> < <SPC> 0 : <NL>              break <NL>          seen [ cand_node ] <SPC> = <SPC> True <NL>          for <SPC> nei , <SPC> d <SPC> in <SPC> graph [ cand_node ] : <NL>              dist [ nei ] <SPC> = <SPC> min ( dist [ nei ] , <SPC> dist [ cand_node ] <SPC> + <SPC> d ) <NL> <NL> <TAB> ans <SPC> = <SPC> max ( dist . values ( ) ) <NL> <TAB> return <SPC> ans <SPC> if <SPC> ans <SPC> < <SPC> float ( "inf" ) <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> ipToInt ( self , <SPC> ip ) : <NL> <TAB> ans <SPC> = <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> ip . split ( "." ) : <NL>          ans <SPC> = <SPC> 256 <SPC> * <SPC> ans <SPC> + <SPC> int ( x ) <NL> <TAB> return <SPC> ans <NL> <NL> <TAB> def <SPC> intToIP ( self , <SPC> x ) : <NL> <TAB> return <SPC> "." . join ( str ( ( x <SPC> >> <SPC> i ) <SPC> % <SPC> 256 ) <SPC> for <SPC> i <SPC> in <SPC> ( 24 , <SPC> 16 , <SPC> 8 , <SPC> 0 ) ) <NL> <NL> <TAB> def <SPC> ipToCIDR ( self , <SPC> ip , <SPC> n ) : <NL> <NL> <TAB> start <SPC> = <SPC> self . ipToInt ( ip ) <NL> <TAB> ans <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> n : <NL> <NL>          mask <SPC> = <SPC> max ( 33 <SPC> - <SPC> ( start <SPC> & <SPC> - start ) . bit_length ( ) , <SPC> 33 <SPC> - <SPC> n . bit_length ( ) ) <NL>          ans . append ( self . intToIP ( start ) <SPC> + <SPC> "/" <SPC> + <SPC> str ( mask ) ) <NL>          start <SPC> += <SPC> 1 <SPC> << <SPC> ( 32 <SPC> - <SPC> mask ) <NL>          n <SPC> -= <SPC> 1 <SPC> << <SPC> ( 32 <SPC> - <SPC> mask ) <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> anagramMappings ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> val_index <SPC> = <SPC> { } <NL> <TAB> ans <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> n <SPC> in <SPC> enumerate ( B ) : <NL>          val_index [ n ] <SPC> = <SPC> i <NL> <TAB> for <SPC> n <SPC> in <SPC> A : <NL>          ans . append ( val_index [ n ] ) <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isToeplitzMatrix ( self , <SPC> matrix ) : <NL> <NL> <TAB> for <SPC> r <SPC> in <SPC> range ( len ( matrix ) <SPC> - <SPC> 1 ) : <NL>          for <SPC> c <SPC> in <SPC> range ( len ( matrix [ 0 ] ) <SPC> - <SPC> 1 ) : <NL>              if <SPC> matrix [ r ] [ c ] <SPC> != <SPC> matrix [ r <SPC> + <SPC> 1 ] [ c <SPC> + <SPC> 1 ] : <NL>                  return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numJewelsInStones ( self , <SPC> J , <SPC> S ) : <NL> <NL> <TAB> if <SPC> len ( J ) <SPC> == <SPC> 0 <SPC> or <SPC> len ( S ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> j_set <SPC> = <SPC> set ( J ) <NL> <TAB> ans <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          if <SPC> c <SPC> in <SPC> j_set : <NL>              ans <SPC> += <SPC> 1 <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> letterCasePermutation ( self , <SPC> S ) : <NL> <TAB> B <SPC> = <SPC> sum ( letter . isalpha ( ) <SPC> for <SPC> letter <SPC> in <SPC> S ) <NL> <TAB> ans <SPC> = <SPC> [ ] <NL> <NL> <TAB> for <SPC> bits <SPC> in <SPC> xrange ( 1 <SPC> << <SPC> B ) : <NL>          b <SPC> = <SPC> 0 <NL>          word <SPC> = <SPC> [ ] <NL>          for <SPC> letter <SPC> in <SPC> S : <NL>              if <SPC> letter . isalpha ( ) : <NL>                  if <SPC> ( bits <SPC> >> <SPC> b ) <SPC> & <SPC> 1 : <NL>                      word . append ( letter . lower ( ) ) <NL>                  else : <NL>                      word . append ( letter . upper ( ) ) <NL> <NL>                  b <SPC> += <SPC> 1 <NL>              else : <NL>                  word . append ( letter ) <NL> <NL>          ans . append ( "" . join ( word ) ) <NL> <TAB> return <SPC> ans <NL> <NL> <NL> Morse_tab <SPC> = <SPC> [ <NL> <TAB> ".-" , <NL> <TAB> "-..." , <NL> <TAB> "-.-." , <NL> <TAB> "-.." , <NL> <TAB> "." , <NL> <TAB> "..-." , <NL> <TAB> "--." , <NL> <TAB> "...." , <NL> <TAB> ".." , <NL> <TAB> ".---" , <NL> <TAB> "-.-" , <NL> <TAB> ".-.." , <NL> <TAB> "--" , <NL> <TAB> "-." , <NL> <TAB> "---" , <NL> <TAB> ".--." , <NL> <TAB> "--.-" , <NL> <TAB> ".-." , <NL> <TAB> "..." , <NL> <TAB> "-" , <NL> <TAB> "..-" , <NL> <TAB> "...-" , <NL> <TAB> ".--" , <NL> <TAB> "-..-" , <NL> <TAB> "-.--" , <NL> <TAB> "--.." , <NL> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> uniqueMorseRepresentations ( self , <SPC> words ) : <NL> <NL> <TAB> if <SPC> len ( words ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> ans_set <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          morsed <SPC> = <SPC> "" <NL>          for <SPC> c <SPC> in <SPC> word : <NL>              morsed <SPC> += <SPC> Morse_tab [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <NL> <NL>          ans_set . add ( morsed ) <NL> <TAB> return <SPC> len ( ans_set ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> subdomainVisits ( self , <SPC> cpdomains ) : <NL> <NL> <TAB> domain_count <SPC> = <SPC> { } <NL> <TAB> for <SPC> cpdomain <SPC> in <SPC> cpdomains : <NL>          count , <SPC> domain <SPC> = <SPC> cpdomain . split ( " " ) <NL>          sub_domain <SPC> = <SPC> domain . split ( "." ) <NL>          for <SPC> i <SPC> in <SPC> range ( len ( sub_domain ) ) : <NL>              curr <SPC> = <SPC> "." . join ( sub_domain [ i : ] ) <NL>              domain_count [ curr ] <SPC> = <SPC> domain_count . get ( curr , <SPC> 0 ) <SPC> + <SPC> int ( count ) <NL> <TAB> return <SPC> [ str ( v ) <SPC> + <SPC> " " <SPC> + <SPC> k <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> domain_count . items ( ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mostCommonWord ( self , <SPC> paragraph , <SPC> banned ) : <NL> <NL> <TAB> banned <SPC> = <SPC> set ( banned ) <NL> <TAB> count <SPC> = <SPC> collections . Counter ( <NL>          word <SPC> for <SPC> word <SPC> in <SPC> re . split ( "[ !?',;.]" , <SPC> paragraph . lower ( ) ) <SPC> if <SPC> word <NL> <TAB> ) <NL> <TAB> return <SPC> max ( <NL>          ( item <SPC> for <SPC> item <SPC> in <SPC> count . items ( ) <SPC> if <SPC> item [ 0 ] <SPC> not <SPC> in <SPC> banned ) , <NL>          key = operator . itemgetter ( 1 ) , <NL> <TAB> ) [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> flipAndInvertImage ( self , <SPC> A ) : <NL> <TAB> for <SPC> row <SPC> in <SPC> A : <NL>          for <SPC> i <SPC> in <SPC> xrange ( ( len ( row ) <SPC> + <SPC> 1 ) <SPC> / <SPC> 2 ) : <NL> <NL>              row [ i ] , <SPC> row [ ~ i ] <SPC> = <SPC> row [ ~ i ] <SPC> ^ <SPC> 1 , <SPC> row [ i ] <SPC> ^ <SPC> 1 <NL> <TAB> return <SPC> A <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isRectangleOverlap ( self , <SPC> rec1 , <SPC> rec2 ) : <NL> <NL> <TAB> return <SPC> not <SPC> ( <NL>          rec1 [ 2 ] <SPC> <= <SPC> rec2 [ 0 ] <NL>          or <SPC> rec1 [ 3 ] <SPC> <= <SPC> rec2 [ 1 ] <NL>          or <SPC> rec1 [ 0 ] <SPC> >= <SPC> rec2 [ 2 ] <NL>          or <SPC> rec1 [ 1 ] <SPC> >= <SPC> rec2 [ 3 ] <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> backspaceCompare ( self , <SPC> S , <SPC> T ) : <NL> <NL> <TAB> if <SPC> S <SPC> == <SPC> T : <NL>          return <SPC> True <NL> <TAB> s_stack <SPC> = <SPC> [ ] <NL> <TAB> t_stack <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          if <SPC> c <SPC> != <SPC> "#" : <NL>              s_stack . append ( c ) <NL>          elif <SPC> len ( s_stack ) <SPC> != <SPC> 0 : <NL>              s_stack . pop ( - 1 ) <NL> <TAB> for <SPC> c <SPC> in <SPC> T : <NL>          if <SPC> c <SPC> != <SPC> "#" : <NL>              t_stack . append ( c ) <NL>          elif <SPC> len ( t_stack ) <SPC> != <SPC> 0 : <NL>              t_stack . pop ( - 1 ) <NL> <TAB> return <SPC> "" . join ( s_stack ) <SPC> == <SPC> "" . join ( t_stack ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> peakIndexInMountainArray ( self , <SPC> A ) : <NL> <TAB> lo , <SPC> hi <SPC> = <SPC> 0 , <SPC> len ( A ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> lo <SPC> < <SPC> hi : <NL>          mid <SPC> = <SPC> ( lo <SPC> + <SPC> hi ) <SPC> / <SPC> 2 <NL>          if <SPC> A [ mid ] <SPC> < <SPC> A [ mid <SPC> + <SPC> 1 ] : <NL>              lo <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          else : <NL>              hi <SPC> = <SPC> mid <NL> <TAB> return <SPC> lo <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> transpose ( self , <SPC> A ) : <NL> <NL> <TAB> R , <SPC> C <SPC> = <SPC> len ( A ) , <SPC> len ( A [ 0 ] ) <NL> <TAB> ans <SPC> = <SPC> [ [ None ] <SPC> * <SPC> R <SPC> for <SPC> _ <SPC> in <SPC> xrange ( C ) ] <NL> <TAB> for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( A ) : <NL>          for <SPC> c , <SPC> val <SPC> in <SPC> enumerate ( row ) : <NL>              ans [ c ] [ r ] <SPC> = <SPC> val <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution : <NL> <NL> <TAB> def <SPC> binaryGap ( self , <SPC> n : <SPC> int ) <SPC> -> <SPC> int : <NL> <NL> <TAB> current <SPC> = <SPC> 1 <NL> <TAB> last1 <SPC> = <SPC> - 1 <NL> <TAB> out <SPC> = <SPC> 0 <NL> <TAB> while <SPC> n <SPC> > <SPC> 0 : <NL>          if <SPC> n <SPC> % <SPC> 2 <SPC> == <SPC> 1 : <NL>              if <SPC> last1 <SPC> >= <SPC> 1 : <NL>                  out <SPC> = <SPC> max ( out , <SPC> current <SPC> - <SPC> last1 ) <NL>              last1 <SPC> = <SPC> current <NL>          current <SPC> += <SPC> 1 <NL>          n <SPC> = <SPC> n <SPC> // <SPC> 2 <NL> <TAB> return <SPC> out <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> leafSimilar ( self , <SPC> root1 , <SPC> root2 ) : <NL> <NL> <TAB> if <SPC> not <SPC> root1 <SPC> and <SPC> not <SPC> root2 : <NL>          return <SPC> True <NL> <TAB> leaf1 <SPC> = <SPC> [ ] <NL> <TAB> leaf2 <SPC> = <SPC> [ ] <NL> <TAB> self . dfs ( root1 , <SPC> leaf1 ) <NL> <TAB> self . dfs ( root2 , <SPC> leaf2 ) <NL> <TAB> if <SPC> leaf1 <SPC> == <SPC> leaf2 : <NL>          return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <TAB> def <SPC> dfs ( self , <SPC> node , <SPC> leavels ) : <NL> <TAB> if <SPC> not <SPC> node : <NL>          return <NL> <TAB> if <SPC> not <SPC> node . left <SPC> and <SPC> not <SPC> node . right : <NL>          leavels . append ( node . val ) <NL> <TAB> self . dfs ( node . left , <SPC> leavels ) <NL> <TAB> self . dfs ( node . right , <SPC> leavels ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> middleNode ( self , <SPC> head ) : <NL> <NL> <TAB> fast <SPC> = <SPC> slow <SPC> = <SPC> head <NL> <TAB> while <SPC> fast <SPC> and <SPC> fast . next : <NL>          slow <SPC> = <SPC> slow . next <NL>          fast <SPC> = <SPC> fast . next . next <NL> <TAB> return <SPC> slow <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> totalFruit ( self , <SPC> tree ) : <NL> <TAB> ans <SPC> = <SPC> i <SPC> = <SPC> 0 <NL> <TAB> count <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> for <SPC> j , <SPC> x <SPC> in <SPC> enumerate ( tree ) : <NL>          count [ x ] <SPC> += <SPC> 1 <NL>          while <SPC> len ( count ) <SPC> >= <SPC> 3 : <NL>              count [ tree [ i ] ] <SPC> -= <SPC> 1 <NL>              if <SPC> count [ tree [ i ] ] <SPC> == <SPC> 0 : <NL>                  del <SPC> count [ tree [ i ] ] <NL>              i <SPC> += <SPC> 1 <NL>          ans <SPC> = <SPC> max ( ans , <SPC> j <SPC> - <SPC> i <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> ans <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> sortArrayByParity ( self , <SPC> A ) : <NL> <NL> <TAB> lo , <SPC> hi <SPC> = <SPC> 0 , <SPC> len ( A ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> lo <SPC> < <SPC> hi : <NL>          if <SPC> A [ lo ] <SPC> % <SPC> 2 <SPC> > <SPC> A [ hi ] <SPC> % <SPC> 2 : <NL>              A [ lo ] , <SPC> A [ hi ] <SPC> = <SPC> A [ hi ] , <SPC> A [ lo ] <NL>          if <SPC> A [ lo ] <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              lo <SPC> += <SPC> 1 <NL>          if <SPC> A [ hi ] <SPC> % <SPC> 2 <SPC> == <SPC> 1 : <NL>              hi <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> A <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> sortArrayByParityII ( self , <SPC> A ) : <NL> <TAB> odd <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 0 , <SPC> len ( A ) , <SPC> 2 ) : <NL>          if <SPC> A [ i ] <SPC> % <SPC> 2 : <NL>              while <SPC> A [ odd ] <SPC> % <SPC> 2 : <NL>                  odd <SPC> += <SPC> 2 <NL>              A [ i ] , <SPC> A [ odd ] <SPC> = <SPC> A [ odd ] , <SPC> A [ i ] <NL> <TAB> return <SPC> A <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numUniqueEmails ( self , <SPC> emails ) : <NL> <NL> <TAB> email_set <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> email <SPC> in <SPC> emails : <NL>          elements <SPC> = <SPC> email . split ( "@" ) <NL>          email_set . add ( elements [ 0 ] . split ( "+" ) [ 0 ] . replace ( "." , <SPC> "" ) <SPC> + <SPC> elements [ 1 ] ) <NL> <TAB> return <SPC> len ( email_set ) <NL> <NL> <NL> class <SPC> RecentCounter ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . queue <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> ping ( self , <SPC> t ) : <NL> <NL> <TAB> self . queue . append ( t ) <NL> <TAB> while <SPC> self . queue <SPC> and <SPC> self . queue [ 0 ] <SPC> < <SPC> t <SPC> - <SPC> 3000 : <NL>          self . queue . pop ( 0 ) <NL> <TAB> return <SPC> len ( self . queue ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> reorderLogFiles ( self , <SPC> logs ) : <NL> <TAB> letter_logs <SPC> = <SPC> [ ] <NL> <TAB> digit_logs <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> log <SPC> in <SPC> logs : <NL>          if <SPC> log . split ( " " ) [ 1 ] . isnumeric ( ) : <NL>              digit_logs . append ( log ) <NL>          else : <NL>              letter_logs . append ( log ) <NL> <TAB> return <SPC> ( <NL>          sorted ( letter_logs , <SPC> key = lambda <SPC> x : <SPC> x . split ( " " ) [ 1 : ] <SPC> + <SPC> x . split ( " " ) [ 0 ] ) <NL>          + <SPC> digit_logs <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minIncrementForUnique ( self , <SPC> A ) : <NL> <NL> <TAB> if <SPC> A <SPC> is <SPC> None <SPC> or <SPC> len ( A ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> num_set <SPC> = <SPC> set ( ) <NL> <TAB> duplicate <SPC> = <SPC> [ ] <NL> <TAB> A . sort ( ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> A [ 0 ] , <SPC> A [ - 1 ] <NL> <TAB> holes <SPC> = <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <NL> <TAB> for <SPC> v <SPC> in <SPC> A : <NL>          if <SPC> v <SPC> in <SPC> num_set : <NL>              duplicate . append ( v ) <NL>          else : <NL>              num_set . add ( v ) <NL> <TAB> holes <SPC> = <SPC> holes <SPC> - <SPC> len ( num_set ) <NL> <NL> <TAB> for <SPC> hole <SPC> in <SPC> range ( left <SPC> + <SPC> 1 , <SPC> right ) : <NL>          if <SPC> holes <SPC> == <SPC> 0 <SPC> or <SPC> len ( duplicate ) <SPC> == <SPC> 0 : <NL>              break <NL>          if <SPC> hole <SPC> not <SPC> in <SPC> num_set <SPC> and <SPC> hole <SPC> > <SPC> duplicate [ 0 ] : <NL>              res <SPC> += <SPC> hole <SPC> - <SPC> duplicate . pop ( 0 ) <NL>              holes <SPC> -= <SPC> 1 <NL> <TAB> while <SPC> len ( duplicate ) <SPC> != <SPC> 0 : <NL>          right <SPC> += <SPC> 1 <NL>          res <SPC> += <SPC> right <SPC> - <SPC> duplicate . pop ( 0 ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validateStackSequences ( self , <SPC> pushed , <SPC> popped ) : <NL> <NL> <TAB> in_stack <SPC> = <SPC> [ ] <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <TAB> while <SPC> pos <SPC> != <SPC> len ( pushed ) : <NL>          curr <SPC> = <SPC> pushed [ pos ] <NL>          while <SPC> len ( in_stack ) <SPC> > <SPC> 0 <SPC> and <SPC> len ( popped ) <SPC> > <SPC> 0 <SPC> and <SPC> in_stack [ - 1 ] <SPC> == <SPC> popped [ 0 ] : <NL>              in_stack . pop ( - 1 ) <NL>              popped . pop ( 0 ) <NL>          if <SPC> len ( popped ) <SPC> == <SPC> 0 : <NL>              break <NL>          if <SPC> curr <SPC> == <SPC> popped [ 0 ] : <NL>              popped . pop ( 0 ) <NL>          else : <NL>              in_stack . append ( curr ) <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> while <SPC> len ( in_stack ) <SPC> > <SPC> 0 <SPC> and <SPC> len ( popped ) <SPC> > <SPC> 0 <SPC> and <SPC> in_stack [ - 1 ] <SPC> == <SPC> popped [ 0 ] : <NL>          in_stack . pop ( - 1 ) <NL>          popped . pop ( 0 ) <NL> <TAB> if <SPC> len ( in_stack ) <SPC> == <SPC> 0 : <NL>          return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <NL> <TAB> print <SPC> s . validateStackSequences ( [ 1 , <SPC> 0 , <SPC> 3 , <SPC> 2 ] , <SPC> [ 0 , <SPC> 1 , <SPC> 2 , <SPC> 3 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isAlienSorted ( self , <SPC> words , <SPC> order ) : <NL> <NL> <TAB> order_map <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( order ) : <NL>          order_map [ v ] <SPC> = <SPC> i <NL> <NL> <TAB> def <SPC> cmp_alien ( x , <SPC> y ) : <NL>          ls <SPC> = <SPC> min ( len ( x ) , <SPC> len ( y ) ) <NL>          index <SPC> = <SPC> 0 <NL>          while <SPC> index <SPC> < <SPC> ls : <NL>              if <SPC> x [ index ] <SPC> != <SPC> y [ index ] : <NL>                  return <SPC> order_map [ x [ index ] ] <SPC> - <SPC> order_map [ y [ index ] ] <NL>              index <SPC> += <SPC> 1 <NL>          return <SPC> len ( x ) <SPC> - <SPC> len ( y ) <NL> <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <TAB> while <SPC> pos <SPC> + <SPC> 1 <SPC> < <SPC> len ( words ) : <NL>          if <SPC> cmp_alien ( words [ pos ] , <SPC> words [ pos <SPC> + <SPC> 1 ] ) <SPC> > <SPC> 0 : <NL>              return <SPC> False <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . isAlienSorted ( [ "hello" , <SPC> "leetcode" ] , <SPC> "hlabcdefgijkmnopqrstuvwxyz" ) <NL> <TAB> print <SPC> s . isAlienSorted ( [ "word" , <SPC> "world" , <SPC> "row" ] , <SPC> "worldabcefghijkmnpqstuvxyz" ) <NL> <TAB> print <SPC> s . isAlienSorted ( [ "apple" , <SPC> "app" ] , <SPC> "abcdefghijklmnopqrstuvwxyz" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canReorderDoubled ( self , <SPC> A ) : <NL> <NL> <TAB> v_map <SPC> = <SPC> { } <NL> <TAB> A . sort ( key = lambda <SPC> x : <SPC> abs ( x ) ) <NL> <TAB> for <SPC> n <SPC> in <SPC> A : <NL>          v_map [ n ] <SPC> = <SPC> v_map . get ( n , <SPC> 0 ) <SPC> + <SPC> 1 <NL> <TAB> for <SPC> n <SPC> in <SPC> A : <NL>          if <SPC> v_map [ n ] <SPC> <= <SPC> 0 : <NL>              continue <NL>          if <SPC> 2 <SPC> * <SPC> n <SPC> in <SPC> v_map <SPC> and <SPC> v_map [ 2 <SPC> * <SPC> n ] <SPC> > <SPC> 0 : <NL>              v_map [ n ] <SPC> -= <SPC> 1 <NL>              v_map [ 2 <SPC> * <SPC> n ] <SPC> -= <SPC> 1 <NL>          else : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . canReorderDoubled ( [ 3 , <SPC> 1 , <SPC> 3 , <SPC> 6 ] ) <NL> <TAB> print <SPC> s . canReorderDoubled ( [ 2 , <SPC> 1 , <SPC> 2 , <SPC> 6 ] ) <NL> <TAB> print <SPC> s . canReorderDoubled ( [ 4 , <SPC> - 2 , <SPC> 2 , <SPC> - 4 ] ) <NL> <TAB> print <SPC> s . canReorderDoubled ( [ 1 , <SPC> 2 , <SPC> 4 , <SPC> 16 , <SPC> 8 , <SPC> 4 ] ) <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> repeatedNTimes ( self , <SPC> A ) : <NL> <NL> <TAB> counter <SPC> = <SPC> collections . Counter ( A ) <NL> <TAB> return <SPC> counter . most_common ( 1 ) [ 0 ] [ 0 ] <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . repeatedNTimes ( [ 1 , <SPC> 2 , <SPC> 3 , <SPC> 3 ] ) <NL> <TAB> print <SPC> s . repeatedNTimes ( [ 2 , <SPC> 1 , <SPC> 2 , <SPC> 5 , <SPC> 3 , <SPC> 2 ] ) <NL> <TAB> print <SPC> s . repeatedNTimes ( [ 5 , <SPC> 1 , <SPC> 5 , <SPC> 2 , <SPC> 5 , <SPC> 3 , <SPC> 5 , <SPC> 4 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maxWidthRamp ( self , <SPC> A ) : <NL> <TAB> ans <SPC> = <SPC> 0 <NL> <TAB> m <SPC> = <SPC> float ( "inf" ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> sorted ( range ( len ( A ) ) , <SPC> key = A . __getitem__ ) : <NL>          ans <SPC> = <SPC> max ( ans , <SPC> i <SPC> - <SPC> m ) <NL>          m <SPC> = <SPC> min ( m , <SPC> i ) <NL> <TAB> return <SPC> ans <NL> <NL> <NL> if <SPC> __name__ <SPC> == <SPC> "__main__" : <NL> <TAB> s <SPC> = <SPC> Solution ( ) <NL> <TAB> print <SPC> s . maxWidthRamp ( [ 6 , <SPC> 0 , <SPC> 8 , <SPC> 2 , <SPC> 1 , <SPC> 5 ] ) <NL> <TAB> print <SPC> s . maxWidthRamp ( [ 9 , <SPC> 8 , <SPC> 1 , <SPC> 0 , <SPC> 1 , <SPC> 9 , <SPC> 4 , <SPC> 0 , <SPC> 4 , <SPC> 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> kClosest ( self , <SPC> points , <SPC> K ) : <NL> <NL> <TAB> return <SPC> heapq . nsmallest ( K , <SPC> points , <SPC> key = lambda <SPC> x : <SPC> x [ 0 ] <SPC> ** <SPC> 2 <SPC> + <SPC> x [ 1 ] <SPC> ** <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> sortedSquares ( self , <SPC> A ) : <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <TAB> while <SPC> pos <SPC> < <SPC> len ( A ) <SPC> and <SPC> A [ pos ] <SPC> < <SPC> 0 : <NL>          pos <SPC> += <SPC> 1 <NL> <NL> <TAB> npos <SPC> = <SPC> pos <SPC> - <SPC> 1 <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> pos <SPC> < <SPC> len ( A ) <SPC> and <SPC> npos <SPC> >= <SPC> 0 : <NL>          if <SPC> A [ npos ] <SPC> ** <SPC> 2 <SPC> < <SPC> A [ pos ] <SPC> ** <SPC> 2 : <NL>              res . append ( A [ npos ] <SPC> ** <SPC> 2 ) <NL>              npos <SPC> -= <SPC> 1 <NL>          else : <NL>              res . append ( A [ pos ] <SPC> ** <SPC> 2 ) <NL>              pos <SPC> += <SPC> 1 <NL> <TAB> while <SPC> npos <SPC> >= <SPC> 0 : <NL>          res . append ( A [ npos ] <SPC> ** <SPC> 2 ) <NL>          npos <SPC> -= <SPC> 1 <NL> <TAB> while <SPC> pos <SPC> < <SPC> len ( A ) : <NL>          res . append ( A [ pos ] <SPC> ** <SPC> 2 ) <NL>          pos <SPC> += <SPC> 1 <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> findJudge ( self , <SPC> N : <SPC> int , <SPC> trust : <SPC> List [ List [ int ] ] ) <SPC> -> <SPC> int : <NL> <TAB> if <SPC> N <SPC> == <SPC> 1 : <NL>          return <SPC> 1 <NL> <TAB> d1 <SPC> = <SPC> { } <NL> <TAB> d2 <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> trust : <NL>          if <SPC> j <SPC> in <SPC> d1 : <NL>              d1 [ j ] <SPC> += <SPC> 1 <NL>          else : <NL>              d1 [ j ] <SPC> = <SPC> 1 <NL>          if <SPC> i <SPC> in <SPC> d2 : <NL>              d2 [ i ] <SPC> += <SPC> 1 <NL>          else : <NL>              d2 [ i ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> d1 . items ( ) : <NL>          if <SPC> j <SPC> == <SPC> N <SPC> - <SPC> 1 : <NL>              if <SPC> i <SPC> not <SPC> in <SPC> d2 : <NL>                  return <SPC> i <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> updateMatrix ( self , <SPC> matrix ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ i ] ) ) : <NL>              if <SPC> not <SPC> matrix [ i ] [ j ] : <NL>                  continue <NL>              matrix [ i ] [ j ] <SPC> = <SPC> float ( "inf" ) <NL>              if <SPC> i <SPC> > <SPC> 0 : <NL>                  matrix [ i ] [ j ] <SPC> = <SPC> min ( matrix [ i ] [ j ] , <SPC> matrix [ i <SPC> - <SPC> 1 ] [ j ] <SPC> + <SPC> 1 ) <NL>              if <SPC> j <SPC> > <SPC> 0 : <NL>                  matrix [ i ] [ j ] <SPC> = <SPC> min ( matrix [ i ] [ j ] , <SPC> matrix [ i ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( matrix ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( matrix [ i ] ) ) ) : <NL>              if <SPC> not <SPC> matrix [ i ] [ j ] : <NL>                  continue <NL>              if <SPC> i <SPC> < <SPC> len ( matrix ) <SPC> - <SPC> 1 : <NL>                  matrix [ i ] [ j ] <SPC> = <SPC> min ( matrix [ i ] [ j ] , <SPC> matrix [ i <SPC> + <SPC> 1 ] [ j ] <SPC> + <SPC> 1 ) <NL>              if <SPC> j <SPC> < <SPC> len ( matrix [ i ] ) <SPC> - <SPC> 1 : <NL>                  matrix [ i ] [ j ] <SPC> = <SPC> min ( matrix [ i ] [ j ] , <SPC> matrix [ i ] [ j <SPC> + <SPC> 1 ] <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> matrix <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> updateMatrix ( self , <SPC> matrix ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ float ( "inf" ) ] <SPC> * <SPC> len ( matrix [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( matrix ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ i ] ) ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> 0 : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> 0 <NL>              else : <NL>                  if <SPC> i <SPC> > <SPC> 0 : <NL>                      dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> dp [ i <SPC> - <SPC> 1 ] [ j ] <SPC> + <SPC> 1 ) <NL>                  if <SPC> j <SPC> > <SPC> 0 : <NL>                      dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> dp [ i ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( matrix ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( matrix [ i ] ) ) ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> 0 : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> 0 <NL>              else : <NL>                  if <SPC> i <SPC> < <SPC> len ( matrix ) <SPC> - <SPC> 1 : <NL>                      dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> dp [ i <SPC> + <SPC> 1 ] [ j ] <SPC> + <SPC> 1 ) <NL>                  if <SPC> j <SPC> < <SPC> len ( matrix [ i ] ) <SPC> - <SPC> 1 : <NL>                      dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> dp [ i ] [ j <SPC> + <SPC> 1 ] <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> dp <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> updateMatrix ( self , <SPC> matrix ) : <NL> <NL> <TAB> queue <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> 0 : <NL>                  queue . append ( ( i , <SPC> j ) ) <NL>              else : <NL>                  matrix [ i ] [ j ] <SPC> = <SPC> float ( "inf" ) <NL> <NL> <TAB> dirs <SPC> = <SPC> [ ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) ] <NL> <TAB> while <SPC> queue : <NL>          cell <SPC> = <SPC> queue . popleft ( ) <NL>          for <SPC> dir <SPC> in <SPC> dirs : <NL>              i , <SPC> j <SPC> = <SPC> cell [ 0 ] <SPC> + <SPC> dir [ 0 ] , <SPC> cell [ 1 ] <SPC> + <SPC> dir [ 1 ] <NL>              if <SPC> not <SPC> ( <NL>                  0 <SPC> <= <SPC> i <SPC> < <SPC> len ( matrix ) <NL>                  and <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> len ( matrix [ 0 ] ) <NL>                  and <SPC> matrix [ i ] [ j ] <SPC> > <SPC> matrix [ cell [ 0 ] ] [ cell [ 1 ] ] <SPC> + <SPC> 1 <NL>              ) : <NL>                  continue <NL>              queue . append ( ( i , <SPC> j ) ) <NL>              matrix [ i ] [ j ] <SPC> = <SPC> matrix [ cell [ 0 ] ] [ cell [ 1 ] ] <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> matrix <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isOneBitCharacter ( self , <SPC> bits ) : <NL> <NL> <TAB> parity <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( bits ) <SPC> - <SPC> 1 ) ) : <NL>          if <SPC> bits [ i ] <SPC> == <SPC> 0 : <NL>              break <NL>          parity <SPC> ^= <SPC> bits [ i ] <NL> <TAB> return <SPC> parity <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> find132pattern ( self , <SPC> nums ) : <NL> <NL> <TAB> ak <SPC> = <SPC> float ( "-inf" ) <NL> <TAB> st <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( nums ) ) ) : <NL>          if <SPC> nums [ i ] <SPC> < <SPC> ak : <NL>              return <SPC> True <NL>          else : <NL>              while <SPC> st <SPC> and <SPC> nums [ i ] <SPC> > <SPC> st [ - 1 ] : <NL>                  ak <SPC> = <SPC> st . pop ( ) <NL>          st . append ( nums [ i ] ) <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minSteps ( self , <SPC> n ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> p <SPC> = <SPC> 2 <NL> <NL> <TAB> while <SPC> p <SPC> ** <SPC> 2 <SPC> <= <SPC> n : <NL>          while <SPC> n <SPC> % <SPC> p <SPC> == <SPC> 0 : <NL>              result <SPC> += <SPC> p <NL>              n <SPC> //= <SPC> p <NL>          p <SPC> += <SPC> 1 <NL> <TAB> if <SPC> n <SPC> > <SPC> 1 : <NL>          result <SPC> += <SPC> n <NL> <TAB> return <SPC> result <NL> <NL> <NL> from <SPC> operator <SPC> import <SPC> add , <SPC> sub , <SPC> mul , <SPC> truediv <NL> from <SPC> fractions <SPC> import <SPC> Fraction <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> judgePoint24 ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> len ( nums ) <SPC> == <SPC> 1 : <NL>          return <SPC> abs ( nums [ 0 ] <SPC> - <SPC> 24 ) <SPC> < <SPC> 1e-6 <NL> <TAB> ops <SPC> = <SPC> [ add , <SPC> sub , <SPC> mul , <SPC> truediv ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>              if <SPC> i <SPC> == <SPC> j : <NL>                  continue <NL>              next_nums <SPC> = <SPC> [ nums [ k ] <SPC> for <SPC> k <SPC> in <SPC> xrange ( len ( nums ) ) <SPC> if <SPC> i <SPC> != <SPC> k <SPC> != <SPC> j ] <NL>              for <SPC> op <SPC> in <SPC> ops : <NL>                  if <SPC> ( ( op <SPC> is <SPC> add <SPC> or <SPC> op <SPC> is <SPC> mul ) <SPC> and <SPC> j <SPC> > <SPC> i ) <SPC> or <SPC> ( <NL>                      op <SPC> == <SPC> truediv <SPC> and <SPC> nums [ j ] <SPC> == <SPC> 0 <NL>                  ) : <NL>                      continue <NL>                  next_nums . append ( op ( nums [ i ] , <SPC> nums [ j ] ) ) <NL>                  if <SPC> self . judgePoint24 ( next_nums ) : <NL>                      return <SPC> True <NL>                  next_nums . pop ( ) <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> judgePoint24 ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> dfs ( nums ) : <NL>          if <SPC> len ( nums ) <SPC> == <SPC> 1 : <NL>              return <SPC> nums [ 0 ] <SPC> == <SPC> 24 <NL>          ops <SPC> = <SPC> [ add , <SPC> sub , <SPC> mul , <SPC> truediv ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>                  if <SPC> i <SPC> == <SPC> j : <NL>                      continue <NL>                  next_nums <SPC> = <SPC> [ nums [ k ] <SPC> for <SPC> k <SPC> in <SPC> xrange ( len ( nums ) ) <SPC> if <SPC> i <SPC> != <SPC> k <SPC> != <SPC> j ] <NL>                  for <SPC> op <SPC> in <SPC> ops : <NL>                      if <SPC> ( ( op <SPC> is <SPC> add <SPC> or <SPC> op <SPC> is <SPC> mul ) <SPC> and <SPC> j <SPC> > <SPC> i ) <SPC> or <SPC> ( <NL>                          op <SPC> == <SPC> truediv <SPC> and <SPC> nums [ j ] <SPC> == <SPC> 0 <NL>                      ) : <NL>                          continue <NL>                      next_nums . append ( op ( nums [ i ] , <SPC> nums [ j ] ) ) <NL>                      if <SPC> dfs ( next_nums ) : <NL>                          return <SPC> True <NL>                      next_nums . pop ( ) <NL>          return <SPC> False <NL> <NL> <TAB> return <SPC> dfs ( map ( Fraction , <SPC> nums ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> threeSumClosest ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> result , <SPC> min_diff <SPC> = <SPC> 0 , <SPC> float ( "inf" ) <NL> <TAB> nums . sort ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 2 , <SPC> len ( nums ) ) ) : <NL>          if <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( nums ) <SPC> and <SPC> nums [ i ] <SPC> == <SPC> nums [ i <SPC> + <SPC> 1 ] : <NL>              continue <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> i <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> < <SPC> right : <NL>              total <SPC> = <SPC> nums [ left ] <SPC> + <SPC> nums [ right ] <SPC> + <SPC> nums [ i ] <NL>              if <SPC> total <SPC> < <SPC> target : <NL>                  left <SPC> += <SPC> 1 <NL>              elif <SPC> total <SPC> > <SPC> target : <NL>                  right <SPC> -= <SPC> 1 <NL>              else : <NL>                  return <SPC> target <NL>              if <SPC> abs ( total <SPC> - <SPC> target ) <SPC> < <SPC> min_diff : <NL>                  min_diff <SPC> = <SPC> abs ( total <SPC> - <SPC> target ) <NL>                  result <SPC> = <SPC> total <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> threeSumSmaller ( self , <SPC> nums , <SPC> target ) : <NL> <TAB> nums . sort ( ) <NL> <TAB> n <SPC> = <SPC> len ( nums ) <NL> <NL> <TAB> count , <SPC> k <SPC> = <SPC> 0 , <SPC> 2 <NL> <TAB> while <SPC> k <SPC> < <SPC> n : <NL>          i , <SPC> j <SPC> = <SPC> 0 , <SPC> k <SPC> - <SPC> 1 <NL>          while <SPC> i <SPC> < <SPC> j : <NL>              if <SPC> nums [ i ] <SPC> + <SPC> nums [ j ] <SPC> + <SPC> nums [ k ] <SPC> >= <SPC> target : <NL>                  j <SPC> -= <SPC> 1 <NL>              else : <NL>                  count <SPC> += <SPC> j <SPC> - <SPC> i <NL>                  i <SPC> += <SPC> 1 <NL>          k <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> count <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> threeSumMulti ( self , <SPC> A , <SPC> target ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( A ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> itertools . combinations_with_replacement ( count , <SPC> 2 ) : <NL>          k <SPC> = <SPC> target <SPC> - <SPC> i <SPC> - <SPC> j <NL>          if <SPC> i <SPC> == <SPC> j <SPC> == <SPC> k : <NL>              result <SPC> += <SPC> count [ i ] <SPC> * <SPC> ( count [ i ] <SPC> - <SPC> 1 ) <SPC> * <SPC> ( count [ i ] <SPC> - <SPC> 2 ) <SPC> // <SPC> 6 <NL>          elif <SPC> i <SPC> == <SPC> j <SPC> != <SPC> k : <NL>              result <SPC> += <SPC> count [ i ] <SPC> * <SPC> ( count [ i ] <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 <SPC> * <SPC> count [ k ] <NL>          elif <SPC> max ( i , <SPC> j ) <SPC> < <SPC> k : <NL>              result <SPC> += <SPC> count [ i ] <SPC> * <SPC> count [ j ] <SPC> * <SPC> count [ k ] <NL> <TAB> return <SPC> result <SPC> % <SPC> ( 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> threeSum ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> nums . sort ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 2 , <SPC> len ( nums ) ) ) : <NL>          if <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( nums ) <SPC> and <SPC> nums [ i ] <SPC> == <SPC> nums [ i <SPC> + <SPC> 1 ] : <NL>              continue <NL>          target <SPC> = <SPC> - nums [ i ] <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> i <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> < <SPC> right : <NL>              if <SPC> nums [ left ] <SPC> + <SPC> nums [ right ] <SPC> < <SPC> target : <NL>                  left <SPC> += <SPC> 1 <NL>              elif <SPC> nums [ left ] <SPC> + <SPC> nums [ right ] <SPC> > <SPC> target : <NL>                  right <SPC> -= <SPC> 1 <NL>              else : <NL>                  result . append ( [ nums [ left ] , <SPC> nums [ right ] , <SPC> nums [ i ] ] ) <NL>                  left <SPC> += <SPC> 1 <NL>                  right <SPC> -= <SPC> 1 <NL>                  while <SPC> left <SPC> < <SPC> right <SPC> and <SPC> nums [ left ] <SPC> == <SPC> nums [ left <SPC> - <SPC> 1 ] : <NL>                      left <SPC> += <SPC> 1 <NL>                  while <SPC> left <SPC> < <SPC> right <SPC> and <SPC> nums [ right ] <SPC> == <SPC> nums [ right <SPC> + <SPC> 1 ] : <NL>                      right <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> threeSum ( self , <SPC> nums ) : <NL> <NL> <TAB> nums , <SPC> result , <SPC> i <SPC> = <SPC> sorted ( nums ) , <SPC> [ ] , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( nums ) <SPC> - <SPC> 2 : <NL>          if <SPC> i <SPC> == <SPC> 0 <SPC> or <SPC> nums [ i ] <SPC> != <SPC> nums [ i <SPC> - <SPC> 1 ] : <NL>              j , <SPC> k <SPC> = <SPC> i <SPC> + <SPC> 1 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>              while <SPC> j <SPC> < <SPC> k : <NL>                  if <SPC> nums [ i ] <SPC> + <SPC> nums [ j ] <SPC> + <SPC> nums [ k ] <SPC> < <SPC> 0 : <NL>                      j <SPC> += <SPC> 1 <NL>                  elif <SPC> nums [ i ] <SPC> + <SPC> nums [ j ] <SPC> + <SPC> nums [ k ] <SPC> > <SPC> 0 : <NL>                      k <SPC> -= <SPC> 1 <NL>                  else : <NL>                      result . append ( [ nums [ i ] , <SPC> nums [ j ] , <SPC> nums [ k ] ] ) <NL>                      j , <SPC> k <SPC> = <SPC> j <SPC> + <SPC> 1 , <SPC> k <SPC> - <SPC> 1 <NL>                      while <SPC> j <SPC> < <SPC> k <SPC> and <SPC> nums [ j ] <SPC> == <SPC> nums [ j <SPC> - <SPC> 1 ] : <NL>                          j <SPC> += <SPC> 1 <NL>                      while <SPC> j <SPC> < <SPC> k <SPC> and <SPC> nums [ k ] <SPC> == <SPC> nums [ k <SPC> + <SPC> 1 ] : <NL>                          k <SPC> -= <SPC> 1 <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxA ( self , <SPC> N ) : <NL> <NL> <TAB> if <SPC> N <SPC> < <SPC> 7 : <NL>          return <SPC> N <NL> <TAB> if <SPC> N <SPC> == <SPC> 10 : <NL>          return <SPC> 20 <NL> <NL> <TAB> n <SPC> = <SPC> N <SPC> // <SPC> 5 <SPC> + <SPC> 1 <NL> <NL> <TAB> n3 <SPC> = <SPC> 5 <SPC> * <SPC> n <SPC> - <SPC> N <SPC> - <SPC> 1 <NL> <TAB> n4 <SPC> = <SPC> n <SPC> - <SPC> n3 <NL> <TAB> return <SPC> 3 <SPC> ** <SPC> n3 <SPC> * <SPC> 4 <SPC> ** <SPC> n4 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxA ( self , <SPC> N ) : <NL> <NL> <TAB> if <SPC> N <SPC> < <SPC> 7 : <NL>          return <SPC> N <NL> <TAB> dp <SPC> = <SPC> range ( N <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 7 , <SPC> N <SPC> + <SPC> 1 ) : <NL>          dp [ i <SPC> % <SPC> 6 ] <SPC> = <SPC> max ( dp [ ( i <SPC> - <SPC> 4 ) <SPC> % <SPC> 6 ] <SPC> * <SPC> 3 , <SPC> dp [ ( i <SPC> - <SPC> 5 ) <SPC> % <SPC> 6 ] <SPC> * <SPC> 4 ) <NL> <TAB> return <SPC> dp [ N <SPC> % <SPC> 6 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fourSumCount ( self , <SPC> A , <SPC> B , <SPC> C , <SPC> D ) : <NL> <NL> <TAB> A_B_sum <SPC> = <SPC> collections . Counter ( a <SPC> + <SPC> b <SPC> for <SPC> a <SPC> in <SPC> A <SPC> for <SPC> b <SPC> in <SPC> B ) <NL> <TAB> return <SPC> sum ( A_B_sum [ - c <SPC> - <SPC> d ] <SPC> for <SPC> c <SPC> in <SPC> C <SPC> for <SPC> d <SPC> in <SPC> D ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fourSum ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) <SPC> - <SPC> 3 ) : <NL>          if <SPC> i <SPC> and <SPC> nums [ i ] <SPC> == <SPC> nums [ i <SPC> - <SPC> 1 ] : <NL>              continue <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( nums ) <SPC> - <SPC> 2 ) : <NL>              if <SPC> j <SPC> != <SPC> i <SPC> + <SPC> 1 <SPC> and <SPC> nums [ j ] <SPC> == <SPC> nums [ j <SPC> - <SPC> 1 ] : <NL>                  continue <NL>              total <SPC> = <SPC> target <SPC> - <SPC> nums [ i ] <SPC> - <SPC> nums [ j ] <NL>              left , <SPC> right <SPC> = <SPC> j <SPC> + <SPC> 1 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>              while <SPC> left <SPC> < <SPC> right : <NL>                  if <SPC> nums [ left ] <SPC> + <SPC> nums [ right ] <SPC> == <SPC> total : <NL>                      result . append ( [ nums [ i ] , <SPC> nums [ j ] , <SPC> nums [ left ] , <SPC> nums [ right ] ] ) <NL>                      right <SPC> -= <SPC> 1 <NL>                      left <SPC> += <SPC> 1 <NL>                      while <SPC> left <SPC> < <SPC> right <SPC> and <SPC> nums [ left ] <SPC> == <SPC> nums [ left <SPC> - <SPC> 1 ] : <NL>                          left <SPC> += <SPC> 1 <NL>                      while <SPC> left <SPC> < <SPC> right <SPC> and <SPC> nums [ right ] <SPC> == <SPC> nums [ right <SPC> + <SPC> 1 ] : <NL>                          right <SPC> -= <SPC> 1 <NL>                  elif <SPC> nums [ left ] <SPC> + <SPC> nums [ right ] <SPC> > <SPC> total : <NL>                      right <SPC> -= <SPC> 1 <NL>                  else : <NL>                      left <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> fourSum ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> nums , <SPC> result , <SPC> lookup <SPC> = <SPC> sorted ( nums ) , <SPC> [ ] , <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( nums ) ) : <NL>              is_duplicated <SPC> = <SPC> False <NL>              for <SPC> [ x , <SPC> y ] <SPC> in <SPC> lookup [ nums [ i ] <SPC> + <SPC> nums [ j ] ] : <NL>                  if <SPC> nums [ x ] <SPC> == <SPC> nums [ i ] : <NL>                      is_duplicated <SPC> = <SPC> True <NL>                      break <NL>              if <SPC> not <SPC> is_duplicated : <NL>                  lookup [ nums [ i ] <SPC> + <SPC> nums [ j ] ] . append ( [ i , <SPC> j ] ) <NL> <TAB> ans <SPC> = <SPC> { } <NL> <TAB> for <SPC> c <SPC> in <SPC> xrange ( 2 , <SPC> len ( nums ) ) : <NL>          for <SPC> d <SPC> in <SPC> xrange ( c <SPC> + <SPC> 1 , <SPC> len ( nums ) ) : <NL>              if <SPC> target <SPC> - <SPC> nums [ c ] <SPC> - <SPC> nums [ d ] <SPC> in <SPC> lookup : <NL>                  for <SPC> [ a , <SPC> b ] <SPC> in <SPC> lookup [ target <SPC> - <SPC> nums [ c ] <SPC> - <SPC> nums [ d ] ] : <NL>                      if <SPC> b <SPC> < <SPC> c : <NL>                          quad <SPC> = <SPC> [ nums [ a ] , <SPC> nums [ b ] , <SPC> nums [ c ] , <SPC> nums [ d ] ] <NL>                          quad_hash <SPC> = <SPC> " " . join ( str ( quad ) ) <NL>                          if <SPC> quad_hash <SPC> not <SPC> in <SPC> ans : <NL>                              ans [ quad_hash ] <SPC> = <SPC> True <NL>                              result . append ( quad ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> fourSum ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> nums , <SPC> result , <SPC> lookup <SPC> = <SPC> sorted ( nums ) , <SPC> [ ] , <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( nums ) ) : <NL>              lookup [ nums [ i ] <SPC> + <SPC> nums [ j ] ] . append ( [ i , <SPC> j ] ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> lookup . keys ( ) : <NL>          if <SPC> target <SPC> - <SPC> i <SPC> in <SPC> lookup : <NL>              for <SPC> x <SPC> in <SPC> lookup [ i ] : <NL>                  for <SPC> y <SPC> in <SPC> lookup [ target <SPC> - <SPC> i ] : <NL>                      [ a , <SPC> b ] , <SPC> [ c , <SPC> d ] <SPC> = <SPC> x , <SPC> y <NL>                      if <SPC> a <SPC> is <SPC> not <SPC> c <SPC> and <SPC> a <SPC> is <SPC> not <SPC> d <SPC> and <SPC> b <SPC> is <SPC> not <SPC> c <SPC> and <SPC> b <SPC> is <SPC> not <SPC> d : <NL>                          quad <SPC> = <SPC> sorted ( [ nums [ a ] , <SPC> nums [ b ] , <SPC> nums [ c ] , <SPC> nums [ d ] ] ) <NL>                          if <SPC> quad <SPC> not <SPC> in <SPC> result : <NL>                              result . append ( quad ) <NL> <TAB> return <SPC> sorted ( result ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . set <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> get_id ( self ) : <NL> <TAB> self . set . append ( len ( self . set ) ) <NL> <TAB> return <SPC> len ( self . set ) <SPC> - <SPC> 1 <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> != <SPC> y_root : <NL>          self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> accountsMerge ( self , <SPC> accounts ) : <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( ) <NL> <TAB> email_to_name <SPC> = <SPC> { } <NL> <TAB> email_to_id <SPC> = <SPC> { } <NL> <TAB> for <SPC> account <SPC> in <SPC> accounts : <NL>          name <SPC> = <SPC> account [ 0 ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( account ) ) : <NL>              if <SPC> account [ i ] <SPC> not <SPC> in <SPC> email_to_id : <NL>                  email_to_name [ account [ i ] ] <SPC> = <SPC> name <NL>                  email_to_id [ account [ i ] ] <SPC> = <SPC> union_find . get_id ( ) <NL>              union_find . union_set ( <NL>                  email_to_id [ account [ 1 ] ] , <SPC> email_to_id [ account [ i ] ] ) <NL> <NL> <TAB> result <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> email <SPC> in <SPC> email_to_name . keys ( ) : <NL>          result [ union_find . find_set ( email_to_id [ email ] ) ] . append ( email ) <NL> <TAB> for <SPC> emails <SPC> in <SPC> result . values ( ) : <NL>          emails . sort ( ) <NL> <TAB> return <SPC> [ [ email_to_name [ emails [ 0 ] ] ] <SPC> + <SPC> emails <SPC> for <SPC> emails <SPC> in <SPC> result . values ( ) ] <NL> <NL> <NL> class <SPC> TrieNode ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . is_string <SPC> = <SPC> False <NL> <TAB> self . leaves <SPC> = <SPC> { } <NL> <NL> <NL> class <SPC> WordDictionary ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . root <SPC> = <SPC> TrieNode ( ) <NL> <NL> <TAB> def <SPC> addWord ( self , <SPC> word ) : <NL> <TAB> curr <SPC> = <SPC> self . root <NL> <TAB> for <SPC> c <SPC> in <SPC> word : <NL>          if <SPC> c <SPC> not <SPC> in <SPC> curr . leaves : <NL>              curr . leaves [ c ] <SPC> = <SPC> TrieNode ( ) <NL>          curr <SPC> = <SPC> curr . leaves [ c ] <NL> <TAB> curr . is_string <SPC> = <SPC> True <NL> <NL> <TAB> def <SPC> search ( self , <SPC> word ) : <NL> <TAB> return <SPC> self . searchHelper ( word , <SPC> 0 , <SPC> self . root ) <NL> <NL> <TAB> def <SPC> searchHelper ( self , <SPC> word , <SPC> start , <SPC> curr ) : <NL> <TAB> if <SPC> start <SPC> == <SPC> len ( word ) : <NL>          return <SPC> curr . is_string <NL> <TAB> if <SPC> word [ start ] <SPC> in <SPC> curr . leaves : <NL>          return <SPC> self . searchHelper ( word , <SPC> start <SPC> + <SPC> 1 , <SPC> curr . leaves [ word [ start ] ] ) <NL> <TAB> elif <SPC> word [ start ] <SPC> == <SPC> "." : <NL>          for <SPC> c <SPC> in <SPC> curr . leaves : <NL>              if <SPC> self . searchHelper ( word , <SPC> start <SPC> + <SPC> 1 , <SPC> curr . leaves [ c ] ) : <NL>                  return <SPC> True <NL> <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> addBinary ( self , <SPC> a , <SPC> b ) : <NL> <TAB> result , <SPC> carry , <SPC> val <SPC> = <SPC> "" , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( max ( len ( a ) , <SPC> len ( b ) ) ) : <NL>          val <SPC> = <SPC> carry <NL>          if <SPC> i <SPC> < <SPC> len ( a ) : <NL>              val <SPC> += <SPC> int ( a [ - ( i <SPC> + <SPC> 1 ) ] ) <NL>          if <SPC> i <SPC> < <SPC> len ( b ) : <NL>              val <SPC> += <SPC> int ( b [ - ( i <SPC> + <SPC> 1 ) ] ) <NL>          carry , <SPC> val <SPC> = <SPC> divmod ( val , <SPC> 2 ) <NL>          result <SPC> += <SPC> str ( val ) <NL> <TAB> if <SPC> carry : <NL>          result <SPC> += <SPC> str ( carry ) <NL> <TAB> return <SPC> result [ : : - 1 ] <NL> <NL> <NL> from <SPC> itertools <SPC> import <SPC> izip_longest <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> addBinary ( self , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> result <SPC> = <SPC> "" <NL> <TAB> carry <SPC> = <SPC> 0 <NL> <TAB> for <SPC> x , <SPC> y <SPC> in <SPC> izip_longest ( reversed ( a ) , <SPC> reversed ( b ) , <SPC> fillvalue = "0" ) : <NL>          carry , <SPC> remainder <SPC> = <SPC> divmod ( int ( x ) <SPC> + <SPC> int ( y ) <SPC> + <SPC> carry , <SPC> 2 ) <NL>          result <SPC> += <SPC> str ( remainder ) <NL> <NL> <TAB> if <SPC> carry : <NL>          result <SPC> += <SPC> str ( carry ) <NL> <NL> <TAB> return <SPC> result [ : : - 1 ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> functools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> addBoldTag ( self , <SPC> s , <SPC> dict ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( s ) <NL> <TAB> for <SPC> d <SPC> in <SPC> dict : <NL>          pos <SPC> = <SPC> s . find ( d ) <NL>          while <SPC> pos <SPC> != <SPC> - 1 : <NL>              lookup [ pos : <SPC> pos <SPC> + <SPC> len ( d ) ] <SPC> = <SPC> [ 1 ] <SPC> * <SPC> len ( d ) <NL>              pos <SPC> = <SPC> s . find ( d , <SPC> pos <SPC> + <SPC> 1 ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> lookup [ i ] <SPC> and <SPC> ( i <SPC> == <SPC> 0 <SPC> or <SPC> not <SPC> lookup [ i <SPC> - <SPC> 1 ] ) : <NL>              result . append ( "<b>" ) <NL>          result . append ( s [ i ] ) <NL>          if <SPC> lookup [ i ] <SPC> and <SPC> ( i <SPC> == <SPC> len ( s ) <SPC> - <SPC> 1 <SPC> or <SPC> not <SPC> lookup [ i <SPC> + <SPC> 1 ] ) : <NL>              result . append ( "</b>" ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> addBoldTag ( self , <SPC> s , <SPC> words ) : <NL> <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> trie <SPC> = <SPC> _trie ( ) <NL> <TAB> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          functools . reduce ( dict . __getitem__ , <SPC> word , <SPC> trie ) . setdefault ( "_end" ) <NL> <NL> <TAB> lookup <SPC> = <SPC> [ False ] <SPC> * <SPC> len ( s ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          curr <SPC> = <SPC> trie <NL>          k <SPC> = <SPC> - 1 <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> len ( s ) ) : <NL>              if <SPC> s [ j ] <SPC> not <SPC> in <SPC> curr : <NL>                  break <NL>              curr <SPC> = <SPC> curr [ s [ j ] ] <NL>              if <SPC> "_end" <SPC> in <SPC> curr : <NL>                  k <SPC> = <SPC> j <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> k <SPC> + <SPC> 1 ) : <NL>              lookup [ j ] <SPC> = <SPC> True <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> lookup [ i ] <SPC> and <SPC> ( i <SPC> == <SPC> 0 <SPC> or <SPC> not <SPC> lookup [ i <SPC> - <SPC> 1 ] ) : <NL>              result . append ( "<b>" ) <NL>          result . append ( s [ i ] ) <NL>          if <SPC> lookup [ i ] <SPC> and <SPC> ( i <SPC> == <SPC> len ( s ) <SPC> - <SPC> 1 <SPC> or <SPC> not <SPC> lookup [ i <SPC> + <SPC> 1 ] ) : <NL>              result . append ( "</b>" ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> addDigits ( self , <SPC> num ) : <NL> <TAB> return <SPC> ( num <SPC> - <SPC> 1 ) <SPC> % <SPC> 9 <SPC> + <SPC> 1 <SPC> if <SPC> num <SPC> > <SPC> 0 <SPC> else <SPC> 0 <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> addOneRow ( self , <SPC> root , <SPC> v , <SPC> d ) : <NL> <NL> <TAB> if <SPC> d <SPC> in <SPC> ( 0 , <SPC> 1 ) : <NL>          node <SPC> = <SPC> TreeNode ( v ) <NL>          if <SPC> d <SPC> == <SPC> 1 : <NL>              node . left <SPC> = <SPC> root <NL>          else : <NL>              node . right <SPC> = <SPC> root <NL>          return <SPC> node <NL> <TAB> if <SPC> root <SPC> and <SPC> d <SPC> >= <SPC> 2 : <NL>          root . left <SPC> = <SPC> self . addOneRow ( root . left , <SPC> v , <SPC> d <SPC> - <SPC> 1 <SPC> if <SPC> d <SPC> > <SPC> 2 <SPC> else <SPC> 1 ) <NL>          root . right <SPC> = <SPC> self . addOneRow ( root . right , <SPC> v , <SPC> d <SPC> - <SPC> 1 <SPC> if <SPC> d <SPC> > <SPC> 2 <SPC> else <SPC> 0 ) <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> addStrings ( self , <SPC> num1 , <SPC> num2 ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i , <SPC> j , <SPC> carry <SPC> = <SPC> len ( num1 ) <SPC> - <SPC> 1 , <SPC> len ( num2 ) <SPC> - <SPC> 1 , <SPC> 0 <NL> <NL> <TAB> while <SPC> i <SPC> >= <SPC> 0 <SPC> or <SPC> j <SPC> >= <SPC> 0 <SPC> or <SPC> carry : <NL>          if <SPC> i <SPC> >= <SPC> 0 : <NL>              carry <SPC> += <SPC> ord ( num1 [ i ] ) <SPC> - <SPC> ord ( "0" ) <NL>              i <SPC> -= <SPC> 1 <NL>          if <SPC> j <SPC> >= <SPC> 0 : <NL>              carry <SPC> += <SPC> ord ( num2 [ j ] ) <SPC> - <SPC> ord ( "0" ) <NL>              j <SPC> -= <SPC> 1 <NL>          result . append ( str ( carry <SPC> % <SPC> 10 ) ) <NL>          carry <SPC> /= <SPC> 10 <NL> <TAB> result . reverse ( ) <NL> <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <TAB> def <SPC> addStrings2 ( self , <SPC> num1 , <SPC> num2 ) : <NL> <NL> <TAB> length <SPC> = <SPC> max ( len ( num1 ) , <SPC> len ( num2 ) ) <NL> <TAB> num1 <SPC> = <SPC> num1 . zfill ( length ) [ : : - 1 ] <NL> <TAB> num2 <SPC> = <SPC> num2 . zfill ( length ) [ : : - 1 ] <NL> <TAB> res , <SPC> plus <SPC> = <SPC> "" , <SPC> 0 <NL> <TAB> for <SPC> index , <SPC> num <SPC> in <SPC> enumerate ( num1 ) : <NL>          tmp <SPC> = <SPC> str ( int ( num ) <SPC> + <SPC> int ( num2 [ index ] ) <SPC> + <SPC> plus ) <NL>          res <SPC> += <SPC> tmp [ - 1 ] <NL>          if <SPC> int ( tmp ) <SPC> > <SPC> 9 : <NL>              plus <SPC> = <SPC> 1 <NL>          else : <NL>              plus <SPC> = <SPC> 0 <NL> <TAB> if <SPC> plus : <NL>          res <SPC> += <SPC> "1" <NL> <TAB> return <SPC> res [ : : - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> addToArrayForm ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> A . reverse ( ) <NL> <TAB> carry , <SPC> i <SPC> = <SPC> K , <SPC> 0 <NL> <TAB> A [ i ] <SPC> += <SPC> carry <NL> <TAB> carry , <SPC> A [ i ] <SPC> = <SPC> divmod ( A [ i ] , <SPC> 10 ) <NL> <TAB> while <SPC> carry : <NL>          i <SPC> += <SPC> 1 <NL>          if <SPC> i <SPC> < <SPC> len ( A ) : <NL>              A [ i ] <SPC> += <SPC> carry <NL>          else : <NL>              A . append ( carry ) <NL>          carry , <SPC> A [ i ] <SPC> = <SPC> divmod ( A [ i ] , <SPC> 10 ) <NL> <TAB> A . reverse ( ) <NL> <TAB> return <SPC> A <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> addTwoNumbers ( self , <SPC> l1 , <SPC> l2 ) : <NL> <NL> <TAB> stk1 , <SPC> stk2 <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> while <SPC> l1 : <NL>          stk1 . append ( l1 . val ) <NL>          l1 <SPC> = <SPC> l1 . next <NL> <TAB> while <SPC> l2 : <NL>          stk2 . append ( l2 . val ) <NL>          l2 <SPC> = <SPC> l2 . next <NL> <NL> <TAB> prev , <SPC> head <SPC> = <SPC> None , <SPC> None <NL> <TAB> sum <SPC> = <SPC> 0 <NL> <TAB> while <SPC> stk1 <SPC> or <SPC> stk2 : <NL>          sum <SPC> /= <SPC> 10 <NL>          if <SPC> stk1 : <NL>              sum <SPC> += <SPC> stk1 . pop ( ) <NL>          if <SPC> stk2 : <NL>              sum <SPC> += <SPC> stk2 . pop ( ) <NL> <NL>          head <SPC> = <SPC> ListNode ( sum <SPC> % <SPC> 10 ) <NL>          head . next <SPC> = <SPC> prev <NL>          prev <SPC> = <SPC> head <NL> <NL> <TAB> if <SPC> sum <SPC> >= <SPC> 10 : <NL>          head <SPC> = <SPC> ListNode ( sum <SPC> / <SPC> 10 ) <NL>          head . next <SPC> = <SPC> prev <NL> <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> addTwoNumbers ( self , <SPC> l1 , <SPC> l2 ) : <NL> <NL> <TAB> dummy <SPC> = <SPC> ListNode ( 0 ) <NL> <TAB> current , <SPC> carry <SPC> = <SPC> dummy , <SPC> 0 <NL> <NL> <TAB> while <SPC> l1 <SPC> or <SPC> l2 : <NL>          val <SPC> = <SPC> carry <NL>          if <SPC> l1 : <NL>              val <SPC> += <SPC> l1 . val <NL>              l1 <SPC> = <SPC> l1 . next <NL>          if <SPC> l2 : <NL>              val <SPC> += <SPC> l2 . val <NL>              l2 <SPC> = <SPC> l2 . next <NL>          carry , <SPC> val <SPC> = <SPC> divmod ( val , <SPC> 10 ) <NL>          current . next <SPC> = <SPC> ListNode ( val ) <NL>          current <SPC> = <SPC> current . next <NL> <NL> <TAB> if <SPC> carry <SPC> == <SPC> 1 : <NL>          current . next <SPC> = <SPC> ListNode ( 1 ) <NL> <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> PolyNode : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x = 0 , <SPC> y = 0 , <SPC> next = None ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> addPoly ( self , <SPC> poly1 , <SPC> poly2 ) : <NL> <NL> <TAB> curr <SPC> = <SPC> dummy <SPC> = <SPC> PolyNode ( ) <NL> <TAB> while <SPC> poly1 <SPC> and <SPC> poly2 : <NL>          if <SPC> poly1 . power <SPC> > <SPC> poly2 . power : <NL>              curr . next <SPC> = <SPC> poly1 <NL>              curr <SPC> = <SPC> curr . next <NL>              poly1 <SPC> = <SPC> poly1 . next <NL>          elif <SPC> poly1 . power <SPC> < <SPC> poly2 . power : <NL>              curr . next <SPC> = <SPC> poly2 <NL>              curr <SPC> = <SPC> curr . next <NL>              poly2 <SPC> = <SPC> poly2 . next <NL>          else : <NL>              coef <SPC> = <SPC> poly1 . coefficient <SPC> + <SPC> poly2 . coefficient <NL>              if <SPC> coef : <NL>                  curr . next <SPC> = <SPC> PolyNode ( coef , <SPC> poly1 . power ) <NL>                  curr <SPC> = <SPC> curr . next <NL>              poly1 , <SPC> poly2 <SPC> = <SPC> poly1 . next , <SPC> poly2 . next <NL> <TAB> curr . next <SPC> = <SPC> poly1 <SPC> or <SPC> poly2 <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> addNegabinary ( self , <SPC> arr1 , <SPC> arr2 ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> carry <SPC> = <SPC> 0 <NL> <TAB> while <SPC> arr1 <SPC> or <SPC> arr2 <SPC> or <SPC> carry : <NL>          if <SPC> arr1 : <NL>              carry <SPC> += <SPC> arr1 . pop ( ) <NL>          if <SPC> arr2 : <NL>              carry <SPC> += <SPC> arr2 . pop ( ) <NL>          result . append ( carry <SPC> & <SPC> 1 ) <NL>          carry <SPC> = <SPC> - ( carry <SPC> >> <SPC> 1 ) <NL> <TAB> while <SPC> len ( result ) <SPC> > <SPC> 1 <SPC> and <SPC> result [ - 1 ] <SPC> == <SPC> 0 : <NL>          result . pop ( ) <NL> <TAB> result . reverse ( ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isAdditiveNumber ( self , <SPC> num ) : <NL> <NL> <TAB> def <SPC> add ( a , <SPC> b ) : <NL>          res , <SPC> carry , <SPC> val <SPC> = <SPC> "" , <SPC> 0 , <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( max ( len ( a ) , <SPC> len ( b ) ) ) : <NL>              val <SPC> = <SPC> carry <NL>              if <SPC> i <SPC> < <SPC> len ( a ) : <NL>                  val <SPC> += <SPC> int ( a [ - ( i <SPC> + <SPC> 1 ) ] ) <NL>              if <SPC> i <SPC> < <SPC> len ( b ) : <NL>                  val <SPC> += <SPC> int ( b [ - ( i <SPC> + <SPC> 1 ) ] ) <NL>              carry , <SPC> val <SPC> = <SPC> val <SPC> / <SPC> 10 , <SPC> val <SPC> % <SPC> 10 <NL>              res <SPC> += <SPC> str ( val ) <NL>          if <SPC> carry : <NL>              res <SPC> += <SPC> str ( carry ) <NL>          return <SPC> res [ : : - 1 ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( num ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( num ) ) : <NL>              s1 , <SPC> s2 <SPC> = <SPC> num [ 0 : i ] , <SPC> num [ i : j ] <NL>              if <SPC> ( len ( s1 ) <SPC> > <SPC> 1 <SPC> and <SPC> s1 [ 0 ] <SPC> == <SPC> "0" ) <SPC> or <SPC> ( len ( s2 ) <SPC> > <SPC> 1 <SPC> and <SPC> s2 [ 0 ] <SPC> == <SPC> "0" ) : <NL>                  continue <NL> <NL>              expected <SPC> = <SPC> add ( s1 , <SPC> s2 ) <NL>              cur <SPC> = <SPC> s1 <SPC> + <SPC> s2 <SPC> + <SPC> expected <NL>              while <SPC> len ( cur ) <SPC> < <SPC> len ( num ) : <NL>                  s1 , <SPC> s2 , <SPC> expected <SPC> = <SPC> s2 , <SPC> expected , <SPC> add ( s2 , <SPC> expected ) <NL>                  cur <SPC> += <SPC> expected <NL>              if <SPC> cur <SPC> == <SPC> num : <NL>                  return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> advantageCount ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> sortedA <SPC> = <SPC> sorted ( A ) <NL> <TAB> sortedB <SPC> = <SPC> sorted ( B ) <NL> <NL> <TAB> candidates <SPC> = <SPC> { b : <SPC> [ ] <SPC> for <SPC> b <SPC> in <SPC> B } <NL> <TAB> others <SPC> = <SPC> [ ] <NL> <TAB> j <SPC> = <SPC> 0 <NL> <TAB> for <SPC> a <SPC> in <SPC> sortedA : <NL>          if <SPC> a <SPC> > <SPC> sortedB [ j ] : <NL>              candidates [ sortedB [ j ] ] . append ( a ) <NL>              j <SPC> += <SPC> 1 <NL>          else : <NL>              others . append ( a ) <NL> <TAB> return <SPC> [ candidates [ b ] . pop ( ) <SPC> if <SPC> candidates [ b ] <SPC> else <SPC> others . pop ( ) <SPC> for <SPC> b <SPC> in <SPC> B ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nthPersonGetsNthSeat ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> 0.5 <SPC> if <SPC> n <SPC> != <SPC> 1 <SPC> else <SPC> 1.0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> nthPersonGetsNthSeat ( self , <SPC> n ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0.0 ] <SPC> * <SPC> 2 <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 1.0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] <SPC> = <SPC> 1.0 <SPC> / <SPC> i <SPC> + <SPC> dp [ ( i <SPC> - <SPC> 2 ) <SPC> % <SPC> 2 ] <SPC> * <SPC> ( i <SPC> - <SPC> 2 ) <SPC> / <SPC> i <NL> <TAB> return <SPC> dp [ ( n <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> alertNames ( self , <SPC> keyName , <SPC> keyTime ) : <NL> <NL> <TAB> THRESHOLD <SPC> = <SPC> 3 <NL> <TAB> name_to_times <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> name , <SPC> hour_minute <SPC> in <SPC> itertools . izip ( keyName , <SPC> keyTime ) : <NL>          hour , <SPC> minute <SPC> = <SPC> map ( int , <SPC> hour_minute . split ( ":" ) ) <NL>          name_to_times [ name ] . append ( hour <SPC> * <SPC> 60 <SPC> + <SPC> minute ) <NL> <TAB> names <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> name , <SPC> times <SPC> in <SPC> name_to_times . iteritems ( ) : <NL>          times . sort ( ) <NL>          left <SPC> = <SPC> 0 <NL>          for <SPC> right , <SPC> time <SPC> in <SPC> enumerate ( times ) : <NL>              while <SPC> time <SPC> - <SPC> times [ left ] <SPC> > <SPC> 60 : <NL>                  left <SPC> += <SPC> 1 <NL>              if <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <SPC> >= <SPC> THRESHOLD : <NL>                  names . append ( name ) <NL>                  break <NL> <TAB> names . sort ( ) <NL> <TAB> return <SPC> names <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> alienOrder ( self , <SPC> words ) : <NL> <NL> <TAB> result , <SPC> in_degree , <SPC> out_degree <SPC> = <SPC> [ ] , <SPC> { } , <SPC> { } <NL> <TAB> zero_in_degree_queue <SPC> = <SPC> collections . deque ( ) <NL> <TAB> nodes <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          for <SPC> c <SPC> in <SPC> word : <NL>              nodes . add ( c ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( words ) ) : <NL>          if <SPC> ( <NL>              len ( words [ i <SPC> - <SPC> 1 ] ) <SPC> > <SPC> len ( words [ i ] ) <NL>              and <SPC> words [ i <SPC> - <SPC> 1 ] [ : <SPC> len ( words [ i ] ) ] <SPC> == <SPC> words [ i ] <NL>          ) : <NL>              return <SPC> "" <NL>          self . findEdges ( words [ i <SPC> - <SPC> 1 ] , <SPC> words [ i ] , <SPC> in_degree , <SPC> out_degree ) <NL> <NL> <TAB> for <SPC> node <SPC> in <SPC> nodes : <NL>          if <SPC> node <SPC> not <SPC> in <SPC> in_degree : <NL>              zero_in_degree_queue . append ( node ) <NL> <NL> <TAB> while <SPC> zero_in_degree_queue : <NL>          precedence <SPC> = <SPC> zero_in_degree_queue . popleft ( ) <NL>          result . append ( precedence ) <NL> <NL>          if <SPC> precedence <SPC> in <SPC> out_degree : <NL>              for <SPC> c <SPC> in <SPC> out_degree [ precedence ] : <NL>                  in_degree [ c ] . discard ( precedence ) <NL>                  if <SPC> not <SPC> in_degree [ c ] : <NL>                      zero_in_degree_queue . append ( c ) <NL> <NL>              del <SPC> out_degree [ precedence ] <NL> <NL> <TAB> if <SPC> out_degree : <NL>          return <SPC> "" <NL> <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <TAB> def <SPC> findEdges ( self , <SPC> word1 , <SPC> word2 , <SPC> in_degree , <SPC> out_degree ) : <NL> <TAB> str_len <SPC> = <SPC> min ( len ( word1 ) , <SPC> len ( word2 ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( str_len ) : <NL>          if <SPC> word1 [ i ] <SPC> != <SPC> word2 [ i ] : <NL>              if <SPC> word2 [ i ] <SPC> not <SPC> in <SPC> in_degree : <NL>                  in_degree [ word2 [ i ] ] <SPC> = <SPC> set ( ) <NL>              if <SPC> word1 [ i ] <SPC> not <SPC> in <SPC> out_degree : <NL>                  out_degree [ word1 [ i ] ] <SPC> = <SPC> set ( ) <NL>              in_degree [ word2 [ i ] ] . add ( word1 [ i ] ) <NL>              out_degree [ word1 [ i ] ] . add ( word2 [ i ] ) <NL>              break <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> alienOrder ( self , <SPC> words ) : <NL> <NL> <TAB> nodes , <SPC> ancestors <SPC> = <SPC> set ( ) , <SPC> { } <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) ) : <NL>          for <SPC> c <SPC> in <SPC> words [ i ] : <NL>              nodes . add ( c ) <NL> <TAB> for <SPC> node <SPC> in <SPC> nodes : <NL>          ancestors [ node ] <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( words ) ) : <NL>          if <SPC> ( <NL>              len ( words [ i <SPC> - <SPC> 1 ] ) <SPC> > <SPC> len ( words [ i ] ) <NL>              and <SPC> words [ i <SPC> - <SPC> 1 ] [ : <SPC> len ( words [ i ] ) ] <SPC> == <SPC> words [ i ] <NL>          ) : <NL>              return <SPC> "" <NL>          self . findEdges ( words [ i <SPC> - <SPC> 1 ] , <SPC> words [ i ] , <SPC> ancestors ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> visited <SPC> = <SPC> { } <NL> <TAB> for <SPC> node <SPC> in <SPC> nodes : <NL>          if <SPC> self . topSortDFS ( node , <SPC> node , <SPC> ancestors , <SPC> visited , <SPC> result ) : <NL>              return <SPC> "" <NL> <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <TAB> def <SPC> findEdges ( self , <SPC> word1 , <SPC> word2 , <SPC> ancestors ) : <NL> <TAB> min_len <SPC> = <SPC> min ( len ( word1 ) , <SPC> len ( word2 ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( min_len ) : <NL>          if <SPC> word1 [ i ] <SPC> != <SPC> word2 [ i ] : <NL>              ancestors [ word2 [ i ] ] . append ( word1 [ i ] ) <NL>              break <NL> <NL> <TAB> def <SPC> topSortDFS ( self , <SPC> root , <SPC> node , <SPC> ancestors , <SPC> visited , <SPC> result ) : <NL> <TAB> if <SPC> node <SPC> not <SPC> in <SPC> visited : <NL>          visited [ node ] <SPC> = <SPC> root <NL>          for <SPC> ancestor <SPC> in <SPC> ancestors [ node ] : <NL>              if <SPC> self . topSortDFS ( root , <SPC> ancestor , <SPC> ancestors , <SPC> visited , <SPC> result ) : <NL>                  return <SPC> True <NL>          result . append ( node ) <NL> <TAB> elif <SPC> visited [ node ] <SPC> == <SPC> root : <NL> <NL>          return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getAllElements ( self , <SPC> root1 , <SPC> root2 ) : <NL> <NL> <TAB> def <SPC> inorder_gen ( root ) : <NL>          result , <SPC> stack <SPC> = <SPC> [ ] , <SPC> [ ( root , <SPC> False ) ] <NL>          while <SPC> stack : <NL>              root , <SPC> is_visited <SPC> = <SPC> stack . pop ( ) <NL>              if <SPC> root <SPC> is <SPC> None : <NL>                  continue <NL>              if <SPC> is_visited : <NL>                  yield <SPC> root . val <NL>              else : <NL>                  stack . append ( ( root . right , <SPC> False ) ) <NL>                  stack . append ( ( root , <SPC> True ) ) <NL>                  stack . append ( ( root . left , <SPC> False ) ) <NL>          yield <SPC> None <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> left_gen , <SPC> right_gen <SPC> = <SPC> inorder_gen ( root1 ) , <SPC> inorder_gen ( root2 ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> next ( left_gen ) , <SPC> next ( right_gen ) <NL> <TAB> while <SPC> left <SPC> is <SPC> not <SPC> None <SPC> or <SPC> right <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> right <SPC> is <SPC> None <SPC> or <SPC> ( left <SPC> is <SPC> not <SPC> None <SPC> and <SPC> left <SPC> < <SPC> right ) : <NL>              result . append ( left ) <NL>              left <SPC> = <SPC> next ( left_gen ) <NL>          else : <NL>              result . append ( right ) <NL>              right <SPC> = <SPC> next ( right_gen ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> distanceK ( self , <SPC> root , <SPC> target , <SPC> K ) : <NL> <NL> <TAB> def <SPC> dfs ( parent , <SPC> child , <SPC> neighbors ) : <NL>          if <SPC> not <SPC> child : <NL>              return <NL>          if <SPC> parent : <NL>              neighbors [ parent . val ] . append ( child . val ) <NL>              neighbors [ child . val ] . append ( parent . val ) <NL>          dfs ( child , <SPC> child . left , <SPC> neighbors ) <NL>          dfs ( child , <SPC> child . right , <SPC> neighbors ) <NL> <NL> <TAB> neighbors <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> dfs ( None , <SPC> root , <SPC> neighbors ) <NL> <TAB> bfs <SPC> = <SPC> [ target . val ] <NL> <TAB> lookup <SPC> = <SPC> set ( bfs ) <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( K ) : <NL>          bfs <SPC> = <SPC> [ nei <SPC> for <SPC> node <SPC> in <SPC> bfs <SPC> for <SPC> nei <SPC> in <SPC> neighbors [ node ] <SPC> if <SPC> nei <SPC> not <SPC> in <SPC> lookup ] <NL>          lookup <SPC> |= <SPC> set ( bfs ) <NL> <TAB> return <SPC> bfs <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> value , <SPC> keys ) : <NL> <TAB> self . value <SPC> = <SPC> value <NL> <TAB> self . keys <SPC> = <SPC> keys <NL> <TAB> self . prev <SPC> = <SPC> None <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> LinkedList ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . head , <SPC> self . tail <SPC> = <SPC> Node ( 0 , <SPC> set ( ) ) , <SPC> Node ( 0 , <SPC> set ( ) ) <NL> <TAB> self . head . next , <SPC> self . tail . prev <SPC> = <SPC> self . tail , <SPC> self . head <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> pos , <SPC> node ) : <NL> <TAB> node . prev , <SPC> node . next <SPC> = <SPC> pos . prev , <SPC> pos <NL> <TAB> pos . prev . next , <SPC> pos . prev <SPC> = <SPC> node , <SPC> node <NL> <TAB> return <SPC> node <NL> <NL> <TAB> def <SPC> erase ( self , <SPC> node ) : <NL> <TAB> node . prev . next , <SPC> node . next . prev <SPC> = <SPC> node . next , <SPC> node . prev <NL> <TAB> del <SPC> node <NL> <NL> <TAB> def <SPC> empty ( self ) : <NL> <TAB> return <SPC> self . head . next <SPC> is <SPC> self . tail <NL> <NL> <TAB> def <SPC> begin ( self ) : <NL> <TAB> return <SPC> self . head . next <NL> <NL> <TAB> def <SPC> end ( self ) : <NL> <TAB> return <SPC> self . tail <NL> <NL> <TAB> def <SPC> front ( self ) : <NL> <TAB> return <SPC> self . head . next <NL> <NL> <TAB> def <SPC> back ( self ) : <NL> <TAB> return <SPC> self . tail . prev <NL> <NL> <NL> class <SPC> AllOne ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . bucket_of_key <SPC> = <SPC> { } <NL> <TAB> self . buckets <SPC> = <SPC> LinkedList ( ) <NL> <NL> <TAB> def <SPC> inc ( self , <SPC> key ) : <NL> <NL> <TAB> if <SPC> key <SPC> not <SPC> in <SPC> self . bucket_of_key : <NL>          self . bucket_of_key [ key ] <SPC> = <SPC> self . buckets . insert ( <NL>              self . buckets . begin ( ) , <SPC> Node ( 0 , <SPC> set ( [ key ] ) ) <NL>          ) <NL> <NL> <TAB> bucket , <SPC> next_bucket <SPC> = <SPC> self . bucket_of_key [ key ] , <SPC> self . bucket_of_key [ key ] . next <NL> <TAB> if <SPC> next_bucket <SPC> is <SPC> self . buckets . end ( ) <SPC> or <SPC> next_bucket . value <SPC> > <SPC> bucket . value <SPC> + <SPC> 1 : <NL>          next_bucket <SPC> = <SPC> self . buckets . insert ( <NL>              next_bucket , <SPC> Node ( bucket . value <SPC> + <SPC> 1 , <SPC> set ( ) ) <NL>          ) <NL> <TAB> next_bucket . keys . add ( key ) <NL> <TAB> self . bucket_of_key [ key ] <SPC> = <SPC> next_bucket <NL> <NL> <TAB> bucket . keys . remove ( key ) <NL> <TAB> if <SPC> not <SPC> bucket . keys : <NL>          self . buckets . erase ( bucket ) <NL> <NL> <TAB> def <SPC> dec ( self , <SPC> key ) : <NL> <NL> <TAB> if <SPC> key <SPC> not <SPC> in <SPC> self . bucket_of_key : <NL>          return <NL> <NL> <TAB> bucket , <SPC> prev_bucket <SPC> = <SPC> self . bucket_of_key [ key ] , <SPC> self . bucket_of_key [ key ] . prev <NL> <TAB> self . bucket_of_key . pop ( key , <SPC> None ) <NL> <TAB> if <SPC> bucket . value <SPC> > <SPC> 1 : <NL>          if <SPC> bucket <SPC> is <SPC> self . buckets . begin ( ) <SPC> or <SPC> prev_bucket . value <SPC> < <SPC> bucket . value <SPC> - <SPC> 1 : <NL>              prev_bucket <SPC> = <SPC> self . buckets . insert ( <NL>                  bucket , <SPC> Node ( bucket . value <SPC> - <SPC> 1 , <SPC> set ( ) ) ) <NL>          prev_bucket . keys . add ( key ) <NL>          self . bucket_of_key [ key ] <SPC> = <SPC> prev_bucket <NL> <NL> <TAB> bucket . keys . remove ( key ) <NL> <TAB> if <SPC> not <SPC> bucket . keys : <NL>          self . buckets . erase ( bucket ) <NL> <NL> <TAB> def <SPC> getMaxKey ( self ) : <NL> <NL> <TAB> if <SPC> self . buckets . empty ( ) : <NL>          return <SPC> "" <NL> <TAB> return <SPC> iter ( self . buckets . back ( ) . keys ) . next ( ) <NL> <NL> <TAB> def <SPC> getMinKey ( self ) : <NL> <NL> <TAB> if <SPC> self . buckets . empty ( ) : <NL>          return <SPC> "" <NL> <TAB> return <SPC> iter ( self . buckets . front ( ) . keys ) . next ( ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> leadsToDestination ( self , <SPC> n , <SPC> edges , <SPC> source , <SPC> destination ) : <NL> <NL> <TAB> UNVISITED , <SPC> VISITING , <SPC> DONE <SPC> = <SPC> range ( 3 ) <NL> <NL> <TAB> def <SPC> dfs ( children , <SPC> node , <SPC> destination , <SPC> status ) : <NL>          if <SPC> status [ node ] <SPC> == <SPC> DONE : <NL>              return <SPC> True <NL>          if <SPC> status [ node ] <SPC> == <SPC> VISITING : <NL>              return <SPC> False <NL>          status [ node ] <SPC> = <SPC> VISITING <NL>          if <SPC> node <SPC> not <SPC> in <SPC> children <SPC> and <SPC> node <SPC> != <SPC> destination : <NL>              return <SPC> False <NL>          if <SPC> node <SPC> in <SPC> children : <NL>              for <SPC> child <SPC> in <SPC> children [ node ] : <NL>                  if <SPC> not <SPC> dfs ( children , <SPC> child , <SPC> destination , <SPC> status ) : <NL>                      return <SPC> False <NL>          status [ node ] <SPC> = <SPC> DONE <NL>          return <SPC> True <NL> <NL> <TAB> children <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> parent , <SPC> child <SPC> in <SPC> edges : <NL>          children [ parent ] . append ( child ) <NL> <TAB> return <SPC> dfs ( children , <SPC> source , <SPC> destination , <SPC> [ 0 ] <SPC> * <SPC> n ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> allPathsSourceTarget ( self , <SPC> graph ) : <NL> <NL> <TAB> def <SPC> dfs ( graph , <SPC> curr , <SPC> path , <SPC> result ) : <NL>          if <SPC> curr <SPC> == <SPC> len ( graph ) <SPC> - <SPC> 1 : <NL>              result . append ( path [ : ] ) <NL>              return <NL>          for <SPC> node <SPC> in <SPC> graph [ curr ] : <NL>              path . append ( node ) <NL>              dfs ( graph , <SPC> node , <SPC> path , <SPC> result ) <NL>              path . pop ( ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> dfs ( graph , <SPC> 0 , <SPC> [ 0 ] , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __memo <SPC> = <SPC> { 1 : <SPC> [ TreeNode ( 0 ) ] } <NL> <NL> <TAB> def <SPC> allPossibleFBT ( self , <SPC> N ) : <NL> <NL> <TAB> if <SPC> N <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>          return <SPC> [ ] <NL> <NL> <TAB> if <SPC> N <SPC> not <SPC> in <SPC> self . __memo : <NL>          result <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( N ) : <NL>              for <SPC> left <SPC> in <SPC> self . allPossibleFBT ( i ) : <NL>                  for <SPC> right <SPC> in <SPC> self . allPossibleFBT ( N <SPC> - <SPC> 1 <SPC> - <SPC> i ) : <NL>                      node <SPC> = <SPC> TreeNode ( 0 ) <NL>                      node . left <SPC> = <SPC> left <NL>                      node . right <SPC> = <SPC> right <NL>                      result . append ( node ) <NL>          self . __memo [ N ] <SPC> = <SPC> result <NL> <NL> <TAB> return <SPC> self . __memo [ N ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDistance ( self , <SPC> houses , <SPC> k ) : <NL> <NL> <TAB> def <SPC> cost ( prefix , <SPC> i , <SPC> j ) : <NL>          return <SPC> ( prefix [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ ( i <SPC> + <SPC> j <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 ] ) <SPC> - <SPC> ( <NL>              prefix [ ( i <SPC> + <SPC> j ) <SPC> // <SPC> 2 <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ i ] <NL>          ) <NL> <NL> <TAB> houses . sort ( ) <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( houses ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i , <SPC> h <SPC> in <SPC> enumerate ( houses ) : <NL>          prefix [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> prefix [ i ] <SPC> + <SPC> h <NL> <TAB> dp <SPC> = <SPC> [ cost ( prefix , <SPC> 0 , <SPC> j ) <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( houses ) ) ] <NL> <TAB> for <SPC> m <SPC> in <SPC> xrange ( 1 , <SPC> k ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( m , <SPC> len ( houses ) ) ) : <NL>              for <SPC> i <SPC> in <SPC> xrange ( m , <SPC> j <SPC> + <SPC> 1 ) : <NL>                  dp [ j ] <SPC> = <SPC> min ( dp [ j ] , <SPC> dp [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> cost ( prefix , <SPC> i , <SPC> j ) ) <NL> <TAB> return <SPC> dp [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> alphabetBoardPath ( self , <SPC> target ) : <NL> <NL> <TAB> x , <SPC> y <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> target : <NL>          y1 , <SPC> x1 <SPC> = <SPC> divmod ( ord ( c ) <SPC> - <SPC> ord ( "a" ) , <SPC> 5 ) <NL>          result . append ( "U" <SPC> * <SPC> max ( y <SPC> - <SPC> y1 , <SPC> 0 ) ) <NL>          result . append ( "L" <SPC> * <SPC> max ( x <SPC> - <SPC> x1 , <SPC> 0 ) ) <NL>          result . append ( "R" <SPC> * <SPC> max ( x1 <SPC> - <SPC> x , <SPC> 0 ) ) <NL>          result . append ( "D" <SPC> * <SPC> max ( y1 <SPC> - <SPC> y , <SPC> 0 ) ) <NL>          result . append ( "!" ) <NL>          x , <SPC> y <SPC> = <SPC> x1 , <SPC> y1 <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> ambiguousCoordinates ( self , <SPC> S ) : <NL> <NL> <TAB> def <SPC> make ( S , <SPC> i , <SPC> n ) : <NL>          for <SPC> d <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>              left <SPC> = <SPC> S [ i : <SPC> i <SPC> + <SPC> d ] <NL>              right <SPC> = <SPC> S [ i <SPC> + <SPC> d : <SPC> i <SPC> + <SPC> n ] <NL>              if <SPC> ( not <SPC> left . startswith ( "0" ) <SPC> or <SPC> left <SPC> == <SPC> "0" ) <SPC> and <SPC> ( <NL>                  not <SPC> right . endswith ( "0" ) <NL>              ) : <NL>                  yield <SPC> "" . join ( [ left , <SPC> "." <SPC> if <SPC> right <SPC> else <SPC> "" , <SPC> right ] ) <NL> <NL> <TAB> return <SPC> [ <NL>          "({}, {})" . format ( * cand ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( S ) <SPC> - <SPC> 2 ) <NL>          for <SPC> cand <SPC> in <SPC> itertools . product ( make ( S , <SPC> 1 , <SPC> i ) , <SPC> make ( S , <SPC> i <SPC> + <SPC> 1 , <SPC> len ( S ) <SPC> - <SPC> 2 <SPC> - <SPC> i ) ) <NL> <TAB> ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mostVisitedPattern ( self , <SPC> username , <SPC> timestamp , <SPC> website ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> A <SPC> = <SPC> zip ( timestamp , <SPC> username , <SPC> website ) <NL> <TAB> A . sort ( ) <NL> <TAB> for <SPC> t , <SPC> u , <SPC> w <SPC> in <SPC> A : <NL>          lookup [ u ] . append ( w ) <NL> <TAB> count <SPC> = <SPC> sum ( <NL>          [ <NL>              collections . Counter ( set ( itertools . combinations ( lookup [ u ] , <SPC> 3 ) ) ) <NL>              for <SPC> u <SPC> in <SPC> lookup <NL>          ] , <NL>          collections . Counter ( ) , <NL> <TAB> ) <NL> <TAB> return <SPC> list ( min ( count , <SPC> key = lambda <SPC> x : <SPC> ( - count [ x ] , <SPC> x ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfPatterns ( self , <SPC> m , <SPC> n ) : <NL> <NL> <TAB> def <SPC> merge ( used , <SPC> i ) : <NL>          return <SPC> used <SPC> | <SPC> ( 1 <SPC> << <SPC> i ) <NL> <NL> <TAB> def <SPC> number_of_keys ( i ) : <NL>          number <SPC> = <SPC> 0 <NL>          while <SPC> i <SPC> > <SPC> 0 : <NL>              i <SPC> &= <SPC> i <SPC> - <SPC> 1 <NL>              number <SPC> += <SPC> 1 <NL>          return <SPC> number <NL> <NL> <TAB> def <SPC> contain ( used , <SPC> i ) : <NL>          return <SPC> bool ( used <SPC> & <SPC> ( 1 <SPC> << <SPC> i ) ) <NL> <NL> <TAB> def <SPC> convert ( i , <SPC> j ) : <NL>          return <SPC> 3 <SPC> * <SPC> i <SPC> + <SPC> j <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> 9 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 1 <SPC> << <SPC> 9 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 9 ) : <NL>          dp [ merge ( 0 , <SPC> i ) ] [ i ] <SPC> = <SPC> 1 <NL> <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> for <SPC> used <SPC> in <SPC> xrange ( len ( dp ) ) : <NL>          number <SPC> = <SPC> number_of_keys ( used ) <NL>          if <SPC> number <SPC> > <SPC> n : <NL>              continue <NL> <NL>          for <SPC> i <SPC> in <SPC> xrange ( 9 ) : <NL>              if <SPC> not <SPC> contain ( used , <SPC> i ) : <NL>                  continue <NL> <NL>              if <SPC> m <SPC> <= <SPC> number <SPC> <= <SPC> n : <NL>                  res <SPC> += <SPC> dp [ used ] [ i ] <NL> <NL>              x1 , <SPC> y1 <SPC> = <SPC> divmod ( i , <SPC> 3 ) <NL>              for <SPC> j <SPC> in <SPC> xrange ( 9 ) : <NL>                  if <SPC> contain ( used , <SPC> j ) : <NL>                      continue <NL> <NL>                  x2 , <SPC> y2 <SPC> = <SPC> divmod ( j , <SPC> 3 ) <NL>                  if <SPC> ( <NL>                      ( x1 <SPC> == <SPC> x2 <SPC> and <SPC> abs ( y1 <SPC> - <SPC> y2 ) <SPC> == <SPC> 2 ) <NL>                      or <SPC> ( y1 <SPC> == <SPC> y2 <SPC> and <SPC> abs ( x1 <SPC> - <SPC> x2 ) <SPC> == <SPC> 2 ) <NL>                      or <SPC> ( abs ( x1 <SPC> - <SPC> x2 ) <SPC> == <SPC> 2 <SPC> and <SPC> abs ( y1 <SPC> - <SPC> y2 ) <SPC> == <SPC> 2 ) <NL>                  ) <SPC> and <SPC> not <SPC> contain ( used , <SPC> convert ( ( x1 <SPC> + <SPC> x2 ) <SPC> // <SPC> 2 , <SPC> ( y1 <SPC> + <SPC> y2 ) <SPC> // <SPC> 2 ) ) : <NL>                      continue <NL> <NL>                  dp [ merge ( used , <SPC> j ) ] [ j ] <SPC> += <SPC> dp [ used ] [ i ] <NL> <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numberOfPatterns ( self , <SPC> m , <SPC> n ) : <NL> <NL> <TAB> def <SPC> merge ( used , <SPC> i ) : <NL>          return <SPC> used <SPC> | <SPC> ( 1 <SPC> << <SPC> i ) <NL> <NL> <TAB> def <SPC> number_of_keys ( i ) : <NL>          number <SPC> = <SPC> 0 <NL>          while <SPC> i <SPC> > <SPC> 0 : <NL>              i <SPC> &= <SPC> i <SPC> - <SPC> 1 <NL>              number <SPC> += <SPC> 1 <NL>          return <SPC> number <NL> <NL> <TAB> def <SPC> exclude ( used , <SPC> i ) : <NL>          return <SPC> used <SPC> & <SPC> ~ ( 1 <SPC> << <SPC> i ) <NL> <NL> <TAB> def <SPC> contain ( used , <SPC> i ) : <NL>          return <SPC> bool ( used <SPC> & <SPC> ( 1 <SPC> << <SPC> i ) ) <NL> <NL> <TAB> def <SPC> convert ( i , <SPC> j ) : <NL>          return <SPC> 3 <SPC> * <SPC> i <SPC> + <SPC> j <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> 9 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 1 <SPC> << <SPC> 9 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 9 ) : <NL>          dp [ merge ( 0 , <SPC> i ) ] [ i ] <SPC> = <SPC> 1 <NL> <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> for <SPC> used <SPC> in <SPC> xrange ( len ( dp ) ) : <NL>          number <SPC> = <SPC> number_of_keys ( used ) <NL>          if <SPC> number <SPC> > <SPC> n : <NL>              continue <NL> <NL>          for <SPC> i <SPC> in <SPC> xrange ( 9 ) : <NL>              if <SPC> not <SPC> contain ( used , <SPC> i ) : <NL>                  continue <NL> <NL>              x1 , <SPC> y1 <SPC> = <SPC> divmod ( i , <SPC> 3 ) <NL>              for <SPC> j <SPC> in <SPC> xrange ( 9 ) : <NL>                  if <SPC> i <SPC> == <SPC> j <SPC> or <SPC> not <SPC> contain ( used , <SPC> j ) : <NL>                      continue <NL> <NL>                  x2 , <SPC> y2 <SPC> = <SPC> divmod ( j , <SPC> 3 ) <NL>                  if <SPC> ( <NL>                      ( x1 <SPC> == <SPC> x2 <SPC> and <SPC> abs ( y1 <SPC> - <SPC> y2 ) <SPC> == <SPC> 2 ) <NL>                      or <SPC> ( y1 <SPC> == <SPC> y2 <SPC> and <SPC> abs ( x1 <SPC> - <SPC> x2 ) <SPC> == <SPC> 2 ) <NL>                      or <SPC> ( abs ( x1 <SPC> - <SPC> x2 ) <SPC> == <SPC> 2 <SPC> and <SPC> abs ( y1 <SPC> - <SPC> y2 ) <SPC> == <SPC> 2 ) <NL>                  ) <SPC> and <SPC> not <SPC> contain ( used , <SPC> convert ( ( x1 <SPC> + <SPC> x2 ) <SPC> // <SPC> 2 , <SPC> ( y1 <SPC> + <SPC> y2 ) <SPC> // <SPC> 2 ) ) : <NL>                      continue <NL> <NL>                  dp [ used ] [ i ] <SPC> += <SPC> dp [ exclude ( used , <SPC> i ) ] [ j ] <NL> <NL>              if <SPC> m <SPC> <= <SPC> number <SPC> <= <SPC> n : <NL>                  res <SPC> += <SPC> dp [ used ] [ i ] <NL> <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution_TLE ( object ) : <NL> <TAB> def <SPC> numberOfPatterns ( self , <SPC> m , <SPC> n ) : <NL> <NL> <TAB> def <SPC> merge ( used , <SPC> i ) : <NL>          return <SPC> used <SPC> | <SPC> ( 1 <SPC> << <SPC> i ) <NL> <NL> <TAB> def <SPC> contain ( used , <SPC> i ) : <NL>          return <SPC> bool ( used <SPC> & <SPC> ( 1 <SPC> << <SPC> i ) ) <NL> <NL> <TAB> def <SPC> convert ( i , <SPC> j ) : <NL>          return <SPC> 3 <SPC> * <SPC> i <SPC> + <SPC> j <NL> <NL> <TAB> def <SPC> numberOfPatternsHelper ( m , <SPC> n , <SPC> level , <SPC> used , <SPC> i ) : <NL>          number <SPC> = <SPC> 0 <NL>          if <SPC> level <SPC> > <SPC> n : <NL>              return <SPC> number <NL> <NL>          if <SPC> m <SPC> <= <SPC> level <SPC> <= <SPC> n : <NL>              number <SPC> += <SPC> 1 <NL> <NL>          x1 , <SPC> y1 <SPC> = <SPC> divmod ( i , <SPC> 3 ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( 9 ) : <NL>              if <SPC> contain ( used , <SPC> j ) : <NL>                  continue <NL> <NL>              x2 , <SPC> y2 <SPC> = <SPC> divmod ( j , <SPC> 3 ) <NL>              if <SPC> ( <NL>                  ( x1 <SPC> == <SPC> x2 <SPC> and <SPC> abs ( y1 <SPC> - <SPC> y2 ) <SPC> == <SPC> 2 ) <NL>                  or <SPC> ( y1 <SPC> == <SPC> y2 <SPC> and <SPC> abs ( x1 <SPC> - <SPC> x2 ) <SPC> == <SPC> 2 ) <NL>                  or <SPC> ( abs ( x1 <SPC> - <SPC> x2 ) <SPC> == <SPC> 2 <SPC> and <SPC> abs ( y1 <SPC> - <SPC> y2 ) <SPC> == <SPC> 2 ) <NL>              ) <SPC> and <SPC> not <SPC> contain ( used , <SPC> convert ( ( x1 <SPC> + <SPC> x2 ) <SPC> // <SPC> 2 , <SPC> ( y1 <SPC> + <SPC> y2 ) <SPC> // <SPC> 2 ) ) : <NL>                  continue <NL> <NL>              number <SPC> += <SPC> numberOfPatternsHelper ( m , <NL>                                               n , <SPC> level <SPC> + <SPC> 1 , <SPC> merge ( used , <SPC> j ) , <SPC> j ) <NL> <NL>          return <SPC> number <NL> <NL> <TAB> number <SPC> = <SPC> 0 <NL> <NL> <TAB> number <SPC> += <SPC> 4 <SPC> * <SPC> numberOfPatternsHelper ( m , <SPC> n , <SPC> 1 , <SPC> merge ( 0 , <SPC> 0 ) , <SPC> 0 ) <NL> <NL> <TAB> number <SPC> += <SPC> 4 <SPC> * <SPC> numberOfPatternsHelper ( m , <SPC> n , <SPC> 1 , <SPC> merge ( 0 , <SPC> 1 ) , <SPC> 1 ) <NL> <NL> <TAB> number <SPC> += <SPC> numberOfPatternsHelper ( m , <SPC> n , <SPC> 1 , <SPC> merge ( 0 , <SPC> 4 ) , <SPC> 4 ) <NL> <TAB> return <SPC> number <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> angleClock ( self , <SPC> hour , <SPC> minutes ) : <NL> <NL> <TAB> angle1 <SPC> = <SPC> ( hour <SPC> % <SPC> 12 <SPC> * <SPC> 60.0 <SPC> + <SPC> minutes ) <SPC> / <SPC> 720.0 <NL> <TAB> angle2 <SPC> = <SPC> minutes <SPC> / <SPC> 60.0 <NL> <TAB> diff <SPC> = <SPC> abs ( angle1 <SPC> - <SPC> angle2 ) <NL> <TAB> return <SPC> min ( diff , <SPC> 1.0 <SPC> - <SPC> diff ) <SPC> * <SPC> 360.0 <NL> <NL> <NL> class <SPC> Cashier ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n , <SPC> discount , <SPC> products , <SPC> prices ) : <NL> <NL> <TAB> self . __n <SPC> = <SPC> n <NL> <TAB> self . __discount <SPC> = <SPC> discount <NL> <TAB> self . __curr <SPC> = <SPC> 0 <NL> <TAB> self . __lookup <SPC> = <SPC> { p : <SPC> prices [ i ] <SPC> for <SPC> i , <SPC> p <SPC> in <SPC> enumerate ( products ) } <NL> <NL> <TAB> def <SPC> getBill ( self , <SPC> product , <SPC> amount ) : <NL> <NL> <TAB> self . __curr <SPC> = <SPC> ( self . __curr <SPC> + <SPC> 1 ) <SPC> % <SPC> self . __n <NL> <TAB> result <SPC> = <SPC> 0.0 <NL> <TAB> for <SPC> i , <SPC> p <SPC> in <SPC> enumerate ( product ) : <NL>          result <SPC> += <SPC> self . __lookup [ p ] <SPC> * <SPC> amount [ i ] <NL> <TAB> return <SPC> result <SPC> * <SPC> ( 1.0 <SPC> - <SPC> self . __discount <SPC> / <SPC> 100.0 <SPC> if <SPC> self . __curr <SPC> == <SPC> 0 <SPC> else <SPC> 1.0 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfArithmeticSlices ( self , <SPC> A ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> dp <SPC> = <SPC> [ collections . defaultdict ( int ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i ) : <NL>              diff <SPC> = <SPC> A [ i ] <SPC> - <SPC> A [ j ] <NL>              dp [ i ] [ diff ] <SPC> += <SPC> 1 <NL>              if <SPC> diff <SPC> in <SPC> dp [ j ] : <NL>                  dp [ i ] [ diff ] <SPC> += <SPC> dp [ j ] [ diff ] <NL>                  result <SPC> += <SPC> dp [ j ] [ diff ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfArithmeticSlices ( self , <SPC> A ) : <NL> <NL> <TAB> res , <SPC> i <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> + <SPC> 2 <SPC> < <SPC> len ( A ) : <NL>          start <SPC> = <SPC> i <NL>          while <SPC> i <SPC> + <SPC> 2 <SPC> < <SPC> len ( A ) <SPC> and <SPC> A [ i <SPC> + <SPC> 2 ] <SPC> + <SPC> A [ i ] <SPC> == <SPC> 2 <SPC> * <SPC> A [ i <SPC> + <SPC> 1 ] : <NL>              res <SPC> += <SPC> i <SPC> - <SPC> start <SPC> + <SPC> 1 <NL>              i <SPC> += <SPC> 1 <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> res <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkArithmeticSubarrays ( self , <SPC> nums , <SPC> l , <SPC> r ) : <NL> <NL> <TAB> def <SPC> is_arith ( n ) : <NL>          mx , <SPC> mn , <SPC> lookup <SPC> = <SPC> max ( n ) , <SPC> min ( n ) , <SPC> set ( n ) <NL>          if <SPC> mx <SPC> == <SPC> mn : <NL>              return <SPC> True <NL>          d , <SPC> r <SPC> = <SPC> divmod ( mx <SPC> - <SPC> mn , <SPC> len ( n ) <SPC> - <SPC> 1 ) <NL>          if <SPC> r : <NL>              return <SPC> False <NL>          return <SPC> all ( i <SPC> in <SPC> lookup <SPC> for <SPC> i <SPC> in <SPC> xrange ( mn , <SPC> mx , <SPC> d ) ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> left , <SPC> right <SPC> in <SPC> itertools . izip ( l , <SPC> r ) : <NL>          result . append ( is_arith ( nums [ left : <SPC> right <SPC> + <SPC> 1 ] ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isArmstrong ( self , <SPC> N ) : <NL> <NL> <TAB> n_str <SPC> = <SPC> str ( N ) <NL> <TAB> return <SPC> sum ( int ( i ) <SPC> ** <SPC> len ( n_str ) <SPC> for <SPC> i <SPC> in <SPC> n_str ) <SPC> == <SPC> N <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> arrangeCoins ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> int ( ( math . sqrt ( 8 <SPC> * <SPC> n <SPC> + <SPC> 1 ) <SPC> - <SPC> 1 ) <SPC> / <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> arrangeCoins ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> check ( mid , <SPC> n ) : <NL>          return <SPC> mid <SPC> * <SPC> ( mid <SPC> + <SPC> 1 ) <SPC> <= <SPC> 2 <SPC> * <SPC> n <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> n <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( mid , <SPC> n ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> arrayNesting ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          if <SPC> num <SPC> is <SPC> not <SPC> None : <NL>              start , <SPC> count <SPC> = <SPC> num , <SPC> 0 <NL>              while <SPC> nums [ start ] <SPC> is <SPC> not <SPC> None : <NL>                  temp <SPC> = <SPC> start <NL>                  start <SPC> = <SPC> nums [ start ] <NL>                  nums [ temp ] <SPC> = <SPC> None <NL>                  count <SPC> += <SPC> 1 <NL>              result <SPC> = <SPC> max ( result , <SPC> count ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canReorderDoubled ( self , <SPC> A ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( A ) <NL> <TAB> for <SPC> x <SPC> in <SPC> sorted ( count , <SPC> key = abs ) : <NL>          if <SPC> count [ x ] <SPC> > <SPC> count [ 2 <SPC> * <SPC> x ] : <NL>              return <SPC> False <NL>          count [ 2 <SPC> * <SPC> x ] <SPC> -= <SPC> count [ x ] <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> arrayPairSum ( self , <SPC> nums ) : <NL> <NL> <TAB> LEFT , <SPC> RIGHT <SPC> = <SPC> - 10000 , <SPC> 10000 <NL> <TAB> lookup <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( RIGHT <SPC> - <SPC> LEFT <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          lookup [ num <SPC> - <SPC> LEFT ] <SPC> += <SPC> 1 <NL> <TAB> r , <SPC> result <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( LEFT , <SPC> RIGHT <SPC> + <SPC> 1 ) : <NL>          result <SPC> += <SPC> ( lookup [ i <SPC> - <SPC> LEFT ] <SPC> + <SPC> 1 <SPC> - <SPC> r ) <SPC> / <SPC> 2 <SPC> * <SPC> i <NL>          r <SPC> = <SPC> ( lookup [ i <SPC> - <SPC> LEFT ] <SPC> + <SPC> r ) <SPC> % <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> arrayPairSum ( self , <SPC> nums ) : <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 0 , <SPC> len ( nums ) , <SPC> 2 ) : <NL>          result <SPC> += <SPC> nums [ i ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> arrayPairSum ( self , <SPC> nums ) : <NL> <NL> <TAB> nums <SPC> = <SPC> sorted ( nums ) <NL> <TAB> return <SPC> sum ( [ nums [ i ] <SPC> for <SPC> i <SPC> in <SPC> range ( 0 , <SPC> len ( nums ) , <SPC> 2 ) ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> transformArray ( self , <SPC> arr ) : <NL> <NL> <TAB> def <SPC> is_changable ( arr ) : <NL>          return <SPC> any ( <NL>              arr [ i <SPC> - <SPC> 1 ] <SPC> > <SPC> arr [ i ] <SPC> < <SPC> arr [ i <SPC> + <SPC> 1 ] <SPC> or <SPC> arr [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> arr [ i ] <SPC> > <SPC> arr [ i <SPC> + <SPC> 1 ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( arr ) <SPC> - <SPC> 1 ) <NL>          ) <NL> <NL> <TAB> while <SPC> is_changable ( arr ) : <NL>          new_arr <SPC> = <SPC> arr [ : ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( arr ) <SPC> - <SPC> 1 ) : <NL>              new_arr [ i ] <SPC> += <SPC> arr [ i <SPC> - <SPC> 1 ] <SPC> > <SPC> arr [ i ] <SPC> < <SPC> arr [ i <SPC> + <SPC> 1 ] <NL>              new_arr [ i ] <SPC> -= <SPC> arr [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> arr [ i ] <SPC> > <SPC> arr [ i <SPC> + <SPC> 1 ] <NL>          arr <SPC> = <SPC> new_arr <NL> <TAB> return <SPC> arr <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxDistance ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> q <SPC> = <SPC> collections . deque ( <NL>          [ <NL>              ( i , <SPC> j ) <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) <NL>              if <SPC> grid [ i ] [ j ] <SPC> == <SPC> 1 <NL>          ] <NL> <TAB> ) <NL> <TAB> if <SPC> len ( q ) <SPC> == <SPC> len ( grid ) <SPC> * <SPC> len ( grid [ 0 ] ) : <NL>          return <SPC> - 1 <NL> <TAB> level <SPC> = <SPC> - 1 <NL> <TAB> while <SPC> q : <NL>          next_q <SPC> = <SPC> collections . deque ( ) <NL>          while <SPC> q : <NL>              x , <SPC> y <SPC> = <SPC> q . popleft ( ) <NL>              for <SPC> dx , <SPC> dy <SPC> in <SPC> directions : <NL>                  nx , <SPC> ny <SPC> = <SPC> x <SPC> + <SPC> dx , <SPC> y <SPC> + <SPC> dy <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> nx <SPC> < <SPC> len ( grid ) <NL>                      and <SPC> 0 <SPC> <= <SPC> ny <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                      and <SPC> grid [ nx ] [ ny ] <SPC> == <SPC> 0 <NL>                  ) : <NL>                      continue <NL>                  next_q . append ( ( nx , <SPC> ny ) ) <NL>                  grid [ nx ] [ ny ] <SPC> = <SPC> 1 <NL>          q <SPC> = <SPC> next_q <NL>          level <SPC> += <SPC> 1 <NL> <TAB> return <SPC> level <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findContentChildren ( self , <SPC> g , <SPC> s ) : <NL> <NL> <TAB> g . sort ( ) <NL> <TAB> s . sort ( ) <NL> <NL> <TAB> result , <SPC> i <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> i <SPC> == <SPC> len ( g ) : <NL>              break <NL>          if <SPC> s [ j ] <SPC> >= <SPC> g [ i ] : <NL>              result <SPC> += <SPC> 1 <NL>              i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> asteroidCollision ( self , <SPC> asteroids ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> asteroid <SPC> in <SPC> asteroids : <NL>          while <SPC> result <SPC> and <SPC> asteroid <SPC> < <SPC> 0 <SPC> < <SPC> result [ - 1 ] : <NL>              if <SPC> result [ - 1 ] <SPC> < <SPC> - asteroid : <NL>                  result . pop ( ) <NL>                  continue <NL>              elif <SPC> result [ - 1 ] <SPC> == <SPC> - asteroid : <NL>                  result . pop ( ) <NL>              break <NL>          else : <NL>              result . append ( asteroid ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numRookCaptures ( self , <SPC> board ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> r , <SPC> c <SPC> = <SPC> None , <SPC> None <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 8 ) : <NL>          if <SPC> r <SPC> is <SPC> not <SPC> None : <NL>              break <NL>          for <SPC> j <SPC> in <SPC> xrange ( 8 ) : <NL>              if <SPC> board [ i ] [ j ] <SPC> == <SPC> "R" : <NL>                  r , <SPC> c <SPC> = <SPC> i , <SPC> j <NL>                  break <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> d <SPC> in <SPC> directions : <NL>          nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> d [ 0 ] , <SPC> c <SPC> + <SPC> d [ 1 ] <NL>          while <SPC> 0 <SPC> <= <SPC> nr <SPC> < <SPC> 8 <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> 8 : <NL>              if <SPC> board [ nr ] [ nc ] <SPC> == <SPC> "p" : <NL>                  result <SPC> += <SPC> 1 <NL>              if <SPC> board [ nr ] [ nc ] <SPC> != <SPC> "." : <NL>                  break <NL>              nr , <SPC> nc <SPC> = <SPC> nr <SPC> + <SPC> d [ 0 ] , <SPC> nc <SPC> + <SPC> d [ 1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> averageOfLevels ( self , <SPC> root ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> q <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> q : <NL>          total , <SPC> count <SPC> = <SPC> 0 , <SPC> 0 <NL>          next_q <SPC> = <SPC> [ ] <NL>          for <SPC> n <SPC> in <SPC> q : <NL>              total <SPC> += <SPC> n . val <NL>              count <SPC> += <SPC> 1 <NL>              if <SPC> n . left : <NL>                  next_q . append ( n . left ) <NL>              if <SPC> n . right : <NL>                  next_q . append ( n . right ) <NL>          q <SPC> = <SPC> next_q <NL>          result . append ( float ( total ) <SPC> / <SPC> count ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> average ( self , <SPC> salary ) : <NL> <NL> <TAB> total , <SPC> mi , <SPC> ma <SPC> = <SPC> 0 , <SPC> float ( "inf" ) , <SPC> float ( "-inf" ) <NL> <TAB> for <SPC> s <SPC> in <SPC> salary : <NL>          total <SPC> += <SPC> s <NL>          mi , <SPC> ma <SPC> = <SPC> min ( mi , <SPC> s ) , <SPC> max ( ma , <SPC> s ) <NL> <TAB> return <SPC> 1.0 <SPC> * <SPC> ( total <SPC> - <SPC> mi <SPC> - <SPC> ma ) <SPC> / <SPC> ( len ( salary ) <SPC> - <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> average ( self , <SPC> salary ) : <NL> <NL> <TAB> return <SPC> 1.0 <SPC> * <SPC> ( sum ( salary ) <SPC> - <SPC> min ( salary ) <SPC> - <SPC> max ( salary ) ) <SPC> / <SPC> ( len ( salary ) <SPC> - <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> averageWaitingTime ( self , <SPC> customers ) : <NL> <NL> <TAB> avai <SPC> = <SPC> wait <SPC> = <SPC> 0.0 <NL> <TAB> for <SPC> a , <SPC> t <SPC> in <SPC> customers : <NL>          avai <SPC> = <SPC> max ( avai , <SPC> a ) <SPC> + <SPC> t <NL>          wait <SPC> += <SPC> avai <SPC> - <SPC> a <NL> <TAB> return <SPC> wait <SPC> / <SPC> len ( customers ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> avoidFlood ( self , <SPC> rains ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> i <SPC> = <SPC> len ( rains ) <SPC> - <SPC> 1 <NL> <TAB> for <SPC> lake <SPC> in <SPC> reversed ( rains ) : <NL>          lookup [ lake ] . append ( i ) <NL>          i <SPC> -= <SPC> 1 <NL> <TAB> result , <SPC> min_heap <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> lake <SPC> in <SPC> enumerate ( rains ) : <NL>          if <SPC> lake : <NL>              if <SPC> len ( lookup [ lake ] ) <SPC> >= <SPC> 2 : <NL>                  lookup [ lake ] . pop ( ) <NL>                  heapq . heappush ( min_heap , <SPC> lookup [ lake ] [ - 1 ] ) <NL>              result . append ( - 1 ) <NL>          elif <SPC> min_heap : <NL>              j <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>              if <SPC> j <SPC> < <SPC> i : <NL>                  return <SPC> [ ] <NL>              result . append ( rains [ j ] ) <NL>          else : <NL>              result . append ( 1 ) <NL> <TAB> return <SPC> result <SPC> if <SPC> not <SPC> min_heap <SPC> else <SPC> [ ] <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> backspaceCompare ( self , <SPC> S , <SPC> T ) : <NL> <NL> <TAB> def <SPC> findNextChar ( S ) : <NL>          skip <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( S ) ) ) : <NL>              if <SPC> S [ i ] <SPC> == <SPC> "#" : <NL>                  skip <SPC> += <SPC> 1 <NL>              elif <SPC> skip : <NL>                  skip <SPC> -= <SPC> 1 <NL>              else : <NL>                  yield <SPC> S [ i ] <NL> <NL> <TAB> return <SPC> all ( <NL>          x <SPC> == <SPC> y <SPC> for <SPC> x , <SPC> y <SPC> in <SPC> itertools . izip_longest ( findNextChar ( S ) , <SPC> findNextChar ( T ) ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> bagOfTokensScore ( self , <SPC> tokens , <SPC> P ) : <NL> <NL> <TAB> tokens . sort ( ) <NL> <TAB> result , <SPC> points <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( tokens ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          if <SPC> P <SPC> >= <SPC> tokens [ left ] : <NL>              P <SPC> -= <SPC> tokens [ left ] <NL>              left <SPC> += <SPC> 1 <NL>              points <SPC> += <SPC> 1 <NL>              result <SPC> = <SPC> max ( result , <SPC> points ) <NL>          elif <SPC> points <SPC> > <SPC> 0 : <NL>              points <SPC> -= <SPC> 1 <NL>              P <SPC> += <SPC> tokens [ right ] <NL>              right <SPC> -= <SPC> 1 <NL>          else : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> balanceBST ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> inorderTraversal ( root ) : <NL>          result , <SPC> stk <SPC> = <SPC> [ ] , <SPC> [ ( root , <SPC> False ) ] <NL>          while <SPC> stk : <NL>              node , <SPC> is_visited <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> node <SPC> is <SPC> None : <NL>                  continue <NL>              if <SPC> is_visited : <NL>                  result . append ( node . val ) <NL>              else : <NL>                  stk . append ( ( node . right , <SPC> False ) ) <NL>                  stk . append ( ( node , <SPC> True ) ) <NL>                  stk . append ( ( node . left , <SPC> False ) ) <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> sortedArrayToBst ( arr ) : <NL>          ROOT , <SPC> LEFT , <SPC> RIGHT <SPC> = <SPC> range ( 3 ) <NL>          result <SPC> = <SPC> [ None ] <NL>          stk <SPC> = <SPC> [ ( 0 , <SPC> len ( arr ) , <SPC> ROOT , <SPC> result ) ] <NL>          while <SPC> stk : <NL>              i , <SPC> j , <SPC> update , <SPC> ret <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> i <SPC> >= <SPC> j : <NL>                  continue <NL>              mid <SPC> = <SPC> i <SPC> + <SPC> ( j <SPC> - <SPC> i ) <SPC> // <SPC> 2 <NL>              node <SPC> = <SPC> TreeNode ( arr [ mid ] ) <NL>              if <SPC> update <SPC> == <SPC> ROOT : <NL>                  ret [ 0 ] <SPC> = <SPC> node <NL>              elif <SPC> update <SPC> == <SPC> LEFT : <NL>                  ret [ 0 ] . left <SPC> = <SPC> node <NL>              else : <NL>                  ret [ 0 ] . right <SPC> = <SPC> node <NL>              stk . append ( ( mid <SPC> + <SPC> 1 , <SPC> j , <SPC> RIGHT , <SPC> [ node ] ) ) <NL>              stk . append ( ( i , <SPC> mid , <SPC> LEFT , <SPC> [ node ] ) ) <NL>          return <SPC> result [ 0 ] <NL> <NL> <TAB> return <SPC> sortedArrayToBst ( inorderTraversal ( root ) ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> balanceBST ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> inorderTraversalHelper ( node , <SPC> arr ) : <NL>          if <SPC> not <SPC> node : <NL>              return <NL>          inorderTraversalHelper ( node . left , <SPC> arr ) <NL>          arr . append ( node . val ) <NL>          inorderTraversalHelper ( node . right , <SPC> arr ) <NL> <NL> <TAB> def <SPC> sortedArrayToBstHelper ( arr , <SPC> i , <SPC> j ) : <NL>          if <SPC> i <SPC> >= <SPC> j : <NL>              return <SPC> None <NL>          mid <SPC> = <SPC> i <SPC> + <SPC> ( j <SPC> - <SPC> i ) <SPC> // <SPC> 2 <NL>          node <SPC> = <SPC> TreeNode ( arr [ mid ] ) <NL>          node . left <SPC> = <SPC> sortedArrayToBstHelper ( arr , <SPC> i , <SPC> mid ) <NL>          node . right <SPC> = <SPC> sortedArrayToBstHelper ( arr , <SPC> mid <SPC> + <SPC> 1 , <SPC> j ) <NL>          return <SPC> node <NL> <NL> <TAB> arr <SPC> = <SPC> [ ] <NL> <TAB> inorderTraversalHelper ( root , <SPC> arr ) <NL> <TAB> return <SPC> sortedArrayToBstHelper ( arr , <SPC> 0 , <SPC> len ( arr ) ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isBalanced ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> getHeight ( root ) : <NL>          if <SPC> root <SPC> is <SPC> None : <NL>              return <SPC> 0 <NL>          left_height , <SPC> right_height <SPC> = <SPC> getHeight ( root . left ) , <SPC> getHeight ( root . right ) <NL>          if <SPC> ( <NL>              left_height <SPC> < <SPC> 0 <NL>              or <SPC> right_height <SPC> < <SPC> 0 <NL>              or <SPC> abs ( left_height <SPC> - <SPC> right_height ) <SPC> > <SPC> 1 <NL>          ) : <NL>              return <SPC> - 1 <NL>          return <SPC> max ( left_height , <SPC> right_height ) <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> getHeight ( root ) <SPC> >= <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> convertToBase7 ( self , <SPC> num ) : <NL> <TAB> if <SPC> num <SPC> < <SPC> 0 : <NL>          return <SPC> "-" <SPC> + <SPC> self . convertToBase7 ( - num ) <NL> <TAB> result <SPC> = <SPC> "" <NL> <TAB> while <SPC> num : <NL>          result <SPC> = <SPC> str ( num <SPC> % <SPC> 7 ) <SPC> + <SPC> result <NL>          num <SPC> //= <SPC> 7 <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> else <SPC> "0" <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> convertToBase7 ( self , <SPC> num ) : <NL> <NL> <TAB> if <SPC> num <SPC> < <SPC> 0 : <NL>          return <SPC> "-" <SPC> + <SPC> self . convertToBase7 ( - num ) <NL> <TAB> if <SPC> num <SPC> < <SPC> 7 : <NL>          return <SPC> str ( num ) <NL> <TAB> return <SPC> self . convertToBase7 ( num <SPC> // <SPC> 7 ) <SPC> + <SPC> str ( num <SPC> % <SPC> 7 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> calPoints ( self , <SPC> ops ) : <NL> <NL> <TAB> history <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> op <SPC> in <SPC> ops : <NL>          if <SPC> op <SPC> == <SPC> "+" : <NL>              history . append ( history [ - 1 ] <SPC> + <SPC> history [ - 2 ] ) <NL>          elif <SPC> op <SPC> == <SPC> "D" : <NL>              history . append ( history [ - 1 ] <SPC> * <SPC> 2 ) <NL>          elif <SPC> op <SPC> == <SPC> "C" : <NL>              history . pop ( ) <NL>          else : <NL>              history . append ( int ( op ) ) <NL> <TAB> return <SPC> sum ( history ) <NL> <NL> <NL> import <SPC> operator <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> calculate ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> compute ( operands , <SPC> operators ) : <NL>          right , <SPC> left <SPC> = <SPC> operands . pop ( ) , <SPC> operands . pop ( ) <NL>          operands . append ( ops [ operators . pop ( ) ] ( left , <SPC> right ) ) <NL> <NL> <TAB> ops <SPC> = <SPC> { <NL>          "+" : <SPC> operator . add , <NL>          "-" : <SPC> operator . sub , <NL>          "*" : <SPC> operator . mul , <NL>          "/" : <SPC> operator . div , <NL> <TAB> } <NL> <TAB> precedence <SPC> = <SPC> { "+" : <SPC> 0 , <SPC> "-" : <SPC> 0 , <SPC> "*" : <SPC> 1 , <SPC> "/" : <SPC> 1 } <NL> <TAB> operands , <SPC> operators , <SPC> operand <SPC> = <SPC> [ ] , <SPC> [ ] , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> s [ i ] . isdigit ( ) : <NL>              operand <SPC> = <SPC> operand <SPC> * <SPC> 10 <SPC> + <SPC> int ( s [ i ] ) <NL>              if <SPC> i <SPC> == <SPC> len ( s ) <SPC> - <SPC> 1 <SPC> or <SPC> not <SPC> s [ i <SPC> + <SPC> 1 ] . isdigit ( ) : <NL>                  operands . append ( operand ) <NL>                  operand <SPC> = <SPC> 0 <NL>          elif <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>              operators . append ( s [ i ] ) <NL>          elif <SPC> s [ i ] <SPC> == <SPC> ")" : <NL>              while <SPC> operators [ - 1 ] <SPC> != <SPC> "(" : <NL>                  compute ( operands , <SPC> operators ) <NL>              operators . pop ( ) <NL>          elif <SPC> s [ i ] <SPC> in <SPC> precedence : <NL>              while <SPC> ( <NL>                  operators <NL>                  and <SPC> operators [ - 1 ] <SPC> in <SPC> precedence <NL>                  and <SPC> precedence [ operators [ - 1 ] ] <SPC> >= <SPC> precedence [ s [ i ] ] <NL>              ) : <NL>                  compute ( operands , <SPC> operators ) <NL>              operators . append ( s [ i ] ) <NL> <TAB> while <SPC> operators : <NL>          compute ( operands , <SPC> operators ) <NL> <TAB> return <SPC> operands [ - 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> calculate ( self , <SPC> s ) : <NL> <TAB> operands , <SPC> operators <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> operand <SPC> = <SPC> "" <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>          if <SPC> s [ i ] . isdigit ( ) : <NL>              operand <SPC> += <SPC> s [ i ] <NL>              if <SPC> i <SPC> == <SPC> 0 <SPC> or <SPC> not <SPC> s [ i <SPC> - <SPC> 1 ] . isdigit ( ) : <NL>                  operands . append ( int ( operand [ : : - 1 ] ) ) <NL>                  operand <SPC> = <SPC> "" <NL>          elif <SPC> s [ i ] <SPC> == <SPC> ")" <SPC> or <SPC> s [ i ] <SPC> == <SPC> "*" <SPC> or <SPC> s [ i ] <SPC> == <SPC> "/" : <NL>              operators . append ( s [ i ] ) <NL>          elif <SPC> s [ i ] <SPC> == <SPC> "+" <SPC> or <SPC> s [ i ] <SPC> == <SPC> "-" : <NL>              while <SPC> operators <SPC> and <SPC> ( operators [ - 1 ] <SPC> == <SPC> "*" <SPC> or <SPC> operators [ - 1 ] <SPC> == <SPC> "/" ) : <NL>                  self . compute ( operands , <SPC> operators ) <NL>              operators . append ( s [ i ] ) <NL>          elif <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>              while <SPC> operators [ - 1 ] <SPC> != <SPC> ")" : <NL>                  self . compute ( operands , <SPC> operators ) <NL>              operators . pop ( ) <NL> <NL> <TAB> while <SPC> operators : <NL>          self . compute ( operands , <SPC> operators ) <NL> <NL> <TAB> return <SPC> operands [ - 1 ] <NL> <NL> <TAB> def <SPC> compute ( self , <SPC> operands , <SPC> operators ) : <NL> <TAB> left , <SPC> right <SPC> = <SPC> operands . pop ( ) , <SPC> operands . pop ( ) <NL> <TAB> op <SPC> = <SPC> operators . pop ( ) <NL> <TAB> if <SPC> op <SPC> == <SPC> "+" : <NL>          operands . append ( left <SPC> + <SPC> right ) <NL> <TAB> elif <SPC> op <SPC> == <SPC> "-" : <NL>          operands . append ( left <SPC> - <SPC> right ) <NL> <TAB> elif <SPC> op <SPC> == <SPC> "*" : <NL>          operands . append ( left <SPC> * <SPC> right ) <NL> <TAB> elif <SPC> op <SPC> == <SPC> "/" : <NL>          operands . append ( left <SPC> / <SPC> right ) <NL> <NL> <NL> import <SPC> operator <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> calculate ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> compute ( operands , <SPC> operators ) : <NL>          right , <SPC> left <SPC> = <SPC> operands . pop ( ) , <SPC> operands . pop ( ) <NL>          operands . append ( ops [ operators . pop ( ) ] ( left , <SPC> right ) ) <NL> <NL> <TAB> ops <SPC> = <SPC> { <NL>          "+" : <SPC> operator . add , <NL>          "-" : <SPC> operator . sub , <NL>          "*" : <SPC> operator . mul , <NL>          "/" : <SPC> operator . div , <NL> <TAB> } <NL> <TAB> precedence <SPC> = <SPC> { "+" : <SPC> 0 , <SPC> "-" : <SPC> 0 , <SPC> "*" : <SPC> 1 , <SPC> "/" : <SPC> 1 } <NL> <TAB> operands , <SPC> operators , <SPC> operand <SPC> = <SPC> [ ] , <SPC> [ ] , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> s [ i ] . isdigit ( ) : <NL>              operand <SPC> = <SPC> operand <SPC> * <SPC> 10 <SPC> + <SPC> int ( s [ i ] ) <NL>              if <SPC> i <SPC> == <SPC> len ( s ) <SPC> - <SPC> 1 <SPC> or <SPC> not <SPC> s [ i <SPC> + <SPC> 1 ] . isdigit ( ) : <NL>                  operands . append ( operand ) <NL>                  operand <SPC> = <SPC> 0 <NL>          elif <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>              operators . append ( s [ i ] ) <NL>          elif <SPC> s [ i ] <SPC> == <SPC> ")" : <NL>              while <SPC> operators [ - 1 ] <SPC> != <SPC> "(" : <NL>                  compute ( operands , <SPC> operators ) <NL>              operators . pop ( ) <NL>          elif <SPC> s [ i ] <SPC> in <SPC> precedence : <NL>              while <SPC> ( <NL>                  operators <NL>                  and <SPC> operators [ - 1 ] <SPC> in <SPC> precedence <NL>                  and <SPC> precedence [ operators [ - 1 ] ] <SPC> >= <SPC> precedence [ s [ i ] ] <NL>              ) : <NL>                  compute ( operands , <SPC> operators ) <NL>              operators . append ( s [ i ] ) <NL> <TAB> while <SPC> operators : <NL>          compute ( operands , <SPC> operators ) <NL> <TAB> return <SPC> operands [ - 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> calculate ( self , <SPC> s ) : <NL> <NL> <TAB> operands , <SPC> operators <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> operand <SPC> = <SPC> "" <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>          if <SPC> s [ i ] . isdigit ( ) : <NL>              operand <SPC> += <SPC> s [ i ] <NL>              if <SPC> i <SPC> == <SPC> 0 <SPC> or <SPC> not <SPC> s [ i <SPC> - <SPC> 1 ] . isdigit ( ) : <NL>                  operands . append ( int ( operand [ : : - 1 ] ) ) <NL>                  operand <SPC> = <SPC> "" <NL>          elif <SPC> s [ i ] <SPC> == <SPC> ")" <SPC> or <SPC> s [ i ] <SPC> == <SPC> "*" <SPC> or <SPC> s [ i ] <SPC> == <SPC> "/" : <NL>              operators . append ( s [ i ] ) <NL>          elif <SPC> s [ i ] <SPC> == <SPC> "+" <SPC> or <SPC> s [ i ] <SPC> == <SPC> "-" : <NL>              while <SPC> operators <SPC> and <SPC> ( operators [ - 1 ] <SPC> == <SPC> "*" <SPC> or <SPC> operators [ - 1 ] <SPC> == <SPC> "/" ) : <NL>                  self . compute ( operands , <SPC> operators ) <NL>              operators . append ( s [ i ] ) <NL>          elif <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>              while <SPC> operators [ - 1 ] <SPC> != <SPC> ")" : <NL>                  self . compute ( operands , <SPC> operators ) <NL>              operators . pop ( ) <NL> <NL> <TAB> while <SPC> operators : <NL>          self . compute ( operands , <SPC> operators ) <NL> <NL> <TAB> return <SPC> operands [ - 1 ] <NL> <NL> <TAB> def <SPC> compute ( self , <SPC> operands , <SPC> operators ) : <NL> <TAB> left , <SPC> right <SPC> = <SPC> operands . pop ( ) , <SPC> operands . pop ( ) <NL> <TAB> op <SPC> = <SPC> operators . pop ( ) <NL> <TAB> if <SPC> op <SPC> == <SPC> "+" : <NL>          operands . append ( left <SPC> + <SPC> right ) <NL> <TAB> elif <SPC> op <SPC> == <SPC> "-" : <NL>          operands . append ( left <SPC> - <SPC> right ) <NL> <TAB> elif <SPC> op <SPC> == <SPC> "*" : <NL>          operands . append ( left <SPC> * <SPC> right ) <NL> <TAB> elif <SPC> op <SPC> == <SPC> "/" : <NL>          operands . append ( left <SPC> / <SPC> right ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> import <SPC> operator <NL> <NL> <NL> class <SPC> Poly ( collections . Counter ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> expr = None ) : <NL> <TAB> if <SPC> expr <SPC> is <SPC> None : <NL>          return <NL> <TAB> if <SPC> expr . isdigit ( ) : <NL>          self . update ( { ( ) : <SPC> int ( expr ) } ) <NL> <TAB> else : <NL>          self [ ( expr , ) ] <SPC> += <SPC> 1 <NL> <NL> <TAB> def <SPC> __add__ ( self , <SPC> other ) : <NL> <TAB> self . update ( other ) <NL> <TAB> return <SPC> self <NL> <NL> <TAB> def <SPC> __sub__ ( self , <SPC> other ) : <NL> <TAB> self . update ( { k : <SPC> - v <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> other . iteritems ( ) } ) <NL> <TAB> return <SPC> self <NL> <NL> <TAB> def <SPC> __mul__ ( self , <SPC> other ) : <NL> <NL> <TAB> def <SPC> merge ( k1 , <SPC> k2 ) : <NL>          result <SPC> = <SPC> [ ] <NL>          i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL>          while <SPC> i <SPC> != <SPC> len ( k1 ) <SPC> or <SPC> j <SPC> != <SPC> len ( k2 ) : <NL>              if <SPC> j <SPC> == <SPC> len ( k2 ) : <NL>                  result . append ( k1 [ i ] ) <NL>                  i <SPC> += <SPC> 1 <NL>              elif <SPC> i <SPC> == <SPC> len ( k1 ) : <NL>                  result . append ( k2 [ j ] ) <NL>                  j <SPC> += <SPC> 1 <NL>              elif <SPC> k1 [ i ] <SPC> < <SPC> k2 [ j ] : <NL>                  result . append ( k1 [ i ] ) <NL>                  i <SPC> += <SPC> 1 <NL>              else : <NL>                  result . append ( k2 [ j ] ) <NL>                  j <SPC> += <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> result <SPC> = <SPC> Poly ( ) <NL> <TAB> for <SPC> k1 , <SPC> v1 <SPC> in <SPC> self . iteritems ( ) : <NL>          for <SPC> k2 , <SPC> v2 <SPC> in <SPC> other . iteritems ( ) : <NL>              result . update ( { tuple ( merge ( k1 , <SPC> k2 ) ) : <SPC> v1 <SPC> * <SPC> v2 } ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> eval ( self , <SPC> lookup ) : <NL> <TAB> result <SPC> = <SPC> Poly ( ) <NL> <TAB> for <SPC> polies , <SPC> c <SPC> in <SPC> self . iteritems ( ) : <NL>          key <SPC> = <SPC> [ ] <NL>          for <SPC> var <SPC> in <SPC> polies : <NL>              if <SPC> var <SPC> in <SPC> lookup : <NL>                  c <SPC> *= <SPC> lookup [ var ] <NL>              else : <NL>                  key . append ( var ) <NL>          result [ tuple ( key ) ] <SPC> += <SPC> c <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> to_list ( self ) : <NL> <TAB> return <SPC> [ <NL>          "*" . join ( ( str ( v ) , ) <SPC> + <SPC> k ) <NL>          for <SPC> k , <SPC> v <SPC> in <SPC> sorted ( self . iteritems ( ) , <SPC> key = lambda <SPC> x : <SPC> ( - len ( x [ 0 ] ) , <SPC> x [ 0 ] ) ) <NL>          if <SPC> v <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> basicCalculatorIV ( self , <SPC> expression , <SPC> evalvars , <SPC> evalints ) : <NL> <NL> <TAB> ops <SPC> = <SPC> { "+" : <SPC> operator . add , <SPC> "-" : <SPC> operator . sub , <SPC> "*" : <SPC> operator . mul } <NL> <NL> <TAB> def <SPC> compute ( operands , <SPC> operators ) : <NL>          right , <SPC> left <SPC> = <SPC> operands . pop ( ) , <SPC> operands . pop ( ) <NL>          operands . append ( ops [ operators . pop ( ) ] ( left , <SPC> right ) ) <NL> <NL> <TAB> def <SPC> parse ( s ) : <NL>          precedence <SPC> = <SPC> { "+" : <SPC> 0 , <SPC> "-" : <SPC> 0 , <SPC> "*" : <SPC> 1 } <NL>          operands , <SPC> operators , <SPC> operand <SPC> = <SPC> [ ] , <SPC> [ ] , <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>              if <SPC> s [ i ] . isalnum ( ) : <NL>                  operand . append ( s [ i ] ) <NL>                  if <SPC> i <SPC> == <SPC> len ( s ) <SPC> - <SPC> 1 <SPC> or <SPC> not <SPC> s [ i <SPC> + <SPC> 1 ] . isalnum ( ) : <NL>                      operands . append ( Poly ( "" . join ( operand ) ) ) <NL>                      operand <SPC> = <SPC> [ ] <NL>              elif <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>                  operators . append ( s [ i ] ) <NL>              elif <SPC> s [ i ] <SPC> == <SPC> ")" : <NL>                  while <SPC> operators [ - 1 ] <SPC> != <SPC> "(" : <NL>                      compute ( operands , <SPC> operators ) <NL>                  operators . pop ( ) <NL>              elif <SPC> s [ i ] <SPC> in <SPC> precedence : <NL>                  while <SPC> ( <NL>                      operators <NL>                      and <SPC> operators [ - 1 ] <SPC> in <SPC> precedence <NL>                      and <SPC> precedence [ operators [ - 1 ] ] <SPC> >= <SPC> precedence [ s [ i ] ] <NL>                  ) : <NL>                      compute ( operands , <SPC> operators ) <NL>                  operators . append ( s [ i ] ) <NL>          while <SPC> operators : <NL>              compute ( operands , <SPC> operators ) <NL>          return <SPC> operands [ - 1 ] <NL> <NL> <TAB> lookup <SPC> = <SPC> dict ( itertools . izip ( evalvars , <SPC> evalints ) ) <NL> <TAB> return <SPC> parse ( expression ) . eval ( lookup ) . to_list ( ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> basicCalculatorIV ( self , <SPC> expression , <SPC> evalvars , <SPC> evalints ) : <NL> <NL> <TAB> def <SPC> compute ( operands , <SPC> operators ) : <NL>          left , <SPC> right <SPC> = <SPC> operands . pop ( ) , <SPC> operands . pop ( ) <NL>          op <SPC> = <SPC> operators . pop ( ) <NL>          if <SPC> op <SPC> == <SPC> "+" : <NL>              operands . append ( left <SPC> + <SPC> right ) <NL>          elif <SPC> op <SPC> == <SPC> "-" : <NL>              operands . append ( left <SPC> - <SPC> right ) <NL>          elif <SPC> op <SPC> == <SPC> "*" : <NL>              operands . append ( left <SPC> * <SPC> right ) <NL> <NL> <TAB> def <SPC> parse ( s ) : <NL>          if <SPC> not <SPC> s : <NL>              return <SPC> Poly ( ) <NL>          operands , <SPC> operators <SPC> = <SPC> [ ] , <SPC> [ ] <NL>          operand <SPC> = <SPC> "" <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>              if <SPC> s [ i ] . isalnum ( ) : <NL>                  operand <SPC> += <SPC> s [ i ] <NL>                  if <SPC> i <SPC> == <SPC> 0 <SPC> or <SPC> not <SPC> s [ i <SPC> - <SPC> 1 ] . isalnum ( ) : <NL>                      operands . append ( Poly ( operand [ : : - 1 ] ) ) <NL>                      operand <SPC> = <SPC> "" <NL>              elif <SPC> s [ i ] <SPC> == <SPC> ")" <SPC> or <SPC> s [ i ] <SPC> == <SPC> "*" : <NL>                  operators . append ( s [ i ] ) <NL>              elif <SPC> s [ i ] <SPC> == <SPC> "+" <SPC> or <SPC> s [ i ] <SPC> == <SPC> "-" : <NL>                  while <SPC> operators <SPC> and <SPC> operators [ - 1 ] <SPC> == <SPC> "*" : <NL>                      compute ( operands , <SPC> operators ) <NL>                  operators . append ( s [ i ] ) <NL>              elif <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>                  while <SPC> operators [ - 1 ] <SPC> != <SPC> ")" : <NL>                      compute ( operands , <SPC> operators ) <NL>                  operators . pop ( ) <NL>          while <SPC> operators : <NL>              compute ( operands , <SPC> operators ) <NL>          return <SPC> operands [ - 1 ] <NL> <NL> <TAB> lookup <SPC> = <SPC> dict ( itertools . izip ( evalvars , <SPC> evalints ) ) <NL> <TAB> return <SPC> parse ( expression ) . eval ( lookup ) . to_list ( ) <NL> <NL> <NL> import <SPC> operator <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> calculate ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> compute ( operands , <SPC> operators ) : <NL>          right , <SPC> left <SPC> = <SPC> operands . pop ( ) , <SPC> operands . pop ( ) <NL>          operands . append ( ops [ operators . pop ( ) ] ( left , <SPC> right ) ) <NL> <NL> <TAB> ops <SPC> = <SPC> { <NL>          "+" : <SPC> operator . add , <NL>          "-" : <SPC> operator . sub , <NL>          "*" : <SPC> operator . mul , <NL>          "/" : <SPC> operator . div , <NL> <TAB> } <NL> <TAB> precedence <SPC> = <SPC> { "+" : <SPC> 0 , <SPC> "-" : <SPC> 0 , <SPC> "*" : <SPC> 1 , <SPC> "/" : <SPC> 1 } <NL> <TAB> operands , <SPC> operators , <SPC> operand <SPC> = <SPC> [ ] , <SPC> [ ] , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> s [ i ] . isdigit ( ) : <NL>              operand <SPC> = <SPC> operand <SPC> * <SPC> 10 <SPC> + <SPC> int ( s [ i ] ) <NL>              if <SPC> i <SPC> == <SPC> len ( s ) <SPC> - <SPC> 1 <SPC> or <SPC> not <SPC> s [ i <SPC> + <SPC> 1 ] . isdigit ( ) : <NL>                  operands . append ( operand ) <NL>                  operand <SPC> = <SPC> 0 <NL>          elif <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>              operators . append ( s [ i ] ) <NL>          elif <SPC> s [ i ] <SPC> == <SPC> ")" : <NL>              while <SPC> operators [ - 1 ] <SPC> != <SPC> "(" : <NL>                  compute ( operands , <SPC> operators ) <NL>              operators . pop ( ) <NL>          elif <SPC> s [ i ] <SPC> in <SPC> precedence : <NL>              while <SPC> ( <NL>                  operators <NL>                  and <SPC> operators [ - 1 ] <SPC> in <SPC> precedence <NL>                  and <SPC> precedence [ operators [ - 1 ] ] <SPC> >= <SPC> precedence [ s [ i ] ] <NL>              ) : <NL>                  compute ( operands , <SPC> operators ) <NL>              operators . append ( s [ i ] ) <NL> <TAB> while <SPC> operators : <NL>          compute ( operands , <SPC> operators ) <NL> <TAB> return <SPC> operands [ - 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> calculate ( self , <SPC> s ) : <NL> <TAB> operands , <SPC> operators <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> operand <SPC> = <SPC> "" <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>          if <SPC> s [ i ] . isdigit ( ) : <NL>              operand <SPC> += <SPC> s [ i ] <NL>              if <SPC> i <SPC> == <SPC> 0 <SPC> or <SPC> not <SPC> s [ i <SPC> - <SPC> 1 ] . isdigit ( ) : <NL>                  operands . append ( int ( operand [ : : - 1 ] ) ) <NL>                  operand <SPC> = <SPC> "" <NL>          elif <SPC> s [ i ] <SPC> == <SPC> ")" <SPC> or <SPC> s [ i ] <SPC> == <SPC> "+" <SPC> or <SPC> s [ i ] <SPC> == <SPC> "-" : <NL>              operators . append ( s [ i ] ) <NL>          elif <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>              while <SPC> operators [ - 1 ] <SPC> != <SPC> ")" : <NL>                  self . compute ( operands , <SPC> operators ) <NL>              operators . pop ( ) <NL> <NL> <TAB> while <SPC> operators : <NL>          self . compute ( operands , <SPC> operators ) <NL> <NL> <TAB> return <SPC> operands [ - 1 ] <NL> <NL> <TAB> def <SPC> compute ( self , <SPC> operands , <SPC> operators ) : <NL> <TAB> left , <SPC> right <SPC> = <SPC> operands . pop ( ) , <SPC> operands . pop ( ) <NL> <TAB> op <SPC> = <SPC> operators . pop ( ) <NL> <TAB> if <SPC> op <SPC> == <SPC> "+" : <NL>          operands . append ( left <SPC> + <SPC> right ) <NL> <TAB> elif <SPC> op <SPC> == <SPC> "-" : <NL>          operands . append ( left <SPC> - <SPC> right ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countBattleships ( self , <SPC> board ) : <NL> <NL> <TAB> if <SPC> not <SPC> board <SPC> or <SPC> not <SPC> board [ 0 ] : <NL>          return <SPC> 0 <NL> <NL> <TAB> cnt <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( board ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( board [ 0 ] ) ) : <NL>              cnt <SPC> += <SPC> int ( <NL>                  board [ i ] [ j ] <SPC> == <SPC> "X" <NL>                  and <SPC> ( i <SPC> == <SPC> 0 <SPC> or <SPC> board [ i <SPC> - <SPC> 1 ] [ j ] <SPC> != <SPC> "X" ) <NL>                  and <SPC> ( j <SPC> == <SPC> 0 <SPC> or <SPC> board [ i ] [ j <SPC> - <SPC> 1 ] <SPC> != <SPC> "X" ) <NL>              ) <NL> <TAB> return <SPC> cnt <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> constructArray ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> n <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          if <SPC> k <SPC> % <SPC> 2 : <NL>              result . append ( left ) <NL>              left <SPC> += <SPC> 1 <NL>          else : <NL>              result . append ( right ) <NL>              right <SPC> -= <SPC> 1 <NL>          if <SPC> k <SPC> > <SPC> 1 : <NL>              k <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countArrangement ( self , <SPC> N ) : <NL> <NL> <TAB> def <SPC> countArrangementHelper ( n , <SPC> arr ) : <NL>          if <SPC> n <SPC> <= <SPC> 0 : <NL>              return <SPC> 1 <NL>          count <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> arr [ i ] <SPC> % <SPC> n <SPC> == <SPC> 0 <SPC> or <SPC> n <SPC> % <SPC> arr [ i ] <SPC> == <SPC> 0 : <NL>                  arr [ i ] , <SPC> arr [ n <SPC> - <SPC> 1 ] <SPC> = <SPC> arr [ n <SPC> - <SPC> 1 ] , <SPC> arr [ i ] <NL>                  count <SPC> += <SPC> countArrangementHelper ( n <SPC> - <SPC> 1 , <SPC> arr ) <NL>                  arr [ i ] , <SPC> arr [ n <SPC> - <SPC> 1 ] <SPC> = <SPC> arr [ n <SPC> - <SPC> 1 ] , <SPC> arr [ i ] <NL>          return <SPC> count <NL> <NL> <TAB> return <SPC> countArrangementHelper ( N , <SPC> range ( 1 , <SPC> N <SPC> + <SPC> 1 ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> beautifulArray ( self , <SPC> N ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 1 ] <NL> <TAB> while <SPC> len ( result ) <SPC> < <SPC> N : <NL>          result <SPC> = <SPC> [ i <SPC> * <SPC> 2 <SPC> - <SPC> 1 <SPC> for <SPC> i <SPC> in <SPC> result ] <SPC> + <SPC> [ i <SPC> * <SPC> 2 <SPC> for <SPC> i <SPC> in <SPC> result ] <NL> <TAB> return <SPC> [ i <SPC> for <SPC> i <SPC> in <SPC> result <SPC> if <SPC> i <SPC> <= <SPC> N ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> beforeAndAfterPuzzles ( self , <SPC> phrases ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> phrase <SPC> in <SPC> enumerate ( phrases ) : <NL>          right <SPC> = <SPC> phrase . rfind ( " " ) <NL>          word <SPC> = <SPC> phrase <SPC> if <SPC> right <SPC> == <SPC> - 1 <SPC> else <SPC> phrase [ right <SPC> + <SPC> 1 : ] <NL>          lookup [ word ] . append ( i ) <NL> <NL> <TAB> result_set <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i , <SPC> phrase <SPC> in <SPC> enumerate ( phrases ) : <NL>          left <SPC> = <SPC> phrase . find ( " " ) <NL>          word <SPC> = <SPC> phrase <SPC> if <SPC> left <SPC> == <SPC> - 1 <SPC> else <SPC> phrase [ : left ] <NL>          if <SPC> word <SPC> not <SPC> in <SPC> lookup : <NL>              continue <NL>          for <SPC> j <SPC> in <SPC> lookup [ word ] : <NL>              if <SPC> j <SPC> == <SPC> i : <NL>                  continue <NL>              result_set . add ( phrases [ j ] <SPC> + <SPC> phrase [ len ( word ) : ] ) <NL> <TAB> return <SPC> sorted ( result_set ) <NL> <NL> <NL> from <SPC> random <SPC> import <SPC> randint <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minTotalDistance ( self , <SPC> grid ) : <NL> <NL> <TAB> x <SPC> = <SPC> [ i <SPC> for <SPC> i , <SPC> row <SPC> in <SPC> enumerate ( grid ) <SPC> for <SPC> v <SPC> in <SPC> row <SPC> if <SPC> v <SPC> == <SPC> 1 ] <NL> <TAB> y <SPC> = <SPC> [ j <SPC> for <SPC> row <SPC> in <SPC> grid <SPC> for <SPC> j , <SPC> v <SPC> in <SPC> enumerate ( row ) <SPC> if <SPC> v <SPC> == <SPC> 1 ] <NL> <TAB> mid_x <SPC> = <SPC> self . findKthLargest ( x , <SPC> len ( x ) <SPC> / <SPC> 2 <SPC> + <SPC> 1 ) <NL> <TAB> mid_y <SPC> = <SPC> self . findKthLargest ( y , <SPC> len ( y ) <SPC> / <SPC> 2 <SPC> + <SPC> 1 ) <NL> <NL> <TAB> return <SPC> sum ( <NL>          [ <NL>              abs ( mid_x <SPC> - <SPC> i ) <SPC> + <SPC> abs ( mid_y <SPC> - <SPC> j ) <NL>              for <SPC> i , <SPC> row <SPC> in <SPC> enumerate ( grid ) <NL>              for <SPC> j , <SPC> v <SPC> in <SPC> enumerate ( row ) <NL>              if <SPC> v <SPC> == <SPC> 1 <NL>          ] <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> findKthLargest ( self , <SPC> nums , <SPC> k ) : <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          pivot_idx <SPC> = <SPC> randint ( left , <SPC> right ) <NL>          new_pivot_idx <SPC> = <SPC> self . PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) <NL>          if <SPC> new_pivot_idx <SPC> == <SPC> k <SPC> - <SPC> 1 : <NL>              return <SPC> nums [ new_pivot_idx ] <NL>          elif <SPC> new_pivot_idx <SPC> > <SPC> k <SPC> - <SPC> 1 : <NL>              right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> def <SPC> PartitionAroundPivot ( self , <SPC> left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) : <NL> <TAB> pivot_value <SPC> = <SPC> nums [ pivot_idx ] <NL> <TAB> new_pivot_idx <SPC> = <SPC> left <NL> <TAB> nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>          if <SPC> nums [ i ] <SPC> > <SPC> pivot_value : <NL>              nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>              new_pivot_idx <SPC> += <SPC> 1 <NL> <NL> <TAB> nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL> <TAB> return <SPC> new_pivot_idx <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getMinDistSum ( self , <SPC> positions ) : <NL> <NL> <TAB> EPS <SPC> = <SPC> 1e-6 <NL> <NL> <TAB> def <SPC> norm ( p1 , <SPC> p2 ) : <NL>          return <SPC> ( ( p1 [ 0 ] <SPC> - <SPC> p2 [ 0 ] ) <SPC> ** <SPC> 2 <SPC> + <SPC> ( p1 [ 1 ] <SPC> - <SPC> p2 [ 1 ] ) <SPC> ** <SPC> 2 ) <SPC> ** <SPC> 0.5 <NL> <NL> <TAB> def <SPC> geometry_median ( positions , <SPC> median ) : <NL>          numerator , <SPC> denominator <SPC> = <SPC> [ 0.0 , <SPC> 0.0 ] , <SPC> 0.0 <NL>          for <SPC> p <SPC> in <SPC> positions : <NL>              l <SPC> = <SPC> norm ( median , <SPC> p ) <NL>              if <SPC> not <SPC> l : <NL>                  continue <NL>              numerator [ 0 ] <SPC> += <SPC> p [ 0 ] <SPC> / <SPC> l <NL>              numerator [ 1 ] <SPC> += <SPC> p [ 1 ] <SPC> / <SPC> l <NL>              denominator <SPC> += <SPC> 1 <SPC> / <SPC> l <NL>          if <SPC> denominator <SPC> == <SPC> 0.0 : <NL>              return <SPC> True , <SPC> None <NL>          return <SPC> False , <SPC> [ numerator [ 0 ] <SPC> / <SPC> denominator , <SPC> numerator [ 1 ] <SPC> / <SPC> denominator ] <NL> <NL> <TAB> median <SPC> = <SPC> [ <NL>          float ( sum ( p [ 0 ] <SPC> for <SPC> p <SPC> in <SPC> positions ) ) <SPC> / <SPC> len ( positions ) , <NL>          float ( sum ( p [ 1 ] <SPC> for <SPC> p <SPC> in <SPC> positions ) ) <SPC> / <SPC> len ( positions ) , <NL> <TAB> ] <NL> <TAB> prev_median <SPC> = <SPC> [ float ( "-inf" ) , <SPC> float ( "-inf" ) ] <NL> <TAB> while <SPC> norm ( median , <SPC> prev_median ) <SPC> * <SPC> len ( positions ) <SPC> > <SPC> EPS : <NL>          stopped , <SPC> new_median <SPC> = <SPC> geometry_median ( positions , <SPC> median ) <NL>          if <SPC> stopped : <NL>              break <NL>          median , <SPC> prev_median <SPC> = <SPC> new_median , <SPC> median <NL> <TAB> return <SPC> sum ( norm ( median , <SPC> p ) <SPC> for <SPC> p <SPC> in <SPC> positions ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> getMinDistSum ( self , <SPC> positions ) : <NL> <NL> <TAB> DIRECTIONS <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> EPS <SPC> = <SPC> 1e-6 <NL> <NL> <TAB> def <SPC> dist ( positions , <SPC> p ) : <NL>          return <SPC> sum ( ( ( p [ 0 ] <SPC> - <SPC> x ) <SPC> ** <SPC> 2 <SPC> + <SPC> ( p [ 1 ] <SPC> - <SPC> y ) <SPC> ** <SPC> 2 ) <SPC> ** <SPC> 0.5 <SPC> for <SPC> x , <SPC> y <SPC> in <SPC> positions ) <NL> <NL> <TAB> median <SPC> = <SPC> [ 0.0 , <SPC> 0.0 ] <NL> <TAB> median [ 0 ] <SPC> = <SPC> float ( sum ( x <SPC> for <SPC> x , <SPC> _ <SPC> in <SPC> positions ) ) <SPC> / <SPC> len ( positions ) <NL> <TAB> median [ 1 ] <SPC> = <SPC> float ( sum ( y <SPC> for <SPC> _ , <SPC> y <SPC> in <SPC> positions ) ) <SPC> / <SPC> len ( positions ) <NL> <TAB> result <SPC> = <SPC> dist ( positions , <SPC> median ) <NL> <TAB> delta <SPC> = <SPC> float ( <NL>          max ( <NL>              max ( positions , <SPC> key = lambda <SPC> x : <SPC> x [ 0 ] ) [ 0 ] , <NL>              max ( positions , <SPC> key = lambda <SPC> x : <SPC> x [ 1 ] ) [ 1 ] , <NL>          ) <NL> <TAB> ) <SPC> - <SPC> float ( <NL>          min ( <NL>              min ( positions , <SPC> key = lambda <SPC> x : <SPC> x [ 0 ] ) [ 0 ] , <NL>              min ( positions , <SPC> key = lambda <SPC> x : <SPC> x [ 1 ] ) [ 1 ] , <NL>          ) <NL> <TAB> ) <NL> <TAB> while <SPC> delta <SPC> > <SPC> EPS : <NL>          for <SPC> dx , <SPC> dy <SPC> in <SPC> DIRECTIONS : <NL>              new_median <SPC> = <SPC> [ median [ 0 ] <SPC> + <SPC> delta <SPC> * <SPC> dx , <SPC> median [ 1 ] <SPC> + <SPC> delta <SPC> * <SPC> dy ] <NL>              nd <SPC> = <SPC> dist ( positions , <SPC> new_median ) <NL>              if <SPC> nd <SPC> < <SPC> result : <NL>                  result <SPC> = <SPC> nd <NL>                  median <SPC> = <SPC> new_median <NL>                  break <NL>          else : <NL>              delta <SPC> /= <SPC> 2.0 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxScoreSightseeingPair ( self , <SPC> A ) : <NL> <NL> <TAB> result , <SPC> curr <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> A : <NL>          result <SPC> = <SPC> max ( result , <SPC> curr <SPC> + <SPC> x ) <NL>          curr <SPC> = <SPC> max ( curr , <SPC> x ) <SPC> - <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> SegmentTree ( object ) : <NL> <TAB> def <SPC> __init__ ( <NL>          self , <NL>          N , <NL>          build_fn = lambda <SPC> x , <SPC> y : <SPC> [ y ] <SPC> * <SPC> ( 2 <SPC> * <SPC> x ) , <NL>          query_fn = lambda <SPC> x , <SPC> y : <SPC> y <NL>          if <SPC> x <SPC> is <SPC> None <NL>          else <SPC> max ( x , <SPC> y ) , <NL>          update_fn = lambda <SPC> x , <SPC> y : <SPC> y , <NL>          default_val = 0 , <NL> <TAB> ) : <NL> <TAB> self . N <SPC> = <SPC> N <NL> <TAB> self . H <SPC> = <SPC> ( N <SPC> - <SPC> 1 ) . bit_length ( ) <NL> <TAB> self . query_fn <SPC> = <SPC> query_fn <NL> <TAB> self . update_fn <SPC> = <SPC> update_fn <NL> <TAB> self . default_val <SPC> = <SPC> default_val <NL> <TAB> self . tree <SPC> = <SPC> build_fn ( N , <SPC> default_val ) <NL> <TAB> self . lazy <SPC> = <SPC> [ None ] <SPC> * <SPC> N <NL> <NL> <TAB> def <SPC> __apply ( self , <SPC> x , <SPC> val ) : <NL> <TAB> self . tree [ x ] <SPC> = <SPC> self . update_fn ( self . tree [ x ] , <SPC> val ) <NL> <TAB> if <SPC> x <SPC> < <SPC> self . N : <NL>          self . lazy [ x ] <SPC> = <SPC> self . update_fn ( self . lazy [ x ] , <SPC> val ) <NL> <NL> <TAB> def <SPC> update ( self , <SPC> L , <SPC> R , <SPC> h ) : <NL> <NL> <TAB> def <SPC> pull ( x ) : <NL>          while <SPC> x <SPC> > <SPC> 1 : <NL>              x <SPC> //= <SPC> 2 <NL>              self . tree [ x ] <SPC> = <SPC> self . query_fn ( <NL>                  self . tree [ x <SPC> * <SPC> 2 ] , <SPC> self . tree [ x <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] ) <NL>              if <SPC> self . lazy [ x ] <SPC> is <SPC> not <SPC> None : <NL>                  self . tree [ x ] <SPC> = <SPC> self . update_fn ( self . tree [ x ] , <SPC> self . lazy [ x ] ) <NL> <NL> <TAB> L <SPC> += <SPC> self . N <NL> <TAB> R <SPC> += <SPC> self . N <NL> <TAB> L0 , <SPC> R0 <SPC> = <SPC> L , <SPC> R <NL> <TAB> while <SPC> L <SPC> <= <SPC> R : <NL>          if <SPC> L <SPC> & <SPC> 1 : <NL>              self . __apply ( L , <SPC> h ) <NL>              L <SPC> += <SPC> 1 <NL>          if <SPC> R <SPC> & <SPC> 1 <SPC> == <SPC> 0 : <NL>              self . __apply ( R , <SPC> h ) <NL>              R <SPC> -= <SPC> 1 <NL>          L <SPC> //= <SPC> 2 <NL>          R <SPC> //= <SPC> 2 <NL> <TAB> pull ( L0 ) <NL> <TAB> pull ( R0 ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> L , <SPC> R ) : <NL> <NL> <TAB> def <SPC> push ( x ) : <NL>          n <SPC> = <SPC> 2 <SPC> ** <SPC> self . H <NL>          while <SPC> n <SPC> != <SPC> 1 : <NL>              y <SPC> = <SPC> x <SPC> // <SPC> n <NL>              if <SPC> self . lazy [ y ] <SPC> is <SPC> not <SPC> None : <NL>                  self . __apply ( y <SPC> * <SPC> 2 , <SPC> self . lazy [ y ] ) <NL>                  self . __apply ( y <SPC> * <SPC> 2 <SPC> + <SPC> 1 , <SPC> self . lazy [ y ] ) <NL>                  self . lazy [ y ] <SPC> = <SPC> None <NL>              n <SPC> //= <SPC> 2 <NL> <NL> <TAB> result <SPC> = <SPC> None <NL> <TAB> if <SPC> L <SPC> > <SPC> R : <NL>          return <SPC> result <NL> <NL> <TAB> L <SPC> += <SPC> self . N <NL> <TAB> R <SPC> += <SPC> self . N <NL> <TAB> push ( L ) <NL> <TAB> push ( R ) <NL> <TAB> while <SPC> L <SPC> <= <SPC> R : <NL>          if <SPC> L <SPC> & <SPC> 1 : <NL>              result <SPC> = <SPC> self . query_fn ( result , <SPC> self . tree [ L ] ) <NL>              L <SPC> += <SPC> 1 <NL>          if <SPC> R <SPC> & <SPC> 1 <SPC> == <SPC> 0 : <NL>              result <SPC> = <SPC> self . query_fn ( result , <SPC> self . tree [ R ] ) <NL>              R <SPC> -= <SPC> 1 <NL>          L <SPC> //= <SPC> 2 <NL>          R <SPC> //= <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> __str__ ( self ) : <NL> <TAB> showList <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . N ) : <NL>          showList . append ( self . query ( i , <SPC> i ) ) <NL> <TAB> return <SPC> "," . join ( map ( str , <SPC> showList ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> bestTeamScore ( self , <SPC> scores , <SPC> ages ) : <NL> <NL> <TAB> players <SPC> = <SPC> sorted ( zip ( scores , <SPC> ages ) ) <NL> <TAB> sorted_ages <SPC> = <SPC> sorted ( set ( ages ) ) <NL> <TAB> lookup <SPC> = <SPC> { age : <SPC> i <SPC> for <SPC> i , <SPC> age <SPC> in <SPC> enumerate ( sorted_ages ) } <NL> <TAB> segment_tree <SPC> = <SPC> SegmentTree ( len ( lookup ) ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> score , <SPC> age <SPC> in <SPC> players : <NL>          segment_tree . update ( <NL>              lookup [ age ] , <SPC> lookup [ age ] , <SPC> segment_tree . query ( <NL>                  0 , <SPC> lookup [ age ] ) <SPC> + <SPC> score <NL>          ) <NL> <TAB> return <SPC> segment_tree . query ( 0 , <SPC> len ( lookup ) <SPC> - <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> bestTeamScore ( self , <SPC> scores , <SPC> ages ) : <NL> <NL> <TAB> players <SPC> = <SPC> sorted ( zip ( ages , <SPC> scores ) ) <NL> <TAB> sorted_scores <SPC> = <SPC> sorted ( set ( scores ) ) <NL> <TAB> lookup <SPC> = <SPC> { <NL>          score : <SPC> i <SPC> for <SPC> i , <SPC> score <SPC> in <SPC> enumerate ( sorted_scores ) <NL> <TAB> } <NL> <TAB> segment_tree <SPC> = <SPC> SegmentTree ( len ( lookup ) ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> age , <SPC> score <SPC> in <SPC> players : <NL>          segment_tree . update ( <NL>              lookup [ score ] , <NL>              lookup [ score ] , <NL>              segment_tree . query ( 0 , <SPC> lookup [ score ] ) <SPC> + <SPC> score , <NL>          ) <NL> <TAB> return <SPC> segment_tree . query ( 0 , <SPC> len ( lookup ) <SPC> - <SPC> 1 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> bestTeamScore ( self , <SPC> scores , <SPC> ages ) : <NL> <NL> <TAB> players <SPC> = <SPC> sorted ( zip ( scores , <SPC> ages ) ) <NL> <TAB> sorted_ages <SPC> = <SPC> sorted ( set ( ages ) ) <NL> <TAB> dp <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> score , <SPC> age <SPC> in <SPC> players : <NL>          dp [ age ] <SPC> = <SPC> max ( dp [ a ] <SPC> for <SPC> a <SPC> in <SPC> sorted_ages <SPC> if <SPC> a <SPC> <= <SPC> age ) <SPC> + <SPC> score <NL> <TAB> return <SPC> max ( dp . itervalues ( ) ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> bestTeamScore ( self , <SPC> scores , <SPC> ages ) : <NL> <NL> <TAB> players <SPC> = <SPC> sorted ( zip ( ages , <SPC> scores ) ) <NL> <TAB> sorted_scores <SPC> = <SPC> sorted ( set ( scores ) ) <NL> <TAB> dp <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> age , <SPC> score <SPC> in <SPC> players : <NL>          dp [ score ] <SPC> = <SPC> max ( dp [ s ] <SPC> for <SPC> s <SPC> in <SPC> sorted_scores <SPC> if <SPC> s <SPC> <= <SPC> score ) <SPC> + <SPC> score <NL> <TAB> return <SPC> max ( dp . itervalues ( ) ) <NL> <NL> <NL> class <SPC> Solution5 ( object ) : <NL> <TAB> def <SPC> bestTeamScore ( self , <SPC> scores , <SPC> ages ) : <NL> <NL> <TAB> players <SPC> = <SPC> sorted ( zip ( scores , <SPC> ages ) ) <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( players ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( players ) ) : <NL>          dp [ i ] <SPC> = <SPC> players [ i ] [ 0 ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( i ) : <NL>              if <SPC> players [ j ] [ 1 ] <SPC> <= <SPC> players [ i ] [ 1 ] : <NL>                  dp [ i ] <SPC> = <SPC> max ( dp [ i ] , <SPC> dp [ j ] <SPC> + <SPC> players [ i ] [ 0 ] ) <NL>          result <SPC> = <SPC> max ( result , <SPC> dp [ i ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution6 ( object ) : <NL> <TAB> def <SPC> bestTeamScore ( self , <SPC> scores , <SPC> ages ) : <NL> <NL> <TAB> players <SPC> = <SPC> sorted ( zip ( ages , <SPC> scores ) ) <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( players ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( players ) ) : <NL>          dp [ i ] <SPC> = <SPC> players [ i ] [ 1 ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( i ) : <NL>              if <SPC> players [ j ] [ 1 ] <SPC> <= <SPC> players [ i ] [ 1 ] : <NL>                  dp [ i ] <SPC> = <SPC> max ( dp [ i ] , <SPC> dp [ j ] <SPC> + <SPC> players [ i ] [ 1 ] ) <NL>          result <SPC> = <SPC> max ( result , <SPC> dp [ i ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maxProfit ( self , <SPC> prices ) : <NL> <TAB> profit <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( prices ) <SPC> - <SPC> 1 ) : <NL>          profit <SPC> += <SPC> max ( 0 , <SPC> prices [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> prices [ i ] ) <NL> <TAB> return <SPC> profit <NL> <NL> <TAB> def <SPC> maxProfit2 ( self , <SPC> prices ) : <NL> <TAB> return <SPC> sum ( <NL>          map ( lambda <SPC> x : <SPC> max ( prices [ x <SPC> + <SPC> 1 ] <SPC> - <SPC> prices [ x ] , <SPC> 0 ) , <NL>              xrange ( len ( prices [ : - 1 ] ) ) ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProfit ( self , <SPC> prices ) : <NL> <NL> <TAB> hold1 , <SPC> hold2 <SPC> = <SPC> float ( "-inf" ) , <SPC> float ( "-inf" ) <NL> <TAB> release1 , <SPC> release2 <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> prices : <NL>          release1 <SPC> = <SPC> max ( release1 , <SPC> hold1 <SPC> + <SPC> i ) <NL>          hold1 <SPC> = <SPC> max ( hold1 , <SPC> - i ) <NL>          release2 <SPC> = <SPC> max ( release2 , <SPC> hold2 <SPC> + <SPC> i ) <NL>          hold2 <SPC> = <SPC> max ( hold2 , <SPC> release1 <SPC> - <SPC> i ) <NL> <TAB> return <SPC> release2 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxProfit ( self , <SPC> prices ) : <NL> <NL> <TAB> def <SPC> maxAtMostKPairsProfit ( prices , <SPC> k ) : <NL>          max_buy <SPC> = <SPC> [ float ( "-inf" ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( k <SPC> + <SPC> 1 ) ] <NL>          max_sell <SPC> = <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( k <SPC> + <SPC> 1 ) ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( prices ) ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> k <SPC> + <SPC> 1 ) : <NL>                  max_buy [ j ] <SPC> = <SPC> max ( max_buy [ j ] , <SPC> max_sell [ j <SPC> - <SPC> 1 ] <SPC> - <SPC> prices [ i ] ) <NL>                  max_sell [ j ] <SPC> = <SPC> max ( max_sell [ j ] , <SPC> max_buy [ j ] <SPC> + <SPC> prices [ i ] ) <NL>          return <SPC> max_sell [ k ] <NL> <NL> <TAB> return <SPC> maxAtMostKPairsProfit ( prices , <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <NL> <TAB> def <SPC> maxProfit ( self , <SPC> prices ) : <NL> <TAB> min_price , <SPC> max_profit_from_left , <SPC> max_profits_from_left <SPC> = <SPC> float ( "inf" ) , <SPC> 0 , <SPC> [ <NL> <TAB> ] <NL> <TAB> for <SPC> price <SPC> in <SPC> prices : <NL>          min_price <SPC> = <SPC> min ( min_price , <SPC> price ) <NL>          max_profit_from_left <SPC> = <SPC> max ( max_profit_from_left , <SPC> price <SPC> - <SPC> min_price ) <NL>          max_profits_from_left . append ( max_profit_from_left ) <NL> <NL> <TAB> max_price , <SPC> max_profit_from_right , <SPC> max_profits_from_right <SPC> = <SPC> 0 , <SPC> 0 , <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( range ( len ( prices ) ) ) : <NL>          max_price <SPC> = <SPC> max ( max_price , <SPC> prices [ i ] ) <NL>          max_profit_from_right <SPC> = <SPC> max ( <NL>              max_profit_from_right , <SPC> max_price <SPC> - <SPC> prices [ i ] ) <NL>          max_profits_from_right . insert ( 0 , <SPC> max_profit_from_right ) <NL> <NL> <TAB> max_profit <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( prices ) ) : <NL>          max_profit <SPC> = <SPC> max ( <NL>              max_profit , <SPC> max_profits_from_left [ i ] <SPC> + <SPC> max_profits_from_right [ i ] <NL>          ) <NL> <NL> <TAB> return <SPC> max_profit <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProfit ( self , <SPC> k , <SPC> prices ) : <NL> <NL> <TAB> def <SPC> nth_element ( nums , <SPC> n , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) : <NL>          def <SPC> tri_partition ( nums , <SPC> left , <SPC> right , <SPC> target , <SPC> compare ) : <NL>              mid <SPC> = <SPC> left <NL>              while <SPC> mid <SPC> <= <SPC> right : <NL>                  if <SPC> nums [ mid ] <SPC> == <SPC> target : <NL>                      mid <SPC> += <SPC> 1 <NL>                  elif <SPC> compare ( nums [ mid ] , <SPC> target ) : <NL>                      nums [ left ] , <SPC> nums [ mid ] <SPC> = <SPC> nums [ mid ] , <SPC> nums [ left ] <NL>                      left <SPC> += <SPC> 1 <NL>                      mid <SPC> += <SPC> 1 <NL>                  else : <NL>                      nums [ mid ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ mid ] <NL>                      right <SPC> -= <SPC> 1 <NL>              return <SPC> left , <SPC> right <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              pivot_left , <SPC> pivot_right <SPC> = <SPC> tri_partition ( <NL>                  nums , <SPC> left , <SPC> right , <SPC> nums [ pivot_idx ] , <SPC> compare <NL>              ) <NL>              if <SPC> pivot_left <SPC> <= <SPC> n <SPC> <= <SPC> pivot_right : <NL>                  return <NL>              elif <SPC> pivot_left <SPC> > <SPC> n : <NL>                  right <SPC> = <SPC> pivot_left <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> pivot_right <SPC> + <SPC> 1 <NL> <NL> <TAB> profits <SPC> = <SPC> [ ] <NL> <TAB> v_p_stk <SPC> = <SPC> [ ] <NL> <TAB> v , <SPC> p <SPC> = <SPC> - 1 , <SPC> - 1 <NL> <TAB> while <SPC> p <SPC> + <SPC> 1 <SPC> < <SPC> len ( <NL>          prices <NL> <TAB> ) : <NL>          for <SPC> v <SPC> in <SPC> xrange ( p <SPC> + <SPC> 1 , <SPC> len ( prices ) <SPC> - <SPC> 1 ) : <NL>              if <SPC> prices [ v ] <SPC> < <SPC> prices [ v <SPC> + <SPC> 1 ] : <NL>                  break <NL>          else : <NL>              v <SPC> = <SPC> len ( prices ) <SPC> - <SPC> 1 <NL>          for <SPC> p <SPC> in <SPC> xrange ( v , <SPC> len ( prices ) <SPC> - <SPC> 1 ) : <NL>              if <SPC> prices [ p ] <SPC> > <SPC> prices [ p <SPC> + <SPC> 1 ] : <NL>                  break <NL>          else : <NL>              p <SPC> = <SPC> len ( prices ) <SPC> - <SPC> 1 <NL>          while <SPC> v_p_stk <SPC> and <SPC> prices [ v_p_stk [ - 1 ] [ 0 ] ] <SPC> > <SPC> prices [ v ] : <NL>              last_v , <SPC> last_p <SPC> = <SPC> v_p_stk . pop ( ) <NL>              profits . append ( <NL>                  prices [ last_p ] <SPC> - <SPC> prices [ last_v ] <NL>              ) <NL>          while <SPC> v_p_stk <SPC> and <SPC> prices [ v_p_stk [ - 1 ] [ 1 ] ] <SPC> <= <SPC> prices [ p ] : <NL> <NL>              last_v , <SPC> last_p <SPC> = <SPC> v_p_stk . pop ( ) <NL>              profits . append ( <NL>                  prices [ last_p ] <SPC> - <SPC> prices [ v ] <NL>              ) <NL>              v <SPC> = <SPC> last_v <NL>          v_p_stk . append ( <NL>              ( v , <SPC> p ) <NL>          ) <NL> <TAB> while <SPC> v_p_stk : <NL>          last_v , <SPC> last_p <SPC> = <SPC> v_p_stk . pop ( ) <NL>          profits . append ( <NL>              prices [ last_p ] <SPC> - <SPC> prices [ last_v ] <NL>          ) <NL> <TAB> if <SPC> k <SPC> > <SPC> len ( profits ) : <NL>          k <SPC> = <SPC> len ( profits ) <NL> <TAB> else : <NL>          nth_element ( profits , <SPC> k <SPC> - <SPC> 1 , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> > <SPC> b ) <NL> <TAB> return <SPC> sum ( <NL>          profits [ i ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( k ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxProfit ( self , <SPC> k , <SPC> prices ) : <NL> <NL> <TAB> def <SPC> maxAtMostNPairsProfit ( sprices ) : <NL>          profit <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( prices ) <SPC> - <SPC> 1 ) : <NL>              profit <SPC> += <SPC> max ( 0 , <SPC> prices [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> prices [ i ] ) <NL>          return <SPC> profit <NL> <NL> <TAB> def <SPC> maxAtMostKPairsProfit ( prices , <SPC> k ) : <NL>          max_buy <SPC> = <SPC> [ float ( "-inf" ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( k <SPC> + <SPC> 1 ) ] <NL>          max_sell <SPC> = <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( k <SPC> + <SPC> 1 ) ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( prices ) ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> k <SPC> + <SPC> 1 ) : <NL>                  max_buy [ j ] <SPC> = <SPC> max ( max_buy [ j ] , <SPC> max_sell [ j <SPC> - <SPC> 1 ] <SPC> - <SPC> prices [ i ] ) <NL>                  max_sell [ j ] <SPC> = <SPC> max ( max_sell [ j ] , <SPC> max_buy [ j ] <SPC> + <SPC> prices [ i ] ) <NL>          return <SPC> max_sell [ k ] <NL> <NL> <TAB> if <SPC> k <SPC> >= <SPC> len ( prices ) <SPC> // <SPC> 2 : <NL>          return <SPC> maxAtMostNPairsProfit ( prices ) <NL> <NL> <TAB> return <SPC> maxAtMostKPairsProfit ( prices , <SPC> k ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProfit ( self , <SPC> prices ) : <NL> <NL> <TAB> if <SPC> not <SPC> prices : <NL>          return <SPC> 0 <NL> <TAB> buy , <SPC> sell , <SPC> coolDown <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 , <SPC> [ 0 ] <SPC> * <SPC> 2 , <SPC> [ 0 ] <SPC> * <SPC> 2 <NL> <TAB> buy [ 0 ] <SPC> = <SPC> - prices [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( prices ) ) : <NL> <NL>          buy [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> max ( buy [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] , <SPC> coolDown [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] <SPC> - <SPC> prices [ i ] ) <NL> <NL>          sell [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> buy [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] <SPC> + <SPC> prices [ i ] <NL> <NL>          coolDown [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> max ( coolDown [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] , <SPC> sell [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] ) <NL> <TAB> return <SPC> max ( coolDown [ ( len ( prices ) <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] , <SPC> sell [ ( len ( prices ) <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProfit ( self , <SPC> prices , <SPC> fee ) : <NL> <NL> <TAB> cash , <SPC> hold <SPC> = <SPC> 0 , <SPC> - prices [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( prices ) ) : <NL>          cash <SPC> = <SPC> max ( cash , <SPC> hold <SPC> + <SPC> prices [ i ] <SPC> - <SPC> fee ) <NL>          hold <SPC> = <SPC> max ( hold , <SPC> cash <SPC> - <SPC> prices [ i ] ) <NL> <TAB> return <SPC> cash <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maxProfit ( self , <SPC> prices ) : <NL> <TAB> max_profit , <SPC> min_price <SPC> = <SPC> 0 , <SPC> float ( "inf" ) <NL> <TAB> for <SPC> price <SPC> in <SPC> prices : <NL>          min_price <SPC> = <SPC> min ( min_price , <SPC> price ) <NL>          max_profit <SPC> = <SPC> max ( max_profit , <SPC> price <SPC> - <SPC> min_price ) <NL> <TAB> return <SPC> max_profit <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> binaryGap ( self , <SPC> N ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> last <SPC> = <SPC> None <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 32 ) : <NL>          if <SPC> ( N <SPC> >> <SPC> i ) <SPC> & <SPC> 1 : <NL>              if <SPC> last <SPC> is <SPC> not <SPC> None : <NL>                  result <SPC> = <SPC> max ( result , <SPC> i <SPC> - <SPC> last ) <NL>              last <SPC> = <SPC> i <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> hasAlternatingBits ( self , <SPC> n ) : <NL> <NL> <TAB> n , <SPC> curr <SPC> = <SPC> divmod ( n , <SPC> 2 ) <NL> <TAB> while <SPC> n <SPC> > <SPC> 0 : <NL>          if <SPC> curr <SPC> == <SPC> n <SPC> % <SPC> 2 : <NL>              return <SPC> False <NL>          n , <SPC> curr <SPC> = <SPC> divmod ( n , <SPC> 2 ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> prefixesDivBy5 ( self , <SPC> A ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) ) : <NL>          A [ i ] <SPC> += <SPC> A [ i <SPC> - <SPC> 1 ] <SPC> * <SPC> 2 <SPC> % <SPC> 5 <NL> <TAB> return <SPC> [ x <SPC> % <SPC> 5 <SPC> == <SPC> 0 <SPC> for <SPC> x <SPC> in <SPC> A ] <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <NL> <NL> class <SPC> BSTIterator ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> root ) : <NL> <NL> <TAB> self . __stk <SPC> = <SPC> [ ] <NL> <TAB> self . __traversalLeft ( root ) <NL> <TAB> self . __vals <SPC> = <SPC> [ ] <NL> <TAB> self . __pos <SPC> = <SPC> - 1 <NL> <NL> <TAB> def <SPC> hasNext ( self ) : <NL> <NL> <TAB> return <SPC> self . __pos <SPC> + <SPC> 1 <SPC> != <SPC> len ( self . __vals ) <SPC> or <SPC> self . __stk <NL> <NL> <TAB> def <SPC> next ( self ) : <NL> <NL> <TAB> self . __pos <SPC> += <SPC> 1 <NL> <TAB> if <SPC> self . __pos <SPC> == <SPC> len ( self . __vals ) : <NL>          node <SPC> = <SPC> self . __stk . pop ( ) <NL>          self . __traversalLeft ( node . right ) <NL>          self . __vals . append ( node . val ) <NL> <TAB> return <SPC> self . __vals [ self . __pos ] <NL> <NL> <TAB> def <SPC> hasPrev ( self ) : <NL> <NL> <TAB> return <SPC> self . __pos <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <NL> <NL> <TAB> def <SPC> prev ( self ) : <NL> <NL> <TAB> self . __pos <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> self . __vals [ self . __pos ] <NL> <NL> <TAB> def <SPC> __traversalLeft ( self , <SPC> node ) : <NL> <TAB> while <SPC> node <SPC> is <SPC> not <SPC> None : <NL>          self . __stk . append ( node ) <NL>          node <SPC> = <SPC> node . left <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> BSTIterator ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> root ) : <NL> <TAB> self . __stk <SPC> = <SPC> [ ] <NL> <TAB> self . __traversalLeft ( root ) <NL> <NL> <TAB> def <SPC> hasNext ( self ) : <NL> <TAB> return <SPC> self . __stk <NL> <NL> <TAB> def <SPC> next ( self ) : <NL> <TAB> node <SPC> = <SPC> self . __stk . pop ( ) <NL> <TAB> self . __traversalLeft ( node . right ) <NL> <TAB> return <SPC> node . val <NL> <NL> <TAB> def <SPC> __traversalLeft ( self , <SPC> node ) : <NL> <TAB> while <SPC> node <SPC> is <SPC> not <SPC> None : <NL>          self . __stk . append ( node ) <NL>          node <SPC> = <SPC> node . left <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> bstToGst ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> bstToGstHelper ( root , <SPC> prev ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> root <NL>          bstToGstHelper ( root . right , <SPC> prev ) <NL>          root . val <SPC> += <SPC> prev [ 0 ] <NL>          prev [ 0 ] <SPC> = <SPC> root . val <NL>          bstToGstHelper ( root . left , <SPC> prev ) <NL>          return <SPC> root <NL> <NL> <TAB> prev <SPC> = <SPC> [ 0 ] <NL> <TAB> return <SPC> bstToGstHelper ( root , <SPC> prev ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> search ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> nums [ mid ] <SPC> > <SPC> target : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          elif <SPC> nums [ mid ] <SPC> < <SPC> target : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          else : <NL>              return <SPC> mid <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> queryString ( self , <SPC> S , <SPC> N ) : <NL> <NL> <TAB> return <SPC> all ( bin ( i ) [ 2 : ] <SPC> in <SPC> S <SPC> for <SPC> i <SPC> in <SPC> reversed ( xrange ( N <SPC> // <SPC> 2 , <SPC> N <SPC> + <SPC> 1 ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSubarraysWithSum ( self , <SPC> A , <SPC> S ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> left , <SPC> right , <SPC> sum_left , <SPC> sum_right <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> a <SPC> in <SPC> enumerate ( A ) : <NL>          sum_left <SPC> += <SPC> a <NL>          while <SPC> left <SPC> < <SPC> i <SPC> and <SPC> sum_left <SPC> > <SPC> S : <NL>              sum_left <SPC> -= <SPC> A [ left ] <NL>              left <SPC> += <SPC> 1 <NL>          sum_right <SPC> += <SPC> a <NL>          while <SPC> right <SPC> < <SPC> i <SPC> and <SPC> ( sum_right <SPC> > <SPC> S <SPC> or <SPC> ( sum_right <SPC> == <SPC> S <SPC> and <SPC> not <SPC> A [ right ] ) ) : <NL>              sum_right <SPC> -= <SPC> A [ right ] <NL>              right <SPC> += <SPC> 1 <NL>          if <SPC> sum_left <SPC> == <SPC> S : <NL>              result <SPC> += <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minCameraCover ( self , <SPC> root ) : <NL> <NL> <TAB> UNCOVERED , <SPC> COVERED , <SPC> CAMERA <SPC> = <SPC> range ( 3 ) <NL> <NL> <TAB> def <SPC> dfs ( root , <SPC> result ) : <NL>          left <SPC> = <SPC> dfs ( root . left , <SPC> result ) <SPC> if <SPC> root . left <SPC> else <SPC> COVERED <NL>          right <SPC> = <SPC> dfs ( root . right , <SPC> result ) <SPC> if <SPC> root . right <SPC> else <SPC> COVERED <NL>          if <SPC> left <SPC> == <SPC> UNCOVERED <SPC> or <SPC> right <SPC> == <SPC> UNCOVERED : <NL>              result [ 0 ] <SPC> += <SPC> 1 <NL>              return <SPC> CAMERA <NL>          if <SPC> left <SPC> == <SPC> CAMERA <SPC> or <SPC> right <SPC> == <SPC> CAMERA : <NL>              return <SPC> COVERED <NL>          return <SPC> UNCOVERED <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> if <SPC> dfs ( root , <SPC> result ) <SPC> == <SPC> UNCOVERED : <NL>          result [ 0 ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> btreeGameWinningMove ( self , <SPC> root , <SPC> n , <SPC> x ) : <NL> <NL> <TAB> def <SPC> count ( node , <SPC> x , <SPC> left_right ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> 0 <NL>          left , <SPC> right <SPC> = <SPC> count ( node . left , <SPC> x , <SPC> left_right ) , <SPC> count ( <NL>              node . right , <SPC> x , <SPC> left_right <NL>          ) <NL>          if <SPC> node . val <SPC> == <SPC> x : <NL>              left_right [ 0 ] , <SPC> left_right [ 1 ] <SPC> = <SPC> left , <SPC> right <NL>          return <SPC> left <SPC> + <SPC> right <SPC> + <SPC> 1 <NL> <NL> <TAB> left_right <SPC> = <SPC> [ 0 , <SPC> 0 ] <NL> <TAB> count ( root , <SPC> x , <SPC> left_right ) <NL> <TAB> blue <SPC> = <SPC> max ( max ( left_right ) , <SPC> n <SPC> - <SPC> ( sum ( left_right ) <SPC> + <SPC> 1 ) ) <NL> <TAB> return <SPC> blue <SPC> > <SPC> n <SPC> - <SPC> blue <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> inorderTraversal ( self , <SPC> root ) : <NL> <NL> <TAB> result , <SPC> curr <SPC> = <SPC> [ ] , <SPC> root <NL> <TAB> while <SPC> curr : <NL>          if <SPC> curr . left <SPC> is <SPC> None : <NL>              result . append ( curr . val ) <NL>              curr <SPC> = <SPC> curr . right <NL>          else : <NL>              node <SPC> = <SPC> curr . left <NL>              while <SPC> node . right <SPC> and <SPC> node . right <SPC> != <SPC> curr : <NL>                  node <SPC> = <SPC> node . right <NL> <NL>              if <SPC> node . right <SPC> is <SPC> None : <NL>                  node . right <SPC> = <SPC> curr <NL>                  curr <SPC> = <SPC> curr . left <NL>              else : <NL>                  result . append ( curr . val ) <NL>                  node . right <SPC> = <SPC> None <NL>                  curr <SPC> = <SPC> curr . right <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> inorderTraversal ( self , <SPC> root ) : <NL> <NL> <TAB> result , <SPC> stack <SPC> = <SPC> [ ] , <SPC> [ ( root , <SPC> False ) ] <NL> <TAB> while <SPC> stack : <NL>          root , <SPC> is_visited <SPC> = <SPC> stack . pop ( ) <NL>          if <SPC> root <SPC> is <SPC> None : <NL>              continue <NL>          if <SPC> is_visited : <NL>              result . append ( root . val ) <NL>          else : <NL>              stack . append ( ( root . right , <SPC> False ) ) <NL>              stack . append ( ( root , <SPC> True ) ) <NL>              stack . append ( ( root . left , <SPC> False ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> levelOrderBottom ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <NL> <TAB> result , <SPC> current <SPC> = <SPC> [ ] , <SPC> [ root ] <NL> <TAB> while <SPC> current : <NL>          next_level , <SPC> vals <SPC> = <SPC> [ ] , <SPC> [ ] <NL>          for <SPC> node <SPC> in <SPC> current : <NL>              vals . append ( node . val ) <NL>              if <SPC> node . left : <NL>                  next_level . append ( node . left ) <NL>              if <SPC> node . right : <NL>                  next_level . append ( node . right ) <NL>          current <SPC> = <SPC> next_level <NL>          result . append ( vals ) <NL> <NL> <TAB> return <SPC> result [ : : - 1 ] <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> levelOrder ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <TAB> result , <SPC> current <SPC> = <SPC> [ ] , <SPC> [ root ] <NL> <TAB> while <SPC> current : <NL>          next_level , <SPC> vals <SPC> = <SPC> [ ] , <SPC> [ ] <NL>          for <SPC> node <SPC> in <SPC> current : <NL>              vals . append ( node . val ) <NL>              if <SPC> node . left : <NL>                  next_level . append ( node . left ) <NL>              if <SPC> node . right : <NL>                  next_level . append ( node . right ) <NL>          current <SPC> = <SPC> next_level <NL>          result . append ( vals ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestConsecutive ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> longestConsecutiveHelper ( root ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 , <SPC> 0 <NL>          left_len <SPC> = <SPC> longestConsecutiveHelper ( root . left ) <NL>          right_len <SPC> = <SPC> longestConsecutiveHelper ( root . right ) <NL>          cur_inc_len , <SPC> cur_dec_len <SPC> = <SPC> 1 , <SPC> 1 <NL>          if <SPC> root . left : <NL>              if <SPC> root . left . val <SPC> == <SPC> root . val <SPC> + <SPC> 1 : <NL>                  cur_inc_len <SPC> = <SPC> max ( cur_inc_len , <SPC> left_len [ 0 ] <SPC> + <SPC> 1 ) <NL>              elif <SPC> root . left . val <SPC> == <SPC> root . val <SPC> - <SPC> 1 : <NL>                  cur_dec_len <SPC> = <SPC> max ( cur_dec_len , <SPC> left_len [ 1 ] <SPC> + <SPC> 1 ) <NL>          if <SPC> root . right : <NL>              if <SPC> root . right . val <SPC> == <SPC> root . val <SPC> + <SPC> 1 : <NL>                  cur_inc_len <SPC> = <SPC> max ( cur_inc_len , <SPC> right_len [ 0 ] <SPC> + <SPC> 1 ) <NL>              elif <SPC> root . right . val <SPC> == <SPC> root . val <SPC> - <SPC> 1 : <NL>                  cur_dec_len <SPC> = <SPC> max ( cur_dec_len , <SPC> right_len [ 1 ] <SPC> + <SPC> 1 ) <NL>          self . max_len <SPC> = <SPC> max ( self . max_len , <SPC> cur_dec_len <SPC> + <SPC> cur_inc_len <SPC> - <SPC> 1 ) <NL>          return <SPC> cur_inc_len , <SPC> cur_dec_len <NL> <NL> <TAB> self . max_len <SPC> = <SPC> 0 <NL> <TAB> longestConsecutiveHelper ( root ) <NL> <TAB> return <SPC> self . max_len <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestConsecutive ( self , <SPC> root ) : <NL> <NL> <TAB> self . max_len <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> longestConsecutiveHelper ( root ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 <NL> <NL>          left_len <SPC> = <SPC> longestConsecutiveHelper ( root . left ) <NL>          right_len <SPC> = <SPC> longestConsecutiveHelper ( root . right ) <NL> <NL>          cur_len <SPC> = <SPC> 1 <NL>          if <SPC> root . left <SPC> and <SPC> root . left . val <SPC> == <SPC> root . val <SPC> + <SPC> 1 : <NL>              cur_len <SPC> = <SPC> max ( cur_len , <SPC> left_len <SPC> + <SPC> 1 ) <NL>          if <SPC> root . right <SPC> and <SPC> root . right . val <SPC> == <SPC> root . val <SPC> + <SPC> 1 : <NL>              cur_len <SPC> = <SPC> max ( cur_len , <SPC> right_len <SPC> + <SPC> 1 ) <NL> <NL>          self . max_len <SPC> = <SPC> max ( self . max_len , <SPC> cur_len ) <NL> <NL>          return <SPC> cur_len <NL> <NL> <TAB> longestConsecutiveHelper ( root ) <NL> <TAB> return <SPC> self . max_len <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maxPathSum ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> iter_dfs ( node ) : <NL>          result <SPC> = <SPC> float ( "-inf" ) <NL>          max_sum <SPC> = <SPC> [ 0 ] <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> [ node , <SPC> max_sum ] ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  node , <SPC> ret <SPC> = <SPC> params <NL>                  if <SPC> not <SPC> node : <NL>                      continue <NL>                  ret1 , <SPC> ret2 <SPC> = <SPC> [ 0 ] , <SPC> [ 0 ] <NL>                  stk . append ( ( 2 , <SPC> [ node , <SPC> ret1 , <SPC> ret2 , <SPC> ret ] ) ) <NL>                  stk . append ( ( 1 , <SPC> [ node . right , <SPC> ret2 ] ) ) <NL>                  stk . append ( ( 1 , <SPC> [ node . left , <SPC> ret1 ] ) ) <NL>              elif <SPC> step <SPC> == <SPC> 2 : <NL>                  node , <SPC> ret1 , <SPC> ret2 , <SPC> ret <SPC> = <SPC> params <NL>                  result <SPC> = <SPC> max ( result , <SPC> node . val <SPC> + <NL>                               max ( ret1 [ 0 ] , <SPC> 0 ) <SPC> + <SPC> max ( ret2 [ 0 ] , <SPC> 0 ) ) <NL>                  ret [ 0 ] <SPC> = <SPC> node . val <SPC> + <SPC> max ( ret1 [ 0 ] , <SPC> ret2 [ 0 ] , <SPC> 0 ) <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> iter_dfs ( root ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> maxPathSum ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> ( float ( "-inf" ) , <SPC> 0 ) <NL>          max_left , <SPC> curr_left <SPC> = <SPC> dfs ( node . left ) <NL>          max_right , <SPC> curr_right <SPC> = <SPC> dfs ( node . right ) <NL>          return <SPC> ( <NL>              max ( <NL>                  max_left , <NL>                  max_right , <NL>                  node . val <SPC> + <SPC> max ( curr_left , <SPC> 0 ) <SPC> + <SPC> max ( curr_right , <SPC> 0 ) , <NL>              ) , <NL>              node . val <SPC> + <SPC> max ( curr_left , <SPC> curr_right , <SPC> 0 ) , <NL>          ) <NL> <NL> <TAB> return <SPC> dfs ( root ) [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> binaryTreePaths ( self , <SPC> root ) : <NL> <TAB> result , <SPC> path <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> self . binaryTreePathsRecu ( root , <SPC> path , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> binaryTreePathsRecu ( self , <SPC> node , <SPC> path , <SPC> result ) : <NL> <TAB> if <SPC> node <SPC> is <SPC> None : <NL>          return <NL> <NL> <TAB> if <SPC> node . left <SPC> is <SPC> node . right <SPC> is <SPC> None : <NL>          ans <SPC> = <SPC> "" <NL>          for <SPC> n <SPC> in <SPC> path : <NL>              ans <SPC> += <SPC> str ( n . val ) <SPC> + <SPC> "->" <NL>          result . append ( ans <SPC> + <SPC> str ( node . val ) ) <NL> <NL> <TAB> if <SPC> node . left : <NL>          path . append ( node ) <NL>          self . binaryTreePathsRecu ( node . left , <SPC> path , <SPC> result ) <NL>          path . pop ( ) <NL> <NL> <TAB> if <SPC> node . right : <NL>          path . append ( node ) <NL>          self . binaryTreePathsRecu ( node . right , <SPC> path , <SPC> result ) <NL>          path . pop ( ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> postorderTraversal ( self , <SPC> root ) : <NL> <NL> <TAB> dummy <SPC> = <SPC> TreeNode ( 0 ) <NL> <TAB> dummy . left <SPC> = <SPC> root <NL> <TAB> result , <SPC> cur <SPC> = <SPC> [ ] , <SPC> dummy <NL> <TAB> while <SPC> cur : <NL>          if <SPC> cur . left <SPC> is <SPC> None : <NL>              cur <SPC> = <SPC> cur . right <NL>          else : <NL>              node <SPC> = <SPC> cur . left <NL>              while <SPC> node . right <SPC> and <SPC> node . right <SPC> != <SPC> cur : <NL>                  node <SPC> = <SPC> node . right <NL> <NL>              if <SPC> node . right <SPC> is <SPC> None : <NL>                  node . right <SPC> = <SPC> cur <NL>                  cur <SPC> = <SPC> cur . left <NL>              else : <NL>                  result <SPC> += <SPC> self . traceBack ( cur . left , <SPC> node ) <NL>                  node . right <SPC> = <SPC> None <NL>                  cur <SPC> = <SPC> cur . right <NL> <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> traceBack ( self , <SPC> frm , <SPC> to ) : <NL> <TAB> result , <SPC> cur <SPC> = <SPC> [ ] , <SPC> frm <NL> <TAB> while <SPC> cur <SPC> is <SPC> not <SPC> to : <NL>          result . append ( cur . val ) <NL>          cur <SPC> = <SPC> cur . right <NL> <TAB> result . append ( to . val ) <NL> <TAB> result . reverse ( ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> postorderTraversal ( self , <SPC> root ) : <NL> <NL> <TAB> result , <SPC> stack <SPC> = <SPC> [ ] , <SPC> [ ( root , <SPC> False ) ] <NL> <TAB> while <SPC> stack : <NL>          root , <SPC> is_visited <SPC> = <SPC> stack . pop ( ) <NL>          if <SPC> root <SPC> is <SPC> None : <NL>              continue <NL>          if <SPC> is_visited : <NL>              result . append ( root . val ) <NL>          else : <NL>              stack . append ( ( root , <SPC> True ) ) <NL>              stack . append ( ( root . right , <SPC> False ) ) <NL>              stack . append ( ( root . left , <SPC> False ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> preorderTraversal ( self , <SPC> root ) : <NL> <NL> <TAB> result , <SPC> curr <SPC> = <SPC> [ ] , <SPC> root <NL> <TAB> while <SPC> curr : <NL>          if <SPC> curr . left <SPC> is <SPC> None : <NL>              result . append ( curr . val ) <NL>              curr <SPC> = <SPC> curr . right <NL>          else : <NL>              node <SPC> = <SPC> curr . left <NL>              while <SPC> node . right <SPC> and <SPC> node . right <SPC> != <SPC> curr : <NL>                  node <SPC> = <SPC> node . right <NL> <NL>              if <SPC> node . right <SPC> is <SPC> None : <NL>                  result . append ( curr . val ) <NL>                  node . right <SPC> = <SPC> curr <NL>                  curr <SPC> = <SPC> curr . left <NL>              else : <NL>                  node . right <SPC> = <SPC> None <NL>                  curr <SPC> = <SPC> curr . right <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> preorderTraversal ( self , <SPC> root ) : <NL> <NL> <TAB> result , <SPC> stack <SPC> = <SPC> [ ] , <SPC> [ ( root , <SPC> False ) ] <NL> <TAB> while <SPC> stack : <NL>          root , <SPC> is_visited <SPC> = <SPC> stack . pop ( ) <NL>          if <SPC> root <SPC> is <SPC> None : <NL>              continue <NL>          if <SPC> is_visited : <NL>              result . append ( root . val ) <NL>          else : <NL>              stack . append ( ( root . right , <SPC> False ) ) <NL>              stack . append ( ( root . left , <SPC> False ) ) <NL>              stack . append ( ( root , <SPC> True ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pruneTree ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> None <NL> <TAB> root . left <SPC> = <SPC> self . pruneTree ( root . left ) <NL> <TAB> root . right <SPC> = <SPC> self . pruneTree ( root . right ) <NL> <TAB> if <SPC> not <SPC> root . left <SPC> and <SPC> not <SPC> root . right <SPC> and <SPC> root . val <SPC> == <SPC> 0 : <NL>          return <SPC> None <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> rightSideView ( self , <SPC> root ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> self . rightSideViewDFS ( root , <SPC> 1 , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> rightSideViewDFS ( self , <SPC> node , <SPC> depth , <SPC> result ) : <NL> <TAB> if <SPC> not <SPC> node : <NL>          return <NL> <NL> <TAB> if <SPC> depth <SPC> > <SPC> len ( result ) : <NL>          result . append ( node . val ) <NL> <NL> <TAB> self . rightSideViewDFS ( node . right , <SPC> depth <SPC> + <SPC> 1 , <SPC> result ) <NL> <TAB> self . rightSideViewDFS ( node . left , <SPC> depth <SPC> + <SPC> 1 , <SPC> result ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> rightSideView ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <NL> <TAB> result , <SPC> current <SPC> = <SPC> [ ] , <SPC> [ root ] <NL> <TAB> while <SPC> current : <NL>          next_level <SPC> = <SPC> [ ] <NL>          for <SPC> node <SPC> in <SPC> current : <NL>              if <SPC> node . left : <NL>                  next_level . append ( node . left ) <NL>              if <SPC> node . right : <NL>                  next_level . append ( node . right ) <NL>          result . append ( node . val ) <NL>          current <SPC> = <SPC> next_level <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findTilt ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> postOrderTraverse ( root , <SPC> tilt ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 , <SPC> tilt <NL>          left , <SPC> tilt <SPC> = <SPC> postOrderTraverse ( root . left , <SPC> tilt ) <NL>          right , <SPC> tilt <SPC> = <SPC> postOrderTraverse ( root . right , <SPC> tilt ) <NL>          tilt <SPC> += <SPC> abs ( left <SPC> - <SPC> right ) <NL>          return <SPC> left <SPC> + <SPC> right <SPC> + <SPC> root . val , <SPC> tilt <NL> <NL> <TAB> return <SPC> postOrderTraverse ( root , <SPC> 0 ) [ 1 ] <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> upsideDownBinaryTree ( self , <SPC> root ) : <NL> <TAB> p , <SPC> parent , <SPC> parent_right <SPC> = <SPC> root , <SPC> None , <SPC> None <NL> <NL> <TAB> while <SPC> p : <NL>          left <SPC> = <SPC> p . left <NL>          p . left <SPC> = <SPC> parent_right <NL>          parent_right <SPC> = <SPC> p . right <NL>          p . right <SPC> = <SPC> parent <NL>          parent <SPC> = <SPC> p <NL>          p <SPC> = <SPC> left <NL> <NL> <TAB> return <SPC> parent <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> upsideDownBinaryTree ( self , <SPC> root ) : <NL> <TAB> return <SPC> self . upsideDownBinaryTreeRecu ( root , <SPC> None ) <NL> <NL> <TAB> def <SPC> upsideDownBinaryTreeRecu ( self , <SPC> p , <SPC> parent ) : <NL> <TAB> if <SPC> p <SPC> is <SPC> None : <NL>          return <SPC> parent <NL> <NL> <TAB> root <SPC> = <SPC> self . upsideDownBinaryTreeRecu ( p . left , <SPC> p ) <NL> <TAB> if <SPC> parent : <NL>          p . left <SPC> = <SPC> parent . right <NL> <TAB> else : <NL>          p . left <SPC> = <SPC> None <NL> <TAB> p . right <SPC> = <SPC> parent <NL> <NL> <TAB> return <SPC> root <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> verticalOrder ( self , <SPC> root ) : <NL> <NL> <TAB> cols <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> queue <SPC> = <SPC> [ ( root , <SPC> 0 ) ] <NL> <TAB> for <SPC> node , <SPC> i <SPC> in <SPC> queue : <NL>          if <SPC> node : <NL>              cols [ i ] . append ( node . val ) <NL>              queue <SPC> += <SPC> ( node . left , <SPC> i <SPC> - <SPC> 1 ) , <SPC> ( node . right , <SPC> i <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> ( <NL>          [ cols [ i ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( min ( cols . keys ( ) ) , <SPC> max ( cols . keys ( ) ) <SPC> + <SPC> 1 ) ] <NL>          if <SPC> cols <NL>          else <SPC> [ ] <NL> <TAB> ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> zigzagLevelOrder ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <TAB> result , <SPC> current <SPC> = <SPC> [ ] , <SPC> [ root ] <NL> <TAB> while <SPC> current : <NL>          next_level , <SPC> vals <SPC> = <SPC> [ ] , <SPC> [ ] <NL>          for <SPC> node <SPC> in <SPC> current : <NL>              vals . append ( node . val ) <NL>              if <SPC> node . left : <NL>                  next_level . append ( node . left ) <NL>              if <SPC> node . right : <NL>                  next_level . append ( node . right ) <NL>          result . append ( vals [ : : - 1 ] <SPC> if <SPC> len ( result ) <SPC> % <SPC> 2 <SPC> else <SPC> vals ) <NL>          current <SPC> = <SPC> next_level <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numFactoredBinaryTrees ( self , <SPC> A ) : <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> A . sort ( ) <NL> <TAB> dp <SPC> = <SPC> { } <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          dp [ A [ i ] ] <SPC> = <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> xrange ( i ) : <NL>              if <SPC> A [ i ] <SPC> % <SPC> A [ j ] <SPC> == <SPC> 0 <SPC> and <SPC> A [ i ] <SPC> // <SPC> A [ j ] <SPC> in <SPC> dp : <NL>                  dp [ A [ i ] ] <SPC> += <SPC> dp [ A [ j ] ] <SPC> * <SPC> dp [ A [ i ] <SPC> // <SPC> A [ j ] ] <NL>                  dp [ A [ i ] ] <SPC> %= <SPC> M <NL> <TAB> return <SPC> sum ( dp . values ( ) ) <SPC> % <SPC> M <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> readBinaryWatch ( self , <SPC> num ) : <NL> <NL> <TAB> def <SPC> bit_count ( bits ) : <NL>          count <SPC> = <SPC> 0 <NL>          while <SPC> bits : <NL>              bits <SPC> &= <SPC> bits <SPC> - <SPC> 1 <NL>              count <SPC> += <SPC> 1 <NL>          return <SPC> count <NL> <NL> <TAB> return <SPC> [ <NL>          "%d:%02d" <SPC> % <SPC> ( h , <SPC> m ) <NL>          for <SPC> h <SPC> in <SPC> xrange ( 12 ) <NL>          for <SPC> m <SPC> in <SPC> xrange ( 60 ) <NL>          if <SPC> bit_count ( h ) <SPC> + <SPC> bit_count ( m ) <SPC> == <SPC> num <NL> <TAB> ] <NL> <NL> <TAB> def <SPC> readBinaryWatch2 ( self , <SPC> num ) : <NL> <NL> <TAB> return <SPC> [ <NL>          "{0}:{1}" . format ( str ( h ) , <SPC> str ( m ) . zfill ( 2 ) ) <NL>          for <SPC> h <SPC> in <SPC> range ( 12 ) <NL>          for <SPC> m <SPC> in <SPC> range ( 60 ) <NL>          if <SPC> ( bin ( h ) <SPC> + <SPC> bin ( m ) ) . count ( "1" ) <SPC> == <SPC> num <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> rangeBitwiseAnd ( self , <SPC> m , <SPC> n ) : <NL> <TAB> while <SPC> m <SPC> < <SPC> n : <NL>          n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL> <TAB> return <SPC> n <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> rangeBitwiseAnd ( self , <SPC> m , <SPC> n ) : <NL> <TAB> i , <SPC> diff <SPC> = <SPC> 0 , <SPC> n <SPC> - <SPC> m <NL> <TAB> while <SPC> diff : <NL>          diff <SPC> >>= <SPC> 1 <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> n <SPC> & <SPC> m <SPC> >> <SPC> i <SPC> << <SPC> i <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> subarrayBitwiseORs ( self , <SPC> A ) : <NL> <NL> <TAB> result , <SPC> curr <SPC> = <SPC> set ( ) , <SPC> { 0 } <NL> <TAB> for <SPC> i <SPC> in <SPC> A : <NL>          curr <SPC> = <SPC> { i } <SPC> | <SPC> { i <SPC> | <SPC> j <SPC> for <SPC> j <SPC> in <SPC> curr } <NL>          result <SPC> |= <SPC> curr <NL> <TAB> return <SPC> len ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numRescueBoats ( self , <SPC> people , <SPC> limit ) : <NL> <NL> <TAB> people . sort ( ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( people ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          result <SPC> += <SPC> 1 <NL>          if <SPC> people [ left ] <SPC> + <SPC> people [ right ] <SPC> <= <SPC> limit : <NL>              left <SPC> += <SPC> 1 <NL>          right <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> functools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> boldWords ( self , <SPC> words , <SPC> S ) : <NL> <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> trie <SPC> = <SPC> _trie ( ) <NL> <TAB> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          functools . reduce ( dict . __getitem__ , <SPC> word , <SPC> trie ) . setdefault ( "_end" ) <NL> <NL> <TAB> lookup <SPC> = <SPC> [ False ] <SPC> * <SPC> len ( S ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( S ) ) : <NL>          curr <SPC> = <SPC> trie <NL>          k <SPC> = <SPC> - 1 <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> len ( S ) ) : <NL>              if <SPC> S [ j ] <SPC> not <SPC> in <SPC> curr : <NL>                  break <NL>              curr <SPC> = <SPC> curr [ S [ j ] ] <NL>              if <SPC> "_end" <SPC> in <SPC> curr : <NL>                  k <SPC> = <SPC> j <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> k <SPC> + <SPC> 1 ) : <NL>              lookup [ j ] <SPC> = <SPC> True <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( S ) ) : <NL>          if <SPC> lookup [ i ] <SPC> and <SPC> ( i <SPC> == <SPC> 0 <SPC> or <SPC> not <SPC> lookup [ i <SPC> - <SPC> 1 ] ) : <NL>              result . append ( "<b>" ) <NL>          result . append ( S [ i ] ) <NL>          if <SPC> lookup [ i ] <SPC> and <SPC> ( i <SPC> == <SPC> len ( S ) <SPC> - <SPC> 1 <SPC> or <SPC> not <SPC> lookup [ i <SPC> + <SPC> 1 ] ) : <NL>              result . append ( "</b>" ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> boldWords ( self , <SPC> words , <SPC> S ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( S ) <NL> <TAB> for <SPC> d <SPC> in <SPC> words : <NL>          pos <SPC> = <SPC> S . find ( d ) <NL>          while <SPC> pos <SPC> != <SPC> - 1 : <NL>              lookup [ pos : <SPC> pos <SPC> + <SPC> len ( d ) ] <SPC> = <SPC> [ 1 ] <SPC> * <SPC> len ( d ) <NL>              pos <SPC> = <SPC> S . find ( d , <SPC> pos <SPC> + <SPC> 1 ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( S ) ) : <NL>          if <SPC> lookup [ i ] <SPC> and <SPC> ( i <SPC> == <SPC> 0 <SPC> or <SPC> not <SPC> lookup [ i <SPC> - <SPC> 1 ] ) : <NL>              result . append ( "<b>" ) <NL>          result . append ( S [ i ] ) <NL>          if <SPC> lookup [ i ] <SPC> and <SPC> ( i <SPC> == <SPC> len ( S ) <SPC> - <SPC> 1 <SPC> or <SPC> not <SPC> lookup [ i <SPC> + <SPC> 1 ] ) : <NL>              result . append ( "</b>" ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxKilledEnemies ( self , <SPC> grid ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> if <SPC> not <SPC> grid <SPC> or <SPC> not <SPC> grid [ 0 ] : <NL>          return <SPC> result <NL> <NL> <TAB> down <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( grid ) ) ] <NL> <TAB> right <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( grid ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( grid ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( grid [ 0 ] ) ) ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> != <SPC> "W" : <NL>                  if <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( grid ) : <NL>                      down [ i ] [ j ] <SPC> = <SPC> down [ i <SPC> + <SPC> 1 ] [ j ] <NL>                  if <SPC> j <SPC> + <SPC> 1 <SPC> < <SPC> len ( grid [ 0 ] ) : <NL>                      right [ i ] [ j ] <SPC> = <SPC> right [ i ] [ j <SPC> + <SPC> 1 ] <NL>                  if <SPC> grid [ i ] [ j ] <SPC> == <SPC> "E" : <NL>                      down [ i ] [ j ] <SPC> += <SPC> 1 <NL>                      right [ i ] [ j ] <SPC> += <SPC> 1 <NL> <NL> <TAB> up <SPC> = <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          left <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> == <SPC> "W" : <NL>                  up [ j ] , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 <NL>              elif <SPC> grid [ i ] [ j ] <SPC> == <SPC> "E" : <NL>                  up [ j ] <SPC> += <SPC> 1 <NL>                  left <SPC> += <SPC> 1 <NL>              else : <NL>                  result <SPC> = <SPC> max ( result , <SPC> left <SPC> + <SPC> up [ j ] <SPC> + <SPC> right [ i ] [ j ] <SPC> + <SPC> down [ i ] [ j ] ) <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> boundaryOfBinaryTree ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> leftBoundary ( root , <SPC> nodes ) : <NL>          if <SPC> not <SPC> root <SPC> or <SPC> ( not <SPC> root . left <SPC> and <SPC> not <SPC> root . right ) : <NL>              return <NL>          nodes . append ( root . val ) <NL>          if <SPC> not <SPC> root . left : <NL>              leftBoundary ( root . right , <SPC> nodes ) <NL>          else : <NL>              leftBoundary ( root . left , <SPC> nodes ) <NL> <NL> <TAB> def <SPC> rightBoundary ( root , <SPC> nodes ) : <NL>          if <SPC> not <SPC> root <SPC> or <SPC> ( not <SPC> root . left <SPC> and <SPC> not <SPC> root . right ) : <NL>              return <NL>          if <SPC> not <SPC> root . right : <NL>              rightBoundary ( root . left , <SPC> nodes ) <NL>          else : <NL>              rightBoundary ( root . right , <SPC> nodes ) <NL>          nodes . append ( root . val ) <NL> <NL> <TAB> def <SPC> leaves ( root , <SPC> nodes ) : <NL>          if <SPC> not <SPC> root : <NL>              return <NL>          if <SPC> not <SPC> root . left <SPC> and <SPC> not <SPC> root . right : <NL>              nodes . append ( root . val ) <NL>              return <NL>          leaves ( root . left , <SPC> nodes ) <NL>          leaves ( root . right , <SPC> nodes ) <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> [ ] <NL> <NL> <TAB> nodes <SPC> = <SPC> [ root . val ] <NL> <TAB> leftBoundary ( root . left , <SPC> nodes ) <NL> <TAB> leaves ( root . left , <SPC> nodes ) <NL> <TAB> leaves ( root . right , <SPC> nodes ) <NL> <TAB> rightBoundary ( root . right , <SPC> nodes ) <NL> <TAB> return <SPC> nodes <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> braceExpansionII ( self , <SPC> expression ) : <NL> <NL> <TAB> def <SPC> form_words ( options ) : <NL>          words <SPC> = <SPC> map ( "" . join , <SPC> itertools . product ( * options ) ) <NL>          words . sort ( ) <NL>          return <SPC> words <NL> <NL> <TAB> def <SPC> generate_option ( expr , <SPC> i ) : <NL>          option_set <SPC> = <SPC> set ( ) <NL>          while <SPC> i [ 0 ] <SPC> != <SPC> len ( expr ) <SPC> and <SPC> expr [ i [ 0 ] ] <SPC> != <SPC> "}" : <NL>              i [ 0 ] <SPC> += <SPC> 1 <NL>              for <SPC> option <SPC> in <SPC> generate_words ( expr , <SPC> i ) : <NL>                  option_set . add ( option ) <NL>          i [ 0 ] <SPC> += <SPC> 1 <NL>          option <SPC> = <SPC> list ( option_set ) <NL>          option . sort ( ) <NL>          return <SPC> option <NL> <NL> <TAB> def <SPC> generate_words ( expr , <SPC> i ) : <NL>          options <SPC> = <SPC> [ ] <NL>          while <SPC> i [ 0 ] <SPC> != <SPC> len ( expr ) <SPC> and <SPC> expr [ i [ 0 ] ] <SPC> not <SPC> in <SPC> ",}" : <NL>              tmp <SPC> = <SPC> [ ] <NL>              if <SPC> expr [ i [ 0 ] ] <SPC> not <SPC> in <SPC> "{,}" : <NL>                  tmp . append ( expr [ i [ 0 ] ] ) <NL>                  i [ 0 ] <SPC> += <SPC> 1 <NL>              elif <SPC> expr [ i [ 0 ] ] <SPC> == <SPC> "{" : <NL>                  tmp <SPC> = <SPC> generate_option ( expr , <SPC> i ) <NL>              options . append ( tmp ) <NL>          return <SPC> form_words ( options ) <NL> <NL> <TAB> return <SPC> generate_words ( expression , <SPC> [ 0 ] ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> braceExpansionII ( self , <SPC> expression ) : <NL> <NL> <TAB> def <SPC> form_words ( options ) : <NL>          words <SPC> = <SPC> [ ] <NL>          total <SPC> = <SPC> 1 <NL>          for <SPC> opt <SPC> in <SPC> options : <NL>              total <SPC> *= <SPC> len ( opt ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( total ) : <NL>              tmp <SPC> = <SPC> [ ] <NL>              for <SPC> opt <SPC> in <SPC> reversed ( options ) : <NL>                  i , <SPC> c <SPC> = <SPC> divmod ( i , <SPC> len ( opt ) ) <NL>                  tmp . append ( opt [ c ] ) <NL>              tmp . reverse ( ) <NL>              words . append ( "" . join ( tmp ) ) <NL>          words . sort ( ) <NL>          return <SPC> words <NL> <NL> <TAB> def <SPC> generate_option ( expr , <SPC> i ) : <NL>          option_set <SPC> = <SPC> set ( ) <NL>          while <SPC> i [ 0 ] <SPC> != <SPC> len ( expr ) <SPC> and <SPC> expr [ i [ 0 ] ] <SPC> != <SPC> "}" : <NL>              i [ 0 ] <SPC> += <SPC> 1 <NL>              for <SPC> option <SPC> in <SPC> generate_words ( expr , <SPC> i ) : <NL>                  option_set . add ( option ) <NL>          i [ 0 ] <SPC> += <SPC> 1 <NL>          option <SPC> = <SPC> list ( option_set ) <NL>          option . sort ( ) <NL>          return <SPC> option <NL> <NL> <TAB> def <SPC> generate_words ( expr , <SPC> i ) : <NL>          options <SPC> = <SPC> [ ] <NL>          while <SPC> i [ 0 ] <SPC> != <SPC> len ( expr ) <SPC> and <SPC> expr [ i [ 0 ] ] <SPC> not <SPC> in <SPC> ",}" : <NL>              tmp <SPC> = <SPC> [ ] <NL>              if <SPC> expr [ i [ 0 ] ] <SPC> not <SPC> in <SPC> "{,}" : <NL>                  tmp . append ( expr [ i [ 0 ] ] ) <NL>                  i [ 0 ] <SPC> += <SPC> 1 <NL>              elif <SPC> expr [ i [ 0 ] ] <SPC> == <SPC> "{" : <NL>                  tmp <SPC> = <SPC> generate_option ( expr , <SPC> i ) <NL>              options . append ( tmp ) <NL>          return <SPC> form_words ( options ) <NL> <NL> <TAB> return <SPC> generate_words ( expression , <SPC> [ 0 ] ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> expand ( self , <SPC> S ) : <NL> <NL> <TAB> def <SPC> form_words ( options ) : <NL>          words <SPC> = <SPC> map ( "" . join , <SPC> itertools . product ( * options ) ) <NL>          words . sort ( ) <NL>          return <SPC> words <NL> <NL> <TAB> def <SPC> generate_option ( expr , <SPC> i ) : <NL>          option_set <SPC> = <SPC> set ( ) <NL>          while <SPC> i [ 0 ] <SPC> != <SPC> len ( expr ) <SPC> and <SPC> expr [ i [ 0 ] ] <SPC> != <SPC> "}" : <NL>              i [ 0 ] <SPC> += <SPC> 1 <NL>              for <SPC> option <SPC> in <SPC> generate_words ( expr , <SPC> i ) : <NL>                  option_set . add ( option ) <NL>          i [ 0 ] <SPC> += <SPC> 1 <NL>          option <SPC> = <SPC> list ( option_set ) <NL>          option . sort ( ) <NL>          return <SPC> option <NL> <NL> <TAB> def <SPC> generate_words ( expr , <SPC> i ) : <NL>          options <SPC> = <SPC> [ ] <NL>          while <SPC> i [ 0 ] <SPC> != <SPC> len ( expr ) <SPC> and <SPC> expr [ i [ 0 ] ] <SPC> not <SPC> in <SPC> ",}" : <NL>              tmp <SPC> = <SPC> [ ] <NL>              if <SPC> expr [ i [ 0 ] ] <SPC> not <SPC> in <SPC> "{,}" : <NL>                  tmp . append ( expr [ i [ 0 ] ] ) <NL>                  i [ 0 ] <SPC> += <SPC> 1 <NL>              elif <SPC> expr [ i [ 0 ] ] <SPC> == <SPC> "{" : <NL>                  tmp <SPC> = <SPC> generate_option ( expr , <SPC> i ) <NL>              options . append ( tmp ) <NL>          return <SPC> form_words ( options ) <NL> <NL> <TAB> return <SPC> generate_words ( S , <SPC> [ 0 ] ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> expand ( self , <SPC> S ) : <NL> <NL> <TAB> def <SPC> form_words ( options ) : <NL>          words <SPC> = <SPC> [ ] <NL>          total <SPC> = <SPC> 1 <NL>          for <SPC> opt <SPC> in <SPC> options : <NL>              total <SPC> *= <SPC> len ( opt ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( total ) : <NL>              tmp <SPC> = <SPC> [ ] <NL>              for <SPC> opt <SPC> in <SPC> reversed ( options ) : <NL>                  i , <SPC> c <SPC> = <SPC> divmod ( i , <SPC> len ( opt ) ) <NL>                  tmp . append ( opt [ c ] ) <NL>              tmp . reverse ( ) <NL>              words . append ( "" . join ( tmp ) ) <NL>          words . sort ( ) <NL>          return <SPC> words <NL> <NL> <TAB> def <SPC> generate_option ( expr , <SPC> i ) : <NL>          option_set <SPC> = <SPC> set ( ) <NL>          while <SPC> i [ 0 ] <SPC> != <SPC> len ( expr ) <SPC> and <SPC> expr [ i [ 0 ] ] <SPC> != <SPC> "}" : <NL>              i [ 0 ] <SPC> += <SPC> 1 <NL>              for <SPC> option <SPC> in <SPC> generate_words ( expr , <SPC> i ) : <NL>                  option_set . add ( option ) <NL>          i [ 0 ] <SPC> += <SPC> 1 <NL>          option <SPC> = <SPC> list ( option_set ) <NL>          option . sort ( ) <NL>          return <SPC> option <NL> <NL> <TAB> def <SPC> generate_words ( expr , <SPC> i ) : <NL>          options <SPC> = <SPC> [ ] <NL>          while <SPC> i [ 0 ] <SPC> != <SPC> len ( expr ) <SPC> and <SPC> expr [ i [ 0 ] ] <SPC> not <SPC> in <SPC> ",}" : <NL>              tmp <SPC> = <SPC> [ ] <NL>              if <SPC> expr [ i [ 0 ] ] <SPC> not <SPC> in <SPC> "{,}" : <NL>                  tmp . append ( expr [ i [ 0 ] ] ) <NL>                  i [ 0 ] <SPC> += <SPC> 1 <NL>              elif <SPC> expr [ i [ 0 ] ] <SPC> == <SPC> "{" : <NL>                  tmp <SPC> = <SPC> generate_option ( expr , <SPC> i ) <NL>              options . append ( tmp ) <NL>          return <SPC> form_words ( options ) <NL> <NL> <TAB> return <SPC> generate_words ( S , <SPC> [ 0 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> breakPalindrome ( self , <SPC> palindrome ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( palindrome ) <SPC> // <SPC> 2 ) : <NL>          if <SPC> palindrome [ i ] <SPC> != <SPC> "a" : <NL>              return <SPC> palindrome [ : i ] <SPC> + <SPC> "a" <SPC> + <SPC> palindrome [ i <SPC> + <SPC> 1 : ] <NL> <TAB> return <SPC> palindrome [ : - 1 ] <SPC> + <SPC> "b" <SPC> if <SPC> len ( palindrome ) <SPC> >= <SPC> 2 <SPC> else <SPC> "" <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> leastBricks ( self , <SPC> wall ) : <NL> <NL> <TAB> widths <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> result <SPC> = <SPC> len ( wall ) <NL> <TAB> for <SPC> row <SPC> in <SPC> wall : <NL>          width <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( row ) <SPC> - <SPC> 1 ) : <NL>              width <SPC> += <SPC> row [ i ] <NL>              widths [ width ] <SPC> += <SPC> 1 <NL>              result <SPC> = <SPC> min ( result , <SPC> len ( wall ) <SPC> - <SPC> widths [ width ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n <SPC> + <SPC> 1 ) <NL> <TAB> self . size <SPC> = <SPC> [ 1 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> self . size [ - 1 ] <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> self . size [ max ( x_root , <SPC> y_root ) ] <SPC> += <SPC> self . size [ min ( x_root , <SPC> y_root ) ] <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> top ( self ) : <NL> <TAB> return <SPC> self . size [ self . find_set ( len ( self . size ) <SPC> - <SPC> 1 ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> hitBricks ( self , <SPC> grid , <SPC> hits ) : <NL> <NL> <TAB> def <SPC> index ( C , <SPC> r , <SPC> c ) : <NL>          return <SPC> r <SPC> * <SPC> C <SPC> + <SPC> c <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <TAB> R , <SPC> C <SPC> = <SPC> len ( grid ) , <SPC> len ( grid [ 0 ] ) <NL> <NL> <TAB> hit_grid <SPC> = <SPC> [ row [ : ] <SPC> for <SPC> row <SPC> in <SPC> grid ] <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> hits : <NL>          hit_grid [ i ] [ j ] <SPC> = <SPC> 0 <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( R <SPC> * <SPC> C ) <NL> <TAB> for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( hit_grid ) : <NL>          for <SPC> c , <SPC> val <SPC> in <SPC> enumerate ( row ) : <NL>              if <SPC> not <SPC> val : <NL>                  continue <NL>              if <SPC> r <SPC> == <SPC> 0 : <NL>                  union_find . union_set ( index ( C , <SPC> r , <SPC> c ) , <SPC> R <SPC> * <SPC> C ) <NL>              if <SPC> r <SPC> and <SPC> hit_grid [ r <SPC> - <SPC> 1 ] [ c ] : <NL>                  union_find . union_set ( index ( C , <SPC> r , <SPC> c ) , <SPC> index ( C , <SPC> r <SPC> - <SPC> 1 , <SPC> c ) ) <NL>              if <SPC> c <SPC> and <SPC> hit_grid [ r ] [ c <SPC> - <SPC> 1 ] : <NL>                  union_find . union_set ( index ( C , <SPC> r , <SPC> c ) , <SPC> index ( C , <SPC> r , <SPC> c <SPC> - <SPC> 1 ) ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> r , <SPC> c <SPC> in <SPC> reversed ( hits ) : <NL>          prev_roof <SPC> = <SPC> union_find . top ( ) <NL>          if <SPC> grid [ r ] [ c ] <SPC> == <SPC> 0 : <NL>              result . append ( 0 ) <NL>              continue <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              nr , <SPC> nc <SPC> = <SPC> ( r <SPC> + <SPC> d [ 0 ] , <SPC> c <SPC> + <SPC> d [ 1 ] ) <NL>              if <SPC> 0 <SPC> <= <SPC> nr <SPC> < <SPC> R <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> C <SPC> and <SPC> hit_grid [ nr ] [ nc ] : <NL>                  union_find . union_set ( index ( C , <SPC> r , <SPC> c ) , <SPC> index ( C , <SPC> nr , <SPC> nc ) ) <NL>          if <SPC> r <SPC> == <SPC> 0 : <NL>              union_find . union_set ( index ( C , <SPC> r , <SPC> c ) , <SPC> R <SPC> * <SPC> C ) <NL>          hit_grid [ r ] [ c ] <SPC> = <SPC> 1 <NL>          result . append ( max ( 0 , <SPC> union_find . top ( ) <SPC> - <SPC> prev_roof <SPC> - <SPC> 1 ) ) <NL> <TAB> return <SPC> result [ : : - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> brokenCalc ( self , <SPC> X , <SPC> Y ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> X <SPC> < <SPC> Y : <NL>          if <SPC> Y <SPC> % <SPC> 2 : <NL>              Y <SPC> += <SPC> 1 <NL>          else : <NL>              Y <SPC> /= <SPC> 2 <NL>          result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <SPC> + <SPC> X <SPC> - <SPC> Y <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> buddyStrings ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> if <SPC> len ( A ) <SPC> != <SPC> len ( B ) : <NL>          return <SPC> False <NL> <TAB> diff <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( A , <SPC> B ) : <NL>          if <SPC> a <SPC> != <SPC> b : <NL>              diff . append ( ( a , <SPC> b ) ) <NL>              if <SPC> len ( diff ) <SPC> > <SPC> 2 : <NL>                  return <SPC> False <NL> <TAB> return <SPC> ( not <SPC> diff <SPC> and <SPC> len ( set ( A ) ) <SPC> < <SPC> len ( A ) ) <SPC> or <SPC> ( <NL>          len ( diff ) <SPC> == <SPC> 2 <SPC> and <SPC> diff [ 0 ] <SPC> == <SPC> diff [ 1 ] [ : : - 1 ] <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> buildArray ( self , <SPC> target , <SPC> n ) : <NL> <NL> <TAB> result , <SPC> curr <SPC> = <SPC> [ ] , <SPC> 1 <NL> <TAB> for <SPC> t <SPC> in <SPC> target : <NL>          result . extend ( [ "Push" , <SPC> "Pop" ] <SPC> * <SPC> ( t <SPC> - <SPC> curr ) ) <NL>          result . append ( "Push" ) <NL>          curr <SPC> = <SPC> t <SPC> + <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numOfArrays ( self , <SPC> n , <SPC> m , <SPC> k ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ [ 0 ] <SPC> * <SPC> ( k <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <NL> <TAB> prefix_dp <SPC> = <SPC> [ [ [ 0 ] <SPC> * <SPC> ( k <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> m <SPC> + <SPC> 1 ) : <NL>          dp [ 1 ] [ i ] [ 1 ] <SPC> = <SPC> 1 <NL>          prefix_dp [ 1 ] [ i ] [ 1 ] <SPC> = <SPC> ( prefix_dp [ 1 ] [ i <SPC> - <SPC> 1 ] [ 1 ] <SPC> + <SPC> dp [ 1 ] [ i ] [ 1 ] ) <SPC> % <SPC> MOD <NL> <TAB> for <SPC> l <SPC> in <SPC> xrange ( 2 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> m <SPC> + <SPC> 1 ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> k <SPC> + <SPC> 1 ) : <NL>                  dp [ l <SPC> % <SPC> 2 ] [ i ] [ j ] <SPC> = <SPC> ( <NL>                      i <SPC> * <SPC> dp [ ( l <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ i ] [ j ] <SPC> % <SPC> MOD <NL>                      + <SPC> prefix_dp [ ( l <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <NL>                  ) <SPC> % <SPC> MOD <NL>                  prefix_dp [ l <SPC> % <SPC> 2 ] [ i ] [ j ] <SPC> = <SPC> ( <NL>                      prefix_dp [ l <SPC> % <SPC> 2 ] [ i <SPC> - <SPC> 1 ] [ j ] <SPC> + <SPC> dp [ l <SPC> % <SPC> 2 ] [ i ] [ j ] <NL>                  ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> prefix_dp [ n <SPC> % <SPC> 2 ] [ m ] [ k ] <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = " " , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> expTree ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> compute ( operands , <SPC> operators ) : <NL>          right , <SPC> left <SPC> = <SPC> operands . pop ( ) , <SPC> operands . pop ( ) <NL>          operands . append ( Node ( val = operators . pop ( ) , <SPC> left = left , <SPC> right = right ) ) <NL> <NL> <TAB> precedence <SPC> = <SPC> { "+" : <SPC> 0 , <SPC> "-" : <SPC> 0 , <SPC> "*" : <SPC> 1 , <SPC> "/" : <SPC> 1 } <NL> <TAB> operands , <SPC> operators , <SPC> operand <SPC> = <SPC> [ ] , <SPC> [ ] , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> s [ i ] . isdigit ( ) : <NL>              operand <SPC> = <SPC> operand <SPC> * <SPC> 10 <SPC> + <SPC> int ( s [ i ] ) <NL>              if <SPC> i <SPC> == <SPC> len ( s ) <SPC> - <SPC> 1 <SPC> or <SPC> not <SPC> s [ i <SPC> + <SPC> 1 ] . isdigit ( ) : <NL>                  operands . append ( Node ( val = str ( operand ) ) ) <NL>                  operand <SPC> = <SPC> 0 <NL>          elif <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>              operators . append ( s [ i ] ) <NL>          elif <SPC> s [ i ] <SPC> == <SPC> ")" : <NL>              while <SPC> operators [ - 1 ] <SPC> != <SPC> "(" : <NL>                  compute ( operands , <SPC> operators ) <NL>              operators . pop ( ) <NL>          elif <SPC> s [ i ] <SPC> in <SPC> precedence : <NL>              while <SPC> ( <NL>                  operators <NL>                  and <SPC> operators [ - 1 ] <SPC> in <SPC> precedence <NL>                  and <SPC> precedence [ operators [ - 1 ] ] <SPC> >= <SPC> precedence [ s [ i ] ] <NL>              ) : <NL>                  compute ( operands , <SPC> operators ) <NL>              operators . append ( s [ i ] ) <NL> <TAB> while <SPC> operators : <NL>          compute ( operands , <SPC> operators ) <NL> <TAB> return <SPC> operands [ - 1 ] <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumBoxes ( self , <SPC> n ) : <NL> <NL> <TAB> h <SPC> = <SPC> int ( ( 6 <SPC> * <SPC> n ) <SPC> ** <SPC> ( 1.0 <SPC> / <SPC> 3 ) ) <NL> <TAB> if <SPC> h <SPC> * <SPC> ( h <SPC> + <SPC> 1 ) <SPC> * <SPC> ( h <SPC> + <SPC> 2 ) <SPC> > <SPC> 6 <SPC> * <SPC> n : <NL> <NL>          h <SPC> -= <SPC> 1 <NL> <TAB> n <SPC> -= <SPC> h <SPC> * <SPC> ( h <SPC> + <SPC> 1 ) <SPC> * <SPC> ( h <SPC> + <SPC> 2 ) <SPC> // <SPC> 6 <NL> <TAB> d <SPC> = <SPC> int ( <NL>          math . ceil ( ( - 1 <SPC> + <SPC> ( 1 <SPC> + <SPC> 8 <SPC> * <SPC> n ) <SPC> ** <SPC> 0.5 ) <SPC> / <SPC> 2 ) <NL> <TAB> ) <NL> <TAB> return <SPC> h <SPC> * <SPC> ( h <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 <SPC> + <SPC> d <NL> <NL> <NL> import <SPC> threading <NL> <NL> <NL> class <SPC> H2O ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __l <SPC> = <SPC> threading . Lock ( ) <NL> <TAB> self . __nH <SPC> = <SPC> 0 <NL> <TAB> self . __nO <SPC> = <SPC> 0 <NL> <TAB> self . __releaseHydrogen <SPC> = <SPC> None <NL> <TAB> self . __releaseOxygen <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> hydrogen ( self , <SPC> releaseHydrogen ) : <NL> <TAB> with <SPC> self . __l : <NL>          self . __releaseHydrogen <SPC> = <SPC> releaseHydrogen <NL>          self . __nH <SPC> += <SPC> 1 <NL>          self . __output ( ) <NL> <NL> <TAB> def <SPC> oxygen ( self , <SPC> releaseOxygen ) : <NL> <TAB> with <SPC> self . __l : <NL>          self . __releaseOxygen <SPC> = <SPC> releaseOxygen <NL>          self . __nO <SPC> += <SPC> 1 <NL>          self . __output ( ) <NL> <NL> <TAB> def <SPC> __output ( self ) : <NL> <TAB> while <SPC> self . __nH <SPC> >= <SPC> 2 <SPC> and <SPC> self . __nO <SPC> >= <SPC> 1 : <NL>          self . __nH <SPC> -= <SPC> 2 <NL>          self . __nO <SPC> -= <SPC> 1 <NL>          self . __releaseHydrogen ( ) <NL>          self . __releaseHydrogen ( ) <NL>          self . __releaseOxygen ( ) <NL> <NL> <NL> class <SPC> H2O2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __nH <SPC> = <SPC> 0 <NL> <TAB> self . __nO <SPC> = <SPC> 0 <NL> <TAB> self . __cv <SPC> = <SPC> threading . Condition ( ) <NL> <NL> <TAB> def <SPC> hydrogen ( self , <SPC> releaseHydrogen ) : <NL> <NL> <TAB> with <SPC> self . __cv : <NL>          while <SPC> ( self . __nH <SPC> + <SPC> 1 ) <SPC> - <SPC> 2 <SPC> * <SPC> self . __nO <SPC> > <SPC> 2 : <NL>              self . __cv . wait ( ) <NL>          self . __nH <SPC> += <SPC> 1 <NL> <NL>          releaseHydrogen ( ) <NL>          self . __cv . notifyAll ( ) <NL> <NL> <TAB> def <SPC> oxygen ( self , <SPC> releaseOxygen ) : <NL> <NL> <TAB> with <SPC> self . __cv : <NL>          while <SPC> 2 <SPC> * <SPC> ( self . __nO <SPC> + <SPC> 1 ) <SPC> - <SPC> self . __nH <SPC> > <SPC> 2 : <NL>              self . __cv . wait ( ) <NL>          self . __nO <SPC> += <SPC> 1 <NL> <NL>          releaseOxygen ( ) <NL>          self . __cv . notifyAll ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findBuildings ( self , <SPC> heights ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( heights ) ) ) : <NL>          if <SPC> not <SPC> result <SPC> or <SPC> heights [ i ] <SPC> > <SPC> heights [ result [ - 1 ] ] : <NL>              result . append ( i ) <NL> <TAB> result . reverse ( ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findBuildings ( self , <SPC> heights ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> h <SPC> in <SPC> enumerate ( heights ) : <NL>          while <SPC> result <SPC> and <SPC> heights [ result [ - 1 ] ] <SPC> <= <SPC> h : <NL>              result . pop ( ) <NL>          result . append ( i ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> flipLights ( self , <SPC> n , <SPC> m ) : <NL> <NL> <TAB> if <SPC> m <SPC> == <SPC> 0 : <NL>          return <SPC> 1 <NL> <TAB> if <SPC> n <SPC> == <SPC> 1 : <NL>          return <SPC> 2 <NL> <TAB> if <SPC> m <SPC> == <SPC> 1 <SPC> and <SPC> n <SPC> == <SPC> 2 : <NL>          return <SPC> 3 <NL> <TAB> if <SPC> m <SPC> == <SPC> 1 <SPC> or <SPC> n <SPC> == <SPC> 2 : <NL>          return <SPC> 4 <NL> <TAB> if <SPC> m <SPC> == <SPC> 2 : <NL>          return <SPC> 7 <NL> <TAB> return <SPC> 8 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numTimesAllBlue ( self , <SPC> light ) : <NL> <NL> <TAB> result , <SPC> right <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( light , <SPC> 1 ) : <NL>          right <SPC> = <SPC> max ( right , <SPC> num ) <NL>          result <SPC> += <SPC> right <SPC> == <SPC> i <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minFlips ( self , <SPC> target ) : <NL> <NL> <TAB> result , <SPC> curr <SPC> = <SPC> 0 , <SPC> "0" <NL> <TAB> for <SPC> c <SPC> in <SPC> target : <NL>          if <SPC> c <SPC> == <SPC> curr : <NL>              continue <NL>          curr <SPC> = <SPC> c <NL>          result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> bulbSwitch ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> int ( math . sqrt ( n ) ) <NL> <NL> <NL> import <SPC> operator <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> defaultdict , <SPC> Counter <NL> from <SPC> itertools <SPC> import <SPC> izip , <SPC> imap <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getHint ( self , <SPC> secret , <SPC> guess ) : <NL> <NL> <TAB> A , <SPC> B <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> defaultdict ( int ) <NL> <TAB> for <SPC> s , <SPC> g <SPC> in <SPC> izip ( secret , <SPC> guess ) : <NL>          if <SPC> s <SPC> == <SPC> g : <NL>              A <SPC> += <SPC> 1 <NL>          else : <NL>              B <SPC> += <SPC> int ( lookup [ s ] <SPC> < <SPC> 0 ) <SPC> + <SPC> int ( lookup [ g ] <SPC> > <SPC> 0 ) <NL>              lookup [ s ] <SPC> += <SPC> 1 <NL>              lookup [ g ] <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> "%dA%dB" <SPC> % <SPC> ( A , <SPC> B ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> getHint ( self , <SPC> secret , <SPC> guess ) : <NL> <NL> <TAB> A <SPC> = <SPC> sum ( imap ( operator . eq , <SPC> secret , <SPC> guess ) ) <NL> <TAB> B <SPC> = <SPC> sum ( ( Counter ( secret ) <SPC> & <SPC> Counter ( guess ) ) . values ( ) ) <SPC> - <SPC> A <NL> <TAB> return <SPC> "%dA%dB" <SPC> % <SPC> ( A , <SPC> B ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxCoins ( self , <SPC> nums ) : <NL> <NL> <TAB> coins <SPC> = <SPC> [ 1 ] <SPC> + <SPC> [ i <SPC> for <SPC> i <SPC> in <SPC> nums <SPC> if <SPC> i <SPC> > <SPC> 0 ] <SPC> + <SPC> [ 1 ] <NL> <TAB> n <SPC> = <SPC> len ( coins ) <NL> <TAB> max_coins <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <NL> <TAB> for <SPC> k <SPC> in <SPC> xrange ( 2 , <SPC> n ) : <NL>          for <SPC> left <SPC> in <SPC> xrange ( n <SPC> - <SPC> k ) : <NL>              right <SPC> = <SPC> left <SPC> + <SPC> k <NL>              for <SPC> i <SPC> in <SPC> xrange ( left <SPC> + <SPC> 1 , <SPC> right ) : <NL>                  max_coins [ left ] [ right ] <SPC> = <SPC> max ( <NL>                      max_coins [ left ] [ right ] , <NL>                      coins [ left ] <SPC> * <SPC> coins [ i ] <SPC> * <SPC> coins [ right ] <NL>                      + <SPC> max_coins [ left ] [ i ] <NL>                      + <SPC> max_coins [ i ] [ right ] , <NL>                  ) <NL> <NL> <TAB> return <SPC> max_coins [ 0 ] [ - 1 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numBusesToDestination ( self , <SPC> routes , <SPC> S , <SPC> T ) : <NL> <NL> <TAB> if <SPC> S <SPC> == <SPC> T : <NL>          return <SPC> 0 <NL> <NL> <TAB> to_route <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> i , <SPC> route <SPC> in <SPC> enumerate ( routes ) : <NL>          for <SPC> stop <SPC> in <SPC> route : <NL>              to_route [ stop ] . add ( i ) <NL> <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> q <SPC> = <SPC> [ S ] <NL> <TAB> lookup <SPC> = <SPC> set ( [ S ] ) <NL> <TAB> while <SPC> q : <NL>          next_q <SPC> = <SPC> [ ] <NL>          for <SPC> stop <SPC> in <SPC> q : <NL>              for <SPC> i <SPC> in <SPC> to_route [ stop ] : <NL>                  for <SPC> next_stop <SPC> in <SPC> routes [ i ] : <NL>                      if <SPC> next_stop <SPC> in <SPC> lookup : <NL>                          continue <NL>                      if <SPC> next_stop <SPC> == <SPC> T : <NL>                          return <SPC> result <NL>                      next_q . append ( next_stop ) <NL>                      to_route [ next_stop ] . remove ( i ) <NL>                      lookup . add ( next_stop ) <NL>          q <SPC> = <SPC> next_q <NL>          result <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> totalMoney ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> arithmetic_sequence_sum ( a , <SPC> d , <SPC> n ) : <NL>          return <SPC> ( 2 <SPC> * <SPC> a <SPC> + <SPC> ( n <SPC> - <SPC> 1 ) <SPC> * <SPC> d ) <SPC> * <SPC> n <SPC> // <SPC> 2 <NL> <NL> <TAB> cost , <SPC> day <SPC> = <SPC> 1 , <SPC> 7 <NL> <TAB> first_week_cost <SPC> = <SPC> arithmetic_sequence_sum ( cost , <SPC> cost , <SPC> day ) <NL> <TAB> week , <SPC> remain_day <SPC> = <SPC> divmod ( n , <SPC> day ) <NL> <TAB> return <SPC> arithmetic_sequence_sum ( <NL>          first_week_cost , <SPC> cost <SPC> * <SPC> day , <SPC> week <NL> <TAB> ) <SPC> + <SPC> arithmetic_sequence_sum ( cost <SPC> * <SPC> ( week <SPC> + <SPC> 1 ) , <SPC> cost , <SPC> remain_day ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> camelMatch ( self , <SPC> queries , <SPC> pattern ) : <NL> <NL> <TAB> def <SPC> is_matched ( query , <SPC> pattern ) : <NL>          i <SPC> = <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> query : <NL>              if <SPC> i <SPC> < <SPC> len ( pattern ) <SPC> and <SPC> pattern [ i ] <SPC> == <SPC> c : <NL>                  i <SPC> += <SPC> 1 <NL>              elif <SPC> c . isupper ( ) : <NL>                  return <SPC> False <NL>          return <SPC> i <SPC> == <SPC> len ( pattern ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> query <SPC> in <SPC> queries : <NL>          result . append ( is_matched ( query , <SPC> pattern ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> assignBikes ( self , <SPC> workers , <SPC> bikes ) : <NL> <NL> <TAB> def <SPC> manhattan ( p1 , <SPC> p2 ) : <NL>          return <SPC> abs ( p1 [ 0 ] <SPC> - <SPC> p2 [ 0 ] ) <SPC> + <SPC> abs ( p1 [ 1 ] <SPC> - <SPC> p2 [ 1 ] ) <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ float ( "inf" ) ] <SPC> * <SPC> ( ( 1 <SPC> << <SPC> len ( bikes ) ) ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( workers ) ) : <NL>          dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] <SPC> = <SPC> [ float ( "inf" ) ] <SPC> * <SPC> ( ( 1 <SPC> << <SPC> len ( bikes ) ) ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( bikes ) ) : <NL>              for <SPC> taken <SPC> in <SPC> xrange ( ( 1 <SPC> << <SPC> len ( bikes ) ) ) : <NL>                  if <SPC> taken <SPC> & <SPC> ( 1 <SPC> << <SPC> j ) : <NL>                      continue <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ taken <SPC> | <SPC> ( 1 <SPC> << <SPC> j ) ] <SPC> = <SPC> min ( <NL>                      dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ taken <SPC> | <SPC> ( 1 <SPC> << <SPC> j ) ] , <NL>                      dp [ i <SPC> % <SPC> 2 ] [ taken ] <SPC> + <SPC> manhattan ( workers [ i ] , <SPC> bikes [ j ] ) , <NL>                  ) <NL> <TAB> return <SPC> min ( dp [ len ( workers ) <SPC> % <SPC> 2 ] ) <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> assignBikes ( self , <SPC> workers , <SPC> bikes ) : <NL> <NL> <TAB> def <SPC> manhattan ( p1 , <SPC> p2 ) : <NL>          return <SPC> abs ( p1 [ 0 ] <SPC> - <SPC> p2 [ 0 ] ) <SPC> + <SPC> abs ( p1 [ 1 ] <SPC> - <SPC> p2 [ 1 ] ) <NL> <NL> <TAB> min_heap <SPC> = <SPC> [ ( 0 , <SPC> 0 , <SPC> 0 ) ] <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> while <SPC> min_heap : <NL>          cost , <SPC> i , <SPC> taken <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> ( i , <SPC> taken ) <SPC> in <SPC> lookup : <NL>              continue <NL>          lookup . add ( ( i , <SPC> taken ) ) <NL>          if <SPC> i <SPC> == <SPC> len ( workers ) : <NL>              return <SPC> cost <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( bikes ) ) : <NL>              if <SPC> taken <SPC> & <SPC> ( 1 <SPC> << <SPC> j ) : <NL>                  continue <NL>              heapq . heappush ( <NL>                  min_heap , <NL>                  ( <NL>                      cost <SPC> + <SPC> manhattan ( workers [ i ] , <SPC> bikes [ j ] ) , <NL>                      i <SPC> + <SPC> 1 , <NL>                      taken <SPC> | <SPC> ( 1 <SPC> << <SPC> j ) , <NL>                  ) , <NL>              ) <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> assignBikes ( self , <SPC> workers , <SPC> bikes ) : <NL> <NL> <TAB> def <SPC> manhattan ( p1 , <SPC> p2 ) : <NL>          return <SPC> abs ( p1 [ 0 ] <SPC> - <SPC> p2 [ 0 ] ) <SPC> + <SPC> abs ( p1 [ 1 ] <SPC> - <SPC> p2 [ 1 ] ) <NL> <NL> <TAB> distances <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( workers ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( workers ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( bikes ) ) : <NL>              distances [ i ] . append ( ( manhattan ( workers [ i ] , <SPC> bikes [ j ] ) , <SPC> i , <SPC> j ) ) <NL>          distances [ i ] . sort ( reverse = True ) <NL> <NL> <TAB> result <SPC> = <SPC> [ None ] <SPC> * <SPC> len ( workers ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( workers ) ) : <NL>          heapq . heappush ( min_heap , <SPC> distances [ i ] . pop ( ) ) <NL> <TAB> while <SPC> len ( lookup ) <SPC> < <SPC> len ( workers ) : <NL>          _ , <SPC> worker , <SPC> bike <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> bike <SPC> not <SPC> in <SPC> lookup : <NL>              result [ worker ] <SPC> = <SPC> bike <NL>              lookup . add ( bike ) <NL>          else : <NL>              heapq . heappush ( min_heap , <SPC> distances [ worker ] . pop ( ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canConvertString ( self , <SPC> s , <SPC> t , <SPC> k ) : <NL> <NL> <TAB> if <SPC> len ( s ) <SPC> != <SPC> len ( t ) : <NL>          return <SPC> False <NL> <TAB> cnt <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( s , <SPC> t ) : <NL>          diff <SPC> = <SPC> ( ord ( b ) <SPC> - <SPC> ord ( a ) ) <SPC> % <SPC> len ( cnt ) <NL>          if <SPC> diff <SPC> != <SPC> 0 <SPC> and <SPC> cnt [ diff ] <SPC> * <SPC> len ( cnt ) <SPC> + <SPC> diff <SPC> > <SPC> k : <NL>              return <SPC> False <NL>          cnt [ diff ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canIWin ( self , <SPC> maxChoosableInteger , <SPC> desiredTotal ) : <NL> <NL> <TAB> def <SPC> canIWinHelper ( maxChoosableInteger , <SPC> desiredTotal , <SPC> visited , <SPC> lookup ) : <NL>          if <SPC> visited <SPC> in <SPC> lookup : <NL>              return <SPC> lookup [ visited ] <NL> <NL>          mask <SPC> = <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( maxChoosableInteger ) : <NL>              if <SPC> visited <SPC> & <SPC> mask <SPC> == <SPC> 0 : <NL>                  if <SPC> i <SPC> + <SPC> 1 <SPC> >= <SPC> desiredTotal <SPC> or <SPC> not <SPC> canIWinHelper ( <NL>                      maxChoosableInteger , <NL>                      desiredTotal <SPC> - <SPC> ( i <SPC> + <SPC> 1 ) , <NL>                      visited <SPC> | <SPC> mask , <NL>                      lookup , <NL>                  ) : <NL>                      lookup [ visited ] <SPC> = <SPC> True <NL>                      return <SPC> True <NL>              mask <SPC> <<= <SPC> 1 <NL>          lookup [ visited ] <SPC> = <SPC> False <NL>          return <SPC> False <NL> <NL> <TAB> if <SPC> ( 1 <SPC> + <SPC> maxChoosableInteger ) <SPC> * <SPC> ( maxChoosableInteger <SPC> / <SPC> 2 ) <SPC> < <SPC> desiredTotal : <NL>          return <SPC> False <NL> <NL> <TAB> return <SPC> canIWinHelper ( maxChoosableInteger , <SPC> desiredTotal , <SPC> 0 , <SPC> { } ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canMakeArithmeticProgression ( self , <SPC> arr ) : <NL> <NL> <TAB> m <SPC> = <SPC> min ( arr ) <NL> <TAB> d <SPC> = <SPC> ( max ( arr ) <SPC> - <SPC> m ) <SPC> // <SPC> ( len ( arr ) <SPC> - <SPC> 1 ) <NL> <TAB> if <SPC> not <SPC> d : <NL>          return <SPC> True <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( arr ) : <NL>          if <SPC> arr [ i ] <SPC> == <SPC> m <SPC> + <SPC> i <SPC> * <SPC> d : <NL>              i <SPC> += <SPC> 1 <NL>          else : <NL>              j , <SPC> r <SPC> = <SPC> divmod ( arr [ i ] <SPC> - <SPC> m , <SPC> d ) <NL>              if <SPC> r <SPC> or <SPC> j <SPC> >= <SPC> len ( arr ) <SPC> or <SPC> arr [ i ] <SPC> == <SPC> arr [ j ] : <NL>                  return <SPC> False <NL>              arr [ i ] , <SPC> arr [ j ] <SPC> = <SPC> arr [ j ] , <SPC> arr [ i ] <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canMakePaliQueries ( self , <SPC> s , <SPC> queries ) : <NL> <NL> <TAB> CHARSET_SIZE <SPC> = <SPC> 26 <NL> <TAB> curr , <SPC> count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> CHARSET_SIZE , <SPC> [ [ 0 ] <SPC> * <SPC> CHARSET_SIZE ] <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          curr [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL>          count . append ( curr [ : ] ) <NL> <TAB> return <SPC> [ <NL>          sum ( ( b <SPC> - <SPC> a ) <SPC> % <NL>              2 <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( count [ left ] , <SPC> count [ right <SPC> + <SPC> 1 ] ) ) <NL>          // <SPC> 2 <NL>          <= <SPC> k <NL>          for <SPC> left , <SPC> right , <SPC> k <SPC> in <SPC> queries <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canPlaceFlowers ( self , <SPC> flowerbed , <SPC> n ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( flowerbed ) ) : <NL>          if <SPC> ( <NL>              flowerbed [ i ] <SPC> == <SPC> 0 <NL>              and <SPC> ( i <SPC> == <SPC> 0 <SPC> or <SPC> flowerbed [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> 0 ) <NL>              and <SPC> ( i <SPC> == <SPC> len ( flowerbed ) <SPC> - <SPC> 1 <SPC> or <SPC> flowerbed [ i <SPC> + <SPC> 1 ] <SPC> == <SPC> 0 ) <NL>          ) : <NL>              flowerbed [ i ] <SPC> = <SPC> 1 <NL>              n <SPC> -= <SPC> 1 <NL>          if <SPC> n <SPC> <= <SPC> 0 : <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canEat ( self , <SPC> candiesCount , <SPC> queries ) : <NL> <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( candiesCount ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( candiesCount ) : <NL>          prefix [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> prefix [ i ] <SPC> + <SPC> c <NL> <TAB> return <SPC> [ prefix [ t ] <SPC> // <SPC> c <SPC> < <SPC> d <SPC> + <SPC> 1 <SPC> <= <SPC> prefix [ t <SPC> + <SPC> 1 ] <SPC> // <SPC> 1 <SPC> for <SPC> t , <SPC> d , <SPC> c <SPC> in <SPC> queries ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> candyCrush ( self , <SPC> board ) : <NL> <NL> <TAB> R , <SPC> C <SPC> = <SPC> len ( board ) , <SPC> len ( board [ 0 ] ) <NL> <TAB> changed <SPC> = <SPC> True <NL> <NL> <TAB> while <SPC> changed : <NL>          changed <SPC> = <SPC> False <NL> <NL>          for <SPC> r <SPC> in <SPC> xrange ( R ) : <NL>              for <SPC> c <SPC> in <SPC> xrange ( C <SPC> - <SPC> 2 ) : <NL>                  if <SPC> ( <NL>                      abs ( board [ r ] [ c ] ) <NL>                      == <SPC> abs ( board [ r ] [ c <SPC> + <SPC> 1 ] ) <NL>                      == <SPC> abs ( board [ r ] [ c <SPC> + <SPC> 2 ] ) <NL>                      != <SPC> 0 <NL>                  ) : <NL>                      board [ r ] [ c ] <SPC> = <SPC> board [ r ] [ c <SPC> + <SPC> 1 ] <SPC> = <SPC> board [ r ] [ c <SPC> + <SPC> 2 ] <SPC> = <SPC> - abs ( <NL>                          board [ r ] [ c ] <NL>                      ) <NL>                      changed <SPC> = <SPC> True <NL> <NL>          for <SPC> r <SPC> in <SPC> xrange ( R <SPC> - <SPC> 2 ) : <NL>              for <SPC> c <SPC> in <SPC> xrange ( C ) : <NL>                  if <SPC> ( <NL>                      abs ( board [ r ] [ c ] ) <NL>                      == <SPC> abs ( board [ r <SPC> + <SPC> 1 ] [ c ] ) <NL>                      == <SPC> abs ( board [ r <SPC> + <SPC> 2 ] [ c ] ) <NL>                      != <SPC> 0 <NL>                  ) : <NL>                      board [ r ] [ c ] <SPC> = <SPC> board [ r <SPC> + <SPC> 1 ] [ c ] <SPC> = <SPC> board [ r <SPC> + <SPC> 2 ] [ c ] <SPC> = <SPC> - abs ( <NL>                          board [ r ] [ c ] <NL>                      ) <NL>                      changed <SPC> = <SPC> True <NL> <NL>          for <SPC> c <SPC> in <SPC> xrange ( C ) : <NL>              i <SPC> = <SPC> R <SPC> - <SPC> 1 <NL>              for <SPC> r <SPC> in <SPC> reversed ( xrange ( R ) ) : <NL>                  if <SPC> board [ r ] [ c ] <SPC> > <SPC> 0 : <NL>                      board [ i ] [ c ] <SPC> = <SPC> board [ r ] [ c ] <NL>                      i <SPC> -= <SPC> 1 <NL>              for <SPC> r <SPC> in <SPC> reversed ( xrange ( i <SPC> + <SPC> 1 ) ) : <NL>                  board [ r ] [ c ] <SPC> = <SPC> 0 <NL> <NL> <TAB> return <SPC> board <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> candy ( self , <SPC> ratings ) : <NL> <TAB> candies <SPC> = <SPC> [ 1 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( ratings ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( ratings ) ) : <NL>          if <SPC> ratings [ i ] <SPC> > <SPC> ratings [ i <SPC> - <SPC> 1 ] : <NL>              candies [ i ] <SPC> = <SPC> candies [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( ratings ) ) ) : <NL>          if <SPC> ratings [ i <SPC> - <SPC> 1 ] <SPC> > <SPC> ratings [ i ] <SPC> and <SPC> candies [ i <SPC> - <SPC> 1 ] <SPC> <= <SPC> candies [ i ] : <NL>              candies [ i <SPC> - <SPC> 1 ] <SPC> = <SPC> candies [ i ] <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> sum ( candies ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shipWithinDays ( self , <SPC> weights , <SPC> D ) : <NL> <NL> <TAB> def <SPC> possible ( weights , <SPC> D , <SPC> mid ) : <NL>          result , <SPC> curr <SPC> = <SPC> 1 , <SPC> 0 <NL>          for <SPC> w <SPC> in <SPC> weights : <NL>              if <SPC> curr <SPC> + <SPC> w <SPC> > <SPC> mid : <NL>                  result <SPC> += <SPC> 1 <NL>                  curr <SPC> = <SPC> 0 <NL>              curr <SPC> += <SPC> w <NL>          return <SPC> result <SPC> <= <SPC> D <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> max ( weights ) , <SPC> sum ( weights ) <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> possible ( weights , <SPC> D , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getCollisionTimes ( self , <SPC> cars ) : <NL> <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> result <SPC> = <SPC> [ - 1.0 ] <SPC> * <SPC> len ( cars ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( cars ) ) ) : <NL>          p , <SPC> s <SPC> = <SPC> cars [ i ] <NL>          while <SPC> stk <SPC> and <SPC> ( <NL>              cars [ stk [ - 1 ] ] [ 1 ] <SPC> >= <SPC> s <NL>              or <SPC> 0 <NL>              < <SPC> result [ stk [ - 1 ] ] <NL>              <= <SPC> float ( cars [ stk [ - 1 ] ] [ 0 ] <SPC> - <SPC> p ) <SPC> / <SPC> ( s <SPC> - <SPC> cars [ stk [ - 1 ] ] [ 1 ] ) <NL>          ) : <NL>              stk . pop ( ) <NL>          if <SPC> stk : <NL>              result [ i ] <SPC> = <SPC> float ( cars [ stk [ - 1 ] ] [ 0 ] <SPC> - <SPC> p ) <SPC> / <SPC> ( s <SPC> - <SPC> cars [ stk [ - 1 ] ] [ 1 ] ) <NL>          stk . append ( i ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> carFleet ( self , <SPC> target , <SPC> position , <SPC> speed ) : <NL> <NL> <TAB> times <SPC> = <SPC> [ float ( target <SPC> - <SPC> p ) <SPC> / <SPC> s <SPC> for <SPC> p , <SPC> s <SPC> in <SPC> sorted ( zip ( position , <SPC> speed ) ) ] <NL> <TAB> result , <SPC> curr <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> t <SPC> in <SPC> reversed ( times ) : <NL>          if <SPC> t <SPC> > <SPC> curr : <NL>              result <SPC> += <SPC> 1 <NL>              curr <SPC> = <SPC> t <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> carPooling ( self , <SPC> trips , <SPC> capacity ) : <NL> <NL> <TAB> line <SPC> = <SPC> [ x <SPC> for <SPC> num , <SPC> start , <SPC> end <SPC> in <SPC> trips <SPC> for <SPC> x <SPC> in <SPC> [ [ start , <SPC> num ] , <SPC> [ end , <SPC> - num ] ] ] <NL> <TAB> line . sort ( ) <NL> <TAB> for <SPC> _ , <SPC> num <SPC> in <SPC> line : <NL>          capacity <SPC> -= <SPC> num <NL>          if <SPC> capacity <SPC> < <SPC> 0 : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> flipgame ( self , <SPC> fronts , <SPC> backs ) : <NL> <NL> <TAB> same <SPC> = <SPC> { n <SPC> for <SPC> i , <SPC> n <SPC> in <SPC> enumerate ( fronts ) <SPC> if <SPC> n <SPC> == <SPC> backs [ i ] } <NL> <TAB> result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> n <SPC> in <SPC> itertools . chain ( fronts , <SPC> backs ) : <NL>          if <SPC> n <SPC> not <SPC> in <SPC> same : <NL>              result <SPC> = <SPC> min ( result , <SPC> n ) <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> < <SPC> float ( "inf" ) <SPC> else <SPC> 0 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canMouseWin ( self , <SPC> grid , <SPC> catJump , <SPC> mouseJump ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> DRAW , <SPC> MOUSE , <SPC> CAT <SPC> = <SPC> range ( 3 ) <NL> <NL> <TAB> def <SPC> parents ( m , <SPC> c , <SPC> t ) : <NL>          if <SPC> t <SPC> == <SPC> CAT : <NL>              for <SPC> nm <SPC> in <SPC> graph [ m , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t ] : <NL>                  yield <SPC> nm , <SPC> c , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t <NL>          else : <NL>              for <SPC> nc <SPC> in <SPC> graph [ c , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t ] : <NL>                  yield <SPC> m , <SPC> nc , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t <NL> <NL> <TAB> R , <SPC> C <SPC> = <SPC> len ( grid ) , <SPC> len ( grid [ 0 ] ) <NL> <TAB> N <SPC> = <SPC> R <SPC> * <SPC> C <NL> <TAB> WALLS <SPC> = <SPC> set ( ) <NL> <TAB> FOOD , <SPC> MOUSE_START , <SPC> CAT_START <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> 3 <NL> <TAB> for <SPC> r <SPC> in <SPC> xrange ( R ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( C ) : <NL>              if <SPC> grid [ r ] [ c ] <SPC> == <SPC> "M" : <NL>                  MOUSE_START <SPC> = <SPC> r <SPC> * <SPC> C <SPC> + <SPC> c <NL>              elif <SPC> grid [ r ] [ c ] <SPC> == <SPC> "C" : <NL>                  CAT_START <SPC> = <SPC> r <SPC> * <SPC> C <SPC> + <SPC> c <NL>              elif <SPC> grid [ r ] [ c ] <SPC> == <SPC> "F" : <NL>                  FOOD <SPC> = <SPC> r <SPC> * <SPC> C <SPC> + <SPC> c <NL>              elif <SPC> grid [ r ] [ c ] <SPC> == <SPC> "#" : <NL>                  WALLS . add ( r <SPC> * <SPC> C <SPC> + <SPC> c ) <NL> <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> jump <SPC> = <SPC> { MOUSE : <SPC> mouseJump , <SPC> CAT : <SPC> catJump } <NL> <TAB> for <SPC> r <SPC> in <SPC> xrange ( R ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( C ) : <NL>              if <SPC> grid [ r ] [ c ] <SPC> == <SPC> "#" : <NL>                  continue <NL>              pos <SPC> = <SPC> r <SPC> * <SPC> C <SPC> + <SPC> c <NL>              for <SPC> t <SPC> in <SPC> [ MOUSE , <SPC> CAT ] : <NL>                  for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                      for <SPC> d <SPC> in <SPC> xrange ( jump [ t ] <SPC> + <SPC> 1 ) : <NL>                          nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr <SPC> * <SPC> d , <SPC> c <SPC> + <SPC> dc <SPC> * <SPC> d <NL>                          if <SPC> not <SPC> ( <NL>                              0 <SPC> <= <SPC> nr <SPC> < <SPC> R <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> C <SPC> and <SPC> grid [ nr ] [ nc ] <SPC> != <SPC> "#" <NL>                          ) : <NL>                              break <NL>                          graph [ pos , <SPC> t ] . add ( nr <SPC> * <SPC> C <SPC> + <SPC> nc ) <NL> <NL> <TAB> degree <SPC> = <SPC> { } <NL> <TAB> for <SPC> m <SPC> in <SPC> xrange ( N ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( N ) : <NL>              degree [ m , <SPC> c , <SPC> MOUSE ] <SPC> = <SPC> len ( graph [ m , <SPC> MOUSE ] ) <NL>              degree [ m , <SPC> c , <SPC> CAT ] <SPC> = <SPC> len ( graph [ c , <SPC> CAT ] ) <NL> <TAB> color <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N ) : <NL>          if <SPC> i <SPC> in <SPC> WALLS <SPC> or <SPC> i <SPC> == <SPC> FOOD : <NL>              continue <NL>          color [ FOOD , <SPC> i , <SPC> CAT ] <SPC> = <SPC> MOUSE <NL>          q . append ( ( FOOD , <SPC> i , <SPC> CAT , <SPC> MOUSE ) ) <NL>          color [ i , <SPC> FOOD , <SPC> MOUSE ] <SPC> = <SPC> CAT <NL>          q . append ( ( i , <SPC> FOOD , <SPC> MOUSE , <SPC> CAT ) ) <NL>          for <SPC> t <SPC> in <SPC> [ MOUSE , <SPC> CAT ] : <NL>              color [ i , <SPC> i , <SPC> t ] <SPC> = <SPC> CAT <NL>              q . append ( ( i , <SPC> i , <SPC> t , <SPC> CAT ) ) <NL> <TAB> while <SPC> q : <NL>          i , <SPC> j , <SPC> t , <SPC> c <SPC> = <SPC> q . popleft ( ) <NL>          for <SPC> ni , <SPC> nj , <SPC> nt <SPC> in <SPC> parents ( i , <SPC> j , <SPC> t ) : <NL>              if <SPC> color [ ni , <SPC> nj , <SPC> nt ] <SPC> != <SPC> DRAW : <NL>                  continue <NL>              if <SPC> nt <SPC> == <SPC> c : <NL>                  color [ ni , <SPC> nj , <SPC> nt ] <SPC> = <SPC> c <NL>                  q . append ( ( ni , <SPC> nj , <SPC> nt , <SPC> c ) ) <NL>                  continue <NL>              degree [ ni , <SPC> nj , <SPC> nt ] <SPC> -= <SPC> 1 <NL>              if <SPC> not <SPC> degree [ ni , <SPC> nj , <SPC> nt ] : <NL>                  color [ ni , <SPC> nj , <SPC> nt ] <SPC> = <SPC> c <NL>                  q . append ( ( ni , <SPC> nj , <SPC> nt , <SPC> c ) ) <NL> <TAB> return <SPC> color [ MOUSE_START , <SPC> CAT_START , <SPC> MOUSE ] <SPC> == <SPC> MOUSE <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> canMouseWin ( self , <SPC> grid , <SPC> catJump , <SPC> mouseJump ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> DRAW , <SPC> MOUSE , <SPC> CAT <SPC> = <SPC> range ( 3 ) <NL> <NL> <TAB> def <SPC> parents ( m , <SPC> c , <SPC> t ) : <NL>          if <SPC> t <SPC> == <SPC> CAT : <NL>              for <SPC> nm <SPC> in <SPC> graph [ m , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t ] : <NL>                  yield <SPC> nm , <SPC> c , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t <NL>          else : <NL>              for <SPC> nc <SPC> in <SPC> graph [ c , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t ] : <NL>                  yield <SPC> m , <SPC> nc , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t <NL> <NL> <TAB> R , <SPC> C <SPC> = <SPC> len ( grid ) , <SPC> len ( grid [ 0 ] ) <NL> <TAB> N <SPC> = <SPC> R <SPC> * <SPC> C <NL> <TAB> WALLS <SPC> = <SPC> set ( ) <NL> <TAB> FOOD , <SPC> MOUSE_START , <SPC> CAT_START <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> 3 <NL> <TAB> for <SPC> r <SPC> in <SPC> xrange ( R ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( C ) : <NL>              if <SPC> grid [ r ] [ c ] <SPC> == <SPC> "M" : <NL>                  MOUSE_START <SPC> = <SPC> r <SPC> * <SPC> C <SPC> + <SPC> c <NL>              elif <SPC> grid [ r ] [ c ] <SPC> == <SPC> "C" : <NL>                  CAT_START <SPC> = <SPC> r <SPC> * <SPC> C <SPC> + <SPC> c <NL>              elif <SPC> grid [ r ] [ c ] <SPC> == <SPC> "F" : <NL>                  FOOD <SPC> = <SPC> r <SPC> * <SPC> C <SPC> + <SPC> c <NL>              elif <SPC> grid [ r ] [ c ] <SPC> == <SPC> "#" : <NL>                  WALLS . add ( r <SPC> * <SPC> C <SPC> + <SPC> c ) <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> jump <SPC> = <SPC> { MOUSE : <SPC> mouseJump , <SPC> CAT : <SPC> catJump } <NL> <TAB> for <SPC> r <SPC> in <SPC> xrange ( R ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( C ) : <NL>              if <SPC> grid [ r ] [ c ] <SPC> == <SPC> "#" : <NL>                  continue <NL>              pos <SPC> = <SPC> r <SPC> * <SPC> C <SPC> + <SPC> c <NL>              for <SPC> t <SPC> in <SPC> [ MOUSE , <SPC> CAT ] : <NL>                  for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                      for <SPC> d <SPC> in <SPC> xrange ( jump [ t ] <SPC> + <SPC> 1 ) : <NL>                          nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr <SPC> * <SPC> d , <SPC> c <SPC> + <SPC> dc <SPC> * <SPC> d <NL>                          if <SPC> not <SPC> ( <NL>                              0 <SPC> <= <SPC> nr <SPC> < <SPC> R <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> C <SPC> and <SPC> grid [ nr ] [ nc ] <SPC> != <SPC> "#" <NL>                          ) : <NL>                              break <NL>                          graph [ pos , <SPC> t ] . add ( nr <SPC> * <SPC> C <SPC> + <SPC> nc ) <NL> <NL> <TAB> degree <SPC> = <SPC> { } <NL> <TAB> for <SPC> m <SPC> in <SPC> xrange ( N ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( N ) : <NL> <NL>              degree [ m , <SPC> c , <SPC> CAT ] <SPC> = <SPC> len ( graph [ c , <SPC> CAT ] ) <NL> <TAB> color <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> q1 <SPC> = <SPC> collections . deque ( ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N ) : <NL>          if <SPC> i <SPC> in <SPC> WALLS <SPC> or <SPC> i <SPC> == <SPC> FOOD : <NL>              continue <NL>          color [ FOOD , <SPC> i , <SPC> CAT ] <SPC> = <SPC> MOUSE <NL>          q1 . append ( ( FOOD , <SPC> i , <SPC> CAT ) ) <NL>          color [ i , <SPC> FOOD , <SPC> MOUSE ] <SPC> = <SPC> CAT <NL> <NL>          for <SPC> t <SPC> in <SPC> [ MOUSE , <SPC> CAT ] : <NL>              color [ i , <SPC> i , <SPC> t ] <SPC> = <SPC> CAT <NL> <NL> <TAB> while <SPC> q1 : <NL>          i , <SPC> j , <SPC> t <SPC> = <SPC> q1 . popleft ( ) <NL>          for <SPC> ni , <SPC> nj , <SPC> nt <SPC> in <SPC> parents ( i , <SPC> j , <SPC> t ) : <NL>              if <SPC> color [ ni , <SPC> nj , <SPC> nt ] <SPC> != <SPC> DRAW : <NL>                  continue <NL>              if <SPC> t <SPC> == <SPC> CAT : <NL>                  color [ ni , <SPC> nj , <SPC> nt ] <SPC> = <SPC> MOUSE <NL>                  q1 . append ( ( ni , <SPC> nj , <SPC> nt ) ) <NL>                  continue <NL>              degree [ ni , <SPC> nj , <SPC> nt ] <SPC> -= <SPC> 1 <NL>              if <SPC> not <SPC> degree [ ni , <SPC> nj , <SPC> nt ] : <NL>                  color [ ni , <SPC> nj , <SPC> nt ] <SPC> = <SPC> MOUSE <NL>                  q1 . append ( ( ni , <SPC> nj , <SPC> nt ) ) <NL> <NL> <TAB> return <SPC> color [ MOUSE_START , <SPC> CAT_START , <SPC> MOUSE ] <SPC> == <SPC> MOUSE <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> catMouseGame ( self , <SPC> graph ) : <NL> <NL> <TAB> HOLE , <SPC> MOUSE_START , <SPC> CAT_START <SPC> = <SPC> range ( 3 ) <NL> <TAB> DRAW , <SPC> MOUSE , <SPC> CAT <SPC> = <SPC> range ( 3 ) <NL> <NL> <TAB> def <SPC> parents ( m , <SPC> c , <SPC> t ) : <NL>          if <SPC> t <SPC> == <SPC> CAT : <NL>              for <SPC> nm <SPC> in <SPC> graph [ m ] : <NL>                  yield <SPC> nm , <SPC> c , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t <NL>          else : <NL>              for <SPC> nc <SPC> in <SPC> graph [ c ] : <NL>                  if <SPC> nc <SPC> != <SPC> HOLE : <NL>                      yield <SPC> m , <SPC> nc , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t <NL> <NL> <TAB> degree <SPC> = <SPC> { } <NL> <TAB> ignore <SPC> = <SPC> set ( graph [ HOLE ] ) <NL> <TAB> for <SPC> m <SPC> in <SPC> xrange ( len ( graph ) ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( len ( graph ) ) : <NL>              degree [ m , <SPC> c , <SPC> MOUSE ] <SPC> = <SPC> len ( graph [ m ] ) <NL>              degree [ m , <SPC> c , <SPC> CAT ] <SPC> = <SPC> len ( graph [ c ] ) <SPC> - <SPC> ( c <SPC> in <SPC> ignore ) <NL> <TAB> color <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( graph ) ) : <NL>          if <SPC> i <SPC> == <SPC> HOLE : <NL>              continue <NL>          color [ HOLE , <SPC> i , <SPC> CAT ] <SPC> = <SPC> MOUSE <NL>          q . append ( ( HOLE , <SPC> i , <SPC> CAT , <SPC> MOUSE ) ) <NL>          for <SPC> t <SPC> in <SPC> [ MOUSE , <SPC> CAT ] : <NL>              color [ i , <SPC> i , <SPC> t ] <SPC> = <SPC> CAT <NL>              q . append ( ( i , <SPC> i , <SPC> t , <SPC> CAT ) ) <NL> <TAB> while <SPC> q : <NL>          i , <SPC> j , <SPC> t , <SPC> c <SPC> = <SPC> q . popleft ( ) <NL>          for <SPC> ni , <SPC> nj , <SPC> nt <SPC> in <SPC> parents ( i , <SPC> j , <SPC> t ) : <NL>              if <SPC> color [ ni , <SPC> nj , <SPC> nt ] <SPC> != <SPC> DRAW : <NL>                  continue <NL>              if <SPC> nt <SPC> == <SPC> c : <NL>                  color [ ni , <SPC> nj , <SPC> nt ] <SPC> = <SPC> c <NL>                  q . append ( ( ni , <SPC> nj , <SPC> nt , <SPC> c ) ) <NL>                  continue <NL>              degree [ ni , <SPC> nj , <SPC> nt ] <SPC> -= <SPC> 1 <NL>              if <SPC> not <SPC> degree [ ni , <SPC> nj , <SPC> nt ] : <NL>                  color [ ni , <SPC> nj , <SPC> nt ] <SPC> = <SPC> c <NL>                  q . append ( ( ni , <SPC> nj , <SPC> nt , <SPC> c ) ) <NL> <TAB> return <SPC> color [ MOUSE_START , <SPC> CAT_START , <SPC> MOUSE ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> catMouseGame ( self , <SPC> graph ) : <NL> <NL> <TAB> HOLE , <SPC> MOUSE_START , <SPC> CAT_START <SPC> = <SPC> range ( 3 ) <NL> <TAB> DRAW , <SPC> MOUSE , <SPC> CAT <SPC> = <SPC> range ( 3 ) <NL> <NL> <TAB> def <SPC> parents ( m , <SPC> c , <SPC> t ) : <NL>          if <SPC> t <SPC> == <SPC> CAT : <NL>              for <SPC> nm <SPC> in <SPC> graph [ m ] : <NL>                  yield <SPC> nm , <SPC> c , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t <NL>          else : <NL>              for <SPC> nc <SPC> in <SPC> graph [ c ] : <NL>                  if <SPC> nc <SPC> != <SPC> HOLE : <NL>                      yield <SPC> m , <SPC> nc , <SPC> MOUSE <SPC> ^ <SPC> CAT <SPC> ^ <SPC> t <NL> <NL> <TAB> color <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> degree <SPC> = <SPC> { } <NL> <TAB> ignore <SPC> = <SPC> set ( graph [ HOLE ] ) <NL> <TAB> for <SPC> m <SPC> in <SPC> xrange ( len ( graph ) ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( len ( graph ) ) : <NL>              degree [ m , <SPC> c , <SPC> MOUSE ] <SPC> = <SPC> len ( graph [ m ] ) <NL>              degree [ m , <SPC> c , <SPC> CAT ] <SPC> = <SPC> len ( graph [ c ] ) <SPC> - <SPC> ( c <SPC> in <SPC> ignore ) <NL> <TAB> q1 <SPC> = <SPC> collections . deque ( ) <NL> <TAB> q2 <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( graph ) ) : <NL>          if <SPC> i <SPC> == <SPC> HOLE : <NL>              continue <NL>          color [ HOLE , <SPC> i , <SPC> CAT ] <SPC> = <SPC> MOUSE <NL>          q1 . append ( ( HOLE , <SPC> i , <SPC> CAT ) ) <NL>          for <SPC> t <SPC> in <SPC> [ MOUSE , <SPC> CAT ] : <NL>              color [ i , <SPC> i , <SPC> t ] <SPC> = <SPC> CAT <NL>              q2 . append ( ( i , <SPC> i , <SPC> t ) ) <NL> <TAB> while <SPC> q1 : <NL>          i , <SPC> j , <SPC> t <SPC> = <SPC> q1 . popleft ( ) <NL>          for <SPC> ni , <SPC> nj , <SPC> nt <SPC> in <SPC> parents ( i , <SPC> j , <SPC> t ) : <NL>              if <SPC> color [ ni , <SPC> nj , <SPC> nt ] <SPC> != <SPC> DRAW : <NL>                  continue <NL>              if <SPC> t <SPC> == <SPC> CAT : <NL>                  color [ ni , <SPC> nj , <SPC> nt ] <SPC> = <SPC> MOUSE <NL>                  q1 . append ( ( ni , <SPC> nj , <SPC> nt ) ) <NL>                  continue <NL>              degree [ ni , <SPC> nj , <SPC> nt ] <SPC> -= <SPC> 1 <NL>              if <SPC> not <SPC> degree [ ni , <SPC> nj , <SPC> nt ] : <NL>                  color [ ni , <SPC> nj , <SPC> nt ] <SPC> = <SPC> MOUSE <NL>                  q1 . append ( ( ni , <SPC> nj , <SPC> nt ) ) <NL> <TAB> while <SPC> q2 : <NL>          i , <SPC> j , <SPC> t <SPC> = <SPC> q2 . popleft ( ) <NL>          for <SPC> ni , <SPC> nj , <SPC> nt <SPC> in <SPC> parents ( i , <SPC> j , <SPC> t ) : <NL>              if <SPC> color [ ni , <SPC> nj , <SPC> nt ] <SPC> != <SPC> DRAW : <NL>                  continue <NL>              if <SPC> t <SPC> == <SPC> MOUSE : <NL>                  color [ ni , <SPC> nj , <SPC> nt ] <SPC> = <SPC> CAT <NL>                  q2 . append ( ( ni , <SPC> nj , <SPC> nt ) ) <NL>                  continue <NL>              degree [ ni , <SPC> nj , <SPC> nt ] <SPC> -= <SPC> 1 <NL>              if <SPC> not <SPC> degree [ ni , <SPC> nj , <SPC> nt ] : <NL>                  color [ ni , <SPC> nj , <SPC> nt ] <SPC> = <SPC> CAT <NL>                  q2 . append ( ( ni , <SPC> nj , <SPC> nt ) ) <NL> <TAB> return <SPC> color [ MOUSE_START , <SPC> CAT_START , <SPC> MOUSE ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> oddCells ( self , <SPC> n , <SPC> m , <SPC> indices ) : <NL> <NL> <TAB> row , <SPC> col <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n , <SPC> [ 0 ] <SPC> * <SPC> m <NL> <TAB> for <SPC> r , <SPC> c <SPC> in <SPC> indices : <NL>          row [ r ] <SPC> ^= <SPC> 1 <NL>          col [ c ] <SPC> ^= <SPC> 1 <NL> <TAB> row_sum , <SPC> col_sum <SPC> = <SPC> sum ( row ) , <SPC> sum ( col ) <NL> <TAB> return <SPC> row_sum <SPC> * <SPC> m <SPC> + <SPC> col_sum <SPC> * <SPC> n <SPC> - <SPC> 2 <SPC> * <SPC> row_sum <SPC> * <SPC> col_sum <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> oddCells ( self , <SPC> n , <SPC> m , <SPC> indices ) : <NL> <NL> <TAB> def <SPC> fn ( x ) : <SPC> return <SPC> sum ( <NL>          count <SPC> & <SPC> 1 <SPC> for <SPC> count <SPC> in <SPC> collections . Counter ( x ) . itervalues ( ) ) <NL> <TAB> row_sum , <SPC> col_sum <SPC> = <SPC> map ( fn , <SPC> itertools . izip ( * indices ) ) <NL> <TAB> return <SPC> row_sum <SPC> * <SPC> m <SPC> + <SPC> col_sum <SPC> * <SPC> n <SPC> - <SPC> 2 <SPC> * <SPC> row_sum <SPC> * <SPC> col_sum <NL> <NL> <NL> from <SPC> operator <SPC> import <SPC> xor <NL> from <SPC> functools <SPC> import <SPC> reduce <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> xorGame ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> reduce ( xor , <SPC> nums ) <SPC> == <SPC> 0 <SPC> or <SPC> len ( nums ) <SPC> % <SPC> 2 <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> champagneTower ( self , <SPC> poured , <SPC> query_row , <SPC> query_glass ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ poured ] <SPC> + <SPC> [ 0 ] <SPC> * <SPC> query_row <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> query_row <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( i <SPC> + <SPC> 1 ) ) : <NL>              result [ j ] <SPC> = <SPC> ( <NL>                  max ( result [ j ] <SPC> - <SPC> 1 , <SPC> 0 ) <SPC> / <SPC> 2.0 <SPC> + <SPC> max ( result [ j <SPC> - <SPC> 1 ] <SPC> - <SPC> 1 , <SPC> 0 ) <SPC> / <SPC> 2.0 <NL>              ) <NL> <TAB> return <SPC> min ( result [ query_glass ] , <SPC> 1 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minCharacters ( self , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> count1 <SPC> = <SPC> collections . Counter ( ord ( c ) <SPC> - <SPC> ord ( "a" ) <SPC> for <SPC> c <SPC> in <SPC> a ) <NL> <TAB> count2 <SPC> = <SPC> collections . Counter ( ord ( c ) <SPC> - <SPC> ord ( "a" ) <SPC> for <SPC> c <SPC> in <SPC> b ) <NL> <TAB> result <SPC> = <SPC> len ( a ) <SPC> + <SPC> len ( b ) <SPC> - <SPC> max ( ( count1 <SPC> + <SPC> count2 ) . itervalues ( ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 26 <SPC> - <SPC> 1 ) : <NL>          if <SPC> i <SPC> > <SPC> 0 : <NL>              count1 [ i ] <SPC> += <SPC> count1 [ i <SPC> - <SPC> 1 ] <NL>              count2 [ i ] <SPC> += <SPC> count2 [ i <SPC> - <SPC> 1 ] <NL>          result <SPC> = <SPC> min ( result , <SPC> len ( a ) <SPC> - <SPC> count1 [ i ] <SPC> + <SPC> count2 [ i ] ) <NL>          result <SPC> = <SPC> min ( result , <SPC> len ( b ) <SPC> - <SPC> count2 [ i ] <SPC> + <SPC> count1 [ i ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Node : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> flipBinaryTree ( self , <SPC> root , <SPC> leaf ) : <NL> <NL> <TAB> curr , <SPC> parent <SPC> = <SPC> leaf , <SPC> None <NL> <TAB> while <SPC> True : <NL>          child <SPC> = <SPC> curr . parent <NL>          curr . parent <SPC> = <SPC> parent <NL>          if <SPC> curr . left <SPC> == <SPC> parent : <NL>              curr . left <SPC> = <SPC> None <NL>          else : <NL>              curr . right <SPC> = <SPC> None <NL>          if <SPC> curr <SPC> == <SPC> root : <NL>              break <NL>          if <SPC> curr . left : <NL>              curr . right <SPC> = <SPC> curr . left <NL>          curr . left <SPC> = <SPC> child <NL>          curr , <SPC> parent <SPC> = <SPC> child , <SPC> curr <NL> <TAB> return <SPC> leaf <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findCheapestPrice ( self , <SPC> n , <SPC> flights , <SPC> src , <SPC> dst , <SPC> K ) : <NL> <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v , <SPC> w <SPC> in <SPC> flights : <NL>          adj [ u ] . append ( ( v , <SPC> w ) ) <NL> <TAB> best <SPC> = <SPC> collections . defaultdict ( <NL>          lambda : <SPC> collections . defaultdict ( lambda : <SPC> float ( "inf" ) ) <NL> <TAB> ) <NL> <TAB> min_heap <SPC> = <SPC> [ ( 0 , <SPC> src , <SPC> K <SPC> + <SPC> 1 ) ] <NL> <TAB> while <SPC> min_heap : <NL>          result , <SPC> u , <SPC> k <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> k <SPC> < <SPC> 0 <SPC> or <SPC> best [ u ] [ k ] <SPC> < <SPC> result : <NL>              continue <NL>          if <SPC> u <SPC> == <SPC> dst : <NL>              return <SPC> result <NL>          for <SPC> v , <SPC> w <SPC> in <SPC> adj [ u ] : <NL>              if <SPC> result <SPC> + <SPC> w <SPC> < <SPC> best [ v ] [ k <SPC> - <SPC> 1 ] : <NL>                  best [ v ] [ k <SPC> - <SPC> 1 ] <SPC> = <SPC> result <SPC> + <SPC> w <NL>                  heapq . heappush ( min_heap , <SPC> ( result <SPC> + <SPC> w , <SPC> v , <SPC> k <SPC> - <SPC> 1 ) ) <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canFormArray ( self , <SPC> arr , <SPC> pieces ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { x [ 0 ] : <SPC> i <SPC> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( pieces ) } <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( arr ) : <NL>          if <SPC> arr [ i ] <SPC> not <SPC> in <SPC> lookup : <NL>              return <SPC> False <NL>          for <SPC> c <SPC> in <SPC> pieces [ lookup [ arr [ i ] ] ] : <NL>              if <SPC> i <SPC> == <SPC> len ( arr ) <SPC> or <SPC> arr [ i ] <SPC> != <SPC> c : <NL>                  return <SPC> False <NL>              i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isCompleteTree ( self , <SPC> root ) : <NL> <NL> <TAB> end <SPC> = <SPC> False <NL> <TAB> current <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> current : <NL>          next_level <SPC> = <SPC> [ ] <NL>          for <SPC> node <SPC> in <SPC> current : <NL>              if <SPC> not <SPC> node : <NL>                  end <SPC> = <SPC> True <NL>                  continue <NL>              if <SPC> end : <NL>                  return <SPC> False <NL>              next_level . append ( node . left ) <NL>              next_level . append ( node . right ) <NL>          current <SPC> = <SPC> next_level <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isCompleteTree ( self , <SPC> root ) : <NL> <NL> <TAB> prev_level , <SPC> current <SPC> = <SPC> [ ] , <SPC> [ ( root , <SPC> 1 ) ] <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> while <SPC> current : <NL>          count <SPC> += <SPC> len ( current ) <NL>          next_level <SPC> = <SPC> [ ] <NL>          for <SPC> node , <SPC> v <SPC> in <SPC> current : <NL>              if <SPC> not <SPC> node : <NL>                  continue <NL>              next_level . append ( ( node . left , <SPC> 2 <SPC> * <SPC> v ) ) <NL>              next_level . append ( ( node . right , <SPC> 2 <SPC> * <SPC> v <SPC> + <SPC> 1 ) ) <NL>          prev_level , <SPC> current <SPC> = <SPC> current , <SPC> next_level <NL> <TAB> return <SPC> prev_level [ - 1 ] [ 1 ] <SPC> == <SPC> count <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isMajorityElement ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> if <SPC> len ( nums ) <SPC> % <SPC> 2 : <NL>          if <SPC> nums [ len ( nums ) <SPC> // <SPC> 2 ] <SPC> != <SPC> target : <NL>              return <SPC> False <NL> <TAB> else : <NL>          if <SPC> not <SPC> ( nums [ len ( nums ) <SPC> // <SPC> 2 <SPC> - <SPC> 1 ] <SPC> == <SPC> nums [ len ( nums ) <SPC> // <SPC> 2 ] <SPC> == <SPC> target ) : <NL>              return <SPC> False <NL> <NL> <TAB> left <SPC> = <SPC> bisect . bisect_left ( nums , <SPC> target ) <NL> <TAB> right <SPC> = <SPC> bisect . bisect_right ( nums , <SPC> target ) <NL> <TAB> return <SPC> ( right <SPC> - <SPC> left ) <SPC> * <SPC> 2 <SPC> > <SPC> len ( nums ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> string <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkIfCanBreak ( self , <SPC> s1 , <SPC> s2 ) : <NL> <NL> <TAB> def <SPC> is_break ( count1 , <SPC> count2 ) : <NL>          curr1 , <SPC> curr2 <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> string . ascii_lowercase : <NL>              curr1 <SPC> += <SPC> count1 [ c ] <NL>              curr2 <SPC> += <SPC> count2 [ c ] <NL>              if <SPC> curr1 <SPC> < <SPC> curr2 : <NL>                  return <SPC> False <NL>          return <SPC> True <NL> <NL> <TAB> count1 , <SPC> count2 <SPC> = <SPC> collections . Counter ( s1 ) , <SPC> collections . Counter ( s2 ) <NL> <TAB> return <SPC> is_break ( count1 , <SPC> count2 ) <SPC> or <SPC> is_break ( count2 , <SPC> count1 ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> checkIfCanBreak ( self , <SPC> s1 , <SPC> s2 ) : <NL> <NL> <TAB> return <SPC> not <SPC> { 1 , <SPC> - 1 } . issubset ( <NL>          set ( cmp ( a , <SPC> b ) <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( sorted ( s1 ) , <SPC> sorted ( s2 ) ) ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> checkIfCanBreak ( self , <SPC> s1 , <SPC> s2 ) : <NL> <NL> <TAB> s1 , <SPC> s2 <SPC> = <SPC> sorted ( s1 ) , <SPC> sorted ( s2 ) <NL> <TAB> return <SPC> all ( a <SPC> >= <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( s1 , <SPC> s2 ) ) <SPC> or <SPC> all ( <NL>          a <SPC> <= <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( s1 , <SPC> s2 ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> hasAllCodes ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> return <SPC> ( <NL>          2 <SPC> ** <SPC> k <SPC> <= <SPC> len ( s ) <NL>          and <SPC> len ( { s [ i : <SPC> i <SPC> + <SPC> k ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> - <SPC> k <SPC> + <SPC> 1 ) } ) <SPC> == <SPC> 2 <SPC> ** <SPC> k <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> hasAllCodes ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> base <SPC> = <SPC> 2 <SPC> ** <SPC> k <NL> <TAB> if <SPC> base <SPC> > <SPC> len ( s ) : <NL>          return <SPC> False <NL> <TAB> num <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          num <SPC> = <SPC> ( num <SPC> << <SPC> 1 ) <SPC> + <SPC> ( s [ i ] <SPC> == <SPC> "1" ) <NL>          if <SPC> i <SPC> >= <SPC> k <SPC> - <SPC> 1 : <NL>              lookup . add ( num ) <NL>              num <SPC> -= <SPC> ( s [ i <SPC> - <SPC> k <SPC> + <SPC> 1 ] <SPC> == <SPC> "1" ) <SPC> * <SPC> ( base <SPC> // <SPC> 2 ) <NL> <TAB> return <SPC> len ( lookup ) <SPC> == <SPC> base <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isValidSequence ( self , <SPC> root , <SPC> arr ) : <NL> <NL> <TAB> q <SPC> = <SPC> [ root ] <NL> <TAB> for <SPC> depth <SPC> in <SPC> xrange ( len ( arr ) ) : <NL>          new_q <SPC> = <SPC> [ ] <NL>          while <SPC> q : <NL>              node <SPC> = <SPC> q . pop ( ) <NL>              if <SPC> not <SPC> node <SPC> or <SPC> node . val <SPC> != <SPC> arr [ depth ] : <NL>                  continue <NL>              if <SPC> depth <SPC> + <SPC> 1 <SPC> == <SPC> len ( arr ) <SPC> and <SPC> node . left <SPC> == <SPC> node . right : <NL>                  return <SPC> True <NL>              new_q . extend ( child <SPC> for <SPC> child <SPC> in <SPC> ( node . left , <SPC> node . right ) ) <NL>          q <SPC> = <SPC> new_q <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isValidSequence ( self , <SPC> root , <SPC> arr ) : <NL> <NL> <TAB> s <SPC> = <SPC> [ ( root , <SPC> 0 ) ] <NL> <TAB> while <SPC> s : <NL>          node , <SPC> depth <SPC> = <SPC> s . pop ( ) <NL>          if <SPC> not <SPC> node <SPC> or <SPC> depth <SPC> == <SPC> len ( arr ) <SPC> or <SPC> node . val <SPC> != <SPC> arr [ depth ] : <NL>              continue <NL>          if <SPC> depth <SPC> + <SPC> 1 <SPC> == <SPC> len ( arr ) <SPC> and <SPC> node . left <SPC> == <SPC> node . right : <NL>              return <SPC> True <NL>          s . append ( ( node . right , <SPC> depth <SPC> + <SPC> 1 ) ) <NL>          s . append ( ( node . left , <SPC> depth <SPC> + <SPC> 1 ) ) <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> isValidSequence ( self , <SPC> root , <SPC> arr ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> arr , <SPC> depth ) : <NL>          if <SPC> not <SPC> node <SPC> or <SPC> depth <SPC> == <SPC> len ( arr ) <SPC> or <SPC> node . val <SPC> != <SPC> arr [ depth ] : <NL>              return <SPC> False <NL>          if <SPC> depth <SPC> + <SPC> 1 <SPC> == <SPC> len ( arr ) <SPC> and <SPC> node . left <SPC> == <SPC> node . right : <NL>              return <SPC> True <NL>          return <SPC> dfs ( node . left , <SPC> arr , <SPC> depth <SPC> + <SPC> 1 ) <SPC> or <SPC> dfs ( node . right , <SPC> arr , <SPC> depth <SPC> + <SPC> 1 ) <NL> <NL> <TAB> return <SPC> dfs ( root , <SPC> arr , <SPC> 0 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPrefixOfWord ( self , <SPC> sentence , <SPC> searchWord ) : <NL> <NL> <TAB> def <SPC> KMP ( text , <SPC> pattern ) : <NL>          def <SPC> getPrefix ( pattern ) : <NL>              prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL>              j <SPC> = <SPC> - 1 <NL>              for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>                  while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>                      j <SPC> = <SPC> prefix [ j ] <NL>                  if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>                      j <SPC> += <SPC> 1 <NL>                  prefix [ i ] <SPC> = <SPC> j <NL>              return <SPC> prefix <NL> <NL>          prefix <SPC> = <SPC> getPrefix ( pattern ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( text ) ) : <NL>              while <SPC> j <SPC> != <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> text [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> text [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              if <SPC> j <SPC> + <SPC> 1 <SPC> == <SPC> len ( pattern ) : <NL>                  return <SPC> i <SPC> - <SPC> j <NL>          return <SPC> - 1 <NL> <NL> <TAB> if <SPC> sentence . startswith ( searchWord ) : <NL>          return <SPC> 1 <NL> <TAB> p <SPC> = <SPC> KMP ( sentence , <SPC> " " <SPC> + <SPC> searchWord ) <NL> <TAB> if <SPC> p <SPC> == <SPC> - 1 : <NL>          return <SPC> - 1 <NL> <TAB> return <SPC> 1 <SPC> + <SPC> sum ( sentence [ i ] <SPC> == <SPC> " " <SPC> for <SPC> i <SPC> in <SPC> xrange ( p <SPC> + <SPC> 1 ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kLengthApart ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> prev <SPC> = <SPC> - k <SPC> - <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> not <SPC> nums [ i ] : <NL>              continue <NL>          if <SPC> i <SPC> - <SPC> prev <SPC> <= <SPC> k : <NL>              return <SPC> False <NL>          prev <SPC> = <SPC> i <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> check ( self , <SPC> nums ) : <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> nums [ i ] <SPC> > <SPC> nums [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> len ( nums ) ] : <NL>              count <SPC> += <SPC> 1 <NL>              if <SPC> count <SPC> > <SPC> 1 : <NL>                  return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canArrange ( self , <SPC> arr , <SPC> k ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( i <SPC> % <SPC> k <SPC> for <SPC> i <SPC> in <SPC> arr ) <NL> <TAB> return <SPC> ( 0 <SPC> not <SPC> in <SPC> count <SPC> or <SPC> not <SPC> count [ 0 ] <SPC> % <SPC> 2 ) <SPC> and <SPC> all ( <NL>          k <SPC> - <SPC> i <SPC> in <SPC> count <SPC> and <SPC> count [ i ] <SPC> == <SPC> count [ k <SPC> - <SPC> i ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> k ) <NL>          if <SPC> i <SPC> in <SPC> count <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkOnesSegment ( self , <SPC> s ) : <NL> <NL> <TAB> return <SPC> "01" <SPC> not <SPC> in <SPC> s <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isGoodArray ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> gcd ( a , <SPC> b ) : <NL>          while <SPC> b : <NL>              a , <SPC> b <SPC> = <SPC> b , <SPC> a <SPC> % <SPC> b <NL>          return <SPC> a <NL> <NL> <TAB> result <SPC> = <SPC> nums [ 0 ] <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          result <SPC> = <SPC> gcd ( result , <SPC> num ) <NL>          if <SPC> result <SPC> == <SPC> 1 : <NL>              break <NL> <TAB> return <SPC> result <SPC> == <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkStraightLine ( self , <SPC> coordinates ) : <NL> <NL> <TAB> i , <SPC> j <SPC> = <SPC> coordinates [ : 2 ] <NL> <TAB> return <SPC> all ( <NL>          i [ 0 ] <SPC> * <SPC> j [ 1 ] <NL>          - <SPC> j [ 0 ] <SPC> * <SPC> i [ 1 ] <NL>          + <SPC> j [ 0 ] <SPC> * <SPC> k [ 1 ] <NL>          - <SPC> k [ 0 ] <SPC> * <SPC> j [ 1 ] <NL>          + <SPC> k [ 0 ] <SPC> * <SPC> i [ 1 ] <NL>          - <SPC> i [ 0 ] <SPC> * <SPC> k [ 1 ] <NL>          == <SPC> 0 <NL>          for <SPC> k <SPC> in <SPC> coordinates <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkIfExist ( self , <SPC> arr ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> x <SPC> in <SPC> arr : <NL>          if <SPC> 2 <SPC> * <SPC> x <SPC> in <SPC> lookup <SPC> or <SPC> ( x <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> and <SPC> x <SPC> // <SPC> 2 <SPC> in <SPC> lookup ) : <NL>              return <SPC> True <NL>          lookup . add ( x ) <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkPowersOfThree ( self , <SPC> n ) : <NL> <NL> <TAB> while <SPC> n <SPC> > <SPC> 0 : <NL>          if <SPC> n <SPC> % <SPC> 3 <SPC> == <SPC> 2 : <NL>              return <SPC> False <NL>          n <SPC> //= <SPC> 3 <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> areAlmostEqual ( self , <SPC> s1 , <SPC> s2 ) : <NL> <NL> <TAB> diff <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( s1 , <SPC> s2 ) : <NL>          if <SPC> a <SPC> == <SPC> b : <NL>              continue <NL>          if <SPC> len ( diff ) <SPC> == <SPC> 2 : <NL>              return <SPC> False <NL>          diff . append ( [ a , <SPC> b ] <SPC> if <SPC> not <SPC> diff <SPC> else <SPC> [ b , <SPC> a ] ) <NL> <TAB> return <SPC> not <SPC> diff <SPC> or <SPC> ( len ( diff ) <SPC> == <SPC> 2 <SPC> and <SPC> diff [ 0 ] <SPC> == <SPC> diff [ 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isTransformable ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> idxs <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 10 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>          idxs [ int ( s [ i ] ) ] . append ( i ) <NL> <TAB> for <SPC> c <SPC> in <SPC> t : <NL>          d <SPC> = <SPC> int ( c ) <NL>          if <SPC> not <SPC> idxs [ d ] : <NL>              return <SPC> False <NL>          for <SPC> k <SPC> in <SPC> xrange ( <NL>              d <NL>          ) : <NL>              if <SPC> idxs [ k ] <SPC> and <SPC> idxs [ k ] [ - 1 ] <SPC> < <SPC> idxs [ d ] [ - 1 ] : <NL>                  return <SPC> False <NL>          idxs [ d ] . pop ( ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> hasValidPath ( self , <SPC> grid ) : <NL> <NL> <TAB> E , <SPC> S , <SPC> W , <SPC> N <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> directions <SPC> = <SPC> [ [ W , <SPC> E ] , <SPC> [ N , <SPC> S ] , <SPC> [ W , <SPC> S ] , <SPC> [ S , <SPC> E ] , <SPC> [ W , <SPC> N ] , <SPC> [ N , <SPC> E ] ] <NL> <NL> <TAB> for <SPC> r , <SPC> c <SPC> in <SPC> directions [ grid [ 0 ] [ 0 ] <SPC> - <SPC> 1 ] : <NL>          if <SPC> not <SPC> ( 0 <SPC> <= <SPC> r <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> c <SPC> < <SPC> len ( grid [ 0 ] ) ) : <NL>              continue <NL>          pr , <SPC> pc <SPC> = <SPC> 0 , <SPC> 0 <NL>          while <SPC> r <SPC> != <SPC> len ( grid ) <SPC> - <SPC> 1 <SPC> or <SPC> c <SPC> != <SPC> len ( grid [ 0 ] ) <SPC> - <SPC> 1 : <NL>              for <SPC> dx , <SPC> dy <SPC> in <SPC> directions [ grid [ r ] [ c ] <SPC> - <SPC> 1 ] : <NL>                  nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dx , <SPC> c <SPC> + <SPC> dy <NL>                  if <SPC> ( <NL>                      ( nr <SPC> == <SPC> pr <SPC> and <SPC> nc <SPC> == <SPC> pc ) <NL>                      or <SPC> not <SPC> ( 0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ 0 ] ) ) <NL>                      or <SPC> ( - dx , <SPC> - dy ) <SPC> not <SPC> in <SPC> directions [ grid [ nr ] [ nc ] <SPC> - <SPC> 1 ] <NL>                  ) : <NL>                      continue <NL>                  pr , <SPC> pc , <SPC> r , <SPC> c <SPC> = <SPC> r , <SPC> c , <SPC> nr , <SPC> nc <NL>                  break <NL>              else : <NL>                  return <SPC> False <NL>          return <SPC> True <NL> <TAB> return <SPC> len ( grid ) <SPC> == <SPC> len ( grid [ 0 ] ) <SPC> == <SPC> 1 <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> functools <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = " " , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkEquivalence ( self , <SPC> root1 , <SPC> root2 ) : <NL> <NL> <TAB> def <SPC> add_counter ( counter , <SPC> prev , <SPC> d , <SPC> val ) : <NL>          if <SPC> val . isalpha ( ) : <NL>              counter [ ord ( val ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> d <SPC> if <SPC> prev [ 0 ] <SPC> == <SPC> "+" <SPC> else <SPC> - d <NL>          prev [ 0 ] <SPC> = <SPC> val <NL> <NL> <TAB> def <SPC> morris_inorder_traversal ( root , <SPC> cb ) : <NL>          curr <SPC> = <SPC> root <NL>          while <SPC> curr : <NL>              if <SPC> curr . left <SPC> is <SPC> None : <NL>                  cb ( curr . val ) <NL>                  curr <SPC> = <SPC> curr . right <NL>              else : <NL>                  node <SPC> = <SPC> curr . left <NL>                  while <SPC> node . right <SPC> and <SPC> node . right <SPC> != <SPC> curr : <NL>                      node <SPC> = <SPC> node . right <NL>                  if <SPC> node . right <SPC> is <SPC> None : <NL>                      node . right <SPC> = <SPC> curr <NL>                      curr <SPC> = <SPC> curr . left <NL>                  else : <NL>                      cb ( curr . val ) <NL>                      node . right <SPC> = <SPC> None <NL>                      curr <SPC> = <SPC> curr . right <NL> <NL> <TAB> counter <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> morris_inorder_traversal ( <NL>          root1 , <SPC> functools . partial ( add_counter , <SPC> counter , <SPC> [ "+" ] , <SPC> 1 ) <NL> <TAB> ) <NL> <TAB> morris_inorder_traversal ( <NL>          root2 , <SPC> functools . partial ( add_counter , <SPC> counter , <SPC> [ "+" ] , <SPC> - 1 ) <NL> <TAB> ) <NL> <TAB> return <SPC> all ( v <SPC> == <SPC> 0 <SPC> for <SPC> v <SPC> in <SPC> counter . itervalues ( ) ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> functools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> checkEquivalence ( self , <SPC> root1 , <SPC> root2 ) : <NL> <NL> <TAB> def <SPC> add_counter ( counter , <SPC> prev , <SPC> d , <SPC> val ) : <NL>          if <SPC> val . isalpha ( ) : <NL>              counter [ ord ( val ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> d <SPC> if <SPC> prev [ 0 ] <SPC> == <SPC> "+" <SPC> else <SPC> - d <NL>          prev [ 0 ] <SPC> = <SPC> val <NL> <NL> <TAB> def <SPC> inorder_traversal ( root , <SPC> cb ) : <NL>          def <SPC> traverseLeft ( node , <SPC> stk ) : <NL>              while <SPC> node : <NL>                  stk . append ( node ) <NL>                  node <SPC> = <SPC> node . left <NL> <NL>          stk <SPC> = <SPC> [ ] <NL>          traverseLeft ( root , <SPC> stk ) <NL>          while <SPC> stk : <NL>              curr <SPC> = <SPC> stk . pop ( ) <NL>              cb ( curr . val ) <NL>              traverseLeft ( curr . right , <SPC> stk ) <NL> <NL> <TAB> counter <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> inorder_traversal ( root1 , <SPC> functools . partial ( add_counter , <SPC> counter , <SPC> [ "+" ] , <SPC> 1 ) ) <NL> <TAB> inorder_traversal ( root2 , <SPC> functools . partial ( <NL>          add_counter , <SPC> counter , <SPC> [ "+" ] , <SPC> - 1 ) ) <NL> <TAB> return <SPC> all ( v <SPC> == <SPC> 0 <SPC> for <SPC> v <SPC> in <SPC> counter . itervalues ( ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> arrayStringsAreEqual ( self , <SPC> word1 , <SPC> word2 ) : <NL> <NL> <TAB> idx1 <SPC> = <SPC> idx2 <SPC> = <SPC> arr_idx1 <SPC> = <SPC> arr_idx2 <SPC> = <SPC> 0 <NL> <TAB> while <SPC> arr_idx1 <SPC> < <SPC> len ( word1 ) <SPC> and <SPC> arr_idx2 <SPC> < <SPC> len ( word2 ) : <NL>          if <SPC> word1 [ arr_idx1 ] [ idx1 ] <SPC> != <SPC> word2 [ arr_idx2 ] [ idx2 ] : <NL>              break <NL>          idx1 <SPC> += <SPC> 1 <NL>          if <SPC> idx1 <SPC> == <SPC> len ( word1 [ arr_idx1 ] ) : <NL>              idx1 <SPC> = <SPC> 0 <NL>              arr_idx1 <SPC> += <SPC> 1 <NL>          idx2 <SPC> += <SPC> 1 <NL>          if <SPC> idx2 <SPC> == <SPC> len ( word2 [ arr_idx2 ] ) : <NL>              idx2 <SPC> = <SPC> 0 <NL>              arr_idx2 <SPC> += <SPC> 1 <NL> <TAB> return <SPC> arr_idx1 <SPC> == <SPC> len ( word1 ) <SPC> and <SPC> arr_idx2 <SPC> == <SPC> len ( word2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isValid ( self , <SPC> S ) : <NL> <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> S : <NL>          if <SPC> i <SPC> == <SPC> "c" : <NL>              if <SPC> stack [ - 2 : ] <SPC> == <SPC> [ "a" , <SPC> "b" ] : <NL>                  stack . pop ( ) <NL>                  stack . pop ( ) <NL>              else : <NL>                  return <SPC> False <NL>          else : <NL>              stack . append ( i ) <NL> <TAB> return <SPC> not <SPC> stack <NL> <NL> <NL> from <SPC> functools <SPC> import <SPC> partial <NL> <NL> <NL> class <SPC> TreeInfos ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> children ) : <NL> <NL> <TAB> def <SPC> preprocess ( curr , <SPC> parent , <SPC> weight ) : <NL>          if <SPC> parent <SPC> != <SPC> - 1 : <NL>              W [ curr ] . append ( weight ) <NL>              P [ curr ] . append ( parent ) <NL>          i <SPC> = <SPC> 0 <NL>          while <SPC> i <SPC> < <SPC> len ( P [ curr ] ) <SPC> and <SPC> i <SPC> < <SPC> len ( P [ P [ curr ] [ i ] ] ) : <NL>              W [ curr ] . append ( max ( W [ curr ] [ i ] , <SPC> W [ P [ curr ] [ i ] ] [ i ] ) ) <NL>              P [ curr ] . append ( P [ P [ curr ] [ i ] ] [ i ] ) <NL>              i <SPC> += <SPC> 1 <NL>          C [ 0 ] <SPC> += <SPC> 1 <NL>          L [ curr ] <SPC> = <SPC> C [ <NL>              0 <NL>          ] <NL> <NL> <TAB> def <SPC> divide ( curr , <SPC> parent , <SPC> weight ) : <NL>          stk . append ( partial ( postprocess , <SPC> curr ) ) <NL>          for <SPC> child , <SPC> w <SPC> in <SPC> reversed ( children [ curr ] ) : <NL>              if <SPC> child <SPC> == <SPC> parent : <NL>                  continue <NL>              stk . append ( partial ( divide , <SPC> child , <SPC> curr , <SPC> w ) ) <NL>          stk . append ( partial ( preprocess , <SPC> curr , <SPC> parent , <SPC> weight ) ) <NL> <NL> <TAB> def <SPC> postprocess ( curr ) : <NL>          R [ curr ] <SPC> = <SPC> C [ <NL>              0 <NL>          ] <NL> <NL> <TAB> N <SPC> = <SPC> len ( children ) <NL> <TAB> L , <SPC> R , <SPC> P , <SPC> W , <SPC> C <SPC> = <SPC> ( <NL>          [ 0 ] <SPC> * <SPC> N , <NL>          [ 0 ] <SPC> * <SPC> N , <NL>          [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( N ) ] , <NL>          [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( N ) ] , <NL>          [ - 1 ] , <NL> <TAB> ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N ) : <NL>          if <SPC> L [ i ] : <NL>              continue <NL>          stk <SPC> = <SPC> [ ] <NL>          stk . append ( partial ( divide , <SPC> i , <SPC> - 1 , <SPC> 0 ) ) <NL>          while <SPC> stk : <NL>              stk . pop ( ) ( ) <NL> <TAB> self . L , <SPC> self . R , <SPC> self . P , <SPC> self . W <SPC> = <SPC> L , <SPC> R , <SPC> P , <SPC> W <NL> <NL> <TAB> def <SPC> is_ancestor ( self , <SPC> a , <SPC> b ) : <NL> <TAB> return <SPC> self . L [ a ] <SPC> <= <SPC> self . L [ b ] <SPC> <= <SPC> self . R [ b ] <SPC> <= <SPC> self . R [ a ] <NL> <NL> <TAB> def <SPC> max_weights ( self , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> def <SPC> binary_lift ( a , <SPC> b ) : <NL>          w <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( self . P [ a ] ) ) ) : <NL>              if <SPC> i <SPC> < <SPC> len ( self . P [ a ] ) <SPC> and <SPC> not <SPC> self . is_ancestor ( self . P [ a ] [ i ] , <SPC> b ) : <NL>                  w <SPC> = <SPC> max ( w , <SPC> self . W [ a ] [ i ] ) <NL>                  a <SPC> = <SPC> self . P [ a ] [ i ] <NL>          return <SPC> max ( w , <SPC> self . W [ a ] [ 0 ] ) <NL> <NL> <TAB> w <SPC> = <SPC> 0 <NL> <TAB> if <SPC> not <SPC> self . is_ancestor ( a , <SPC> b ) : <NL>          w <SPC> = <SPC> max ( w , <SPC> binary_lift ( a , <SPC> b ) ) <NL> <TAB> if <SPC> not <SPC> self . is_ancestor ( b , <SPC> a ) : <NL>          w <SPC> = <SPC> max ( w , <SPC> binary_lift ( b , <SPC> a ) ) <NL> <TAB> return <SPC> w <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . rank <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          stk . append ( x ) <NL>          x <SPC> = <SPC> self . set [ x ] <NL> <TAB> while <SPC> stk : <NL>          self . set [ stk . pop ( ) ] <SPC> = <SPC> x <NL> <TAB> return <SPC> x <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> if <SPC> self . rank [ x_root ] <SPC> < <SPC> self . rank [ y_root ] : <NL>          self . set [ x_root ] <SPC> = <SPC> y_root <NL> <TAB> elif <SPC> self . rank [ x_root ] <SPC> > <SPC> self . rank [ y_root ] : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL> <TAB> else : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL>          self . rank [ x_root ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> DistanceLimitedPathsExist ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n , <SPC> edgeList ) : <NL> <NL> <TAB> edgeList . sort ( key = lambda <SPC> x : <SPC> x [ 2 ] ) <NL> <TAB> self . __uf <SPC> = <SPC> UnionFind ( n ) <NL> <TAB> self . __adj <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> index , <SPC> ( i , <SPC> j , <SPC> weight ) <SPC> in <SPC> enumerate ( edgeList ) : <NL>          if <SPC> not <SPC> self . __uf . union_set ( i , <SPC> j ) : <NL>              continue <NL>          self . __adj [ i ] . append ( ( j , <SPC> weight ) ) <NL>          self . __adj [ j ] . append ( ( i , <SPC> weight ) ) <NL> <TAB> self . __tree_infos <SPC> = <SPC> TreeInfos ( self . __adj ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> p , <SPC> q , <SPC> limit ) : <NL> <NL> <TAB> if <SPC> self . __uf . find_set ( p ) <SPC> != <SPC> self . __uf . find_set ( q ) : <NL>          return <SPC> False <NL> <TAB> return <SPC> self . __tree_infos . max_weights ( p , <SPC> q ) <SPC> < <SPC> limit <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> sortedcontainers <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> SnapshotArray ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> length ) : <NL> <NL> <TAB> self . __snaps <SPC> = <SPC> collections . defaultdict ( <NL>          lambda : <SPC> sortedcontainers . SortedList ( [ ( 0 , <SPC> 0 ) ] ) <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> set ( self , <SPC> index , <SPC> val , <SPC> snap_id ) : <NL> <NL> <TAB> i <SPC> = <SPC> self . __snaps [ index ] . bisect_left ( ( snap_id , <SPC> float ( "-inf" ) ) ) <NL> <TAB> if <SPC> i <SPC> != <SPC> len ( self . __snaps [ index ] ) <SPC> and <SPC> self . __snaps [ index ] [ i ] [ 0 ] <SPC> == <SPC> snap_id : <NL>          self . __snaps [ index ] . remove ( self . __snaps [ index ] [ i ] ) <NL> <TAB> self . __snaps [ index ] . add ( ( snap_id , <SPC> val ) ) <NL> <NL> <TAB> def <SPC> get ( self , <SPC> index , <SPC> snap_id ) : <NL> <NL> <TAB> i <SPC> = <SPC> self . __snaps [ index ] . bisect_left ( ( snap_id <SPC> + <SPC> 1 , <SPC> float ( "-inf" ) ) ) <SPC> - <SPC> 1 <NL> <TAB> return <SPC> self . __snaps [ index ] [ i ] [ 1 ] <NL> <NL> <NL> class <SPC> VersionedUnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . snap_id <SPC> = <SPC> 0 <NL> <TAB> self . set <SPC> = <SPC> SnapshotArray ( n ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          self . set . set ( i , <SPC> i , <SPC> self . snap_id ) <NL> <TAB> self . rank <SPC> = <SPC> SnapshotArray ( n ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x , <SPC> snap_id ) : <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> self . set . get ( x , <SPC> snap_id ) <SPC> != <SPC> x : <NL>          stk . append ( x ) <NL>          x <SPC> = <SPC> self . set . get ( x , <SPC> snap_id ) <NL> <TAB> while <SPC> stk : <NL>          self . set . set ( stk . pop ( ) , <SPC> x , <SPC> snap_id ) <NL> <TAB> return <SPC> x <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root <SPC> = <SPC> self . find_set ( x , <SPC> self . snap_id ) <NL> <TAB> y_root <SPC> = <SPC> self . find_set ( y , <SPC> self . snap_id ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> if <SPC> self . rank . get ( x_root , <SPC> self . snap_id ) <SPC> < <SPC> self . rank . get ( <NL>          y_root , <SPC> self . snap_id <NL> <TAB> ) : <NL>          self . set . set ( x_root , <SPC> y_root , <SPC> self . snap_id ) <NL> <TAB> elif <SPC> self . rank . get ( x_root , <SPC> self . snap_id ) <SPC> > <SPC> self . rank . get ( y_root , <SPC> self . snap_id ) : <NL>          self . set . set ( y_root , <SPC> x_root , <SPC> self . snap_id ) <NL> <TAB> else : <NL>          self . set . set ( y_root , <SPC> x_root , <SPC> self . snap_id ) <NL>          self . rank . set ( x_root , <SPC> self . rank . get ( <NL>              x_root , <SPC> self . snap_id ) <SPC> + <SPC> 1 , <SPC> self . snap_id ) <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> snap ( self ) : <NL> <TAB> self . snap_id <SPC> += <SPC> 1 <NL> <NL> <NL> class <SPC> DistanceLimitedPathsExist2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n , <SPC> edgeList ) : <NL> <NL> <TAB> edgeList . sort ( key = lambda <SPC> x : <SPC> x [ 2 ] ) <NL> <TAB> self . __uf <SPC> = <SPC> VersionedUnionFind ( n ) <NL> <TAB> self . __weights <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> index , <SPC> ( i , <SPC> j , <SPC> weight ) <SPC> in <SPC> enumerate ( edgeList ) : <NL>          if <SPC> not <SPC> self . __uf . union_set ( i , <SPC> j ) : <NL>              continue <NL>          self . __uf . snap ( ) <NL>          self . __weights . append ( weight ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> p , <SPC> q , <SPC> limit ) : <NL> <NL> <TAB> snap_id <SPC> = <SPC> bisect . bisect_left ( self . __weights , <SPC> limit ) <SPC> - <SPC> 1 <NL> <TAB> if <SPC> snap_id <SPC> == <SPC> - 1 : <NL>          return <SPC> False <NL> <TAB> return <SPC> self . __uf . find_set ( p , <SPC> snap_id ) <SPC> == <SPC> self . __uf . find_set ( q , <SPC> snap_id ) <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . rank <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          stk . append ( x ) <NL>          x <SPC> = <SPC> self . set [ x ] <NL> <TAB> while <SPC> stk : <NL>          self . set [ stk . pop ( ) ] <SPC> = <SPC> x <NL> <TAB> return <SPC> x <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> if <SPC> self . rank [ x_root ] <SPC> < <SPC> self . rank [ y_root ] : <NL>          self . set [ x_root ] <SPC> = <SPC> y_root <NL> <TAB> elif <SPC> self . rank [ x_root ] <SPC> > <SPC> self . rank [ y_root ] : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL> <TAB> else : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL>          self . rank [ x_root ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> distanceLimitedPathsExist ( self , <SPC> n , <SPC> edgeList , <SPC> queries ) : <NL> <NL> <TAB> for <SPC> i , <SPC> q <SPC> in <SPC> enumerate ( queries ) : <NL>          q . append ( i ) <NL> <TAB> edgeList . sort ( key = lambda <SPC> x : <SPC> x [ 2 ] ) <NL> <TAB> queries . sort ( key = lambda <SPC> x : <SPC> x [ 2 ] ) <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( n ) <NL> <TAB> result <SPC> = <SPC> [ False ] <SPC> * <SPC> len ( queries ) <NL> <TAB> curr <SPC> = <SPC> 0 <NL> <TAB> for <SPC> u , <SPC> v , <SPC> w , <SPC> i <SPC> in <SPC> queries : <NL>          while <SPC> curr <SPC> < <SPC> len ( edgeList ) <SPC> and <SPC> edgeList [ curr ] [ 2 ] <SPC> < <SPC> w : <NL>              union_find . union_set ( edgeList [ curr ] [ 0 ] , <SPC> edgeList [ curr ] [ 1 ] ) <NL>              curr <SPC> += <SPC> 1 <NL>          result [ i ] <SPC> = <SPC> union_find . find_set ( u ) <SPC> == <SPC> union_find . find_set ( v ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> cherryPickup ( self , <SPC> grid ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ <NL>          [ [ float ( "-inf" ) ] <SPC> * <SPC> ( len ( grid [ 0 ] ) <SPC> + <SPC> 2 ) <NL>           for <SPC> _ <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) <SPC> + <SPC> 2 ) ] <NL>          for <SPC> _ <SPC> in <SPC> xrange ( 2 ) <NL> <TAB> ] <NL> <TAB> dp [ 0 ] [ 1 ] [ len ( grid [ 0 ] ) ] <SPC> = <SPC> grid [ 0 ] [ 0 ] <SPC> + <SPC> grid [ 0 ] [ len ( grid [ 0 ] ) <SPC> - <SPC> 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( grid [ 0 ] ) <SPC> + <SPC> 1 ) : <NL>              for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> len ( grid [ 0 ] ) <SPC> + <SPC> 1 ) : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] [ k ] <SPC> = <SPC> max ( <NL>                      dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> d1 ] [ k <SPC> + <SPC> d2 ] <NL>                      for <SPC> d1 <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) <NL>                      for <SPC> d2 <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) <NL>                  ) <SPC> + <SPC> ( <NL>                      ( grid [ i ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> grid [ i ] [ k <SPC> - <SPC> 1 ] <NL>                       ) <SPC> if <SPC> j <SPC> != <SPC> k <SPC> else <SPC> grid [ i ] [ j <SPC> - <SPC> 1 ] <NL>                  ) <NL> <TAB> return <SPC> max ( itertools . imap ( max , <SPC> * dp [ ( len ( grid ) <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] ) ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> cherryPickup ( self , <SPC> grid ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ <NL>          [ [ float ( "-inf" ) ] <SPC> * <SPC> len ( grid [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) ] <NL>          for <SPC> _ <SPC> in <SPC> xrange ( 2 ) <NL> <TAB> ] <NL> <TAB> dp [ 0 ] [ 0 ] [ len ( grid [ 0 ] ) <SPC> - <SPC> 1 ] <SPC> = <SPC> grid [ 0 ] [ 0 ] <SPC> + <SPC> grid [ 0 ] [ len ( grid [ 0 ] ) <SPC> - <SPC> 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              for <SPC> k <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] [ k ] <SPC> = <SPC> max ( <NL>                      dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> d1 ] [ k <SPC> + <SPC> d2 ] <NL>                      for <SPC> d1 <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) <NL>                      for <SPC> d2 <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) <NL>                      if <SPC> 0 <SPC> <= <SPC> j <SPC> + <SPC> d1 <SPC> < <SPC> len ( grid [ 0 ] ) <SPC> and <SPC> 0 <SPC> <= <SPC> k <SPC> + <SPC> d2 <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                  ) <SPC> + <SPC> ( ( grid [ i ] [ j ] <SPC> + <SPC> grid [ i ] [ k ] ) <SPC> if <SPC> j <SPC> != <SPC> k <SPC> else <SPC> grid [ i ] [ j ] ) <NL> <TAB> return <SPC> max ( itertools . imap ( max , <SPC> * dp [ ( len ( grid ) <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> cherryPickup ( self , <SPC> grid ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( grid ) <NL> <TAB> dp <SPC> = <SPC> [ [ - 1 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> grid [ 0 ] [ 0 ] <NL> <TAB> max_len <SPC> = <SPC> 2 <SPC> * <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 0 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> - 1 ) ] <NL> <TAB> for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> max_len <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> reversed ( <NL>              xrange ( max ( 0 , <SPC> k <SPC> - <SPC> n <SPC> + <SPC> 1 ) , <SPC> min ( k <SPC> + <SPC> 1 , <SPC> n ) ) <NL>          ) : <NL>              for <SPC> j <SPC> in <SPC> reversed ( xrange ( i , <SPC> min ( k <SPC> + <SPC> 1 , <SPC> n ) ) ) : <NL>                  if <SPC> grid [ i ] [ k <SPC> - <SPC> i ] <SPC> == <SPC> - 1 <SPC> or <SPC> grid [ j ] [ k <SPC> - <SPC> j ] <SPC> == <SPC> - 1 : <NL>                      dp [ i ] [ j ] <SPC> = <SPC> - 1 <NL>                      continue <NL>                  cnt <SPC> = <SPC> grid [ i ] [ k <SPC> - <SPC> i ] <NL>                  if <SPC> i <SPC> != <SPC> j : <NL>                      cnt <SPC> += <SPC> grid [ j ] [ k <SPC> - <SPC> j ] <NL>                  max_cnt <SPC> = <SPC> - 1 <NL>                  for <SPC> direction <SPC> in <SPC> directions : <NL>                      ii , <SPC> jj <SPC> = <SPC> i <SPC> + <SPC> direction [ 0 ] , <SPC> j <SPC> + <SPC> direction [ 1 ] <NL>                      if <SPC> ii <SPC> >= <SPC> 0 <SPC> and <SPC> jj <SPC> >= <SPC> 0 <SPC> and <SPC> dp [ ii ] [ jj ] <SPC> >= <SPC> 0 : <NL>                          max_cnt <SPC> = <SPC> max ( max_cnt , <SPC> dp [ ii ] [ jj ] <SPC> + <SPC> cnt ) <NL>                  dp [ i ] [ j ] <SPC> = <SPC> max_cnt <NL> <TAB> return <SPC> max ( dp [ n <SPC> - <SPC> 1 ] [ n <SPC> - <SPC> 1 ] , <SPC> 0 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxNumberOfFamilies ( self , <SPC> n , <SPC> reservedSeats ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( lambda : <SPC> [ False ] <SPC> * <SPC> 3 ) <NL> <TAB> for <SPC> r , <SPC> c <SPC> in <SPC> reservedSeats : <NL>          if <SPC> 2 <SPC> <= <SPC> c <SPC> <= <SPC> 5 : <NL>              lookup [ r ] [ 0 ] <SPC> = <SPC> True <NL>          if <SPC> 4 <SPC> <= <SPC> c <SPC> <= <SPC> 7 : <NL>              lookup [ r ] [ 1 ] <SPC> = <SPC> True <NL>          if <SPC> 6 <SPC> <= <SPC> c <SPC> <= <SPC> 9 : <NL>              lookup [ r ] [ 2 ] <SPC> = <SPC> True <NL> <TAB> result <SPC> = <SPC> 2 <SPC> * <SPC> n <NL> <TAB> for <SPC> a , <SPC> b , <SPC> c <SPC> in <SPC> lookup . itervalues ( ) : <NL>          if <SPC> not <SPC> a <SPC> and <SPC> not <SPC> c : <NL>              continue <NL>          if <SPC> not <SPC> a <SPC> or <SPC> not <SPC> b <SPC> or <SPC> not <SPC> c : <NL>              result <SPC> -= <SPC> 1 <NL>              continue <NL>          result <SPC> -= <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxNumberOfFamilies ( self , <SPC> n , <SPC> reservedSeats ) : <NL> <NL> <TAB> reservedSeats . sort ( ) <NL> <TAB> result , <SPC> i <SPC> = <SPC> 2 <SPC> * <SPC> n , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( reservedSeats ) : <NL>          reserved <SPC> = <SPC> [ False ] <SPC> * <SPC> 3 <NL>          curr <SPC> = <SPC> reservedSeats [ i ] [ 0 ] <NL>          while <SPC> i <SPC> < <SPC> len ( reservedSeats ) <SPC> and <SPC> reservedSeats [ i ] [ 0 ] <SPC> == <SPC> curr : <NL>              _ , <SPC> c <SPC> = <SPC> reservedSeats [ i ] <NL>              if <SPC> 2 <SPC> <= <SPC> c <SPC> <= <SPC> 5 : <NL>                  reserved [ 0 ] <SPC> = <SPC> True <NL>              if <SPC> 4 <SPC> <= <SPC> c <SPC> <= <SPC> 7 : <NL>                  reserved [ 1 ] <SPC> = <SPC> True <NL>              if <SPC> 6 <SPC> <= <SPC> c <SPC> <= <SPC> 9 : <NL>                  reserved [ 2 ] <SPC> = <SPC> True <NL>              i <SPC> += <SPC> 1 <NL>          if <SPC> not <SPC> reserved [ 0 ] <SPC> and <SPC> not <SPC> reserved [ 2 ] : <NL>              continue <NL>          if <SPC> not <SPC> all ( reserved ) : <NL>              result <SPC> -= <SPC> 1 <NL>              continue <NL>          result <SPC> -= <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkOverlap ( self , <SPC> radius , <SPC> x_center , <SPC> y_center , <SPC> x1 , <SPC> y1 , <SPC> x2 , <SPC> y2 ) : <NL> <NL> <TAB> x1 <SPC> -= <SPC> x_center <NL> <TAB> y1 <SPC> -= <SPC> y_center <NL> <TAB> x2 <SPC> -= <SPC> x_center <NL> <TAB> y2 <SPC> -= <SPC> y_center <NL> <TAB> x <SPC> = <SPC> x1 <SPC> if <SPC> x1 <SPC> > <SPC> 0 <SPC> else <SPC> x2 <SPC> if <SPC> x2 <SPC> < <SPC> 0 <SPC> else <SPC> 0 <NL> <TAB> y <SPC> = <SPC> y1 <SPC> if <SPC> y1 <SPC> > <SPC> 0 <SPC> else <SPC> y2 <SPC> if <SPC> y2 <SPC> < <SPC> 0 <SPC> else <SPC> 0 <NL> <TAB> return <SPC> x <SPC> ** <SPC> 2 <SPC> + <SPC> y <SPC> ** <SPC> 2 <SPC> <= <SPC> radius <SPC> ** <SPC> 2 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> checkOverlap ( self , <SPC> radius , <SPC> x_center , <SPC> y_center , <SPC> x1 , <SPC> y1 , <SPC> x2 , <SPC> y2 ) : <NL> <NL> <TAB> x1 <SPC> -= <SPC> x_center <NL> <TAB> y1 <SPC> -= <SPC> y_center <NL> <TAB> x2 <SPC> -= <SPC> x_center <NL> <TAB> y2 <SPC> -= <SPC> y_center <NL> <TAB> x <SPC> = <SPC> min ( abs ( x1 ) , <SPC> abs ( x2 ) ) <SPC> if <SPC> x1 <SPC> * <SPC> x2 <SPC> > <SPC> 0 <SPC> else <SPC> 0 <NL> <TAB> y <SPC> = <SPC> min ( abs ( y1 ) , <SPC> abs ( y2 ) ) <SPC> if <SPC> y1 <SPC> * <SPC> y2 <SPC> > <SPC> 0 <SPC> else <SPC> 0 <NL> <TAB> return <SPC> x <SPC> ** <SPC> 2 <SPC> + <SPC> y <SPC> ** <SPC> 2 <SPC> <= <SPC> radius <SPC> ** <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> circularArrayLoop ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> next_index ( nums , <SPC> i ) : <NL>          return <SPC> ( i <SPC> + <SPC> nums [ i ] ) <SPC> % <SPC> len ( nums ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> nums [ i ] <SPC> == <SPC> 0 : <NL>              continue <NL> <NL>          slow , <SPC> fast <SPC> = <SPC> i , <SPC> i <NL>          while <SPC> ( <NL>              nums [ next_index ( nums , <SPC> slow ) ] <SPC> * <SPC> nums [ i ] <SPC> > <SPC> 0 <NL>              and <SPC> nums [ next_index ( nums , <SPC> fast ) ] <SPC> * <SPC> nums [ i ] <SPC> > <SPC> 0 <NL>              and <SPC> nums [ next_index ( nums , <SPC> next_index ( nums , <SPC> fast ) ) ] <SPC> * <SPC> nums [ i ] <SPC> > <SPC> 0 <NL>          ) : <NL>              slow <SPC> = <SPC> next_index ( nums , <SPC> slow ) <NL>              fast <SPC> = <SPC> next_index ( nums , <SPC> next_index ( nums , <SPC> fast ) ) <NL>              if <SPC> slow <SPC> == <SPC> fast : <NL>                  if <SPC> slow <SPC> == <SPC> next_index ( nums , <SPC> slow ) : <NL>                      break <NL>                  return <SPC> True <NL> <NL>          slow , <SPC> val <SPC> = <SPC> i , <SPC> nums [ i ] <NL>          while <SPC> nums [ slow ] <SPC> * <SPC> val <SPC> > <SPC> 0 : <NL>              tmp <SPC> = <SPC> next_index ( nums , <SPC> slow ) <NL>              nums [ slow ] <SPC> = <SPC> 0 <NL>              slow <SPC> = <SPC> tmp <NL> <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> circularPermutation ( self , <SPC> n , <SPC> start ) : <NL> <NL> <TAB> return <SPC> [ start <SPC> ^ <SPC> ( i <SPC> >> <SPC> 1 ) <SPC> ^ <SPC> i <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 <SPC> << <SPC> n ) ] <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> climbStairs ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> matrix_expo ( A , <SPC> K ) : <NL>          result <SPC> = <SPC> [ [ int ( i <SPC> == <SPC> j ) <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>                    for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>          while <SPC> K : <NL>              if <SPC> K <SPC> % <SPC> 2 : <NL>                  result <SPC> = <SPC> matrix_mult ( result , <SPC> A ) <NL>              A <SPC> = <SPC> matrix_mult ( A , <SPC> A ) <NL>              K <SPC> /= <SPC> 2 <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> matrix_mult ( A , <SPC> B ) : <NL>          ZB <SPC> = <SPC> zip ( * B ) <NL>          return <SPC> [ <NL>              [ sum ( a <SPC> * <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( row , <SPC> col ) ) <SPC> for <SPC> col <SPC> in <SPC> ZB ] <NL>              for <SPC> row <SPC> in <SPC> A <NL>          ] <NL> <NL> <TAB> T <SPC> = <SPC> [ [ 1 , <SPC> 1 ] , <SPC> [ 1 , <SPC> 0 ] ] <NL> <TAB> return <SPC> matrix_mult ( [ [ 1 , <SPC> 0 ] ] , <SPC> matrix_expo ( T , <SPC> n ) ) [ 0 ] [ 0 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> climbStairs ( self , <SPC> n ) : <NL> <TAB> prev , <SPC> current <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          prev , <SPC> current <SPC> = <SPC> ( <NL>              current , <NL>              prev <SPC> + <SPC> current , <NL>          ) <NL> <TAB> return <SPC> current <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None , <SPC> random = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <TAB> self . random <SPC> = <SPC> random <NL> <NL> <NL> class <SPC> NodeCopy ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None , <SPC> random = None ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> copyRandomBinaryTree ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> iter_dfs ( node , <SPC> callback ) : <NL>          result <SPC> = <SPC> None <NL>          stk <SPC> = <SPC> [ node ] <NL>          while <SPC> stk : <NL>              node <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> not <SPC> node : <NL>                  continue <NL>              left_node , <SPC> copy <SPC> = <SPC> callback ( node ) <NL>              if <SPC> not <SPC> result : <NL>                  result <SPC> = <SPC> copy <NL>              stk . append ( node . right ) <NL>              stk . append ( left_node ) <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> merge ( node ) : <NL>          copy <SPC> = <SPC> NodeCopy ( node . val ) <NL>          node . left , <SPC> copy . left <SPC> = <SPC> copy , <SPC> node . left <NL>          return <SPC> copy . left , <SPC> copy <NL> <NL> <TAB> def <SPC> clone ( node ) : <NL>          copy <SPC> = <SPC> node . left <NL>          node . left . random <SPC> = <SPC> node . random . left <SPC> if <SPC> node . random <SPC> else <SPC> None <NL>          node . left . right <SPC> = <SPC> node . right . left <SPC> if <SPC> node . right <SPC> else <SPC> None <NL>          return <SPC> copy . left , <SPC> copy <NL> <NL> <TAB> def <SPC> split ( node ) : <NL>          copy <SPC> = <SPC> node . left <NL>          node . left , <SPC> copy . left <SPC> = <SPC> copy . left , <SPC> copy . left . left <SPC> if <SPC> copy . left <SPC> else <SPC> None <NL>          return <SPC> node . left , <SPC> copy <NL> <NL> <TAB> iter_dfs ( root , <SPC> merge ) <NL> <TAB> iter_dfs ( root , <SPC> clone ) <NL> <TAB> return <SPC> iter_dfs ( root , <SPC> split ) <NL> <NL> <NL> class <SPC> Solution_Recu ( object ) : <NL> <TAB> def <SPC> copyRandomBinaryTree ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> callback ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> None <NL>          left_node , <SPC> copy <SPC> = <SPC> callback ( node ) <NL>          dfs ( left_node , <SPC> callback ) <NL>          dfs ( node . right , <SPC> callback ) <NL>          return <SPC> copy <NL> <NL> <TAB> def <SPC> merge ( node ) : <NL>          copy <SPC> = <SPC> NodeCopy ( node . val ) <NL>          node . left , <SPC> copy . left <SPC> = <SPC> copy , <SPC> node . left <NL>          return <SPC> copy . left , <SPC> copy <NL> <NL> <TAB> def <SPC> clone ( node ) : <NL>          copy <SPC> = <SPC> node . left <NL>          node . left . random <SPC> = <SPC> node . random . left <SPC> if <SPC> node . random <SPC> else <SPC> None <NL>          node . left . right <SPC> = <SPC> node . right . left <SPC> if <SPC> node . right <SPC> else <SPC> None <NL>          return <SPC> copy . left , <SPC> copy <NL> <NL> <TAB> def <SPC> split ( node ) : <NL>          copy <SPC> = <SPC> node . left <NL>          node . left , <SPC> copy . left <SPC> = <SPC> copy . left , <SPC> copy . left . left <SPC> if <SPC> copy . left <SPC> else <SPC> None <NL>          return <SPC> node . left , <SPC> copy <NL> <NL> <TAB> dfs ( root , <SPC> merge ) <NL> <TAB> dfs ( root , <SPC> clone ) <NL> <TAB> return <SPC> dfs ( root , <SPC> split ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> copyRandomBinaryTree ( self , <SPC> root ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( lambda : <SPC> NodeCopy ( ) ) <NL> <TAB> lookup [ None ] <SPC> = <SPC> None <NL> <TAB> stk <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> stk : <NL>          node <SPC> = <SPC> stk . pop ( ) <NL>          if <SPC> not <SPC> node : <NL>              continue <NL>          lookup [ node ] . val <SPC> = <SPC> node . val <NL>          lookup [ node ] . left <SPC> = <SPC> lookup [ node . left ] <NL>          lookup [ node ] . right <SPC> = <SPC> lookup [ node . right ] <NL>          lookup [ node ] . random <SPC> = <SPC> lookup [ node . random ] <NL>          stk . append ( node . right ) <NL>          stk . append ( node . left ) <NL> <TAB> return <SPC> lookup [ root ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2_Recu ( object ) : <NL> <TAB> def <SPC> copyRandomBinaryTree ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> lookup ) : <NL>          if <SPC> not <SPC> node : <NL>              return <NL>          lookup [ node ] . val <SPC> = <SPC> node . val <NL>          lookup [ node ] . left <SPC> = <SPC> lookup [ node . left ] <NL>          lookup [ node ] . right <SPC> = <SPC> lookup [ node . right ] <NL>          lookup [ node ] . random <SPC> = <SPC> lookup [ node . random ] <NL>          dfs ( node . left , <SPC> lookup ) <NL>          dfs ( node . right , <SPC> lookup ) <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( lambda : <SPC> NodeCopy ( ) ) <NL> <TAB> lookup [ None ] <SPC> = <SPC> None <NL> <TAB> dfs ( root , <SPC> lookup ) <NL> <TAB> return <SPC> lookup [ root ] <NL> <NL> <NL> class <SPC> UndirectedGraphNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . label <SPC> = <SPC> x <NL> <TAB> self . neighbors <SPC> = <SPC> [ ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> cloneGraph ( self , <SPC> node ) : <NL> <TAB> if <SPC> node <SPC> is <SPC> None : <NL>          return <SPC> None <NL> <TAB> cloned_node <SPC> = <SPC> UndirectedGraphNode ( node . label ) <NL> <TAB> cloned , <SPC> queue <SPC> = <SPC> { node : <SPC> cloned_node } , <SPC> [ node ] <NL> <NL> <TAB> while <SPC> queue : <NL>          current <SPC> = <SPC> queue . pop ( ) <NL>          for <SPC> neighbor <SPC> in <SPC> current . neighbors : <NL>              if <SPC> neighbor <SPC> not <SPC> in <SPC> cloned : <NL>                  queue . append ( neighbor ) <NL>                  cloned_neighbor <SPC> = <SPC> UndirectedGraphNode ( neighbor . label ) <NL>                  cloned [ neighbor ] <SPC> = <SPC> cloned_neighbor <NL>              cloned [ current ] . neighbors . append ( cloned [ neighbor ] ) <NL> <TAB> return <SPC> cloned [ node ] <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = None , <SPC> children = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . children <SPC> = <SPC> children <SPC> if <SPC> children <SPC> is <SPC> not <SPC> None <SPC> else <SPC> [ ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> cloneTree ( self , <SPC> root ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ None ] <NL> <TAB> stk <SPC> = <SPC> [ ( 1 , <SPC> ( root , <SPC> result ) ) ] <NL> <TAB> while <SPC> stk : <NL>          step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>          if <SPC> step <SPC> == <SPC> 1 : <NL>              node , <SPC> ret <SPC> = <SPC> params <NL>              if <SPC> not <SPC> node : <NL>                  continue <NL>              ret [ 0 ] <SPC> = <SPC> Node ( node . val ) <NL>              for <SPC> child <SPC> in <SPC> reversed ( node . children ) : <NL>                  ret1 <SPC> = <SPC> [ None ] <NL>                  stk . append ( ( 2 , <SPC> ( ret1 , <SPC> ret ) ) ) <NL>                  stk . append ( ( 1 , <SPC> ( child , <SPC> ret1 ) ) ) <NL>          else : <NL>              ret1 , <SPC> ret <SPC> = <SPC> params <NL>              ret [ 0 ] . children . append ( ret1 [ 0 ] ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> cloneTree ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> None <NL>          copy <SPC> = <SPC> Node ( node . val ) <NL>          for <SPC> child <SPC> in <SPC> node . children : <NL>              copy . children . append ( dfs ( child ) ) <NL>          return <SPC> copy <NL> <NL> <TAB> return <SPC> dfs ( root ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> closestKValues ( self , <SPC> root , <SPC> target , <SPC> k ) : <NL> <NL> <TAB> def <SPC> nextNode ( stack , <SPC> child1 , <SPC> child2 ) : <NL>          if <SPC> stack : <NL>              if <SPC> child2 ( stack ) : <NL>                  stack . append ( child2 ( stack ) ) <NL>                  while <SPC> child1 ( stack ) : <NL>                      stack . append ( child1 ( stack ) ) <NL>              else : <NL>                  child <SPC> = <SPC> stack . pop ( ) <NL>                  while <SPC> stack <SPC> and <SPC> child <SPC> is <SPC> child2 ( stack ) : <NL>                      child <SPC> = <SPC> stack . pop ( ) <NL> <NL> <TAB> def <SPC> backward ( stack ) : <SPC> return <SPC> stack [ - 1 ] . left <NL> <TAB> def <SPC> forward ( stack ) : <SPC> return <SPC> stack [ - 1 ] . right <NL> <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> root : <NL>          stack . append ( root ) <NL>          root <SPC> = <SPC> root . left <SPC> if <SPC> target <SPC> < <SPC> root . val <SPC> else <SPC> root . right <NL> <NL> <TAB> def <SPC> dist ( node ) : <SPC> return <SPC> abs ( node . val <SPC> - <SPC> target ) <NL> <TAB> forward_stack <SPC> = <SPC> stack [ : <SPC> stack . index ( min ( stack , <SPC> key = dist ) ) <SPC> + <SPC> 1 ] <NL> <NL> <TAB> backward_stack <SPC> = <SPC> list ( forward_stack ) <NL> <TAB> nextNode ( backward_stack , <SPC> backward , <SPC> forward ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( k ) : <NL>          if <SPC> forward_stack <SPC> and <SPC> ( <NL>              not <SPC> backward_stack <SPC> or <SPC> dist ( <NL>                  forward_stack [ - 1 ] ) <SPC> < <SPC> dist ( backward_stack [ - 1 ] ) <NL>          ) : <NL>              result . append ( forward_stack [ - 1 ] . val ) <NL>              nextNode ( forward_stack , <SPC> forward , <SPC> backward ) <NL>          elif <SPC> backward_stack <SPC> and <SPC> ( <NL>              not <SPC> forward_stack <SPC> or <SPC> dist ( <NL>                  backward_stack [ - 1 ] ) <SPC> <= <SPC> dist ( forward_stack [ - 1 ] ) <NL>          ) : <NL>              result . append ( backward_stack [ - 1 ] . val ) <NL>              nextNode ( backward_stack , <SPC> backward , <SPC> forward ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> closestKValues ( self , <SPC> root , <SPC> target , <SPC> k ) : <NL> <NL> <TAB> class <SPC> BSTIterator : <NL> <NL>          def <SPC> __init__ ( self , <SPC> stack , <SPC> child1 , <SPC> child2 ) : <NL>              self . stack <SPC> = <SPC> list ( stack ) <NL>              self . cur <SPC> = <SPC> self . stack . pop ( ) <NL>              self . child1 <SPC> = <SPC> child1 <NL>              self . child2 <SPC> = <SPC> child2 <NL> <NL>          def <SPC> next ( self ) : <NL>              node <SPC> = <SPC> None <NL>              if <SPC> self . cur <SPC> and <SPC> self . child1 ( self . cur ) : <NL>                  self . stack . append ( self . cur ) <NL>                  node <SPC> = <SPC> self . child1 ( self . cur ) <NL>                  while <SPC> self . child2 ( node ) : <NL>                      self . stack . append ( node ) <NL>                      node <SPC> = <SPC> self . child2 ( node ) <NL>              elif <SPC> self . stack : <NL>                  prev <SPC> = <SPC> self . cur <NL>                  node <SPC> = <SPC> self . stack . pop ( ) <NL>                  while <SPC> node : <NL>                      if <SPC> self . child2 ( node ) <SPC> is <SPC> prev : <NL>                          break <NL>                      else : <NL>                          prev <SPC> = <SPC> node <NL>                          node <SPC> = <SPC> self . stack . pop ( ) <SPC> if <SPC> self . stack <SPC> else <SPC> None <NL>              self . cur <SPC> = <SPC> node <NL>              return <SPC> node <NL> <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> root : <NL>          stack . append ( root ) <NL>          root <SPC> = <SPC> root . left <SPC> if <SPC> target <SPC> < <SPC> root . val <SPC> else <SPC> root . right <NL> <NL> <TAB> def <SPC> dist ( node ) : <SPC> return <SPC> abs ( node . val <SPC> - <SPC> target ) <SPC> if <SPC> node <SPC> else <SPC> float ( "inf" ) <NL> <TAB> stack <SPC> = <SPC> stack [ : <SPC> stack . index ( min ( stack , <SPC> key = dist ) ) <SPC> + <SPC> 1 ] <NL> <NL> <TAB> def <SPC> backward ( node ) : <SPC> return <SPC> node . left <NL> <TAB> def <SPC> forward ( node ) : <SPC> return <SPC> node . right <NL> <TAB> smaller_it , <SPC> larger_it <SPC> = <SPC> BSTIterator ( stack , <SPC> backward , <SPC> forward ) , <SPC> BSTIterator ( <NL>          stack , <SPC> forward , <SPC> backward <NL> <TAB> ) <NL> <TAB> smaller_node , <SPC> larger_node <SPC> = <SPC> smaller_it . next ( ) , <SPC> larger_it . next ( ) <NL> <NL> <TAB> result <SPC> = <SPC> [ stack [ - 1 ] . val ] <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( k <SPC> - <SPC> 1 ) : <NL>          if <SPC> dist ( smaller_node ) <SPC> < <SPC> dist ( larger_node ) : <NL>              result . append ( smaller_node . val ) <NL>              smaller_node <SPC> = <SPC> smaller_it . next ( ) <NL>          else : <NL>              result . append ( larger_node . val ) <NL>              larger_node <SPC> = <SPC> larger_it . next ( ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> closestValue ( self , <SPC> root , <SPC> target ) : <NL> <NL> <TAB> gap <SPC> = <SPC> float ( "inf" ) <NL> <TAB> closest <SPC> = <SPC> float ( "inf" ) <NL> <TAB> while <SPC> root : <NL>          if <SPC> abs ( root . val <SPC> - <SPC> target ) <SPC> < <SPC> gap : <NL>              gap <SPC> = <SPC> abs ( root . val <SPC> - <SPC> target ) <NL>              closest <SPC> = <SPC> root . val <NL>          if <SPC> target <SPC> == <SPC> root . val : <NL>              break <NL>          elif <SPC> target <SPC> < <SPC> root . val : <NL>              root <SPC> = <SPC> root . left <NL>          else : <NL>              root <SPC> = <SPC> root . right <NL> <TAB> return <SPC> closest <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> closestCost ( self , <SPC> baseCosts , <SPC> toppingCosts , <SPC> target ) : <NL> <NL> <TAB> max_count <SPC> = <SPC> 2 <NL> <TAB> max_base , <SPC> max_topping <SPC> = <SPC> max ( baseCosts ) , <SPC> max ( toppingCosts ) <NL> <TAB> dp <SPC> = <SPC> [ False ] <SPC> * <SPC> ( max ( max_base , <SPC> target <SPC> + <SPC> max_topping <SPC> // <SPC> 2 ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> b <SPC> in <SPC> baseCosts : <NL>          dp [ b ] <SPC> = <SPC> True <NL> <TAB> for <SPC> t <SPC> in <SPC> toppingCosts : <NL>          for <SPC> _ <SPC> in <SPC> xrange ( max_count ) : <NL>              for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( dp ) <SPC> - <SPC> t ) ) : <NL>                  if <SPC> dp [ i ] : <NL>                      dp [ i <SPC> + <SPC> t ] <SPC> = <SPC> True <NL> <TAB> result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( dp ) ) : <NL>          if <SPC> not <SPC> dp [ i ] : <NL>              continue <NL>          if <SPC> abs ( i <SPC> - <SPC> target ) <SPC> < <SPC> abs ( result <SPC> - <SPC> target ) : <NL>              result <SPC> = <SPC> i <NL>          if <SPC> i <SPC> >= <SPC> target : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> closestCost ( self , <SPC> baseCosts , <SPC> toppingCosts , <SPC> target ) : <NL> <NL> <TAB> max_count <SPC> = <SPC> 2 <NL> <NL> <TAB> def <SPC> backtracking ( toppingCosts , <SPC> i , <SPC> cost , <SPC> target , <SPC> lookup , <SPC> result ) : <NL>          if <SPC> ( i , <SPC> cost ) <SPC> in <SPC> lookup : <NL>              return <NL>          lookup . add ( ( i , <SPC> cost ) ) <NL>          if <SPC> cost <SPC> >= <SPC> target <SPC> or <SPC> i <SPC> == <SPC> len ( toppingCosts ) : <NL>              if <SPC> ( abs ( cost <SPC> - <SPC> target ) , <SPC> cost ) <SPC> < <SPC> ( abs ( result [ 0 ] <SPC> - <SPC> target ) , <SPC> result [ 0 ] ) : <NL>                  result [ 0 ] <SPC> = <SPC> cost <NL>              return <NL>          for <SPC> j <SPC> in <SPC> xrange ( max_count <SPC> + <SPC> 1 ) : <NL>              backtracking ( <NL>                  toppingCosts , <NL>                  i <SPC> + <SPC> 1 , <NL>                  cost <SPC> + <SPC> j <SPC> * <SPC> toppingCosts [ i ] , <NL>                  target , <NL>                  lookup , <NL>                  result , <NL>              ) <NL> <NL> <TAB> result <SPC> = <SPC> [ float ( "inf" ) ] <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> b <SPC> in <SPC> baseCosts : <NL>          backtracking ( toppingCosts , <SPC> 0 , <SPC> b , <SPC> target , <SPC> lookup , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> closestCost ( self , <SPC> baseCosts , <SPC> toppingCosts , <SPC> target ) : <NL> <NL> <TAB> max_count <SPC> = <SPC> 2 <NL> <TAB> combs <SPC> = <SPC> set ( [ 0 ] ) <NL> <TAB> for <SPC> t <SPC> in <SPC> toppingCosts : <NL>          combs <SPC> = <SPC> set ( [ c <SPC> + <SPC> i <SPC> * <SPC> t <SPC> for <SPC> c <SPC> in <SPC> combs <SPC> for <SPC> i <SPC> in <SPC> xrange ( max_count <SPC> + <SPC> 1 ) ] ) <NL> <TAB> result , <SPC> combs <SPC> = <SPC> float ( "inf" ) , <SPC> sorted ( combs ) <NL> <TAB> for <SPC> b <SPC> in <SPC> baseCosts : <NL>          idx <SPC> = <SPC> bisect . bisect_left ( combs , <SPC> target <SPC> - <SPC> b ) <NL>          if <SPC> idx <SPC> < <SPC> len ( combs ) : <NL>              result <SPC> = <SPC> min ( result , <SPC> b <SPC> + <SPC> combs [ idx ] , <NL>                           key = lambda <SPC> x : <SPC> ( abs ( x <SPC> - <SPC> target ) , <SPC> x ) ) <NL>          if <SPC> idx <SPC> > <SPC> 0 : <NL>              result <SPC> = <SPC> min ( <NL>                  result , <SPC> b <SPC> + <SPC> combs [ idx <SPC> - <SPC> 1 ] , <SPC> key = lambda <SPC> x : <SPC> ( abs ( x <SPC> - <SPC> target ) , <SPC> x ) <NL>              ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> closestCost ( self , <SPC> baseCosts , <SPC> toppingCosts , <SPC> target ) : <NL> <NL> <TAB> max_count <SPC> = <SPC> 2 <NL> <TAB> combs <SPC> = <SPC> set ( [ 0 ] ) <NL> <TAB> for <SPC> t <SPC> in <SPC> toppingCosts : <NL>          combs <SPC> = <SPC> set ( [ c <SPC> + <SPC> i <SPC> * <SPC> t <SPC> for <SPC> c <SPC> in <SPC> combs <SPC> for <SPC> i <SPC> in <SPC> xrange ( max_count <SPC> + <SPC> 1 ) ] ) <NL> <TAB> result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> b <SPC> in <SPC> baseCosts : <NL>          for <SPC> c <SPC> in <SPC> combs : <NL>              result <SPC> = <SPC> min ( result , <SPC> b <SPC> + <SPC> c , <SPC> key = lambda <SPC> x : <SPC> ( abs ( x <SPC> - <SPC> target ) , <SPC> x ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> closestDivisors ( self , <SPC> num ) : <NL> <NL> <TAB> def <SPC> divisors ( n ) : <NL>          for <SPC> d <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> int ( n <SPC> ** <SPC> 0.5 ) <SPC> + <SPC> 1 ) ) : <NL>              if <SPC> n <SPC> % <SPC> d <SPC> == <SPC> 0 : <NL>                  return <SPC> d , <SPC> n <SPC> // <SPC> d <NL>          return <SPC> 1 , <SPC> n <NL> <NL> <TAB> return <SPC> min ( [ divisors ( num <SPC> + <SPC> 1 ) , <SPC> divisors ( num <SPC> + <SPC> 2 ) ] , <SPC> key = lambda <SPC> x : <SPC> x [ 1 ] <SPC> - <SPC> x [ 0 ] ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> closestDivisors ( self , <SPC> num ) : <NL> <NL> <TAB> result , <SPC> d <SPC> = <SPC> [ 1 , <SPC> num <SPC> + <SPC> 1 ] , <SPC> 1 <NL> <TAB> while <SPC> d <SPC> * <SPC> d <SPC> <= <SPC> num <SPC> + <SPC> 2 : <NL>          if <SPC> ( num <SPC> + <SPC> 2 ) <SPC> % <SPC> d <SPC> == <SPC> 0 : <NL>              result <SPC> = <SPC> [ d , <SPC> ( num <SPC> + <SPC> 2 ) <SPC> // <SPC> d ] <NL>          if <SPC> ( num <SPC> + <SPC> 1 ) <SPC> % <SPC> d <SPC> == <SPC> 0 : <NL>              result <SPC> = <SPC> [ d , <SPC> ( num <SPC> + <SPC> 1 ) <SPC> // <SPC> d ] <NL>          d <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findClosestLeaf ( self , <SPC> root , <SPC> k ) : <NL> <NL> <TAB> def <SPC> traverse ( node , <SPC> neighbors , <SPC> leaves ) : <NL>          if <SPC> not <SPC> node : <NL>              return <NL>          if <SPC> not <SPC> node . left <SPC> and <SPC> not <SPC> node . right : <NL>              leaves . add ( node . val ) <NL>              return <NL>          if <SPC> node . left : <NL>              neighbors [ node . val ] . append ( node . left . val ) <NL>              neighbors [ node . left . val ] . append ( node . val ) <NL>              traverse ( node . left , <SPC> neighbors , <SPC> leaves ) <NL>          if <SPC> node . right : <NL>              neighbors [ node . val ] . append ( node . right . val ) <NL>              neighbors [ node . right . val ] . append ( node . val ) <NL>              traverse ( node . right , <SPC> neighbors , <SPC> leaves ) <NL> <NL> <TAB> neighbors , <SPC> leaves <SPC> = <SPC> collections . defaultdict ( list ) , <SPC> set ( ) <NL> <TAB> traverse ( root , <SPC> neighbors , <SPC> leaves ) <NL> <TAB> q , <SPC> lookup <SPC> = <SPC> [ k ] , <SPC> set ( [ k ] ) <NL> <TAB> while <SPC> q : <NL>          next_q <SPC> = <SPC> [ ] <NL>          for <SPC> u <SPC> in <SPC> q : <NL>              if <SPC> u <SPC> in <SPC> leaves : <NL>                  return <SPC> u <NL>              for <SPC> v <SPC> in <SPC> neighbors [ u ] : <NL>                  if <SPC> v <SPC> in <SPC> lookup : <NL>                      continue <NL>                  lookup . add ( v ) <NL>                  next_q . append ( v ) <NL>          q <SPC> = <SPC> next_q <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minAbsDifference ( self , <SPC> nums , <SPC> goal ) : <NL> <NL> <TAB> mx , <SPC> mn <SPC> = <SPC> sum ( x <SPC> for <SPC> x <SPC> in <SPC> nums <SPC> if <SPC> x <SPC> > <SPC> 0 ) , <SPC> sum ( x <SPC> for <SPC> x <SPC> in <SPC> nums <SPC> if <SPC> x <SPC> < <SPC> 0 ) <NL> <TAB> if <SPC> goal <SPC> > <SPC> mx : <NL>          return <SPC> goal <SPC> - <SPC> mx <NL> <TAB> if <SPC> goal <SPC> < <SPC> mn : <NL>          return <SPC> mn <SPC> - <SPC> goal <NL> <TAB> result <SPC> = <SPC> abs ( goal ) <NL> <TAB> sums1 <SPC> = <SPC> set ( [ 0 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) <SPC> // <SPC> 2 ) : <NL>          for <SPC> x <SPC> in <SPC> list ( sums1 ) : <NL>              if <SPC> x <SPC> + <SPC> nums [ i ] <SPC> in <SPC> sums1 : <NL>                  continue <NL>              sums1 . add ( x <SPC> + <SPC> nums [ i ] ) <NL>              result <SPC> = <SPC> min ( <NL>                  result , <SPC> abs ( goal <SPC> - <SPC> x <SPC> - <SPC> nums [ i ] ) <NL>              ) <NL> <TAB> sorted_sums1 <SPC> = <SPC> sorted ( sums1 ) <NL> <TAB> sums2 <SPC> = <SPC> set ( [ 0 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) <SPC> // <SPC> 2 , <SPC> len ( nums ) ) : <NL>          for <SPC> x <SPC> in <SPC> list ( sums2 ) : <NL>              if <SPC> x <SPC> + <SPC> nums [ i ] <SPC> in <SPC> sums2 : <NL>                  continue <NL>              sums2 . add ( x <SPC> + <SPC> nums [ i ] ) <NL>              ni <SPC> = <SPC> bisect . bisect_left ( sorted_sums1 , <SPC> goal <SPC> - <SPC> x <SPC> - <SPC> nums [ i ] ) <NL>              if <SPC> ni <SPC> < <SPC> len ( sorted_sums1 ) : <NL>                  result <SPC> = <SPC> min ( result , <SPC> abs ( <NL>                      goal <SPC> - <SPC> x <SPC> - <SPC> nums [ i ] <SPC> - <SPC> sorted_sums1 [ ni ] ) ) <NL>              if <SPC> ni <SPC> > <SPC> 0 : <NL>                  result <SPC> = <SPC> min ( result , <SPC> abs ( <NL>                      goal <SPC> - <SPC> x <SPC> - <SPC> nums [ i ] <SPC> - <SPC> sorted_sums1 [ ni <SPC> - <SPC> 1 ] ) ) <NL>              if <SPC> result <SPC> == <SPC> 0 : <NL>                  return <SPC> result <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> clumsy ( self , <SPC> N ) : <NL> <NL> <TAB> if <SPC> N <SPC> <= <SPC> 2 : <NL>          return <SPC> N <NL> <TAB> if <SPC> N <SPC> <= <SPC> 4 : <NL>          return <SPC> N <SPC> + <SPC> 3 <NL> <NL> <TAB> if <SPC> N <SPC> % <SPC> 4 <SPC> == <SPC> 0 : <NL>          return <SPC> N <SPC> + <SPC> 1 <NL> <TAB> elif <SPC> N <SPC> % <SPC> 4 <SPC> <= <SPC> 2 : <NL>          return <SPC> N <SPC> + <SPC> 2 <NL> <TAB> return <SPC> N <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> change ( self , <SPC> amount , <SPC> coins ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( amount <SPC> + <SPC> 1 ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> coin <SPC> in <SPC> coins : <NL>          for <SPC> i <SPC> in <SPC> xrange ( coin , <SPC> amount <SPC> + <SPC> 1 ) : <NL>              dp [ i ] <SPC> += <SPC> dp [ i <SPC> - <SPC> coin ] <NL> <TAB> return <SPC> dp [ amount ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> coinChange ( self , <SPC> coins , <SPC> amount ) : <NL> <NL> <TAB> INF <SPC> = <SPC> 0x7FFFFFFF <NL> <TAB> dp <SPC> = <SPC> [ INF ] <SPC> * <SPC> ( amount <SPC> + <SPC> 1 ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( amount <SPC> + <SPC> 1 ) : <NL>          if <SPC> dp [ i ] <SPC> != <SPC> INF : <NL>              for <SPC> coin <SPC> in <SPC> coins : <NL>                  if <SPC> i <SPC> + <SPC> coin <SPC> <= <SPC> amount : <NL>                      dp [ i <SPC> + <SPC> coin ] <SPC> = <SPC> min ( dp [ i <SPC> + <SPC> coin ] , <SPC> dp [ i ] <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> dp [ amount ] <SPC> if <SPC> dp [ amount ] <SPC> != <SPC> INF <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> cheapestJump ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> not <SPC> A <SPC> or <SPC> A [ - 1 ] <SPC> == <SPC> - 1 : <NL>          return <SPC> result <NL> <TAB> n <SPC> = <SPC> len ( A ) <NL> <TAB> dp , <SPC> next_pos <SPC> = <SPC> [ float ( "inf" ) ] <SPC> * <SPC> n , <SPC> [ - 1 ] <SPC> * <SPC> n <NL> <TAB> dp [ n <SPC> - <SPC> 1 ] <SPC> = <SPC> A [ n <SPC> - <SPC> 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( n <SPC> - <SPC> 1 ) ) : <NL>          if <SPC> A [ i ] <SPC> == <SPC> - 1 : <NL>              continue <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> min ( i <SPC> + <SPC> B <SPC> + <SPC> 1 , <SPC> n ) ) : <NL>              if <SPC> A [ i ] <SPC> + <SPC> dp [ j ] <SPC> < <SPC> dp [ i ] : <NL>                  dp [ i ] <SPC> = <SPC> A [ i ] <SPC> + <SPC> dp [ j ] <NL>                  next_pos [ i ] <SPC> = <SPC> j <NL> <TAB> if <SPC> dp [ 0 ] <SPC> == <SPC> float ( "inf" ) : <NL>          return <SPC> result <NL> <TAB> k <SPC> = <SPC> 0 <NL> <TAB> while <SPC> k <SPC> != <SPC> - 1 : <NL>          result . append ( k <SPC> + <SPC> 1 ) <NL>          k <SPC> = <SPC> next_pos [ k ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> colorBorder ( self , <SPC> grid , <SPC> r0 , <SPC> c0 , <SPC> color ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <NL> <TAB> lookup , <SPC> q , <SPC> borders <SPC> = <SPC> set ( [ ( r0 , <SPC> c0 ) ] ) , <SPC> collections . deque ( [ ( r0 , <SPC> c0 ) ] ) , <SPC> [ ] <NL> <TAB> while <SPC> q : <NL>          r , <SPC> c <SPC> = <SPC> q . popleft ( ) <NL>          is_border <SPC> = <SPC> False <NL> <NL>          for <SPC> direction <SPC> in <SPC> directions : <NL>              nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> direction [ 0 ] , <SPC> c <SPC> + <SPC> direction [ 1 ] <NL>              if <SPC> not <SPC> ( <NL>                  ( 0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( grid ) ) <NL>                  and <SPC> ( 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ 0 ] ) ) <NL>                  and <SPC> grid [ nr ] [ nc ] <SPC> == <SPC> grid [ r ] [ c ] <NL>              ) : <NL>                  is_border <SPC> = <SPC> True <NL>                  continue <NL>              if <SPC> ( nr , <SPC> nc ) <SPC> in <SPC> lookup : <NL>                  continue <NL>              lookup . add ( ( nr , <SPC> nc ) ) <NL>              q . append ( ( nr , <SPC> nc ) ) <NL> <NL>          if <SPC> is_border : <NL>              borders . append ( ( r , <SPC> c ) ) <NL> <NL> <TAB> for <SPC> r , <SPC> c <SPC> in <SPC> borders : <NL>          grid [ r ] [ c ] <SPC> = <SPC> color <NL> <TAB> return <SPC> grid <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> combinationSum2 ( self , <SPC> candidates , <SPC> target ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> self . combinationSumRecu ( sorted ( candidates ) , <SPC> result , <SPC> 0 , <SPC> [ ] , <SPC> target ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> combinationSumRecu ( self , <SPC> candidates , <SPC> result , <SPC> start , <SPC> intermediate , <SPC> target ) : <NL> <TAB> if <SPC> target <SPC> == <SPC> 0 : <NL>          result . append ( list ( intermediate ) ) <NL> <TAB> prev <SPC> = <SPC> 0 <NL> <TAB> while <SPC> start <SPC> < <SPC> len ( candidates ) <SPC> and <SPC> candidates [ start ] <SPC> <= <SPC> target : <NL>          if <SPC> prev <SPC> != <SPC> candidates [ start ] : <NL>              intermediate . append ( candidates [ start ] ) <NL>              self . combinationSumRecu ( <NL>                  candidates , <NL>                  result , <NL>                  start <SPC> + <SPC> 1 , <NL>                  intermediate , <NL>                  target <SPC> - <SPC> candidates [ start ] , <NL>              ) <NL>              intermediate . pop ( ) <NL>              prev <SPC> = <SPC> candidates [ start ] <NL>          start <SPC> += <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> combinationSum3 ( self , <SPC> k , <SPC> n ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> self . combinationSumRecu ( result , <SPC> [ ] , <SPC> 1 , <SPC> k , <SPC> n ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> combinationSumRecu ( self , <SPC> result , <SPC> intermediate , <SPC> start , <SPC> k , <SPC> target ) : <NL> <TAB> if <SPC> k <SPC> == <SPC> 0 <SPC> and <SPC> target <SPC> == <SPC> 0 : <NL>          result . append ( list ( intermediate ) ) <NL> <TAB> elif <SPC> k <SPC> < <SPC> 0 : <NL>          return <NL> <TAB> while <SPC> start <SPC> < <SPC> 10 <SPC> and <SPC> start <SPC> * <SPC> k <SPC> + <SPC> k <SPC> * <SPC> ( k <SPC> - <SPC> 1 ) <SPC> / <SPC> 2 <SPC> <= <SPC> target : <NL>          intermediate . append ( start ) <NL>          self . combinationSumRecu ( <NL>              result , <SPC> intermediate , <SPC> start <SPC> + <SPC> 1 , <SPC> k <SPC> - <SPC> 1 , <SPC> target <SPC> - <SPC> start <NL>          ) <NL>          intermediate . pop ( ) <NL>          start <SPC> += <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> combinationSum4 ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( target <SPC> + <SPC> 1 ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> nums . sort ( ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> target <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>              if <SPC> nums [ j ] <SPC> <= <SPC> i : <NL>                  dp [ i ] <SPC> += <SPC> dp [ i <SPC> - <SPC> nums [ j ] ] <NL>              else : <NL>                  break <NL> <NL> <TAB> return <SPC> dp [ target ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> combinationSum ( self , <SPC> candidates , <SPC> target ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> self . combinationSumRecu ( sorted ( candidates ) , <SPC> result , <SPC> 0 , <SPC> [ ] , <SPC> target ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> combinationSumRecu ( self , <SPC> candidates , <SPC> result , <SPC> start , <SPC> intermediate , <SPC> target ) : <NL> <TAB> if <SPC> target <SPC> == <SPC> 0 : <NL>          result . append ( list ( intermediate ) ) <NL> <TAB> while <SPC> start <SPC> < <SPC> len ( candidates ) <SPC> and <SPC> candidates [ start ] <SPC> <= <SPC> target : <NL>          intermediate . append ( candidates [ start ] ) <NL>          self . combinationSumRecu ( <NL>              candidates , <SPC> result , <SPC> start , <SPC> intermediate , <SPC> target <SPC> - <SPC> candidates [ start ] <NL>          ) <NL>          intermediate . pop ( ) <NL>          start <SPC> += <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> combine ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> if <SPC> k <SPC> > <SPC> n : <NL>          return <SPC> [ ] <NL> <TAB> nums , <SPC> idxs <SPC> = <SPC> range ( 1 , <SPC> n <SPC> + <SPC> 1 ) , <SPC> range ( k ) <NL> <TAB> result <SPC> = <SPC> [ [ nums [ i ] <SPC> for <SPC> i <SPC> in <SPC> idxs ] ] <NL> <TAB> while <SPC> True : <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( k ) ) : <NL>              if <SPC> idxs [ i ] <SPC> != <SPC> i <SPC> + <SPC> n <SPC> - <SPC> k : <NL>                  break <NL>          else : <NL>              break <NL>          idxs [ i ] <SPC> += <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> k ) : <NL>              idxs [ j ] <SPC> = <SPC> idxs [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 <NL>          result . append ( [ nums [ i ] <SPC> for <SPC> i <SPC> in <SPC> idxs ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> combine ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> result , <SPC> combination <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> i <SPC> = <SPC> 1 <NL> <TAB> while <SPC> True : <NL>          if <SPC> len ( combination ) <SPC> == <SPC> k : <NL>              result . append ( combination [ : ] ) <NL>          if <SPC> len ( combination ) <SPC> == <SPC> k <SPC> or <SPC> len ( combination ) <SPC> + <SPC> ( n <SPC> - <SPC> i <SPC> + <SPC> 1 ) <SPC> < <SPC> k : <NL>              if <SPC> not <SPC> combination : <NL>                  break <NL>              i <SPC> = <SPC> combination . pop ( ) <SPC> + <SPC> 1 <NL>          else : <NL>              combination . append ( i ) <NL>              i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> combine ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> def <SPC> combineDFS ( n , <SPC> start , <SPC> intermediate , <SPC> k , <SPC> result ) : <NL>          if <SPC> k <SPC> == <SPC> 0 : <NL>              result . append ( intermediate [ : ] ) <NL>              return <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> n ) : <NL>              intermediate . append ( i <SPC> + <SPC> 1 ) <NL>              combineDFS ( n , <SPC> i <SPC> + <SPC> 1 , <SPC> intermediate , <SPC> k <SPC> - <SPC> 1 , <SPC> result ) <NL>              intermediate . pop ( ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> combineDFS ( n , <SPC> 0 , <SPC> [ ] , <SPC> k , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSmallerByFrequency ( self , <SPC> queries , <SPC> words ) : <NL> <NL> <TAB> words_freq <SPC> = <SPC> sorted ( word . count ( min ( word ) ) <SPC> for <SPC> word <SPC> in <SPC> words ) <NL> <TAB> return <SPC> [ <NL>          len ( words ) <SPC> - <SPC> bisect . bisect_right ( words_freq , <SPC> query . count ( min ( query ) ) ) <NL>          for <SPC> query <SPC> in <SPC> queries <NL> <TAB> ] <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> compareVersion ( self , <SPC> version1 , <SPC> version2 ) : <NL> <NL> <TAB> n1 , <SPC> n2 <SPC> = <SPC> len ( version1 ) , <SPC> len ( version2 ) <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> n1 <SPC> or <SPC> j <SPC> < <SPC> n2 : <NL>          v1 , <SPC> v2 <SPC> = <SPC> 0 , <SPC> 0 <NL>          while <SPC> i <SPC> < <SPC> n1 <SPC> and <SPC> version1 [ i ] <SPC> != <SPC> "." : <NL>              v1 <SPC> = <SPC> v1 <SPC> * <SPC> 10 <SPC> + <SPC> int ( version1 [ i ] ) <NL>              i <SPC> += <SPC> 1 <NL>          while <SPC> j <SPC> < <SPC> n2 <SPC> and <SPC> version2 [ j ] <SPC> != <SPC> "." : <NL>              v2 <SPC> = <SPC> v2 <SPC> * <SPC> 10 <SPC> + <SPC> int ( version2 [ j ] ) <NL>              j <SPC> += <SPC> 1 <NL>          if <SPC> v1 <SPC> != <SPC> v2 : <NL>              return <SPC> 1 <SPC> if <SPC> v1 <SPC> > <SPC> v2 <SPC> else <SPC> - 1 <NL>          i <SPC> += <SPC> 1 <NL>          j <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> compareVersion ( self , <SPC> version1 , <SPC> version2 ) : <NL> <NL> <TAB> v1 , <SPC> v2 <SPC> = <SPC> version1 . split ( "." ) , <SPC> version2 . split ( "." ) <NL> <NL> <TAB> if <SPC> len ( v1 ) <SPC> > <SPC> len ( v2 ) : <NL>          v2 <SPC> += <SPC> [ "0" <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( v1 ) <SPC> - <SPC> len ( v2 ) ) ] <NL> <TAB> elif <SPC> len ( v1 ) <SPC> < <SPC> len ( v2 ) : <NL>          v1 <SPC> += <SPC> [ "0" <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( v2 ) <SPC> - <SPC> len ( v1 ) ) ] <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( v1 ) : <NL>          if <SPC> int ( v1 [ i ] ) <SPC> > <SPC> int ( v2 [ i ] ) : <NL>              return <SPC> 1 <NL>          elif <SPC> int ( v1 [ i ] ) <SPC> < <SPC> int ( v2 [ i ] ) : <NL>              return <SPC> - 1 <NL>          else : <NL>              i <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> 0 <NL> <NL> <TAB> def <SPC> compareVersion2 ( self , <SPC> version1 , <SPC> version2 ) : <NL> <NL> <TAB> v1 <SPC> = <SPC> [ int ( x ) <SPC> for <SPC> x <SPC> in <SPC> version1 . split ( "." ) ] <NL> <TAB> v2 <SPC> = <SPC> [ int ( x ) <SPC> for <SPC> x <SPC> in <SPC> version2 . split ( "." ) ] <NL> <TAB> while <SPC> len ( v1 ) <SPC> != <SPC> len ( v2 ) : <NL>          if <SPC> len ( v1 ) <SPC> > <SPC> len ( v2 ) : <NL>              v2 . append ( 0 ) <NL>          else : <NL>              v1 . append ( 0 ) <NL> <TAB> return <SPC> cmp ( v1 , <SPC> v2 ) <NL> <NL> <TAB> def <SPC> compareVersion3 ( self , <SPC> version1 , <SPC> version2 ) : <NL> <TAB> splits <SPC> = <SPC> ( map ( int , <SPC> v . split ( "." ) ) <SPC> for <SPC> v <SPC> in <SPC> ( version1 , <SPC> version2 ) ) <NL> <TAB> return <SPC> cmp ( * zip ( * itertools . izip_longest ( * splits , <SPC> fillvalue = 0 ) ) ) <NL> <NL> <TAB> def <SPC> compareVersion4 ( self , <SPC> version1 , <SPC> version2 ) : <NL> <TAB> main1 , <SPC> _ , <SPC> rest1 <SPC> = <SPC> ( "0" <SPC> + <SPC> version1 ) . partition ( "." ) <NL> <TAB> main2 , <SPC> _ , <SPC> rest2 <SPC> = <SPC> ( "0" <SPC> + <SPC> version2 ) . partition ( "." ) <NL> <TAB> return <SPC> ( <NL>          cmp ( int ( main1 ) , <SPC> int ( main2 ) ) <NL>          or <SPC> len ( rest1 <SPC> + <SPC> rest2 ) <NL>          and <SPC> self . compareVersion4 ( rest1 , <SPC> rest2 ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> bitwiseComplement ( self , <SPC> N ) : <NL> <NL> <TAB> mask <SPC> = <SPC> 1 <NL> <TAB> while <SPC> N <SPC> > <SPC> mask : <NL>          mask <SPC> = <SPC> mask <SPC> * <SPC> 2 <SPC> + <SPC> 1 <NL> <TAB> return <SPC> mask <SPC> - <SPC> N <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> CBTInserter ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> root ) : <NL> <NL> <TAB> self . __tree <SPC> = <SPC> [ root ] <NL> <TAB> for <SPC> i <SPC> in <SPC> self . __tree : <NL>          if <SPC> i . left : <NL>              self . __tree . append ( i . left ) <NL>          if <SPC> i . right : <NL>              self . __tree . append ( i . right ) <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> v ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( self . __tree ) <NL> <TAB> self . __tree . append ( TreeNode ( v ) ) <NL> <TAB> if <SPC> n <SPC> % <SPC> 2 : <NL>          self . __tree [ ( n <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 ] . left <SPC> = <SPC> self . __tree [ - 1 ] <NL> <TAB> else : <NL>          self . __tree [ ( n <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 ] . right <SPC> = <SPC> self . __tree [ - 1 ] <NL> <TAB> return <SPC> self . __tree [ ( n <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 ] . val <NL> <NL> <TAB> def <SPC> get_root ( self ) : <NL> <NL> <TAB> return <SPC> self . __tree [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> complexNumberMultiply ( self , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> ra , <SPC> ia <SPC> = <SPC> map ( int , <SPC> a [ : - 1 ] . split ( "+" ) ) <NL> <TAB> rb , <SPC> ib <SPC> = <SPC> map ( int , <SPC> b [ : - 1 ] . split ( "+" ) ) <NL> <TAB> return <SPC> "%d+%di" <SPC> % <SPC> ( ra <SPC> * <SPC> rb <SPC> - <SPC> ia <SPC> * <SPC> ib , <SPC> ra <SPC> * <SPC> ib <SPC> + <SPC> ia <SPC> * <SPC> rb ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findAllConcatenatedWordsInADict ( self , <SPC> words ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( words ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          dp <SPC> = <SPC> [ False ] <SPC> * <SPC> ( len ( word ) <SPC> + <SPC> 1 ) <NL>          dp [ 0 ] <SPC> = <SPC> True <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( word ) ) : <NL>              if <SPC> not <SPC> dp [ i ] : <NL>                  continue <NL> <NL>              for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( word ) <SPC> + <SPC> 1 ) : <NL>                  if <SPC> j <SPC> - <SPC> i <SPC> < <SPC> len ( word ) <SPC> and <SPC> word [ i : j ] <SPC> in <SPC> lookup : <NL>                      dp [ j ] <SPC> = <SPC> True <NL> <NL>              if <SPC> dp [ len ( word ) ] : <NL>                  result . append ( word ) <NL>                  break <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> concatenatedBinary ( self , <SPC> n ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> result <SPC> = <SPC> l <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          if <SPC> i <SPC> & <SPC> ( i <SPC> - <SPC> 1 ) <SPC> == <SPC> 0 : <NL>              l <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> ( ( result <SPC> << <SPC> l ) <SPC> % <SPC> MOD <SPC> + <SPC> i ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> confusingNumberII ( self , <SPC> N ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { "0" : <SPC> "0" , <SPC> "1" : <SPC> "1" , <SPC> "6" : <SPC> "9" , <SPC> "8" : <SPC> "8" , <SPC> "9" : <SPC> "6" } <NL> <TAB> centers <SPC> = <SPC> { "0" : <SPC> "0" , <SPC> "1" : <SPC> "1" , <SPC> "8" : <SPC> "8" } <NL> <NL> <TAB> def <SPC> totalCount ( N ) : <NL>          s <SPC> = <SPC> str ( N ) <NL>          total <SPC> = <SPC> 0 <NL>          p <SPC> = <SPC> len ( lookup ) <SPC> ** <SPC> ( len ( s ) <SPC> - <SPC> 1 ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>              if <SPC> i <SPC> + <SPC> 1 <SPC> == <SPC> len ( s ) : <NL>                  for <SPC> c <SPC> in <SPC> lookup . iterkeys ( ) : <NL>                      total <SPC> += <SPC> int ( c <SPC> <= <SPC> s [ i ] ) <NL>                  continue <NL>              smaller <SPC> = <SPC> 0 <NL>              for <SPC> c <SPC> in <SPC> lookup . iterkeys ( ) : <NL>                  smaller <SPC> += <SPC> int ( c <SPC> < <SPC> s [ i ] ) <NL>              total <SPC> += <SPC> smaller <SPC> * <SPC> p <NL>              if <SPC> s [ i ] <SPC> not <SPC> in <SPC> lookup : <NL>                  break <NL>              p <SPC> //= <SPC> len ( lookup ) <NL>          return <SPC> total <NL> <NL> <TAB> def <SPC> validCountInLessLength ( N ) : <NL>          s <SPC> = <SPC> str ( N ) <NL>          valid <SPC> = <SPC> 0 <NL>          total <SPC> = <SPC> len ( centers ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) , <SPC> 2 ) : <NL>              if <SPC> i <SPC> == <SPC> 1 : <NL>                  valid <SPC> += <SPC> total <NL>              else : <NL>                  valid <SPC> += <SPC> total <SPC> * <SPC> ( len ( lookup ) <SPC> - <SPC> 1 ) <NL>                  total <SPC> *= <SPC> len ( lookup ) <NL>          total <SPC> = <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> len ( s ) , <SPC> 2 ) : <NL>              valid <SPC> += <SPC> total <SPC> * <SPC> ( len ( lookup ) <SPC> - <SPC> 1 ) <NL>              total <SPC> *= <SPC> len ( lookup ) <NL>          return <SPC> valid <NL> <NL> <TAB> def <SPC> validCountInFullLength ( N ) : <NL>          s <SPC> = <SPC> str ( N ) <NL>          half_s <SPC> = <SPC> s [ : <SPC> ( len ( s ) <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 ] <NL>          total <SPC> = <SPC> 0 <NL>          p <SPC> = <SPC> ( <NL>              len ( lookup ) <SPC> ** <SPC> ( len ( half_s ) <SPC> - <SPC> 2 ) <SPC> * <SPC> len ( centers ) <NL>              if <SPC> ( len ( s ) <SPC> % <SPC> 2 ) <NL>              else <SPC> len ( lookup ) <SPC> ** <SPC> ( len ( half_s ) <SPC> - <SPC> 1 ) <NL>          ) <NL>          choices <SPC> = <SPC> centers <SPC> if <SPC> ( len ( s ) <SPC> % <SPC> 2 ) <SPC> else <SPC> lookup <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( half_s ) ) : <NL>              if <SPC> i <SPC> + <SPC> 1 <SPC> == <SPC> len ( half_s ) : <NL>                  for <SPC> c <SPC> in <SPC> choices . iterkeys ( ) : <NL>                      if <SPC> c <SPC> == <SPC> "0" <SPC> and <SPC> i <SPC> == <SPC> 0 : <NL>                          continue <NL>                      total <SPC> += <SPC> int ( c <SPC> < <SPC> half_s [ i ] ) <NL>                  if <SPC> half_s [ i ] <SPC> not <SPC> in <SPC> choices : <NL>                      break <NL>                  tmp <SPC> = <SPC> list ( half_s ) <NL>                  for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( half_s ) <SPC> - <SPC> ( len ( s ) <SPC> % <SPC> 2 ) ) ) : <NL>                      tmp . append ( lookup [ half_s [ i ] ] ) <NL>                  if <SPC> int ( "" . join ( tmp ) ) <SPC> <= <SPC> N : <NL>                      total <SPC> += <SPC> 1 <NL>                  continue <NL> <NL>              smaller <SPC> = <SPC> 0 <NL>              for <SPC> c <SPC> in <SPC> lookup . iterkeys ( ) : <NL>                  if <SPC> c <SPC> == <SPC> "0" <SPC> and <SPC> i <SPC> == <SPC> 0 : <NL>                      continue <NL>                  smaller <SPC> += <SPC> int ( c <SPC> < <SPC> half_s [ i ] ) <NL>              total <SPC> += <SPC> smaller <SPC> * <SPC> p <NL>              if <SPC> half_s [ i ] <SPC> not <SPC> in <SPC> lookup : <NL>                  break <NL>              p <SPC> //= <SPC> len ( lookup ) <NL>          return <SPC> total <NL> <NL> <TAB> return <SPC> totalCount ( N ) <SPC> - <SPC> validCountInLessLength ( N ) <SPC> - <SPC> validCountInFullLength ( N ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> confusingNumber ( self , <SPC> N ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { "0" : <SPC> "0" , <SPC> "1" : <SPC> "1" , <SPC> "6" : <SPC> "9" , <SPC> "8" : <SPC> "8" , <SPC> "9" : <SPC> "6" } <NL> <NL> <TAB> S <SPC> = <SPC> str ( N ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( S ) ) : <NL>          if <SPC> S [ i ] <SPC> not <SPC> in <SPC> lookup : <NL>              return <SPC> False <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( ( len ( S ) <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 ) : <NL>          if <SPC> S [ i ] <SPC> != <SPC> lookup [ S [ - ( i <SPC> + <SPC> 1 ) ] ] : <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . count <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> self . count <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumCost ( self , <SPC> N , <SPC> connections ) : <NL> <NL> <TAB> connections . sort ( key = lambda <SPC> x : <SPC> x [ 2 ] ) <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( N ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> u , <SPC> v , <SPC> val <SPC> in <SPC> connections : <NL>          if <SPC> union_find . union_set ( u <SPC> - <SPC> 1 , <SPC> v <SPC> - <SPC> 1 ) : <NL>              result <SPC> += <SPC> val <NL> <TAB> return <SPC> result <SPC> if <SPC> union_find . count <SPC> == <SPC> 1 <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxPower ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> count <SPC> = <SPC> 1 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) ) : <NL>          if <SPC> s [ i ] <SPC> == <SPC> s [ i <SPC> - <SPC> 1 ] : <NL>              count <SPC> += <SPC> 1 <NL>          else : <NL>              count <SPC> = <SPC> 1 <NL>          result <SPC> = <SPC> max ( result , <SPC> count ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxPower ( self , <SPC> s ) : <NL> <TAB> return <SPC> max ( len ( list ( v ) ) <SPC> for <SPC> _ , <SPC> v <SPC> in <SPC> itertools . groupby ( s ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> consecutiveNumbersSum ( self , <SPC> N ) : <NL> <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> while <SPC> N <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>          N <SPC> /= <SPC> 2 <NL> <TAB> i <SPC> = <SPC> 3 <NL> <TAB> while <SPC> i <SPC> * <SPC> i <SPC> <= <SPC> N : <NL>          count <SPC> = <SPC> 0 <NL>          while <SPC> N <SPC> % <SPC> i <SPC> == <SPC> 0 : <NL>              N <SPC> /= <SPC> i <NL>              count <SPC> += <SPC> 1 <NL>          result <SPC> *= <SPC> count <SPC> + <SPC> 1 <NL>          i <SPC> += <SPC> 2 <NL> <TAB> if <SPC> N <SPC> > <SPC> 1 : <NL>          result <SPC> *= <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> constrainedSubsetSum ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> result , <SPC> dq <SPC> = <SPC> float ( "-inf" ) , <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> dq <SPC> and <SPC> i <SPC> - <SPC> dq [ 0 ] [ 0 ] <SPC> == <SPC> k <SPC> + <SPC> 1 : <NL>              dq . popleft ( ) <NL>          curr <SPC> = <SPC> nums [ i ] <SPC> + <SPC> ( dq [ 0 ] [ 1 ] <SPC> if <SPC> dq <SPC> else <SPC> 0 ) <NL>          while <SPC> dq <SPC> and <SPC> dq [ - 1 ] [ 1 ] <SPC> <= <SPC> curr : <NL>              dq . pop ( ) <NL>          if <SPC> curr <SPC> > <SPC> 0 : <NL>              dq . append ( ( i , <SPC> curr ) ) <NL>          result <SPC> = <SPC> max ( result , <SPC> curr ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> bstFromPreorder ( self , <SPC> preorder ) : <NL> <NL> <TAB> def <SPC> bstFromPreorderHelper ( preorder , <SPC> left , <SPC> right , <SPC> index ) : <NL>          if <SPC> ( <NL>              index [ 0 ] <SPC> == <SPC> len ( preorder ) <NL>              or <SPC> preorder [ index [ 0 ] ] <SPC> < <SPC> left <NL>              or <SPC> preorder [ index [ 0 ] ] <SPC> > <SPC> right <NL>          ) : <NL>              return <SPC> None <NL> <NL>          root <SPC> = <SPC> TreeNode ( preorder [ index [ 0 ] ] ) <NL>          index [ 0 ] <SPC> += <SPC> 1 <NL>          root . left <SPC> = <SPC> bstFromPreorderHelper ( preorder , <SPC> left , <SPC> root . val , <SPC> index ) <NL>          root . right <SPC> = <SPC> bstFromPreorderHelper ( preorder , <SPC> root . val , <SPC> right , <SPC> index ) <NL>          return <SPC> root <NL> <NL> <TAB> return <SPC> bstFromPreorderHelper ( preorder , <SPC> float ( "-inf" ) , <SPC> float ( "inf" ) , <SPC> [ 0 ] ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> buildTree ( self , <SPC> inorder , <SPC> postorder ) : <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( inorder ) : <NL>          lookup [ num ] <SPC> = <SPC> i <NL> <TAB> return <SPC> self . buildTreeRecu ( <NL>          lookup , <SPC> postorder , <SPC> inorder , <SPC> len ( postorder ) , <SPC> 0 , <SPC> len ( inorder ) <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> buildTreeRecu ( self , <SPC> lookup , <SPC> postorder , <SPC> inorder , <SPC> post_end , <SPC> in_start , <SPC> in_end ) : <NL> <TAB> if <SPC> in_start <SPC> == <SPC> in_end : <NL>          return <SPC> None <NL> <TAB> node <SPC> = <SPC> TreeNode ( postorder [ post_end <SPC> - <SPC> 1 ] ) <NL> <TAB> i <SPC> = <SPC> lookup [ postorder [ post_end <SPC> - <SPC> 1 ] ] <NL> <TAB> node . left <SPC> = <SPC> self . buildTreeRecu ( <NL>          lookup , <SPC> postorder , <SPC> inorder , <SPC> post_end <SPC> - <NL>          1 <SPC> - <SPC> ( in_end <SPC> - <SPC> i <SPC> - <SPC> 1 ) , <SPC> in_start , <SPC> i <NL> <TAB> ) <NL> <TAB> node . right <SPC> = <SPC> self . buildTreeRecu ( <NL>          lookup , <SPC> postorder , <SPC> inorder , <SPC> post_end <SPC> - <SPC> 1 , <SPC> i <SPC> + <SPC> 1 , <SPC> in_end <NL> <TAB> ) <NL> <TAB> return <SPC> node <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> buildTree ( self , <SPC> preorder , <SPC> inorder ) : <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( inorder ) : <NL>          lookup [ num ] <SPC> = <SPC> i <NL> <TAB> return <SPC> self . buildTreeRecu ( lookup , <SPC> preorder , <SPC> inorder , <SPC> 0 , <SPC> 0 , <SPC> len ( inorder ) ) <NL> <NL> <TAB> def <SPC> buildTreeRecu ( self , <SPC> lookup , <SPC> preorder , <SPC> inorder , <SPC> pre_start , <SPC> in_start , <SPC> in_end ) : <NL> <TAB> if <SPC> in_start <SPC> == <SPC> in_end : <NL>          return <SPC> None <NL> <TAB> node <SPC> = <SPC> TreeNode ( preorder [ pre_start ] ) <NL> <TAB> i <SPC> = <SPC> lookup [ preorder [ pre_start ] ] <NL> <TAB> node . left <SPC> = <SPC> self . buildTreeRecu ( <NL>          lookup , <SPC> preorder , <SPC> inorder , <SPC> pre_start <SPC> + <SPC> 1 , <SPC> in_start , <SPC> i <NL> <TAB> ) <NL> <TAB> node . right <SPC> = <SPC> self . buildTreeRecu ( <NL>          lookup , <SPC> preorder , <SPC> inorder , <SPC> pre_start <SPC> + <SPC> 1 <SPC> + <SPC> i <SPC> - <SPC> in_start , <SPC> i <SPC> + <SPC> 1 , <SPC> in_end <NL> <TAB> ) <NL> <TAB> return <SPC> node <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> buildTree ( self , <SPC> preorder , <SPC> inorder ) : <NL> <NL> <TAB> preorder_iterator <SPC> = <SPC> iter ( preorder ) <NL> <TAB> inorder_lookup <SPC> = <SPC> { n : <SPC> i <SPC> for <SPC> i , <SPC> n <SPC> in <SPC> enumerate ( inorder ) } <NL> <NL> <TAB> def <SPC> helper ( start , <SPC> end ) : <NL>          if <SPC> start <SPC> > <SPC> end : <NL>              return <SPC> None <NL> <NL>          root_val <SPC> = <SPC> next ( preorder_iterator ) <NL>          root <SPC> = <SPC> TreeNode ( root_val ) <NL>          idx <SPC> = <SPC> inorder_lookup [ root_val ] <NL>          root . left <SPC> = <SPC> helper ( start , <SPC> idx <SPC> - <SPC> 1 ) <NL>          root . right <SPC> = <SPC> helper ( idx <SPC> + <SPC> 1 , <SPC> end ) <NL>          return <SPC> root <NL> <NL> <TAB> return <SPC> helper ( 0 , <SPC> len ( inorder ) <SPC> - <SPC> 1 ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> constructFromPrePost ( self , <SPC> pre , <SPC> post ) : <NL> <NL> <TAB> stack <SPC> = <SPC> [ TreeNode ( pre [ 0 ] ) ] <NL> <TAB> j <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pre ) ) : <NL>          node <SPC> = <SPC> TreeNode ( pre [ i ] ) <NL>          while <SPC> stack [ - 1 ] . val <SPC> == <SPC> post [ j ] : <NL>              stack . pop ( ) <NL>              j <SPC> += <SPC> 1 <NL>          if <SPC> not <SPC> stack [ - 1 ] . left : <NL>              stack [ - 1 ] . left <SPC> = <SPC> node <NL>          else : <NL>              stack [ - 1 ] . right <SPC> = <SPC> node <NL>          stack . append ( node ) <NL> <TAB> return <SPC> stack [ 0 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> constructFromPrePost ( self , <SPC> pre , <SPC> post ) : <NL> <NL> <TAB> def <SPC> constructFromPrePostHelper ( <NL>          pre , <SPC> pre_s , <SPC> pre_e , <SPC> post , <SPC> post_s , <SPC> post_e , <SPC> post_entry_idx_map <NL> <TAB> ) : <NL>          if <SPC> pre_s <SPC> >= <SPC> pre_e <SPC> or <SPC> post_s <SPC> >= <SPC> post_e : <NL>              return <SPC> None <NL>          node <SPC> = <SPC> TreeNode ( pre [ pre_s ] ) <NL>          if <SPC> pre_e <SPC> - <SPC> pre_s <SPC> > <SPC> 1 : <NL>              left_tree_size <SPC> = <SPC> post_entry_idx_map [ pre [ pre_s <SPC> + <SPC> 1 ] ] <SPC> - <SPC> post_s <SPC> + <SPC> 1 <NL>              node . left <SPC> = <SPC> constructFromPrePostHelper ( <NL>                  pre , <NL>                  pre_s <SPC> + <SPC> 1 , <NL>                  pre_s <SPC> + <SPC> 1 <SPC> + <SPC> left_tree_size , <NL>                  post , <NL>                  post_s , <NL>                  post_s <SPC> + <SPC> left_tree_size , <NL>                  post_entry_idx_map , <NL>              ) <NL>              node . right <SPC> = <SPC> constructFromPrePostHelper ( <NL>                  pre , <NL>                  pre_s <SPC> + <SPC> 1 <SPC> + <SPC> left_tree_size , <NL>                  pre_e , <NL>                  post , <NL>                  post_s <SPC> + <SPC> left_tree_size , <NL>                  post_e <SPC> - <SPC> 1 , <NL>                  post_entry_idx_map , <NL>              ) <NL>          return <SPC> node <NL> <NL> <TAB> post_entry_idx_map <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> val <SPC> in <SPC> enumerate ( post ) : <NL>          post_entry_idx_map [ val ] <SPC> = <SPC> i <NL> <TAB> return <SPC> constructFromPrePostHelper ( <NL>          pre , <SPC> 0 , <SPC> len ( pre ) , <SPC> post , <SPC> 0 , <SPC> len ( post ) , <SPC> post_entry_idx_map <NL> <TAB> ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> str2tree ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> str2treeHelper ( s , <SPC> i ) : <NL>          start <SPC> = <SPC> i <NL>          if <SPC> s [ i ] <SPC> == <SPC> "-" : <NL>              i <SPC> += <SPC> 1 <NL>          while <SPC> i <SPC> < <SPC> len ( s ) <SPC> and <SPC> s [ i ] . isdigit ( ) : <NL>              i <SPC> += <SPC> 1 <NL>          node <SPC> = <SPC> TreeNode ( int ( s [ start : i ] ) ) <NL>          if <SPC> i <SPC> < <SPC> len ( s ) <SPC> and <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>              i <SPC> += <SPC> 1 <NL>              node . left , <SPC> i <SPC> = <SPC> str2treeHelper ( s , <SPC> i ) <NL>              i <SPC> += <SPC> 1 <NL>          if <SPC> i <SPC> < <SPC> len ( s ) <SPC> and <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>              i <SPC> += <SPC> 1 <NL>              node . right , <SPC> i <SPC> = <SPC> str2treeHelper ( s , <SPC> i ) <NL>              i <SPC> += <SPC> 1 <NL>          return <SPC> node , <SPC> i <NL> <NL> <TAB> return <SPC> str2treeHelper ( s , <SPC> 0 ) [ 0 ] <SPC> if <SPC> s <SPC> else <SPC> None <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canConstruct ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( s ) <NL> <TAB> odd <SPC> = <SPC> sum ( v <SPC> % <SPC> 2 <SPC> for <SPC> v <SPC> in <SPC> count . itervalues ( ) ) <NL> <TAB> return <SPC> odd <SPC> <= <SPC> k <SPC> <= <SPC> len ( s ) <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> isLeaf , <SPC> topLeft , <SPC> topRight , <SPC> bottomLeft , <SPC> bottomRight ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . isLeaf <SPC> = <SPC> isLeaf <NL> <TAB> self . topLeft <SPC> = <SPC> topLeft <NL> <TAB> self . topRight <SPC> = <SPC> topRight <NL> <TAB> self . bottomLeft <SPC> = <SPC> bottomLeft <NL> <TAB> self . bottomRight <SPC> = <SPC> bottomRight <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> construct ( self , <SPC> grid ) : <NL> <NL> <TAB> def <SPC> dfs ( grid , <SPC> x , <SPC> y , <SPC> l ) : <NL>          if <SPC> l <SPC> == <SPC> 1 : <NL>              return <SPC> Node ( grid [ x ] [ y ] <SPC> == <SPC> 1 , <SPC> True , <SPC> None , <SPC> None , <SPC> None , <SPC> None ) <NL>          half <SPC> = <SPC> l <SPC> // <SPC> 2 <NL>          topLeftNode <SPC> = <SPC> dfs ( grid , <SPC> x , <SPC> y , <SPC> half ) <NL>          topRightNode <SPC> = <SPC> dfs ( grid , <SPC> x , <SPC> y <SPC> + <SPC> half , <SPC> half ) <NL>          bottomLeftNode <SPC> = <SPC> dfs ( grid , <SPC> x <SPC> + <SPC> half , <SPC> y , <SPC> half ) <NL>          bottomRightNode <SPC> = <SPC> dfs ( grid , <SPC> x <SPC> + <SPC> half , <SPC> y <SPC> + <SPC> half , <SPC> half ) <NL>          if <SPC> ( <NL>              topLeftNode . isLeaf <NL>              and <SPC> topRightNode . isLeaf <NL>              and <SPC> bottomLeftNode . isLeaf <NL>              and <SPC> bottomRightNode . isLeaf <NL>              and <SPC> topLeftNode . val <NL>              == <SPC> topRightNode . val <NL>              == <SPC> bottomLeftNode . val <NL>              == <SPC> bottomRightNode . val <NL>          ) : <NL>              return <SPC> Node ( topLeftNode . val , <SPC> True , <SPC> None , <SPC> None , <SPC> None , <SPC> None ) <NL>          return <SPC> Node ( <NL>              True , <SPC> False , <SPC> topLeftNode , <SPC> topRightNode , <SPC> bottomLeftNode , <SPC> bottomRightNode <NL>          ) <NL> <NL> <TAB> if <SPC> not <SPC> grid : <NL>          return <SPC> None <NL> <TAB> return <SPC> dfs ( grid , <SPC> 0 , <SPC> 0 , <SPC> len ( grid ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> tree2str ( self , <SPC> t ) : <NL> <NL> <TAB> if <SPC> not <SPC> t : <NL>          return <SPC> "" <NL> <TAB> s <SPC> = <SPC> str ( t . val ) <NL> <TAB> if <SPC> t . left <SPC> or <SPC> t . right : <NL>          s <SPC> += <SPC> "(" <SPC> + <SPC> self . tree2str ( t . left ) <SPC> + <SPC> ")" <NL> <TAB> if <SPC> t . right : <NL>          s <SPC> += <SPC> "(" <SPC> + <SPC> self . tree2str ( t . right ) <SPC> + <SPC> ")" <NL> <TAB> return <SPC> s <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPossible ( self , <SPC> target ) : <NL> <NL> <TAB> total <SPC> = <SPC> sum ( target ) <NL> <TAB> max_heap <SPC> = <SPC> [ - x <SPC> for <SPC> x <SPC> in <SPC> target ] <NL> <TAB> heapq . heapify ( max_heap ) <NL> <TAB> while <SPC> total <SPC> != <SPC> len ( target ) : <NL>          y <SPC> = <SPC> - heapq . heappop ( max_heap ) <NL>          remain <SPC> = <SPC> total <SPC> - <SPC> y <NL>          x <SPC> = <SPC> y <SPC> - <SPC> remain <NL>          if <SPC> x <SPC> <= <SPC> 0 : <NL>              return <SPC> False <NL>          if <SPC> x <SPC> > <SPC> remain : <NL>              x <SPC> = <SPC> x <SPC> % <SPC> remain <SPC> + <SPC> remain <NL>          heapq . heappush ( max_heap , <SPC> - x ) <NL>          total <SPC> = <SPC> x <SPC> + <SPC> remain <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> constructDistancedSequence ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> backtracking ( n , <SPC> i , <SPC> result , <SPC> lookup ) : <NL>          if <SPC> i <SPC> == <SPC> len ( result ) : <NL>              return <SPC> True <NL>          if <SPC> result [ i ] : <NL>              return <SPC> backtracking ( n , <SPC> i <SPC> + <SPC> 1 , <SPC> result , <SPC> lookup ) <NL>          for <SPC> x <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) ) : <NL>              j <SPC> = <SPC> i <SPC> if <SPC> x <SPC> == <SPC> 1 <SPC> else <SPC> i <SPC> + <SPC> x <NL>              if <SPC> lookup [ x ] <SPC> or <SPC> j <SPC> >= <SPC> len ( result ) <SPC> or <SPC> result [ j ] : <NL>                  continue <NL>              result [ i ] , <SPC> result [ j ] , <SPC> lookup [ x ] <SPC> = <SPC> x , <SPC> x , <SPC> True <NL>              if <SPC> backtracking ( n , <SPC> i <SPC> + <SPC> 1 , <SPC> result , <SPC> lookup ) : <NL>                  return <SPC> True <NL>              result [ i ] , <SPC> result [ j ] , <SPC> lookup [ x ] <SPC> = <SPC> 0 , <SPC> 0 , <SPC> False <NL>          return <SPC> False <NL> <NL> <TAB> result , <SPC> lookup <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 2 <SPC> * <SPC> n <SPC> - <SPC> 1 ) , <SPC> [ False ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> backtracking ( n , <SPC> 0 , <SPC> result , <SPC> lookup ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> constructRectangle ( self , <SPC> area ) : <NL> <NL> <TAB> w <SPC> = <SPC> int ( math . sqrt ( area ) ) <NL> <TAB> while <SPC> area <SPC> % <SPC> w : <NL>          w <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> [ area <SPC> // <SPC> w , <SPC> w ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> containVirus ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> dfs ( grid , <SPC> r , <SPC> c , <SPC> lookup , <SPC> regions , <SPC> frontiers , <SPC> perimeters ) : <NL>          if <SPC> ( r , <SPC> c ) <SPC> in <SPC> lookup : <NL>              return <NL>          lookup . add ( ( r , <SPC> c ) ) <NL>          regions [ - 1 ] . add ( ( r , <SPC> c ) ) <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> d [ 0 ] , <SPC> c <SPC> + <SPC> d [ 1 ] <NL>              if <SPC> not <SPC> ( 0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ r ] ) ) : <NL>                  continue <NL>              if <SPC> grid [ nr ] [ nc ] <SPC> == <SPC> 1 : <NL>                  dfs ( grid , <SPC> nr , <SPC> nc , <SPC> lookup , <SPC> regions , <SPC> frontiers , <SPC> perimeters ) <NL>              elif <SPC> grid [ nr ] [ nc ] <SPC> == <SPC> 0 : <NL>                  frontiers [ - 1 ] . add ( ( nr , <SPC> nc ) ) <NL>                  perimeters [ - 1 ] <SPC> += <SPC> 1 <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> True : <NL>          lookup , <SPC> regions , <SPC> frontiers , <SPC> perimeters <SPC> = <SPC> set ( ) , <SPC> [ ] , <SPC> [ ] , <SPC> [ ] <NL>          for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( grid ) : <NL>              for <SPC> c , <SPC> val <SPC> in <SPC> enumerate ( row ) : <NL>                  if <SPC> val <SPC> == <SPC> 1 <SPC> and <SPC> ( r , <SPC> c ) <SPC> not <SPC> in <SPC> lookup : <NL>                      regions . append ( set ( ) ) <NL>                      frontiers . append ( set ( ) ) <NL>                      perimeters . append ( 0 ) <NL>                      dfs ( grid , <SPC> r , <SPC> c , <SPC> lookup , <SPC> regions , <SPC> frontiers , <SPC> perimeters ) <NL> <NL>          if <SPC> not <SPC> regions : <NL>              break <NL> <NL>          triage_idx <SPC> = <SPC> frontiers . index ( max ( frontiers , <SPC> key = len ) ) <NL>          for <SPC> i , <SPC> region <SPC> in <SPC> enumerate ( regions ) : <NL>              if <SPC> i <SPC> == <SPC> triage_idx : <NL>                  result <SPC> += <SPC> perimeters [ i ] <NL>                  for <SPC> r , <SPC> c <SPC> in <SPC> region : <NL>                      grid [ r ] [ c ] <SPC> = <SPC> - 1 <NL>                  continue <NL>              for <SPC> r , <SPC> c <SPC> in <SPC> region : <NL>                  for <SPC> d <SPC> in <SPC> directions : <NL>                      nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> d [ 0 ] , <SPC> c <SPC> + <SPC> d [ 1 ] <NL>                      if <SPC> not <SPC> ( 0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ r ] ) ) : <NL>                          continue <NL>                      if <SPC> grid [ nr ] [ nc ] <SPC> == <SPC> 0 : <NL>                          grid [ nr ] [ nc ] <SPC> = <SPC> 1 <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maxArea ( self , <SPC> height ) : <NL> <TAB> max_area , <SPC> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 , <SPC> len ( height ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> j : <NL>          max_area <SPC> = <SPC> max ( max_area , <SPC> min ( height [ i ] , <SPC> height [ j ] ) <SPC> * <SPC> ( j <SPC> - <SPC> i ) ) <NL>          if <SPC> height [ i ] <SPC> < <SPC> height [ j ] : <NL>              i <SPC> += <SPC> 1 <NL>          else : <NL>              j <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> max_area <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> containsNearbyDuplicate ( self , <SPC> nums , <SPC> k ) : <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          if <SPC> num <SPC> not <SPC> in <SPC> lookup : <NL>              lookup [ num ] <SPC> = <SPC> i <NL>          else : <NL> <NL>              if <SPC> i <SPC> - <SPC> lookup [ num ] <SPC> <= <SPC> k : <NL>                  return <SPC> True <NL> <NL>              lookup [ num ] <SPC> = <SPC> i <NL> <TAB> return <SPC> False <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> containsNearbyAlmostDuplicate ( self , <SPC> nums , <SPC> k , <SPC> t ) : <NL> <TAB> if <SPC> k <SPC> < <SPC> 0 <SPC> or <SPC> t <SPC> < <SPC> 0 : <NL>          return <SPC> False <NL> <TAB> window <SPC> = <SPC> collections . OrderedDict ( ) <NL> <TAB> for <SPC> n <SPC> in <SPC> nums : <NL> <NL>          if <SPC> len ( window ) <SPC> > <SPC> k : <NL>              window . popitem ( False ) <NL> <NL>          bucket <SPC> = <SPC> n <SPC> if <SPC> not <SPC> t <SPC> else <SPC> n <SPC> // <SPC> t <NL> <NL>          for <SPC> m <SPC> in <SPC> ( <NL>              window . get ( bucket <SPC> - <SPC> 1 ) , <NL>              window . get ( bucket ) , <NL>              window . get ( bucket <SPC> + <SPC> 1 ) , <NL>          ) : <NL>              if <SPC> m <SPC> is <SPC> not <SPC> None <SPC> and <SPC> abs ( n <SPC> - <SPC> m ) <SPC> <= <SPC> t : <NL>                  return <SPC> True <NL>          window [ bucket ] <SPC> = <SPC> n <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> containsDuplicate ( self , <SPC> nums ) : <NL> <TAB> return <SPC> len ( nums ) <SPC> > <SPC> len ( set ( nums ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMaxLength ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> count <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> { 0 : <SPC> - 1 } <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          count <SPC> += <SPC> 1 <SPC> if <SPC> num <SPC> == <SPC> 1 <SPC> else <SPC> - 1 <NL>          if <SPC> count <SPC> in <SPC> lookup : <NL>              result <SPC> = <SPC> max ( result , <SPC> i <SPC> - <SPC> lookup [ count ] ) <NL>          else : <NL>              lookup [ count ] <SPC> = <SPC> i <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkSubarraySum ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> { 0 : <SPC> - 1 } <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          count <SPC> += <SPC> num <NL>          if <SPC> k : <NL>              count <SPC> %= <SPC> k <NL>          if <SPC> count <SPC> in <SPC> lookup : <NL>              if <SPC> i <SPC> - <SPC> lookup [ count ] <SPC> > <SPC> 1 : <NL>                  return <SPC> True <NL>          else : <NL>              lookup [ count ] <SPC> = <SPC> i <NL> <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> toHex ( self , <SPC> num ) : <NL> <NL> <TAB> if <SPC> not <SPC> num : <NL>          return <SPC> "0" <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> num <SPC> and <SPC> len ( result ) <SPC> != <SPC> 8 : <NL>          h <SPC> = <SPC> num <SPC> & <SPC> 15 <NL>          if <SPC> h <SPC> < <SPC> 10 : <NL>              result . append ( str ( chr ( ord ( "0" ) <SPC> + <SPC> h ) ) ) <NL>          else : <NL>              result . append ( str ( chr ( ord ( "a" ) <SPC> + <SPC> h <SPC> - <SPC> 10 ) ) ) <NL>          num <SPC> >>= <SPC> 4 <NL> <TAB> result . reverse ( ) <NL> <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getDecimalValue ( self , <SPC> head ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> head : <NL>          result <SPC> = <SPC> result <SPC> * <SPC> 2 <SPC> + <SPC> head . val <NL>          head <SPC> = <SPC> head . next <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> left , <SPC> right ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> treeToDoublyList ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> None <NL> <TAB> left_head , <SPC> left_tail , <SPC> right_head , <SPC> right_tail <SPC> = <SPC> root , <SPC> root , <SPC> root , <SPC> root <NL> <TAB> if <SPC> root . left : <NL>          left_head <SPC> = <SPC> self . treeToDoublyList ( root . left ) <NL>          left_tail <SPC> = <SPC> left_head . left <NL> <TAB> if <SPC> root . right : <NL>          right_head <SPC> = <SPC> self . treeToDoublyList ( root . right ) <NL>          right_tail <SPC> = <SPC> right_head . left <NL> <TAB> left_tail . right , <SPC> right_head . left <SPC> = <SPC> root , <SPC> root <NL> <TAB> root . left , <SPC> root . right <SPC> = <SPC> left_tail , <SPC> right_head <NL> <TAB> left_head . left , <SPC> right_tail . right <SPC> = <SPC> right_tail , <SPC> left_head <NL> <TAB> return <SPC> left_head <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> convertBST ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> convertBSTHelper ( root , <SPC> cur_sum ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> cur_sum <NL> <NL>          if <SPC> root . right : <NL>              cur_sum <SPC> = <SPC> convertBSTHelper ( root . right , <SPC> cur_sum ) <NL>          cur_sum <SPC> += <SPC> root . val <NL>          root . val <SPC> = <SPC> cur_sum <NL>          if <SPC> root . left : <NL>              cur_sum <SPC> = <SPC> convertBSTHelper ( root . left , <SPC> cur_sum ) <NL>          return <SPC> cur_sum <NL> <NL> <TAB> convertBSTHelper ( root , <SPC> 0 ) <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getNoZeroIntegers ( self , <SPC> n ) : <NL> <NL> <TAB> a , <SPC> curr , <SPC> base <SPC> = <SPC> 0 , <SPC> n , <SPC> 1 <NL> <TAB> while <SPC> curr : <NL>          if <SPC> curr <SPC> % <SPC> 10 <SPC> == <SPC> 0 <SPC> or <SPC> ( curr <SPC> % <SPC> 10 <SPC> == <SPC> 1 <SPC> and <SPC> curr <SPC> != <SPC> 1 ) : <NL>              a <SPC> += <SPC> base <NL>              curr <SPC> -= <SPC> 10 <NL>          a <SPC> += <SPC> base <NL>          base <SPC> *= <SPC> 10 <NL>          curr <SPC> //= <SPC> 10 <NL> <TAB> return <SPC> [ a , <SPC> n <SPC> - <SPC> a ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> getNoZeroIntegers ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> next ( <NL>          [ a , <SPC> n <SPC> - <SPC> a ] <SPC> for <SPC> a <SPC> in <SPC> xrange ( 1 , <SPC> n ) <SPC> if <SPC> "0" <SPC> not <SPC> in <SPC> "{}{}" . format ( a , <SPC> n <SPC> - <SPC> a ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sortedArrayToBST ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> self . sortedArrayToBSTRecu ( nums , <SPC> 0 , <SPC> len ( nums ) ) <NL> <NL> <TAB> def <SPC> sortedArrayToBSTRecu ( self , <SPC> nums , <SPC> start , <SPC> end ) : <NL> <TAB> if <SPC> start <SPC> == <SPC> end : <NL>          return <SPC> None <NL> <TAB> mid <SPC> = <SPC> start <SPC> + <SPC> self . perfect_tree_pivot ( end <SPC> - <SPC> start ) <NL> <TAB> node <SPC> = <SPC> TreeNode ( nums [ mid ] ) <NL> <TAB> node . left <SPC> = <SPC> self . sortedArrayToBSTRecu ( nums , <SPC> start , <SPC> mid ) <NL> <TAB> node . right <SPC> = <SPC> self . sortedArrayToBSTRecu ( nums , <SPC> mid <SPC> + <SPC> 1 , <SPC> end ) <NL> <TAB> return <SPC> node <NL> <NL> <TAB> def <SPC> perfect_tree_pivot ( self , <SPC> n ) : <NL> <NL> <TAB> x <SPC> = <SPC> 1 <NL> <NL> <TAB> x <SPC> = <SPC> 1 <SPC> << <SPC> ( <NL>          n . bit_length ( ) <SPC> - <SPC> 1 <NL> <TAB> ) <NL> <NL> <TAB> if <SPC> x <SPC> // <SPC> 2 <SPC> - <SPC> 1 <SPC> <= <SPC> ( n <SPC> - <SPC> x ) : <NL>          return <SPC> ( <NL>              x <SPC> - <SPC> 1 <NL>          ) <NL> <TAB> else : <NL>          return <SPC> ( <NL>              n <SPC> - <SPC> x <SPC> // <SPC> 2 <NL>          ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> sortedArrayToBST ( self , <SPC> nums ) : <NL> <NL> <TAB> self . iterator <SPC> = <SPC> iter ( nums ) <NL> <TAB> return <SPC> self . helper ( 0 , <SPC> len ( nums ) ) <NL> <NL> <TAB> def <SPC> helper ( self , <SPC> start , <SPC> end ) : <NL> <TAB> if <SPC> start <SPC> == <SPC> end : <NL>          return <SPC> None <NL> <NL> <TAB> mid <SPC> = <SPC> ( start <SPC> + <SPC> end ) <SPC> // <SPC> 2 <NL> <TAB> left <SPC> = <SPC> self . helper ( start , <SPC> mid ) <NL> <TAB> current <SPC> = <SPC> TreeNode ( next ( self . iterator ) ) <NL> <TAB> current . left <SPC> = <SPC> left <NL> <TAB> current . right <SPC> = <SPC> self . helper ( mid <SPC> + <SPC> 1 , <SPC> end ) <NL> <TAB> return <SPC> current <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> head <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> sortedListToBST ( self , <SPC> head ) : <NL> <TAB> current , <SPC> length <SPC> = <SPC> head , <SPC> 0 <NL> <TAB> while <SPC> current <SPC> is <SPC> not <SPC> None : <NL>          current , <SPC> length <SPC> = <SPC> current . next , <SPC> length <SPC> + <SPC> 1 <NL> <TAB> self . head <SPC> = <SPC> head <NL> <TAB> return <SPC> self . sortedListToBSTRecu ( 0 , <SPC> length ) <NL> <NL> <TAB> def <SPC> sortedListToBSTRecu ( self , <SPC> start , <SPC> end ) : <NL> <TAB> if <SPC> start <SPC> == <SPC> end : <NL>          return <SPC> None <NL> <TAB> mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> / <SPC> 2 <NL> <TAB> left <SPC> = <SPC> self . sortedListToBSTRecu ( start , <SPC> mid ) <NL> <TAB> current <SPC> = <SPC> TreeNode ( self . head . val ) <NL> <TAB> current . left <SPC> = <SPC> left <NL> <TAB> self . head <SPC> = <SPC> self . head . next <NL> <TAB> current . right <SPC> = <SPC> self . sortedListToBSTRecu ( mid <SPC> + <SPC> 1 , <SPC> end ) <NL> <TAB> return <SPC> current <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> baseNeg2 ( self , <SPC> N ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> N : <NL>          result . append ( str ( - N <SPC> & <SPC> 1 ) ) <NL>          N <SPC> = <SPC> - ( N <SPC> >> <SPC> 1 ) <NL> <TAB> result . reverse ( ) <NL> <TAB> return <SPC> "" . join ( result ) <SPC> if <SPC> result <SPC> else <SPC> "0" <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> baseNeg2 ( self , <SPC> N ) : <NL> <NL> <TAB> BASE <SPC> = <SPC> - 2 <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> N : <NL>          N , <SPC> r <SPC> = <SPC> divmod ( N , <SPC> BASE ) <NL>          if <SPC> r <SPC> < <SPC> 0 : <NL>              r <SPC> -= <SPC> BASE <NL>              N <SPC> += <SPC> 1 <NL>          result . append ( str ( r ) ) <NL> <TAB> result . reverse ( ) <NL> <TAB> return <SPC> "" . join ( result ) <SPC> if <SPC> result <SPC> else <SPC> "0" <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isConvex ( self , <SPC> points ) : <NL> <NL> <TAB> def <SPC> det ( A ) : <NL>          return <SPC> A [ 0 ] [ 0 ] <SPC> * <SPC> A [ 1 ] [ 1 ] <SPC> - <SPC> A [ 0 ] [ 1 ] <SPC> * <SPC> A [ 1 ] [ 0 ] <NL> <NL> <TAB> n , <SPC> prev , <SPC> curr <SPC> = <SPC> len ( points ) , <SPC> 0 , <SPC> None <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( points ) ) : <NL>          A <SPC> = <SPC> [ <NL>              [ <NL>                  points [ ( i <SPC> + <SPC> j ) <SPC> % <SPC> n ] [ 0 ] <SPC> - <SPC> points [ i ] [ 0 ] , <NL>                  points [ ( i <SPC> + <SPC> j ) <SPC> % <SPC> n ] [ 1 ] <SPC> - <SPC> points [ i ] [ 1 ] , <NL>              ] <NL>              for <SPC> j <SPC> in <SPC> ( 1 , <SPC> 2 ) <NL>          ] <NL>          curr <SPC> = <SPC> det ( A ) <NL>          if <SPC> curr : <NL>              if <SPC> curr <SPC> * <SPC> prev <SPC> < <SPC> 0 : <NL>                  return <SPC> False <NL>              prev <SPC> = <SPC> curr <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> bestCoordinate ( self , <SPC> towers , <SPC> radius ) : <NL> <NL> <TAB> min_x <SPC> = <SPC> min ( towers , <SPC> key = lambda <SPC> x : <SPC> x [ 0 ] ) [ 0 ] <NL> <TAB> max_x <SPC> = <SPC> max ( towers , <SPC> key = lambda <SPC> x : <SPC> x [ 0 ] ) [ 0 ] <NL> <TAB> min_y <SPC> = <SPC> min ( towers , <SPC> key = lambda <SPC> x : <SPC> x [ 1 ] ) [ 1 ] <NL> <TAB> max_y <SPC> = <SPC> max ( towers , <SPC> key = lambda <SPC> x : <SPC> x [ 1 ] ) [ 1 ] <NL> <TAB> max_quality <SPC> = <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> xrange ( min_x , <SPC> max_x <SPC> + <SPC> 1 ) : <NL>          for <SPC> y <SPC> in <SPC> xrange ( min_y , <SPC> max_y <SPC> + <SPC> 1 ) : <NL>              q <SPC> = <SPC> 0 <NL>              for <SPC> nx , <SPC> ny , <SPC> nq <SPC> in <SPC> towers : <NL>                  d <SPC> = <SPC> ( ( nx <SPC> - <SPC> x ) <SPC> ** <SPC> 2 <SPC> + <SPC> ( ny <SPC> - <SPC> y ) <SPC> ** <SPC> 2 ) <SPC> ** <SPC> 0.5 <NL>                  if <SPC> d <SPC> <= <SPC> radius : <NL>                      q <SPC> += <SPC> int ( nq <SPC> / <SPC> ( 1 <SPC> + <SPC> d ) ) <NL>              if <SPC> q <SPC> > <SPC> max_quality : <NL>                  max_quality <SPC> = <SPC> q <NL>                  result <SPC> = <SPC> x , <SPC> y <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <TAB> self . random <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> copyRandomList ( self , <SPC> head ) : <NL> <NL> <TAB> current <SPC> = <SPC> head <NL> <TAB> while <SPC> current : <NL>          copied <SPC> = <SPC> Node ( current . val ) <NL>          copied . next <SPC> = <SPC> current . next <NL>          current . next <SPC> = <SPC> copied <NL>          current <SPC> = <SPC> copied . next <NL> <NL> <TAB> current <SPC> = <SPC> head <NL> <TAB> while <SPC> current : <NL>          if <SPC> current . random : <NL>              current . next . random <SPC> = <SPC> current . random . next <NL>          current <SPC> = <SPC> current . next . next <NL> <NL> <TAB> dummy <SPC> = <SPC> Node ( 0 ) <NL> <TAB> copied_current , <SPC> current <SPC> = <SPC> dummy , <SPC> head <NL> <TAB> while <SPC> current : <NL>          copied_current . next <SPC> = <SPC> current . next <NL>          current . next <SPC> = <SPC> current . next . next <NL>          copied_current , <SPC> current <SPC> = <SPC> copied_current . next , <SPC> current . next <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> copyRandomList ( self , <SPC> head ) : <NL> <TAB> dummy <SPC> = <SPC> Node ( 0 ) <NL> <TAB> current , <SPC> prev , <SPC> copies <SPC> = <SPC> head , <SPC> dummy , <SPC> { } <NL> <NL> <TAB> while <SPC> current : <NL>          copied <SPC> = <SPC> Node ( current . val ) <NL>          copies [ current ] <SPC> = <SPC> copied <NL>          prev . next <SPC> = <SPC> copied <NL>          prev , <SPC> current <SPC> = <SPC> prev . next , <SPC> current . next <NL> <NL> <TAB> current <SPC> = <SPC> head <NL> <TAB> while <SPC> current : <NL>          if <SPC> current . random : <NL>              copies [ current ] . random <SPC> = <SPC> copies [ current . random ] <NL>          current <SPC> = <SPC> current . next <NL> <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> defaultdict <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> copyRandomList ( self , <SPC> head ) : <NL> <NL> <TAB> clone <SPC> = <SPC> defaultdict ( lambda : <SPC> Node ( 0 ) ) <NL> <TAB> clone [ None ] <SPC> = <SPC> None <NL> <TAB> cur <SPC> = <SPC> head <NL> <NL> <TAB> while <SPC> cur : <NL>          clone [ cur ] . val <SPC> = <SPC> cur . val <NL>          clone [ cur ] . next <SPC> = <SPC> clone [ cur . next ] <NL>          clone [ cur ] . random <SPC> = <SPC> clone [ cur . random ] <NL>          cur <SPC> = <SPC> cur . next <NL> <NL> <TAB> return <SPC> clone [ head ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> corpFlightBookings ( self , <SPC> bookings , <SPC> n ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i , <SPC> j , <SPC> k <SPC> in <SPC> bookings : <NL>          result [ i <SPC> - <SPC> 1 ] <SPC> += <SPC> k <NL>          result [ j ] <SPC> -= <SPC> k <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( result ) ) : <NL>          result [ i ] <SPC> += <SPC> result [ i <SPC> - <SPC> 1 ] <NL> <TAB> result . pop ( ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> correctBinaryTree ( self , <SPC> root ) : <NL> <NL> <TAB> q <SPC> = <SPC> { root : <SPC> None } <NL> <TAB> while <SPC> q : <NL>          new_q <SPC> = <SPC> { } <NL>          for <SPC> node , <SPC> parent <SPC> in <SPC> q . iteritems ( ) : <NL>              if <SPC> node . right <SPC> in <SPC> q : <NL>                  if <SPC> parent . left <SPC> == <SPC> node : <NL>                      parent . left <SPC> = <SPC> None <NL>                  else : <NL>                      parent . right <SPC> = <SPC> None <NL>                  return <SPC> root <NL>              if <SPC> node . left : <NL>                  new_q [ node . left ] <SPC> = <SPC> node <NL>              if <SPC> node . right : <NL>                  new_q [ node . right ] <SPC> = <SPC> node <NL>          q <SPC> = <SPC> new_q <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countRoutes ( self , <SPC> locations , <SPC> start , <SPC> finish , <SPC> fuel ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> s , <SPC> f <SPC> = <SPC> locations [ start ] , <SPC> locations [ finish ] <NL> <TAB> locations . sort ( ) <NL> <TAB> start , <SPC> finish <SPC> = <SPC> bisect . bisect_left ( locations , <SPC> s ) , <SPC> bisect . bisect_left ( <NL>          locations , <SPC> f <NL> <TAB> ) <NL> <NL> <TAB> left <SPC> = <SPC> [ <NL>          [ 0 ] <SPC> * <SPC> ( fuel <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( locations ) ) <NL> <TAB> ] <NL> <TAB> right <SPC> = <SPC> [ <NL>          [ 0 ] <SPC> * <SPC> ( fuel <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( locations ) ) <NL> <TAB> ] <NL> <TAB> for <SPC> f <SPC> in <SPC> xrange ( 1 , <SPC> fuel <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( locations ) <SPC> - <SPC> 1 ) : <NL>              d <SPC> = <SPC> locations [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> locations [ j ] <NL>              if <SPC> f <SPC> > <SPC> d : <NL> <NL>                  left [ j ] [ f ] <SPC> = <SPC> ( <NL>                      right [ j <SPC> + <SPC> 1 ] [ f <SPC> - <SPC> d ] <SPC> + <SPC> 2 <SPC> * <SPC> left [ j <SPC> + <SPC> 1 ] [ f <SPC> - <SPC> d ] <SPC> % <SPC> MOD <NL>                  ) <SPC> % <SPC> MOD <NL>              elif <SPC> f <SPC> == <SPC> d : <NL>                  left [ j ] [ f ] <SPC> = <SPC> int ( j <SPC> + <SPC> 1 <SPC> == <SPC> start ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( locations ) ) : <NL>              d <SPC> = <SPC> locations [ j ] <SPC> - <SPC> locations [ j <SPC> - <SPC> 1 ] <NL>              if <SPC> f <SPC> > <SPC> d : <NL> <NL>                  right [ j ] [ f ] <SPC> = <SPC> ( <NL>                      left [ j <SPC> - <SPC> 1 ] [ f <SPC> - <SPC> d ] <SPC> + <SPC> 2 <SPC> * <SPC> right [ j <SPC> - <SPC> 1 ] [ f <SPC> - <SPC> d ] <SPC> % <SPC> MOD <NL>                  ) <SPC> % <SPC> MOD <NL>              elif <SPC> f <SPC> == <SPC> d : <NL>                  right [ j ] [ f ] <SPC> = <SPC> int ( j <SPC> - <SPC> 1 <SPC> == <SPC> start ) <NL> <TAB> result <SPC> = <SPC> int ( start <SPC> == <SPC> finish ) <NL> <TAB> for <SPC> f <SPC> in <SPC> xrange ( 1 , <SPC> fuel <SPC> + <SPC> 1 ) : <NL>          result <SPC> = <SPC> ( ( result <SPC> + <SPC> left [ finish ] [ f ] ) <SPC> % <SPC> MOD <SPC> + <SPC> right [ finish ] [ f ] ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> countRoutes ( self , <SPC> locations , <SPC> start , <SPC> finish , <SPC> fuel ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( fuel <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( locations ) ) ] <NL> <TAB> dp [ start ] [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> f <SPC> in <SPC> xrange ( fuel <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( locations ) ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( locations ) ) : <NL>                  if <SPC> i <SPC> == <SPC> j : <NL>                      continue <NL>                  d <SPC> = <SPC> abs ( locations [ i ] <SPC> - <SPC> locations [ j ] ) <NL>                  if <SPC> f <SPC> - <SPC> d <SPC> < <SPC> 0 : <NL>                      continue <NL>                  dp [ i ] [ f ] <SPC> = <SPC> ( dp [ i ] [ f ] <SPC> + <SPC> dp [ j ] [ f <SPC> - <SPC> d ] ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> reduce ( lambda <SPC> x , <SPC> y : <SPC> ( x <SPC> + <SPC> y ) <SPC> % <SPC> MOD , <SPC> dp [ finish ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countOrders ( self , <SPC> n ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 2 , <SPC> 2 <SPC> * <SPC> n <SPC> + <SPC> 1 , <SPC> 2 ) ) : <NL>          result <SPC> = <SPC> result <SPC> * <SPC> i <SPC> * <SPC> ( i <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 <SPC> % <SPC> MOD <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> countAndSay ( self , <SPC> n ) : <NL> <TAB> seq <SPC> = <SPC> "1" <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n <SPC> - <SPC> 1 ) : <NL>          seq <SPC> = <SPC> self . getNext ( seq ) <NL> <TAB> return <SPC> seq <NL> <NL> <TAB> def <SPC> getNext ( self , <SPC> seq ) : <NL> <TAB> i , <SPC> next_seq <SPC> = <SPC> 0 , <SPC> "" <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( seq ) : <NL>          cnt <SPC> = <SPC> 1 <NL>          while <SPC> i <SPC> < <SPC> len ( seq ) <SPC> - <SPC> 1 <SPC> and <SPC> seq [ i ] <SPC> == <SPC> seq [ i <SPC> + <SPC> 1 ] : <NL>              cnt <SPC> += <SPC> 1 <NL>              i <SPC> += <SPC> 1 <NL>          next_seq <SPC> += <SPC> str ( cnt ) <SPC> + <SPC> seq [ i ] <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> next_seq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countBinarySubstrings ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> prev , <SPC> curr <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) ) : <NL>          if <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> != <SPC> s [ i ] : <NL>              result <SPC> += <SPC> min ( prev , <SPC> curr ) <NL>              prev , <SPC> curr <SPC> = <SPC> curr , <SPC> 1 <NL>          else : <NL>              curr <SPC> += <SPC> 1 <NL> <TAB> result <SPC> += <SPC> min ( prev , <SPC> curr ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countNodes ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> height ( root ) : <NL>          h <SPC> = <SPC> - 1 <NL>          while <SPC> root : <NL>              h <SPC> += <SPC> 1 <NL>              root <SPC> = <SPC> root . left <NL>          return <SPC> h <NL> <NL> <TAB> result , <SPC> h <SPC> = <SPC> 0 , <SPC> height ( root ) <NL> <TAB> while <SPC> root : <NL>          if <SPC> height ( root . right ) <SPC> == <SPC> h <SPC> - <SPC> 1 : <NL>              result <SPC> += <SPC> 2 <SPC> ** <SPC> h <NL>              root <SPC> = <SPC> root . right <NL>          else : <NL>              result <SPC> += <SPC> 2 <SPC> ** <SPC> ( h <SPC> - <SPC> 1 ) <NL>              root <SPC> = <SPC> root . left <NL>          h <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> countNodes ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> check ( node , <SPC> n ) : <NL>          base <SPC> = <SPC> 1 <NL>          while <SPC> base <SPC> <= <SPC> n : <NL>              base <SPC> <<= <SPC> 1 <NL>          base <SPC> >>= <SPC> 2 <NL> <NL>          while <SPC> base : <NL>              if <SPC> ( n <SPC> & <SPC> base ) <SPC> == <SPC> 0 : <NL>                  node <SPC> = <SPC> node . left <NL>              else : <NL>                  node <SPC> = <SPC> node . right <NL>              base <SPC> >>= <SPC> 1 <NL>          return <SPC> bool ( node ) <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> 0 <NL> <NL> <TAB> node , <SPC> level <SPC> = <SPC> root , <SPC> 0 <NL> <TAB> while <SPC> node . left : <NL>          node <SPC> = <SPC> node . left <NL>          level <SPC> += <SPC> 1 <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 2 <SPC> ** <SPC> level , <SPC> 2 <SPC> ** <SPC> ( level <SPC> + <SPC> 1 ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( root , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countPalindromicSubsequences ( self , <SPC> S ) : <NL> <NL> <TAB> def <SPC> dp ( i , <SPC> j , <SPC> prv , <SPC> nxt , <SPC> lookup ) : <NL>          if <SPC> lookup [ i ] [ j ] <SPC> is <SPC> not <SPC> None : <NL>              return <SPC> lookup [ i ] [ j ] <NL>          result <SPC> = <SPC> 1 <NL>          if <SPC> i <SPC> <= <SPC> j : <NL>              for <SPC> x <SPC> in <SPC> xrange ( 4 ) : <NL>                  i0 <SPC> = <SPC> nxt [ i ] [ x ] <NL>                  j0 <SPC> = <SPC> prv [ j ] [ x ] <NL>                  if <SPC> i <SPC> <= <SPC> i0 <SPC> <= <SPC> j : <NL>                      result <SPC> = <SPC> ( result <SPC> + <SPC> 1 ) <SPC> % <SPC> P <NL>                  if <SPC> None <SPC> < <SPC> i0 <SPC> < <SPC> j0 : <NL>                      result <SPC> = <SPC> ( result <SPC> + <SPC> dp ( i0 <SPC> + <SPC> 1 , <SPC> j0 <SPC> - <NL>                                1 , <SPC> prv , <SPC> nxt , <SPC> lookup ) ) <SPC> % <SPC> P <NL>          result <SPC> %= <SPC> P <NL>          lookup [ i ] [ j ] <SPC> = <SPC> result <NL>          return <SPC> result <NL> <NL> <TAB> prv <SPC> = <SPC> [ None ] <SPC> * <SPC> len ( S ) <NL> <TAB> nxt <SPC> = <SPC> [ None ] <SPC> * <SPC> len ( S ) <NL> <NL> <TAB> last <SPC> = <SPC> [ None ] <SPC> * <SPC> 4 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( S ) ) : <NL>          last [ ord ( S [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> i <NL>          prv [ i ] <SPC> = <SPC> tuple ( last ) <NL> <NL> <TAB> last <SPC> = <SPC> [ None ] <SPC> * <SPC> 4 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( S ) ) ) : <NL>          last [ ord ( S [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> i <NL>          nxt [ i ] <SPC> = <SPC> tuple ( last ) <NL> <NL> <TAB> P <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> lookup <SPC> = <SPC> [ [ None ] <SPC> * <SPC> len ( S ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( S ) ) ] <NL> <TAB> return <SPC> dp ( 0 , <SPC> len ( S ) <SPC> - <SPC> 1 , <SPC> prv , <SPC> nxt , <SPC> lookup ) <SPC> - <SPC> 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countPairs ( self , <SPC> deliciousness ) : <NL> <NL> <TAB> def <SPC> floor_log2_x ( x ) : <NL>          return <SPC> x . bit_length ( ) <SPC> - <SPC> 1 <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> max_pow <SPC> = <SPC> floor_log2_x ( max ( deliciousness ) ) <SPC> + <SPC> 1 <NL> <TAB> cnt <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> d <SPC> in <SPC> deliciousness : <NL>          p <SPC> = <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( max_pow <SPC> + <SPC> 1 ) : <NL>              result <SPC> = <SPC> ( result <SPC> + <SPC> cnt [ p <SPC> - <SPC> d ] ) <SPC> % <SPC> MOD <NL>              p <SPC> <<= <SPC> 1 <NL>          cnt [ d ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> goodNodes ( self , <SPC> root ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> stk <SPC> = <SPC> [ ( root , <SPC> root . val ) ] <NL> <TAB> while <SPC> stk : <NL>          node , <SPC> curr_max <SPC> = <SPC> stk . pop ( ) <NL>          if <SPC> not <SPC> node : <NL>              continue <NL>          curr_max <SPC> = <SPC> max ( curr_max , <SPC> node . val ) <NL>          result <SPC> += <SPC> int ( curr_max <SPC> <= <SPC> node . val ) <NL>          stk . append ( ( node . right , <SPC> curr_max ) ) <NL>          stk . append ( ( node . left , <SPC> curr_max ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> goodNodes ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> curr_max ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> 0 <NL>          curr_max <SPC> = <SPC> max ( curr_max , <SPC> node . val ) <NL>          return <SPC> ( <NL>              int ( curr_max <SPC> <= <SPC> node . val ) <NL>              + <SPC> dfs ( node . left , <SPC> curr_max ) <NL>              + <SPC> dfs ( node . right , <SPC> curr_max ) <NL>          ) <NL> <NL> <TAB> return <SPC> dfs ( root , <SPC> root . val ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countGoodTriplets ( self , <SPC> arr , <SPC> a , <SPC> b , <SPC> c ) : <NL> <NL> <TAB> return <SPC> sum ( <NL>          abs ( arr [ i ] <SPC> - <SPC> arr [ j ] ) <SPC> <= <SPC> a <NL>          and <SPC> abs ( arr [ j ] <SPC> - <SPC> arr [ k ] ) <SPC> <= <SPC> b <NL>          and <SPC> abs ( arr [ k ] <SPC> - <SPC> arr [ i ] ) <SPC> <= <SPC> c <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( arr ) <SPC> - <SPC> 2 ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( arr ) <SPC> - <SPC> 1 ) <NL>          for <SPC> k <SPC> in <SPC> xrange ( j <SPC> + <SPC> 1 , <SPC> len ( arr ) ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countMatches ( self , <SPC> items , <SPC> ruleKey , <SPC> ruleValue ) : <NL> <NL> <TAB> rule <SPC> = <SPC> { "type" : <SPC> 0 , <SPC> "color" : <SPC> 1 , <SPC> "name" : <SPC> 2 } <NL> <TAB> return <SPC> sum ( item [ rule [ ruleKey ] ] <SPC> == <SPC> ruleValue <SPC> for <SPC> item <SPC> in <SPC> items ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countLargestGroup ( self , <SPC> n ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> for <SPC> x <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          count [ sum ( map ( int , <SPC> str ( x ) ) ) ] <SPC> += <SPC> 1 <NL> <TAB> max_count <SPC> = <SPC> max ( count . itervalues ( ) ) <NL> <TAB> return <SPC> sum ( v <SPC> == <SPC> max_count <SPC> for <SPC> v <SPC> in <SPC> count . itervalues ( ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countNegatives ( self , <SPC> grid ) : <NL> <NL> <TAB> result , <SPC> c <SPC> = <SPC> 0 , <SPC> len ( grid [ 0 ] ) <SPC> - <SPC> 1 <NL> <TAB> for <SPC> row <SPC> in <SPC> grid : <NL>          while <SPC> c <SPC> >= <SPC> 0 <SPC> and <SPC> row [ c ] <SPC> < <SPC> 0 : <NL>              c <SPC> -= <SPC> 1 <NL>          result <SPC> += <SPC> len ( grid [ 0 ] ) <SPC> - <SPC> 1 <SPC> - <SPC> c <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countHomogenous ( self , <SPC> s ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> result <SPC> = <SPC> cnt <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> i <SPC> and <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> s [ i ] : <NL>              cnt <SPC> += <SPC> 1 <NL>          else : <NL>              cnt <SPC> = <SPC> 1 <NL>          result <SPC> = <SPC> ( result <SPC> + <SPC> cnt ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfSubarrays ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> atMost ( nums , <SPC> k ) : <NL>          result , <SPC> left , <SPC> count <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL>          for <SPC> right <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>              count <SPC> += <SPC> nums [ right ] <SPC> % <SPC> 2 <NL>              while <SPC> count <SPC> > <SPC> k : <NL>                  count <SPC> -= <SPC> nums [ left ] <SPC> % <SPC> 2 <NL>                  left <SPC> += <SPC> 1 <NL>              result <SPC> += <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> atMost ( nums , <SPC> k ) <SPC> - <SPC> atMost ( nums , <SPC> k <SPC> - <SPC> 1 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numberOfSubarrays ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> dq <SPC> = <SPC> collections . deque ( [ - 1 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> nums [ i ] <SPC> % <SPC> 2 : <NL>              dq . append ( i ) <NL>          if <SPC> len ( dq ) <SPC> > <SPC> k <SPC> + <SPC> 1 : <NL>              dq . popleft ( ) <NL>          if <SPC> len ( dq ) <SPC> == <SPC> k <SPC> + <SPC> 1 : <NL>              result <SPC> += <SPC> dq [ 1 ] <SPC> - <SPC> dq [ 0 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numTeams ( self , <SPC> rating ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( rating ) <SPC> - <SPC> 1 ) : <NL>          less , <SPC> greater <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 , <SPC> [ 0 ] <SPC> * <SPC> 2 <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( rating ) ) : <NL>              if <SPC> rating [ i ] <SPC> > <SPC> rating [ j ] : <NL>                  less [ i <SPC> < <SPC> j ] <SPC> += <SPC> 1 <NL>              if <SPC> rating [ i ] <SPC> < <SPC> rating [ j ] : <NL>                  greater [ i <SPC> < <SPC> j ] <SPC> += <SPC> 1 <NL>          result <SPC> += <SPC> less [ 0 ] <SPC> * <SPC> greater [ 1 ] <SPC> + <SPC> greater [ 0 ] <SPC> * <SPC> less [ 1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countNumbersWithUniqueDigits ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 : <NL>          return <SPC> 1 <NL> <TAB> count , <SPC> fk <SPC> = <SPC> 10 , <SPC> 9 <NL> <TAB> for <SPC> k <SPC> in <SPC> xrange ( 2 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          fk <SPC> *= <SPC> 10 <SPC> - <SPC> ( k <SPC> - <SPC> 1 ) <NL>          count <SPC> += <SPC> fk <NL> <TAB> return <SPC> count <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countOdds ( self , <SPC> low , <SPC> high ) : <NL> <NL> <TAB> return <SPC> ( high <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 <SPC> - <SPC> ( ( low <SPC> - <SPC> 1 ) <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfMatches ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> n <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countRangeSum ( self , <SPC> nums , <SPC> lower , <SPC> upper ) : <NL> <NL> <TAB> def <SPC> countAndMergeSort ( sums , <SPC> start , <SPC> end , <SPC> lower , <SPC> upper ) : <NL>          if <SPC> ( <NL>              end <SPC> - <SPC> start <SPC> <= <SPC> 1 <NL>          ) : <NL>              return <SPC> 0 <NL>          mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> / <SPC> 2 <NL>          count <SPC> = <SPC> countAndMergeSort ( <NL>              sums , <SPC> start , <SPC> mid , <SPC> lower , <SPC> upper <NL>          ) <SPC> + <SPC> countAndMergeSort ( sums , <SPC> mid , <SPC> end , <SPC> lower , <SPC> upper ) <NL>          j , <SPC> k , <SPC> r <SPC> = <SPC> mid , <SPC> mid , <SPC> mid <NL>          tmp <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> mid ) : <NL> <NL>              while <SPC> k <SPC> < <SPC> end <SPC> and <SPC> sums [ k ] <SPC> - <SPC> sums [ i ] <SPC> < <SPC> lower : <NL>                  k <SPC> += <SPC> 1 <NL>              while <SPC> j <SPC> < <SPC> end <SPC> and <SPC> sums [ j ] <SPC> - <SPC> sums [ i ] <SPC> <= <SPC> upper : <NL>                  j <SPC> += <SPC> 1 <NL>              count <SPC> += <SPC> j <SPC> - <SPC> k <NL> <NL>              while <SPC> r <SPC> < <SPC> end <SPC> and <SPC> sums [ r ] <SPC> < <SPC> sums [ i ] : <NL>                  tmp . append ( sums [ r ] ) <NL>                  r <SPC> += <SPC> 1 <NL>              tmp . append ( sums [ i ] ) <NL> <NL>          sums [ start : <SPC> start <SPC> + <SPC> len ( tmp ) ] <SPC> = <SPC> tmp <NL>          return <SPC> count <NL> <NL> <TAB> sums <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( nums ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          sums [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> sums [ i ] <SPC> + <SPC> nums [ i ] <NL> <TAB> return <SPC> countAndMergeSort ( sums , <SPC> 0 , <SPC> len ( sums ) , <SPC> lower , <SPC> upper ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> countRangeSum ( self , <SPC> nums , <SPC> lower , <SPC> upper ) : <NL> <NL> <TAB> def <SPC> countAndMergeSort ( sums , <SPC> start , <SPC> end , <SPC> lower , <SPC> upper ) : <NL>          if <SPC> ( <NL>              end <SPC> - <SPC> start <SPC> <= <SPC> 0 <NL>          ) : <NL>              return <SPC> 0 <NL> <NL>          mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> / <SPC> 2 <NL>          count <SPC> = <SPC> countAndMergeSort ( <NL>              sums , <SPC> start , <SPC> mid , <SPC> lower , <SPC> upper <NL>          ) <SPC> + <SPC> countAndMergeSort ( sums , <SPC> mid <SPC> + <SPC> 1 , <SPC> end , <SPC> lower , <SPC> upper ) <NL>          j , <SPC> k , <SPC> r <SPC> = <SPC> mid <SPC> + <SPC> 1 , <SPC> mid <SPC> + <SPC> 1 , <SPC> mid <SPC> + <SPC> 1 <NL>          tmp <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> mid <SPC> + <SPC> 1 ) : <NL> <NL>              while <SPC> k <SPC> <= <SPC> end <SPC> and <SPC> sums [ k ] <SPC> - <SPC> sums [ i ] <SPC> < <SPC> lower : <NL>                  k <SPC> += <SPC> 1 <NL>              while <SPC> j <SPC> <= <SPC> end <SPC> and <SPC> sums [ j ] <SPC> - <SPC> sums [ i ] <SPC> <= <SPC> upper : <NL>                  j <SPC> += <SPC> 1 <NL>              count <SPC> += <SPC> j <SPC> - <SPC> k <NL> <NL>              while <SPC> r <SPC> <= <SPC> end <SPC> and <SPC> sums [ r ] <SPC> < <SPC> sums [ i ] : <NL>                  tmp . append ( sums [ r ] ) <NL>                  r <SPC> += <SPC> 1 <NL>              tmp . append ( sums [ i ] ) <NL> <NL>          sums [ start : <SPC> start <SPC> + <SPC> len ( tmp ) ] <SPC> = <SPC> tmp <NL>          return <SPC> count <NL> <NL> <TAB> sums <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( nums ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          sums [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> sums [ i ] <SPC> + <SPC> nums [ i ] <NL> <TAB> return <SPC> countAndMergeSort ( sums , <SPC> 0 , <SPC> len ( sums ) <SPC> - <SPC> 1 , <SPC> lower , <SPC> upper ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countSmaller ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> countAndMergeSort ( num_idxs , <SPC> start , <SPC> end , <SPC> counts ) : <NL>          if <SPC> ( <NL>              end <SPC> - <SPC> start <SPC> <= <SPC> 0 <NL>          ) : <NL>              return <SPC> 0 <NL> <NL>          mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> / <SPC> 2 <NL>          countAndMergeSort ( num_idxs , <SPC> start , <SPC> mid , <SPC> counts ) <NL>          countAndMergeSort ( num_idxs , <SPC> mid <SPC> + <SPC> 1 , <SPC> end , <SPC> counts ) <NL>          r <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          tmp <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> mid <SPC> + <SPC> 1 ) : <NL> <NL>              while <SPC> r <SPC> <= <SPC> end <SPC> and <SPC> num_idxs [ r ] [ 0 ] <SPC> < <SPC> num_idxs [ i ] [ 0 ] : <NL>                  tmp . append ( num_idxs [ r ] ) <NL>                  r <SPC> += <SPC> 1 <NL>              tmp . append ( num_idxs [ i ] ) <NL>              counts [ num_idxs [ i ] [ 1 ] ] <SPC> += <SPC> r <SPC> - <SPC> ( mid <SPC> + <SPC> 1 ) <NL> <NL>          num_idxs [ start : <SPC> start <SPC> + <SPC> len ( tmp ) ] <SPC> = <SPC> tmp <NL> <NL> <TAB> num_idxs <SPC> = <SPC> [ ] <NL> <TAB> counts <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( nums ) <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          num_idxs . append ( ( num , <SPC> i ) ) <NL> <TAB> countAndMergeSort ( num_idxs , <SPC> 0 , <SPC> len ( num_idxs ) <SPC> - <SPC> 1 , <SPC> counts ) <NL> <TAB> return <SPC> counts <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> countSmaller ( self , <SPC> nums ) : <NL> <NL> <TAB> class <SPC> BIT ( object ) : <NL>          def <SPC> __init__ ( self , <SPC> n ) : <NL>              self . __bit <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <NL>          def <SPC> add ( self , <SPC> i , <SPC> val ) : <NL>              i <SPC> += <SPC> 1 <NL>              while <SPC> i <SPC> < <SPC> len ( self . __bit ) : <NL>                  self . __bit [ i ] <SPC> += <SPC> val <NL>                  i <SPC> += <SPC> i <SPC> & <SPC> - i <NL> <NL>          def <SPC> query ( self , <SPC> i ) : <NL>              i <SPC> += <SPC> 1 <NL>              ret <SPC> = <SPC> 0 <NL>              while <SPC> i <SPC> > <SPC> 0 : <NL>                  ret <SPC> += <SPC> self . __bit [ i ] <NL>                  i <SPC> -= <SPC> i <SPC> & <SPC> - i <NL>              return <SPC> ret <NL> <NL> <TAB> sorted_nums <SPC> = <SPC> sorted ( zip ( nums , <SPC> range ( len ( nums ) ) ) ) <NL> <TAB> lookup <SPC> = <SPC> { i : <SPC> new_i <SPC> for <SPC> new_i , <SPC> ( _ , <SPC> i ) <SPC> in <SPC> enumerate ( sorted_nums ) } <NL> <NL> <TAB> result , <SPC> bit <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( nums ) , <SPC> BIT ( len ( nums ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( nums ) ) ) : <NL>          result [ i ] <SPC> = <SPC> bit . query ( lookup [ i ] <SPC> - <SPC> 1 ) <NL>          bit . add ( lookup [ i ] , <SPC> 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> countSmaller ( self , <SPC> nums ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( nums ) <NL> <TAB> bst <SPC> = <SPC> self . BST ( ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( nums ) ) ) : <NL>          bst . insertNode ( nums [ i ] ) <NL>          res [ i ] <SPC> = <SPC> bst . query ( nums [ i ] ) <NL> <NL> <TAB> return <SPC> res <NL> <NL> <TAB> class <SPC> BST ( object ) : <NL> <NL> <TAB> class <SPC> BSTreeNode ( object ) : <NL>          def <SPC> __init__ ( self , <SPC> val ) : <NL>              self . val <SPC> = <SPC> val <NL>              self . count <SPC> = <SPC> 0 <NL>              self . left <SPC> = <SPC> self . right <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL>          self . root <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> insertNode ( self , <SPC> val ) : <NL>          node <SPC> = <SPC> self . BSTreeNode ( val ) <NL>          if <SPC> not <SPC> self . root : <NL>              self . root <SPC> = <SPC> node <NL>              return <NL>          curr <SPC> = <SPC> self . root <NL>          while <SPC> curr : <NL> <NL>              if <SPC> node . val <SPC> < <SPC> curr . val : <NL>                  curr . count <SPC> += <SPC> 1 <NL>                  if <SPC> curr . left : <NL>                      curr <SPC> = <SPC> curr . left <NL>                  else : <NL>                      curr . left <SPC> = <SPC> node <NL>                      break <NL>              else : <NL>                  if <SPC> curr . right : <NL>                      curr <SPC> = <SPC> curr . right <NL>                  else : <NL>                      curr . right <SPC> = <SPC> node <NL>                      break <NL> <NL> <TAB> def <SPC> query ( self , <SPC> val ) : <NL>          count <SPC> = <SPC> 0 <NL>          curr <SPC> = <SPC> self . root <NL>          while <SPC> curr : <NL> <NL>              if <SPC> val <SPC> < <SPC> curr . val : <NL>                  curr <SPC> = <SPC> curr . left <NL>              elif <SPC> val <SPC> > <SPC> curr . val : <NL>                  count <SPC> += <SPC> 1 <SPC> + <SPC> curr . count <NL>                  curr <SPC> = <SPC> curr . right <NL>              else : <NL>                  return <SPC> count <SPC> + <SPC> curr . count <NL>          return <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countQuadruples ( self , <SPC> firstString , <SPC> secondString ) : <NL> <NL> <TAB> lookup1 <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( firstString ) ) ) : <NL>          lookup1 [ ord ( firstString [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> i <NL> <TAB> lookup2 <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( secondString ) ) : <NL>          lookup2 [ ord ( secondString [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> i <NL> <TAB> result , <SPC> diff <SPC> = <SPC> 0 , <SPC> float ( "inf" ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 26 ) : <NL>          if <SPC> lookup1 [ i ] <SPC> == <SPC> - 1 <SPC> or <SPC> lookup2 [ i ] <SPC> == <SPC> - 1 : <NL>              continue <NL>          if <SPC> lookup1 [ i ] <SPC> - <SPC> lookup2 [ i ] <SPC> < <SPC> diff : <NL>              diff <SPC> = <SPC> lookup1 [ i ] <SPC> - <SPC> lookup2 [ i ] <NL>              result <SPC> = <SPC> 0 <NL>          result <SPC> += <SPC> int ( lookup1 [ i ] <SPC> - <SPC> lookup2 [ i ] <SPC> == <SPC> diff ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countPairs ( self , <SPC> n , <SPC> edges , <SPC> queries ) : <NL> <NL> <TAB> degree <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> shared <SPC> = <SPC> collections . Counter ( ( min ( n1 , <SPC> n2 ) , <SPC> max ( n1 , <SPC> n2 ) ) <NL>                                   for <SPC> n1 , <SPC> n2 <SPC> in <SPC> edges ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          degree [ u ] <SPC> += <SPC> 1 <NL>          degree [ v ] <SPC> += <SPC> 1 <NL> <TAB> cnt <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 2 <SPC> * <SPC> ( max ( degree [ 1 : ] ) <SPC> + <SPC> 1 ) ) <NL> <TAB> count <SPC> = <SPC> collections . Counter ( degree [ 1 : ] ) <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> itertools . product ( count , <SPC> count ) : <NL>          if <SPC> i <SPC> < <SPC> j : <NL>              cnt [ i <SPC> + <SPC> j ] <SPC> += <SPC> count [ i ] <SPC> * <SPC> count [ j ] <NL>          elif <SPC> i <SPC> == <SPC> j : <NL>              cnt [ i <SPC> + <SPC> j ] <SPC> += <SPC> count [ i ] <SPC> * <SPC> ( count [ i ] <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 <NL> <TAB> for <SPC> ( i , <SPC> j ) , <SPC> shared_degree <SPC> in <SPC> shared . iteritems ( ) : <NL>          cnt [ degree [ i ] <SPC> + <SPC> degree [ j ] ] <SPC> -= <SPC> 1 <NL>          cnt [ degree [ i ] <SPC> + <SPC> degree [ j ] <SPC> - <SPC> shared_degree ] <SPC> += <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( cnt ) <SPC> - <SPC> 1 ) ) : <NL>          cnt [ i ] <SPC> += <SPC> cnt [ i <SPC> + <SPC> 1 ] <NL> <TAB> return <SPC> [ cnt [ q <SPC> + <SPC> 1 ] <SPC> if <SPC> q <SPC> + <SPC> 1 <SPC> < <SPC> len ( cnt ) <SPC> else <SPC> 0 <SPC> for <SPC> q <SPC> in <SPC> queries ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> countPairs ( self , <SPC> n , <SPC> edges , <SPC> queries ) : <NL> <NL> <TAB> degree <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> shared <SPC> = <SPC> collections . Counter ( ( min ( n1 , <SPC> n2 ) , <SPC> max ( n1 , <SPC> n2 ) ) <NL>                                   for <SPC> n1 , <SPC> n2 <SPC> in <SPC> edges ) <NL> <TAB> for <SPC> n1 , <SPC> n2 <SPC> in <SPC> edges : <NL>          degree [ n1 ] <SPC> += <SPC> 1 <NL>          degree [ n2 ] <SPC> += <SPC> 1 <NL> <TAB> sorted_degree <SPC> = <SPC> sorted ( degree ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> k , <SPC> q <SPC> in <SPC> enumerate ( queries ) : <NL>          left , <SPC> right <SPC> = <SPC> 1 , <SPC> n <NL>          cnt <SPC> = <SPC> 0 <NL>          while <SPC> left <SPC> < <SPC> right : <NL>              if <SPC> q <SPC> < <SPC> sorted_degree [ left ] <SPC> + <SPC> sorted_degree [ right ] : <NL>                  cnt <SPC> += <SPC> right <SPC> - <SPC> left <NL>                  right <SPC> -= <SPC> 1 <NL>              else : <NL>                  left <SPC> += <SPC> 1 <NL>          for <SPC> ( i , <SPC> j ) , <SPC> shared_degree <SPC> in <SPC> shared . iteritems ( ) : <NL>              if <SPC> degree [ i ] <SPC> + <SPC> degree [ j ] <SPC> - <SPC> shared_degree <SPC> <= <SPC> q <SPC> < <SPC> degree [ i ] <SPC> + <SPC> degree [ j ] : <NL>                  cnt <SPC> -= <SPC> 1 <NL>          result . append ( cnt ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> countPrimes ( self , <SPC> n ) : <NL> <TAB> if <SPC> n <SPC> <= <SPC> 2 : <NL>          return <SPC> 0 <NL> <NL> <TAB> is_prime <SPC> = <SPC> [ True ] <SPC> * <SPC> ( n <SPC> // <SPC> 2 ) <NL> <TAB> cnt <SPC> = <SPC> len ( is_prime ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 3 , <SPC> n , <SPC> 2 ) : <NL>          if <SPC> i <SPC> * <SPC> i <SPC> >= <SPC> n : <NL>              break <NL>          if <SPC> not <SPC> is_prime [ i <SPC> // <SPC> 2 ] : <NL>              continue <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> * <SPC> i , <SPC> n , <SPC> 2 <SPC> * <SPC> i ) : <NL>              if <SPC> not <SPC> is_prime [ j <SPC> // <SPC> 2 ] : <NL>                  continue <NL>              cnt <SPC> -= <SPC> 1 <NL>              is_prime [ j <SPC> // <SPC> 2 ] <SPC> = <SPC> False <NL> <NL> <TAB> return <SPC> cnt <NL> <NL> <TAB> def <SPC> countPrimes2 ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> < <SPC> 3 : <NL>          return <SPC> 0 <NL> <TAB> primes <SPC> = <SPC> [ True ] <SPC> * <SPC> n <NL> <TAB> primes [ 0 ] <SPC> = <SPC> primes [ 1 ] <SPC> = <SPC> False <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 2 , <SPC> int ( n <SPC> ** <SPC> 0.5 ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> primes [ i ] : <NL>              primes [ i <SPC> * <SPC> i : <SPC> n : <SPC> i ] <SPC> = <SPC> [ False ] <SPC> * <SPC> len ( primes [ i <SPC> * <SPC> i : <SPC> n : <SPC> i ] ) <NL> <TAB> return <SPC> sum ( primes ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countServers ( self , <SPC> grid ) : <NL> <NL> <TAB> rows , <SPC> cols <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( grid ) , <SPC> [ 0 ] <SPC> * <SPC> len ( grid [ 0 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> grid [ i ] [ j ] : <NL>                  rows [ i ] <SPC> += <SPC> 1 <NL>                  cols [ j ] <SPC> += <SPC> 1 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> and <SPC> ( rows [ i ] <SPC> > <SPC> 1 <SPC> or <SPC> cols [ j ] <SPC> > <SPC> 1 ) : <NL>                  result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countVowelStrings ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> nCr ( n , <SPC> r ) : <NL>          if <SPC> n <SPC> - <SPC> r <SPC> < <SPC> r : <NL>              return <SPC> nCr ( n , <SPC> n <SPC> - <SPC> r ) <NL>          c <SPC> = <SPC> 1 <NL>          for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> r <SPC> + <SPC> 1 ) : <NL>              c <SPC> *= <SPC> n <SPC> - <SPC> k <SPC> + <SPC> 1 <NL>              c <SPC> //= <SPC> k <NL>          return <SPC> c <NL> <NL> <TAB> return <SPC> nCr ( n <SPC> + <SPC> 4 , <SPC> 4 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countSquares ( self , <SPC> matrix ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( matrix [ 0 ] ) ) : <NL>              if <SPC> not <SPC> matrix [ i ] [ j ] : <NL>                  continue <NL>              l <SPC> = <SPC> min ( matrix [ i <SPC> - <SPC> 1 ] [ j ] , <SPC> matrix [ i ] [ j <SPC> - <SPC> 1 ] ) <NL>              matrix [ i ] [ j ] <SPC> = <SPC> l <SPC> + <SPC> 1 <SPC> if <SPC> matrix [ i <SPC> - <SPC> l ] [ j <SPC> - <SPC> l ] <SPC> else <SPC> l <NL> <TAB> return <SPC> sum ( x <SPC> for <SPC> row <SPC> in <SPC> matrix <SPC> for <SPC> x <SPC> in <SPC> row ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSubmat ( self , <SPC> mat ) : <NL> <NL> <TAB> def <SPC> count ( heights ) : <NL>          dp , <SPC> stk <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( heights ) , <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( heights ) ) : <NL>              while <SPC> stk <SPC> and <SPC> heights [ stk [ - 1 ] ] <SPC> >= <SPC> heights [ i ] : <NL>                  stk . pop ( ) <NL>              dp [ i ] <SPC> = <SPC> ( <NL>                  dp [ stk [ - 1 ] ] <SPC> + <SPC> heights [ i ] <SPC> * <SPC> ( i <SPC> - <SPC> stk [ - 1 ] ) <NL>                  if <SPC> stk <NL>                  else <SPC> heights [ i ] <SPC> * <SPC> ( i <SPC> - <SPC> ( - 1 ) ) <NL>              ) <NL>              stk . append ( i ) <NL>          return <SPC> sum ( dp ) <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> heights <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( mat [ 0 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( mat ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( mat [ 0 ] ) ) : <NL>              heights [ j ] <SPC> = <SPC> heights [ j ] <SPC> + <SPC> 1 <SPC> if <SPC> mat [ i ] [ j ] <SPC> == <SPC> 1 <SPC> else <SPC> 0 <NL>          result <SPC> += <SPC> count ( heights ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countSubstrings ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> def <SPC> count ( <NL>          i , <SPC> j <NL> <TAB> ) : <NL>          result <SPC> = <SPC> ( <NL>              left_cnt <NL>          ) <SPC> = <SPC> ( <NL>              right_cnt <NL>          ) <SPC> = <SPC> 0 <NL>          for <SPC> k <SPC> in <SPC> xrange ( min ( len ( s ) <SPC> - <SPC> i , <SPC> len ( t ) <SPC> - <SPC> j ) ) : <NL>              right_cnt <SPC> += <SPC> 1 <NL>              if <SPC> s [ i <SPC> + <SPC> k ] <SPC> != <SPC> t [ j <SPC> + <SPC> k ] : <NL>                  left_cnt , <SPC> right_cnt <SPC> = <SPC> right_cnt , <SPC> 0 <NL> <NL>              result <SPC> += <SPC> left_cnt <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> sum ( count ( i , <SPC> 0 ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) ) <SPC> + <SPC> sum ( <NL>          count ( 0 , <SPC> j ) <SPC> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( t ) ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countLetters ( self , <SPC> S ) : <NL> <NL> <TAB> result <SPC> = <SPC> len ( S ) <NL> <TAB> left <SPC> = <SPC> 0 <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( 1 , <SPC> len ( S ) ) : <NL>          if <SPC> S [ right ] <SPC> == <SPC> S [ left ] : <NL>              result <SPC> += <SPC> right <SPC> - <SPC> left <NL>          else : <NL>              left <SPC> = <SPC> right <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countSubgraphsForEachDiameter ( self , <SPC> n , <SPC> edges ) : <NL> <NL> <TAB> def <SPC> dfs ( n , <SPC> adj , <SPC> curr , <SPC> parent , <SPC> lookup , <SPC> count , <SPC> dp ) : <NL>          for <SPC> child <SPC> in <SPC> adj [ curr ] : <NL>              if <SPC> child <SPC> == <SPC> parent <SPC> or <SPC> lookup [ child ] : <NL>                  continue <NL>              dfs ( n , <SPC> adj , <SPC> child , <SPC> curr , <SPC> lookup , <SPC> count , <SPC> dp ) <NL>          dp [ curr ] [ 0 ] [ 0 ] <SPC> = <SPC> 1 <NL>          for <SPC> child <SPC> in <SPC> adj [ curr ] : <NL>              if <SPC> child <SPC> == <SPC> parent <SPC> or <SPC> lookup [ child ] : <NL>                  continue <NL>              new_dp_curr <SPC> = <SPC> [ row [ : ] <SPC> for <SPC> row <SPC> in <SPC> dp [ curr ] ] <NL>              for <SPC> curr_d <SPC> in <SPC> xrange ( count [ curr ] ) : <NL>                  for <SPC> curr_max_d <SPC> in <SPC> xrange ( curr_d , <SPC> min ( 2 <SPC> * <SPC> curr_d <SPC> + <SPC> 1 , <SPC> count [ curr ] ) ) : <NL>                      if <SPC> not <SPC> dp [ curr ] [ curr_d ] [ curr_max_d ] : <NL>                          continue <NL>                      for <SPC> child_d <SPC> in <SPC> xrange ( count [ child ] ) : <NL>                          for <SPC> child_max_d <SPC> in <SPC> xrange ( <NL>                              child_d , <SPC> min ( 2 <SPC> * <SPC> child_d <SPC> + <SPC> 1 , <SPC> count [ child ] ) <NL>                          ) : <NL>                              new_dp_curr [ max ( curr_d , <SPC> child_d <SPC> + <SPC> 1 ) ] [ <NL>                                  max ( curr_max_d , <SPC> child_max_d , <NL>                                      curr_d <SPC> + <SPC> child_d <SPC> + <SPC> 1 ) <NL>                              ] <SPC> += <SPC> ( <NL>                                  dp [ curr ] [ curr_d ] [ curr_max_d ] <NL>                                  * <SPC> dp [ child ] [ child_d ] [ child_max_d ] <NL>                              ) <NL>              count [ curr ] <SPC> += <SPC> count [ child ] <NL>              dp [ curr ] <SPC> = <SPC> new_dp_curr <NL> <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          u <SPC> -= <SPC> 1 <NL>          v <SPC> -= <SPC> 1 <NL>          adj [ u ] . append ( v ) <NL>          adj [ v ] . append ( u ) <NL> <TAB> lookup , <SPC> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n , <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          dp <SPC> = <SPC> [ [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL>          count <SPC> = <SPC> [ 1 ] <SPC> * <SPC> n <NL>          dfs ( <NL>              n , <SPC> adj , <SPC> i , <SPC> - 1 , <SPC> lookup , <SPC> count , <SPC> dp <NL>          ) <NL>          lookup [ i ] <SPC> = <SPC> 1 <NL>          for <SPC> d <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>              for <SPC> max_d <SPC> in <SPC> xrange ( d , <SPC> min ( 2 <SPC> * <SPC> d <SPC> + <SPC> 1 , <SPC> n ) ) : <NL>                  result [ max_d <SPC> - <SPC> 1 ] <SPC> += <SPC> dp [ i ] [ d ] [ max_d ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> countSubgraphsForEachDiameter ( self , <SPC> n , <SPC> edges ) : <NL> <NL> <TAB> def <SPC> popcount ( mask ) : <NL>          count <SPC> = <SPC> 0 <NL>          while <SPC> mask : <NL>              mask <SPC> &= <SPC> mask <SPC> - <SPC> 1 <NL>              count <SPC> += <SPC> 1 <NL>          return <SPC> count <NL> <NL> <TAB> def <SPC> bfs ( adj , <SPC> mask , <SPC> start ) : <NL>          q <SPC> = <SPC> collections . deque ( [ ( start , <SPC> 0 ) ] ) <NL>          lookup <SPC> = <SPC> 1 <SPC> << <SPC> start <NL>          count <SPC> = <SPC> popcount ( mask ) <SPC> - <SPC> 1 <NL>          u , <SPC> d <SPC> = <SPC> None , <SPC> None <NL>          while <SPC> q : <NL>              u , <SPC> d <SPC> = <SPC> q . popleft ( ) <NL>              for <SPC> v <SPC> in <SPC> adj [ u ] : <NL>                  if <SPC> not <SPC> ( mask <SPC> & <SPC> ( 1 <SPC> << <SPC> v ) ) <SPC> or <SPC> ( lookup <SPC> & <SPC> ( 1 <SPC> << <SPC> v ) ) : <NL>                      continue <NL>                  lookup <SPC> |= <SPC> 1 <SPC> << <SPC> v <NL>                  count <SPC> -= <SPC> 1 <NL>                  q . append ( ( v , <SPC> d <SPC> + <SPC> 1 ) ) <NL>          return <SPC> count <SPC> == <SPC> 0 , <SPC> u , <SPC> d <NL> <NL> <TAB> def <SPC> max_distance ( n , <SPC> edges , <SPC> adj , <SPC> mask ) : <NL>          is_valid , <SPC> farthest , <SPC> _ <SPC> = <SPC> bfs ( adj , <SPC> mask , <SPC> int ( math . log ( mask <SPC> & <SPC> - mask , <SPC> 2 ) ) ) <NL>          return <SPC> bfs ( adj , <SPC> mask , <SPC> farthest ) [ - 1 ] <SPC> if <SPC> is_valid <SPC> else <SPC> 0 <NL> <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          u <SPC> -= <SPC> 1 <NL>          v <SPC> -= <SPC> 1 <NL>          adj [ u ] . append ( v ) <NL>          adj [ v ] . append ( u ) <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> for <SPC> mask <SPC> in <SPC> xrange ( 1 , <SPC> 2 <SPC> ** <SPC> n ) : <NL>          max_d <SPC> = <SPC> max_distance ( n , <SPC> edges , <SPC> adj , <SPC> mask ) <NL>          if <SPC> max_d <SPC> - <SPC> 1 <SPC> >= <SPC> 0 : <NL>              result [ max_d <SPC> - <SPC> 1 ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countConsistentStrings ( self , <SPC> allowed , <SPC> words ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> [ False ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> c <SPC> in <SPC> allowed : <NL>          lookup [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> True <NL> <TAB> result <SPC> = <SPC> len ( words ) <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          for <SPC> c <SPC> in <SPC> word : <NL>              if <SPC> not <SPC> lookup [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] : <NL>                  result <SPC> -= <SPC> 1 <NL>                  break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getMaxRepetitions ( self , <SPC> s1 , <SPC> n1 , <SPC> s2 , <SPC> n2 ) : <NL> <NL> <TAB> repeat_count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( s2 ) <SPC> + <SPC> 1 ) <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> j , <SPC> count <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> n1 <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s1 ) ) : <NL>              if <SPC> s1 [ i ] <SPC> == <SPC> s2 [ j ] : <NL>                  j <SPC> = <SPC> ( j <SPC> + <SPC> 1 ) <SPC> % <SPC> len ( s2 ) <NL>                  count <SPC> += <SPC> j <SPC> == <SPC> 0 <NL> <NL>          if <SPC> j <SPC> in <SPC> lookup : <NL>              i <SPC> = <SPC> lookup [ j ] <NL>              prefix_count <SPC> = <SPC> repeat_count [ i ] <NL>              pattern_count <SPC> = <SPC> ( count <SPC> - <SPC> repeat_count [ i ] ) <SPC> * <SPC> ( ( n1 <SPC> - <SPC> i ) <SPC> // <SPC> ( k <SPC> - <SPC> i ) ) <NL>              suffix_count <SPC> = <SPC> repeat_count [ i <SPC> + <NL>                                          ( n1 <SPC> - <SPC> i ) <SPC> % <SPC> ( k <SPC> - <SPC> i ) ] <SPC> - <SPC> repeat_count [ i ] <NL>              return <SPC> ( prefix_count <SPC> + <SPC> pattern_count <SPC> + <SPC> suffix_count ) <SPC> / <SPC> n2 <NL>          lookup [ j ] <SPC> = <SPC> k <NL>          repeat_count [ k ] <SPC> = <SPC> count <NL> <NL> <TAB> return <SPC> repeat_count [ n1 ] <SPC> / <SPC> n2 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countTriplets ( self , <SPC> arr ) : <NL> <NL> <TAB> count_sum <SPC> = <SPC> collections . defaultdict ( lambda : <SPC> [ 0 , <SPC> 0 ] ) <NL> <TAB> count_sum [ 0 ] <SPC> = <SPC> [ 1 , <SPC> 0 ] <NL> <TAB> result , <SPC> prefix <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( arr ) : <NL>          prefix <SPC> ^= <SPC> x <NL>          c , <SPC> t <SPC> = <SPC> count_sum [ prefix ] <NL> <NL>          result <SPC> += <SPC> c <SPC> * <SPC> i <SPC> - <SPC> t <NL>          count_sum [ prefix ] <SPC> = <SPC> [ c <SPC> + <SPC> 1 , <SPC> t <SPC> + <SPC> i <SPC> + <SPC> 1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> unhappyFriends ( self , <SPC> n , <SPC> preferences , <SPC> pairs ) : <NL> <NL> <TAB> friends <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( preferences ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( preferences [ i ] ) ) : <NL>              friends [ i ] [ preferences [ i ] [ j ] ] <SPC> = <SPC> j <NL> <TAB> pairing <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> pairs : <NL>          pairing [ i ] , <SPC> pairing [ j ] <SPC> = <SPC> j , <SPC> i <NL> <TAB> return <SPC> sum ( <NL>          any ( <NL>              friends [ i ] [ j ] <SPC> < <SPC> friends [ i ] [ pairing [ i ] ] <NL>              and <SPC> friends [ j ] [ i ] <SPC> < <SPC> friends [ j ] [ pairing [ j ] ] <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( friends [ i ] ) ) <NL>              if <SPC> j <SPC> != <SPC> i <SPC> and <SPC> j <SPC> != <SPC> pairing [ i ] <NL>          ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( friends ) ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> string <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> uniqueLetterString ( self , <SPC> S ) : <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> index <SPC> = <SPC> { c : <SPC> [ - 1 , <SPC> - 1 ] <SPC> for <SPC> c <SPC> in <SPC> string . ascii_uppercase } <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( S ) : <NL>          k , <SPC> j <SPC> = <SPC> index [ c ] <NL>          result <SPC> += <SPC> ( i <SPC> - <SPC> j ) <SPC> * <SPC> ( j <SPC> - <SPC> k ) <NL>          index [ c ] <SPC> = <SPC> [ j , <SPC> i ] <NL> <TAB> for <SPC> c <SPC> in <SPC> index : <NL>          k , <SPC> j <SPC> = <SPC> index [ c ] <NL>          result <SPC> += <SPC> ( len ( S ) <SPC> - <SPC> j ) <SPC> * <SPC> ( j <SPC> - <SPC> k ) <NL> <TAB> return <SPC> result <SPC> % <SPC> M <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> countUnivalSubtrees ( self , <SPC> root ) : <NL> <TAB> [ is_uni , <SPC> count ] <SPC> = <SPC> self . isUnivalSubtrees ( root , <SPC> 0 ) <NL> <TAB> return <SPC> count <NL> <NL> <TAB> def <SPC> isUnivalSubtrees ( self , <SPC> root , <SPC> count ) : <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> [ True , <SPC> count ] <NL> <NL> <TAB> [ left , <SPC> count ] <SPC> = <SPC> self . isUnivalSubtrees ( root . left , <SPC> count ) <NL> <TAB> [ right , <SPC> count ] <SPC> = <SPC> self . isUnivalSubtrees ( root . right , <SPC> count ) <NL> <TAB> if <SPC> self . isSame ( root , <SPC> root . left , <SPC> left ) <SPC> and <SPC> self . isSame ( root , <SPC> root . right , <SPC> right ) : <NL>          count <SPC> += <SPC> 1 <NL>          return <SPC> [ True , <SPC> count ] <NL> <NL> <TAB> return <SPC> [ False , <SPC> count ] <NL> <NL> <TAB> def <SPC> isSame ( self , <SPC> root , <SPC> child , <SPC> is_uni ) : <NL> <TAB> return <SPC> not <SPC> child <SPC> or <SPC> ( is_uni <SPC> and <SPC> root . val <SPC> == <SPC> child . val ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countVowelPermutation ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> matrix_expo ( A , <SPC> K ) : <NL>          result <SPC> = <SPC> [ [ int ( i <SPC> == <SPC> j ) <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>                    for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>          while <SPC> K : <NL>              if <SPC> K <SPC> % <SPC> 2 : <NL>                  result <SPC> = <SPC> matrix_mult ( result , <SPC> A ) <NL>              A <SPC> = <SPC> matrix_mult ( A , <SPC> A ) <NL>              K <SPC> /= <SPC> 2 <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> matrix_mult ( A , <SPC> B ) : <NL>          ZB <SPC> = <SPC> zip ( * B ) <NL>          return <SPC> [ <NL>              [ sum ( a <SPC> * <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( row , <SPC> col ) ) <SPC> % <NL>               MOD <SPC> for <SPC> col <SPC> in <SPC> ZB ] <NL>              for <SPC> row <SPC> in <SPC> A <NL>          ] <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> T <SPC> = <SPC> [ <NL>          [ 0 , <SPC> 1 , <SPC> 1 , <SPC> 0 , <SPC> 1 ] , <NL>          [ 1 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 0 ] , <NL>          [ 0 , <SPC> 1 , <SPC> 0 , <SPC> 1 , <SPC> 0 ] , <NL>          [ 0 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 0 ] , <NL>          [ 0 , <SPC> 0 , <SPC> 1 , <SPC> 1 , <SPC> 0 ] , <NL> <TAB> ] <NL> <TAB> return <SPC> sum ( map ( sum , <SPC> matrix_expo ( T , <SPC> n <SPC> - <SPC> 1 ) ) ) <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> countVowelPermutation ( self , <SPC> n ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> a , <SPC> e , <SPC> i , <SPC> o , <SPC> u <SPC> = <SPC> 1 , <SPC> 1 , <SPC> 1 , <SPC> 1 , <SPC> 1 <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>          a , <SPC> e , <SPC> i , <SPC> o , <SPC> u <SPC> = <SPC> ( <NL>              ( e <SPC> + <SPC> i <SPC> + <SPC> u ) <SPC> % <SPC> MOD , <NL>              ( a <SPC> + <SPC> i ) <SPC> % <SPC> MOD , <NL>              ( e <SPC> + <SPC> o ) <SPC> % <SPC> MOD , <NL>              i , <NL>              ( i <SPC> + <SPC> o ) <SPC> % <SPC> MOD , <NL>          ) <NL> <TAB> return <SPC> ( a <SPC> + <SPC> e <SPC> + <SPC> i <SPC> + <SPC> o <SPC> + <SPC> u ) <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> waysToDistribute ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> dp <SPC> = <SPC> [ 1 ] <SPC> * <SPC> k <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> min ( i , <SPC> k ) ) ) : <NL>              dp [ j ] <SPC> = <SPC> ( ( j <SPC> + <SPC> 1 ) <SPC> * <SPC> dp [ j ] <SPC> + <SPC> dp [ j <SPC> - <SPC> 1 ] ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> dp [ k <SPC> - <SPC> 1 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> MAX_N <SPC> = <SPC> 10 <SPC> ** <SPC> 4 <NL> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> MAX_F <SPC> = <SPC> MAX_N . bit_length ( ) <SPC> - <SPC> 1 <NL> fact <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( ( MAX_F <SPC> + <SPC> MAX_N <SPC> - <SPC> 1 ) <SPC> + <SPC> 1 ) <NL> inv <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( ( MAX_F <SPC> + <SPC> MAX_N <SPC> - <SPC> 1 ) <SPC> + <SPC> 1 ) <NL> inv_fact <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( ( MAX_F <SPC> + <SPC> MAX_N <SPC> - <SPC> 1 ) <SPC> + <SPC> 1 ) <NL> fact [ 0 ] <SPC> = <SPC> inv_fact [ 0 ] <SPC> = <SPC> fact [ 1 ] <SPC> = <SPC> inv_fact [ 1 ] <SPC> = <SPC> inv [ 1 ] <SPC> = <SPC> 1 <NL> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> len ( fact ) ) : <NL> <TAB> fact [ i ] <SPC> = <SPC> fact [ i <SPC> - <SPC> 1 ] <SPC> * <SPC> i <SPC> % <SPC> MOD <NL> <TAB> inv [ i ] <SPC> = <SPC> ( <NL>          inv [ MOD <SPC> % <SPC> i ] <SPC> * <SPC> ( MOD <SPC> - <SPC> MOD <SPC> // <SPC> i ) <SPC> % <SPC> MOD <NL> <TAB> ) <NL> <TAB> inv_fact [ i ] <SPC> = <SPC> inv_fact [ i <SPC> - <SPC> 1 ] <SPC> * <SPC> inv [ i ] <SPC> % <SPC> MOD <NL> <NL> sieve <SPC> = <SPC> range ( MAX_N <SPC> + <SPC> 1 ) <NL> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> MAX_N <SPC> + <SPC> 1 ) : <NL> <TAB> if <SPC> sieve [ i ] <SPC> != <SPC> i : <NL> <TAB> continue <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( i <SPC> * <SPC> i , <SPC> MAX_N <SPC> + <SPC> 1 , <SPC> i ) : <NL> <TAB> sieve [ j ] <SPC> = <SPC> i <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> waysToFillArray ( self , <SPC> queries ) : <NL> <NL> <TAB> def <SPC> nCr ( n , <SPC> k , <SPC> mod ) : <NL>          return <SPC> ( fact [ n ] <SPC> * <SPC> inv_fact [ n <SPC> - <SPC> k ] <SPC> % <SPC> mod ) <SPC> * <SPC> inv_fact [ k ] <SPC> % <SPC> mod <NL> <NL> <TAB> def <SPC> get_factors ( k ) : <NL>          factors <SPC> = <SPC> collections . Counter ( ) <NL>          while <SPC> k <SPC> > <SPC> 1 : <NL>              factors [ sieve [ k ] ] <SPC> += <SPC> 1 <NL>              k <SPC> //= <SPC> sieve [ k ] <NL>          return <SPC> factors <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> n , <SPC> k <SPC> in <SPC> queries : <NL>          factors <SPC> = <SPC> get_factors ( k ) <NL>          curr <SPC> = <SPC> 1 <NL>          for <SPC> f <SPC> in <SPC> factors . itervalues ( ) : <NL>              curr <SPC> *= <SPC> nCr ( f <SPC> + <SPC> n <SPC> - <SPC> 1 , <SPC> f , <SPC> MOD ) <NL>          result . append ( curr <SPC> % <SPC> MOD ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countBits ( self , <SPC> num ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> num <SPC> + <SPC> 1 ) : <NL> <NL>          res . append ( ( i <SPC> & <SPC> 1 ) <SPC> + <SPC> res [ i <SPC> >> <SPC> 1 ] ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> countBits2 ( self , <SPC> num ) : <NL> <NL> <TAB> s <SPC> = <SPC> [ 0 ] <NL> <TAB> while <SPC> len ( s ) <SPC> <= <SPC> num : <NL>          s . extend ( map ( lambda <SPC> x : <SPC> x <SPC> + <SPC> 1 , <SPC> s ) ) <NL> <TAB> return <SPC> s [ : <SPC> num <SPC> + <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countElements ( self , <SPC> arr ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( arr ) <NL> <TAB> return <SPC> sum ( 1 <SPC> for <SPC> x <SPC> in <SPC> arr <SPC> if <SPC> x <SPC> + <SPC> 1 <SPC> in <SPC> lookup ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countElements ( self , <SPC> arr ) : <NL> <NL> <TAB> arr . sort ( ) <NL> <TAB> result , <SPC> l <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( arr ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> arr [ i ] <SPC> == <SPC> arr [ i <SPC> + <SPC> 1 ] : <NL>              l <SPC> += <SPC> 1 <NL>              continue <NL>          if <SPC> arr [ i ] <SPC> + <SPC> 1 <SPC> == <SPC> arr [ i <SPC> + <SPC> 1 ] : <NL>              result <SPC> += <SPC> l <NL>          l <SPC> = <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minSwapsCouples ( self , <SPC> row ) : <NL> <NL> <TAB> N <SPC> = <SPC> len ( row ) <SPC> // <SPC> 2 <NL> <TAB> couples <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( N ) ] <NL> <TAB> for <SPC> seat , <SPC> num <SPC> in <SPC> enumerate ( row ) : <NL>          couples [ num <SPC> // <SPC> 2 ] . append ( seat <SPC> // <SPC> 2 ) <NL> <TAB> adj <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( N ) ] <NL> <TAB> for <SPC> couch1 , <SPC> couch2 <SPC> in <SPC> couples : <NL>          adj [ couch1 ] . append ( couch2 ) <NL>          adj [ couch2 ] . append ( couch1 ) <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> couch <SPC> in <SPC> xrange ( N ) : <NL>          if <SPC> not <SPC> adj [ couch ] : <NL>              continue <NL>          couch1 , <SPC> couch2 <SPC> = <SPC> couch , <SPC> adj [ couch ] . pop ( ) <NL>          while <SPC> couch2 <SPC> != <SPC> couch : <NL>              result <SPC> += <SPC> 1 <NL>              adj [ couch2 ] . remove ( couch1 ) <NL>              couch1 , <SPC> couch2 <SPC> = <SPC> couch2 , <SPC> adj [ couch2 ] . pop ( ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findOrder ( self , <SPC> numCourses , <SPC> prerequisites ) : <NL> <NL> <TAB> in_degree <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> out_degree <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> prerequisites : <NL>          in_degree [ i ] . add ( j ) <NL>          out_degree [ j ] . add ( i ) <NL> <TAB> q <SPC> = <SPC> collections . deque ( <NL>          [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( numCourses ) <SPC> if <SPC> i <SPC> not <SPC> in <SPC> in_degree ] ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> q : <NL>          node <SPC> = <SPC> q . popleft ( ) <NL>          result . append ( node ) <NL>          for <SPC> i <SPC> in <SPC> out_degree [ node ] : <NL>              in_degree [ i ] . remove ( node ) <NL>              if <SPC> not <SPC> in_degree [ i ] : <NL>                  q . append ( i ) <NL>                  del <SPC> in_degree [ i ] <NL>          del <SPC> out_degree [ node ] <NL> <TAB> return <SPC> result <SPC> if <SPC> not <SPC> in_degree <SPC> and <SPC> not <SPC> out_degree <SPC> else <SPC> [ ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findOrder ( self , <SPC> numCourses , <SPC> prerequisites ) : <NL> <NL> <TAB> in_degree <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> out_degree <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> prerequisites : <NL>          in_degree [ i ] . add ( j ) <NL>          out_degree [ j ] . add ( i ) <NL> <TAB> stk <SPC> = <SPC> [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( numCourses ) <SPC> if <SPC> i <SPC> not <SPC> in <SPC> in_degree ] <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> stk : <NL>          node <SPC> = <SPC> stk . pop ( ) <NL>          result . append ( node ) <NL>          for <SPC> i <SPC> in <SPC> out_degree [ node ] : <NL>              in_degree [ i ] . remove ( node ) <NL>              if <SPC> not <SPC> in_degree [ i ] : <NL>                  stk . append ( i ) <NL>                  del <SPC> in_degree [ i ] <NL>          del <SPC> out_degree [ node ] <NL> <TAB> return <SPC> result <SPC> if <SPC> not <SPC> in_degree <SPC> and <SPC> not <SPC> out_degree <SPC> else <SPC> [ ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> scheduleCourse ( self , <SPC> courses ) : <NL> <NL> <TAB> courses . sort ( key = lambda <SPC> t_end : <SPC> t_end [ 1 ] ) <NL> <TAB> max_heap <SPC> = <SPC> [ ] <NL> <TAB> now <SPC> = <SPC> 0 <NL> <TAB> for <SPC> t , <SPC> end <SPC> in <SPC> courses : <NL>          now <SPC> += <SPC> t <NL>          heapq . heappush ( max_heap , <SPC> - t ) <NL>          if <SPC> now <SPC> > <SPC> end : <NL>              now <SPC> += <SPC> heapq . heappop ( max_heap ) <NL> <TAB> return <SPC> len ( max_heap ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkIfPrerequisite ( self , <SPC> n , <SPC> prerequisites , <SPC> queries ) : <NL> <NL> <TAB> def <SPC> floydWarshall ( n , <SPC> graph ) : <NL>          reachable <SPC> = <SPC> set ( map ( lambda <SPC> x : <SPC> x [ 0 ] <SPC> * <SPC> n <SPC> + <SPC> x [ 1 ] , <SPC> graph ) ) <NL>          for <SPC> k <SPC> in <SPC> xrange ( n ) : <NL>              for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>                  for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>                      if <SPC> i <SPC> * <SPC> n <SPC> + <SPC> j <SPC> not <SPC> in <SPC> reachable <SPC> and <SPC> ( <NL>                          i <SPC> * <SPC> n <SPC> + <SPC> k <SPC> in <SPC> reachable <SPC> and <SPC> k <SPC> * <SPC> n <SPC> + <SPC> j <SPC> in <SPC> reachable <NL>                      ) : <NL>                          reachable . add ( i <SPC> * <SPC> n <SPC> + <SPC> j ) <NL>          return <SPC> reachable <NL> <NL> <TAB> reachable <SPC> = <SPC> floydWarshall ( n , <SPC> prerequisites ) <NL> <TAB> return <SPC> [ i <SPC> * <SPC> n <SPC> + <SPC> j <SPC> in <SPC> reachable <SPC> for <SPC> i , <SPC> j <SPC> in <SPC> queries ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> checkIfPrerequisite ( self , <SPC> n , <SPC> prerequisites , <SPC> queries ) : <NL> <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> prerequisites : <NL>          graph [ u ] . append ( v ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> queries : <NL>          stk , <SPC> lookup <SPC> = <SPC> [ i ] , <SPC> set ( [ i ] ) <NL>          while <SPC> stk : <NL>              node <SPC> = <SPC> stk . pop ( ) <NL>              for <SPC> nei <SPC> in <SPC> graph [ node ] : <NL>                  if <SPC> nei <SPC> in <SPC> lookup : <NL>                      continue <NL>                  stk . append ( nei ) <NL>                  lookup . add ( nei ) <NL>          result . append ( j <SPC> in <SPC> lookup ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canFinish ( self , <SPC> numCourses , <SPC> prerequisites ) : <NL> <NL> <TAB> in_degree <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> out_degree <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> prerequisites : <NL>          in_degree [ i ] . add ( j ) <NL>          out_degree [ j ] . add ( i ) <NL> <TAB> q <SPC> = <SPC> collections . deque ( <NL>          [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( numCourses ) <SPC> if <SPC> i <SPC> not <SPC> in <SPC> in_degree ] ) <NL> <TAB> while <SPC> q : <NL>          node <SPC> = <SPC> q . popleft ( ) <NL>          for <SPC> i <SPC> in <SPC> out_degree [ node ] : <NL>              in_degree [ i ] . remove ( node ) <NL>              if <SPC> not <SPC> in_degree [ i ] : <NL>                  q . append ( i ) <NL>                  del <SPC> in_degree [ i ] <NL>          del <SPC> out_degree [ node ] <NL> <TAB> return <SPC> not <SPC> in_degree <SPC> and <SPC> not <SPC> out_degree <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> canFinish ( self , <SPC> numCourses , <SPC> prerequisites ) : <NL> <NL> <TAB> in_degree <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> out_degree <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> prerequisites : <NL>          in_degree [ i ] . add ( j ) <NL>          out_degree [ j ] . add ( i ) <NL> <TAB> stk <SPC> = <SPC> [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( numCourses ) <SPC> if <SPC> i <SPC> not <SPC> in <SPC> in_degree ] <NL> <TAB> while <SPC> stk : <NL>          node <SPC> = <SPC> stk . pop ( ) <NL>          for <SPC> i <SPC> in <SPC> out_degree [ node ] : <NL>              in_degree [ i ] . remove ( node ) <NL>              if <SPC> not <SPC> in_degree [ i ] : <NL>                  stk . append ( i ) <NL>                  del <SPC> in_degree [ i ] <NL>          del <SPC> out_degree [ node ] <NL> <TAB> return <SPC> not <SPC> in_degree <SPC> and <SPC> not <SPC> out_degree <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isCousins ( self , <SPC> root , <SPC> x , <SPC> y ) : <NL> <NL> <TAB> def <SPC> dfs ( root , <SPC> x , <SPC> depth , <SPC> parent ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> False <NL>          if <SPC> root . val <SPC> == <SPC> x : <NL>              return <SPC> True <NL>          depth [ 0 ] <SPC> += <SPC> 1 <NL>          prev_parent , <SPC> parent [ 0 ] <SPC> = <SPC> parent [ 0 ] , <SPC> root <NL>          if <SPC> dfs ( root . left , <SPC> x , <SPC> depth , <SPC> parent ) : <NL>              return <SPC> True <NL>          parent [ 0 ] <SPC> = <SPC> root <NL>          if <SPC> dfs ( root . right , <SPC> x , <SPC> depth , <SPC> parent ) : <NL>              return <SPC> True <NL>          parent [ 0 ] <SPC> = <SPC> prev_parent <NL>          depth [ 0 ] <SPC> -= <SPC> 1 <NL>          return <SPC> False <NL> <NL> <TAB> depth_x , <SPC> depth_y <SPC> = <SPC> [ 0 ] , <SPC> [ 0 ] <NL> <TAB> parent_x , <SPC> parent_y <SPC> = <SPC> [ None ] , <SPC> [ None ] <NL> <TAB> return <SPC> ( <NL>          dfs ( root , <SPC> x , <SPC> depth_x , <SPC> parent_x ) <NL>          and <SPC> dfs ( root , <SPC> y , <SPC> depth_y , <SPC> parent_y ) <NL>          and <SPC> depth_x [ 0 ] <SPC> == <SPC> depth_y [ 0 ] <NL>          and <SPC> parent_x [ 0 ] <SPC> != <SPC> parent_y [ 0 ] <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> crackSafe ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> M <SPC> = <SPC> k <SPC> ** <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> P <SPC> = <SPC> [ <NL>          q <SPC> * <SPC> k <SPC> + <SPC> i <SPC> for <SPC> i <SPC> in <SPC> xrange ( k ) <SPC> for <SPC> q <SPC> in <SPC> xrange ( M ) <NL> <TAB> ] <NL> <TAB> result <SPC> = <SPC> [ str ( k <SPC> - <SPC> 1 ) ] <SPC> * <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k <SPC> ** <SPC> n ) : <NL>          j <SPC> = <SPC> i <NL> <NL>          while <SPC> P [ j ] <SPC> >= <SPC> 0 : <NL>              result . append ( str ( j <SPC> // <SPC> M ) ) <NL>              P [ j ] , <SPC> j <SPC> = <SPC> - 1 , <SPC> P [ j ] <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> crackSafe ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> total <SPC> = <SPC> k <SPC> ** <SPC> n <NL> <TAB> M <SPC> = <SPC> total <SPC> // <SPC> k <NL> <TAB> unique_rolling_hash <SPC> = <SPC> 0 <NL> <TAB> result <SPC> = <SPC> [ str ( 0 ) ] <SPC> * <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> while <SPC> len ( lookup ) <SPC> < <SPC> total : <NL>          for <SPC> i <SPC> in <SPC> reversed ( <NL>              xrange ( k ) <NL>          ) : <NL>              new_unique_rolling_hash <SPC> = <SPC> unique_rolling_hash <SPC> * <SPC> k <SPC> + <SPC> i <NL>              if <SPC> new_unique_rolling_hash <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( new_unique_rolling_hash ) <NL>                  result . append ( str ( i ) ) <NL>                  unique_rolling_hash <SPC> = <SPC> new_unique_rolling_hash <SPC> % <SPC> M <NL>                  break <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> crackSafe ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> M <SPC> = <SPC> k <SPC> ** <SPC> ( n <SPC> - <SPC> 1 ) <NL> <NL> <TAB> def <SPC> dfs ( k , <SPC> unique_rolling_hash , <SPC> lookup , <SPC> result ) : <NL>          for <SPC> i <SPC> in <SPC> reversed ( <NL>              xrange ( k ) <NL>          ) : <NL>              new_unique_rolling_hash <SPC> = <SPC> unique_rolling_hash <SPC> * <SPC> k <SPC> + <SPC> i <NL>              if <SPC> new_unique_rolling_hash <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( new_unique_rolling_hash ) <NL>                  result . append ( str ( i ) ) <NL>                  dfs ( k , <SPC> new_unique_rolling_hash <SPC> % <SPC> M , <SPC> lookup , <SPC> result ) <NL>                  break <NL> <NL> <TAB> unique_rolling_hash <SPC> = <SPC> 0 <NL> <TAB> result <SPC> = <SPC> [ str ( 0 ) ] <SPC> * <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> dfs ( k , <SPC> unique_rolling_hash , <SPC> lookup , <SPC> result ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> crackSafe ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ str ( k <SPC> - <SPC> 1 ) ] <SPC> * <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> total <SPC> = <SPC> k <SPC> ** <SPC> n <NL> <TAB> while <SPC> len ( lookup ) <SPC> < <SPC> total : <NL>          node <SPC> = <SPC> result [ len ( result ) <SPC> - <SPC> n <SPC> + <SPC> 1 : ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( <NL>              k <NL>          ) : <NL>              neighbor <SPC> = <SPC> "" . join ( node ) <SPC> + <SPC> str ( i ) <NL>              if <SPC> neighbor <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( neighbor ) <NL>                  result . append ( str ( i ) ) <NL>                  break <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution5 ( object ) : <NL> <TAB> def <SPC> crackSafe ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> def <SPC> dfs ( k , <SPC> node , <SPC> lookup , <SPC> result ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( <NL>              k <NL>          ) : <NL>              neighbor <SPC> = <SPC> node <SPC> + <SPC> str ( i ) <NL>              if <SPC> neighbor <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( neighbor ) <NL>                  result . append ( str ( i ) ) <NL>                  dfs ( k , <SPC> neighbor [ 1 : ] , <SPC> lookup , <SPC> result ) <NL>                  break <NL> <NL> <TAB> result <SPC> = <SPC> [ str ( k <SPC> - <SPC> 1 ) ] <SPC> * <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> dfs ( k , <SPC> "" . join ( result ) , <SPC> lookup , <SPC> result ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minOperations ( self , <SPC> logs ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> log <SPC> in <SPC> logs : <NL>          if <SPC> log <SPC> == <SPC> "../" : <NL>              if <SPC> result <SPC> > <SPC> 0 : <NL>                  result <SPC> -= <SPC> 1 <NL>          elif <SPC> log <SPC> != <SPC> "./" : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxNumber ( self , <SPC> nums1 , <SPC> nums2 , <SPC> k ) : <NL> <NL> <TAB> def <SPC> get_max_digits ( nums , <SPC> start , <SPC> end , <SPC> max_digits ) : <NL>          max_digits [ end ] <SPC> = <SPC> max_digit ( nums , <SPC> end ) <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( start , <SPC> end ) ) : <NL>              max_digits [ i ] <SPC> = <SPC> delete_digit ( max_digits [ i <SPC> + <SPC> 1 ] ) <NL> <NL> <TAB> def <SPC> max_digit ( nums , <SPC> k ) : <NL>          drop <SPC> = <SPC> len ( nums ) <SPC> - <SPC> k <NL>          res <SPC> = <SPC> [ ] <NL>          for <SPC> num <SPC> in <SPC> nums : <NL>              while <SPC> drop <SPC> and <SPC> res <SPC> and <SPC> res [ - 1 ] <SPC> < <SPC> num : <NL>                  res . pop ( ) <NL>                  drop <SPC> -= <SPC> 1 <NL>              res . append ( num ) <NL>          return <SPC> res [ : k ] <NL> <NL> <TAB> def <SPC> delete_digit ( nums ) : <NL>          res <SPC> = <SPC> list ( nums ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( res ) ) : <NL>              if <SPC> i <SPC> == <SPC> len ( res ) <SPC> - <SPC> 1 <SPC> or <SPC> res [ i ] <SPC> < <SPC> res [ i <SPC> + <SPC> 1 ] : <NL>                  res <SPC> = <SPC> res [ : i ] <SPC> + <SPC> res [ i <SPC> + <SPC> 1 : ] <NL>                  break <NL>          return <SPC> res <NL> <NL> <TAB> def <SPC> merge ( a , <SPC> b ) : <NL>          return <SPC> [ max ( a , <SPC> b ) . pop ( 0 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( a ) <SPC> + <SPC> len ( b ) ) ] <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( nums1 ) , <SPC> len ( nums2 ) <NL> <NL> <TAB> max_digits1 , <SPC> max_digits2 <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( k <SPC> + <SPC> 1 ) ] , <SPC> [ <NL>          [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( k <SPC> + <SPC> 1 ) <NL> <TAB> ] <NL> <TAB> get_max_digits ( nums1 , <SPC> max ( 0 , <SPC> k <SPC> - <SPC> n ) , <SPC> min ( k , <SPC> m ) , <SPC> max_digits1 ) <NL> <TAB> get_max_digits ( nums2 , <SPC> max ( 0 , <SPC> k <SPC> - <SPC> m ) , <SPC> min ( k , <SPC> n ) , <SPC> max_digits2 ) <NL> <NL> <TAB> return <SPC> max ( <NL>          merge ( max_digits1 [ i ] , <SPC> max_digits2 [ k <SPC> - <SPC> i ] ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( max ( 0 , <SPC> k <SPC> - <SPC> n ) , <SPC> min ( k , <SPC> m ) <SPC> + <SPC> 1 ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> BIT ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . __bit <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <NL> <TAB> def <SPC> add ( self , <SPC> i , <SPC> val ) : <NL> <TAB> i <SPC> += <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( self . __bit ) : <NL>          self . __bit [ i ] <SPC> += <SPC> val <NL>          i <SPC> += <SPC> i <SPC> & <SPC> - i <NL> <NL> <TAB> def <SPC> query ( self , <SPC> i ) : <NL> <TAB> i <SPC> += <SPC> 1 <NL> <TAB> ret <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> > <SPC> 0 : <NL>          ret <SPC> += <SPC> self . __bit [ i ] <NL>          i <SPC> -= <SPC> i <SPC> & <SPC> - i <NL> <TAB> return <SPC> ret <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> createSortedArray ( self , <SPC> instructions ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> bit <SPC> = <SPC> BIT ( max ( instructions ) ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> inst <SPC> in <SPC> enumerate ( instructions ) : <NL>          inst <SPC> -= <SPC> 1 <NL>          result <SPC> += <SPC> min ( bit . query ( inst <SPC> - <SPC> 1 ) , <SPC> i <SPC> - <SPC> bit . query ( inst ) ) <NL>          bit . add ( inst , <SPC> 1 ) <NL> <TAB> return <SPC> result <SPC> % <SPC> MOD <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution_TLE ( object ) : <NL> <TAB> def <SPC> createSortedArray ( self , <SPC> instructions ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> def <SPC> smallerMergeSort ( idxs , <SPC> start , <SPC> end , <SPC> counts ) : <NL>          if <SPC> ( <NL>              end <SPC> - <SPC> start <SPC> <= <SPC> 0 <NL>          ) : <NL>              return <SPC> 0 <NL> <NL>          mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> // <SPC> 2 <NL>          smallerMergeSort ( idxs , <SPC> start , <SPC> mid , <SPC> counts ) <NL>          smallerMergeSort ( idxs , <SPC> mid <SPC> + <SPC> 1 , <SPC> end , <SPC> counts ) <NL>          r <SPC> = <SPC> start <NL>          tmp <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( mid <SPC> + <SPC> 1 , <SPC> end <SPC> + <SPC> 1 ) : <NL> <NL>              while <SPC> r <SPC> <= <SPC> mid <SPC> and <SPC> idxs [ r ] [ 0 ] <SPC> < <SPC> idxs [ i ] [ 0 ] : <NL>                  tmp . append ( idxs [ r ] ) <NL>                  r <SPC> += <SPC> 1 <NL>              tmp . append ( idxs [ i ] ) <NL>              counts [ idxs [ i ] [ 1 ] ] <SPC> += <SPC> r <SPC> - <SPC> start <NL>          while <SPC> r <SPC> <= <SPC> mid : <NL>              tmp . append ( idxs [ r ] ) <NL>              r <SPC> += <SPC> 1 <NL> <NL>          idxs [ start : <SPC> start <SPC> + <SPC> len ( tmp ) ] <SPC> = <SPC> tmp <NL> <NL> <TAB> def <SPC> largerMergeSort ( idxs , <SPC> start , <SPC> end , <SPC> counts ) : <NL>          if <SPC> ( <NL>              end <SPC> - <SPC> start <SPC> <= <SPC> 0 <NL>          ) : <NL>              return <SPC> 0 <NL> <NL>          mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> // <SPC> 2 <NL>          largerMergeSort ( idxs , <SPC> start , <SPC> mid , <SPC> counts ) <NL>          largerMergeSort ( idxs , <SPC> mid <SPC> + <SPC> 1 , <SPC> end , <SPC> counts ) <NL>          r <SPC> = <SPC> start <NL>          tmp <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( mid <SPC> + <SPC> 1 , <SPC> end <SPC> + <SPC> 1 ) : <NL> <NL>              while <SPC> r <SPC> <= <SPC> mid <SPC> and <SPC> idxs [ r ] [ 0 ] <SPC> <= <SPC> idxs [ i ] [ 0 ] : <NL>                  tmp . append ( idxs [ r ] ) <NL>                  r <SPC> += <SPC> 1 <NL>              if <SPC> r <SPC> <= <SPC> mid : <NL>                  tmp . append ( idxs [ i ] ) <NL>              counts [ idxs [ i ] [ 1 ] ] <SPC> += <SPC> mid <SPC> - <SPC> r <SPC> + <SPC> 1 <NL>          while <SPC> r <SPC> <= <SPC> mid : <NL>              tmp . append ( idxs [ r ] ) <NL>              r <SPC> += <SPC> 1 <NL> <NL>          idxs [ start : <SPC> start <SPC> + <SPC> len ( tmp ) ] <SPC> = <SPC> tmp <NL> <NL> <TAB> idxs <SPC> = <SPC> [ ] <NL> <TAB> smaller_counts , <SPC> larger_counts <SPC> = <SPC> [ <NL>          [ 0 ] <SPC> * <SPC> len ( instructions ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i , <SPC> inst <SPC> in <SPC> enumerate ( instructions ) : <NL>          idxs . append ( ( inst , <SPC> i ) ) <NL> <TAB> smallerMergeSort ( idxs [ : ] , <SPC> 0 , <SPC> len ( idxs ) <SPC> - <SPC> 1 , <SPC> smaller_counts ) <NL> <TAB> largerMergeSort ( idxs , <SPC> 0 , <SPC> len ( idxs ) <SPC> - <SPC> 1 , <SPC> larger_counts ) <NL> <TAB> return <SPC> ( <NL>          sum ( min ( s , <SPC> l ) <NL>              for <SPC> s , <SPC> l <SPC> in <SPC> itertools . izip ( smaller_counts , <SPC> larger_counts ) ) <NL>          % <SPC> MOD <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> createTargetArray ( self , <SPC> nums , <SPC> index ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i ) : <NL>              if <SPC> index [ j ] <SPC> >= <SPC> index [ i ] : <NL>                  index [ j ] <SPC> += <SPC> 1 <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( nums ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          result [ index [ i ] ] <SPC> = <SPC> nums [ i ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> createTargetArray ( self , <SPC> nums , <SPC> index ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> itertools . izip ( index , <SPC> nums ) : <NL>          result . insert ( i , <SPC> x ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> criticalConnections ( self , <SPC> n , <SPC> connections ) : <NL> <NL> <TAB> def <SPC> dfs ( edges , <SPC> parent , <SPC> u , <SPC> idx , <SPC> lowlinks , <SPC> lookup , <SPC> result ) : <NL>          if <SPC> lookup [ u ] : <NL>              return <NL>          lookup [ u ] <SPC> = <SPC> True <NL>          curr_idx <SPC> = <SPC> lowlinks [ u ] <SPC> = <SPC> idx [ 0 ] <NL>          idx [ 0 ] <SPC> += <SPC> 1 <NL>          for <SPC> v <SPC> in <SPC> edges [ u ] : <NL>              if <SPC> v <SPC> == <SPC> parent : <NL>                  continue <NL>              dfs ( edges , <SPC> u , <SPC> v , <SPC> idx , <SPC> lowlinks , <SPC> lookup , <SPC> result ) <NL>              lowlinks [ u ] <SPC> = <SPC> min ( lowlinks [ u ] , <SPC> lowlinks [ v ] ) <NL>              if <SPC> lowlinks [ v ] <SPC> > <SPC> curr_idx : <NL> <NL>                  result . append ( [ u , <SPC> v ] ) <NL> <NL> <TAB> edges <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> idx , <SPC> lowlinks , <SPC> lookup <SPC> = <SPC> [ 0 ] , <SPC> [ 0 ] <SPC> * <SPC> n , <SPC> [ False ] <SPC> * <SPC> n <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> connections : <NL>          edges [ u ] . append ( v ) <NL>          edges [ v ] . append ( u ) <NL> <TAB> dfs ( edges , <SPC> - 1 , <SPC> 0 , <SPC> idx , <SPC> lowlinks , <SPC> lookup , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> customSortString ( self , <SPC> S , <SPC> T ) : <NL> <NL> <TAB> counter , <SPC> s <SPC> = <SPC> collections . Counter ( T ) , <SPC> set ( S ) <NL> <TAB> result <SPC> = <SPC> [ c <SPC> * <SPC> counter [ c ] <SPC> for <SPC> c <SPC> in <SPC> S ] <NL> <TAB> result . extend ( <NL>          [ c <SPC> * <SPC> counter <SPC> for <SPC> c , <SPC> counter <SPC> in <SPC> counter . iteritems ( ) <SPC> if <SPC> c <SPC> not <SPC> in <SPC> s ] ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> cutOffTree ( self , <SPC> forest ) : <NL> <NL> <TAB> def <SPC> dot ( p1 , <SPC> p2 ) : <NL>          return <SPC> p1 [ 0 ] <SPC> * <SPC> p2 [ 0 ] <SPC> + <SPC> p1 [ 1 ] <SPC> * <SPC> p2 [ 1 ] <NL> <NL> <TAB> def <SPC> minStep ( p1 , <SPC> p2 ) : <NL>          min_steps <SPC> = <SPC> abs ( p1 [ 0 ] <SPC> - <SPC> p2 [ 0 ] ) <SPC> + <SPC> abs ( p1 [ 1 ] <SPC> - <SPC> p2 [ 1 ] ) <NL>          closer , <SPC> detour <SPC> = <SPC> [ p1 ] , <SPC> [ ] <NL>          lookup <SPC> = <SPC> set ( ) <NL>          while <SPC> True : <NL>              if <SPC> not <SPC> closer : <NL>                  if <SPC> not <SPC> detour : <NL>                      return <SPC> - 1 <NL> <NL>                  min_steps <SPC> += <SPC> 2 <NL>                  closer , <SPC> detour <SPC> = <SPC> detour , <SPC> closer <NL>              i , <SPC> j <SPC> = <SPC> closer . pop ( ) <NL>              if <SPC> ( i , <SPC> j ) <SPC> == <SPC> p2 : <NL>                  return <SPC> min_steps <NL>              if <SPC> ( i , <SPC> j ) <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( ( i , <SPC> j ) ) <NL>                  for <SPC> I , <SPC> J <SPC> in <SPC> ( i <SPC> + <SPC> 1 , <SPC> j ) , <SPC> ( i <SPC> - <SPC> 1 , <SPC> j ) , <SPC> ( i , <SPC> j <SPC> + <SPC> 1 ) , <SPC> ( i , <SPC> j <SPC> - <SPC> 1 ) : <NL>                      if <SPC> ( <NL>                          0 <SPC> <= <SPC> I <SPC> < <SPC> m <NL>                          and <SPC> 0 <SPC> <= <SPC> J <SPC> < <SPC> n <NL>                          and <SPC> forest [ I ] [ J ] <NL>                          and <SPC> ( I , <SPC> J ) <SPC> not <SPC> in <SPC> lookup <NL>                      ) : <NL>                          is_closer <SPC> = <SPC> dot ( <NL>                              ( I <SPC> - <SPC> i , <SPC> J <SPC> - <SPC> j ) , <SPC> ( p2 [ 0 ] <SPC> - <SPC> i , <SPC> p2 [ 1 ] <SPC> - <SPC> j ) ) <SPC> > <SPC> 0 <NL>                          ( closer <SPC> if <SPC> is_closer <SPC> else <SPC> detour ) . append ( ( I , <SPC> J ) ) <NL>          return <SPC> min_steps <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( forest ) , <SPC> len ( forest [ 0 ] ) <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> forest [ i ] [ j ] <SPC> > <SPC> 1 : <NL>                  heapq . heappush ( min_heap , <SPC> ( forest [ i ] [ j ] , <SPC> ( i , <SPC> j ) ) ) <NL> <NL> <TAB> start <SPC> = <SPC> ( 0 , <SPC> 0 ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> min_heap : <NL>          tree <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          step <SPC> = <SPC> minStep ( start , <SPC> tree [ 1 ] ) <NL>          if <SPC> step <SPC> < <SPC> 0 : <NL>              return <SPC> - 1 <NL>          result <SPC> += <SPC> step <NL>          start <SPC> = <SPC> tree [ 1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution_TLE ( object ) : <NL> <TAB> def <SPC> cutOffTree ( self , <SPC> forest ) : <NL> <NL> <TAB> def <SPC> minStep ( p1 , <SPC> p2 ) : <NL>          min_steps <SPC> = <SPC> 0 <NL>          lookup <SPC> = <SPC> { p1 } <NL>          q <SPC> = <SPC> collections . deque ( [ p1 ] ) <NL>          while <SPC> q : <NL>              size <SPC> = <SPC> len ( q ) <NL>              for <SPC> _ <SPC> in <SPC> xrange ( size ) : <NL>                  ( i , <SPC> j ) <SPC> = <SPC> q . popleft ( ) <NL>                  if <SPC> ( i , <SPC> j ) <SPC> == <SPC> p2 : <NL>                      return <SPC> min_steps <NL>                  for <SPC> i , <SPC> j <SPC> in <SPC> ( i <SPC> + <SPC> 1 , <SPC> j ) , <SPC> ( i <SPC> - <SPC> 1 , <SPC> j ) , <SPC> ( i , <SPC> j <SPC> + <SPC> 1 ) , <SPC> ( i , <SPC> j <SPC> - <SPC> 1 ) : <NL>                      if <SPC> not <SPC> ( <NL>                          0 <SPC> <= <SPC> i <SPC> < <SPC> m <NL>                          and <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> n <NL>                          and <SPC> forest [ i ] [ j ] <NL>                          and <SPC> ( i , <SPC> j ) <SPC> not <SPC> in <SPC> lookup <NL>                      ) : <NL>                          continue <NL>                      q . append ( ( i , <SPC> j ) ) <NL>                      lookup . add ( ( i , <SPC> j ) ) <NL>              min_steps <SPC> += <SPC> 1 <NL>          return <SPC> - 1 <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( forest ) , <SPC> len ( forest [ 0 ] ) <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> forest [ i ] [ j ] <SPC> > <SPC> 1 : <NL>                  heapq . heappush ( min_heap , <SPC> ( forest [ i ] [ j ] , <SPC> ( i , <SPC> j ) ) ) <NL> <NL> <TAB> start <SPC> = <SPC> ( 0 , <SPC> 0 ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> min_heap : <NL>          tree <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          step <SPC> = <SPC> minStep ( start , <SPC> tree [ 1 ] ) <NL>          if <SPC> step <SPC> < <SPC> 0 : <NL>              return <SPC> - 1 <NL>          result <SPC> += <SPC> step <NL>          start <SPC> = <SPC> tree [ 1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> dailyTemperatures ( self , <SPC> temperatures ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( temperatures ) <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( temperatures ) ) : <NL>          while <SPC> stk <SPC> and <SPC> temperatures [ stk [ - 1 ] ] <SPC> < <SPC> temperatures [ i ] : <NL>              idx <SPC> = <SPC> stk . pop ( ) <NL>              result [ idx ] <SPC> = <SPC> i <SPC> - <SPC> idx <NL>          stk . append ( i ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Interval ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> s = 0 , <SPC> e = 0 ) : <NL> <TAB> self . start <SPC> = <SPC> s <NL> <TAB> self . end <SPC> = <SPC> e <NL> <NL> <NL> class <SPC> SummaryRanges ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . __intervals <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> addNum ( self , <SPC> val ) : <NL> <NL> <TAB> def <SPC> upper_bound ( nums , <SPC> target ) : <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>              if <SPC> nums [ mid ] . start <SPC> > <SPC> target : <NL>                  right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          return <SPC> left <NL> <NL> <TAB> i <SPC> = <SPC> upper_bound ( self . __intervals , <SPC> val ) <NL> <TAB> start , <SPC> end <SPC> = <SPC> val , <SPC> val <NL> <TAB> if <SPC> i <SPC> != <SPC> 0 <SPC> and <SPC> self . __intervals [ i <SPC> - <SPC> 1 ] . end <SPC> + <SPC> 1 <SPC> >= <SPC> val : <NL>          i <SPC> -= <SPC> 1 <NL> <TAB> while <SPC> i <SPC> != <SPC> len ( self . __intervals ) <SPC> and <SPC> end <SPC> + <SPC> 1 <SPC> >= <SPC> self . __intervals [ i ] . start : <NL>          start <SPC> = <SPC> min ( start , <SPC> self . __intervals [ i ] . start ) <NL>          end <SPC> = <SPC> max ( end , <SPC> self . __intervals [ i ] . end ) <NL>          del <SPC> self . __intervals [ i ] <NL> <TAB> self . __intervals . insert ( i , <SPC> Interval ( start , <SPC> end ) ) <NL> <NL> <TAB> def <SPC> getIntervals ( self ) : <NL> <NL> <TAB> return <SPC> self . __intervals <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> dayOfTheWeek ( self , <SPC> day , <SPC> month , <SPC> year ) : <NL> <NL> <TAB> DAYS <SPC> = <SPC> [ <NL>          "Sunday" , <NL>          "Monday" , <NL>          "Tuesday" , <NL>          "Wednesday" , <NL>          "Thursday" , <NL>          "Friday" , <NL>          "Saturday" , <NL> <TAB> ] <NL> <NL> <TAB> if <SPC> month <SPC> < <SPC> 3 : <NL>          month <SPC> += <SPC> 12 <NL>          year <SPC> -= <SPC> 1 <NL> <TAB> c , <SPC> y <SPC> = <SPC> divmod ( year , <SPC> 100 ) <NL> <TAB> w <SPC> = <SPC> ( c <SPC> // <SPC> 4 <SPC> - <SPC> 2 <SPC> * <SPC> c <SPC> + <SPC> y <SPC> + <SPC> y <SPC> // <SPC> 4 <SPC> + <SPC> 13 <SPC> * <SPC> ( month <SPC> + <SPC> 1 ) <SPC> // <SPC> 5 <SPC> + <SPC> day <SPC> - <SPC> 1 ) <SPC> % <SPC> 7 <NL> <TAB> return <SPC> DAYS [ w ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> def <SPC> dayOfMonth ( M ) : <NL>          return <SPC> 28 <SPC> if <SPC> ( M <SPC> == <SPC> 2 ) <SPC> else <SPC> 31 <SPC> - <SPC> ( M <SPC> - <SPC> 1 ) <SPC> % <SPC> 7 <SPC> % <SPC> 2 <NL> <NL> <TAB> self . __lookup <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 12 <NL> <TAB> for <SPC> M <SPC> in <SPC> xrange ( 1 , <SPC> len ( self . __lookup ) ) : <NL>          self . __lookup [ M ] <SPC> += <SPC> self . __lookup [ M <SPC> - <SPC> 1 ] <SPC> + <SPC> dayOfMonth ( M ) <NL> <NL> <TAB> def <SPC> dayOfYear ( self , <SPC> date ) : <NL> <NL> <TAB> Y , <SPC> M , <SPC> D <SPC> = <SPC> map ( int , <SPC> date . split ( "-" ) ) <NL> <TAB> leap <SPC> = <SPC> ( <NL>          1 <SPC> if <SPC> M <SPC> > <SPC> 2 <SPC> and <SPC> ( ( ( Y <SPC> % <SPC> 4 <SPC> == <SPC> 0 ) <SPC> and <SPC> ( Y <SPC> % <SPC> 100 <SPC> != <SPC> 0 ) ) <NL>                          or <SPC> ( Y <SPC> % <SPC> 400 <SPC> == <SPC> 0 ) ) <SPC> else <SPC> 0 <NL> <TAB> ) <NL> <TAB> return <SPC> self . __lookup [ M <SPC> - <SPC> 1 ] <SPC> + <SPC> D <SPC> + <SPC> leap <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> dayOfYear ( self , <SPC> date ) : <NL> <NL> <TAB> def <SPC> numberOfDays ( Y , <SPC> M ) : <NL>          leap <SPC> = <SPC> 1 <SPC> if <SPC> ( ( Y <SPC> % <SPC> 4 <SPC> == <SPC> 0 ) <SPC> and <SPC> ( Y <SPC> % <SPC> 100 <SPC> != <SPC> 0 ) ) <SPC> or <SPC> ( Y <SPC> % <SPC> 400 <SPC> == <SPC> 0 ) <SPC> else <SPC> 0 <NL>          return <SPC> 28 <SPC> + <SPC> leap <SPC> if <SPC> ( M <SPC> == <SPC> 2 ) <SPC> else <SPC> 31 <SPC> - <SPC> ( M <SPC> - <SPC> 1 ) <SPC> % <SPC> 7 <SPC> % <SPC> 2 <NL> <NL> <TAB> Y , <SPC> M , <SPC> result <SPC> = <SPC> map ( int , <SPC> date . split ( "-" ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> M ) : <NL>          result <SPC> += <SPC> numberOfDays ( Y , <SPC> i ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> decodeString ( self , <SPC> s ) : <NL> <NL> <TAB> n , <SPC> curr , <SPC> nums , <SPC> strs <SPC> = <SPC> 0 , <SPC> [ ] , <SPC> [ ] , <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          if <SPC> c . isdigit ( ) : <NL>              n <SPC> = <SPC> n <SPC> * <SPC> 10 <SPC> + <SPC> ord ( c ) <SPC> - <SPC> ord ( "0" ) <NL>          elif <SPC> c . isalpha ( ) : <NL>              curr . append ( c ) <NL>          elif <SPC> c <SPC> == <SPC> "[" : <NL>              nums . append ( n ) <NL>              strs . append ( curr ) <NL>              n , <SPC> curr <SPC> = <SPC> 0 , <SPC> [ ] <NL>          elif <SPC> c <SPC> == <SPC> "]" : <NL>              strs [ - 1 ] . extend ( curr <SPC> * <SPC> nums . pop ( ) ) <NL>              curr <SPC> = <SPC> strs . pop ( ) <NL> <TAB> return <SPC> "" . join ( curr ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numDecodings ( self , <SPC> s ) : <NL> <NL> <TAB> M , <SPC> W <SPC> = <SPC> 1000000007 , <SPC> 3 <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> W <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> dp [ 1 ] <SPC> = <SPC> 9 <SPC> if <SPC> s [ 0 ] <SPC> == <SPC> "*" <SPC> else <SPC> dp [ 0 ] <SPC> if <SPC> s [ 0 ] <SPC> != <SPC> "0" <SPC> else <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) ) : <NL>          if <SPC> s [ i ] <SPC> == <SPC> "*" : <NL>              dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> = <SPC> 9 <SPC> * <SPC> dp [ i <SPC> % <SPC> W ] <NL>              if <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "1" : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> = <SPC> ( dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> + <SPC> 9 <SPC> * <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> W ] ) <SPC> % <SPC> M <NL>              elif <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "2" : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> = <SPC> ( dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> + <SPC> 6 <SPC> * <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> W ] ) <SPC> % <SPC> M <NL>              elif <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "*" : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> = <SPC> ( dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> + <SPC> 15 <SPC> * <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> W ] ) <SPC> % <SPC> M <NL>          else : <NL>              dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> = <SPC> dp [ i <SPC> % <SPC> W ] <SPC> if <SPC> s [ i ] <SPC> != <SPC> "0" <SPC> else <SPC> 0 <NL>              if <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "1" : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> = <SPC> ( dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> + <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> W ] ) <SPC> % <SPC> M <NL>              elif <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "2" <SPC> and <SPC> s [ i ] <SPC> <= <SPC> "6" : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> = <SPC> ( dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> + <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> W ] ) <SPC> % <SPC> M <NL>              elif <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "*" : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> = <SPC> ( <NL>                      dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> W ] <SPC> + <SPC> ( 2 <SPC> if <SPC> s [ i ] <SPC> <= <NL>                                         "6" <SPC> else <SPC> 1 ) <SPC> * <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> W ] <NL>                  ) <SPC> % <SPC> M <NL> <TAB> return <SPC> dp [ len ( s ) <SPC> % <SPC> W ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numDecodings ( self , <SPC> s ) : <NL> <NL> <TAB> if <SPC> len ( s ) <SPC> == <SPC> 0 <SPC> or <SPC> s [ 0 ] <SPC> == <SPC> "0" : <NL>          return <SPC> 0 <NL> <TAB> prev , <SPC> prev_prev <SPC> = <SPC> 1 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          cur <SPC> = <SPC> 0 <NL>          if <SPC> s [ i ] <SPC> != <SPC> "0" : <NL>              cur <SPC> = <SPC> prev <NL>          if <SPC> i <SPC> > <SPC> 0 <SPC> and <SPC> ( s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "1" <SPC> or <SPC> ( s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "2" <SPC> and <SPC> s [ i ] <SPC> <= <SPC> "6" ) ) : <NL>              cur <SPC> += <SPC> prev_prev <NL>          prev , <SPC> prev_prev <SPC> = <SPC> cur , <SPC> prev <NL> <TAB> return <SPC> prev <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> decode ( self , <SPC> encoded , <SPC> first ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ first ] <NL> <TAB> for <SPC> x <SPC> in <SPC> encoded : <NL>          result . append ( result [ - 1 ] <SPC> ^ <SPC> x ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> decode ( self , <SPC> encoded ) : <NL> <NL> <TAB> curr <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( ( len ( encoded ) <SPC> + <SPC> 1 ) <SPC> + <SPC> 1 ) : <NL>          curr <SPC> ^= <SPC> i <NL>          if <SPC> i <SPC> <= <SPC> len ( encoded ) <SPC> and <SPC> i <SPC> % <SPC> 2 <SPC> == <SPC> 1 : <NL>              curr <SPC> ^= <SPC> encoded [ i ] <NL> <TAB> result <SPC> = <SPC> [ curr ] <NL> <TAB> for <SPC> x <SPC> in <SPC> encoded : <NL>          result . append ( result [ - 1 ] <SPC> ^ <SPC> x ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> decodeAtIndex ( self , <SPC> S , <SPC> K ) : <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          if <SPC> c . isdigit ( ) : <NL>              i <SPC> *= <SPC> int ( c ) <NL>          else : <NL>              i <SPC> += <SPC> 1 <NL> <NL> <TAB> for <SPC> c <SPC> in <SPC> reversed ( S ) : <NL>          K <SPC> %= <SPC> i <NL>          if <SPC> K <SPC> == <SPC> 0 <SPC> and <SPC> c . isalpha ( ) : <NL>              return <SPC> c <NL> <NL>          if <SPC> c . isdigit ( ) : <NL>              i <SPC> /= <SPC> int ( c ) <NL>          else : <NL>              i <SPC> -= <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> decompressRLElist ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> [ nums [ i <SPC> + <SPC> 1 ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( 0 , <SPC> len ( nums ) , <SPC> 2 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( nums [ i ] ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> movesToMakeZigzag ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 , <SPC> 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          left <SPC> = <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> if <SPC> i <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <SPC> else <SPC> float ( "inf" ) <NL>          right <SPC> = <SPC> nums [ i <SPC> + <SPC> 1 ] <SPC> if <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( nums ) <SPC> else <SPC> float ( "inf" ) <NL>          result [ i <SPC> % <SPC> 2 ] <SPC> += <SPC> max ( nums [ i ] <SPC> - <SPC> min ( left , <SPC> right ) <SPC> + <SPC> 1 , <SPC> 0 ) <NL> <TAB> return <SPC> min ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> freqAlphabets ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> alpha ( num ) : <NL>          return <SPC> chr ( ord ( "a" ) <SPC> + <SPC> int ( num ) <SPC> - <SPC> 1 ) <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( s ) : <NL>          if <SPC> i <SPC> + <SPC> 2 <SPC> < <SPC> len ( s ) <SPC> and <SPC> s [ i <SPC> + <SPC> 2 ] <SPC> == <SPC> "#" : <NL>              result . append ( alpha ( s [ i : <SPC> i <SPC> + <SPC> 2 ] ) ) <NL>              i <SPC> += <SPC> 3 <NL>          else : <NL>              result . append ( alpha ( s [ i ] ) ) <NL>              i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> freqAlphabets ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> alpha ( num ) : <NL>          return <SPC> chr ( ord ( "a" ) <SPC> + <SPC> int ( num ) <SPC> - <SPC> 1 ) <NL> <NL> <TAB> i <SPC> = <SPC> len ( s ) <SPC> - <SPC> 1 <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> i <SPC> >= <SPC> 0 : <NL>          if <SPC> s [ i ] <SPC> == <SPC> "#" : <NL>              result . append ( alpha ( s [ i <SPC> - <SPC> 2 : <SPC> i ] ) ) <NL>              i <SPC> -= <SPC> 3 <NL>          else : <NL>              result . append ( alpha ( s [ i ] ) ) <NL>              i <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> "" . join ( reversed ( result ) ) <NL> <NL> <NL> import <SPC> re <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> freqAlphabets ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> alpha ( num ) : <NL>          return <SPC> chr ( ord ( "a" ) <SPC> + <SPC> int ( num ) <SPC> - <SPC> 1 ) <NL> <NL> <TAB> return <SPC> "" . join ( alpha ( i [ : 2 ] ) <SPC> for <SPC> i <SPC> in <SPC> re . findall ( r"\d\d#|\d" , <SPC> s ) ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> deepestLeavesSum ( self , <SPC> root ) : <NL> <NL> <TAB> curr <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> curr : <NL>          prev , <SPC> curr <SPC> = <SPC> curr , <SPC> [ <NL>              child <SPC> for <SPC> p <SPC> in <SPC> curr <SPC> for <SPC> child <SPC> in <SPC> [ p . left , <SPC> p . right ] <SPC> if <SPC> child <NL>          ] <NL> <TAB> return <SPC> sum ( node . val <SPC> for <SPC> node <SPC> in <SPC> prev ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> defangIPaddr ( self , <SPC> address ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> address : <NL>          if <SPC> c <SPC> == <SPC> "." : <NL>              result . append ( "[.]" ) <NL>          else : <NL>              result . append ( c ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> decrypt ( self , <SPC> code , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( code ) <NL> <TAB> if <SPC> k <SPC> == <SPC> 0 : <NL>          return <SPC> result <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> k <NL> <TAB> if <SPC> k <SPC> < <SPC> 0 : <NL>          k <SPC> = <SPC> - k <NL>          left , <SPC> right <SPC> = <SPC> len ( code ) <SPC> - <SPC> k , <SPC> len ( code ) <SPC> - <SPC> 1 <NL> <TAB> total <SPC> = <SPC> sum ( code [ i ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right <SPC> + <SPC> 1 ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( code ) ) : <NL>          result [ i ] <SPC> = <SPC> total <NL>          total <SPC> -= <SPC> code [ left <SPC> % <SPC> len ( code ) ] <NL>          total <SPC> += <SPC> code [ ( right <SPC> + <SPC> 1 ) <SPC> % <SPC> len ( code ) ] <NL>          left <SPC> += <SPC> 1 <NL>          right <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findShortestSubArray ( self , <SPC> nums ) : <NL> <NL> <TAB> counts <SPC> = <SPC> collections . Counter ( nums ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> { } , <SPC> { } <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          left . setdefault ( num , <SPC> i ) <NL>          right [ num ] <SPC> = <SPC> i <NL> <TAB> degree <SPC> = <SPC> max ( counts . values ( ) ) <NL> <TAB> return <SPC> min ( <NL>          right [ num ] <SPC> - <SPC> left [ num ] <SPC> + <SPC> 1 <SPC> for <SPC> num <SPC> in <SPC> counts . keys ( ) <SPC> if <SPC> counts [ num ] <SPC> == <SPC> degree <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> deleteAndEarn ( self , <SPC> nums ) : <NL> <NL> <TAB> vals <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 10001 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          vals [ num ] <SPC> += <SPC> num <NL> <TAB> val_i , <SPC> val_i_1 <SPC> = <SPC> vals [ 0 ] , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( vals ) ) : <NL>          val_i_1 , <SPC> val_i_2 <SPC> = <SPC> val_i , <SPC> val_i_1 <NL>          val_i <SPC> = <SPC> max ( vals [ i ] <SPC> + <SPC> val_i_2 , <SPC> val_i_1 ) <NL> <TAB> return <SPC> val_i <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDeletionSize ( self , <SPC> A ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> unsorted <SPC> = <SPC> set ( range ( len ( A ) <SPC> - <SPC> 1 ) ) <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( A [ 0 ] ) ) : <NL>          if <SPC> any ( A [ i ] [ j ] <SPC> > <SPC> A [ i <SPC> + <SPC> 1 ] [ j ] <SPC> for <SPC> i <SPC> in <SPC> unsorted ) : <NL>              result <SPC> += <SPC> 1 <NL>          else : <NL>              unsorted <SPC> -= <SPC> set ( i <SPC> for <SPC> i <SPC> in <SPC> unsorted <SPC> if <SPC> A [ i ] [ j ] <SPC> < <SPC> A [ i <SPC> + <SPC> 1 ] [ j ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minDeletionSize ( self , <SPC> A ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> is_sorted <SPC> = <SPC> [ False ] <SPC> * <SPC> ( len ( A ) <SPC> - <SPC> 1 ) <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( A [ 0 ] ) ) : <NL>          tmp <SPC> = <SPC> is_sorted [ : ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( A ) <SPC> - <SPC> 1 ) : <NL>              if <SPC> A [ i ] [ j ] <SPC> > <SPC> A [ i <SPC> + <SPC> 1 ] [ j ] <SPC> and <SPC> tmp [ i ] <SPC> == <SPC> False : <NL>                  result <SPC> += <SPC> 1 <NL>                  break <NL>              if <SPC> A [ i ] [ j ] <SPC> < <SPC> A [ i <SPC> + <SPC> 1 ] [ j ] : <NL>                  tmp [ i ] <SPC> = <SPC> True <NL>          else : <NL>              is_sorted <SPC> = <SPC> tmp <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDeletionSize ( self , <SPC> A ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 1 ] <SPC> * <SPC> len ( A [ 0 ] ) <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( A [ 0 ] ) ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( j ) : <NL>              if <SPC> all ( A [ k ] [ i ] <SPC> <= <SPC> A [ k ] [ j ] <SPC> for <SPC> k <SPC> in <SPC> xrange ( len ( A ) ) ) : <NL>                  dp [ j ] <SPC> = <SPC> max ( dp [ j ] , <SPC> dp [ i ] <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> len ( A [ 0 ] ) <SPC> - <SPC> max ( dp ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDeletionSize ( self , <SPC> A ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> xrange ( len ( A [ 0 ] ) ) : <NL>          for <SPC> r <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) ) : <NL>              if <SPC> A [ r <SPC> - <SPC> 1 ] [ c ] <SPC> > <SPC> A [ r ] [ c ] : <NL>                  result <SPC> += <SPC> 1 <NL>                  break <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minDeletionSize ( self , <SPC> A ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> col <SPC> in <SPC> itertools . izip ( * A ) : <NL>          if <SPC> any ( col [ i ] <SPC> > <SPC> col [ i <SPC> + <SPC> 1 ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( col ) <SPC> - <SPC> 1 ) ) : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeLeafNodes ( self , <SPC> root , <SPC> target ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> None <NL> <TAB> root . left <SPC> = <SPC> self . removeLeafNodes ( root . left , <SPC> target ) <NL> <TAB> root . right <SPC> = <SPC> self . removeLeafNodes ( root . right , <SPC> target ) <NL> <TAB> return <SPC> None <SPC> if <SPC> root . left <SPC> == <SPC> root . right <SPC> and <SPC> root . val <SPC> == <SPC> target <SPC> else <SPC> root <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> next = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . next <SPC> = <SPC> next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> deleteNodes ( self , <SPC> head , <SPC> m , <SPC> n ) : <NL> <NL> <TAB> head <SPC> = <SPC> dummy <SPC> = <SPC> ListNode ( next = head ) <NL> <TAB> while <SPC> head : <NL>          for <SPC> _ <SPC> in <SPC> xrange ( m ) : <NL>              if <SPC> not <SPC> head . next : <NL>                  return <SPC> dummy . next <NL>              head <SPC> = <SPC> head . next <NL>          prev <SPC> = <SPC> head <NL>          for <SPC> _ <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> not <SPC> head . next : <NL>                  prev . next <SPC> = <SPC> None <NL>                  return <SPC> dummy . next <NL>              head <SPC> = <SPC> head . next <NL>          prev . next <SPC> = <SPC> head . next <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> deleteNode ( self , <SPC> root , <SPC> key ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> root <NL> <NL> <TAB> if <SPC> root . val <SPC> > <SPC> key : <NL>          root . left <SPC> = <SPC> self . deleteNode ( root . left , <SPC> key ) <NL> <TAB> elif <SPC> root . val <SPC> < <SPC> key : <NL>          root . right <SPC> = <SPC> self . deleteNode ( root . right , <SPC> key ) <NL> <TAB> else : <NL>          if <SPC> not <SPC> root . left : <NL>              right <SPC> = <SPC> root . right <NL>              del <SPC> root <NL>              return <SPC> right <NL>          elif <SPC> not <SPC> root . right : <NL>              left <SPC> = <SPC> root . left <NL>              del <SPC> root <NL>              return <SPC> left <NL>          else : <NL>              successor <SPC> = <SPC> root . right <NL>              while <SPC> successor . left : <NL>                  successor <SPC> = <SPC> successor . left <NL> <NL>              root . val <SPC> = <SPC> successor . val <NL>              root . right <SPC> = <SPC> self . deleteNode ( root . right , <SPC> successor . val ) <NL> <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> deleteNode ( self , <SPC> node ) : <NL> <TAB> if <SPC> node <SPC> and <SPC> node . next : <NL>          node_to_delete <SPC> = <SPC> node . next <NL>          node . val <SPC> = <SPC> node_to_delete . val <NL>          node . next <SPC> = <SPC> node_to_delete . next <NL>          del <SPC> node_to_delete <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> delNodes ( self , <SPC> root , <SPC> to_delete ) : <NL> <NL> <TAB> def <SPC> delNodesHelper ( to_delete_set , <SPC> root , <SPC> is_root , <SPC> result ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> None <NL>          is_deleted <SPC> = <SPC> root . val <SPC> in <SPC> to_delete_set <NL>          if <SPC> is_root <SPC> and <SPC> not <SPC> is_deleted : <NL>              result . append ( root ) <NL>          root . left <SPC> = <SPC> delNodesHelper ( <NL>              to_delete_set , <SPC> root . left , <SPC> is_deleted , <SPC> result ) <NL>          root . right <SPC> = <SPC> delNodesHelper ( <NL>              to_delete_set , <SPC> root . right , <SPC> is_deleted , <SPC> result ) <NL>          return <SPC> None <SPC> if <SPC> is_deleted <SPC> else <SPC> root <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> to_delete_set <SPC> = <SPC> set ( to_delete ) <NL> <TAB> delNodesHelper ( to_delete_set , <SPC> root , <SPC> True , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDistance ( self , <SPC> word1 , <SPC> word2 ) : <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( word1 ) , <SPC> len ( word2 ) <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> max ( <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] , <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> + <SPC> ( word1 [ i ] <SPC> == <SPC> word2 [ j ] ) , <NL>              ) <NL> <TAB> return <SPC> m <SPC> + <SPC> n <SPC> - <SPC> 2 <SPC> * <SPC> dp [ m <SPC> % <SPC> 2 ] [ n ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> deleteTreeNodes ( self , <SPC> nodes , <SPC> parent , <SPC> value ) : <NL> <NL> <TAB> def <SPC> dfs ( value , <SPC> children , <SPC> x ) : <NL>          total , <SPC> count <SPC> = <SPC> value [ x ] , <SPC> 1 <NL>          for <SPC> y <SPC> in <SPC> children [ x ] : <NL>              t , <SPC> c <SPC> = <SPC> dfs ( value , <SPC> children , <SPC> y ) <NL>              total <SPC> += <SPC> t <NL>              count <SPC> += <SPC> c <SPC> if <SPC> t <SPC> else <SPC> 0 <NL>          return <SPC> total , <SPC> count <SPC> if <SPC> total <SPC> else <SPC> 0 <NL> <NL> <TAB> children <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> p <SPC> in <SPC> enumerate ( parent ) : <NL>          if <SPC> i : <NL>              children [ p ] . append ( i ) <NL> <TAB> return <SPC> dfs ( value , <SPC> children , <SPC> 0 ) [ 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> deleteTreeNodes ( self , <SPC> nodes , <SPC> parent , <SPC> value ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 1 ] <SPC> * <SPC> nodes <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> nodes ) ) : <NL>          value [ parent [ i ] ] <SPC> += <SPC> value [ i ] <NL>          result [ parent [ i ] ] <SPC> += <SPC> result [ i ] <SPC> if <SPC> value [ i ] <SPC> else <SPC> 0 <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> boxDelivering ( self , <SPC> boxes , <SPC> portsCount , <SPC> maxBoxes , <SPC> maxWeight ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( boxes ) <SPC> + <SPC> 1 ) <NL> <TAB> left , <SPC> cost , <SPC> curr <SPC> = <SPC> 0 , <SPC> 1 , <SPC> 0 <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( boxes ) ) : <NL>          if <SPC> right <SPC> == <SPC> 0 <SPC> or <SPC> boxes [ right ] [ 0 ] <SPC> != <SPC> boxes [ right <SPC> - <SPC> 1 ] [ 0 ] : <NL>              cost <SPC> += <SPC> 1 <NL>          curr <SPC> += <SPC> boxes [ right ] [ 1 ] <NL>          while <SPC> ( <NL>              right <SPC> - <SPC> left <SPC> + <SPC> 1 <SPC> > <SPC> maxBoxes <NL>              or <SPC> curr <SPC> > <SPC> maxWeight <NL>              or <SPC> ( left <SPC> + <SPC> 1 <SPC> < <SPC> right <SPC> + <SPC> 1 <SPC> and <SPC> dp [ left <SPC> + <SPC> 1 ] <SPC> == <SPC> dp [ left ] ) <NL>          ) : <NL>              curr <SPC> -= <SPC> boxes [ left ] [ 1 ] <NL>              if <SPC> boxes [ left <SPC> + <SPC> 1 ] [ 0 ] <SPC> != <SPC> boxes [ left ] [ 0 ] : <NL>                  cost <SPC> -= <SPC> 1 <NL>              left <SPC> += <SPC> 1 <NL>          dp [ right <SPC> + <SPC> 1 ] <SPC> = <SPC> dp [ ( left <SPC> - <SPC> 1 ) <SPC> + <SPC> 1 ] <SPC> + <SPC> cost <NL> <TAB> return <SPC> dp [ len ( boxes ) ] <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> FileSharing ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> m ) : <NL> <NL> <TAB> self . __users <SPC> = <SPC> [ ] <NL> <TAB> self . __lookup <SPC> = <SPC> set ( ) <NL> <TAB> self . __min_heap <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> join ( self , <SPC> ownedChunks ) : <NL> <NL> <TAB> if <SPC> self . __min_heap : <NL>          userID <SPC> = <SPC> heapq . heappop ( self . __min_heap ) <NL> <TAB> else : <NL>          userID <SPC> = <SPC> len ( self . __users ) <SPC> + <SPC> 1 <NL>          self . __users . append ( set ( ) ) <NL> <TAB> self . __users [ userID <SPC> - <SPC> 1 ] <SPC> = <SPC> set ( ownedChunks ) <NL> <TAB> self . __lookup . add ( userID ) <NL> <TAB> return <SPC> userID <NL> <NL> <TAB> def <SPC> leave ( self , <SPC> userID ) : <NL> <NL> <TAB> if <SPC> userID <SPC> not <SPC> in <SPC> self . __lookup : <NL>          return <NL> <TAB> self . __lookup . remove ( userID ) <NL> <TAB> self . __users [ userID <SPC> - <SPC> 1 ] <SPC> = <SPC> [ ] <NL> <TAB> heapq . heappush ( self . __min_heap , <SPC> userID ) <NL> <NL> <TAB> def <SPC> request ( self , <SPC> userID , <SPC> chunkID ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> u , <SPC> chunks <SPC> in <SPC> enumerate ( self . __users , <SPC> 1 ) : <NL>          if <SPC> chunkID <SPC> not <SPC> in <SPC> chunks : <NL>              continue <NL>          result . append ( u ) <NL> <TAB> if <SPC> not <SPC> result : <NL>          return <NL> <TAB> self . __users [ userID <SPC> - <SPC> 1 ] . add ( chunkID ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> FileSharing2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> m ) : <NL> <NL> <TAB> self . __users <SPC> = <SPC> [ ] <NL> <TAB> self . __lookup <SPC> = <SPC> set ( ) <NL> <TAB> self . __chunks <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> self . __min_heap <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> join ( self , <SPC> ownedChunks ) : <NL> <NL> <TAB> if <SPC> self . __min_heap : <NL>          userID <SPC> = <SPC> heapq . heappop ( self . __min_heap ) <NL> <TAB> else : <NL>          userID <SPC> = <SPC> len ( self . __users ) <SPC> + <SPC> 1 <NL>          self . __users . append ( set ( ) ) <NL> <TAB> self . __users [ userID <SPC> - <SPC> 1 ] <SPC> = <SPC> set ( ownedChunks ) <NL> <TAB> self . __lookup . add ( userID ) <NL> <TAB> for <SPC> c <SPC> in <SPC> ownedChunks : <NL>          self . __chunks [ c ] . add ( userID ) <NL> <TAB> return <SPC> userID <NL> <NL> <TAB> def <SPC> leave ( self , <SPC> userID ) : <NL> <NL> <TAB> if <SPC> userID <SPC> not <SPC> in <SPC> self . __lookup : <NL>          return <NL> <TAB> for <SPC> c <SPC> in <SPC> self . __users [ userID <SPC> - <SPC> 1 ] : <NL>          self . __chunks [ c ] . remove ( userID ) <NL> <TAB> self . __lookup . remove ( userID ) <NL> <TAB> self . __users [ userID <SPC> - <SPC> 1 ] <SPC> = <SPC> [ ] <NL> <TAB> heapq . heappush ( self . __min_heap , <SPC> userID ) <NL> <NL> <TAB> def <SPC> request ( self , <SPC> userID , <SPC> chunkID ) : <NL> <NL> <TAB> result <SPC> = <SPC> sorted ( self . __chunks [ chunkID ] ) <NL> <TAB> if <SPC> not <SPC> result : <NL>          return <NL> <TAB> self . __users [ userID <SPC> - <SPC> 1 ] . add ( chunkID ) <NL> <TAB> self . __chunks [ chunkID ] . add ( userID ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Leaderboard ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __lookup <SPC> = <SPC> collections . Counter ( ) <NL> <NL> <TAB> def <SPC> addScore ( self , <SPC> playerId , <SPC> score ) : <NL> <NL> <TAB> self . __lookup [ playerId ] <SPC> += <SPC> score <NL> <NL> <TAB> def <SPC> top ( self , <SPC> K ) : <NL> <NL> <TAB> def <SPC> kthElement ( nums , <SPC> k , <SPC> compare ) : <NL>          def <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare ) : <NL>              new_pivot_idx <SPC> = <SPC> left <NL>              nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>                  if <SPC> compare ( nums [ i ] , <SPC> nums [ right ] ) : <NL>                      nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                      new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>              nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>              return <SPC> new_pivot_idx <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> PartitionAroundPivot ( <NL>                  left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare <NL>              ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> k : <NL>                  return <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> k : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> scores <SPC> = <SPC> self . __lookup . values ( ) <NL> <TAB> kthElement ( scores , <SPC> K , <SPC> lambda <SPC> a , <SPC> b : <SPC> a <SPC> > <SPC> b ) <NL> <TAB> return <SPC> sum ( scores [ : K ] ) <NL> <NL> <TAB> def <SPC> reset ( self , <SPC> playerId ) : <NL> <NL> <TAB> self . __lookup [ playerId ] <SPC> = <SPC> 0 <NL> <NL> <NL> class <SPC> CustomStack ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> maxSize ) : <NL> <NL> <TAB> self . __max_size <SPC> = <SPC> maxSize <NL> <TAB> self . __stk <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <NL> <TAB> if <SPC> len ( self . __stk ) <SPC> == <SPC> self . __max_size : <NL>          return <NL> <TAB> self . __stk . append ( [ x , <SPC> 0 ] ) <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <NL> <TAB> if <SPC> not <SPC> self . __stk : <NL>          return <SPC> - 1 <NL> <TAB> x , <SPC> inc <SPC> = <SPC> self . __stk . pop ( ) <NL> <TAB> if <SPC> self . __stk : <NL>          self . __stk [ - 1 ] [ 1 ] <SPC> += <SPC> inc <NL> <TAB> return <SPC> x <SPC> + <SPC> inc <NL> <NL> <TAB> def <SPC> increment ( self , <SPC> k , <SPC> val ) : <NL> <NL> <TAB> i <SPC> = <SPC> min ( len ( self . __stk ) , <SPC> k ) <SPC> - <SPC> 1 <NL> <TAB> if <SPC> i <SPC> >= <SPC> 0 : <NL>          self . __stk [ i ] [ 1 ] <SPC> += <SPC> val <NL> <NL> <NL> import <SPC> abc <NL> from <SPC> abc <SPC> import <SPC> ABCMeta , <SPC> abstractmethod <NL> <NL> <NL> class <SPC> Node : <NL> <TAB> __metaclass__ <SPC> = <SPC> ABCMeta <NL> <NL> <TAB> @ abstractmethod <NL> <TAB> def <SPC> evaluate ( self ) : <NL> <TAB> pass <NL> <NL> <NL> import <SPC> operator <NL> <NL> <NL> class <SPC> NodeIter ( Node ) : <NL> <TAB> ops <SPC> = <SPC> { "+" : <SPC> operator . add , <SPC> "-" : <SPC> operator . sub , <NL>             "*" : <SPC> operator . mul , <SPC> "/" : <SPC> operator . div } <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> val ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> evaluate ( self ) : <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> stk <SPC> = <SPC> [ ( 1 , <SPC> ( self , <SPC> result ) ) ] <NL> <TAB> while <SPC> stk : <NL>          step , <SPC> args <SPC> = <SPC> stk . pop ( ) <NL>          if <SPC> step <SPC> == <SPC> 1 : <NL>              node , <SPC> ret <SPC> = <SPC> args <NL>              if <SPC> node . val . isdigit ( ) : <NL>                  ret [ 0 ] <SPC> = <SPC> int ( node . val ) <NL>                  continue <NL>              ret1 , <SPC> ret2 <SPC> = <SPC> [ 0 ] , <SPC> [ 0 ] <NL>              stk . append ( ( 2 , <SPC> ( node , <SPC> ret1 , <SPC> ret2 , <SPC> ret ) ) ) <NL>              stk . append ( ( 1 , <SPC> ( node . right , <SPC> ret2 ) ) ) <NL>              stk . append ( ( 1 , <SPC> ( node . left , <SPC> ret1 ) ) ) <NL>          elif <SPC> step <SPC> == <SPC> 2 : <NL>              node , <SPC> ret1 , <SPC> ret2 , <SPC> ret <SPC> = <SPC> args <NL>              ret [ 0 ] <SPC> = <SPC> NodeIter . ops [ node . val ] ( ret1 [ 0 ] , <SPC> ret2 [ 0 ] ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> TreeBuilder ( object ) : <NL> <TAB> def <SPC> buildTree ( self , <SPC> postfix ) : <NL> <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> postfix : <NL>          if <SPC> c . isdigit ( ) : <NL>              stk . append ( NodeIter ( c ) ) <NL>          else : <NL>              node <SPC> = <SPC> NodeIter ( c ) <NL>              node . right <SPC> = <SPC> stk . pop ( ) <NL>              node . left <SPC> = <SPC> stk . pop ( ) <NL>              stk . append ( node ) <NL> <TAB> return <SPC> stk . pop ( ) <NL> <NL> <NL> class <SPC> NodeRecu ( Node ) : <NL> <TAB> ops <SPC> = <SPC> { "+" : <SPC> operator . add , <SPC> "-" : <SPC> operator . sub , <NL>             "*" : <SPC> operator . mul , <SPC> "/" : <SPC> operator . div } <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> val ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> evaluate ( self ) : <NL> <TAB> if <SPC> self . val . isdigit ( ) : <NL>          return <SPC> int ( self . val ) <NL> <TAB> return <SPC> NodeRecu . ops [ self . val ] ( self . left . evaluate ( ) , <SPC> self . right . evaluate ( ) ) <NL> <NL> <NL> class <SPC> TreeBuilder2 ( object ) : <NL> <TAB> def <SPC> buildTree ( self , <SPC> postfix ) : <NL> <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> postfix : <NL>          if <SPC> c . isdigit ( ) : <NL>              stk . append ( NodeRecu ( c ) ) <NL>          else : <NL>              node <SPC> = <SPC> NodeRecu ( c ) <NL>              node . right <SPC> = <SPC> stk . pop ( ) <NL>              node . left <SPC> = <SPC> stk . pop ( ) <NL>              stk . append ( node ) <NL> <TAB> return <SPC> stk . pop ( ) <NL> <NL> <NL> class <SPC> OrderedStream ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <NL> <TAB> self . __i <SPC> = <SPC> 0 <NL> <TAB> self . __values <SPC> = <SPC> [ None ] <SPC> * <SPC> n <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> id , <SPC> value ) : <NL> <NL> <TAB> id <SPC> -= <SPC> 1 <NL> <TAB> self . __values [ id ] <SPC> = <SPC> value <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> self . __i <SPC> != <SPC> id : <NL>          return <SPC> result <NL> <TAB> while <SPC> self . __i <SPC> < <SPC> len ( self . __values ) <SPC> and <SPC> self . __values [ self . __i ] : <NL>          result . append ( self . __values [ self . __i ] ) <NL>          self . __i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> threading <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> BoundedBlockingQueue ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> capacity ) : <NL> <NL> <TAB> self . __cv <SPC> = <SPC> threading . Condition ( ) <NL> <TAB> self . __q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> self . __cap <SPC> = <SPC> capacity <NL> <NL> <TAB> def <SPC> enqueue ( self , <SPC> element ) : <NL> <NL> <TAB> with <SPC> self . __cv : <NL>          while <SPC> len ( self . __q ) <SPC> == <SPC> self . __cap : <NL>              self . __cv . wait ( ) <NL>          self . __q . append ( element ) <NL>          self . __cv . notifyAll ( ) <NL> <NL> <TAB> def <SPC> dequeue ( self ) : <NL> <NL> <TAB> with <SPC> self . __cv : <NL>          while <SPC> not <SPC> self . __q : <NL>              self . __cv . wait ( ) <NL>          self . __cv . notifyAll ( ) <NL>          return <SPC> self . __q . popleft ( ) <NL> <NL> <TAB> def <SPC> size ( self ) : <NL> <NL> <TAB> with <SPC> self . __cv : <NL>          return <SPC> len ( self . __q ) <NL> <NL> <NL> class <SPC> BrowserHistory ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> homepage ) : <NL> <NL> <TAB> self . __history <SPC> = <SPC> [ homepage ] <NL> <TAB> self . __curr <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> visit ( self , <SPC> url ) : <NL> <NL> <TAB> while <SPC> len ( self . __history ) <SPC> > <SPC> self . __curr <SPC> + <SPC> 1 : <NL>          self . __history . pop ( ) <NL> <TAB> self . __history . append ( url ) <NL> <TAB> self . __curr <SPC> += <SPC> 1 <NL> <NL> <TAB> def <SPC> back ( self , <SPC> steps ) : <NL> <NL> <TAB> self . __curr <SPC> = <SPC> max ( self . __curr <SPC> - <SPC> steps , <SPC> 0 ) <NL> <TAB> return <SPC> self . __history [ self . __curr ] <NL> <NL> <TAB> def <SPC> forward ( self , <SPC> steps ) : <NL> <NL> <TAB> self . __curr <SPC> = <SPC> min ( self . __curr <SPC> + <SPC> steps , <SPC> len ( self . __history ) <SPC> - <SPC> 1 ) <NL> <TAB> return <SPC> self . __history [ self . __curr ] <NL> <NL> <NL> class <SPC> MyCircularDeque ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> k ) : <NL> <NL> <TAB> self . __start <SPC> = <SPC> 0 <NL> <TAB> self . __size <SPC> = <SPC> 0 <NL> <TAB> self . __buffer <SPC> = <SPC> [ 0 ] <SPC> * <SPC> k <NL> <NL> <TAB> def <SPC> insertFront ( self , <SPC> value ) : <NL> <NL> <TAB> if <SPC> self . isFull ( ) : <NL>          return <SPC> False <NL> <TAB> self . __start <SPC> = <SPC> ( self . __start <SPC> - <SPC> 1 ) <SPC> % <SPC> len ( self . __buffer ) <NL> <TAB> self . __buffer [ self . __start ] <SPC> = <SPC> value <NL> <TAB> self . __size <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> insertLast ( self , <SPC> value ) : <NL> <NL> <TAB> if <SPC> self . isFull ( ) : <NL>          return <SPC> False <NL> <TAB> self . __buffer [ ( self . __start <SPC> + <SPC> self . __size ) <SPC> % <SPC> len ( self . __buffer ) ] <SPC> = <SPC> value <NL> <TAB> self . __size <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> deleteFront ( self ) : <NL> <NL> <TAB> if <SPC> self . isEmpty ( ) : <NL>          return <SPC> False <NL> <TAB> self . __start <SPC> = <SPC> ( self . __start <SPC> + <SPC> 1 ) <SPC> % <SPC> len ( self . __buffer ) <NL> <TAB> self . __size <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> deleteLast ( self ) : <NL> <NL> <TAB> if <SPC> self . isEmpty ( ) : <NL>          return <SPC> False <NL> <TAB> self . __size <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> getFront ( self ) : <NL> <NL> <TAB> return <SPC> - 1 <SPC> if <SPC> self . isEmpty ( ) <SPC> else <SPC> self . __buffer [ self . __start ] <NL> <NL> <TAB> def <SPC> getRear ( self ) : <NL> <NL> <TAB> return <SPC> ( <NL>          - 1 <NL>          if <SPC> self . isEmpty ( ) <NL>          else <SPC> self . __buffer [ ( self . __start <SPC> + <SPC> self . __size <SPC> - <SPC> 1 ) <SPC> % <SPC> len ( self . __buffer ) ] <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> isEmpty ( self ) : <NL> <NL> <TAB> return <SPC> self . __size <SPC> == <SPC> 0 <NL> <NL> <TAB> def <SPC> isFull ( self ) : <NL> <NL> <TAB> return <SPC> self . __size <SPC> == <SPC> len ( self . __buffer ) <NL> <NL> <NL> class <SPC> MyCircularQueue ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> k ) : <NL> <NL> <TAB> self . __start <SPC> = <SPC> 0 <NL> <TAB> self . __size <SPC> = <SPC> 0 <NL> <TAB> self . __buffer <SPC> = <SPC> [ 0 ] <SPC> * <SPC> k <NL> <NL> <TAB> def <SPC> enQueue ( self , <SPC> value ) : <NL> <NL> <TAB> if <SPC> self . isFull ( ) : <NL>          return <SPC> False <NL> <TAB> self . __buffer [ ( self . __start <SPC> + <SPC> self . __size ) <SPC> % <SPC> len ( self . __buffer ) ] <SPC> = <SPC> value <NL> <TAB> self . __size <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> deQueue ( self ) : <NL> <NL> <TAB> if <SPC> self . isEmpty ( ) : <NL>          return <SPC> False <NL> <TAB> self . __start <SPC> = <SPC> ( self . __start <SPC> + <SPC> 1 ) <SPC> % <SPC> len ( self . __buffer ) <NL> <TAB> self . __size <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> Front ( self ) : <NL> <NL> <TAB> return <SPC> - 1 <SPC> if <SPC> self . isEmpty ( ) <SPC> else <SPC> self . __buffer [ self . __start ] <NL> <NL> <TAB> def <SPC> Rear ( self ) : <NL> <NL> <TAB> return <SPC> ( <NL>          - 1 <NL>          if <SPC> self . isEmpty ( ) <NL>          else <SPC> self . __buffer [ ( self . __start <SPC> + <SPC> self . __size <SPC> - <SPC> 1 ) <SPC> % <SPC> len ( self . __buffer ) ] <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> isEmpty ( self ) : <NL> <NL> <TAB> return <SPC> self . __size <SPC> == <SPC> 0 <NL> <NL> <TAB> def <SPC> isFull ( self ) : <NL> <NL> <TAB> return <SPC> self . __size <SPC> == <SPC> len ( self . __buffer ) <NL> <NL> <NL> import <SPC> re <NL> <NL> <NL> class <SPC> StringIterator ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> compressedString ) : <NL> <NL> <TAB> self . __result <SPC> = <SPC> re . findall ( r"([a-zA-Z])(\d+)" , <SPC> compressedString ) <NL> <TAB> self . __index , <SPC> self . __num , <SPC> self . __ch <SPC> = <SPC> 0 , <SPC> 0 , <SPC> " " <NL> <NL> <TAB> def <SPC> next ( self ) : <NL> <NL> <TAB> if <SPC> not <SPC> self . hasNext ( ) : <NL>          return <SPC> " " <NL> <TAB> if <SPC> self . __num <SPC> == <SPC> 0 : <NL>          self . __ch <SPC> = <SPC> self . __result [ self . __index ] [ 0 ] <NL>          self . __num <SPC> = <SPC> int ( self . __result [ self . __index ] [ 1 ] ) <NL>          self . __index <SPC> += <SPC> 1 <NL> <TAB> self . __num <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> self . __ch <NL> <NL> <TAB> def <SPC> hasNext ( self ) : <NL> <NL> <TAB> return <SPC> self . __index <SPC> != <SPC> len ( self . __result ) <SPC> or <SPC> self . __num <SPC> != <SPC> 0 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Excel ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> H , <SPC> W ) : <NL> <NL> <TAB> self . __exl <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( ord ( W ) <SPC> - <SPC> ord ( "A" ) <SPC> + <SPC> 1 ) ] <NL>                    for <SPC> _ <SPC> in <SPC> xrange ( H <SPC> + <SPC> 1 ) ] <NL> <TAB> self . __fward <SPC> = <SPC> collections . defaultdict ( <NL>          lambda : <SPC> collections . defaultdict ( int ) ) <NL> <TAB> self . __bward <SPC> = <SPC> collections . defaultdict ( set ) <NL> <NL> <TAB> def <SPC> set ( self , <SPC> r , <SPC> c , <SPC> v ) : <NL> <NL> <TAB> self . __reset_dependency ( r , <SPC> c ) <NL> <TAB> self . __update_others ( r , <SPC> c , <SPC> v ) <NL> <NL> <TAB> def <SPC> get ( self , <SPC> r , <SPC> c ) : <NL> <NL> <TAB> return <SPC> self . __exl [ r ] [ ord ( c ) <SPC> - <SPC> ord ( "A" ) ] <NL> <NL> <TAB> def <SPC> sum ( self , <SPC> r , <SPC> c , <SPC> strs ) : <NL> <NL> <TAB> self . __reset_dependency ( r , <SPC> c ) <NL> <TAB> result <SPC> = <SPC> self . __calc_and_update_dependency ( r , <SPC> c , <SPC> strs ) <NL> <TAB> self . __update_others ( r , <SPC> c , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> __reset_dependency ( self , <SPC> r , <SPC> c ) : <NL> <TAB> key <SPC> = <SPC> ( r , <SPC> c ) <NL> <TAB> if <SPC> key <SPC> in <SPC> self . __bward . keys ( ) : <NL>          for <SPC> k <SPC> in <SPC> self . __bward [ key ] : <NL>              self . __fward [ k ] . pop ( key , <SPC> None ) <NL>          self . __bward [ key ] <SPC> = <SPC> set ( ) <NL> <NL> <TAB> def <SPC> __calc_and_update_dependency ( self , <SPC> r , <SPC> c , <SPC> strs ) : <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> s <SPC> in <SPC> strs : <NL>          s , <SPC> e <SPC> = <SPC> s . split ( ":" ) [ 0 ] , <SPC> s . split ( ":" ) [ 1 ] <SPC> if <SPC> ":" <SPC> in <SPC> s <SPC> else <SPC> s <NL>          left , <SPC> right , <SPC> top , <SPC> bottom <SPC> = <SPC> ( <NL>              ord ( s [ 0 ] ) <SPC> - <SPC> ord ( "A" ) , <NL>              ord ( e [ 0 ] ) <SPC> - <SPC> ord ( "A" ) , <NL>              int ( s [ 1 : ] ) , <NL>              int ( e [ 1 : ] ) , <NL>          ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( top , <SPC> bottom <SPC> + <SPC> 1 ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( left , <SPC> right <SPC> + <SPC> 1 ) : <NL>                  result <SPC> += <SPC> self . __exl [ i ] [ j ] <NL>                  self . __fward [ ( i , <SPC> chr ( ord ( "A" ) <SPC> + <SPC> j ) ) ] [ ( r , <SPC> c ) ] <SPC> += <SPC> 1 <NL>                  self . __bward [ ( r , <SPC> c ) ] . add ( ( i , <SPC> chr ( ord ( "A" ) <SPC> + <SPC> j ) ) ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> __update_others ( self , <SPC> r , <SPC> c , <SPC> v ) : <NL> <TAB> prev <SPC> = <SPC> self . __exl [ r ] [ ord ( c ) <SPC> - <SPC> ord ( "A" ) ] <NL> <TAB> self . __exl [ r ] [ ord ( c ) <SPC> - <SPC> ord ( "A" ) ] <SPC> = <SPC> v <NL> <TAB> q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> q . append ( ( ( r , <SPC> c ) , <SPC> v <SPC> - <SPC> prev ) ) <NL> <TAB> while <SPC> q : <NL>          key , <SPC> diff <SPC> = <SPC> q . popleft ( ) <NL>          if <SPC> key <SPC> in <SPC> self . __fward : <NL>              for <SPC> k , <SPC> count <SPC> in <SPC> self . __fward [ key ] . iteritems ( ) : <NL>                  q . append ( ( k , <SPC> diff <SPC> * <SPC> count ) ) <NL>                  self . __exl [ k [ 0 ] ] [ ord ( k [ 1 ] ) <SPC> - <SPC> ord ( "A" ) ] <SPC> += <SPC> diff <SPC> * <SPC> count <NL> <NL> <NL> class <SPC> FileSystem ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __lookup <SPC> = <SPC> { "" : <SPC> - 1 } <NL> <NL> <TAB> def <SPC> create ( self , <SPC> path , <SPC> value ) : <NL> <NL> <TAB> if <SPC> path [ : <SPC> path . rfind ( "/" ) ] <SPC> not <SPC> in <SPC> self . __lookup : <NL>          return <SPC> False <NL> <TAB> self . __lookup [ path ] <SPC> = <SPC> value <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> get ( self , <SPC> path ) : <NL> <NL> <TAB> if <SPC> path <SPC> not <SPC> in <SPC> self . __lookup : <NL>          return <SPC> - 1 <NL> <TAB> return <SPC> self . __lookup [ path ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> FrontMiddleBackQueue ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __left , <SPC> self . __right <SPC> = <SPC> collections . deque ( ) , <SPC> collections . deque ( ) <NL> <NL> <TAB> def <SPC> pushFront ( self , <SPC> val ) : <NL> <NL> <TAB> self . __left . appendleft ( val ) <NL> <TAB> self . __balance ( ) <NL> <NL> <TAB> def <SPC> pushMiddle ( self , <SPC> val ) : <NL> <NL> <TAB> if <SPC> len ( self . __left ) <SPC> > <SPC> len ( self . __right ) : <NL>          self . __right . appendleft ( self . __left . pop ( ) ) <NL> <TAB> self . __left . append ( val ) <NL> <NL> <TAB> def <SPC> pushBack ( self , <SPC> val ) : <NL> <NL> <TAB> self . __right . append ( val ) <NL> <TAB> self . __balance ( ) <NL> <NL> <TAB> def <SPC> popFront ( self ) : <NL> <NL> <TAB> val <SPC> = <SPC> ( self . __left <SPC> or <SPC> collections . deque ( [ - 1 ] ) ) . popleft ( ) <NL> <TAB> self . __balance ( ) <NL> <TAB> return <SPC> val <NL> <NL> <TAB> def <SPC> popMiddle ( self ) : <NL> <NL> <TAB> val <SPC> = <SPC> ( self . __left <SPC> or <SPC> [ - 1 ] ) . pop ( ) <NL> <TAB> self . __balance ( ) <NL> <TAB> return <SPC> val <NL> <NL> <TAB> def <SPC> popBack ( self ) : <NL> <NL> <TAB> val <SPC> = <SPC> ( self . __right <SPC> or <SPC> self . __left <SPC> or <SPC> [ - 1 ] ) . pop ( ) <NL> <TAB> self . __balance ( ) <NL> <TAB> return <SPC> val <NL> <NL> <TAB> def <SPC> __balance ( self ) : <NL> <TAB> if <SPC> len ( self . __left ) <SPC> > <SPC> len ( self . __right ) <SPC> + <SPC> 1 : <NL>          self . __right . appendleft ( self . __left . pop ( ) ) <NL> <TAB> elif <SPC> len ( self . __left ) <SPC> < <SPC> len ( self . __right ) : <NL>          self . __left . append ( self . __right . popleft ( ) ) <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> key , <SPC> val ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . key <SPC> = <SPC> key <NL> <TAB> self . next <SPC> = <SPC> None <NL> <TAB> self . prev <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> LinkedList ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . head <SPC> = <SPC> None <NL> <TAB> self . tail <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> node ) : <NL> <TAB> node . next , <SPC> node . prev <SPC> = <SPC> None , <SPC> None <NL> <TAB> if <SPC> self . head <SPC> is <SPC> None : <NL>          self . head <SPC> = <SPC> node <NL> <TAB> else : <NL>          self . tail . next <SPC> = <SPC> node <NL>          node . prev <SPC> = <SPC> self . tail <NL> <TAB> self . tail <SPC> = <SPC> node <NL> <NL> <TAB> def <SPC> delete ( self , <SPC> node ) : <NL> <TAB> if <SPC> node . prev : <NL>          node . prev . next <SPC> = <SPC> node . next <NL> <TAB> else : <NL>          self . head <SPC> = <SPC> node . next <NL> <TAB> if <SPC> node . next : <NL>          node . next . prev <SPC> = <SPC> node . prev <NL> <TAB> else : <NL>          self . tail <SPC> = <SPC> node . prev <NL> <TAB> node . next , <SPC> node . prev <SPC> = <SPC> None , <SPC> None <NL> <NL> <TAB> def <SPC> find ( self , <SPC> key ) : <NL> <TAB> curr <SPC> = <SPC> self . head <NL> <TAB> while <SPC> curr : <NL>          if <SPC> curr . key <SPC> == <SPC> key : <NL>              break <NL>          curr <SPC> = <SPC> curr . next <NL> <TAB> return <SPC> curr <NL> <NL> <NL> class <SPC> MyHashMap ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . __data <SPC> = <SPC> [ LinkedList ( ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 10000 ) ] <NL> <NL> <TAB> def <SPC> put ( self , <SPC> key , <SPC> value ) : <NL> <NL> <TAB> l <SPC> = <SPC> self . __data [ key <SPC> % <SPC> len ( self . __data ) ] <NL> <TAB> node <SPC> = <SPC> l . find ( key ) <NL> <TAB> if <SPC> node : <NL>          node . val <SPC> = <SPC> value <NL> <TAB> else : <NL>          l . insert ( ListNode ( key , <SPC> value ) ) <NL> <NL> <TAB> def <SPC> get ( self , <SPC> key ) : <NL> <NL> <TAB> l <SPC> = <SPC> self . __data [ key <SPC> % <SPC> len ( self . __data ) ] <NL> <TAB> node <SPC> = <SPC> l . find ( key ) <NL> <TAB> if <SPC> node : <NL>          return <SPC> node . val <NL> <TAB> else : <NL>          return <SPC> - 1 <NL> <NL> <TAB> def <SPC> remove ( self , <SPC> key ) : <NL> <NL> <TAB> l <SPC> = <SPC> self . __data [ key <SPC> % <SPC> len ( self . __data ) ] <NL> <TAB> node <SPC> = <SPC> l . find ( key ) <NL> <TAB> if <SPC> node : <NL>          l . delete ( node ) <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> key , <SPC> val ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . key <SPC> = <SPC> key <NL> <TAB> self . next <SPC> = <SPC> None <NL> <TAB> self . prev <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> LinkedList ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . head <SPC> = <SPC> None <NL> <TAB> self . tail <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> node ) : <NL> <TAB> node . next , <SPC> node . prev <SPC> = <SPC> None , <SPC> None <NL> <TAB> if <SPC> self . head <SPC> is <SPC> None : <NL>          self . head <SPC> = <SPC> node <NL> <TAB> else : <NL>          self . tail . next <SPC> = <SPC> node <NL>          node . prev <SPC> = <SPC> self . tail <NL> <TAB> self . tail <SPC> = <SPC> node <NL> <NL> <TAB> def <SPC> delete ( self , <SPC> node ) : <NL> <TAB> if <SPC> node . prev : <NL>          node . prev . next <SPC> = <SPC> node . next <NL> <TAB> else : <NL>          self . head <SPC> = <SPC> node . next <NL> <TAB> if <SPC> node . next : <NL>          node . next . prev <SPC> = <SPC> node . prev <NL> <TAB> else : <NL>          self . tail <SPC> = <SPC> node . prev <NL> <TAB> node . next , <SPC> node . prev <SPC> = <SPC> None , <SPC> None <NL> <NL> <TAB> def <SPC> find ( self , <SPC> key ) : <NL> <TAB> curr <SPC> = <SPC> self . head <NL> <TAB> while <SPC> curr : <NL>          if <SPC> curr . key <SPC> == <SPC> key : <NL>              break <NL>          curr <SPC> = <SPC> curr . next <NL> <TAB> return <SPC> curr <NL> <NL> <NL> class <SPC> MyHashSet ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . __data <SPC> = <SPC> [ LinkedList ( ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 10000 ) ] <NL> <NL> <TAB> def <SPC> add ( self , <SPC> key ) : <NL> <NL> <TAB> l <SPC> = <SPC> self . __data [ key <SPC> % <SPC> len ( self . __data ) ] <NL> <TAB> node <SPC> = <SPC> l . find ( key ) <NL> <TAB> if <SPC> not <SPC> node : <NL>          l . insert ( ListNode ( key , <SPC> 0 ) ) <NL> <NL> <TAB> def <SPC> remove ( self , <SPC> key ) : <NL> <NL> <TAB> l <SPC> = <SPC> self . __data [ key <SPC> % <SPC> len ( self . __data ) ] <NL> <TAB> node <SPC> = <SPC> l . find ( key ) <NL> <TAB> if <SPC> node : <NL>          l . delete ( node ) <NL> <NL> <TAB> def <SPC> contains ( self , <SPC> key ) : <NL> <NL> <TAB> l <SPC> = <SPC> self . __data [ key <SPC> % <SPC> len ( self . __data ) ] <NL> <TAB> node <SPC> = <SPC> l . find ( key ) <NL> <TAB> return <SPC> node <SPC> is <SPC> not <SPC> None <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> deque <NL> <NL> <NL> class <SPC> HitCounter ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . __k <SPC> = <SPC> 300 <NL> <TAB> self . __dq <SPC> = <SPC> deque ( ) <NL> <TAB> self . __count <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> hit ( self , <SPC> timestamp ) : <NL> <NL> <TAB> self . getHits ( timestamp ) <NL> <TAB> if <SPC> self . __dq <SPC> and <SPC> self . __dq [ - 1 ] [ 0 ] <SPC> == <SPC> timestamp : <NL>          self . __dq [ - 1 ] [ 1 ] <SPC> += <SPC> 1 <NL> <TAB> else : <NL>          self . __dq . append ( [ timestamp , <SPC> 1 ] ) <NL> <TAB> self . __count <SPC> += <SPC> 1 <NL> <NL> <TAB> def <SPC> getHits ( self , <SPC> timestamp ) : <NL> <NL> <TAB> while <SPC> self . __dq <SPC> and <SPC> self . __dq [ 0 ] [ 0 ] <SPC> <= <SPC> timestamp <SPC> - <SPC> self . __k : <NL>          self . __count <SPC> -= <SPC> self . __dq . popleft ( ) [ 1 ] <NL> <TAB> return <SPC> self . __count <NL> <NL> <NL> class <SPC> TrieNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . is_file <SPC> = <SPC> False <NL> <TAB> self . children <SPC> = <SPC> { } <NL> <TAB> self . content <SPC> = <SPC> "" <NL> <NL> <NL> class <SPC> FileSystem ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __root <SPC> = <SPC> TrieNode ( ) <NL> <NL> <TAB> def <SPC> ls ( self , <SPC> path ) : <NL> <NL> <TAB> curr <SPC> = <SPC> self . __getNode ( path ) <NL> <NL> <TAB> if <SPC> curr . is_file : <NL>          return <SPC> [ self . __split ( path , <SPC> "/" ) [ - 1 ] ] <NL> <NL> <TAB> return <SPC> sorted ( curr . children . keys ( ) ) <NL> <NL> <TAB> def <SPC> mkdir ( self , <SPC> path ) : <NL> <NL> <TAB> curr <SPC> = <SPC> self . __putNode ( path ) <NL> <TAB> curr . is_file <SPC> = <SPC> False <NL> <NL> <TAB> def <SPC> addContentToFile ( self , <SPC> filePath , <SPC> content ) : <NL> <NL> <TAB> curr <SPC> = <SPC> self . __putNode ( filePath ) <NL> <TAB> curr . is_file <SPC> = <SPC> True <NL> <TAB> curr . content <SPC> += <SPC> content <NL> <NL> <TAB> def <SPC> readContentFromFile ( self , <SPC> filePath ) : <NL> <NL> <TAB> return <SPC> self . __getNode ( filePath ) . content <NL> <NL> <TAB> def <SPC> __getNode ( self , <SPC> path ) : <NL> <TAB> curr <SPC> = <SPC> self . __root <NL> <TAB> for <SPC> s <SPC> in <SPC> self . __split ( path , <SPC> "/" ) : <NL>          curr <SPC> = <SPC> curr . children [ s ] <NL> <TAB> return <SPC> curr <NL> <NL> <TAB> def <SPC> __putNode ( self , <SPC> path ) : <NL> <TAB> curr <SPC> = <SPC> self . __root <NL> <TAB> for <SPC> s <SPC> in <SPC> self . __split ( path , <SPC> "/" ) : <NL>          if <SPC> s <SPC> not <SPC> in <SPC> curr . children : <NL>              curr . children [ s ] <SPC> = <SPC> TrieNode ( ) <NL>          curr <SPC> = <SPC> curr . children [ s ] <NL> <TAB> return <SPC> curr <NL> <NL> <TAB> def <SPC> __split ( self , <SPC> path , <SPC> delim ) : <NL> <TAB> if <SPC> path <SPC> == <SPC> "/" : <NL>          return <SPC> [ ] <NL> <TAB> return <SPC> path . split ( "/" ) [ 1 : ] <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> value ) : <NL> <TAB> self . val <SPC> = <SPC> value <NL> <TAB> self . next <SPC> = <SPC> self . prev <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> MyLinkedList ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . __head <SPC> = <SPC> self . __tail <SPC> = <SPC> Node ( - 1 ) <NL> <TAB> self . __head . next <SPC> = <SPC> self . __tail <NL> <TAB> self . __tail . prev <SPC> = <SPC> self . __head <NL> <TAB> self . __size <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> get ( self , <SPC> index ) : <NL> <NL> <TAB> if <SPC> 0 <SPC> <= <SPC> index <SPC> <= <SPC> self . __size <SPC> // <SPC> 2 : <NL>          return <SPC> self . __forward ( 0 , <SPC> index , <SPC> self . __head . next ) . val <NL> <TAB> elif <SPC> self . __size <SPC> // <SPC> 2 <SPC> < <SPC> index <SPC> < <SPC> self . __size : <NL>          return <SPC> self . __backward ( self . __size , <SPC> index , <SPC> self . __tail ) . val <NL> <TAB> return <SPC> - 1 <NL> <NL> <TAB> def <SPC> addAtHead ( self , <SPC> val ) : <NL> <NL> <TAB> self . __add ( self . __head , <SPC> val ) <NL> <NL> <TAB> def <SPC> addAtTail ( self , <SPC> val ) : <NL> <NL> <TAB> self . __add ( self . __tail . prev , <SPC> val ) <NL> <NL> <TAB> def <SPC> addAtIndex ( self , <SPC> index , <SPC> val ) : <NL> <NL> <TAB> if <SPC> 0 <SPC> <= <SPC> index <SPC> <= <SPC> self . __size <SPC> // <SPC> 2 : <NL>          self . __add ( self . __forward ( 0 , <SPC> index , <SPC> self . __head . next ) . prev , <SPC> val ) <NL> <TAB> elif <SPC> self . __size <SPC> // <SPC> 2 <SPC> < <SPC> index <SPC> <= <SPC> self . __size : <NL>          self . __add ( self . __backward ( self . __size , <SPC> index , <SPC> self . __tail ) . prev , <SPC> val ) <NL> <NL> <TAB> def <SPC> deleteAtIndex ( self , <SPC> index ) : <NL> <NL> <TAB> if <SPC> 0 <SPC> <= <SPC> index <SPC> <= <SPC> self . __size <SPC> // <SPC> 2 : <NL>          self . __remove ( self . __forward ( 0 , <SPC> index , <SPC> self . __head . next ) ) <NL> <TAB> elif <SPC> self . __size <SPC> // <SPC> 2 <SPC> < <SPC> index <SPC> < <SPC> self . __size : <NL>          self . __remove ( self . __backward ( self . __size , <SPC> index , <SPC> self . __tail ) ) <NL> <NL> <TAB> def <SPC> __add ( self , <SPC> preNode , <SPC> val ) : <NL> <TAB> node <SPC> = <SPC> Node ( val ) <NL> <TAB> node . prev <SPC> = <SPC> preNode <NL> <TAB> node . next <SPC> = <SPC> preNode . next <NL> <TAB> node . prev . next <SPC> = <SPC> node . next . prev <SPC> = <SPC> node <NL> <TAB> self . __size <SPC> += <SPC> 1 <NL> <NL> <TAB> def <SPC> __remove ( self , <SPC> node ) : <NL> <TAB> node . prev . next <SPC> = <SPC> node . next <NL> <TAB> node . next . prev <SPC> = <SPC> node . prev <NL> <TAB> self . __size <SPC> -= <SPC> 1 <NL> <NL> <TAB> def <SPC> __forward ( self , <SPC> start , <SPC> end , <SPC> curr ) : <NL> <TAB> while <SPC> start <SPC> != <SPC> end : <NL>          start <SPC> += <SPC> 1 <NL>          curr <SPC> = <SPC> curr . next <NL> <TAB> return <SPC> curr <NL> <NL> <TAB> def <SPC> __backward ( self , <SPC> start , <SPC> end , <SPC> curr ) : <NL> <TAB> while <SPC> start <SPC> != <SPC> end : <NL>          start <SPC> -= <SPC> 1 <NL>          curr <SPC> = <SPC> curr . prev <NL> <TAB> return <SPC> curr <NL> <NL> <NL> class <SPC> LogSystem ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __logs <SPC> = <SPC> [ ] <NL> <TAB> self . __granularity <SPC> = <SPC> { <NL>          "Year" : <SPC> 4 , <NL>          "Month" : <SPC> 7 , <NL>          "Day" : <SPC> 10 , <NL>          "Hour" : <SPC> 13 , <NL>          "Minute" : <SPC> 16 , <NL>          "Second" : <SPC> 19 , <NL> <TAB> } <NL> <NL> <TAB> def <SPC> put ( self , <SPC> id , <SPC> timestamp ) : <NL> <NL> <TAB> self . __logs . append ( ( id , <SPC> timestamp ) ) <NL> <NL> <TAB> def <SPC> retrieve ( self , <SPC> s , <SPC> e , <SPC> gra ) : <NL> <NL> <TAB> i <SPC> = <SPC> self . __granularity [ gra ] <NL> <TAB> begin <SPC> = <SPC> s [ : i ] <NL> <TAB> end <SPC> = <SPC> e [ : i ] <NL> <TAB> return <SPC> sorted ( <NL>          id <SPC> for <SPC> id , <SPC> timestamp <SPC> in <SPC> self . __logs <SPC> if <SPC> begin <SPC> <= <SPC> timestamp [ : i ] <SPC> <= <SPC> end <NL> <TAB> ) <NL> <NL> <NL> from <SPC> sortedcontainers <SPC> import <SPC> SortedList <NL> <NL> <NL> class <SPC> MRUQueue ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <NL> <TAB> self . __sl <SPC> = <SPC> SortedList ( ( i <SPC> - <SPC> 1 , <SPC> i ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) ) <NL> <NL> <TAB> def <SPC> fetch ( self , <SPC> k ) : <NL> <NL> <TAB> last , <SPC> _ <SPC> = <SPC> self . __sl [ - 1 ] <NL> <TAB> _ , <SPC> val <SPC> = <SPC> self . __sl . pop ( k <SPC> - <SPC> 1 ) <NL> <TAB> self . __sl . add ( ( last <SPC> + <SPC> 1 , <SPC> val ) ) <NL> <TAB> return <SPC> val <NL> <NL> <NL> class <SPC> BIT ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> MAX_CALLS <SPC> = <SPC> 2000 <NL> <TAB> self . __bit <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> MAX_CALLS <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( self . __bit ) ) : <NL>          self . __bit [ i ] <SPC> = <SPC> ( 1 <SPC> if <SPC> i <SPC> - <SPC> 1 <SPC> < <SPC> n <SPC> else <SPC> 0 ) <SPC> + <SPC> self . __bit [ i <SPC> - <SPC> 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( self . __bit ) ) ) : <NL>          last_i <SPC> = <SPC> i <SPC> - <SPC> ( i <SPC> & <SPC> - i ) <NL>          self . __bit [ i ] <SPC> -= <SPC> self . __bit [ last_i ] <NL> <NL> <TAB> def <SPC> add ( self , <SPC> i , <SPC> val ) : <NL> <TAB> i <SPC> += <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( self . __bit ) : <NL>          self . __bit [ i ] <SPC> += <SPC> val <NL>          i <SPC> += <SPC> i <SPC> & <SPC> - i <NL> <NL> <TAB> def <SPC> query ( self , <SPC> i ) : <NL> <TAB> i <SPC> += <SPC> 1 <NL> <TAB> ret <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> > <SPC> 0 : <NL>          ret <SPC> += <SPC> self . __bit [ i ] <NL>          i <SPC> -= <SPC> i <SPC> & <SPC> - i <NL> <TAB> return <SPC> ret <NL> <NL> <TAB> def <SPC> binary_lift ( self , <SPC> k ) : <NL> <TAB> floor_log2_n <SPC> = <SPC> len ( self . __bit ) . bit_length ( ) <SPC> - <SPC> 1 <NL> <TAB> pow_i <SPC> = <SPC> 2 <SPC> ** <SPC> floor_log2_n <NL> <TAB> total <SPC> = <SPC> pos <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( floor_log2_n <SPC> + <SPC> 1 ) ) : <NL>          if <SPC> pos <SPC> + <SPC> pow_i <SPC> < <SPC> len ( self . __bit ) <SPC> and <SPC> not <SPC> ( <NL>              total <SPC> + <SPC> self . __bit [ pos <SPC> + <SPC> pow_i ] <SPC> >= <SPC> k <NL>          ) : <NL>              total <SPC> += <SPC> self . __bit [ pos <SPC> + <SPC> pow_i ] <NL>              pos <SPC> += <SPC> pow_i <NL>          pow_i <SPC> >>= <SPC> 1 <NL> <TAB> return <SPC> ( pos <SPC> + <SPC> 1 ) <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> MRUQueue2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <NL> <TAB> self . __bit <SPC> = <SPC> BIT ( n ) <NL> <TAB> self . __lookup <SPC> = <SPC> { i : <SPC> i <SPC> + <SPC> 1 <SPC> for <SPC> i <SPC> in <SPC> xrange ( n ) } <NL> <TAB> self . __curr <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> fetch ( self , <SPC> k ) : <NL> <NL> <TAB> pos <SPC> = <SPC> self . __bit . binary_lift ( k ) <NL> <TAB> val <SPC> = <SPC> self . __lookup . pop ( pos ) <NL> <TAB> self . __bit . add ( pos , <SPC> - 1 ) <NL> <TAB> self . __bit . add ( self . __curr , <SPC> 1 ) <NL> <TAB> self . __lookup [ self . __curr ] <SPC> = <SPC> val <NL> <TAB> self . __curr <SPC> += <SPC> 1 <NL> <TAB> return <SPC> val <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> math <NL> <NL> <NL> class <SPC> MRUQueue3 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <NL> <TAB> self . __buckets <SPC> = <SPC> [ collections . deque ( ) <NL>                        for <SPC> _ <SPC> in <SPC> xrange ( int ( math . ceil ( n <SPC> ** <SPC> 0.5 ) ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          self . __buckets [ i <SPC> // <SPC> len ( self . __buckets ) ] . append ( i <SPC> + <SPC> 1 ) <NL> <NL> <TAB> def <SPC> fetch ( self , <SPC> k ) : <NL> <NL> <TAB> k <SPC> -= <SPC> 1 <NL> <TAB> left , <SPC> idx <SPC> = <SPC> divmod ( k , <SPC> len ( self . __buckets ) ) <NL> <TAB> val <SPC> = <SPC> self . __buckets [ left ] [ idx ] <NL> <TAB> del <SPC> self . __buckets [ left ] [ idx ] <NL> <TAB> self . __buckets [ - 1 ] . append ( val ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( left , <SPC> len ( self . __buckets ) <SPC> - <SPC> 1 ) ) : <NL>          x <SPC> = <SPC> self . __buckets [ i <SPC> + <SPC> 1 ] . popleft ( ) <NL>          self . __buckets [ i ] . append ( x ) <NL> <TAB> return <SPC> val <NL> <NL> <NL> class <SPC> ParkingSystem ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> big , <SPC> medium , <SPC> small ) : <NL> <NL> <TAB> self . __space <SPC> = <SPC> [ 0 , <SPC> big , <SPC> medium , <SPC> small ] <NL> <NL> <TAB> def <SPC> addCar ( self , <SPC> carType ) : <NL> <NL> <TAB> if <SPC> self . __space [ carType ] <SPC> > <SPC> 0 : <NL>          self . __space [ carType ] <SPC> -= <SPC> 1 <NL>          return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> PhoneDirectory ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> maxNumbers ) : <NL> <NL> <TAB> self . __curr <SPC> = <SPC> 0 <NL> <TAB> self . __numbers <SPC> = <SPC> range ( maxNumbers ) <NL> <TAB> self . __used <SPC> = <SPC> [ False ] <SPC> * <SPC> maxNumbers <NL> <NL> <TAB> def <SPC> get ( self ) : <NL> <NL> <TAB> if <SPC> self . __curr <SPC> == <SPC> len ( self . __numbers ) : <NL>          return <SPC> - 1 <NL> <TAB> number <SPC> = <SPC> self . __numbers [ self . __curr ] <NL> <TAB> self . __curr <SPC> += <SPC> 1 <NL> <TAB> self . __used [ number ] <SPC> = <SPC> True <NL> <TAB> return <SPC> number <NL> <NL> <TAB> def <SPC> check ( self , <SPC> number ) : <NL> <NL> <TAB> return <SPC> 0 <SPC> <= <SPC> number <SPC> < <SPC> len ( self . __numbers ) <SPC> and <SPC> not <SPC> self . __used [ number ] <NL> <NL> <TAB> def <SPC> release ( self , <SPC> number ) : <NL> <NL> <TAB> if <SPC> not <SPC> 0 <SPC> <= <SPC> number <SPC> < <SPC> len ( self . __numbers ) <SPC> or <SPC> not <SPC> self . __used [ number ] : <NL>          return <NL> <TAB> self . __used [ number ] <SPC> = <SPC> False <NL> <TAB> self . __curr <SPC> -= <SPC> 1 <NL> <TAB> self . __numbers [ self . __curr ] <SPC> = <SPC> number <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> TrieNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __TOP_COUNT <SPC> = <SPC> 3 <NL> <TAB> self . infos <SPC> = <SPC> [ ] <NL> <TAB> self . leaves <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> s , <SPC> times ) : <NL> <TAB> cur <SPC> = <SPC> self <NL> <TAB> cur . add_info ( s , <SPC> times ) <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          if <SPC> c <SPC> not <SPC> in <SPC> cur . leaves : <NL>              cur . leaves [ c ] <SPC> = <SPC> TrieNode ( ) <NL>          cur <SPC> = <SPC> cur . leaves [ c ] <NL>          cur . add_info ( s , <SPC> times ) <NL> <NL> <TAB> def <SPC> add_info ( self , <SPC> s , <SPC> times ) : <NL> <TAB> for <SPC> p <SPC> in <SPC> self . infos : <NL>          if <SPC> p [ 1 ] <SPC> == <SPC> s : <NL>              p [ 0 ] <SPC> = <SPC> - times <NL>              break <NL> <TAB> else : <NL>          self . infos . append ( [ - times , <SPC> s ] ) <NL> <TAB> self . infos . sort ( ) <NL> <TAB> if <SPC> len ( self . infos ) <SPC> > <SPC> self . __TOP_COUNT : <NL>          self . infos . pop ( ) <NL> <NL> <NL> class <SPC> AutocompleteSystem ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> sentences , <SPC> times ) : <NL> <NL> <TAB> self . __trie <SPC> = <SPC> TrieNode ( ) <NL> <TAB> self . __cur_node <SPC> = <SPC> self . __trie <NL> <TAB> self . __search <SPC> = <SPC> [ ] <NL> <TAB> self . __sentence_to_count <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> sentence , <SPC> count <SPC> in <SPC> zip ( sentences , <SPC> times ) : <NL>          self . __sentence_to_count [ sentence ] <SPC> = <SPC> count <NL>          self . __trie . insert ( sentence , <SPC> count ) <NL> <NL> <TAB> def <SPC> input ( self , <SPC> c ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> c <SPC> == <SPC> "#" : <NL>          self . __sentence_to_count [ "" . join ( self . __search ) ] <SPC> += <SPC> 1 <NL>          self . __trie . insert ( <NL>              "" . join ( self . __search ) , <SPC> self . __sentence_to_count [ "" . join ( <NL>                  self . __search ) ] <NL>          ) <NL>          self . __cur_node <SPC> = <SPC> self . __trie <NL>          self . __search <SPC> = <SPC> [ ] <NL> <TAB> else : <NL>          self . __search . append ( c ) <NL>          if <SPC> self . __cur_node : <NL>              if <SPC> c <SPC> not <SPC> in <SPC> self . __cur_node . leaves : <NL>                  self . __cur_node <SPC> = <SPC> None <NL>                  return <SPC> [ ] <NL>              self . __cur_node <SPC> = <SPC> self . __cur_node . leaves [ c ] <NL>              result <SPC> = <SPC> [ p [ 1 ] <SPC> for <SPC> p <SPC> in <SPC> self . __cur_node . infos ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> SkipNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> level = 0 , <SPC> num = None ) : <NL> <TAB> self . num <SPC> = <SPC> num <NL> <TAB> self . nexts <SPC> = <SPC> [ None ] <SPC> * <SPC> level <NL> <NL> <NL> class <SPC> Skiplist ( object ) : <NL> <TAB> P_NUMERATOR , <SPC> P_DENOMINATOR <SPC> = <SPC> 1 , <SPC> 2 <NL> <TAB> MAX_LEVEL <SPC> = <SPC> 32 <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __head <SPC> = <SPC> SkipNode ( ) <NL> <TAB> self . __len <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> search ( self , <SPC> target ) : <NL> <NL> <TAB> return <SPC> True <SPC> if <SPC> self . __find ( target , <SPC> self . __find_prev_nodes ( target ) ) <SPC> else <SPC> False <NL> <NL> <TAB> def <SPC> add ( self , <SPC> num ) : <NL> <NL> <TAB> node <SPC> = <SPC> SkipNode ( self . __random_level ( ) , <SPC> num ) <NL> <TAB> if <SPC> len ( self . __head . nexts ) <SPC> < <SPC> len ( node . nexts ) : <NL>          self . __head . nexts . extend ( <NL>              [ None ] <SPC> * <SPC> ( len ( node . nexts ) <SPC> - <SPC> len ( self . __head . nexts ) ) <NL>          ) <NL> <TAB> prevs <SPC> = <SPC> self . __find_prev_nodes ( num ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( node . nexts ) ) : <NL>          node . nexts [ i ] <SPC> = <SPC> prevs [ i ] . nexts [ i ] <NL>          prevs [ i ] . nexts [ i ] <SPC> = <SPC> node <NL> <TAB> self . __len <SPC> += <SPC> 1 <NL> <NL> <TAB> def <SPC> erase ( self , <SPC> num ) : <NL> <NL> <TAB> prevs <SPC> = <SPC> self . __find_prev_nodes ( num ) <NL> <TAB> curr <SPC> = <SPC> self . __find ( num , <SPC> prevs ) <NL> <TAB> if <SPC> not <SPC> curr : <NL>          return <SPC> False <NL> <TAB> self . __len <SPC> -= <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( curr . nexts ) ) ) : <NL>          prevs [ i ] . nexts [ i ] <SPC> = <SPC> curr . nexts [ i ] <NL>          if <SPC> not <SPC> self . __head . nexts [ i ] : <NL>              self . __head . nexts . pop ( ) <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> __find ( self , <SPC> num , <SPC> prevs ) : <NL> <TAB> if <SPC> prevs : <NL>          candidate <SPC> = <SPC> prevs [ 0 ] . nexts [ 0 ] <NL>          if <SPC> candidate <SPC> and <SPC> candidate . num <SPC> == <SPC> num : <NL>              return <SPC> candidate <NL> <TAB> return <SPC> None <NL> <NL> <TAB> def <SPC> __find_prev_nodes ( self , <SPC> num ) : <NL> <TAB> prevs <SPC> = <SPC> [ None ] <SPC> * <SPC> len ( self . __head . nexts ) <NL> <TAB> curr <SPC> = <SPC> self . __head <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( self . __head . nexts ) ) ) : <NL>          while <SPC> curr . nexts [ i ] <SPC> and <SPC> curr . nexts [ i ] . num <SPC> < <SPC> num : <NL>              curr <SPC> = <SPC> curr . nexts [ i ] <NL>          prevs [ i ] <SPC> = <SPC> curr <NL> <TAB> return <SPC> prevs <NL> <NL> <TAB> def <SPC> __random_level ( self ) : <NL> <TAB> level <SPC> = <SPC> 1 <NL> <TAB> while <SPC> ( <NL>          random . randint ( 1 , <SPC> Skiplist . P_DENOMINATOR ) <SPC> <= <SPC> Skiplist . P_NUMERATOR <NL>          and <SPC> level <SPC> < <SPC> Skiplist . MAX_LEVEL <NL> <TAB> ) : <NL>          level <SPC> += <SPC> 1 <NL> <TAB> return <SPC> level <NL> <NL> <TAB> def <SPC> __len__ ( self ) : <NL> <TAB> return <SPC> self . __len <NL> <NL> <TAB> def <SPC> __str__ ( self ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( self . __head . nexts ) ) ) : <NL>          result . append ( [ ] ) <NL>          curr <SPC> = <SPC> self . __head . nexts [ i ] <NL>          while <SPC> curr : <NL>              result [ - 1 ] . append ( str ( curr . num ) ) <NL>              curr <SPC> = <SPC> curr . nexts [ i ] <NL> <TAB> return <SPC> "\n" . join ( map ( lambda <SPC> x : <SPC> "->" . join ( x ) , <SPC> result ) ) <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> deque <NL> <NL> <NL> class <SPC> SnakeGame ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> width , <SPC> height , <SPC> food ) : <NL> <NL> <TAB> self . __width <SPC> = <SPC> width <NL> <TAB> self . __height <SPC> = <SPC> height <NL> <TAB> self . __score <SPC> = <SPC> 0 <NL> <TAB> self . __f <SPC> = <SPC> 0 <NL> <TAB> self . __food <SPC> = <SPC> food <NL> <TAB> self . __snake <SPC> = <SPC> deque ( [ ( 0 , <SPC> 0 ) ] ) <NL> <TAB> self . __direction <SPC> = <SPC> { "U" : <SPC> ( - 1 , <SPC> 0 ) , <SPC> "L" : <SPC> ( 0 , <SPC> - 1 ) , <SPC> "R" : <SPC> ( 0 , <SPC> 1 ) , <SPC> "D" : <SPC> ( 1 , <SPC> 0 ) } <NL> <TAB> self . __lookup <SPC> = <SPC> { ( 0 , <SPC> 0 ) } <NL> <NL> <TAB> def <SPC> move ( self , <SPC> direction ) : <NL> <NL> <TAB> def <SPC> valid ( x , <SPC> y ) : <NL>          return <SPC> 0 <SPC> <= <SPC> x <SPC> < <SPC> self . __height <SPC> and <SPC> 0 <SPC> <= <SPC> y <SPC> < <SPC> self . __width <SPC> and <SPC> ( x , <SPC> y ) <SPC> not <SPC> in <SPC> self . __lookup <NL> <TAB> d <SPC> = <SPC> self . __direction [ direction ] <NL> <TAB> x , <SPC> y <SPC> = <SPC> self . __snake [ - 1 ] [ 0 ] <SPC> + <SPC> d [ 0 ] , <SPC> self . __snake [ - 1 ] [ 1 ] <SPC> + <SPC> d [ 1 ] <NL> <TAB> self . __lookup . remove ( self . __snake [ 0 ] ) <NL> <TAB> tail <SPC> = <SPC> self . __snake . popleft ( ) <NL> <TAB> if <SPC> not <SPC> valid ( x , <SPC> y ) : <NL>          return <SPC> - 1 <NL> <TAB> elif <SPC> self . __f <SPC> != <SPC> len ( self . __food ) <SPC> and <SPC> ( self . __food [ self . __f ] [ 0 ] , <SPC> self . __food [ self . __f ] [ 1 ] ) <SPC> == <SPC> ( x , <SPC> y ) : <NL>          self . __score <SPC> += <SPC> 1 <NL>          self . __f <SPC> += <SPC> 1 <NL>          self . __snake . appendleft ( tail ) <NL>          self . __lookup . add ( tail ) <NL> <TAB> self . __snake . append ( ( x , <SPC> y ) ) <NL> <TAB> self . __lookup . add ( ( x , <SPC> y ) ) <NL> <TAB> return <SPC> self . __score <NL> <NL> <NL> class <SPC> TicTacToe ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <NL> <TAB> self . __size <SPC> = <SPC> n <NL> <TAB> self . __rows <SPC> = <SPC> [ [ 0 , <SPC> 0 ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> self . __cols <SPC> = <SPC> [ [ 0 , <SPC> 0 ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> self . __diagonal <SPC> = <SPC> [ 0 , <SPC> 0 ] <NL> <TAB> self . __anti_diagonal <SPC> = <SPC> [ 0 , <SPC> 0 ] <NL> <NL> <TAB> def <SPC> move ( self , <SPC> row , <SPC> col , <SPC> player ) : <NL> <NL> <TAB> i <SPC> = <SPC> player <SPC> - <SPC> 1 <NL> <TAB> self . __rows [ row ] [ i ] <SPC> += <SPC> 1 <NL> <TAB> self . __cols [ col ] [ i ] <SPC> += <SPC> 1 <NL> <TAB> if <SPC> row <SPC> == <SPC> col : <NL>          self . __diagonal [ i ] <SPC> += <SPC> 1 <NL> <TAB> if <SPC> col <SPC> == <SPC> len ( self . __rows ) <SPC> - <SPC> row <SPC> - <SPC> 1 : <NL>          self . __anti_diagonal [ i ] <SPC> += <SPC> 1 <NL> <TAB> if <SPC> any ( <NL>          self . __rows [ row ] [ i ] <SPC> == <SPC> self . __size , <NL>          self . __cols [ col ] [ i ] <SPC> == <SPC> self . __size , <NL>          self . __diagonal [ i ] <SPC> == <SPC> self . __size , <NL>          self . __anti_diagonal [ i ] <SPC> == <SPC> self . __size , <NL> <TAB> ) : <NL>          return <SPC> player <NL> <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Twitter ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . __number_of_most_recent_tweets <SPC> = <SPC> 10 <NL> <TAB> self . __followings <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> self . __messages <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> self . __time <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> postTweet ( self , <SPC> userId , <SPC> tweetId ) : <NL> <NL> <TAB> self . __time <SPC> += <SPC> 1 <NL> <TAB> self . __messages [ userId ] . append ( ( self . __time , <SPC> tweetId ) ) <NL> <NL> <TAB> def <SPC> getNewsFeed ( self , <SPC> userId ) : <NL> <NL> <TAB> max_heap <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> self . __messages [ userId ] : <NL>          heapq . heappush ( max_heap , <SPC> ( - self . __messages [ userId ] [ - 1 ] [ 0 ] , <SPC> userId , <SPC> 0 ) ) <NL> <TAB> for <SPC> uid <SPC> in <SPC> self . __followings [ userId ] : <NL>          if <SPC> self . __messages [ uid ] : <NL>              heapq . heappush ( max_heap , <SPC> ( - self . __messages [ uid ] [ - 1 ] [ 0 ] , <SPC> uid , <SPC> 0 ) ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> max_heap <SPC> and <SPC> len ( result ) <SPC> < <SPC> self . __number_of_most_recent_tweets : <NL>          t , <SPC> uid , <SPC> curr <SPC> = <SPC> heapq . heappop ( max_heap ) <NL>          nxt <SPC> = <SPC> curr <SPC> + <SPC> 1 <NL>          if <SPC> nxt <SPC> != <SPC> len ( self . __messages [ uid ] ) : <NL>              heapq . heappush ( <NL>                  max_heap , <SPC> ( - self . __messages [ uid ] [ - ( nxt <SPC> + <SPC> 1 ) ] [ 0 ] , <SPC> uid , <SPC> nxt ) <NL>              ) <NL>          result . append ( self . __messages [ uid ] [ - ( curr <SPC> + <SPC> 1 ) ] [ 1 ] ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> follow ( self , <SPC> followerId , <SPC> followeeId ) : <NL> <NL> <TAB> if <SPC> followerId <SPC> != <SPC> followeeId : <NL>          self . __followings [ followerId ] . add ( followeeId ) <NL> <NL> <TAB> def <SPC> unfollow ( self , <SPC> followerId , <SPC> followeeId ) : <NL> <NL> <TAB> self . __followings [ followerId ] . discard ( followeeId ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> UndergroundSystem ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __live <SPC> = <SPC> { } <NL> <TAB> self . __statistics <SPC> = <SPC> collections . defaultdict ( lambda : <SPC> [ 0 , <SPC> 0 ] ) <NL> <NL> <TAB> def <SPC> checkIn ( self , <SPC> id , <SPC> stationName , <SPC> t ) : <NL> <NL> <TAB> self . __live [ id ] <SPC> = <SPC> ( stationName , <SPC> t ) <NL> <NL> <TAB> def <SPC> checkOut ( self , <SPC> id , <SPC> stationName , <SPC> t ) : <NL> <NL> <TAB> startStation , <SPC> startTime <SPC> = <SPC> self . __live . pop ( id ) <NL> <TAB> self . __statistics [ startStation , <SPC> stationName ] [ 0 ] <SPC> += <SPC> t <SPC> - <SPC> startTime <NL> <TAB> self . __statistics [ startStation , <SPC> stationName ] [ 1 ] <SPC> += <SPC> 1 <NL> <NL> <TAB> def <SPC> getAverageTime ( self , <SPC> startStation , <SPC> endStation ) : <NL> <NL> <TAB> total_time , <SPC> cnt <SPC> = <SPC> self . __statistics [ startStation , <SPC> endStation ] <NL> <TAB> return <SPC> float ( total_time ) <SPC> / <SPC> cnt <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> destCity ( self , <SPC> paths ) : <NL> <NL> <TAB> A , <SPC> B <SPC> = <SPC> map ( set , <SPC> itertools . izip ( * paths ) ) <NL> <TAB> return <SPC> ( B <SPC> - <SPC> A ) . pop ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> detectCapitalUse ( self , <SPC> word ) : <NL> <NL> <TAB> return <SPC> word . isupper ( ) <SPC> or <SPC> word . islower ( ) <SPC> or <SPC> word . istitle ( ) <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . count <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> != <SPC> y_root : <NL>          self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL>          self . count <SPC> -= <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> containsCycle ( self , <SPC> grid ) : <NL> <NL> <TAB> def <SPC> index ( n , <SPC> i , <SPC> j ) : <NL>          return <SPC> i <SPC> * <SPC> n <SPC> + <SPC> j <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( grid ) <SPC> * <SPC> len ( grid [ 0 ] ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> ( <NL>                  i <NL>                  and <SPC> j <NL>                  and <SPC> grid [ i ] [ j ] <SPC> == <SPC> grid [ i <SPC> - <SPC> 1 ] [ j ] <SPC> == <SPC> grid [ i ] [ j <SPC> - <SPC> 1 ] <NL>                  and <SPC> union_find . find_set ( index ( len ( grid [ 0 ] ) , <SPC> i <SPC> - <SPC> 1 , <SPC> j ) ) <NL>                  == <SPC> union_find . find_set ( index ( len ( grid [ 0 ] ) , <SPC> i , <SPC> j <SPC> - <SPC> 1 ) ) <NL>              ) : <NL>                  return <SPC> True <NL>              if <SPC> i <SPC> and <SPC> grid [ i ] [ j ] <SPC> == <SPC> grid [ i <SPC> - <SPC> 1 ] [ j ] : <NL>                  union_find . union_set ( <NL>                      index ( len ( grid [ 0 ] ) , <SPC> i <SPC> - <SPC> 1 , <SPC> j ) , <SPC> index ( len ( grid [ 0 ] ) , <SPC> i , <SPC> j ) <NL>                  ) <NL>              if <SPC> j <SPC> and <SPC> grid [ i ] [ j ] <SPC> == <SPC> grid [ i ] [ j <SPC> - <SPC> 1 ] : <NL>                  union_find . union_set ( <NL>                      index ( len ( grid [ 0 ] ) , <SPC> i , <SPC> j <SPC> - <SPC> 1 ) , <SPC> index ( len ( grid [ 0 ] ) , <SPC> i , <SPC> j ) <NL>                  ) <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> containsCycle ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> not <SPC> grid [ i ] [ j ] : <NL>                  continue <NL>              val <SPC> = <SPC> grid [ i ] [ j ] <NL>              q <SPC> = <SPC> [ ( i , <SPC> j ) ] <NL>              while <SPC> q : <NL>                  new_q <SPC> = <SPC> [ ] <NL>                  for <SPC> r , <SPC> c <SPC> in <SPC> q : <NL>                      if <SPC> not <SPC> grid [ r ] [ c ] : <NL>                          return <SPC> True <NL>                      grid [ r ] [ c ] <SPC> = <SPC> 0 <NL>                      for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                          nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr , <SPC> c <SPC> + <SPC> dc <NL>                          if <SPC> not <SPC> ( <NL>                              0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( grid ) <NL>                              and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                              and <SPC> grid [ nr ] [ nc ] <SPC> == <SPC> val <NL>                          ) : <NL>                              continue <NL>                          new_q . append ( ( nr , <SPC> nc ) ) <NL>                  q <SPC> = <SPC> new_q <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> containsPattern ( self , <SPC> arr , <SPC> m , <SPC> k ) : <NL> <NL> <TAB> cnt <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( arr ) <SPC> - <SPC> m ) : <NL>          if <SPC> arr [ i ] <SPC> != <SPC> arr [ i <SPC> + <SPC> m ] : <NL>              cnt <SPC> = <SPC> 0 <NL>              continue <NL>          cnt <SPC> += <SPC> 1 <NL>          if <SPC> cnt <SPC> == <SPC> ( k <SPC> - <SPC> 1 ) <SPC> * <SPC> m : <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> halvesAreAlike ( self , <SPC> s ) : <NL> <NL> <TAB> vowels <SPC> = <SPC> set ( "aeiouAEIOU" ) <NL> <TAB> cnt1 <SPC> = <SPC> cnt2 <SPC> = <SPC> 0 <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( s ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          cnt1 <SPC> += <SPC> s [ left ] <SPC> in <SPC> vowels <NL>          cnt2 <SPC> += <SPC> s [ right ] <SPC> in <SPC> vowels <NL>          left <SPC> += <SPC> 1 <NL>          right <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> cnt1 <SPC> == <SPC> cnt2 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> closeStrings ( self , <SPC> word1 , <SPC> word2 ) : <NL> <NL> <TAB> if <SPC> len ( word1 ) <SPC> != <SPC> len ( word2 ) : <NL>          return <SPC> False <NL> <NL> <TAB> cnt1 , <SPC> cnt2 <SPC> = <SPC> collections . Counter ( word1 ) , <SPC> collections . Counter ( <NL>          word2 <NL> <TAB> ) <NL> <TAB> return <SPC> set ( cnt1 . iterkeys ( ) ) <SPC> == <SPC> set ( cnt2 . iterkeys ( ) ) <SPC> and <SPC> collections . Counter ( <NL>          cnt1 . itervalues ( ) <NL> <TAB> ) <SPC> == <SPC> collections . Counter ( cnt2 . itervalues ( ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> diStringMatch ( self , <SPC> S ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( S ) <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          if <SPC> c <SPC> == <SPC> "I" : <NL>              result . append ( left ) <NL>              left <SPC> += <SPC> 1 <NL>          else : <NL>              result . append ( right ) <NL>              right <SPC> -= <SPC> 1 <NL> <TAB> result . append ( left ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findDiagonalOrder ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> dq , <SPC> col <SPC> = <SPC> [ ] , <SPC> collections . deque ( ) , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) <SPC> + <SPC> max ( itertools . imap ( len , <SPC> nums ) ) <SPC> - <SPC> 1 ) : <NL>          new_dq <SPC> = <SPC> collections . deque ( ) <NL>          if <SPC> i <SPC> < <SPC> len ( nums ) : <NL>              dq . appendleft ( ( i , <SPC> 0 ) ) <NL>          for <SPC> r , <SPC> c <SPC> in <SPC> dq : <NL>              result . append ( nums [ r ] [ c ] ) <NL>              if <SPC> c <SPC> + <SPC> 1 <SPC> < <SPC> len ( nums [ r ] ) : <NL>                  new_dq . append ( ( r , <SPC> c <SPC> + <SPC> 1 ) ) <NL>          dq <SPC> = <SPC> new_dq <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findDiagonalOrder ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( nums ) : <NL>          for <SPC> c , <SPC> num <SPC> in <SPC> enumerate ( row ) : <NL>              if <SPC> len ( result ) <SPC> <= <SPC> r <SPC> + <SPC> c : <NL>                  result . append ( [ ] ) <NL>              result [ r <SPC> + <SPC> c ] . append ( num ) <NL> <TAB> return <SPC> [ num <SPC> for <SPC> row <SPC> in <SPC> result <SPC> for <SPC> num <SPC> in <SPC> reversed ( row ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findDiagonalOrder ( self , <SPC> matrix ) : <NL> <NL> <TAB> if <SPC> not <SPC> matrix <SPC> or <SPC> not <SPC> matrix [ 0 ] : <NL>          return <SPC> [ ] <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> row , <SPC> col , <SPC> d <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> dirs <SPC> = <SPC> [ ( - 1 , <SPC> 1 ) , <SPC> ( 1 , <SPC> - 1 ) ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) <SPC> * <SPC> len ( matrix [ 0 ] ) ) : <NL>          result . append ( matrix [ row ] [ col ] ) <NL>          row <SPC> += <SPC> dirs [ d ] [ 0 ] <NL>          col <SPC> += <SPC> dirs [ d ] [ 1 ] <NL> <NL>          if <SPC> row <SPC> >= <SPC> len ( matrix ) : <NL>              row <SPC> = <SPC> len ( matrix ) <SPC> - <SPC> 1 <NL>              col <SPC> += <SPC> 2 <NL>              d <SPC> = <SPC> 1 <SPC> - <SPC> d <NL>          elif <SPC> col <SPC> >= <SPC> len ( matrix [ 0 ] ) : <NL>              col <SPC> = <SPC> len ( matrix [ 0 ] ) <SPC> - <SPC> 1 <NL>              row <SPC> += <SPC> 2 <NL>              d <SPC> = <SPC> 1 <SPC> - <SPC> d <NL>          elif <SPC> row <SPC> < <SPC> 0 : <NL>              row <SPC> = <SPC> 0 <NL>              d <SPC> = <SPC> 1 <SPC> - <SPC> d <NL>          elif <SPC> col <SPC> < <SPC> 0 : <NL>              col <SPC> = <SPC> 0 <NL>              d <SPC> = <SPC> 1 <SPC> - <SPC> d <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> diameterOfBinaryTree ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> iter_dfs ( node ) : <NL>          result <SPC> = <SPC> 0 <NL>          max_depth <SPC> = <SPC> [ 0 ] <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> [ node , <SPC> max_depth ] ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  node , <SPC> ret <SPC> = <SPC> params <NL>                  if <SPC> not <SPC> node : <NL>                      continue <NL>                  ret1 , <SPC> ret2 <SPC> = <SPC> [ 0 ] , <SPC> [ 0 ] <NL>                  stk . append ( ( 2 , <SPC> [ node , <SPC> ret1 , <SPC> ret2 , <SPC> ret ] ) ) <NL>                  stk . append ( ( 1 , <SPC> [ node . right , <SPC> ret2 ] ) ) <NL>                  stk . append ( ( 1 , <SPC> [ node . left , <SPC> ret1 ] ) ) <NL>              elif <SPC> step <SPC> == <SPC> 2 : <NL>                  node , <SPC> ret1 , <SPC> ret2 , <SPC> ret <SPC> = <SPC> params <NL>                  result <SPC> = <SPC> max ( result , <SPC> ret1 [ 0 ] <SPC> + <SPC> ret2 [ 0 ] ) <NL>                  ret [ 0 ] <SPC> = <SPC> 1 <SPC> + <SPC> max ( ret1 [ 0 ] , <SPC> ret2 [ 0 ] ) <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> iter_dfs ( root ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> diameterOfBinaryTree ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( root ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 , <SPC> 0 <NL>          left_d , <SPC> left_h <SPC> = <SPC> dfs ( root . left ) <NL>          right_d , <SPC> right_h <SPC> = <SPC> dfs ( root . right ) <NL>          return <SPC> max ( left_d , <SPC> right_d , <SPC> left_h <SPC> + <SPC> right_h ) , <SPC> 1 <SPC> + <SPC> max ( left_h , <SPC> right_h ) <NL> <NL> <TAB> return <SPC> dfs ( root ) [ 0 ] <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = None , <SPC> children = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . children <SPC> = <SPC> children <SPC> if <SPC> children <SPC> is <SPC> not <SPC> None <SPC> else <SPC> [ ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> diameter ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> iter_dfs ( root ) : <NL>          result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> ( root , <SPC> result ) ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  node , <SPC> ret <SPC> = <SPC> params <NL>                  for <SPC> child <SPC> in <SPC> reversed ( node . children ) : <NL>                      ret2 <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 <NL>                      stk . append ( ( 2 , <SPC> ( ret2 , <SPC> ret ) ) ) <NL>                      stk . append ( ( 1 , <SPC> ( child , <SPC> ret2 ) ) ) <NL>              else : <NL>                  ret2 , <SPC> ret <SPC> = <SPC> params <NL>                  ret [ 0 ] <SPC> = <SPC> max ( ret [ 0 ] , <SPC> ret2 [ 0 ] , <SPC> ret [ 1 ] <SPC> + <SPC> ret2 [ 1 ] <SPC> + <SPC> 1 ) <NL>                  ret [ 1 ] <SPC> = <SPC> max ( ret [ 1 ] , <SPC> ret2 [ 1 ] <SPC> + <SPC> 1 ) <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> iter_dfs ( root ) [ 0 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> diameter ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node ) : <NL>          max_dia , <SPC> max_depth <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> child <SPC> in <SPC> node . children : <NL>              child_max_dia , <SPC> child_max_depth <SPC> = <SPC> dfs ( child ) <NL>              max_dia <SPC> = <SPC> max ( max_dia , <SPC> child_max_dia , <NL>                            max_depth <SPC> + <SPC> child_max_depth <SPC> + <SPC> 1 ) <NL>              max_depth <SPC> = <SPC> max ( max_depth , <SPC> child_max_depth <SPC> + <SPC> 1 ) <NL>          return <SPC> max_dia , <SPC> max_depth <NL> <NL> <TAB> return <SPC> dfs ( root ) [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> dieSimulator ( self , <SPC> n , <SPC> rollMax ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> def <SPC> sum_mod ( array ) : <NL>          return <SPC> reduce ( lambda <SPC> x , <SPC> y : <SPC> ( x <SPC> + <SPC> y ) <SPC> % <SPC> MOD , <SPC> array ) <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 1 ] <SPC> + <SPC> [ 0 ] <SPC> * <SPC> ( rollMax [ i ] <SPC> - <SPC> 1 ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( 6 ) ] <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( n <SPC> - <SPC> 1 ) : <NL>          new_dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> rollMax [ i ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( 6 ) ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( 6 ) : <NL>              for <SPC> k <SPC> in <SPC> xrange ( rollMax [ i ] ) : <NL>                  for <SPC> j <SPC> in <SPC> xrange ( 6 ) : <NL>                      if <SPC> i <SPC> == <SPC> j : <NL>                          if <SPC> k <SPC> < <SPC> rollMax [ i ] <SPC> - <SPC> 1 : <NL>                              new_dp [ j ] [ k <SPC> + <SPC> 1 ] <SPC> = <SPC> ( new_dp [ j ] <NL>                                                  [ k <SPC> + <SPC> 1 ] <SPC> + <SPC> dp [ i ] [ k ] ) <SPC> % <SPC> MOD <NL>                      else : <NL>                          new_dp [ j ] [ 0 ] <SPC> = <SPC> ( new_dp [ j ] [ 0 ] <SPC> + <SPC> dp [ i ] [ k ] ) <SPC> % <SPC> MOD <NL>          dp <SPC> = <SPC> new_dp <NL> <TAB> return <SPC> sum_mod ( sum_mod ( row ) <SPC> for <SPC> row <SPC> in <SPC> dp ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> dietPlanPerformance ( self , <SPC> calories , <SPC> k , <SPC> lower , <SPC> upper ) : <NL> <NL> <TAB> total <SPC> = <SPC> sum ( itertools . islice ( calories , <SPC> 0 , <SPC> k ) ) <NL> <TAB> result <SPC> = <SPC> int ( total <SPC> > <SPC> upper ) <SPC> - <SPC> int ( total <SPC> < <SPC> lower ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k , <SPC> len ( calories ) ) : <NL>          total <SPC> += <SPC> calories [ i ] <SPC> - <SPC> calories [ i <SPC> - <SPC> k ] <NL>          result <SPC> += <SPC> int ( total <SPC> > <SPC> upper ) <SPC> - <SPC> int ( total <SPC> < <SPC> lower ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> operator <NL> import <SPC> re <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> diffWaysToCompute ( self , <SPC> input ) : <NL> <TAB> tokens <SPC> = <SPC> re . split ( "(\D)" , <SPC> input ) <NL> <TAB> nums <SPC> = <SPC> map ( int , <SPC> tokens [ : : 2 ] ) <NL> <TAB> ops <SPC> = <SPC> map ( <NL>          { "+" : <SPC> operator . add , <SPC> "-" : <SPC> operator . sub , <NL>              "*" : <SPC> operator . mul } . get , <SPC> tokens [ 1 : : 2 ] <NL> <TAB> ) <NL> <TAB> lookup <SPC> = <SPC> [ [ None <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( nums ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( nums ) ) ] <NL> <NL> <TAB> def <SPC> diffWaysToComputeRecu ( left , <SPC> right ) : <NL>          if <SPC> left <SPC> == <SPC> right : <NL>              return <SPC> [ nums [ left ] ] <NL>          if <SPC> lookup [ left ] [ right ] : <NL>              return <SPC> lookup [ left ] [ right ] <NL>          lookup [ left ] [ right ] <SPC> = <SPC> [ <NL>              ops [ i ] ( x , <SPC> y ) <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) <NL>              for <SPC> x <SPC> in <SPC> diffWaysToComputeRecu ( left , <SPC> i ) <NL>              for <SPC> y <SPC> in <SPC> diffWaysToComputeRecu ( i <SPC> + <SPC> 1 , <SPC> right ) <NL>          ] <NL>          return <SPC> lookup [ left ] [ right ] <NL> <NL> <TAB> return <SPC> diffWaysToComputeRecu ( 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> diffWaysToCompute ( self , <SPC> input ) : <NL> <TAB> lookup <SPC> = <SPC> [ <NL>          [ None <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( input ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( input ) <SPC> + <SPC> 1 ) <NL> <TAB> ] <NL> <TAB> ops <SPC> = <SPC> { "+" : <SPC> operator . add , <SPC> "-" : <SPC> operator . sub , <SPC> "*" : <SPC> operator . mul } <NL> <NL> <TAB> def <SPC> diffWaysToComputeRecu ( left , <SPC> right ) : <NL>          if <SPC> lookup [ left ] [ right ] : <NL>              return <SPC> lookup [ left ] [ right ] <NL>          result <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>              if <SPC> input [ i ] <SPC> in <SPC> ops : <NL>                  for <SPC> x <SPC> in <SPC> diffWaysToComputeRecu ( left , <SPC> i ) : <NL>                      for <SPC> y <SPC> in <SPC> diffWaysToComputeRecu ( i <SPC> + <SPC> 1 , <SPC> right ) : <NL>                          result . append ( ops [ input [ i ] ] ( x , <SPC> y ) ) <NL> <NL>          if <SPC> not <SPC> result : <NL>              result <SPC> = <SPC> [ int ( input [ left : right ] ) ] <NL>          lookup [ left ] [ right ] <SPC> = <SPC> result <NL>          return <SPC> lookup [ left ] [ right ] <NL> <NL> <TAB> return <SPC> diffWaysToComputeRecu ( 0 , <SPC> len ( input ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> digitsCount ( self , <SPC> d , <SPC> low , <SPC> high ) : <NL> <NL> <TAB> def <SPC> digitsCount ( n , <SPC> k ) : <NL>          pivot , <SPC> result <SPC> = <SPC> 1 , <SPC> 0 <NL>          while <SPC> n <SPC> >= <SPC> pivot : <NL>              result <SPC> += <SPC> ( n <SPC> // <SPC> ( 10 <SPC> * <SPC> pivot ) ) <SPC> * <SPC> pivot <SPC> + <SPC> min ( <NL>                  pivot , <SPC> max ( n <SPC> % <SPC> ( 10 <SPC> * <SPC> pivot ) <SPC> - <SPC> k <SPC> * <SPC> pivot <SPC> + <SPC> 1 , <SPC> 0 ) <NL>              ) <NL>              if <SPC> k <SPC> == <SPC> 0 : <NL>                  result <SPC> -= <SPC> pivot <NL>              pivot <SPC> *= <SPC> 10 <NL>          return <SPC> result <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> digitsCount ( high , <SPC> d ) <SPC> - <SPC> digitsCount ( low <SPC> - <SPC> 1 , <SPC> d ) <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> DinnerPlates ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> capacity ) : <NL> <NL> <TAB> self . __stks <SPC> = <SPC> [ ] <NL> <TAB> self . __c <SPC> = <SPC> capacity <NL> <TAB> self . __min_heap <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( self , <SPC> val ) : <NL> <NL> <TAB> if <SPC> self . __min_heap : <NL>          l <SPC> = <SPC> heapq . heappop ( self . __min_heap ) <NL>          if <SPC> l <SPC> < <SPC> len ( self . __stks ) : <NL>              self . __stks [ l ] . append ( val ) <NL>              return <NL>          self . __min_heap <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> not <SPC> self . __stks <SPC> or <SPC> len ( self . __stks [ - 1 ] ) <SPC> == <SPC> self . __c : <NL>          self . __stks . append ( [ ] ) <NL> <TAB> self . __stks [ - 1 ] . append ( val ) <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <NL> <TAB> while <SPC> self . __stks <SPC> and <SPC> not <SPC> self . __stks [ - 1 ] : <NL>          self . __stks . pop ( ) <NL> <TAB> if <SPC> not <SPC> self . __stks : <NL>          return <SPC> - 1 <NL> <TAB> return <SPC> self . __stks [ - 1 ] . pop ( ) <NL> <NL> <TAB> def <SPC> popAtStack ( self , <SPC> index ) : <NL> <NL> <TAB> if <SPC> index <SPC> >= <SPC> len ( self . __stks ) <SPC> or <SPC> not <SPC> self . __stks [ index ] : <NL>          return <SPC> - 1 <NL> <TAB> heapq . heappush ( self . __min_heap , <SPC> index ) <NL> <TAB> return <SPC> self . __stks [ index ] . pop ( ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> displayTable ( self , <SPC> orders ) : <NL> <NL> <TAB> table_count <SPC> = <SPC> collections . defaultdict ( collections . Counter ) <NL> <TAB> for <SPC> _ , <SPC> table , <SPC> food <SPC> in <SPC> orders : <NL>          table_count [ int ( table ) ] [ food ] <SPC> += <SPC> 1 <NL> <TAB> foods <SPC> = <SPC> sorted ( { food <SPC> for <SPC> _ , <SPC> _ , <SPC> food <SPC> in <SPC> orders } ) <NL> <TAB> result <SPC> = <SPC> [ [ "Table" ] ] <NL> <TAB> result [ 0 ] . extend ( foods ) <NL> <TAB> for <SPC> table <SPC> in <SPC> sorted ( table_count ) : <NL>          result . append ( [ str ( table ) ] ) <NL>          result [ - 1 ] . extend ( str ( table_count [ table ] [ food ] ) <SPC> for <SPC> food <SPC> in <SPC> foods ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> distanceBetweenBusStops ( self , <SPC> distance , <SPC> start , <SPC> destination ) : <NL> <NL> <TAB> if <SPC> start <SPC> > <SPC> destination : <NL>          start , <SPC> destination <SPC> = <SPC> destination , <SPC> start <NL> <TAB> s_to_d <SPC> = <SPC> sum ( itertools . islice ( distance , <SPC> start , <SPC> destination ) ) <NL> <TAB> d_to_s <SPC> = <SPC> sum ( itertools . islice ( distance , <SPC> 0 , <SPC> start ) ) <SPC> + <SPC> sum ( <NL>          itertools . islice ( distance , <SPC> destination , <SPC> len ( distance ) ) <NL> <TAB> ) <NL> <TAB> return <SPC> min ( s_to_d , <SPC> d_to_s ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rearrangeBarcodes ( self , <SPC> barcodes ) : <NL> <NL> <TAB> cnts <SPC> = <SPC> collections . Counter ( barcodes ) <NL> <TAB> sorted_cnts <SPC> = <SPC> [ [ v , <SPC> k ] <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> cnts . iteritems ( ) ] <NL> <TAB> sorted_cnts . sort ( reverse = True ) <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> for <SPC> v , <SPC> k <SPC> in <SPC> sorted_cnts : <NL>          for <SPC> _ <SPC> in <SPC> xrange ( v ) : <NL>              barcodes [ i ] <SPC> = <SPC> k <NL>              i <SPC> += <SPC> 2 <NL>              if <SPC> i <SPC> >= <SPC> len ( barcodes ) : <NL>                  i <SPC> = <SPC> 1 <NL> <TAB> return <SPC> barcodes <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> distinctEchoSubstrings ( self , <SPC> text ) : <NL> <NL> <TAB> def <SPC> KMP ( text , <SPC> l , <SPC> result ) : <NL>          prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> ( len ( text ) <SPC> - <SPC> l ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( prefix ) ) : <NL>              while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> text [ l <SPC> + <SPC> j <SPC> + <SPC> 1 ] <SPC> != <SPC> text [ l <SPC> + <SPC> i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> text [ l <SPC> + <SPC> j <SPC> + <SPC> 1 ] <SPC> == <SPC> text [ l <SPC> + <SPC> i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              prefix [ i ] <SPC> = <SPC> j <NL>              if <SPC> ( <NL>                  ( j <SPC> + <SPC> 1 ) <NL>                  and <SPC> ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> ( ( i <SPC> + <SPC> 1 ) <SPC> - <SPC> ( j <SPC> + <SPC> 1 ) ) <SPC> == <SPC> 0 <NL>                  and <SPC> ( i <SPC> + <SPC> 1 ) <SPC> // <SPC> ( ( i <SPC> + <SPC> 1 ) <SPC> - <SPC> ( j <SPC> + <SPC> 1 ) ) <SPC> % <SPC> 2 <SPC> == <SPC> 0 <NL>              ) : <NL>                  result . add ( text [ l : <SPC> l <SPC> + <SPC> i <SPC> + <SPC> 1 ] ) <NL>          return <SPC> ( <NL>              len ( prefix ) <SPC> - <SPC> ( prefix [ - 1 ] <SPC> + <SPC> 1 ) <NL>              if <SPC> prefix [ - 1 ] <SPC> + <SPC> 1 <NL>              and <SPC> len ( prefix ) <SPC> % <SPC> ( len ( prefix ) <SPC> - <SPC> ( prefix [ - 1 ] <SPC> + <SPC> 1 ) ) <SPC> == <SPC> 0 <NL>              else <SPC> float ( "inf" ) <NL>          ) <NL> <NL> <TAB> result <SPC> = <SPC> set ( ) <NL> <TAB> i , <SPC> l <SPC> = <SPC> 0 , <SPC> len ( text ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> l : <NL>          l <SPC> = <SPC> min ( l , <SPC> i <SPC> + <SPC> KMP ( text , <SPC> i , <SPC> result ) ) <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> len ( result ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> distinctEchoSubstrings ( self , <SPC> text ) : <NL> <NL> <TAB> result <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> l <SPC> in <SPC> xrange ( 1 , <SPC> len ( text ) <SPC> // <SPC> 2 <SPC> + <SPC> 1 ) : <NL>          count <SPC> = <SPC> sum ( text [ i ] <SPC> == <SPC> text [ i <SPC> + <SPC> l ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( l ) ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( text ) <SPC> - <SPC> 2 <SPC> * <SPC> l ) : <NL>              if <SPC> count <SPC> == <SPC> l : <NL>                  result . add ( text [ i : <SPC> i <SPC> + <SPC> l ] ) <NL>              count <SPC> += <SPC> ( text [ i <SPC> + <SPC> l ] <SPC> == <SPC> text [ i <SPC> + <SPC> l <SPC> + <SPC> l ] ) <SPC> -                  ( text [ i ] <SPC> == <SPC> text [ i <SPC> + <SPC> l ] ) <NL>          if <SPC> count <SPC> == <SPC> l : <NL>              result . add ( text [ len ( text ) <SPC> - <SPC> 2 <SPC> * <SPC> l : <SPC> len ( text ) <SPC> - <SPC> 2 <SPC> * <SPC> l <SPC> + <SPC> l ] ) <NL> <TAB> return <SPC> len ( result ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> distinctEchoSubstrings ( self , <SPC> text ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> D <SPC> = <SPC> 27 <NL> <TAB> result <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( text ) <SPC> - <SPC> 1 ) : <NL>          left , <SPC> right , <SPC> pow_D <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 1 <NL>          for <SPC> l <SPC> in <SPC> xrange ( 1 , <SPC> min ( i <SPC> + <SPC> 2 , <SPC> len ( text ) <SPC> - <SPC> i ) ) : <NL>              left <SPC> = <SPC> ( D <SPC> * <SPC> left <SPC> + <SPC> ( ord ( text [ i <SPC> - <SPC> l <SPC> + <SPC> 1 ] ) <SPC> - <SPC> ord ( "a" ) <SPC> + <SPC> 1 ) ) <SPC> % <SPC> MOD <NL>              right <SPC> = <SPC> ( pow_D <SPC> * <SPC> ( ord ( text [ i <SPC> + <SPC> l ] ) <SPC> - <SPC> ord ( "a" ) <SPC> + <SPC> 1 ) <SPC> + <SPC> right ) <SPC> % <SPC> MOD <NL>              if <SPC> left <SPC> == <SPC> right : <NL>                  result . add ( left ) <NL>              pow_D <SPC> = <SPC> ( pow_D <SPC> * <SPC> D ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> len ( result ) <NL> <NL> <NL> class <SPC> Solution_TLE ( object ) : <NL> <TAB> def <SPC> distinctEchoSubstrings ( self , <SPC> text ) : <NL> <NL> <TAB> def <SPC> compare ( text , <SPC> l , <SPC> s1 , <SPC> s2 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( l ) : <NL>              if <SPC> text [ s1 <SPC> + <SPC> i ] <SPC> != <SPC> text [ s2 <SPC> + <SPC> i ] : <NL>                  return <SPC> False <NL>          return <SPC> True <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> D <SPC> = <SPC> 27 <NL> <TAB> result <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( text ) ) : <NL>          left , <SPC> right , <SPC> pow_D <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 1 <NL>          for <SPC> l <SPC> in <SPC> xrange ( 1 , <SPC> min ( i <SPC> + <SPC> 2 , <SPC> len ( text ) <SPC> - <SPC> i ) ) : <NL>              left <SPC> = <SPC> ( D <SPC> * <SPC> left <SPC> + <SPC> ( ord ( text [ i <SPC> - <SPC> l <SPC> + <SPC> 1 ] ) <SPC> - <SPC> ord ( "a" ) <SPC> + <SPC> 1 ) ) <SPC> % <SPC> MOD <NL>              right <SPC> = <SPC> ( pow_D <SPC> * <SPC> ( ord ( text [ i <SPC> + <SPC> l ] ) <SPC> - <SPC> ord ( "a" ) <SPC> + <SPC> 1 ) <SPC> + <SPC> right ) <SPC> % <SPC> MOD <NL>              if <SPC> left <SPC> == <SPC> right <SPC> and <SPC> compare ( text , <SPC> l , <SPC> i <SPC> - <SPC> l <SPC> + <SPC> 1 , <SPC> i <SPC> + <SPC> 1 ) : <NL>                  result . add ( text [ i <SPC> + <SPC> 1 : <SPC> i <SPC> + <SPC> 1 <SPC> + <SPC> l ] ) <NL>              pow_D <SPC> = <SPC> ( pow_D <SPC> * <SPC> D ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> len ( result ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> distinctSubseqII ( self , <SPC> S ) : <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> result , <SPC> dp <SPC> = <SPC> 0 , <SPC> [ 0 ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          result , <SPC> dp [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> ( <NL>              2 <SPC> * <SPC> result <SPC> - <SPC> dp [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> + <SPC> 1 , <NL>              result <SPC> + <SPC> 1 , <NL>          ) <NL> <TAB> return <SPC> result <SPC> % <SPC> M <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> numDistinct ( self , <SPC> S , <SPC> T ) : <NL> <TAB> ways <SPC> = <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( T ) <SPC> + <SPC> 1 ) ] <NL> <TAB> ways [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> S_char <SPC> in <SPC> S : <NL>          for <SPC> j , <SPC> T_char <SPC> in <SPC> reversed ( list ( enumerate ( T ) ) ) : <NL>              if <SPC> S_char <SPC> == <SPC> T_char : <NL>                  ways [ j <SPC> + <SPC> 1 ] <SPC> += <SPC> ways [ j ] <NL> <TAB> return <SPC> ways [ len ( T ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> distributeCandies ( self , <SPC> candies , <SPC> num_people ) : <NL> <NL> <TAB> p <SPC> = <SPC> int ( ( 2 <SPC> * <SPC> candies <SPC> + <SPC> 0.25 ) <SPC> ** <SPC> 0.5 <SPC> - <SPC> 0.5 ) <NL> <TAB> remaining <SPC> = <SPC> candies <SPC> - <SPC> ( p <SPC> + <SPC> 1 ) <SPC> * <SPC> p <SPC> // <SPC> 2 <NL> <TAB> rows , <SPC> cols <SPC> = <SPC> divmod ( p , <SPC> num_people ) <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> num_people <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( num_people ) : <NL>          result [ i ] <SPC> = <SPC> ( <NL>              ( i <SPC> + <SPC> 1 ) <SPC> * <SPC> ( rows <SPC> + <SPC> 1 ) <SPC> + <SPC> ( rows <SPC> * <SPC> ( rows <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 ) <SPC> * <SPC> num_people <NL>              if <SPC> i <SPC> < <SPC> cols <NL>              else <SPC> ( i <SPC> + <SPC> 1 ) <SPC> * <SPC> rows <SPC> + <SPC> ( ( rows <SPC> - <SPC> 1 ) <SPC> * <SPC> rows <SPC> // <SPC> 2 ) <SPC> * <SPC> num_people <NL>          ) <NL> <TAB> result [ cols ] <SPC> += <SPC> remaining <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> distributeCandies ( self , <SPC> candies , <SPC> num_people ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> candies <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> ( ( mid <SPC> <= <SPC> candies <SPC> * <SPC> 2 <SPC> // <SPC> ( mid <SPC> + <SPC> 1 ) ) ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> p <SPC> = <SPC> right <NL> <TAB> remaining <SPC> = <SPC> candies <SPC> - <SPC> ( p <SPC> + <SPC> 1 ) <SPC> * <SPC> p <SPC> // <SPC> 2 <NL> <TAB> rows , <SPC> cols <SPC> = <SPC> divmod ( p , <SPC> num_people ) <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> num_people <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( num_people ) : <NL>          result [ i ] <SPC> = <SPC> ( <NL>              ( i <SPC> + <SPC> 1 ) <SPC> * <SPC> ( rows <SPC> + <SPC> 1 ) <SPC> + <SPC> ( rows <SPC> * <SPC> ( rows <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 ) <SPC> * <SPC> num_people <NL>              if <SPC> i <SPC> < <SPC> cols <NL>              else <SPC> ( i <SPC> + <SPC> 1 ) <SPC> * <SPC> rows <SPC> + <SPC> ( ( rows <SPC> - <SPC> 1 ) <SPC> * <SPC> rows <SPC> // <SPC> 2 ) <SPC> * <SPC> num_people <NL>          ) <NL> <TAB> result [ cols ] <SPC> += <SPC> remaining <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> distributeCandies ( self , <SPC> candies , <SPC> num_people ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> num_people <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> candies <SPC> != <SPC> 0 : <NL>          result [ i <SPC> % <SPC> num_people ] <SPC> += <SPC> min ( candies , <SPC> i <SPC> + <SPC> 1 ) <NL>          candies <SPC> -= <SPC> min ( candies , <SPC> i <SPC> + <SPC> 1 ) <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> distributeCandies ( self , <SPC> candies ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( candies ) <NL> <TAB> return <SPC> min ( len ( lookup ) , <SPC> len ( candies ) <SPC> / <SPC> 2 ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> distributeCoins ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( root , <SPC> result ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 <NL>          left , <SPC> right <SPC> = <SPC> dfs ( root . left , <SPC> result ) , <SPC> dfs ( root . right , <SPC> result ) <NL>          result [ 0 ] <SPC> += <SPC> abs ( left ) <SPC> + <SPC> abs ( right ) <NL>          return <SPC> root . val <SPC> + <SPC> left <SPC> + <SPC> right <SPC> - <SPC> 1 <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> dfs ( root , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canDistribute ( self , <SPC> nums , <SPC> quantity ) : <NL> <NL> <TAB> def <SPC> nth_element ( nums , <SPC> n , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) : <NL>          def <SPC> tri_partition ( nums , <SPC> left , <SPC> right , <SPC> target , <SPC> compare ) : <NL>              mid <SPC> = <SPC> left <NL>              while <SPC> mid <SPC> <= <SPC> right : <NL>                  if <SPC> nums [ mid ] <SPC> == <SPC> target : <NL>                      mid <SPC> += <SPC> 1 <NL>                  elif <SPC> compare ( nums [ mid ] , <SPC> target ) : <NL>                      nums [ left ] , <SPC> nums [ mid ] <SPC> = <SPC> nums [ mid ] , <SPC> nums [ left ] <NL>                      left <SPC> += <SPC> 1 <NL>                      mid <SPC> += <SPC> 1 <NL>                  else : <NL>                      nums [ mid ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ mid ] <NL>                      right <SPC> -= <SPC> 1 <NL>              return <SPC> left , <SPC> right <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              pivot_left , <SPC> pivot_right <SPC> = <SPC> tri_partition ( <NL>                  nums , <SPC> left , <SPC> right , <SPC> nums [ pivot_idx ] , <SPC> compare <NL>              ) <NL>              if <SPC> pivot_left <SPC> <= <SPC> n <SPC> <= <SPC> pivot_right : <NL>                  return <NL>              elif <SPC> pivot_left <SPC> > <SPC> n : <NL>                  right <SPC> = <SPC> pivot_left <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> pivot_right <SPC> + <SPC> 1 <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( nums ) <NL> <TAB> total <SPC> = <SPC> ( 1 <SPC> << <SPC> len ( quantity ) ) <SPC> - <SPC> 1 <NL> <TAB> requirement <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( total <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> mask <SPC> in <SPC> xrange ( len ( requirement ) ) : <NL>          base <SPC> = <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( quantity ) ) : <NL>              if <SPC> mask <SPC> & <SPC> base : <NL>                  requirement [ mask ] <SPC> += <SPC> quantity [ i ] <NL>              base <SPC> <<= <SPC> 1 <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( total <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> cnts <SPC> = <SPC> count . values ( ) <NL> <TAB> if <SPC> len ( quantity ) <SPC> < <SPC> len ( cnts ) : <NL>          nth_element ( cnts , <SPC> len ( quantity ) <SPC> - <SPC> 1 , <SPC> lambda <SPC> a , <SPC> b : <SPC> a <SPC> > <SPC> b ) <NL>          cnts <SPC> = <SPC> cnts [ : <SPC> len ( quantity ) ] <NL> <TAB> for <SPC> cnt <SPC> in <SPC> cnts : <NL>          dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( total <SPC> + <SPC> 1 ) <NL> <NL>          for <SPC> mask <SPC> in <SPC> reversed ( xrange ( total <SPC> + <SPC> 1 ) ) : <NL>              dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ mask ] <SPC> |= <SPC> dp [ i <SPC> % <SPC> 2 ] [ mask ] <NL>              submask <SPC> = <SPC> mask <NL>              while <SPC> submask <SPC> > <SPC> 0 : <NL>                  if <SPC> requirement [ submask ] <SPC> <= <SPC> cnt <SPC> and <SPC> dp [ i <SPC> % <SPC> 2 ] [ mask <SPC> ^ <SPC> submask ] : <NL>                      dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ mask ] <SPC> = <SPC> 1 <NL>                  submask <SPC> = <SPC> ( submask <SPC> - <SPC> 1 ) <SPC> & <SPC> mask <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> dp [ len ( cnts ) <SPC> % <SPC> 2 ] [ total ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPossibleDivide ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( nums ) <NL> <TAB> for <SPC> num <SPC> in <SPC> sorted ( count . keys ( ) ) : <NL>          c <SPC> = <SPC> count [ num ] <NL>          if <SPC> not <SPC> c : <NL>              continue <NL>          for <SPC> i <SPC> in <SPC> xrange ( num , <SPC> num <SPC> + <SPC> k ) : <NL>              if <SPC> count [ i ] <SPC> < <SPC> c : <NL>                  return <SPC> False <NL>              count [ i ] <SPC> -= <SPC> c <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canDivideIntoSubsequences ( self , <SPC> nums , <SPC> K ) : <NL> <NL> <TAB> curr , <SPC> max_count <SPC> = <SPC> 1 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( nums ) ) : <NL>          curr <SPC> = <SPC> 1 <SPC> if <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> nums [ i ] <SPC> else <SPC> curr <SPC> + <SPC> 1 <NL>          max_count <SPC> = <SPC> max ( max_count , <SPC> curr ) <NL> <TAB> return <SPC> K <SPC> * <SPC> max_count <SPC> <= <SPC> len ( nums ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximizeSweetness ( self , <SPC> sweetness , <SPC> K ) : <NL> <NL> <TAB> def <SPC> check ( sweetness , <SPC> K , <SPC> x ) : <NL>          curr , <SPC> cuts <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> s <SPC> in <SPC> sweetness : <NL>              curr <SPC> += <SPC> s <NL>              if <SPC> curr <SPC> >= <SPC> x : <NL>                  cuts <SPC> += <SPC> 1 <NL>                  curr <SPC> = <SPC> 0 <NL>          return <SPC> cuts <SPC> >= <SPC> K <SPC> + <SPC> 1 <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> min ( sweetness ) , <SPC> sum ( sweetness ) <SPC> // <SPC> ( K <SPC> + <SPC> 1 ) <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( sweetness , <SPC> K , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> divide ( self , <SPC> dividend , <SPC> divisor ) : <NL> <NL> <TAB> result , <SPC> dvd , <SPC> dvs <SPC> = <SPC> 0 , <SPC> abs ( dividend ) , <SPC> abs ( divisor ) <NL> <TAB> while <SPC> dvd <SPC> >= <SPC> dvs : <NL>          inc <SPC> = <SPC> dvs <NL>          i <SPC> = <SPC> 0 <NL>          while <SPC> dvd <SPC> >= <SPC> inc : <NL>              dvd <SPC> -= <SPC> inc <NL>              result <SPC> += <SPC> 1 <SPC> << <SPC> i <NL>              inc <SPC> <<= <SPC> 1 <NL>              i <SPC> += <SPC> 1 <NL> <TAB> if <SPC> dividend <SPC> > <SPC> 0 <SPC> and <SPC> divisor <SPC> < <SPC> 0 <SPC> or <SPC> dividend <SPC> < <SPC> 0 <SPC> and <SPC> divisor <SPC> > <SPC> 0 : <NL>          return <SPC> - result <NL> <TAB> else : <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> divide2 ( self , <SPC> dividend , <SPC> divisor ) : <NL> <NL> <TAB> positive <SPC> = <SPC> ( dividend <SPC> < <SPC> 0 ) <SPC> is <SPC> ( divisor <SPC> < <SPC> 0 ) <NL> <TAB> dividend , <SPC> divisor <SPC> = <SPC> abs ( dividend ) , <SPC> abs ( divisor ) <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> while <SPC> dividend <SPC> >= <SPC> divisor : <NL>          temp , <SPC> i <SPC> = <SPC> divisor , <SPC> 1 <NL>          while <SPC> dividend <SPC> >= <SPC> temp : <NL>              dividend <SPC> -= <SPC> temp <NL>              res <SPC> += <SPC> i <NL>              i <SPC> <<= <SPC> 1 <NL>              temp <SPC> <<= <SPC> 1 <NL> <TAB> if <SPC> not <SPC> positive : <NL>          res <SPC> = <SPC> - res <NL> <TAB> return <SPC> min ( max ( - 2147483648 , <SPC> res ) , <SPC> 2147483647 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> divisorGame ( self , <SPC> N ) : <NL> <NL> <TAB> return <SPC> N <SPC> % <SPC> 2 <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> divisorGame ( self , <SPC> N ) : <NL> <NL> <TAB> def <SPC> memoization ( N , <SPC> dp ) : <NL>          if <SPC> N <SPC> == <SPC> 1 : <NL>              return <SPC> False <NL>          if <SPC> N <SPC> not <SPC> in <SPC> dp : <NL>              result <SPC> = <SPC> False <NL>              for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> N <SPC> + <SPC> 1 ) : <NL>                  if <SPC> i <SPC> * <SPC> i <SPC> > <SPC> N : <NL>                      break <NL>                  if <SPC> N <SPC> % <SPC> i <SPC> == <SPC> 0 : <NL>                      if <SPC> not <SPC> memoization ( N <SPC> - <SPC> i , <SPC> dp ) : <NL>                          result <SPC> = <SPC> True <NL>                          break <NL>              dp [ N ] <SPC> = <SPC> result <NL>          return <SPC> dp [ N ] <NL> <NL> <TAB> return <SPC> memoization ( N , <SPC> { } ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numTilings ( self , <SPC> N ) : <NL> <NL> <TAB> M <SPC> = <SPC> int ( 1e9 <SPC> + <SPC> 7 ) <NL> <NL> <TAB> def <SPC> matrix_expo ( A , <SPC> K ) : <NL>          result <SPC> = <SPC> [ [ int ( i <SPC> == <SPC> j ) <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>                    for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>          while <SPC> K : <NL>              if <SPC> K <SPC> % <SPC> 2 : <NL>                  result <SPC> = <SPC> matrix_mult ( result , <SPC> A ) <NL>              A <SPC> = <SPC> matrix_mult ( A , <SPC> A ) <NL>              K <SPC> /= <SPC> 2 <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> matrix_mult ( A , <SPC> B ) : <NL>          ZB <SPC> = <SPC> zip ( * B ) <NL>          return <SPC> [ <NL>              [ sum ( a <SPC> * <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( row , <SPC> col ) ) <SPC> % <SPC> M <SPC> for <SPC> col <SPC> in <SPC> ZB ] <NL>              for <SPC> row <SPC> in <SPC> A <NL>          ] <NL> <NL> <TAB> T <SPC> = <SPC> [ <NL>          [ 1 , <SPC> 0 , <SPC> 0 , <SPC> 1 ] , <NL>          [ 1 , <SPC> 0 , <SPC> 1 , <SPC> 0 ] , <NL>          [ 1 , <SPC> 1 , <SPC> 0 , <SPC> 0 ] , <NL>          [ 1 , <SPC> 1 , <SPC> 1 , <SPC> 0 ] , <NL> <TAB> ] <NL> <NL> <TAB> return <SPC> matrix_mult ( [ [ 1 , <SPC> 0 , <SPC> 0 , <SPC> 0 ] ] , <SPC> matrix_expo ( T , <SPC> N ) ) [ 0 ] [ <NL>          0 <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numTilings ( self , <SPC> N ) : <NL> <NL> <TAB> M <SPC> = <SPC> int ( 1e9 <SPC> + <SPC> 7 ) <NL> <TAB> dp <SPC> = <SPC> [ 1 , <SPC> 1 , <SPC> 2 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 3 , <SPC> N <SPC> + <SPC> 1 ) : <NL>          dp [ i <SPC> % <SPC> 3 ] <SPC> = <SPC> ( 2 <SPC> * <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 3 ] <SPC> % <SPC> M <SPC> + <SPC> dp [ ( i <SPC> - <SPC> 3 ) <SPC> % <SPC> 3 ] ) <SPC> % <SPC> M <NL> <TAB> return <SPC> dp [ N <SPC> % <SPC> 3 ] <NL> <NL> <NL> class <SPC> SparseVector : <NL> <TAB> def <SPC> __init__ ( self , <SPC> nums ) : <NL> <NL> <TAB> self . lookup <SPC> = <SPC> { i : <SPC> v <SPC> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( nums ) <SPC> if <SPC> v } <NL> <NL> <TAB> def <SPC> dotProduct ( self , <SPC> vec ) : <NL> <NL> <TAB> if <SPC> len ( self . lookup ) <SPC> > <SPC> len ( vec . lookup ) : <NL>          self , <SPC> vec <SPC> = <SPC> vec , <SPC> self <NL> <TAB> return <SPC> sum ( <NL>          v <SPC> * <SPC> vec . lookup [ i ] <SPC> for <SPC> i , <SPC> v <SPC> in <SPC> self . lookup . iteritems ( ) <SPC> if <SPC> i <SPC> in <SPC> vec . lookup <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> predictPartyVictory ( self , <SPC> senate ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( senate ) <NL> <TAB> radiant , <SPC> dire <SPC> = <SPC> collections . deque ( ) , <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( senate ) : <NL>          if <SPC> c <SPC> == <SPC> "R" : <NL>              radiant . append ( i ) <NL>          else : <NL>              dire . append ( i ) <NL> <TAB> while <SPC> radiant <SPC> and <SPC> dire : <NL>          r_idx , <SPC> d_idx <SPC> = <SPC> radiant . popleft ( ) , <SPC> dire . popleft ( ) <NL>          if <SPC> r_idx <SPC> < <SPC> d_idx : <NL>              radiant . append ( r_idx <SPC> + <SPC> n ) <NL>          else : <NL>              dire . append ( d_idx <SPC> + <SPC> n ) <NL> <TAB> return <SPC> "Radiant" <SPC> if <SPC> len ( radiant ) <SPC> > <SPC> len ( dire ) <SPC> else <SPC> "Dire" <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> calculateMinimumHP ( self , <SPC> dungeon ) : <NL> <TAB> DP <SPC> = <SPC> [ float ( "inf" ) <SPC> for <SPC> _ <SPC> in <SPC> dungeon [ 0 ] ] <NL> <TAB> DP [ - 1 ] <SPC> = <SPC> 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( dungeon ) ) ) : <NL>          DP [ - 1 ] <SPC> = <SPC> max ( DP [ - 1 ] <SPC> - <SPC> dungeon [ i ] [ - 1 ] , <SPC> 1 ) <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( dungeon [ i ] ) <SPC> - <SPC> 1 ) ) : <NL>              min_HP_on_exit <SPC> = <SPC> min ( DP [ j ] , <SPC> DP [ j <SPC> + <SPC> 1 ] ) <NL>              DP [ j ] <SPC> = <SPC> max ( min_HP_on_exit <SPC> - <SPC> dungeon [ i ] [ j ] , <SPC> 1 ) <NL> <NL> <TAB> return <SPC> DP [ 0 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> calculateMinimumHP ( self , <SPC> dungeon ) : <NL> <TAB> maximum_loses <SPC> = <SPC> 0 <NL> <TAB> for <SPC> rooms <SPC> in <SPC> dungeon : <NL>          for <SPC> room <SPC> in <SPC> rooms : <NL>              if <SPC> room <SPC> < <SPC> 0 : <NL>                  maximum_loses <SPC> += <SPC> abs ( room ) <NL> <NL> <TAB> return <SPC> self . binarySearch ( dungeon , <SPC> maximum_loses ) <NL> <NL> <TAB> def <SPC> binarySearch ( self , <SPC> dungeon , <SPC> maximum_loses ) : <NL> <TAB> start , <SPC> end <SPC> = <SPC> 1 , <SPC> maximum_loses <SPC> + <SPC> 1 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> start <SPC> < <SPC> end : <NL>          mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> / <SPC> 2 <NL>          if <SPC> self . DP ( dungeon , <SPC> mid ) : <NL>              end <SPC> = <SPC> mid <NL>          else : <NL>              start <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> start <NL> <NL> <TAB> def <SPC> DP ( self , <SPC> dungeon , <SPC> HP ) : <NL> <TAB> remain_HP <SPC> = <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> dungeon [ 0 ] ] <NL> <TAB> remain_HP [ 0 ] <SPC> = <SPC> HP <SPC> + <SPC> dungeon [ 0 ] [ 0 ] <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( remain_HP ) ) : <NL>          if <SPC> remain_HP [ j <SPC> - <SPC> 1 ] <SPC> > <SPC> 0 : <NL>              remain_HP [ j ] <SPC> = <SPC> max ( remain_HP [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> dungeon [ 0 ] [ j ] , <SPC> 0 ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( dungeon ) ) : <NL>          if <SPC> remain_HP [ 0 ] <SPC> > <SPC> 0 : <NL>              remain_HP [ 0 ] <SPC> = <SPC> max ( remain_HP [ 0 ] <SPC> + <SPC> dungeon [ i ] [ 0 ] , <SPC> 0 ) <NL>          else : <NL>              remain_HP [ 0 ] <SPC> = <SPC> 0 <NL> <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( remain_HP ) ) : <NL>              remain <SPC> = <SPC> 0 <NL>              if <SPC> remain_HP [ j <SPC> - <SPC> 1 ] <SPC> > <SPC> 0 : <NL>                  remain <SPC> = <SPC> max ( remain_HP [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> dungeon [ i ] [ j ] , <SPC> remain ) <NL>              if <SPC> remain_HP [ j ] <SPC> > <SPC> 0 : <NL>                  remain <SPC> = <SPC> max ( remain_HP [ j ] <SPC> + <SPC> dungeon [ i ] [ j ] , <SPC> remain ) <NL>              remain_HP [ j ] <SPC> = <SPC> remain <NL> <NL> <TAB> return <SPC> remain_HP [ - 1 ] <SPC> > <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> duplicateZeros ( self , <SPC> arr ) : <NL> <NL> <TAB> shift , <SPC> i <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> + <SPC> shift <SPC> < <SPC> len ( arr ) : <NL>          shift <SPC> += <SPC> int ( arr [ i ] <SPC> == <SPC> 0 ) <NL>          i <SPC> += <SPC> 1 <NL> <TAB> i <SPC> -= <SPC> 1 <NL> <TAB> while <SPC> shift : <NL>          if <SPC> i <SPC> + <SPC> shift <SPC> < <SPC> len ( arr ) : <NL>              arr [ i <SPC> + <SPC> shift ] <SPC> = <SPC> arr [ i ] <NL>          if <SPC> arr [ i ] <SPC> == <SPC> 0 : <NL>              shift <SPC> -= <SPC> 1 <NL>              arr [ i <SPC> + <SPC> shift ] <SPC> = <SPC> arr [ i ] <NL>          i <SPC> -= <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> minDistance ( self , <SPC> word1 , <SPC> word2 ) : <NL> <TAB> if <SPC> len ( word1 ) <SPC> < <SPC> len ( word2 ) : <NL>          return <SPC> self . minDistance ( word2 , <SPC> word1 ) <NL> <NL> <TAB> distance <SPC> = <SPC> [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( word2 ) <SPC> + <SPC> 1 ) ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( word1 ) <SPC> + <SPC> 1 ) : <NL>          pre_distance_i_j <SPC> = <SPC> distance [ 0 ] <NL>          distance [ 0 ] <SPC> = <SPC> i <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( word2 ) <SPC> + <SPC> 1 ) : <NL>              insert <SPC> = <SPC> distance [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 <NL>              delete <SPC> = <SPC> distance [ j ] <SPC> + <SPC> 1 <NL>              replace <SPC> = <SPC> pre_distance_i_j <NL>              if <SPC> word1 [ i <SPC> - <SPC> 1 ] <SPC> != <SPC> word2 [ j <SPC> - <SPC> 1 ] : <NL>                  replace <SPC> += <SPC> 1 <NL>              pre_distance_i_j <SPC> = <SPC> distance [ j ] <NL>              distance [ j ] <SPC> = <SPC> min ( insert , <SPC> delete , <SPC> replace ) <NL> <NL> <TAB> return <SPC> distance [ - 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> minDistance ( self , <SPC> word1 , <SPC> word2 ) : <NL> <TAB> distance <SPC> = <SPC> [ [ i ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( word1 ) <SPC> + <SPC> 1 ) ] <NL> <TAB> distance [ 0 ] <SPC> = <SPC> [ j <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( word2 ) <SPC> + <SPC> 1 ) ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( word1 ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( word2 ) <SPC> + <SPC> 1 ) : <NL>              insert <SPC> = <SPC> distance [ i ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 <NL>              delete <SPC> = <SPC> distance [ i <SPC> - <SPC> 1 ] [ j ] <SPC> + <SPC> 1 <NL>              replace <SPC> = <SPC> distance [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <NL>              if <SPC> word1 [ i <SPC> - <SPC> 1 ] <SPC> != <SPC> word2 [ j <SPC> - <SPC> 1 ] : <NL>                  replace <SPC> += <SPC> 1 <NL>              distance [ i ] . append ( min ( insert , <SPC> delete , <SPC> replace ) ) <NL> <NL> <TAB> return <SPC> distance [ - 1 ] [ - 1 ] <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findSpecialInteger ( self , <SPC> arr ) : <NL> <NL> <TAB> for <SPC> x <SPC> in <SPC> [ arr [ len ( arr ) <SPC> // <SPC> 4 ] , <SPC> arr [ len ( arr ) <SPC> // <SPC> 2 ] , <SPC> arr [ len ( arr ) <SPC> * <SPC> 3 <SPC> // <SPC> 4 ] ] : <NL>          if <SPC> ( bisect . bisect_right ( arr , <SPC> x ) <SPC> - <SPC> bisect . bisect_left ( arr , <SPC> x ) ) <SPC> * <SPC> 4 <SPC> > <SPC> len ( <NL>              arr <NL>          ) : <NL>              return <SPC> x <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lastRemaining ( self , <SPC> n ) : <NL> <NL> <TAB> start , <SPC> step , <SPC> direction <SPC> = <SPC> 1 , <SPC> 2 , <SPC> 1 <NL> <TAB> while <SPC> n <SPC> > <SPC> 1 : <NL>          start <SPC> += <SPC> direction <SPC> * <SPC> ( step <SPC> * <SPC> ( n <SPC> / <SPC> 2 ) <SPC> - <SPC> step <SPC> / <SPC> 2 ) <NL>          n <SPC> /= <SPC> 2 <NL>          step <SPC> *= <SPC> 2 <NL>          direction <SPC> *= <SPC> - 1 <NL> <TAB> return <SPC> start <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Interval ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> s = 0 , <SPC> e = 0 ) : <NL> <TAB> self . start <SPC> = <SPC> s <NL> <TAB> self . end <SPC> = <SPC> e <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> employeeFreeTime ( self , <SPC> schedule ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> min_heap <SPC> = <SPC> [ ( emp [ 0 ] . start , <SPC> eid , <SPC> 0 ) <SPC> for <SPC> eid , <SPC> emp <SPC> in <SPC> enumerate ( schedule ) ] <NL> <TAB> heapq . heapify ( min_heap ) <NL> <TAB> last_end <SPC> = <SPC> - 1 <NL> <TAB> while <SPC> min_heap : <NL>          t , <SPC> eid , <SPC> i <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> 0 <SPC> <= <SPC> last_end <SPC> < <SPC> t : <NL>              result . append ( Interval ( last_end , <SPC> t ) ) <NL>          last_end <SPC> = <SPC> max ( last_end , <SPC> schedule [ eid ] [ i ] . end ) <NL>          if <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( schedule [ eid ] ) : <NL>              heapq . heappush ( min_heap , <SPC> ( schedule [ eid ] [ i <SPC> + <SPC> 1 ] . start , <SPC> eid , <SPC> i <SPC> + <SPC> 1 ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getImportance ( self , <SPC> employees , <SPC> id ) : <NL> <NL> <TAB> if <SPC> employees [ id <SPC> - <SPC> 1 ] <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <TAB> result <SPC> = <SPC> employees [ id <SPC> - <SPC> 1 ] . importance <NL> <TAB> for <SPC> id <SPC> in <SPC> employees [ id <SPC> - <SPC> 1 ] . subordinates : <NL>          result <SPC> += <SPC> self . getImportance ( employees , <SPC> id ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> getImportance ( self , <SPC> employees , <SPC> id ) : <NL> <NL> <TAB> result , <SPC> q <SPC> = <SPC> 0 , <SPC> collections . deque ( [ id ] ) <NL> <TAB> while <SPC> q : <NL>          curr <SPC> = <SPC> q . popleft ( ) <NL>          employee <SPC> = <SPC> employees [ curr <SPC> - <SPC> 1 ] <NL>          result <SPC> += <SPC> employee . importance <NL>          for <SPC> id <SPC> in <SPC> employee . subordinates : <NL>              q . append ( id ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Codec ( object ) : <NL> <TAB> def <SPC> encode ( self , <SPC> strs ) : <NL> <NL> <TAB> encoded_str <SPC> = <SPC> "" <NL> <TAB> for <SPC> s <SPC> in <SPC> strs : <NL>          encoded_str <SPC> += <SPC> "%0*x" <SPC> % <SPC> ( 8 , <SPC> len ( s ) ) <SPC> + <SPC> s <NL> <TAB> return <SPC> encoded_str <NL> <NL> <TAB> def <SPC> decode ( self , <SPC> s ) : <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> strs <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( s ) : <NL>          l <SPC> = <SPC> int ( s [ i : <SPC> i <SPC> + <SPC> 8 ] , <SPC> 16 ) <NL>          strs . append ( s [ i <SPC> + <SPC> 8 : <SPC> i <SPC> + <SPC> 8 <SPC> + <SPC> l ] ) <NL>          i <SPC> += <SPC> 8 <SPC> + <SPC> l <NL> <TAB> return <SPC> strs <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Codec ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __random_length <SPC> = <SPC> 6 <NL> <TAB> self . __tiny_url <SPC> = <SPC> "http://tinyurl.com/" <NL> <TAB> self . __alphabet <SPC> = <SPC> ( <NL>          "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" <NL> <TAB> ) <NL> <TAB> self . __lookup <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> encode ( self , <SPC> longUrl ) : <NL> <NL> <TAB> def <SPC> getRand ( ) : <NL>          rand <SPC> = <SPC> [ ] <NL>          for <SPC> _ <SPC> in <SPC> xrange ( self . __random_length ) : <NL>              rand <SPC> += <SPC> self . __alphabet [ random . randint ( 0 , <NL>                                                     len ( self . __alphabet ) <SPC> - <SPC> 1 ) ] <NL>          return <SPC> "" . join ( rand ) <NL> <NL> <TAB> key <SPC> = <SPC> getRand ( ) <NL> <TAB> while <SPC> key <SPC> in <SPC> self . __lookup : <NL>          key <SPC> = <SPC> getRand ( ) <NL> <TAB> self . __lookup [ key ] <SPC> = <SPC> longUrl <NL> <TAB> return <SPC> self . __tiny_url <SPC> + <SPC> key <NL> <NL> <TAB> def <SPC> decode ( self , <SPC> shortUrl ) : <NL> <NL> <TAB> return <SPC> self . __lookup [ shortUrl [ len ( self . __tiny_url ) : ] ] <NL> <NL> <NL> from <SPC> hashlib <SPC> import <SPC> sha256 <NL> <NL> <NL> class <SPC> Codec2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . _cache <SPC> = <SPC> { } <NL> <TAB> self . url <SPC> = <SPC> "http://tinyurl.com/" <NL> <NL> <TAB> def <SPC> encode ( self , <SPC> long_url ) : <NL> <NL> <TAB> key <SPC> = <SPC> sha256 ( long_url . encode ( ) ) . hexdigest ( ) [ : 6 ] <NL> <TAB> self . _cache [ key ] <SPC> = <SPC> long_url <NL> <TAB> return <SPC> self . url <SPC> + <SPC> key <NL> <NL> <TAB> def <SPC> decode ( self , <SPC> short_url ) : <NL> <NL> <TAB> key <SPC> = <SPC> short_url . replace ( self . url , <SPC> "" ) <NL> <TAB> return <SPC> self . _cache [ key ] <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> children ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . children <SPC> = <SPC> children <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Codec ( object ) : <NL> <TAB> def <SPC> encode ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> encodeHelper ( root , <SPC> parent , <SPC> index ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> None <NL>          node <SPC> = <SPC> TreeNode ( root . val ) <NL>          if <SPC> index <SPC> + <SPC> 1 <SPC> < <SPC> len ( parent . children ) : <NL>              node . left <SPC> = <SPC> encodeHelper ( <NL>                  parent . children [ index <SPC> + <SPC> 1 ] , <SPC> parent , <SPC> index <SPC> + <SPC> 1 ) <NL>          if <SPC> root . children : <NL>              node . right <SPC> = <SPC> encodeHelper ( root . children [ 0 ] , <SPC> root , <SPC> 0 ) <NL>          return <SPC> node <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> None <NL> <TAB> node <SPC> = <SPC> TreeNode ( root . val ) <NL> <TAB> if <SPC> root . children : <NL>          node . right <SPC> = <SPC> encodeHelper ( root . children [ 0 ] , <SPC> root , <SPC> 0 ) <NL> <TAB> return <SPC> node <NL> <NL> <TAB> def <SPC> decode ( self , <SPC> data ) : <NL> <NL> <TAB> def <SPC> decodeHelper ( root , <SPC> parent ) : <NL>          if <SPC> not <SPC> root : <NL>              return <NL>          children <SPC> = <SPC> [ ] <NL>          node <SPC> = <SPC> Node ( root . val , <SPC> children ) <NL>          decodeHelper ( root . right , <SPC> node ) <NL>          parent . children . append ( node ) <NL>          decodeHelper ( root . left , <SPC> parent ) <NL> <NL> <TAB> if <SPC> not <SPC> data : <NL>          return <SPC> None <NL> <TAB> children <SPC> = <SPC> [ ] <NL> <TAB> node <SPC> = <SPC> Node ( data . val , <SPC> children ) <NL> <TAB> decodeHelper ( data . right , <SPC> node ) <NL> <TAB> return <SPC> node <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> encode ( self , <SPC> num ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> num : <NL>          result . append ( "0" <SPC> if <SPC> num <SPC> % <SPC> 2 <SPC> else <SPC> "1" ) <NL>          num <SPC> = <SPC> ( num <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 <NL> <TAB> return <SPC> "" . join ( reversed ( result ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> encode ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> encode_substr ( dp , <SPC> s , <SPC> i , <SPC> j ) : <NL>          temp <SPC> = <SPC> s [ i : <SPC> j <SPC> + <SPC> 1 ] <NL>          pos <SPC> = <SPC> ( temp <SPC> + <SPC> temp ) . find ( temp , <SPC> 1 ) <NL>          if <SPC> pos <SPC> >= <SPC> len ( temp ) : <NL>              return <SPC> temp <NL>          return <SPC> str ( len ( temp ) <SPC> / <SPC> pos ) <SPC> + <SPC> "[" <SPC> + <SPC> dp [ i ] [ i <SPC> + <SPC> pos <SPC> - <SPC> 1 ] <SPC> + <SPC> "]" <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ "" <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( s ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( s ) ) ] <NL> <TAB> for <SPC> length <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> + <SPC> 1 <SPC> - <SPC> length ) : <NL>              j <SPC> = <SPC> i <SPC> + <SPC> length <SPC> - <SPC> 1 <NL>              dp [ i ] [ j ] <SPC> = <SPC> s [ i : <SPC> i <SPC> + <SPC> length ] <NL>              for <SPC> k <SPC> in <SPC> xrange ( i , <SPC> j ) : <NL>                  if <SPC> len ( dp [ i ] [ k ] ) <SPC> + <SPC> len ( dp [ k <SPC> + <SPC> 1 ] [ j ] ) <SPC> < <SPC> len ( dp [ i ] [ j ] ) : <NL>                      dp [ i ] [ j ] <SPC> = <SPC> dp [ i ] [ k ] <SPC> + <SPC> dp [ k <SPC> + <SPC> 1 ] [ j ] <NL>              encoded_string <SPC> = <SPC> encode_substr ( dp , <SPC> s , <SPC> i , <SPC> j ) <NL>              if <SPC> len ( encoded_string ) <SPC> < <SPC> len ( dp [ i ] [ j ] ) : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> encoded_string <NL> <TAB> return <SPC> dp [ 0 ] [ len ( s ) <SPC> - <SPC> 1 ] <NL> <NL> <NL> from <SPC> fractions <SPC> import <SPC> Fraction <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isRationalEqual ( self , <SPC> S , <SPC> T ) : <NL> <NL> <TAB> def <SPC> frac ( S ) : <NL>          if <SPC> "." <SPC> not <SPC> in <SPC> S : <NL>              return <SPC> Fraction ( int ( S ) , <SPC> 1 ) <NL> <NL>          i <SPC> = <SPC> S . index ( "." ) <NL>          result <SPC> = <SPC> Fraction ( int ( S [ : i ] ) , <SPC> 1 ) <NL>          non_int_part <SPC> = <SPC> S [ i <SPC> + <SPC> 1 : ] <NL>          if <SPC> "(" <SPC> not <SPC> in <SPC> non_int_part : <NL>              if <SPC> non_int_part : <NL>                  result <SPC> += <SPC> Fraction ( int ( non_int_part ) , <SPC> 10 <SPC> ** <SPC> len ( non_int_part ) ) <NL>              return <SPC> result <NL> <NL>          i <SPC> = <SPC> non_int_part . index ( "(" ) <NL>          if <SPC> i : <NL>              result <SPC> += <SPC> Fraction ( int ( non_int_part [ : i ] ) , <SPC> 10 <SPC> ** <SPC> i ) <NL>          repeat_part <SPC> = <SPC> non_int_part [ i <SPC> + <SPC> 1 : <SPC> - 1 ] <NL>          result <SPC> += <SPC> Fraction ( int ( repeat_part ) , <SPC> 10 <SPC> ** <SPC> i <SPC> * <NL>                             ( 10 <SPC> ** <SPC> len ( repeat_part ) <SPC> - <SPC> 1 ) ) <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> frac ( S ) <SPC> == <SPC> frac ( T ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minOperations ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> if <SPC> len ( nums1 ) <SPC> * <SPC> 6 <SPC> < <SPC> len ( nums2 ) <SPC> or <SPC> len ( nums1 ) <SPC> > <SPC> len ( nums2 ) <SPC> * <SPC> 6 : <NL>          return <SPC> - 1 <NL> <TAB> diff <SPC> = <SPC> sum ( nums2 ) <SPC> - <SPC> sum ( nums1 ) <NL> <TAB> if <SPC> diff <SPC> < <SPC> 0 : <NL>          nums1 , <SPC> nums2 <SPC> = <SPC> nums2 , <SPC> nums1 <NL>          diff <SPC> = <SPC> - diff <NL> <TAB> count <SPC> = <SPC> collections . Counter ( 6 <SPC> - <SPC> num <SPC> for <SPC> num <SPC> in <SPC> nums1 ) <NL> <TAB> count <SPC> += <SPC> collections . Counter ( num <SPC> - <SPC> 1 <SPC> for <SPC> num <SPC> in <SPC> nums2 ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> 6 ) ) : <NL>          if <SPC> not <SPC> count [ i ] : <NL>              continue <NL>          cnt <SPC> = <SPC> min ( count [ i ] , <SPC> ( diff <SPC> + <SPC> i <SPC> - <SPC> 1 ) <SPC> // <SPC> i ) <NL>          result <SPC> += <SPC> cnt <NL>          diff <SPC> -= <SPC> i <SPC> * <SPC> cnt <NL>          if <SPC> diff <SPC> <= <SPC> 0 : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkEqualTree ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> getSumHelper ( node , <SPC> lookup ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> 0 <NL>          total <SPC> = <SPC> ( <NL>              node . val <NL>              + <SPC> getSumHelper ( node . left , <SPC> lookup ) <NL>              + <SPC> getSumHelper ( node . right , <SPC> lookup ) <NL>          ) <NL>          lookup [ total ] <SPC> += <SPC> 1 <NL>          return <SPC> total <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> total <SPC> = <SPC> getSumHelper ( root , <SPC> lookup ) <NL> <TAB> if <SPC> total <SPC> == <SPC> 0 : <NL>          return <SPC> lookup [ total ] <SPC> > <SPC> 1 <NL> <TAB> return <SPC> total <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> and <SPC> ( total <SPC> / <SPC> 2 ) <SPC> in <SPC> lookup <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> outerTrees ( self , <SPC> points ) : <NL> <NL> <TAB> def <SPC> ccw ( A , <SPC> B , <SPC> C ) : <NL>          return <SPC> ( B [ 0 ] <SPC> - <SPC> A [ 0 ] ) <SPC> * <SPC> ( C [ 1 ] <SPC> - <SPC> A [ 1 ] ) <SPC> - <SPC> ( B [ 1 ] <SPC> - <SPC> A [ 1 ] ) <SPC> * <SPC> ( C [ 0 ] <SPC> - <SPC> A [ 0 ] ) <NL> <NL> <TAB> if <SPC> len ( points ) <SPC> <= <SPC> 1 : <NL>          return <SPC> points <NL> <NL> <TAB> hull <SPC> = <SPC> [ ] <NL> <TAB> points . sort ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> itertools . chain ( <NL>          xrange ( len ( points ) ) , <SPC> reversed ( xrange ( len ( points ) <SPC> - <SPC> 1 ) ) <NL> <TAB> ) : <NL>          while <SPC> len ( hull ) <SPC> >= <SPC> 2 <SPC> and <SPC> ccw ( hull [ - 2 ] , <SPC> hull [ - 1 ] , <SPC> points [ i ] ) <SPC> < <SPC> 0 : <NL>              hull . pop ( ) <NL>          hull . append ( points [ i ] ) <NL> <TAB> hull . pop ( ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> ( len ( hull ) <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 ) : <NL>          if <SPC> hull [ i ] <SPC> != <SPC> hull [ - 1 ] : <NL>              break <NL>          hull . pop ( ) <NL> <TAB> return <SPC> hull <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isEscapePossible ( self , <SPC> blocked , <SPC> source , <SPC> target ) : <NL> <NL> <TAB> R , <SPC> C <SPC> = <SPC> 10 <SPC> ** <SPC> 6 , <SPC> 10 <SPC> ** <SPC> 6 <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> bfs ( blocks , <SPC> source , <SPC> target ) : <NL>          max_area_surrounded_by_blocks <SPC> = <SPC> len ( blocks ) <SPC> * <SPC> ( len ( blocks ) <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 <NL>          lookup <SPC> = <SPC> set ( [ source ] ) <NL>          if <SPC> len ( lookup ) <SPC> > <SPC> max_area_surrounded_by_blocks : <NL>              return <SPC> True <NL>          q <SPC> = <SPC> collections . deque ( [ source ] ) <NL>          while <SPC> q : <NL>              source <SPC> = <SPC> q . popleft ( ) <NL>              if <SPC> source <SPC> == <SPC> target : <NL>                  return <SPC> True <NL>              for <SPC> direction <SPC> in <SPC> directions : <NL>                  nr , <SPC> nc <SPC> = <SPC> source [ 0 ] <SPC> + <SPC> direction [ 0 ] , <SPC> source [ 1 ] <SPC> + <SPC> direction [ 1 ] <NL>                  if <SPC> not <SPC> ( <NL>                      ( 0 <SPC> <= <SPC> nr <SPC> < <SPC> R ) <NL>                      and <SPC> ( 0 <SPC> <= <SPC> nc <SPC> < <SPC> C ) <NL>                      and <SPC> ( nr , <SPC> nc ) <SPC> not <SPC> in <SPC> lookup <NL>                      and <SPC> ( nr , <SPC> nc ) <SPC> not <SPC> in <SPC> blocks <NL>                  ) : <NL>                      continue <NL>                  lookup . add ( ( nr , <SPC> nc ) ) <NL>                  if <SPC> len ( lookup ) <SPC> > <SPC> max_area_surrounded_by_blocks : <NL>                      return <SPC> True <NL>                  q . append ( ( nr , <SPC> nc ) ) <NL>          return <SPC> False <NL> <NL> <TAB> return <SPC> bfs ( set ( map ( tuple , <SPC> blocked ) ) , <SPC> tuple ( source ) , <SPC> tuple ( target ) ) <SPC> and <SPC> bfs ( <NL>          set ( map ( tuple , <SPC> blocked ) ) , <SPC> tuple ( target ) , <SPC> tuple ( source ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> escapeGhosts ( self , <SPC> ghosts , <SPC> target ) : <NL> <NL> <TAB> total <SPC> = <SPC> abs ( target [ 0 ] ) <SPC> + <SPC> abs ( target [ 1 ] ) <NL> <TAB> return <SPC> all ( total <SPC> < <SPC> abs ( target [ 0 ] <SPC> - <SPC> i ) <SPC> + <SPC> abs ( target [ 1 ] <SPC> - <SPC> j ) <SPC> for <SPC> i , <SPC> j <SPC> in <SPC> ghosts ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . set <SPC> = <SPC> { } <NL> <TAB> self . rank <SPC> = <SPC> collections . Counter ( ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> xp , <SPC> xr <SPC> = <SPC> self . set . setdefault ( x , <SPC> ( x , <SPC> 1.0 ) ) <NL> <TAB> if <SPC> x <SPC> != <SPC> xp : <NL>          pp , <SPC> pr <SPC> = <SPC> self . find_set ( xp ) <NL>          self . set [ x ] <SPC> = <SPC> ( pp , <SPC> xr <SPC> * <SPC> pr ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y , <SPC> r ) : <NL> <TAB> ( xp , <SPC> xr ) , <SPC> ( yp , <SPC> yr ) <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> xp <SPC> == <SPC> yp : <NL>          return <SPC> False <NL> <TAB> if <SPC> self . rank [ xp ] <SPC> < <SPC> self . rank [ yp ] : <NL> <NL>          self . set [ xp ] <SPC> = <SPC> ( yp , <SPC> r <SPC> * <SPC> yr <SPC> / <SPC> xr ) <NL> <TAB> elif <SPC> self . rank [ xp ] <SPC> > <SPC> self . rank [ yp ] : <NL> <NL>          self . set [ yp ] <SPC> = <SPC> ( xp , <SPC> 1.0 <SPC> / <SPC> r <SPC> * <SPC> xr <SPC> / <SPC> yr ) <NL> <TAB> else : <NL> <NL>          self . set [ yp ] <SPC> = <SPC> ( xp , <SPC> 1.0 <SPC> / <SPC> r <SPC> * <SPC> xr <SPC> / <SPC> yr ) <NL>          self . rank [ xp ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> query_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> if <SPC> x <SPC> not <SPC> in <SPC> self . set <SPC> or <SPC> y <SPC> not <SPC> in <SPC> self . set : <NL>          return <SPC> - 1.0 <NL> <TAB> ( xp , <SPC> xr ) , <SPC> ( yp , <SPC> yr ) <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> return <SPC> xr <SPC> / <SPC> yr <SPC> if <SPC> xp <SPC> == <SPC> yp <SPC> else <SPC> - 1.0 <NL> <NL> <NL> class <SPC> UnionFindPathCompressionOnly ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . set <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> xp , <SPC> xr <SPC> = <SPC> self . set . setdefault ( x , <SPC> ( x , <SPC> 1.0 ) ) <NL> <TAB> if <SPC> x <SPC> != <SPC> xp : <NL>          pp , <SPC> pr <SPC> = <SPC> self . find_set ( xp ) <NL>          self . set [ x ] <SPC> = <SPC> ( pp , <SPC> xr <SPC> * <SPC> pr ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y , <SPC> r ) : <NL> <TAB> ( xp , <SPC> xr ) , <SPC> ( yp , <SPC> yr ) <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> xp <SPC> == <SPC> yp : <NL>          return <SPC> False <NL> <NL> <TAB> self . set [ xp ] <SPC> = <SPC> ( yp , <SPC> r <SPC> * <SPC> yr <SPC> / <SPC> xr ) <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> query_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> if <SPC> x <SPC> not <SPC> in <SPC> self . set <SPC> or <SPC> y <SPC> not <SPC> in <SPC> self . set : <NL>          return <SPC> - 1.0 <NL> <TAB> ( xp , <SPC> xr ) , <SPC> ( yp , <SPC> yr ) <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> return <SPC> xr <SPC> / <SPC> yr <SPC> if <SPC> xp <SPC> == <SPC> yp <SPC> else <SPC> - 1.0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> calcEquation ( self , <SPC> equations , <SPC> values , <SPC> queries ) : <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( ) <NL> <TAB> for <SPC> ( a , <SPC> b ) , <SPC> k <SPC> in <SPC> itertools . izip ( equations , <SPC> values ) : <NL>          union_find . union_set ( a , <SPC> b , <SPC> k ) <NL> <TAB> return <SPC> [ union_find . query_set ( a , <SPC> b ) <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> queries ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> calcEquation ( self , <SPC> equations , <SPC> values , <SPC> queries ) : <NL> <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( dict ) <NL> <TAB> for <SPC> ( a , <SPC> b ) , <SPC> k <SPC> in <SPC> itertools . izip ( equations , <SPC> values ) : <NL>          adj [ a ] [ b ] <SPC> = <SPC> k <NL>          adj [ b ] [ a ] <SPC> = <SPC> 1.0 <SPC> / <SPC> k <NL> <NL> <TAB> def <SPC> bfs ( adj , <SPC> a , <SPC> b , <SPC> lookup ) : <NL>          if <SPC> a <SPC> not <SPC> in <SPC> adj <SPC> or <SPC> b <SPC> not <SPC> in <SPC> adj : <NL>              return <SPC> - 1.0 <NL>          if <SPC> ( a , <SPC> b ) <SPC> in <SPC> lookup : <NL>              return <SPC> lookup [ a , <SPC> b ] <NL>          visited <SPC> = <SPC> { a } <NL>          q <SPC> = <SPC> collections . deque ( [ ( a , <SPC> 1.0 ) ] ) <NL>          while <SPC> q : <NL>              u , <SPC> val <SPC> = <SPC> q . popleft ( ) <NL>              if <SPC> u <SPC> == <SPC> b : <NL>                  lookup [ a , <SPC> b ] <SPC> = <SPC> val <NL>                  return <SPC> val <NL>              for <SPC> v , <SPC> k <SPC> in <SPC> adj [ u ] . iteritems ( ) : <NL>                  if <SPC> v <SPC> in <SPC> visited : <NL>                      continue <NL>                  visited . add ( v ) <NL>                  q . append ( ( v , <SPC> val <SPC> * <SPC> k ) ) <NL>          lookup [ a , <SPC> b ] <SPC> = <SPC> - 1.0 <NL>          return <SPC> - 1.0 <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> return <SPC> [ bfs ( adj , <SPC> a , <SPC> b , <SPC> lookup ) <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> queries ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> calcEquation ( self , <SPC> equations , <SPC> values , <SPC> queries ) : <NL> <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( dict ) <NL> <TAB> for <SPC> ( a , <SPC> b ) , <SPC> k <SPC> in <SPC> itertools . izip ( equations , <SPC> values ) : <NL>          adj [ a ] [ a ] <SPC> = <SPC> adj [ b ] [ b ] <SPC> = <SPC> 1.0 <NL>          adj [ a ] [ b ] <SPC> = <SPC> k <NL>          adj [ b ] [ a ] <SPC> = <SPC> 1.0 <SPC> / <SPC> k <NL> <TAB> for <SPC> k <SPC> in <SPC> adj : <NL>          for <SPC> i <SPC> in <SPC> adj [ k ] : <NL>              for <SPC> j <SPC> in <SPC> adj [ k ] : <NL>                  adj [ i ] [ j ] <SPC> = <SPC> adj [ i ] [ k ] <SPC> * <SPC> adj [ k ] [ j ] <NL> <TAB> return <SPC> [ adj [ a ] . get ( b , <SPC> - 1.0 ) <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> queries ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> calcEquation ( self , <SPC> equations , <SPC> values , <SPC> query ) : <NL> <NL> <TAB> def <SPC> check ( up , <SPC> down , <SPC> lookup , <SPC> visited ) : <NL>          if <SPC> up <SPC> in <SPC> lookup <SPC> and <SPC> down <SPC> in <SPC> lookup [ up ] : <NL>              return <SPC> ( True , <SPC> lookup [ up ] [ down ] ) <NL>          for <SPC> k , <SPC> v <SPC> in <SPC> lookup [ up ] . iteritems ( ) : <NL>              if <SPC> k <SPC> not <SPC> in <SPC> visited : <NL>                  visited . add ( k ) <NL>                  tmp <SPC> = <SPC> check ( k , <SPC> down , <SPC> lookup , <SPC> visited ) <NL>                  if <SPC> tmp [ 0 ] : <NL>                      return <SPC> ( True , <SPC> v <SPC> * <SPC> tmp [ 1 ] ) <NL>          return <SPC> ( False , <SPC> 0 ) <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( dict ) <NL> <TAB> for <SPC> i , <SPC> e <SPC> in <SPC> enumerate ( equations ) : <NL>          lookup [ e [ 0 ] ] [ e [ 1 ] ] <SPC> = <SPC> values [ i ] <NL>          if <SPC> values [ i ] : <NL>              lookup [ e [ 1 ] ] [ e [ 0 ] ] <SPC> = <SPC> 1.0 <SPC> / <SPC> values [ i ] <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> q <SPC> in <SPC> query : <NL>          visited <SPC> = <SPC> set ( ) <NL>          tmp <SPC> = <SPC> check ( q [ 0 ] , <SPC> q [ 1 ] , <SPC> lookup , <SPC> visited ) <NL>          result . append ( tmp [ 1 ] <SPC> if <SPC> tmp [ 0 ] <SPC> else <SPC> - 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> operator <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> evalRPN ( self , <SPC> tokens ) : <NL> <TAB> numerals , <SPC> operators <SPC> = <SPC> [ ] , <SPC> { <NL>          "+" : <SPC> operator . add , <NL>          "-" : <SPC> operator . sub , <NL>          "*" : <SPC> operator . mul , <NL>          "/" : <SPC> operator . div , <NL> <TAB> } <NL> <TAB> for <SPC> token <SPC> in <SPC> tokens : <NL>          if <SPC> token <SPC> not <SPC> in <SPC> operators : <NL>              numerals . append ( int ( token ) ) <NL>          else : <NL>              y , <SPC> x <SPC> = <SPC> numerals . pop ( ) , <SPC> numerals . pop ( ) <NL>              numerals . append ( int ( operators [ token ] ( x <SPC> * <SPC> 1.0 , <SPC> y ) ) ) <NL> <TAB> return <SPC> numerals . pop ( ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isEvenOddTree ( self , <SPC> root ) : <NL> <NL> <TAB> q <SPC> = <SPC> [ root ] <NL> <TAB> is_odd <SPC> = <SPC> False <NL> <TAB> while <SPC> q : <NL>          new_q <SPC> = <SPC> [ ] <NL>          prev <SPC> = <SPC> None <NL>          for <SPC> node <SPC> in <SPC> q : <NL>              if <SPC> is_odd : <NL>                  if <SPC> node . val <SPC> % <SPC> 2 <SPC> or <SPC> ( prev <SPC> and <SPC> prev . val <SPC> <= <SPC> node . val ) : <NL>                      return <SPC> False <NL>              else : <NL>                  if <SPC> not <SPC> node . val <SPC> % <SPC> 2 <SPC> or <SPC> ( prev <SPC> and <SPC> prev . val <SPC> >= <SPC> node . val ) : <NL>                      return <SPC> False <NL>              if <SPC> node . left : <NL>                  new_q . append ( node . left ) <NL>              if <SPC> node . right : <NL>                  new_q . append ( node . right ) <NL>              prev <SPC> = <SPC> node <NL>          q <SPC> = <SPC> new_q <NL>          is_odd <SPC> = <SPC> not <SPC> is_odd <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> ExamRoom ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> N ) : <NL> <NL> <TAB> self . __num <SPC> = <SPC> N <NL> <TAB> self . __seats <SPC> = <SPC> { - 1 : <SPC> [ - 1 , <SPC> self . __num ] , <SPC> self . __num : <SPC> [ - 1 , <SPC> self . __num ] } <NL> <TAB> self . __max_heap <SPC> = <SPC> [ ( - self . __distance ( ( - 1 , <SPC> self . __num ) ) , <SPC> - 1 , <SPC> self . __num ) ] <NL> <NL> <TAB> def <SPC> seat ( self ) : <NL> <NL> <TAB> while <SPC> ( <NL>          self . __max_heap [ 0 ] [ 1 ] <SPC> not <SPC> in <SPC> self . __seats <NL>          or <SPC> self . __max_heap [ 0 ] [ 2 ] <SPC> not <SPC> in <SPC> self . __seats <NL>          or <SPC> self . __seats [ self . __max_heap [ 0 ] [ 1 ] ] [ 1 ] <SPC> != <SPC> self . __max_heap [ 0 ] [ 2 ] <NL>          or <SPC> self . __seats [ self . __max_heap [ 0 ] [ 2 ] ] [ 0 ] <SPC> != <SPC> self . __max_heap [ 0 ] [ 1 ] <NL> <TAB> ) : <NL>          heapq . heappop ( self . __max_heap ) <NL> <NL> <TAB> _ , <SPC> left , <SPC> right <SPC> = <SPC> heapq . heappop ( self . __max_heap ) <NL> <TAB> mid <SPC> = <SPC> ( <NL>          0 <NL>          if <SPC> left <SPC> == <SPC> - 1 <NL>          else <SPC> self . __num <SPC> - <SPC> 1 <NL>          if <SPC> right <SPC> == <SPC> self . __num <NL>          else <SPC> ( left <SPC> + <SPC> right ) <SPC> // <SPC> 2 <NL> <TAB> ) <NL> <TAB> self . __seats [ mid ] <SPC> = <SPC> [ left , <SPC> right ] <NL> <TAB> heapq . heappush ( self . __max_heap , <SPC> ( - self . __distance ( ( left , <SPC> mid ) ) , <SPC> left , <SPC> mid ) ) <NL> <TAB> heapq . heappush ( self . __max_heap , <NL>                     ( - self . __distance ( ( mid , <SPC> right ) ) , <SPC> mid , <SPC> right ) ) <NL> <TAB> self . __seats [ left ] [ 1 ] <SPC> = <SPC> mid <NL> <TAB> self . __seats [ right ] [ 0 ] <SPC> = <SPC> mid <NL> <TAB> return <SPC> mid <NL> <NL> <TAB> def <SPC> leave ( self , <SPC> p ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> self . __seats [ p ] <NL> <TAB> self . __seats . pop ( p ) <NL> <TAB> self . __seats [ left ] [ 1 ] <SPC> = <SPC> right <NL> <TAB> self . __seats [ right ] [ 0 ] <SPC> = <SPC> left <NL> <TAB> heapq . heappush ( self . __max_heap , <NL>                     ( - self . __distance ( ( left , <SPC> right ) ) , <SPC> left , <SPC> right ) ) <NL> <NL> <TAB> def <SPC> __distance ( self , <SPC> segment ) : <NL> <TAB> return <SPC> ( <NL>          segment [ 1 ] <SPC> - <SPC> segment [ 0 ] <SPC> - <SPC> 1 <NL>          if <SPC> segment [ 0 ] <SPC> == <SPC> - 1 <SPC> or <SPC> segment [ 1 ] <SPC> == <SPC> self . __num <NL>          else <SPC> ( segment [ 1 ] <SPC> - <SPC> segment [ 0 ] ) <SPC> // <SPC> 2 <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> titleToNumber ( self , <SPC> s ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          result <SPC> *= <SPC> 26 <NL>          result <SPC> += <SPC> ord ( s [ i ] ) <SPC> - <SPC> ord ( "A" ) <SPC> + <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> convertToTitle ( self , <SPC> n ) : <NL> <NL> <TAB> result , <SPC> dvd <SPC> = <SPC> "" , <SPC> n <NL> <NL> <TAB> while <SPC> dvd : <NL>          result <SPC> += <SPC> chr ( ( dvd <SPC> - <SPC> 1 ) <SPC> % <SPC> 26 <SPC> + <SPC> ord ( "A" ) ) <NL>          dvd <SPC> = <SPC> ( dvd <SPC> - <SPC> 1 ) <SPC> / <SPC> 26 <NL> <NL> <TAB> return <SPC> result [ : : - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> exclusiveTime ( self , <SPC> n , <SPC> logs ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> stk , <SPC> prev <SPC> = <SPC> [ ] , <SPC> 0 <NL> <TAB> for <SPC> log <SPC> in <SPC> logs : <NL>          tokens <SPC> = <SPC> log . split ( ":" ) <NL>          if <SPC> tokens [ 1 ] <SPC> == <SPC> "start" : <NL>              if <SPC> stk : <NL>                  result [ stk [ - 1 ] ] <SPC> += <SPC> int ( tokens [ 2 ] ) <SPC> - <SPC> prev <NL>              stk . append ( int ( tokens [ 0 ] ) ) <NL>              prev <SPC> = <SPC> int ( tokens [ 2 ] ) <NL>          else : <NL>              result [ stk . pop ( ) ] <SPC> += <SPC> int ( tokens [ 2 ] ) <SPC> - <SPC> prev <SPC> + <SPC> 1 <NL>              prev <SPC> = <SPC> int ( tokens [ 2 ] ) <SPC> + <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> addOperators ( self , <SPC> num , <SPC> target ) : <NL> <NL> <TAB> result , <SPC> expr <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> val , <SPC> i <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> val_str <SPC> = <SPC> "" <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( num ) : <NL>          val <SPC> = <SPC> val <SPC> * <SPC> 10 <SPC> + <SPC> ord ( num [ i ] ) <SPC> - <SPC> ord ( "0" ) <NL>          val_str <SPC> += <SPC> num [ i ] <NL> <NL>          if <SPC> str ( val ) <SPC> != <SPC> val_str : <NL>              break <NL>          expr . append ( val_str ) <NL>          self . addOperatorsDFS ( num , <SPC> target , <SPC> i <SPC> + <SPC> 1 , <SPC> 0 , <SPC> val , <SPC> expr , <SPC> result ) <NL>          expr . pop ( ) <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> addOperatorsDFS ( self , <SPC> num , <SPC> target , <SPC> pos , <SPC> operand1 , <SPC> operand2 , <SPC> expr , <SPC> result ) : <NL> <TAB> if <SPC> pos <SPC> == <SPC> len ( num ) <SPC> and <SPC> operand1 <SPC> + <SPC> operand2 <SPC> == <SPC> target : <NL>          result . append ( "" . join ( expr ) ) <NL> <TAB> else : <NL>          val , <SPC> i <SPC> = <SPC> 0 , <SPC> pos <NL>          val_str <SPC> = <SPC> "" <NL>          while <SPC> i <SPC> < <SPC> len ( num ) : <NL>              val <SPC> = <SPC> val <SPC> * <SPC> 10 <SPC> + <SPC> ord ( num [ i ] ) <SPC> - <SPC> ord ( "0" ) <NL>              val_str <SPC> += <SPC> num [ i ] <NL> <NL>              if <SPC> str ( val ) <SPC> != <SPC> val_str : <NL>                  break <NL> <NL>              expr . append ( "+" <SPC> + <SPC> val_str ) <NL>              self . addOperatorsDFS ( <NL>                  num , <SPC> target , <SPC> i <SPC> + <SPC> 1 , <SPC> operand1 <SPC> + <SPC> operand2 , <SPC> val , <SPC> expr , <SPC> result <NL>              ) <NL>              expr . pop ( ) <NL> <NL>              expr . append ( "-" <SPC> + <SPC> val_str ) <NL>              self . addOperatorsDFS ( <NL>                  num , <SPC> target , <SPC> i <SPC> + <SPC> 1 , <SPC> operand1 <SPC> + <SPC> operand2 , <SPC> - val , <SPC> expr , <SPC> result <NL>              ) <NL>              expr . pop ( ) <NL> <NL>              expr . append ( "*" <SPC> + <SPC> val_str ) <NL>              self . addOperatorsDFS ( <NL>                  num , <SPC> target , <SPC> i <SPC> + <SPC> 1 , <SPC> operand1 , <SPC> operand2 <SPC> * <SPC> val , <SPC> expr , <SPC> result <NL>              ) <NL>              expr . pop ( ) <NL> <NL>              i <SPC> += <SPC> 1 <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> expressiveWords ( self , <SPC> S , <SPC> words ) : <NL> <NL> <TAB> def <SPC> RLE ( S ) : <NL>          return <SPC> itertools . izip ( <NL>              * [ ( k , <SPC> len ( list ( grp ) ) ) <SPC> for <SPC> k , <SPC> grp <SPC> in <SPC> itertools . groupby ( S ) ] <NL>          ) <NL> <NL> <TAB> R , <SPC> count <SPC> = <SPC> RLE ( S ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          R2 , <SPC> count2 <SPC> = <SPC> RLE ( word ) <NL>          if <SPC> R2 <SPC> != <SPC> R : <NL>              continue <NL>          result <SPC> += <SPC> all ( <NL>              c1 <SPC> >= <SPC> max ( c2 , <SPC> 3 ) <SPC> or <SPC> c1 <SPC> == <SPC> c2 <SPC> for <SPC> c1 , <SPC> c2 <SPC> in <SPC> itertools . izip ( count , <SPC> count2 ) <NL>          ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> getFactors ( self , <SPC> n ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> factors <SPC> = <SPC> [ ] <NL> <TAB> self . getResult ( n , <SPC> result , <SPC> factors ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> getResult ( self , <SPC> n , <SPC> result , <SPC> factors ) : <NL> <TAB> i <SPC> = <SPC> 2 <SPC> if <SPC> not <SPC> factors <SPC> else <SPC> factors [ - 1 ] <NL> <TAB> while <SPC> i <SPC> <= <SPC> n <SPC> / <SPC> i : <NL>          if <SPC> n <SPC> % <SPC> i <SPC> == <SPC> 0 : <NL>              factors . append ( i ) <NL>              factors . append ( n <SPC> / <SPC> i ) <NL>              result . append ( list ( factors ) ) <NL>              factors . pop ( ) <NL>              self . getResult ( n <SPC> / <SPC> i , <SPC> result , <SPC> factors ) <NL>              factors . pop ( ) <NL>          i <SPC> += <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> trailingZeroes ( self , <SPC> n ) : <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> n <SPC> > <SPC> 0 : <NL>          result <SPC> += <SPC> n <SPC> / <SPC> 5 <NL>          n <SPC> /= <SPC> 5 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fairCandySwap ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> diff <SPC> = <SPC> ( sum ( A ) <SPC> - <SPC> sum ( B ) ) <SPC> // <SPC> 2 <NL> <TAB> setA <SPC> = <SPC> set ( A ) <NL> <TAB> for <SPC> b <SPC> in <SPC> set ( B ) : <NL>          if <SPC> diff <SPC> + <SPC> b <SPC> in <SPC> setA : <NL>              return <SPC> [ diff <SPC> + <SPC> b , <SPC> b ] <NL> <TAB> return <SPC> [ ] <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fallingSquares ( self , <SPC> positions ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> pos <SPC> = <SPC> [ - 1 ] <NL> <TAB> heights <SPC> = <SPC> [ 0 ] <NL> <TAB> maxH <SPC> = <SPC> 0 <NL> <TAB> for <SPC> left , <SPC> side <SPC> in <SPC> positions : <NL>          l <SPC> = <SPC> bisect . bisect_right ( pos , <SPC> left ) <NL>          r <SPC> = <SPC> bisect . bisect_left ( pos , <SPC> left <SPC> + <SPC> side ) <NL>          high <SPC> = <SPC> max ( heights [ l <SPC> - <SPC> 1 : <SPC> r ] <SPC> or <SPC> [ 0 ] ) <SPC> + <SPC> side <NL>          pos [ l : r ] <SPC> = <SPC> [ left , <SPC> left <SPC> + <SPC> side ] <NL>          heights [ l : r ] <SPC> = <SPC> [ high , <SPC> heights [ r <SPC> - <SPC> 1 ] ] <NL>          maxH <SPC> = <SPC> max ( maxH , <SPC> high ) <NL>          result . append ( maxH ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> SegmentTree ( object ) : <NL> <TAB> def <SPC> __init__ ( <NL>          self , <SPC> N , <SPC> query_fn = min , <SPC> update_fn = lambda <SPC> x , <SPC> y : <SPC> y , <SPC> default_val = float ( "inf" ) <NL> <TAB> ) : <NL> <TAB> self . N <SPC> = <SPC> N <NL> <TAB> self . H <SPC> = <SPC> ( N <SPC> - <SPC> 1 ) . bit_length ( ) <NL> <TAB> self . query_fn <SPC> = <SPC> query_fn <NL> <TAB> self . update_fn <SPC> = <SPC> update_fn <NL> <TAB> self . default_val <SPC> = <SPC> default_val <NL> <TAB> self . tree <SPC> = <SPC> [ default_val ] <SPC> * <SPC> ( 2 <SPC> * <SPC> N ) <NL> <TAB> self . lazy <SPC> = <SPC> [ None ] <SPC> * <SPC> N <NL> <NL> <TAB> def <SPC> __apply ( self , <SPC> x , <SPC> val ) : <NL> <TAB> self . tree [ x ] <SPC> = <SPC> self . update_fn ( self . tree [ x ] , <SPC> val ) <NL> <TAB> if <SPC> x <SPC> < <SPC> self . N : <NL>          self . lazy [ x ] <SPC> = <SPC> self . update_fn ( self . lazy [ x ] , <SPC> val ) <NL> <NL> <TAB> def <SPC> update ( self , <SPC> L , <SPC> R , <SPC> h ) : <NL> <NL> <TAB> def <SPC> pull ( x ) : <NL>          while <SPC> x <SPC> > <SPC> 1 : <NL>              x <SPC> //= <SPC> 2 <NL>              self . tree [ x ] <SPC> = <SPC> self . query_fn ( <NL>                  self . tree [ x <SPC> * <SPC> 2 ] , <SPC> self . tree [ x <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] ) <NL>              if <SPC> self . lazy [ x ] <SPC> is <SPC> not <SPC> None : <NL>                  self . tree [ x ] <SPC> = <SPC> self . update_fn ( self . tree [ x ] , <SPC> self . lazy [ x ] ) <NL> <NL> <TAB> L <SPC> += <SPC> self . N <NL> <TAB> R <SPC> += <SPC> self . N <NL> <TAB> L0 , <SPC> R0 <SPC> = <SPC> L , <SPC> R <NL> <TAB> while <SPC> L <SPC> <= <SPC> R : <NL>          if <SPC> L <SPC> & <SPC> 1 : <NL>              self . __apply ( L , <SPC> h ) <NL>              L <SPC> += <SPC> 1 <NL>          if <SPC> R <SPC> & <SPC> 1 <SPC> == <SPC> 0 : <NL>              self . __apply ( R , <SPC> h ) <NL>              R <SPC> -= <SPC> 1 <NL>          L <SPC> //= <SPC> 2 <NL>          R <SPC> //= <SPC> 2 <NL> <TAB> pull ( L0 ) <NL> <TAB> pull ( R0 ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> L , <SPC> R ) : <NL> <NL> <TAB> def <SPC> push ( x ) : <NL>          n <SPC> = <SPC> 2 <SPC> ** <SPC> self . H <NL>          while <SPC> n <SPC> != <SPC> 1 : <NL>              y <SPC> = <SPC> x <SPC> // <SPC> n <NL>              if <SPC> self . lazy [ y ] <SPC> is <SPC> not <SPC> None : <NL>                  self . __apply ( y <SPC> * <SPC> 2 , <SPC> self . lazy [ y ] ) <NL>                  self . __apply ( y <SPC> * <SPC> 2 <SPC> + <SPC> 1 , <SPC> self . lazy [ y ] ) <NL>                  self . lazy [ y ] <SPC> = <SPC> None <NL>              n <SPC> //= <SPC> 2 <NL> <NL> <TAB> result <SPC> = <SPC> self . default_val <NL> <TAB> if <SPC> L <SPC> > <SPC> R : <NL>          return <SPC> result <NL> <NL> <TAB> L <SPC> += <SPC> self . N <NL> <TAB> R <SPC> += <SPC> self . N <NL> <TAB> push ( L ) <NL> <TAB> push ( R ) <NL> <TAB> while <SPC> L <SPC> <= <SPC> R : <NL>          if <SPC> L <SPC> & <SPC> 1 : <NL>              result <SPC> = <SPC> self . query_fn ( result , <SPC> self . tree [ L ] ) <NL>              L <SPC> += <SPC> 1 <NL>          if <SPC> R <SPC> & <SPC> 1 <SPC> == <SPC> 0 : <NL>              result <SPC> = <SPC> self . query_fn ( result , <SPC> self . tree [ R ] ) <NL>              R <SPC> -= <SPC> 1 <NL>          L <SPC> //= <SPC> 2 <NL>          R <SPC> //= <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> data ( self ) : <NL> <TAB> showList <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . N ) : <NL>          showList . append ( self . query ( i , <SPC> i ) ) <NL> <TAB> return <SPC> showList <NL> <NL> <NL> class <SPC> SegmentTree2 ( object ) : <NL> <TAB> def <SPC> __init__ ( <NL>          self , <SPC> nums , <SPC> query_fn = min , <SPC> update_fn = lambda <SPC> x , <SPC> y : <SPC> y , <SPC> default_val = float ( "inf" ) <NL> <TAB> ) : <NL> <NL> <TAB> N <SPC> = <SPC> len ( nums ) <NL> <TAB> self . __original_length <SPC> = <SPC> N <NL> <TAB> self . __tree_length <SPC> = <SPC> 2 <SPC> ** <SPC> ( N . bit_length ( ) <SPC> + <SPC> ( N <SPC> & <SPC> ( N <SPC> - <SPC> 1 ) <SPC> != <SPC> 0 ) ) <SPC> - <SPC> 1 <NL> <TAB> self . __query_fn <SPC> = <SPC> query_fn <NL> <TAB> self . __update_fn <SPC> = <SPC> update_fn <NL> <TAB> self . __default_val <SPC> = <SPC> default_val <NL> <TAB> self . __tree <SPC> = <SPC> [ default_val <SPC> for <SPC> _ <SPC> in <SPC> range ( self . __tree_length ) ] <NL> <TAB> self . __lazy <SPC> = <SPC> [ None <SPC> for <SPC> _ <SPC> in <SPC> range ( self . __tree_length ) ] <NL> <TAB> self . __constructTree ( nums , <SPC> 0 , <SPC> self . __original_length <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <TAB> def <SPC> update ( self , <SPC> i , <SPC> j , <SPC> val ) : <NL> <TAB> self . __updateTree ( val , <SPC> i , <SPC> j , <SPC> 0 , <SPC> self . __original_length <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> i , <SPC> j ) : <NL> <TAB> return <SPC> self . __queryRange ( i , <SPC> j , <SPC> 0 , <SPC> self . __original_length <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <TAB> def <SPC> __constructTree ( self , <SPC> nums , <SPC> left , <SPC> right , <SPC> idx ) : <NL> <TAB> if <SPC> left <SPC> > <SPC> right : <NL>          return <NL> <TAB> if <SPC> left <SPC> == <SPC> right : <NL>          self . __tree [ idx ] <SPC> = <SPC> self . __update_fn ( self . __tree [ idx ] , <SPC> nums [ left ] ) <NL>          return <NL> <TAB> mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL> <TAB> self . __constructTree ( nums , <SPC> left , <SPC> mid , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ) <NL> <TAB> self . __constructTree ( nums , <SPC> mid <SPC> + <SPC> 1 , <SPC> right , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ) <NL> <TAB> self . __tree [ idx ] <SPC> = <SPC> self . __query_fn ( <NL>          self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] , <SPC> self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ] <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> __apply ( self , <SPC> left , <SPC> right , <SPC> idx , <SPC> val ) : <NL> <TAB> self . __tree [ idx ] <SPC> = <SPC> self . __update_fn ( self . __tree [ idx ] , <SPC> val ) <NL> <TAB> if <SPC> left <SPC> != <SPC> right : <NL>          self . __lazy [ idx <SPC> * <SPC> 2 <SPC> + <NL>                      1 ] <SPC> = <SPC> self . __update_fn ( self . __lazy [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] , <SPC> val ) <NL>          self . __lazy [ idx <SPC> * <SPC> 2 <SPC> + <NL>                      2 ] <SPC> = <SPC> self . __update_fn ( self . __lazy [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ] , <SPC> val ) <NL> <NL> <TAB> def <SPC> __updateTree ( self , <SPC> val , <SPC> range_left , <SPC> range_right , <SPC> left , <SPC> right , <SPC> idx ) : <NL> <TAB> if <SPC> left <SPC> > <SPC> right : <NL>          return <NL> <TAB> if <SPC> self . __lazy [ idx ] <SPC> is <SPC> not <SPC> None : <NL>          self . __apply ( left , <SPC> right , <SPC> idx , <SPC> self . __lazy [ idx ] ) <NL>          self . __lazy [ idx ] <SPC> = <SPC> None <NL> <TAB> if <SPC> range_left <SPC> > <SPC> right <SPC> or <SPC> range_right <SPC> < <SPC> left : <NL>          return <NL> <TAB> if <SPC> range_left <SPC> <= <SPC> left <SPC> and <SPC> right <SPC> <= <SPC> range_right : <NL>          self . __apply ( left , <SPC> right , <SPC> idx , <SPC> val ) <NL>          return <NL> <TAB> mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL> <TAB> self . __updateTree ( val , <SPC> range_left , <SPC> range_right , <SPC> left , <SPC> mid , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ) <NL> <TAB> self . __updateTree ( val , <SPC> range_left , <SPC> range_right , <NL>                        mid <SPC> + <SPC> 1 , <SPC> right , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ) <NL> <TAB> self . __tree [ idx ] <SPC> = <SPC> self . __query_fn ( <NL>          self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] , <SPC> self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ] <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> __queryRange ( self , <SPC> range_left , <SPC> range_right , <SPC> left , <SPC> right , <SPC> idx ) : <NL> <TAB> if <SPC> left <SPC> > <SPC> right : <NL>          return <SPC> self . __default_val <NL> <TAB> if <SPC> self . __lazy [ idx ] <SPC> is <SPC> not <SPC> None : <NL>          self . __apply ( left , <SPC> right , <SPC> idx , <SPC> self . __lazy [ idx ] ) <NL>          self . __lazy [ idx ] <SPC> = <SPC> None <NL> <TAB> if <SPC> right <SPC> < <SPC> range_left <SPC> or <SPC> left <SPC> > <SPC> range_right : <NL>          return <SPC> self . __default_val <NL> <TAB> if <SPC> range_left <SPC> <= <SPC> left <SPC> and <SPC> right <SPC> <= <SPC> range_right : <NL>          return <SPC> self . __tree [ idx ] <NL> <TAB> mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL> <TAB> return <SPC> self . __query_fn ( <NL>          self . __queryRange ( range_left , <SPC> range_right , <SPC> left , <SPC> mid , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ) , <NL>          self . __queryRange ( range_left , <SPC> range_right , <NL>                            mid <SPC> + <SPC> 1 , <SPC> right , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ) , <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> fallingSquares ( self , <SPC> positions ) : <NL> <TAB> index <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> left , <SPC> size <SPC> in <SPC> positions : <NL>          index . add ( left ) <NL>          index . add ( left <SPC> + <SPC> size <SPC> - <SPC> 1 ) <NL> <TAB> index <SPC> = <SPC> sorted ( list ( index ) ) <NL> <TAB> tree <SPC> = <SPC> SegmentTree ( len ( index ) , <SPC> max , <SPC> max , <SPC> 0 ) <NL> <NL> <TAB> max_height <SPC> = <SPC> 0 <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> left , <SPC> size <SPC> in <SPC> positions : <NL>          L , <SPC> R <SPC> = <SPC> bisect . bisect_left ( index , <SPC> left ) , <SPC> bisect . bisect_left ( <NL>              index , <SPC> left <SPC> + <SPC> size <SPC> - <SPC> 1 <NL>          ) <NL>          h <SPC> = <SPC> tree . query ( L , <SPC> R ) <SPC> + <SPC> size <NL>          tree . update ( L , <SPC> R , <SPC> h ) <NL>          max_height <SPC> = <SPC> max ( max_height , <SPC> h ) <NL>          result . append ( max_height ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> fallingSquares ( self , <SPC> positions ) : <NL> <NL> <TAB> def <SPC> query ( heights , <SPC> left , <SPC> right , <SPC> B , <SPC> blocks , <SPC> blocks_read ) : <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> left <SPC> % <SPC> B <SPC> and <SPC> left <SPC> <= <SPC> right : <NL>              result <SPC> = <SPC> max ( result , <SPC> heights [ left ] , <SPC> blocks [ left <SPC> // <SPC> B ] ) <NL>              left <SPC> += <SPC> 1 <NL>          while <SPC> right <SPC> % <SPC> B <SPC> != <SPC> B <SPC> - <SPC> 1 <SPC> and <SPC> left <SPC> <= <SPC> right : <NL>              result <SPC> = <SPC> max ( result , <SPC> heights [ right ] , <SPC> blocks [ right <SPC> // <SPC> B ] ) <NL>              right <SPC> -= <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              result <SPC> = <SPC> max ( result , <SPC> blocks [ left <SPC> // <SPC> B ] , <SPC> blocks_read [ left <SPC> // <SPC> B ] ) <NL>              left <SPC> += <SPC> B <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> update ( heights , <SPC> left , <SPC> right , <SPC> B , <SPC> blocks , <SPC> blocks_read , <SPC> h ) : <NL>          while <SPC> left <SPC> % <SPC> B <SPC> and <SPC> left <SPC> <= <SPC> right : <NL>              heights [ left ] <SPC> = <SPC> max ( heights [ left ] , <SPC> h ) <NL>              blocks_read [ left <SPC> // <SPC> B ] <SPC> = <SPC> max ( blocks_read [ left <SPC> // <SPC> B ] , <SPC> h ) <NL>              left <SPC> += <SPC> 1 <NL>          while <SPC> right <SPC> % <SPC> B <SPC> != <SPC> B <SPC> - <SPC> 1 <SPC> and <SPC> left <SPC> <= <SPC> right : <NL>              heights [ right ] <SPC> = <SPC> max ( heights [ right ] , <SPC> h ) <NL>              blocks_read [ right <SPC> // <SPC> B ] <SPC> = <SPC> max ( blocks_read [ right <SPC> // <SPC> B ] , <SPC> h ) <NL>              right <SPC> -= <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              blocks [ left <SPC> // <SPC> B ] <SPC> = <SPC> max ( blocks [ left <SPC> // <SPC> B ] , <SPC> h ) <NL>              left <SPC> += <SPC> B <NL> <NL> <TAB> index <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> left , <SPC> size <SPC> in <SPC> positions : <NL>          index . add ( left ) <NL>          index . add ( left <SPC> + <SPC> size <SPC> - <SPC> 1 ) <NL> <TAB> index <SPC> = <SPC> sorted ( list ( index ) ) <NL> <TAB> W <SPC> = <SPC> len ( index ) <NL> <TAB> B <SPC> = <SPC> int ( W <SPC> ** <SPC> 0.5 ) <NL> <TAB> heights <SPC> = <SPC> [ 0 ] <SPC> * <SPC> W <NL> <TAB> blocks <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( B <SPC> + <SPC> 2 ) <NL> <TAB> blocks_read <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( B <SPC> + <SPC> 2 ) <NL> <NL> <TAB> max_height <SPC> = <SPC> 0 <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> left , <SPC> size <SPC> in <SPC> positions : <NL>          L , <SPC> R <SPC> = <SPC> bisect . bisect_left ( index , <SPC> left ) , <SPC> bisect . bisect_left ( <NL>              index , <SPC> left <SPC> + <SPC> size <SPC> - <SPC> 1 <NL>          ) <NL>          h <SPC> = <SPC> query ( heights , <SPC> L , <SPC> R , <SPC> B , <SPC> blocks , <SPC> blocks_read ) <SPC> + <SPC> size <NL>          update ( heights , <SPC> L , <SPC> R , <SPC> B , <SPC> blocks , <SPC> blocks_read , <SPC> h ) <NL>          max_height <SPC> = <SPC> max ( max_height , <SPC> h ) <NL>          result . append ( max_height ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> fallingSquares ( self , <SPC> positions ) : <NL> <NL> <TAB> heights <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( positions ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( positions ) ) : <NL>          left_i , <SPC> size_i <SPC> = <SPC> positions [ i ] <NL>          right_i <SPC> = <SPC> left_i <SPC> + <SPC> size_i <NL>          heights [ i ] <SPC> += <SPC> size_i <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( positions ) ) : <NL>              left_j , <SPC> size_j <SPC> = <SPC> positions [ j ] <NL>              right_j <SPC> = <SPC> left_j <SPC> + <SPC> size_j <NL>              if <SPC> left_j <SPC> < <SPC> right_i <SPC> and <SPC> left_i <SPC> < <SPC> right_j : <NL>                  heights [ j ] <SPC> = <SPC> max ( heights [ j ] , <SPC> heights [ i ] ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> height <SPC> in <SPC> heights : <NL>          result . append ( max ( result [ - 1 ] , <SPC> height ) <SPC> if <SPC> result <SPC> else <SPC> height ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <NL> class <SPC> Fancy ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __arr <SPC> = <SPC> [ ] <NL> <TAB> self . __ops <SPC> = <SPC> [ [ 1 , <SPC> 0 ] ] <NL> <NL> <TAB> def <SPC> append ( self , <SPC> val ) : <NL> <NL> <TAB> self . __arr . append ( val ) <NL> <TAB> self . __ops . append ( self . __ops [ - 1 ] [ : ] ) <NL> <NL> <TAB> def <SPC> addAll ( self , <SPC> inc ) : <NL> <NL> <TAB> self . __ops [ - 1 ] [ 1 ] <SPC> = <SPC> ( self . __ops [ - 1 ] [ 1 ] <SPC> + <SPC> inc ) <SPC> % <SPC> MOD <NL> <NL> <TAB> def <SPC> multAll ( self , <SPC> m ) : <NL> <NL> <TAB> self . __ops [ - 1 ] <SPC> = <SPC> [ ( self . __ops [ - 1 ] [ 0 ] <SPC> * <SPC> m ) <SPC> % <NL>                        MOD , <SPC> ( self . __ops [ - 1 ] [ 1 ] <SPC> * <SPC> m ) <SPC> % <SPC> MOD ] <NL> <NL> <TAB> def <SPC> getIndex ( self , <SPC> idx ) : <NL> <NL> <TAB> if <SPC> idx <SPC> >= <SPC> len ( self . __arr ) : <NL>          return <SPC> - 1 <NL> <TAB> a1 , <SPC> b1 <SPC> = <SPC> self . __ops [ idx ] <NL> <TAB> a2 , <SPC> b2 <SPC> = <SPC> self . __ops [ - 1 ] <NL> <TAB> a <SPC> = <SPC> a2 <SPC> * <SPC> pow ( a1 , <SPC> MOD <SPC> - <SPC> 2 , <SPC> MOD ) <SPC> % <SPC> MOD <NL> <TAB> b <SPC> = <SPC> ( b2 <SPC> - <SPC> b1 <SPC> * <SPC> a ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> ( self . __arr [ idx ] <SPC> * <SPC> a <SPC> + <SPC> b ) <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Fancy2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __arr <SPC> = <SPC> [ ] <NL> <TAB> self . __op <SPC> = <SPC> [ 1 , <SPC> 0 ] <NL> <NL> <TAB> def <SPC> append ( self , <SPC> val ) : <NL> <NL> <TAB> self . __arr . append ( <NL>          ( val <SPC> - <SPC> self . __op [ 1 ] ) <SPC> * <SPC> pow ( self . __op [ 0 ] , <SPC> MOD <SPC> - <SPC> 2 , <SPC> MOD ) <SPC> % <SPC> MOD <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> addAll ( self , <SPC> inc ) : <NL> <NL> <TAB> self . __op [ 1 ] <SPC> = <SPC> ( self . __op [ 1 ] <SPC> + <SPC> inc ) <SPC> % <SPC> MOD <NL> <NL> <TAB> def <SPC> multAll ( self , <SPC> m ) : <NL> <NL> <TAB> self . __op <SPC> = <SPC> [ ( self . __op [ 0 ] <SPC> * <SPC> m ) <SPC> % <SPC> MOD , <SPC> ( self . __op [ 1 ] <SPC> * <SPC> m ) <SPC> % <SPC> MOD ] <NL> <NL> <TAB> def <SPC> getIndex ( self , <SPC> idx ) : <NL> <NL> <TAB> if <SPC> idx <SPC> >= <SPC> len ( self . __arr ) : <NL>          return <SPC> - 1 <NL> <TAB> a , <SPC> b <SPC> = <SPC> self . __op <NL> <TAB> return <SPC> ( self . __arr [ idx ] <SPC> * <SPC> a <SPC> + <SPC> b ) <SPC> % <SPC> MOD <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fib ( self , <SPC> N ) : <NL> <NL> <TAB> def <SPC> matrix_expo ( A , <SPC> K ) : <NL>          result <SPC> = <SPC> [ [ int ( i <SPC> == <SPC> j ) <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>                    for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>          while <SPC> K : <NL>              if <SPC> K <SPC> % <SPC> 2 : <NL>                  result <SPC> = <SPC> matrix_mult ( result , <SPC> A ) <NL>              A <SPC> = <SPC> matrix_mult ( A , <SPC> A ) <NL>              K <SPC> /= <SPC> 2 <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> matrix_mult ( A , <SPC> B ) : <NL>          ZB <SPC> = <SPC> zip ( * B ) <NL>          return <SPC> [ <NL>              [ sum ( a <SPC> * <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( row , <SPC> col ) ) <SPC> for <SPC> col <SPC> in <SPC> ZB ] <NL>              for <SPC> row <SPC> in <SPC> A <NL>          ] <NL> <NL> <TAB> T <SPC> = <SPC> [ [ 1 , <SPC> 1 ] , <SPC> [ 1 , <SPC> 0 ] ] <NL> <TAB> return <SPC> matrix_mult ( [ [ 1 , <SPC> 0 ] ] , <SPC> matrix_expo ( T , <SPC> N ) ) [ 0 ] [ 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> fib ( self , <SPC> N ) : <NL> <NL> <TAB> prev , <SPC> current <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N ) : <NL>          prev , <SPC> current <SPC> = <SPC> ( <NL>              current , <NL>              prev <SPC> + <SPC> current , <NL>          ) <NL> <TAB> return <SPC> prev <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minHeightShelves ( self , <SPC> books , <SPC> shelf_width ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ float ( "inf" ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( books ) <SPC> + <SPC> 1 ) ] <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( books ) <SPC> + <SPC> 1 ) : <NL>          max_width <SPC> = <SPC> shelf_width <NL>          max_height <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( i ) ) : <NL>              if <SPC> max_width <SPC> - <SPC> books [ j ] [ 0 ] <SPC> < <SPC> 0 : <NL>                  break <NL>              max_width <SPC> -= <SPC> books [ j ] [ 0 ] <NL>              max_height <SPC> = <SPC> max ( max_height , <SPC> books [ j ] [ 1 ] ) <NL>              dp [ i ] <SPC> = <SPC> min ( dp [ i ] , <SPC> dp [ j ] <SPC> + <SPC> max_height ) <NL> <TAB> return <SPC> dp [ len ( books ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> filterRestaurants ( self , <SPC> restaurants , <SPC> veganFriendly , <SPC> maxPrice , <SPC> maxDistance ) : <NL> <NL> <TAB> result , <SPC> lookup <SPC> = <SPC> [ ] , <SPC> { } <NL> <TAB> for <SPC> j , <SPC> ( i , <SPC> _ , <SPC> v , <SPC> p , <SPC> d ) <SPC> in <SPC> enumerate ( restaurants ) : <NL>          if <SPC> v <SPC> >= <SPC> veganFriendly <SPC> and <SPC> p <SPC> <= <SPC> maxPrice <SPC> and <SPC> d <SPC> <= <SPC> maxDistance : <NL>              lookup [ i ] <SPC> = <SPC> j <NL>              result . append ( i ) <NL> <TAB> result . sort ( <NL>          key = lambda <SPC> i : <SPC> ( - restaurants [ lookup [ i ] ] [ 1 ] , <SPC> - restaurants [ lookup [ i ] ] [ 0 ] ) <NL> <TAB> ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> finalPrices ( self , <SPC> prices ) : <NL> <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> p <SPC> in <SPC> enumerate ( prices ) : <NL>          while <SPC> stk <SPC> and <SPC> prices [ stk [ - 1 ] ] <SPC> >= <SPC> p : <NL>              prices [ stk . pop ( ) ] <SPC> -= <SPC> p <NL>          stk . append ( i ) <NL> <TAB> return <SPC> prices <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getTargetCopy ( self , <SPC> original , <SPC> cloned , <SPC> target ) : <NL> <NL> <TAB> def <SPC> preorder_gen ( node ) : <NL>          stk <SPC> = <SPC> [ node ] <NL>          while <SPC> stk : <NL>              node <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> not <SPC> node : <NL>                  continue <NL>              yield <SPC> node <NL>              stk . append ( node . right ) <NL>              stk . append ( node . left ) <NL> <NL> <TAB> for <SPC> node1 , <SPC> node2 <SPC> in <SPC> itertools . izip ( <NL>          preorder_gen ( original ) , <SPC> preorder_gen ( cloned ) <NL> <TAB> ) : <NL>          if <SPC> node1 <SPC> == <SPC> target : <NL>              return <SPC> node2 <NL> <NL> <NL> class <SPC> BitCount ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . __l <SPC> = <SPC> 0 <NL> <TAB> self . __n <SPC> = <SPC> n <NL> <TAB> self . __count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <NL> <TAB> def <SPC> __iadd__ ( self , <SPC> num ) : <NL> <TAB> self . __l <SPC> += <SPC> 1 <NL> <TAB> base <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . __n ) : <NL>          if <SPC> num <SPC> & <SPC> base : <NL>              self . __count [ i ] <SPC> += <SPC> 1 <NL>          base <SPC> <<= <SPC> 1 <NL> <TAB> return <SPC> self <NL> <NL> <TAB> def <SPC> __isub__ ( self , <SPC> num ) : <NL> <TAB> self . __l <SPC> -= <SPC> 1 <NL> <TAB> base <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . __n ) : <NL>          if <SPC> num <SPC> & <SPC> base : <NL>              self . __count [ i ] <SPC> -= <SPC> 1 <NL>          base <SPC> <<= <SPC> 1 <NL> <TAB> return <SPC> self <NL> <NL> <TAB> def <SPC> bit_and ( self ) : <NL> <TAB> num , <SPC> base <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . __n ) : <NL>          if <SPC> self . __count [ i ] <SPC> == <SPC> self . __l : <NL>              num <SPC> |= <SPC> base <NL>          base <SPC> <<= <SPC> 1 <NL> <TAB> return <SPC> num <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> closestToTarget ( self , <SPC> arr , <SPC> target ) : <NL> <NL> <TAB> count <SPC> = <SPC> BitCount ( max ( arr ) . bit_length ( ) ) <NL> <TAB> result , <SPC> left <SPC> = <SPC> float ( "inf" ) , <SPC> 0 <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( arr ) ) : <NL>          count <SPC> += <SPC> arr [ right ] <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              f <SPC> = <SPC> count . bit_and ( ) <NL>              result <SPC> = <SPC> min ( result , <SPC> abs ( f <SPC> - <SPC> target ) ) <NL>              if <SPC> f <SPC> >= <SPC> target : <NL>                  break <NL>              count <SPC> -= <SPC> arr [ left ] <NL>              left <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> closestToTarget ( self , <SPC> arr , <SPC> target ) : <NL> <NL> <TAB> result , <SPC> dp <SPC> = <SPC> float ( "inf" ) , <SPC> set ( ) <NL> <TAB> for <SPC> x <SPC> in <SPC> arr : <NL>          dp <SPC> = <SPC> { x } <SPC> | <SPC> { f <SPC> & <SPC> x <SPC> for <SPC> f <SPC> in <SPC> dp } <NL>          for <SPC> f <SPC> in <SPC> dp : <NL>              result <SPC> = <SPC> min ( result , <SPC> abs ( f <SPC> - <SPC> target ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findAnagrams ( self , <SPC> s , <SPC> p ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <NL> <TAB> cnts <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> c <SPC> in <SPC> p : <NL>          cnts [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> right <SPC> < <SPC> len ( s ) : <NL>          cnts [ ord ( s [ right ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> -= <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right <SPC> and <SPC> cnts [ ord ( s [ right ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> < <SPC> 0 : <NL>              cnts [ ord ( s [ left ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL>              left <SPC> += <SPC> 1 <NL>          if <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <SPC> == <SPC> len ( p ) : <NL>              result . append ( left ) <NL>          right <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findDuplicates ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> nums : <NL>          if <SPC> nums [ abs ( i ) <SPC> - <SPC> 1 ] <SPC> < <SPC> 0 : <NL>              result . append ( abs ( i ) ) <NL>          else : <NL>              nums [ abs ( i ) <SPC> - <SPC> 1 ] <SPC> *= <SPC> - 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findDuplicates ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( nums ) : <NL>          if <SPC> nums [ i ] <SPC> != <SPC> nums [ nums [ i ] <SPC> - <SPC> 1 ] : <NL>              nums [ nums [ i ] <SPC> - <SPC> 1 ] , <SPC> nums [ i ] <SPC> = <SPC> nums [ i ] , <SPC> nums [ nums [ i ] <SPC> - <SPC> 1 ] <NL>          else : <NL>              i <SPC> += <SPC> 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> i <SPC> != <SPC> nums [ i ] <SPC> - <SPC> 1 : <NL>              result . append ( nums [ i ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> Counter <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> findDuplicates ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> [ elem <SPC> for <SPC> elem , <SPC> count <SPC> in <SPC> Counter ( nums ) . items ( ) <SPC> if <SPC> count <SPC> == <SPC> 2 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findGoodStrings ( self , <SPC> n , <SPC> s1 , <SPC> s2 , <SPC> evil ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> def <SPC> getPrefix ( pattern ) : <NL>          prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>              while <SPC> j <SPC> != <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              prefix [ i ] <SPC> = <SPC> j <NL>          return <SPC> prefix <NL> <NL> <TAB> prefix <SPC> = <SPC> getPrefix ( evil ) <NL> <TAB> dp <SPC> = <SPC> [ <NL>          [ [ [ 0 ] <SPC> * <SPC> len ( evil ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) <NL> <TAB> ] <NL> <TAB> dp [ 0 ] [ 0 ] [ 0 ] [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] <SPC> = <SPC> [ [ [ 0 ] <SPC> * <SPC> len ( evil ) <NL>                              for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( 2 ) : <NL>              for <SPC> k <SPC> in <SPC> xrange ( 2 ) : <NL>                  min_c <SPC> = <SPC> "a" <SPC> if <SPC> j <SPC> else <SPC> s1 [ i ] <NL>                  max_c <SPC> = <SPC> "z" <SPC> if <SPC> k <SPC> else <SPC> s2 [ i ] <NL>                  for <SPC> l <SPC> in <SPC> xrange ( len ( evil ) ) : <NL>                      if <SPC> not <SPC> dp [ i <SPC> % <SPC> 2 ] [ j ] [ k ] [ l ] : <NL>                          continue <NL>                      for <SPC> c <SPC> in <SPC> xrange ( <NL>                          ord ( min_c ) <SPC> - <SPC> ord ( "a" ) , <SPC> ord ( max_c ) <SPC> - <SPC> ord ( "a" ) <SPC> + <SPC> 1 <NL>                      ) : <NL>                          c <SPC> = <SPC> chr ( c <SPC> + <SPC> ord ( "a" ) ) <NL>                          m <SPC> = <SPC> l <SPC> - <SPC> 1 <NL>                          while <SPC> m <SPC> != <SPC> - 1 <SPC> and <SPC> evil [ m <SPC> + <SPC> 1 ] <SPC> != <SPC> c : <NL>                              m <SPC> = <SPC> prefix [ m ] <NL>                          if <SPC> evil [ m <SPC> + <SPC> 1 ] <SPC> == <SPC> c : <NL>                              m <SPC> += <SPC> 1 <NL>                          if <SPC> m <SPC> + <SPC> 1 <SPC> == <SPC> len ( evil ) : <NL>                              continue <NL>                          dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> or <SPC> ( s1 [ i ] <SPC> != <SPC> c ) ] [ k <SPC> or <SPC> ( s2 [ i ] <SPC> != <SPC> c ) ] [ <NL>                              m <SPC> + <SPC> 1 <NL>                          ] <SPC> = <SPC> ( <NL>                              dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> or <SPC> ( s1 [ i ] <SPC> != <SPC> c ) ] [ k <SPC> or <SPC> ( s2 [ i ] <SPC> != <SPC> c ) ] [ <NL>                                  m <SPC> + <SPC> 1 <NL>                              ] <NL>                              + <SPC> dp [ i <SPC> % <SPC> 2 ] [ j ] [ k ] [ l ] <NL>                          ) <SPC> % <SPC> MOD <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 2 ) : <NL>          for <SPC> k <SPC> in <SPC> xrange ( 2 ) : <NL>              for <SPC> l <SPC> in <SPC> xrange ( len ( evil ) ) : <NL>                  result <SPC> = <SPC> ( result <SPC> + <SPC> dp [ n <SPC> % <SPC> 2 ] [ j ] [ k ] [ l ] ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findDisappearedNumbers ( self , <SPC> nums ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> nums [ abs ( nums [ i ] ) <SPC> - <SPC> 1 ] <SPC> > <SPC> 0 : <NL>              nums [ abs ( nums [ i ] ) <SPC> - <SPC> 1 ] <SPC> *= <SPC> - 1 <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> nums [ i ] <SPC> > <SPC> 0 : <NL>              result . append ( i <SPC> + <SPC> 1 ) <NL>          else : <NL>              nums [ i ] <SPC> *= <SPC> - 1 <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> findDisappearedNumbers2 ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> list ( set ( range ( 1 , <SPC> len ( nums ) <SPC> + <SPC> 1 ) ) <SPC> - <SPC> set ( nums ) ) <NL> <NL> <TAB> def <SPC> findDisappearedNumbers3 ( self , <SPC> nums ) : <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( nums ) ) : <NL>          index <SPC> = <SPC> abs ( nums [ i ] ) <SPC> - <SPC> 1 <NL>          nums [ index ] <SPC> = <SPC> - abs ( nums [ index ] ) <NL> <NL> <TAB> return <SPC> [ i <SPC> + <SPC> 1 <SPC> for <SPC> i <SPC> in <SPC> range ( len ( nums ) ) <SPC> if <SPC> nums [ i ] <SPC> > <SPC> 0 ] <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getLonelyNodes ( self , <SPC> root ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> stk <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> stk : <NL>          node <SPC> = <SPC> stk . pop ( ) <NL>          if <SPC> not <SPC> node : <NL>              continue <NL>          if <SPC> node . left <SPC> and <SPC> not <SPC> node . right : <NL>              result . append ( node . left . val ) <NL>          elif <SPC> node . right <SPC> and <SPC> not <SPC> node . left : <NL>              result . append ( node . right . val ) <NL>          stk . append ( node . right ) <NL>          stk . append ( node . left ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> getLonelyNodes ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> result ) : <NL>          if <SPC> not <SPC> node : <NL>              return <NL>          if <SPC> node . left <SPC> and <SPC> not <SPC> node . right : <NL>              result . append ( node . left . val ) <NL>          elif <SPC> node . right <SPC> and <SPC> not <SPC> node . left : <NL>              result . append ( node . right . val ) <NL>          dfs ( node . left , <SPC> result ) <NL>          dfs ( node . right , <SPC> result ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> dfs ( root , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> anagramMappings ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( collections . deque ) <NL> <TAB> for <SPC> i , <SPC> n <SPC> in <SPC> enumerate ( B ) : <NL>          lookup [ n ] . append ( i ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> n <SPC> in <SPC> A : <NL>          result . append ( lookup [ n ] . popleft ( ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findReplaceString ( self , <SPC> S , <SPC> indexes , <SPC> sources , <SPC> targets ) : <NL> <NL> <TAB> bucket <SPC> = <SPC> [ None ] <SPC> * <SPC> len ( S ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( indexes ) ) : <NL>          if <SPC> all ( <NL>              indexes [ i ] <SPC> + <SPC> k <SPC> < <SPC> len ( S ) <SPC> and <SPC> S [ indexes [ i ] <SPC> + <SPC> k ] <SPC> == <SPC> sources [ i ] [ k ] <NL>              for <SPC> k <SPC> in <SPC> xrange ( len ( sources [ i ] ) ) <NL>          ) : <NL>              bucket [ indexes [ i ] ] <SPC> = <SPC> ( len ( sources [ i ] ) , <SPC> list ( targets [ i ] ) ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( S ) : <NL>          if <SPC> bucket [ i ] : <NL>              result . extend ( bucket [ i ] [ 1 ] ) <NL>              i <SPC> += <SPC> bucket [ i ] [ 0 ] <NL>          else : <NL>              result . append ( S [ i ] ) <NL>              i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findReplaceString ( self , <SPC> S , <SPC> indexes , <SPC> sources , <SPC> targets ) : <NL> <NL> <TAB> for <SPC> i , <SPC> s , <SPC> t <SPC> in <SPC> sorted ( zip ( indexes , <SPC> sources , <SPC> targets ) , <SPC> reverse = True ) : <NL>          if <SPC> S [ i : <SPC> i <SPC> + <SPC> len ( s ) ] <SPC> == <SPC> s : <NL>              S <SPC> = <SPC> S [ : i ] <SPC> + <SPC> t <SPC> + <SPC> S [ i <SPC> + <SPC> len ( s ) : ] <NL> <NL> <TAB> return <SPC> S <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findAndReplacePattern ( self , <SPC> words , <SPC> pattern ) : <NL> <NL> <TAB> def <SPC> match ( word ) : <NL>          lookup <SPC> = <SPC> { } <NL>          for <SPC> x , <SPC> y <SPC> in <SPC> itertools . izip ( pattern , <SPC> word ) : <NL>              if <SPC> lookup . setdefault ( x , <SPC> y ) <SPC> != <SPC> y : <NL>                  return <SPC> False <NL>          return <SPC> len ( set ( lookup . values ( ) ) ) <SPC> == <SPC> len ( lookup . values ( ) ) <NL> <NL> <TAB> return <SPC> filter ( match , <SPC> words ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findBottomLeftValue ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> findBottomLeftValueHelper ( root , <SPC> curr_depth , <SPC> max_depth , <SPC> bottom_left_value ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> max_depth , <SPC> bottom_left_value <NL>          if <SPC> not <SPC> root . left <SPC> and <SPC> not <SPC> root . right <SPC> and <SPC> curr_depth <SPC> + <SPC> 1 <SPC> > <SPC> max_depth : <NL>              return <SPC> curr_depth <SPC> + <SPC> 1 , <SPC> root . val <NL>          max_depth , <SPC> bottom_left_value <SPC> = <SPC> findBottomLeftValueHelper ( <NL>              root . left , <SPC> curr_depth <SPC> + <SPC> 1 , <SPC> max_depth , <SPC> bottom_left_value <NL>          ) <NL>          max_depth , <SPC> bottom_left_value <SPC> = <SPC> findBottomLeftValueHelper ( <NL>              root . right , <SPC> curr_depth <SPC> + <SPC> 1 , <SPC> max_depth , <SPC> bottom_left_value <NL>          ) <NL>          return <SPC> max_depth , <SPC> bottom_left_value <NL> <NL> <TAB> result , <SPC> max_depth <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> return <SPC> findBottomLeftValueHelper ( root , <SPC> 0 , <SPC> max_depth , <SPC> result ) [ 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findBottomLeftValue ( self , <SPC> root ) : <NL> <NL> <TAB> last_node , <SPC> queue <SPC> = <SPC> None , <SPC> [ root ] <NL> <TAB> while <SPC> queue : <NL>          last_node <SPC> = <SPC> queue . pop ( 0 ) <NL>          queue . extend ( [ n <SPC> for <SPC> n <SPC> in <SPC> [ last_node . right , <SPC> last_node . left ] <SPC> if <SPC> n ] ) <NL> <TAB> return <SPC> last_node . value <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findCenter ( self , <SPC> edges ) : <NL> <NL> <TAB> return <SPC> edges [ 0 ] [ edges [ 0 ] [ 1 ] <SPC> in <SPC> edges [ 1 ] ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> commonChars ( self , <SPC> A ) : <NL> <NL> <TAB> result <SPC> = <SPC> collections . Counter ( A [ 0 ] ) <NL> <TAB> for <SPC> a <SPC> in <SPC> A : <NL>          result <SPC> &= <SPC> collections . Counter ( a ) <NL> <TAB> return <SPC> list ( result . elements ( ) ) <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . count <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ max ( x_root , <SPC> y_root ) ] <SPC> = <SPC> min ( x_root , <SPC> y_root ) <NL> <TAB> self . count <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findCriticalAndPseudoCriticalEdges ( self , <SPC> n , <SPC> edges ) : <NL> <NL> <TAB> def <SPC> MST ( n , <SPC> edges , <SPC> unused = None , <SPC> used = None ) : <NL>          union_find <SPC> = <SPC> UnionFind ( n ) <NL>          weight <SPC> = <SPC> 0 <NL>          if <SPC> used <SPC> is <SPC> not <SPC> None : <NL>              u , <SPC> v , <SPC> w , <SPC> _ <SPC> = <SPC> edges [ used ] <NL>              if <SPC> union_find . union_set ( u , <SPC> v ) : <NL>                  weight <SPC> += <SPC> w <NL>          for <SPC> i , <SPC> ( u , <SPC> v , <SPC> w , <SPC> _ ) <SPC> in <SPC> enumerate ( edges ) : <NL>              if <SPC> i <SPC> == <SPC> unused : <NL>                  continue <NL>              if <SPC> union_find . union_set ( u , <SPC> v ) : <NL>                  weight <SPC> += <SPC> w <NL>          return <SPC> weight <SPC> if <SPC> union_find . count <SPC> == <SPC> 1 <SPC> else <SPC> float ( "inf" ) <NL> <NL> <TAB> for <SPC> i , <SPC> edge <SPC> in <SPC> enumerate ( edges ) : <NL>          edge . append ( i ) <NL> <TAB> edges . sort ( key = lambda <SPC> x : <SPC> x [ 2 ] ) <NL> <TAB> mst <SPC> = <SPC> MST ( n , <SPC> edges ) <NL> <TAB> result <SPC> = <SPC> [ [ ] , <SPC> [ ] ] <NL> <TAB> for <SPC> i , <SPC> edge <SPC> in <SPC> enumerate ( edges ) : <NL>          if <SPC> mst <SPC> < <SPC> MST ( n , <SPC> edges , <SPC> unused = i ) : <NL>              result [ 0 ] . append ( edge [ 3 ] ) <NL>          elif <SPC> mst <SPC> == <SPC> MST ( n , <SPC> edges , <SPC> used = i ) : <NL>              result [ 1 ] . append ( edge [ 3 ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findDistance ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> def <SPC> iter_dfs ( root , <SPC> p , <SPC> q ) : <NL>          result <SPC> = <SPC> 0 <NL>          dist <SPC> = <SPC> [ - 1 ] <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> [ root , <SPC> dist ] ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  node , <SPC> ret <SPC> = <SPC> params <NL>                  if <SPC> not <SPC> node : <NL>                      continue <NL>                  ret1 , <SPC> ret2 <SPC> = <SPC> [ - 1 ] , <SPC> [ - 1 ] <NL>                  stk . append ( ( 2 , <SPC> [ node , <SPC> ret1 , <SPC> ret2 , <SPC> ret ] ) ) <NL>                  stk . append ( ( 1 , <SPC> [ node . right , <SPC> ret2 ] ) ) <NL>                  stk . append ( ( 1 , <SPC> [ node . left , <SPC> ret1 ] ) ) <NL>              elif <SPC> step <SPC> == <SPC> 2 : <NL>                  node , <SPC> ret1 , <SPC> ret2 , <SPC> ret <SPC> = <SPC> params <NL>                  if <SPC> node . val <SPC> in <SPC> ( p , <SPC> q ) : <NL>                      if <SPC> ret1 [ 0 ] <SPC> == <SPC> ret2 [ 0 ] <SPC> == <SPC> - 1 : <NL>                          ret [ 0 ] <SPC> = <SPC> 0 <NL>                      else : <NL>                          result <SPC> = <SPC> ret1 [ 0 ] <SPC> + <SPC> 1 <SPC> if <SPC> ret1 [ 0 ] <SPC> != <SPC> - 1 <SPC> else <SPC> ret2 [ 0 ] <SPC> + <SPC> 1 <NL>                  elif <SPC> ret1 [ 0 ] <SPC> != <SPC> - 1 <SPC> and <SPC> ret2 [ 0 ] <SPC> != <SPC> - 1 : <NL>                      result <SPC> = <SPC> ret1 [ 0 ] <SPC> + <SPC> ret2 [ 0 ] <SPC> + <SPC> 2 <NL>                  elif <SPC> ret1 [ 0 ] <SPC> != <SPC> - 1 : <NL>                      ret [ 0 ] <SPC> = <SPC> ret1 [ 0 ] <SPC> + <SPC> 1 <NL>                  elif <SPC> ret2 [ 0 ] <SPC> != <SPC> - 1 : <NL>                      ret [ 0 ] <SPC> = <SPC> ret2 [ 0 ] <SPC> + <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> iter_dfs ( root , <SPC> p , <SPC> q ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findDistance ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> p , <SPC> q , <SPC> result ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> - 1 <NL>          left <SPC> = <SPC> dfs ( node . left , <SPC> p , <SPC> q , <SPC> result ) <NL>          right <SPC> = <SPC> dfs ( node . right , <SPC> p , <SPC> q , <SPC> result ) <NL>          if <SPC> node . val <SPC> in <SPC> ( p , <SPC> q ) : <NL>              if <SPC> left <SPC> == <SPC> right <SPC> == <SPC> - 1 : <NL>                  return <SPC> 0 <NL>              result [ 0 ] <SPC> = <SPC> left <SPC> + <SPC> 1 <SPC> if <SPC> left <SPC> != <SPC> - 1 <SPC> else <SPC> right <SPC> + <SPC> 1 <NL>          if <SPC> left <SPC> != <SPC> - 1 <SPC> and <SPC> right <SPC> != <SPC> - 1 : <NL>              result [ 0 ] <SPC> = <SPC> left <SPC> + <SPC> right <SPC> + <SPC> 2 <NL>          elif <SPC> left <SPC> != <SPC> - 1 : <NL>              return <SPC> left <SPC> + <SPC> 1 <NL>          elif <SPC> right <SPC> != <SPC> - 1 : <NL>              return <SPC> right <SPC> + <SPC> 1 <NL>          return <SPC> - 1 <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> dfs ( root , <SPC> p , <SPC> q , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findDuplicate ( self , <SPC> paths ) : <NL> <NL> <TAB> files <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> path <SPC> in <SPC> paths : <NL>          s <SPC> = <SPC> path . split ( " " ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) ) : <NL>              file_name <SPC> = <SPC> s [ 0 ] <SPC> + <SPC> "/" <SPC> + <SPC> s [ i ] [ 0 : <SPC> s [ i ] . find ( "(" ) ] <NL>              file_content <SPC> = <SPC> s [ i ] [ s [ i ] . find ( "(" ) <SPC> + <SPC> 1 : <SPC> s [ i ] . find ( ")" ) ] <NL>              files [ file_content ] . append ( file_name ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> file_content , <SPC> file_names <SPC> in <SPC> files . iteritems ( ) : <NL>          if <SPC> len ( file_names ) <SPC> > <SPC> 1 : <NL>              result . append ( file_names ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findDuplicateSubtrees ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> getid ( root , <SPC> lookup , <SPC> trees ) : <NL>          if <SPC> root : <NL>              node_id <SPC> = <SPC> lookup [ <NL>                  root . val , <NL>                  getid ( root . left , <SPC> lookup , <SPC> trees ) , <NL>                  getid ( root . right , <SPC> lookup , <SPC> trees ) , <NL>              ] <NL>              trees [ node_id ] . append ( root ) <NL>              return <SPC> node_id <NL> <NL> <TAB> trees <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( ) <NL> <TAB> lookup . default_factory <SPC> = <SPC> lookup . __len__ <NL> <TAB> getid ( root , <SPC> lookup , <SPC> trees ) <NL> <TAB> return <SPC> [ roots [ 0 ] <SPC> for <SPC> roots <SPC> in <SPC> trees . values ( ) <SPC> if <SPC> len ( roots ) <SPC> > <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findDuplicateSubtrees ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> postOrderTraversal ( node , <SPC> lookup , <SPC> result ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> "" <NL>          s <SPC> = <SPC> ( <NL>              "(" <NL>              + <SPC> postOrderTraversal ( node . left , <SPC> lookup , <SPC> result ) <NL>              + <SPC> str ( node . val ) <NL>              + <SPC> postOrderTraversal ( node . right , <SPC> lookup , <SPC> result ) <NL>              + <SPC> ")" <NL>          ) <NL>          if <SPC> lookup [ s ] <SPC> == <SPC> 1 : <NL>              result . append ( node ) <NL>          lookup [ s ] <SPC> += <SPC> 1 <NL>          return <SPC> s <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> postOrderTraversal ( root , <SPC> lookup , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> FindElements ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> v , <SPC> lookup ) : <NL>          if <SPC> not <SPC> node : <NL>              return <NL>          node . val <SPC> = <SPC> v <NL>          lookup . add ( v ) <NL>          dfs ( node . left , <SPC> 2 <SPC> * <SPC> v <SPC> + <SPC> 1 , <SPC> lookup ) <NL>          dfs ( node . right , <SPC> 2 <SPC> * <SPC> v <SPC> + <SPC> 2 , <SPC> lookup ) <NL> <NL> <TAB> self . __lookup <SPC> = <SPC> set ( ) <NL> <TAB> dfs ( root , <SPC> 0 , <SPC> self . __lookup ) <NL> <NL> <TAB> def <SPC> find ( self , <SPC> target ) : <NL> <NL> <TAB> return <SPC> target <SPC> in <SPC> self . __lookup <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> eventualSafeNodes ( self , <SPC> graph ) : <NL> <NL> <TAB> WHITE , <SPC> GRAY , <SPC> BLACK <SPC> = <SPC> 0 , <SPC> 1 , <SPC> 2 <NL> <NL> <TAB> def <SPC> dfs ( graph , <SPC> node , <SPC> lookup ) : <NL>          if <SPC> lookup [ node ] <SPC> != <SPC> WHITE : <NL>              return <SPC> lookup [ node ] <SPC> == <SPC> BLACK <NL>          lookup [ node ] <SPC> = <SPC> GRAY <NL>          for <SPC> child <SPC> in <SPC> graph [ node ] : <NL>              if <SPC> lookup [ child ] <SPC> == <SPC> BLACK : <NL>                  continue <NL>              if <SPC> lookup [ child ] <SPC> == <SPC> GRAY <SPC> or <SPC> not <SPC> dfs ( graph , <SPC> child , <SPC> lookup ) : <NL>                  return <SPC> False <NL>          lookup [ node ] <SPC> = <SPC> BLACK <NL>          return <SPC> True <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> return <SPC> filter ( lambda <SPC> node : <SPC> dfs ( graph , <SPC> node , <SPC> lookup ) , <SPC> xrange ( len ( graph ) ) ) <NL> <NL> <NL> class <SPC> MountainArray ( object ) : <NL> <TAB> def <SPC> get ( self , <SPC> index ) : <NL> <NL> <TAB> pass <NL> <NL> <TAB> def <SPC> length ( self ) : <NL> <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findInMountainArray ( self , <SPC> target , <SPC> mountain_arr ) : <NL> <NL> <TAB> def <SPC> binarySearch ( A , <SPC> left , <SPC> right , <SPC> check ) : <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>              if <SPC> check ( mid ) : <NL>                  right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          return <SPC> left <NL> <NL> <TAB> peak <SPC> = <SPC> binarySearch ( <NL>          mountain_arr , <NL>          0 , <NL>          mountain_arr . length ( ) <SPC> - <SPC> 1 , <NL>          lambda <SPC> x : <SPC> mountain_arr . get ( x ) <SPC> >= <SPC> mountain_arr . get ( x <SPC> + <SPC> 1 ) , <NL> <TAB> ) <NL> <TAB> left <SPC> = <SPC> binarySearch ( <NL>          mountain_arr , <SPC> 0 , <SPC> peak , <SPC> lambda <SPC> x : <SPC> mountain_arr . get ( x ) <SPC> >= <SPC> target <NL> <TAB> ) <NL> <TAB> if <SPC> left <SPC> <= <SPC> peak <SPC> and <SPC> mountain_arr . get ( left ) <SPC> == <SPC> target : <NL>          return <SPC> left <NL> <TAB> right <SPC> = <SPC> binarySearch ( <NL>          mountain_arr , <NL>          peak , <NL>          mountain_arr . length ( ) <SPC> - <SPC> 1 , <NL>          lambda <SPC> x : <SPC> mountain_arr . get ( x ) <SPC> <= <SPC> target , <NL> <TAB> ) <NL> <TAB> if <SPC> right <SPC> <= <SPC> mountain_arr . length ( ) <SPC> - <SPC> 1 <SPC> and <SPC> mountain_arr . get ( right ) <SPC> == <SPC> target : <NL>          return <SPC> right <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findClosestElements ( self , <SPC> arr , <SPC> k , <SPC> x ) : <NL> <NL> <TAB> i <SPC> = <SPC> bisect . bisect_left ( arr , <SPC> x ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> i <SPC> - <SPC> 1 , <SPC> i <NL> <TAB> while <SPC> k : <NL>          if <SPC> right <SPC> >= <SPC> len ( arr ) <SPC> or <SPC> ( <NL>              left <SPC> >= <SPC> 0 <SPC> and <SPC> abs ( arr [ left ] <SPC> - <SPC> x ) <SPC> <= <SPC> abs ( arr [ right ] <SPC> - <SPC> x ) <NL>          ) : <NL>              left <SPC> -= <SPC> 1 <NL>          else : <NL>              right <SPC> += <SPC> 1 <NL>          k <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> arr [ left <SPC> + <SPC> 1 : <SPC> right ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numKLenSubstrNoRepeats ( self , <SPC> S , <SPC> K ) : <NL> <NL> <TAB> result , <SPC> i <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( S ) ) : <NL>          while <SPC> S [ j ] <SPC> in <SPC> lookup : <NL>              lookup . remove ( S [ i ] ) <NL>              i <SPC> += <SPC> 1 <NL>          lookup . add ( S [ j ] ) <NL>          result <SPC> += <SPC> j <SPC> - <SPC> i <SPC> + <SPC> 1 <SPC> >= <SPC> K <NL> <TAB> return <SPC> result <NL> <NL> <NL> from <SPC> heapq <SPC> import <SPC> heappush , <SPC> heappop <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kSmallestPairs ( self , <SPC> nums1 , <SPC> nums2 , <SPC> k ) : <NL> <NL> <TAB> pairs <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> len ( nums1 ) <SPC> > <SPC> len ( nums2 ) : <NL>          tmp <SPC> = <SPC> self . kSmallestPairs ( nums2 , <SPC> nums1 , <SPC> k ) <NL>          for <SPC> pair <SPC> in <SPC> tmp : <NL>              pairs . append ( [ pair [ 1 ] , <SPC> pair [ 0 ] ] ) <NL>          return <SPC> pairs <NL> <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( i , <SPC> j ) : <NL>          if <SPC> i <SPC> < <SPC> len ( nums1 ) <SPC> and <SPC> j <SPC> < <SPC> len ( nums2 ) : <NL>              heappush ( min_heap , <SPC> [ nums1 [ i ] <SPC> + <SPC> nums2 [ j ] , <SPC> i , <SPC> j ] ) <NL> <NL> <TAB> push ( 0 , <SPC> 0 ) <NL> <TAB> while <SPC> min_heap <SPC> and <SPC> len ( pairs ) <SPC> < <SPC> k : <NL>          _ , <SPC> i , <SPC> j <SPC> = <SPC> heappop ( min_heap ) <NL>          pairs . append ( [ nums1 [ i ] , <SPC> nums2 [ j ] ] ) <NL>          push ( i , <SPC> j <SPC> + <SPC> 1 ) <NL>          if <SPC> j <SPC> == <SPC> 0 : <NL>              push ( i <SPC> + <SPC> 1 , <SPC> 0 ) <NL> <TAB> return <SPC> pairs <NL> <NL> <NL> from <SPC> heapq <SPC> import <SPC> nsmallest <NL> from <SPC> itertools <SPC> import <SPC> product <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> kSmallestPairs ( self , <SPC> nums1 , <SPC> nums2 , <SPC> k ) : <NL> <NL> <TAB> return <SPC> nsmallest ( k , <SPC> product ( nums1 , <SPC> nums2 ) , <SPC> key = sum ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestDistancePair ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> possible ( guess , <SPC> nums , <SPC> k ) : <NL>          count , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> right , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>              while <SPC> num <SPC> - <SPC> nums [ left ] <SPC> > <SPC> guess : <NL>                  left <SPC> += <SPC> 1 <NL>              count <SPC> += <SPC> right <SPC> - <SPC> left <NL>          return <SPC> count <SPC> >= <SPC> k <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> nums [ - 1 ] <SPC> - <SPC> nums [ 0 ] <SPC> + <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> possible ( mid , <SPC> nums , <SPC> k ) : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findKthBit ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> flip , <SPC> l <SPC> = <SPC> 0 , <SPC> 2 <SPC> ** <SPC> n <SPC> - <SPC> 1 <NL> <TAB> while <SPC> k <SPC> > <SPC> 1 : <NL>          if <SPC> k <SPC> == <SPC> l <SPC> // <SPC> 2 <SPC> + <SPC> 1 : <NL>              flip <SPC> ^= <SPC> 1 <NL>              break <NL>          if <SPC> k <SPC> > <SPC> l <SPC> // <SPC> 2 : <NL>              k <SPC> = <SPC> l <SPC> + <SPC> 1 <SPC> - <SPC> k <NL>              flip <SPC> ^= <SPC> 1 <NL>          l <SPC> //= <SPC> 2 <NL> <TAB> return <SPC> str ( flip ) <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kthLargestValue ( self , <SPC> matrix , <SPC> k ) : <NL> <NL> <TAB> def <SPC> nth_element ( nums , <SPC> n , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) : <NL>          def <SPC> tri_partition ( nums , <SPC> left , <SPC> right , <SPC> target , <SPC> compare ) : <NL>              mid <SPC> = <SPC> left <NL>              while <SPC> mid <SPC> <= <SPC> right : <NL>                  if <SPC> nums [ mid ] <SPC> == <SPC> target : <NL>                      mid <SPC> += <SPC> 1 <NL>                  elif <SPC> compare ( nums [ mid ] , <SPC> target ) : <NL>                      nums [ left ] , <SPC> nums [ mid ] <SPC> = <SPC> nums [ mid ] , <SPC> nums [ left ] <NL>                      left <SPC> += <SPC> 1 <NL>                      mid <SPC> += <SPC> 1 <NL>                  else : <NL>                      nums [ mid ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ mid ] <NL>                      right <SPC> -= <SPC> 1 <NL>              return <SPC> left , <SPC> right <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              pivot_left , <SPC> pivot_right <SPC> = <SPC> tri_partition ( <NL>                  nums , <SPC> left , <SPC> right , <SPC> nums [ pivot_idx ] , <SPC> compare <NL>              ) <NL>              if <SPC> pivot_left <SPC> <= <SPC> n <SPC> <= <SPC> pivot_right : <NL>                  return <NL>              elif <SPC> pivot_left <SPC> > <SPC> n : <NL>                  right <SPC> = <SPC> pivot_left <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> pivot_right <SPC> + <SPC> 1 <NL> <NL> <TAB> vals <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> r <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          curr <SPC> = <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) : <NL>              curr <SPC> = <SPC> curr <SPC> ^ <SPC> matrix [ r ] [ c ] <NL>              if <SPC> r <SPC> == <SPC> 0 : <NL>                  matrix [ r ] [ c ] <SPC> = <SPC> curr <NL>              else : <NL>                  matrix [ r ] [ c ] <SPC> = <SPC> curr <SPC> ^ <SPC> matrix [ r <SPC> - <SPC> 1 ] [ c ] <NL>              vals . append ( matrix [ r ] [ c ] ) <NL> <TAB> nth_element ( vals , <SPC> k <SPC> - <SPC> 1 , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> > <SPC> b ) <NL> <TAB> return <SPC> vals [ k <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestValues ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> largestValuesHelper ( root , <SPC> depth , <SPC> result ) : <NL>          if <SPC> not <SPC> root : <NL>              return <NL>          if <SPC> depth <SPC> == <SPC> len ( result ) : <NL>              result . append ( root . val ) <NL>          else : <NL>              result [ depth ] <SPC> = <SPC> max ( result [ depth ] , <SPC> root . val ) <NL>          largestValuesHelper ( root . left , <SPC> depth <SPC> + <SPC> 1 , <SPC> result ) <NL>          largestValuesHelper ( root . right , <SPC> depth <SPC> + <SPC> 1 , <SPC> result ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> largestValuesHelper ( root , <SPC> 0 , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> largestValues ( self , <SPC> root ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> curr <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> any ( curr ) : <NL>          result . append ( max ( node . val <SPC> for <SPC> node <SPC> in <SPC> curr ) ) <NL>          curr <SPC> = <SPC> [ <NL>              child <SPC> for <SPC> node <SPC> in <SPC> curr <SPC> for <SPC> child <SPC> in <SPC> ( node . left , <SPC> node . right ) <SPC> if <SPC> child <NL>          ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLatestStep ( self , <SPC> arr , <SPC> m ) : <NL> <NL> <TAB> if <SPC> m <SPC> == <SPC> len ( arr ) : <NL>          return <SPC> m <NL> <TAB> length <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( arr ) <SPC> + <SPC> 2 ) <NL> <TAB> result <SPC> = <SPC> - 1 <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( arr ) : <NL>          left , <SPC> right <SPC> = <SPC> length [ x <SPC> - <SPC> 1 ] , <SPC> length [ x <SPC> + <SPC> 1 ] <NL>          if <SPC> left <SPC> == <SPC> m <SPC> or <SPC> right <SPC> == <SPC> m : <NL>              result <SPC> = <SPC> i <NL>          length [ x <SPC> - <SPC> left ] <SPC> = <SPC> length [ x <SPC> + <SPC> right ] <SPC> = <SPC> left <SPC> + <SPC> right <SPC> + <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLeaves ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> findLeavesHelper ( node , <SPC> result ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> - 1 <NL>          level <SPC> = <SPC> 1 <SPC> + <SPC> max ( <NL>              findLeavesHelper ( node . left , <SPC> result ) , <NL>              findLeavesHelper ( node . right , <SPC> result ) , <NL>          ) <NL>          if <SPC> len ( result ) <SPC> < <SPC> level <SPC> + <SPC> 1 : <NL>              result . append ( [ ] ) <NL>          result [ level ] . append ( node . val ) <NL>          return <SPC> level <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> findLeavesHelper ( root , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestAwesome ( self , <SPC> s ) : <NL> <NL> <TAB> ALPHABET_SIZE <SPC> = <SPC> 10 <NL> <TAB> result , <SPC> mask , <SPC> lookup <SPC> = <SPC> 0 , <SPC> 0 , <SPC> [ len ( s ) ] <SPC> * <SPC> ( 2 <SPC> ** <SPC> ALPHABET_SIZE ) <NL> <TAB> lookup [ 0 ] <SPC> = <SPC> - 1 <NL> <TAB> for <SPC> i , <SPC> ch <SPC> in <SPC> enumerate ( s ) : <NL>          mask <SPC> ^= <SPC> 2 <SPC> ** <SPC> ( ord ( ch ) <SPC> - <SPC> ord ( "0" ) ) <NL>          if <SPC> lookup [ mask ] <SPC> == <SPC> len ( s ) : <NL>              lookup [ mask ] <SPC> = <SPC> i <NL>          result <SPC> = <SPC> max ( result , <SPC> i <SPC> - <SPC> lookup [ mask ] ) <NL>          for <SPC> d <SPC> in <SPC> xrange ( ALPHABET_SIZE ) : <NL>              result <SPC> = <SPC> max ( result , <SPC> i <SPC> - <SPC> lookup [ mask <SPC> ^ <SPC> ( 2 <SPC> ** <SPC> d ) ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLucky ( self , <SPC> arr ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( arr ) <NL> <TAB> result <SPC> = <SPC> - 1 <NL> <TAB> for <SPC> k , <SPC> v <SPC> in <SPC> count . iteritems ( ) : <NL>          if <SPC> k <SPC> == <SPC> v : <NL>              result <SPC> = <SPC> max ( result , <SPC> k ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> from <SPC> heapq <SPC> import <SPC> heappush , <SPC> heappop <NL> <NL> <NL> class <SPC> MedianFinder ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . __max_heap <SPC> = <SPC> [ ] <NL> <TAB> self . __min_heap <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> addNum ( self , <SPC> num ) : <NL> <NL> <TAB> if <SPC> not <SPC> self . __max_heap <SPC> or <SPC> num <SPC> > <SPC> - self . __max_heap [ 0 ] : <NL>          heappush ( self . __min_heap , <SPC> num ) <NL>          if <SPC> len ( self . __min_heap ) <SPC> > <SPC> len ( self . __max_heap ) <SPC> + <SPC> 1 : <NL>              heappush ( self . __max_heap , <SPC> - heappop ( self . __min_heap ) ) <NL> <TAB> else : <NL>          heappush ( self . __max_heap , <SPC> - num ) <NL>          if <SPC> len ( self . __max_heap ) <SPC> > <SPC> len ( self . __min_heap ) : <NL>              heappush ( self . __min_heap , <SPC> - heappop ( self . __max_heap ) ) <NL> <NL> <TAB> def <SPC> findMedian ( self ) : <NL> <NL> <TAB> return <SPC> ( <NL>          ( - self . __max_heap [ 0 ] <SPC> + <SPC> self . __min_heap [ 0 ] ) <SPC> / <SPC> 2.0 <NL>          if <SPC> len ( self . __min_heap ) <SPC> == <SPC> len ( self . __max_heap ) <NL>          else <SPC> self . __min_heap [ 0 ] <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMin ( self , <SPC> nums ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL> <NL>          if <SPC> nums [ mid ] <SPC> == <SPC> nums [ right ] : <NL>              right <SPC> -= <SPC> 1 <NL>          elif <SPC> nums [ mid ] <SPC> < <SPC> nums [ right ] : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> nums [ left ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findMin ( self , <SPC> nums ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right <SPC> and <SPC> nums [ left ] <SPC> >= <SPC> nums [ right ] : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL> <NL>          if <SPC> nums [ mid ] <SPC> == <SPC> nums [ left ] : <NL>              left <SPC> += <SPC> 1 <NL>          elif <SPC> nums [ mid ] <SPC> < <SPC> nums [ left ] : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> nums [ left ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMin ( self , <SPC> nums ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <NL> <TAB> target <SPC> = <SPC> nums [ - 1 ] <NL> <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL> <NL>          if <SPC> nums [ mid ] <SPC> <= <SPC> target : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> nums [ left ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findMin ( self , <SPC> nums ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right <SPC> and <SPC> nums [ left ] <SPC> >= <SPC> nums [ right ] : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL> <NL>          if <SPC> nums [ mid ] <SPC> < <SPC> nums [ left ] : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> nums [ left ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumTimeRequired ( self , <SPC> jobs , <SPC> k ) : <NL> <NL> <TAB> def <SPC> backtracking ( jobs , <SPC> i , <SPC> cap , <SPC> counts ) : <NL>          if <SPC> i <SPC> == <SPC> len ( jobs ) : <NL>              return <SPC> True <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( counts ) ) : <NL>              if <SPC> counts [ j ] <SPC> + <SPC> jobs [ i ] <SPC> <= <SPC> cap : <NL>                  counts [ j ] <SPC> += <SPC> jobs [ i ] <NL>                  if <SPC> backtracking ( jobs , <SPC> i <SPC> + <SPC> 1 , <SPC> cap , <SPC> counts ) : <NL>                      return <SPC> True <NL>                  counts [ j ] <SPC> -= <SPC> jobs [ i ] <NL>              if <SPC> counts [ j ] <SPC> == <SPC> 0 : <NL>                  break <NL>          return <SPC> False <NL> <NL> <TAB> jobs . sort ( reverse = True ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> max ( jobs ) , <SPC> sum ( jobs ) <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> backtracking ( jobs , <SPC> 0 , <SPC> mid , <SPC> [ 0 ] <SPC> * <SPC> k ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minimumTimeRequired ( self , <SPC> jobs , <SPC> k ) : <NL> <NL> <TAB> def <SPC> backtracking ( jobs , <SPC> i , <SPC> counts , <SPC> result ) : <NL>          if <SPC> i <SPC> == <SPC> len ( jobs ) : <NL>              result [ 0 ] <SPC> = <SPC> min ( result [ 0 ] , <SPC> max ( counts ) ) <NL>              return <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( counts ) ) : <NL>              if <SPC> counts [ j ] <SPC> + <SPC> jobs [ i ] <SPC> <= <SPC> result [ 0 ] : <NL>                  counts [ j ] <SPC> += <SPC> jobs [ i ] <NL>                  backtracking ( jobs , <SPC> i <SPC> + <SPC> 1 , <SPC> counts , <SPC> result ) <NL>                  counts [ j ] <SPC> -= <SPC> jobs [ i ] <NL>              if <SPC> counts [ j ] <SPC> == <SPC> 0 : <NL>                  break <NL> <NL> <TAB> jobs . sort ( reverse = False ) <NL> <TAB> result <SPC> = <SPC> [ sum ( jobs ) ] <NL> <TAB> backtracking ( jobs , <SPC> 0 , <SPC> [ 0 ] <SPC> * <SPC> k , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMode ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> inorder ( root , <SPC> prev , <SPC> cnt , <SPC> max_cnt , <SPC> result ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> prev , <SPC> cnt , <SPC> max_cnt <NL> <NL>          prev , <SPC> cnt , <SPC> max_cnt <SPC> = <SPC> inorder ( root . left , <SPC> prev , <SPC> cnt , <SPC> max_cnt , <SPC> result ) <NL>          if <SPC> prev : <NL>              if <SPC> root . val <SPC> == <SPC> prev . val : <NL>                  cnt <SPC> += <SPC> 1 <NL>              else : <NL>                  cnt <SPC> = <SPC> 1 <NL>          if <SPC> cnt <SPC> > <SPC> max_cnt : <NL>              max_cnt <SPC> = <SPC> cnt <NL>              del <SPC> result [ : ] <NL>              result . append ( root . val ) <NL>          elif <SPC> cnt <SPC> == <SPC> max_cnt : <NL>              result . append ( root . val ) <NL>          return <SPC> inorder ( root . right , <SPC> root , <SPC> cnt , <SPC> max_cnt , <SPC> result ) <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> [ ] <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> inorder ( root , <SPC> None , <SPC> 1 , <SPC> 0 , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumZero ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( - ( n <SPC> // <SPC> 2 ) , <SPC> n <SPC> // <SPC> 2 <SPC> + <SPC> 1 ) <SPC> if <SPC> not <SPC> ( i <SPC> == <SPC> 0 <SPC> and <SPC> n <SPC> % <SPC> 2 <SPC> == <SPC> 0 ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nearestValidPoint ( self , <SPC> x , <SPC> y , <SPC> points ) : <NL> <NL> <TAB> smallest , <SPC> idx <SPC> = <SPC> float ( "inf" ) , <SPC> - 1 <NL> <TAB> for <SPC> i , <SPC> ( r , <SPC> c ) <SPC> in <SPC> enumerate ( points ) : <NL>          dx , <SPC> dy <SPC> = <SPC> x <SPC> - <SPC> r , <SPC> y <SPC> - <SPC> c <NL>          if <SPC> dx <SPC> * <SPC> dy <SPC> == <SPC> 0 <SPC> and <SPC> abs ( dx ) <SPC> + <SPC> abs ( dy ) <SPC> < <SPC> smallest : <NL>              smallest <SPC> = <SPC> abs ( dx ) <SPC> + <SPC> abs ( dy ) <NL>              idx <SPC> = <SPC> i <NL> <TAB> return <SPC> idx <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findNeartestRightNode ( self , <SPC> root , <SPC> u ) : <NL> <NL> <TAB> q <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> q : <NL>          new_q <SPC> = <SPC> [ ] <NL>          for <SPC> i , <SPC> node <SPC> in <SPC> enumerate ( q ) : <NL>              if <SPC> node <SPC> == <SPC> u : <NL>                  return <SPC> q [ i <SPC> + <SPC> 1 ] <SPC> if <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( q ) <SPC> else <SPC> None <NL>              if <SPC> node . left : <NL>                  new_q . append ( node . left ) <NL>              if <SPC> node . right : <NL>                  new_q . append ( node . right ) <NL>          q <SPC> = <SPC> new_q <NL> <TAB> return <SPC> None <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 5 <NL> <TAB> self . __lookup <SPC> = <SPC> [ 0 ] <NL> <TAB> i <SPC> = <SPC> 10 <NL> <TAB> while <SPC> i <SPC> < <SPC> M : <NL>          self . __lookup . append ( i ) <NL>          i <SPC> *= <SPC> 10 <NL> <TAB> self . __lookup . append ( i ) <NL> <NL> <TAB> def <SPC> findNumbers ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> digit_count ( n ) : <NL>          return <SPC> bisect . bisect_right ( self . __lookup , <SPC> n ) <NL> <NL> <TAB> return <SPC> sum ( digit_count ( n ) <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> for <SPC> n <SPC> in <SPC> nums ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findNumbers ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> digit_count ( n ) : <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> n : <NL>              n <SPC> //= <SPC> 10 <NL>              result <SPC> += <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> sum ( digit_count ( n ) <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> for <SPC> n <SPC> in <SPC> nums ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> findNumbers ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> sum ( len ( str ( n ) ) <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> for <SPC> n <SPC> in <SPC> nums ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findPeakElement ( self , <SPC> nums ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> nums [ mid ] <SPC> > <SPC> nums [ mid <SPC> + <SPC> 1 ] : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findPermutation ( self , <SPC> s ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> i <SPC> == <SPC> len ( s ) <SPC> or <SPC> s [ i ] <SPC> == <SPC> "I" : <NL>              result <SPC> += <SPC> range ( i <SPC> + <SPC> 1 , <SPC> len ( result ) , <SPC> - 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pivotIndex ( self , <SPC> nums ) : <NL> <NL> <TAB> total <SPC> = <SPC> sum ( nums ) <NL> <TAB> left_sum <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          if <SPC> left_sum <SPC> == <SPC> ( total <SPC> - <SPC> left_sum <SPC> - <SPC> num ) : <NL>              return <SPC> i <NL>          left_sum <SPC> += <SPC> num <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findSolution ( self , <SPC> customfunction , <SPC> z ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> x , <SPC> y <SPC> = <SPC> 1 , <SPC> 1 <NL> <TAB> while <SPC> customfunction . f ( x , <SPC> y ) <SPC> < <SPC> z : <NL>          y <SPC> += <SPC> 1 <NL> <TAB> while <SPC> y <SPC> > <SPC> 0 : <NL>          while <SPC> y <SPC> > <SPC> 0 <SPC> and <SPC> customfunction . f ( x , <SPC> y ) <SPC> > <SPC> z : <NL>              y <SPC> -= <SPC> 1 <NL>          if <SPC> y <SPC> > <SPC> 0 <SPC> and <SPC> customfunction . f ( x , <SPC> y ) <SPC> == <SPC> z : <NL>              result . append ( [ x , <SPC> y ] ) <NL>          x <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findRightInterval ( self , <SPC> intervals ) : <NL> <NL> <TAB> sorted_intervals <SPC> = <SPC> sorted ( <NL>          ( interval . start , <SPC> i ) <SPC> for <SPC> i , <SPC> interval <SPC> in <SPC> enumerate ( intervals ) <NL> <TAB> ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> interval <SPC> in <SPC> intervals : <NL>          idx <SPC> = <SPC> bisect . bisect_left ( sorted_intervals , <SPC> ( interval . end , ) ) <NL>          result . append ( <NL>              sorted_intervals [ idx ] [ 1 ] <SPC> if <SPC> idx <SPC> < <SPC> len ( sorted_intervals ) <SPC> else <SPC> - 1 <NL>          ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = None , <SPC> children = None ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findRoot ( self , <SPC> tree ) : <NL> <NL> <TAB> root <SPC> = <SPC> 0 <NL> <TAB> for <SPC> node <SPC> in <SPC> tree : <NL>          root <SPC> ^= <SPC> id ( node ) <NL>          for <SPC> child <SPC> in <SPC> node . children : <NL>              root <SPC> ^= <SPC> id ( child ) <NL> <TAB> for <SPC> node <SPC> in <SPC> tree : <NL>          if <SPC> id ( node ) <SPC> == <SPC> root : <NL>              return <SPC> node <NL> <TAB> return <SPC> None <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findRoot ( self , <SPC> tree ) : <NL> <NL> <TAB> root <SPC> = <SPC> 0 <NL> <TAB> for <SPC> node <SPC> in <SPC> tree : <NL>          root <SPC> ^= <SPC> node . val <NL>          for <SPC> child <SPC> in <SPC> node . children : <NL>              root <SPC> ^= <SPC> child . val <NL> <TAB> for <SPC> node <SPC> in <SPC> tree : <NL>          if <SPC> node . val <SPC> == <SPC> root : <NL>              return <SPC> node <NL> <TAB> return <SPC> None <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> findRoot ( self , <SPC> tree ) : <NL> <NL> <TAB> root <SPC> = <SPC> 0 <NL> <TAB> for <SPC> node <SPC> in <SPC> tree : <NL>          root <SPC> += <SPC> node . val <SPC> - <SPC> sum ( child . val <SPC> for <SPC> child <SPC> in <SPC> node . children ) <NL> <TAB> for <SPC> node <SPC> in <SPC> tree : <NL>          if <SPC> node . val <SPC> == <SPC> root : <NL>              return <SPC> node <NL> <TAB> return <SPC> None <NL> <NL> <NL> import <SPC> itertools <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> busiestServers ( self , <SPC> k , <SPC> arrival , <SPC> load ) : <NL> <NL> <TAB> count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> k <NL> <TAB> min_heap_of_endtimes <SPC> = <SPC> [ ] <NL> <TAB> min_heap_of_nodes_after_curr <SPC> = <SPC> [ ] <NL> <TAB> min_heap_of_nodes_before_curr <SPC> = <SPC> range ( k ) <NL> <TAB> for <SPC> i , <SPC> ( t , <SPC> l ) <SPC> in <SPC> enumerate ( itertools . izip ( arrival , <SPC> load ) ) : <NL>          if <SPC> i <SPC> % <SPC> k <SPC> == <SPC> 0 : <NL>              min_heap_of_nodes_before_curr , <SPC> min_heap_of_nodes_after_curr <SPC> = <SPC> ( <NL>                  [ ] , <NL>                  min_heap_of_nodes_before_curr , <NL>              ) <NL>          while <SPC> min_heap_of_endtimes <SPC> and <SPC> min_heap_of_endtimes [ 0 ] [ 0 ] <SPC> <= <SPC> t : <NL>              _ , <SPC> free <SPC> = <SPC> heapq . heappop ( min_heap_of_endtimes ) <NL>              if <SPC> free <SPC> < <SPC> i <SPC> % <SPC> k : <NL>                  heapq . heappush ( min_heap_of_nodes_before_curr , <SPC> free ) <NL>              else : <NL>                  heapq . heappush ( min_heap_of_nodes_after_curr , <SPC> free ) <NL>          min_heap_of_candidates <SPC> = <SPC> ( <NL>              min_heap_of_nodes_after_curr <NL>              if <SPC> min_heap_of_nodes_after_curr <NL>              else <SPC> min_heap_of_nodes_before_curr <NL>          ) <NL>          if <SPC> not <SPC> min_heap_of_candidates : <NL>              continue <NL>          node <SPC> = <SPC> heapq . heappop ( min_heap_of_candidates ) <NL>          count [ node ] <SPC> += <SPC> 1 <NL>          heapq . heappush ( min_heap_of_endtimes , <SPC> ( t <SPC> + <SPC> l , <SPC> node ) ) <NL> <TAB> max_count <SPC> = <SPC> max ( count ) <NL> <TAB> return <SPC> [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( k ) <SPC> if <SPC> count [ i ] <SPC> == <SPC> max_count ] <NL> <NL> <NL> import <SPC> sortedcontainers <NL> import <SPC> itertools <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> busiestServers ( self , <SPC> k , <SPC> arrival , <SPC> load ) : <NL> <NL> <TAB> count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> k <NL> <TAB> min_heap_of_endtimes <SPC> = <SPC> [ ] <NL> <TAB> availables <SPC> = <SPC> sortedcontainers . SortedList ( xrange ( k ) ) <NL> <TAB> for <SPC> i , <SPC> ( t , <SPC> l ) <SPC> in <SPC> enumerate ( itertools . izip ( arrival , <SPC> load ) ) : <NL>          while <SPC> min_heap_of_endtimes <SPC> and <SPC> min_heap_of_endtimes [ 0 ] [ 0 ] <SPC> <= <SPC> t : <NL>              _ , <SPC> free <SPC> = <SPC> heapq . heappop ( min_heap_of_endtimes ) <NL>              availables . add ( free ) <NL>          if <SPC> not <SPC> availables : <NL>              continue <NL>          idx <SPC> = <SPC> availables . bisect_left ( i <SPC> % <SPC> k ) <SPC> % <SPC> len ( availables ) <NL>          node <SPC> = <SPC> availables . pop ( idx ) <NL>          count [ node ] <SPC> += <SPC> 1 <NL>          heapq . heappush ( min_heap_of_endtimes , <SPC> ( t <SPC> + <SPC> l , <SPC> node ) ) <NL> <TAB> max_count <SPC> = <SPC> max ( count ) <NL> <TAB> return <SPC> [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( k ) <SPC> if <SPC> count [ i ] <SPC> == <SPC> max_count ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestCommonElement ( self , <SPC> mat ) : <NL> <NL> <TAB> intersections <SPC> = <SPC> set ( mat [ 0 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( mat ) ) : <NL>          intersections <SPC> &= <SPC> set ( mat [ i ] ) <NL>          if <SPC> not <SPC> intersections : <NL>              return <SPC> - 1 <NL> <TAB> return <SPC> min ( intersections ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> smallestCommonElement ( self , <SPC> mat ) : <NL> <NL> <TAB> counter <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> for <SPC> row <SPC> in <SPC> mat : <NL>          for <SPC> c <SPC> in <SPC> row : <NL>              counter [ c ] <SPC> += <SPC> 1 <NL>              if <SPC> counter [ c ] <SPC> == <SPC> len ( mat ) : <NL>                  return <SPC> c <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nextGreatestLetter ( self , <SPC> letters , <SPC> target ) : <NL> <NL> <TAB> i <SPC> = <SPC> bisect . bisect_right ( letters , <SPC> target ) <NL> <TAB> return <SPC> letters [ 0 ] <SPC> if <SPC> i <SPC> == <SPC> len ( letters ) <SPC> else <SPC> letters [ i ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findCelebrity ( self , <SPC> n ) : <NL> <NL> <TAB> candidate <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>          if <SPC> knows ( candidate , <SPC> i ) : <NL>              candidate <SPC> = <SPC> i <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          candidate_knows_i <SPC> = <SPC> knows ( candidate , <SPC> i ) <NL>          i_knows_candidate <SPC> = <SPC> knows ( i , <SPC> candidate ) <NL>          if <SPC> i <SPC> != <SPC> candidate <SPC> and <SPC> ( candidate_knows_i <SPC> or <SPC> not <SPC> i_knows_candidate ) : <NL>              return <SPC> - 1 <NL> <TAB> return <SPC> candidate <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findTheCity ( self , <SPC> n , <SPC> edges , <SPC> distanceThreshold ) : <NL> <NL> <TAB> dist <SPC> = <SPC> [ [ float ( "inf" ) ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> i , <SPC> j , <SPC> w <SPC> in <SPC> edges : <NL>          dist [ i ] [ j ] <SPC> = <SPC> dist [ j ] [ i ] <SPC> = <SPC> w <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          dist [ i ] [ i ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> k <SPC> in <SPC> xrange ( n ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>                  dist [ i ] [ j ] <SPC> = <SPC> min ( dist [ i ] [ j ] , <SPC> dist [ i ] [ k ] <SPC> + <SPC> dist [ k ] [ j ] ) <NL> <TAB> result <SPC> = <SPC> { <NL>          sum ( d <SPC> <= <SPC> distanceThreshold <SPC> for <SPC> d <SPC> in <SPC> dist [ i ] ) : <SPC> i <SPC> for <SPC> i <SPC> in <SPC> xrange ( n ) } <NL> <TAB> return <SPC> result [ min ( result . iterkeys ( ) ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nearestPalindromic ( self , <SPC> n ) : <NL> <NL> <TAB> l <SPC> = <SPC> len ( n ) <NL> <TAB> candidates <SPC> = <SPC> set ( ( str ( 10 <SPC> ** <SPC> l <SPC> + <SPC> 1 ) , <SPC> str ( 10 <SPC> ** <SPC> ( l <SPC> - <SPC> 1 ) <SPC> - <SPC> 1 ) ) ) <NL> <TAB> prefix <SPC> = <SPC> int ( n [ : <SPC> ( l <SPC> + <SPC> 1 ) <SPC> / <SPC> 2 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> map ( str , <SPC> ( prefix <SPC> - <SPC> 1 , <SPC> prefix , <SPC> prefix <SPC> + <SPC> 1 ) ) : <NL>          candidates . add ( i <SPC> + <SPC> [ i , <SPC> i [ : - 1 ] ] [ l <SPC> % <SPC> 2 ] [ : : - 1 ] ) <NL> <TAB> candidates . discard ( n ) <NL> <TAB> return <SPC> min ( candidates , <SPC> key = lambda <SPC> x : <SPC> ( abs ( int ( x ) <SPC> - <SPC> int ( n ) ) , <SPC> int ( x ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findDerangement ( self , <SPC> n ) : <NL> <NL> <TAB> M <SPC> = <SPC> 1000000007 <NL> <TAB> mul , <SPC> total <SPC> = <SPC> 1 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( n <SPC> + <SPC> 1 ) ) : <NL>          total <SPC> = <SPC> ( total <SPC> + <SPC> M <SPC> + <SPC> ( 1 <SPC> if <SPC> i <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> else <SPC> - 1 ) <SPC> * <SPC> mul ) <SPC> % <SPC> M <NL>          mul <SPC> = <SPC> ( mul <SPC> * <SPC> i ) <SPC> % <SPC> M <NL> <TAB> return <SPC> total <NL> <NL> <NL> import <SPC> operator <NL> import <SPC> collections <NL> from <SPC> functools <SPC> import <SPC> reduce <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findTheDifference ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> return <SPC> chr ( <NL>          reduce ( operator . xor , <SPC> map ( ord , <SPC> s ) , <SPC> 0 ) <SPC> ^ <SPC> reduce ( <NL>              operator . xor , <SPC> map ( ord , <SPC> t ) , <SPC> 0 ) <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> findTheDifference2 ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> t <SPC> = <SPC> list ( t ) <NL> <TAB> s <SPC> = <SPC> list ( s ) <NL> <TAB> for <SPC> i <SPC> in <SPC> s : <NL>          t . remove ( i ) <NL> <TAB> return <SPC> t [ 0 ] <NL> <NL> <TAB> def <SPC> findTheDifference3 ( self , <SPC> s , <SPC> t ) : <NL> <TAB> return <SPC> chr ( reduce ( operator . xor , <SPC> map ( ord , <SPC> s <SPC> + <SPC> t ) ) ) <NL> <NL> <TAB> def <SPC> findTheDifference4 ( self , <SPC> s , <SPC> t ) : <NL> <TAB> return <SPC> list ( ( collections . Counter ( t ) <SPC> - <SPC> collections . Counter ( s ) ) ) [ 0 ] <NL> <NL> <TAB> def <SPC> findTheDifference5 ( self , <SPC> s , <SPC> t ) : <NL> <TAB> s , <SPC> t <SPC> = <SPC> sorted ( s ) , <SPC> sorted ( t ) <NL> <TAB> return <SPC> t [ - 1 ] <SPC> if <SPC> s <SPC> == <SPC> t [ : - 1 ] <SPC> else <SPC> [ x [ 1 ] <SPC> for <SPC> x <SPC> in <SPC> zip ( s , <SPC> t ) <SPC> if <SPC> x [ 0 ] <SPC> != <SPC> x [ 1 ] ] [ 0 ] <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findTheDistanceValue ( self , <SPC> arr1 , <SPC> arr2 , <SPC> d ) : <NL> <NL> <TAB> arr2 . sort ( ) <NL> <TAB> result , <SPC> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> arr1 : <NL>          j <SPC> = <SPC> bisect . bisect_left ( arr2 , <SPC> x ) <NL>          left <SPC> = <SPC> arr2 [ j <SPC> - <SPC> 1 ] <SPC> if <SPC> j <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <SPC> else <SPC> float ( "-inf" ) <NL>          right <SPC> = <SPC> arr2 [ j ] <SPC> if <SPC> j <SPC> < <SPC> len ( arr2 ) <SPC> else <SPC> float ( "inf" ) <NL>          result <SPC> += <SPC> left <SPC> + <SPC> d <SPC> < <SPC> x <SPC> < <SPC> right <SPC> - <SPC> d <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findTheDistanceValue ( self , <SPC> arr1 , <SPC> arr2 , <SPC> d ) : <NL> <NL> <TAB> arr1 . sort ( ) , <SPC> arr2 . sort ( ) <NL> <TAB> result , <SPC> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( arr1 ) <SPC> and <SPC> j <SPC> < <SPC> len ( arr2 ) : <NL>          if <SPC> arr1 [ i ] <SPC> - <SPC> arr2 [ j ] <SPC> > <SPC> d : <NL>              j <SPC> += <SPC> 1 <NL>              continue <NL>          result <SPC> += <SPC> arr2 [ j ] <SPC> - <SPC> arr1 [ i ] <SPC> > <SPC> d <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <SPC> + <SPC> len ( arr1 ) <SPC> - <SPC> i <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findDuplicate ( self , <SPC> nums ) : <NL> <NL> <TAB> slow <SPC> = <SPC> nums [ 0 ] <NL> <TAB> fast <SPC> = <SPC> nums [ nums [ 0 ] ] <NL> <TAB> while <SPC> slow <SPC> != <SPC> fast : <NL>          slow <SPC> = <SPC> nums [ slow ] <NL>          fast <SPC> = <SPC> nums [ nums [ fast ] ] <NL> <NL> <TAB> fast <SPC> = <SPC> 0 <NL> <TAB> while <SPC> slow <SPC> != <SPC> fast : <NL>          slow <SPC> = <SPC> nums [ slow ] <NL>          fast <SPC> = <SPC> nums [ fast ] <NL> <TAB> return <SPC> slow <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findDuplicate ( self , <SPC> nums ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL> <NL>          count <SPC> = <SPC> 0 <NL>          for <SPC> num <SPC> in <SPC> nums : <NL>              if <SPC> num <SPC> <= <SPC> mid : <NL>                  count <SPC> += <SPC> 1 <NL>          if <SPC> count <SPC> > <SPC> mid : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> findDuplicate ( self , <SPC> nums ) : <NL> <NL> <TAB> duplicate <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          if <SPC> nums [ abs ( num ) <SPC> - <SPC> 1 ] <SPC> > <SPC> 0 : <NL>              nums [ abs ( num ) <SPC> - <SPC> 1 ] <SPC> *= <SPC> - 1 <NL>          else : <NL>              duplicate <SPC> = <SPC> abs ( num ) <NL>              break <NL> <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          if <SPC> nums [ abs ( num ) <SPC> - <SPC> 1 ] <SPC> < <SPC> 0 : <NL>              nums [ abs ( num ) <SPC> - <SPC> 1 ] <SPC> *= <SPC> - 1 <NL>          else : <NL>              break <NL> <TAB> return <SPC> duplicate <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestAltitude ( self , <SPC> gain ) : <NL> <NL> <TAB> result <SPC> = <SPC> curr <SPC> = <SPC> 0 <NL> <TAB> for <SPC> g <SPC> in <SPC> gain : <NL>          curr <SPC> += <SPC> g <NL>          result <SPC> = <SPC> max ( result , <SPC> curr ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> ArrayReader ( object ) : <NL> <TAB> def <SPC> compareSub ( self , <SPC> l , <SPC> r , <SPC> x , <SPC> y ) : <NL> <TAB> pass <NL> <NL> <TAB> def <SPC> length ( self ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getIndex ( self , <SPC> reader ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> reader . length ( ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> ( <NL>              reader . compareSub ( <NL>                  left , <SPC> mid , <SPC> mid <SPC> if <SPC> ( right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 <SPC> else <SPC> mid <SPC> + <SPC> 1 , <SPC> right <NL>              ) <NL>              >= <SPC> 0 <NL>          ) : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kthSmallest ( self , <SPC> mat , <SPC> k ) : <NL> <NL> <TAB> def <SPC> kSmallestPairs ( nums1 , <SPC> nums2 , <SPC> k ) : <NL>          result , <SPC> min_heap <SPC> = <SPC> [ ] , <SPC> [ ] <NL>          for <SPC> c <SPC> in <SPC> xrange ( min ( len ( nums1 ) , <SPC> k ) ) : <NL>              heapq . heappush ( min_heap , <SPC> ( nums1 [ c ] <SPC> + <SPC> nums2 [ 0 ] , <SPC> 0 ) ) <NL>              c <SPC> += <SPC> 1 <NL>          while <SPC> len ( result ) <SPC> != <SPC> k <SPC> and <SPC> min_heap : <NL>              total , <SPC> c <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>              result . append ( total ) <NL>              if <SPC> c <SPC> + <SPC> 1 <SPC> == <SPC> len ( nums2 ) : <NL>                  continue <NL>              heapq . heappush ( min_heap , <SPC> ( total <SPC> - <SPC> nums2 [ c ] <SPC> + <SPC> nums2 [ c <SPC> + <SPC> 1 ] , <SPC> c <SPC> + <SPC> 1 ) ) <NL>          return <SPC> result <NL> <NL> <TAB> result <SPC> = <SPC> mat [ 0 ] <NL> <TAB> for <SPC> r <SPC> in <SPC> xrange ( 1 , <SPC> len ( mat ) ) : <NL>          result <SPC> = <SPC> kSmallestPairs ( result , <SPC> mat [ r ] , <SPC> k ) <NL> <TAB> return <SPC> result [ k <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> kthSmallest ( self , <SPC> mat , <SPC> k ) : <NL> <NL> <TAB> def <SPC> countArraysHaveSumLessOrEqual ( <NL>          mat , <SPC> k , <SPC> r , <SPC> target <NL> <TAB> ) : <NL>          if <SPC> target <SPC> < <SPC> 0 : <NL>              return <SPC> 0 <NL>          if <SPC> r <SPC> == <SPC> len ( mat ) : <NL>              return <SPC> 1 <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> xrange ( len ( mat [ 0 ] ) ) : <NL>              cnt <SPC> = <SPC> countArraysHaveSumLessOrEqual ( <NL>                  mat , <SPC> k <SPC> - <SPC> result , <SPC> r <SPC> + <SPC> 1 , <SPC> target <SPC> - <SPC> mat [ r ] [ c ] <NL>              ) <NL>              if <SPC> not <SPC> cnt : <NL>                  break <NL>              result <SPC> += <SPC> cnt <NL>              if <SPC> result <SPC> > <SPC> k : <NL>                  break <NL>          return <SPC> result <NL> <NL> <TAB> MAX_NUM <SPC> = <SPC> 5000 <NL> <TAB> left , <SPC> right <SPC> = <SPC> len ( mat ) , <SPC> len ( mat ) <SPC> * <SPC> MAX_NUM <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          cnt <SPC> = <SPC> countArraysHaveSumLessOrEqual ( mat , <SPC> k , <SPC> 0 , <SPC> mid ) <NL>          if <SPC> cnt <SPC> >= <SPC> k : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findTheLongestSubstring ( self , <SPC> s ) : <NL> <NL> <TAB> VOWELS <SPC> = <SPC> "aeiou" <NL> <TAB> result , <SPC> mask , <SPC> lookup <SPC> = <SPC> 0 , <SPC> 0 , <SPC> [ len ( s ) ] <SPC> * <SPC> ( 2 <SPC> ** <SPC> len ( VOWELS ) ) <NL> <TAB> lookup [ 0 ] <SPC> = <SPC> - 1 <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          index <SPC> = <SPC> VOWELS . find ( c ) <NL>          mask <SPC> ^= <SPC> ( 1 <SPC> << <SPC> index ) <SPC> if <SPC> index <SPC> >= <SPC> 0 <SPC> else <SPC> 0 <NL>          if <SPC> lookup [ mask ] <SPC> == <SPC> len ( s ) : <NL>              lookup [ mask ] <SPC> = <SPC> i <NL>          result <SPC> = <SPC> max ( result , <SPC> i <SPC> - <SPC> lookup [ mask ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMinFibonacciNumbers ( self , <SPC> k ) : <NL> <NL> <TAB> result , <SPC> a , <SPC> b <SPC> = <SPC> 0 , <SPC> 1 , <SPC> 1 <NL> <TAB> while <SPC> b <SPC> <= <SPC> k : <NL>          b , <SPC> a <SPC> = <SPC> a <SPC> + <SPC> b , <SPC> b <NL> <TAB> while <SPC> k : <NL>          if <SPC> a <SPC> <= <SPC> k : <NL>              k <SPC> -= <SPC> a <NL>              result <SPC> += <SPC> 1 <NL>          a , <SPC> b <SPC> = <SPC> b <SPC> - <SPC> a , <SPC> a <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mostCompetitive ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( nums ) : <NL>          while <SPC> stk <SPC> and <SPC> stk [ - 1 ] <SPC> > <SPC> x <SPC> and <SPC> len ( stk ) <SPC> + <SPC> ( len ( nums ) <SPC> - <SPC> i ) <SPC> > <SPC> k : <NL>              stk . pop ( ) <NL>          if <SPC> len ( stk ) <SPC> < <SPC> k : <NL>              stk . append ( x ) <NL> <TAB> return <SPC> stk <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestSuperstring ( self , <SPC> A ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( A ) <NL> <TAB> overlaps <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( A ) : <NL>          for <SPC> j , <SPC> y <SPC> in <SPC> enumerate ( A ) : <NL>              for <SPC> l <SPC> in <SPC> reversed ( xrange ( min ( len ( x ) , <SPC> len ( y ) ) ) ) : <NL>                  if <SPC> y [ : l ] . startswith ( x [ len ( x ) <SPC> - <SPC> l : ] ) : <NL>                      overlaps [ i ] [ j ] <SPC> = <SPC> l <NL>                      break <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 1 <SPC> << <SPC> n ) ] <NL> <TAB> prev <SPC> = <SPC> [ [ None ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 1 <SPC> << <SPC> n ) ] <NL> <TAB> for <SPC> mask <SPC> in <SPC> xrange ( 1 , <SPC> 1 <SPC> << <SPC> n ) : <NL>          for <SPC> bit <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> ( ( mask <SPC> >> <SPC> bit ) <SPC> & <SPC> 1 ) <SPC> == <SPC> 0 : <NL>                  continue <NL>              prev_mask <SPC> = <SPC> mask <SPC> ^ <SPC> ( 1 <SPC> << <SPC> bit ) <NL>              for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>                  if <SPC> ( ( prev_mask <SPC> >> <SPC> i ) <SPC> & <SPC> 1 ) <SPC> == <SPC> 0 : <NL>                      continue <NL>                  value <SPC> = <SPC> dp [ prev_mask ] [ i ] <SPC> + <SPC> overlaps [ i ] [ bit ] <NL>                  if <SPC> value <SPC> > <SPC> dp [ mask ] [ bit ] : <NL>                      dp [ mask ] [ bit ] <SPC> = <SPC> value <NL>                      prev [ mask ] [ bit ] <SPC> = <SPC> i <NL> <NL> <TAB> bit <SPC> = <SPC> max ( xrange ( n ) , <SPC> key = dp [ - 1 ] . __getitem__ ) <NL> <TAB> words <SPC> = <SPC> [ ] <NL> <TAB> mask <SPC> = <SPC> ( 1 <SPC> << <SPC> n ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> bit <SPC> is <SPC> not <SPC> None : <NL>          words . append ( bit ) <NL>          mask , <SPC> bit <SPC> = <SPC> mask <SPC> ^ <SPC> ( 1 <SPC> << <SPC> bit ) , <SPC> prev [ mask ] [ bit ] <NL> <TAB> words . reverse ( ) <NL> <TAB> lookup <SPC> = <SPC> set ( words ) <NL> <TAB> words . extend ( [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( n ) <SPC> if <SPC> i <SPC> not <SPC> in <SPC> lookup ] ) <NL> <NL> <TAB> result <SPC> = <SPC> [ A [ words [ 0 ] ] ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( words ) ) : <NL>          overlap <SPC> = <SPC> overlaps [ words [ i <SPC> - <SPC> 1 ] ] [ words [ i ] ] <NL>          result . append ( A [ words [ i ] ] [ overlap : ] ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestDivisor ( self , <SPC> nums , <SPC> threshold ) : <NL> <NL> <TAB> def <SPC> check ( A , <SPC> d , <SPC> threshold ) : <NL>          return <SPC> sum ( ( i <SPC> - <SPC> 1 ) <SPC> // <SPC> d <SPC> + <SPC> 1 <SPC> for <SPC> i <SPC> in <SPC> nums ) <SPC> <= <SPC> threshold <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> max ( nums ) <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> check ( nums , <SPC> mid , <SPC> threshold ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findJudge ( self , <SPC> N , <SPC> trust ) : <NL> <NL> <TAB> degrees <SPC> = <SPC> [ 0 ] <SPC> * <SPC> N <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> trust : <NL>          degrees [ i <SPC> - <SPC> 1 ] <SPC> -= <SPC> 1 <NL>          degrees [ j <SPC> - <SPC> 1 ] <SPC> += <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( degrees ) ) : <NL>          if <SPC> degrees [ i ] <SPC> == <SPC> N <SPC> - <SPC> 1 : <NL>              return <SPC> i <SPC> + <SPC> 1 <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getWinner ( self , <SPC> arr , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> arr [ 0 ] <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( arr ) ) : <NL>          if <SPC> arr [ i ] <SPC> > <SPC> result : <NL>              result <SPC> = <SPC> arr [ i ] <NL>              count <SPC> = <SPC> 0 <NL>          count <SPC> += <SPC> 1 <NL>          if <SPC> count <SPC> == <SPC> k : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minSumOfLengths ( self , <SPC> arr , <SPC> target ) : <NL> <NL> <TAB> prefix , <SPC> dp <SPC> = <SPC> { 0 : <SPC> - 1 } , <SPC> [ 0 ] <SPC> * <SPC> len ( <NL>          arr <NL> <TAB> ) <NL> <TAB> result <SPC> = <SPC> min_len <SPC> = <SPC> float ( "inf" ) <NL> <TAB> accu <SPC> = <SPC> 0 <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( arr ) ) : <NL>          accu <SPC> += <SPC> arr [ right ] <NL>          prefix [ accu ] <SPC> = <SPC> right <NL>          if <SPC> accu <SPC> - <SPC> target <SPC> in <SPC> prefix : <NL>              left <SPC> = <SPC> prefix [ accu <SPC> - <SPC> target ] <NL>              min_len <SPC> = <SPC> min ( min_len , <SPC> right <SPC> - <SPC> left ) <NL>              if <SPC> left <SPC> != <SPC> - 1 : <NL>                  result <SPC> = <SPC> min ( result , <SPC> dp [ left ] <SPC> + <SPC> ( right <SPC> - <SPC> left ) ) <NL>          dp [ right ] <SPC> = <SPC> min_len <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> != <SPC> float ( "inf" ) <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> restoreMatrix ( self , <SPC> rowSum , <SPC> colSum ) : <NL> <NL> <TAB> matrix <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( colSum ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( rowSum ) ) ] <NL> <TAB> i <SPC> = <SPC> j <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( matrix ) <SPC> and <SPC> j <SPC> < <SPC> len ( matrix [ 0 ] ) : <NL>          matrix [ i ] [ j ] <SPC> = <SPC> min ( rowSum [ i ] , <SPC> colSum [ j ] ) <NL>          rowSum [ i ] <SPC> -= <SPC> matrix [ i ] [ j ] <NL>          colSum [ j ] <SPC> -= <SPC> matrix [ i ] [ j ] <NL>          if <SPC> not <SPC> rowSum [ i ] : <NL>              i <SPC> += <SPC> 1 <NL>          if <SPC> not <SPC> colSum [ j ] : <NL>              j <SPC> += <SPC> 1 <NL> <TAB> return <SPC> matrix <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> restoreMatrix ( self , <SPC> rowSum , <SPC> colSum ) : <NL> <NL> <TAB> matrix <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( colSum ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( rowSum ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ i ] ) ) : <NL>              matrix [ i ] [ j ] <SPC> = <SPC> min ( rowSum [ i ] , <SPC> colSum [ j ] ) <NL>              rowSum [ i ] <SPC> -= <SPC> matrix [ i ] [ j ] <NL>              colSum [ j ] <SPC> -= <SPC> matrix [ i ] [ j ] <NL> <TAB> return <SPC> matrix <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> tictactoe ( self , <SPC> moves ) : <NL> <NL> <TAB> row , <SPC> col <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> 3 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] , <SPC> [ [ 0 ] <SPC> * <SPC> 3 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> diag , <SPC> anti_diag <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 , <SPC> [ 0 ] <SPC> * <SPC> 2 <NL> <TAB> p <SPC> = <SPC> 0 <NL> <TAB> for <SPC> r , <SPC> c <SPC> in <SPC> moves : <NL>          row [ p ] [ r ] <SPC> += <SPC> 1 <NL>          col [ p ] [ c ] <SPC> += <SPC> 1 <NL>          diag [ p ] <SPC> += <SPC> r <SPC> == <SPC> c <NL>          anti_diag [ p ] <SPC> += <SPC> r <SPC> + <SPC> c <SPC> == <SPC> 2 <NL>          if <SPC> 3 <SPC> in <SPC> ( row [ p ] [ r ] , <SPC> col [ p ] [ c ] , <SPC> diag [ p ] , <SPC> anti_diag [ p ] ) : <NL>              return <SPC> "AB" [ p ] <NL>          p <SPC> ^= <SPC> 1 <NL> <TAB> return <SPC> "Draw" <SPC> if <SPC> len ( moves ) <SPC> == <SPC> 9 <SPC> else <SPC> "Pending" <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countCharacters ( self , <SPC> words , <SPC> chars ) : <NL> <NL> <TAB> def <SPC> check ( word , <SPC> chars , <SPC> count ) : <NL>          if <SPC> len ( word ) <SPC> > <SPC> len ( chars ) : <NL>              return <SPC> False <NL>          curr_count <SPC> = <SPC> collections . Counter ( ) <NL>          for <SPC> c <SPC> in <SPC> word : <NL>              curr_count [ c ] <SPC> += <SPC> 1 <NL>              if <SPC> c <SPC> not <SPC> in <SPC> count <SPC> or <SPC> count [ c ] <SPC> < <SPC> curr_count [ c ] : <NL>                  return <SPC> False <NL>          return <SPC> True <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( chars ) <NL> <TAB> return <SPC> sum ( len ( word ) <SPC> for <SPC> word <SPC> in <SPC> words <SPC> if <SPC> check ( word , <SPC> chars , <SPC> count ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> firstBadVersion ( self , <SPC> n ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> n <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> isBadVersion ( mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> firstMissingPositive ( self , <SPC> A ) : <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( A ) : <NL>          if <SPC> A [ i ] <SPC> > <SPC> 0 <SPC> and <SPC> A [ i ] <SPC> - <SPC> 1 <SPC> < <SPC> len ( A ) <SPC> and <SPC> A [ i ] <SPC> != <SPC> A [ A [ i ] <SPC> - <SPC> 1 ] : <NL>              A [ A [ i ] <SPC> - <SPC> 1 ] , <SPC> A [ i ] <SPC> = <SPC> A [ i ] , <SPC> A [ A [ i ] <SPC> - <SPC> 1 ] <NL>          else : <NL>              i <SPC> += <SPC> 1 <NL> <NL> <TAB> for <SPC> i , <SPC> integer <SPC> in <SPC> enumerate ( A ) : <NL>          if <SPC> integer <SPC> != <SPC> i <SPC> + <SPC> 1 : <NL>              return <SPC> i <SPC> + <SPC> 1 <NL> <TAB> return <SPC> len ( A ) <SPC> + <SPC> 1 <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> defaultdict <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> firstUniqChar ( self , <SPC> s ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> defaultdict ( int ) <NL> <TAB> candidtates <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          if <SPC> lookup [ c ] : <NL>              candidtates . discard ( lookup [ c ] ) <NL>          else : <NL>              lookup [ c ] <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>              candidtates . add ( i <SPC> + <SPC> 1 ) <NL> <NL> <TAB> return <SPC> min ( candidtates ) <SPC> - <SPC> 1 <SPC> if <SPC> candidtates <SPC> else <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> FirstUnique ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> nums ) : <NL> <NL> <TAB> self . __q <SPC> = <SPC> collections . OrderedDict ( ) <NL> <TAB> self . __dup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          self . add ( num ) <NL> <NL> <TAB> def <SPC> showFirstUnique ( self ) : <NL> <NL> <TAB> if <SPC> self . __q : <NL>          return <SPC> next ( iter ( self . __q ) ) <NL> <TAB> return <SPC> - 1 <NL> <NL> <TAB> def <SPC> add ( self , <SPC> value ) : <NL> <NL> <TAB> if <SPC> value <SPC> not <SPC> in <SPC> self . __dup <SPC> and <SPC> value <SPC> not <SPC> in <SPC> self . __q : <NL>          self . __q [ value ] <SPC> = <SPC> None <NL>          return <NL> <TAB> if <SPC> value <SPC> in <SPC> self . __q : <NL>          self . __q . pop ( value ) <NL>          self . __dup . add ( value ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fixedPoint ( self , <SPC> A ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( A ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> A [ mid ] <SPC> >= <SPC> mid : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <SPC> if <SPC> A [ left ] <SPC> == <SPC> left <SPC> else <SPC> - 1 <NL> <NL> <NL> import <SPC> threading <NL> <NL> <NL> class <SPC> FizzBuzz ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . __n <SPC> = <SPC> n <NL> <TAB> self . __curr <SPC> = <SPC> 0 <NL> <TAB> self . __cv <SPC> = <SPC> threading . Condition ( ) <NL> <NL> <TAB> def <SPC> fizz ( self , <SPC> printFizz ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> self . __n <SPC> + <SPC> 1 ) : <NL>          with <SPC> self . __cv : <NL>              while <SPC> self . __curr <SPC> % <SPC> 4 <SPC> != <SPC> 0 : <NL>                  self . __cv . wait ( ) <NL>              self . __curr <SPC> += <SPC> 1 <NL>              if <SPC> i <SPC> % <SPC> 3 <SPC> == <SPC> 0 <SPC> and <SPC> i <SPC> % <SPC> 5 <SPC> != <SPC> 0 : <NL>                  printFizz ( ) <NL>              self . __cv . notify_all ( ) <NL> <NL> <TAB> def <SPC> buzz ( self , <SPC> printBuzz ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> self . __n <SPC> + <SPC> 1 ) : <NL>          with <SPC> self . __cv : <NL>              while <SPC> self . __curr <SPC> % <SPC> 4 <SPC> != <SPC> 1 : <NL>                  self . __cv . wait ( ) <NL>              self . __curr <SPC> += <SPC> 1 <NL>              if <SPC> i <SPC> % <SPC> 3 <SPC> != <SPC> 0 <SPC> and <SPC> i <SPC> % <SPC> 5 <SPC> == <SPC> 0 : <NL>                  printBuzz ( ) <NL>              self . __cv . notify_all ( ) <NL> <NL> <TAB> def <SPC> fizzbuzz ( self , <SPC> printFizzBuzz ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> self . __n <SPC> + <SPC> 1 ) : <NL>          with <SPC> self . __cv : <NL>              while <SPC> self . __curr <SPC> % <SPC> 4 <SPC> != <SPC> 2 : <NL>                  self . __cv . wait ( ) <NL>              self . __curr <SPC> += <SPC> 1 <NL>              if <SPC> i <SPC> % <SPC> 3 <SPC> == <SPC> 0 <SPC> and <SPC> i <SPC> % <SPC> 5 <SPC> == <SPC> 0 : <NL>                  printFizzBuzz ( ) <NL>              self . __cv . notify_all ( ) <NL> <NL> <TAB> def <SPC> number ( self , <SPC> printNumber ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> self . __n <SPC> + <SPC> 1 ) : <NL>          with <SPC> self . __cv : <NL>              while <SPC> self . __curr <SPC> % <SPC> 4 <SPC> != <SPC> 3 : <NL>                  self . __cv . wait ( ) <NL>              self . __curr <SPC> += <SPC> 1 <NL>              if <SPC> i <SPC> % <SPC> 3 <SPC> != <SPC> 0 <SPC> and <SPC> i <SPC> % <SPC> 5 <SPC> != <SPC> 0 : <NL>                  printNumber ( i ) <NL>              self . __cv . notify_all ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fizzBuzz ( self , <SPC> n ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          if <SPC> i <SPC> % <SPC> 15 <SPC> == <SPC> 0 : <NL>              result . append ( "FizzBuzz" ) <NL>          elif <SPC> i <SPC> % <SPC> 5 <SPC> == <SPC> 0 : <NL>              result . append ( "Buzz" ) <NL>          elif <SPC> i <SPC> % <SPC> 3 <SPC> == <SPC> 0 : <NL>              result . append ( "Fizz" ) <NL>          else : <NL>              result . append ( str ( i ) ) <NL> <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> fizzBuzz2 ( self , <SPC> n ) : <NL> <NL> <TAB> l <SPC> = <SPC> [ str ( x ) <SPC> for <SPC> x <SPC> in <SPC> range ( n <SPC> + <SPC> 1 ) ] <NL> <TAB> l3 <SPC> = <SPC> range ( 0 , <SPC> n <SPC> + <SPC> 1 , <SPC> 3 ) <NL> <TAB> l5 <SPC> = <SPC> range ( 0 , <SPC> n <SPC> + <SPC> 1 , <SPC> 5 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> l3 : <NL>          l [ i ] <SPC> = <SPC> "Fizz" <NL> <TAB> for <SPC> i <SPC> in <SPC> l5 : <NL>          if <SPC> l [ i ] <SPC> == <SPC> "Fizz" : <NL>              l [ i ] <SPC> += <SPC> "Buzz" <NL>          else : <NL>              l [ i ] <SPC> = <SPC> "Buzz" <NL> <TAB> return <SPC> l [ 1 : ] <NL> <NL> <TAB> def <SPC> fizzBuzz3 ( self , <SPC> n ) : <NL> <TAB> return <SPC> [ <NL>          "Fizz" <SPC> * <SPC> ( not <SPC> i <SPC> % <SPC> 3 ) <SPC> + <SPC> "Buzz" <SPC> * <SPC> ( not <SPC> i <SPC> % <SPC> 5 ) <SPC> or <SPC> str ( i ) <NL>          for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> n <SPC> + <SPC> 1 ) <NL> <TAB> ] <NL> <NL> <TAB> def <SPC> fizzBuzz4 ( self , <SPC> n ) : <NL> <TAB> return <SPC> [ <NL>          "FizzBuzz" [ i <SPC> % <SPC> - 3 <SPC> & <SPC> - 4 : <SPC> i <SPC> % <SPC> - 5 <SPC> & <SPC> 8 <SPC> ^ <SPC> 12 ] <SPC> or <SPC> repr ( i ) <NL>          for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> n <SPC> + <SPC> 1 ) <NL> <TAB> ] <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> deque <NL> <NL> <NL> class <SPC> Vector2D ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> vec2d ) : <NL> <NL> <TAB> self . stack <SPC> = <SPC> deque ( ( len ( v ) , <SPC> iter ( v ) ) <SPC> for <SPC> v <SPC> in <SPC> vec2d <SPC> if <SPC> v ) <NL> <NL> <TAB> def <SPC> next ( self ) : <NL> <NL> <TAB> length , <SPC> iterator <SPC> = <SPC> self . stack . popleft ( ) <NL> <TAB> if <SPC> length <SPC> > <SPC> 1 : <NL>          self . stack . appendleft ( ( length <SPC> - <SPC> 1 , <SPC> iterator ) ) <NL> <TAB> return <SPC> next ( iterator ) <NL> <NL> <TAB> def <SPC> hasNext ( self ) : <NL> <NL> <TAB> return <SPC> bool ( self . stack ) <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> prev , <SPC> next , <SPC> child ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . prev <SPC> = <SPC> prev <NL> <TAB> self . next <SPC> = <SPC> next <NL> <TAB> self . child <SPC> = <SPC> child <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> flatten ( self , <SPC> head ) : <NL> <NL> <TAB> curr <SPC> = <SPC> head <NL> <TAB> while <SPC> curr : <NL>          if <SPC> curr . child : <NL>              curr_next <SPC> = <SPC> curr . next <NL>              curr . child . prev <SPC> = <SPC> curr <NL>              curr . next <SPC> = <SPC> curr . child <NL>              last_child <SPC> = <SPC> curr <NL>              while <SPC> last_child . next : <NL>                  last_child <SPC> = <SPC> last_child . next <NL>              if <SPC> curr_next : <NL>                  last_child . next <SPC> = <SPC> curr_next <NL>                  curr_next . prev <SPC> = <SPC> last_child <NL>              curr . child <SPC> = <SPC> None <NL>          curr <SPC> = <SPC> curr . next <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> flatten ( self , <SPC> root ) : <NL> <TAB> self . flattenRecu ( root , <SPC> None ) <NL> <NL> <TAB> def <SPC> flattenRecu ( self , <SPC> root , <SPC> list_head ) : <NL> <TAB> if <SPC> root : <NL>          list_head <SPC> = <SPC> self . flattenRecu ( root . right , <SPC> list_head ) <NL>          list_head <SPC> = <SPC> self . flattenRecu ( root . left , <SPC> list_head ) <NL>          root . right <SPC> = <SPC> list_head <NL>          root . left <SPC> = <SPC> None <NL>          return <SPC> root <NL> <TAB> else : <NL>          return <SPC> list_head <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> list_head <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> flatten ( self , <SPC> root ) : <NL> <TAB> if <SPC> root : <NL>          self . flatten ( root . right ) <NL>          self . flatten ( root . left ) <NL>          root . right <SPC> = <SPC> self . list_head <NL>          root . left <SPC> = <SPC> None <NL>          self . list_head <SPC> = <SPC> root <NL> <NL> <NL> class <SPC> NestedIterator ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> nestedList ) : <NL> <NL> <TAB> self . __depth <SPC> = <SPC> [ [ nestedList , <SPC> 0 ] ] <NL> <NL> <TAB> def <SPC> next ( self ) : <NL> <NL> <TAB> nestedList , <SPC> i <SPC> = <SPC> self . __depth [ - 1 ] <NL> <TAB> self . __depth [ - 1 ] [ 1 ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> nestedList [ i ] . getInteger ( ) <NL> <NL> <TAB> def <SPC> hasNext ( self ) : <NL> <NL> <TAB> while <SPC> self . __depth : <NL>          nestedList , <SPC> i <SPC> = <SPC> self . __depth [ - 1 ] <NL>          if <SPC> i <SPC> == <SPC> len ( nestedList ) : <NL>              self . __depth . pop ( ) <NL>          elif <SPC> nestedList [ i ] . isInteger ( ) : <NL>              return <SPC> True <NL>          else : <NL>              self . __depth [ - 1 ] [ 1 ] <SPC> += <SPC> 1 <NL>              self . __depth . append ( [ nestedList [ i ] . getList ( ) , <SPC> 0 ] ) <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> flipMatchVoyage ( self , <SPC> root , <SPC> voyage ) : <NL> <NL> <TAB> def <SPC> dfs ( root , <SPC> voyage , <SPC> i , <SPC> result ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> True <NL>          if <SPC> root . val <SPC> != <SPC> voyage [ i [ 0 ] ] : <NL>              return <SPC> False <NL>          i [ 0 ] <SPC> += <SPC> 1 <NL>          if <SPC> root . left <SPC> and <SPC> root . left . val <SPC> != <SPC> voyage [ i [ 0 ] ] : <NL>              result . append ( root . val ) <NL>              return <SPC> dfs ( root . right , <SPC> voyage , <SPC> i , <SPC> result ) <SPC> and <SPC> dfs ( <NL>                  root . left , <SPC> voyage , <SPC> i , <SPC> result <NL>              ) <NL>          return <SPC> dfs ( root . left , <SPC> voyage , <SPC> i , <SPC> result ) <SPC> and <SPC> dfs ( <NL>              root . right , <SPC> voyage , <SPC> i , <SPC> result <NL>          ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> return <SPC> result <SPC> if <SPC> dfs ( root , <SPC> voyage , <SPC> [ 0 ] , <SPC> result ) <SPC> else <SPC> [ - 1 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxEqualRowsAfterFlips ( self , <SPC> matrix ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( <NL>          tuple ( x <SPC> ^ <SPC> row [ 0 ] <SPC> for <SPC> x <SPC> in <SPC> row ) <SPC> for <SPC> row <SPC> in <SPC> matrix ) <NL> <TAB> return <SPC> max ( count . itervalues ( ) ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> flipEquiv ( self , <SPC> root1 , <SPC> root2 ) : <NL> <NL> <TAB> dq1 , <SPC> dq2 <SPC> = <SPC> collections . deque ( [ root1 ] ) , <SPC> collections . deque ( [ root2 ] ) <NL> <TAB> while <SPC> dq1 <SPC> and <SPC> dq2 : <NL>          node1 , <SPC> node2 <SPC> = <SPC> dq1 . pop ( ) , <SPC> dq2 . pop ( ) <NL>          if <SPC> not <SPC> node1 <SPC> and <SPC> not <SPC> node2 : <NL>              continue <NL>          if <SPC> not <SPC> node1 <SPC> or <SPC> not <SPC> node2 <SPC> or <SPC> node1 . val <SPC> != <SPC> node2 . val : <NL>              return <SPC> False <NL>          if <SPC> ( not <SPC> node1 . left <SPC> and <SPC> not <SPC> node2 . right ) <SPC> or <SPC> ( <NL>              node1 . left <SPC> and <SPC> node2 . right <SPC> and <SPC> node1 . left . val <SPC> == <SPC> node2 . right . val <NL>          ) : <NL>              dq1 . extend ( [ node1 . right , <SPC> node1 . left ] ) <NL>          else : <NL>              dq1 . extend ( [ node1 . left , <SPC> node1 . right ] ) <NL>          dq2 . extend ( [ node2 . left , <SPC> node2 . right ] ) <NL> <TAB> return <SPC> not <SPC> dq1 <SPC> and <SPC> not <SPC> dq2 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> flipEquiv ( self , <SPC> root1 , <SPC> root2 ) : <NL> <NL> <TAB> stk1 , <SPC> stk2 <SPC> = <SPC> [ root1 ] , <SPC> [ root2 ] <NL> <TAB> while <SPC> stk1 <SPC> and <SPC> stk2 : <NL>          node1 , <SPC> node2 <SPC> = <SPC> stk1 . pop ( ) , <SPC> stk2 . pop ( ) <NL>          if <SPC> not <SPC> node1 <SPC> and <SPC> not <SPC> node2 : <NL>              continue <NL>          if <SPC> not <SPC> node1 <SPC> or <SPC> not <SPC> node2 <SPC> or <SPC> node1 . val <SPC> != <SPC> node2 . val : <NL>              return <SPC> False <NL>          if <SPC> ( not <SPC> node1 . left <SPC> and <SPC> not <SPC> node2 . right ) <SPC> or <SPC> ( <NL>              node1 . left <SPC> and <SPC> node2 . right <SPC> and <SPC> node1 . left . val <SPC> == <SPC> node2 . right . val <NL>          ) : <NL>              stk1 . extend ( [ node1 . right , <SPC> node1 . left ] ) <NL>          else : <NL>              stk1 . extend ( [ node1 . left , <SPC> node1 . right ] ) <NL>          stk2 . extend ( [ node2 . left , <SPC> node2 . right ] ) <NL> <TAB> return <SPC> not <SPC> stk1 <SPC> and <SPC> not <SPC> stk2 <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> flipEquiv ( self , <SPC> root1 , <SPC> root2 ) : <NL> <NL> <TAB> if <SPC> not <SPC> root1 <SPC> and <SPC> not <SPC> root2 : <NL>          return <SPC> True <NL> <TAB> if <SPC> not <SPC> root1 <SPC> or <SPC> not <SPC> root2 <SPC> or <SPC> root1 . val <SPC> != <SPC> root2 . val : <NL>          return <SPC> False <NL> <NL> <TAB> return <SPC> ( <NL>          self . flipEquiv ( root1 . left , <SPC> root2 . left ) <NL>          and <SPC> self . flipEquiv ( root1 . right , <SPC> root2 . right ) <NL>          or <SPC> self . flipEquiv ( root1 . left , <SPC> root2 . right ) <NL>          and <SPC> self . flipEquiv ( root1 . right , <SPC> root2 . left ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> itertools <NL> import <SPC> re <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canWin ( self , <SPC> s ) : <NL> <TAB> g , <SPC> g_final <SPC> = <SPC> [ 0 ] , <SPC> 0 <NL> <TAB> for <SPC> p <SPC> in <SPC> itertools . imap ( len , <SPC> re . split ( "-+" , <SPC> s ) ) : <NL>          while <SPC> len ( g ) <SPC> <= <SPC> p : <NL> <NL>              g <SPC> += <SPC> ( <NL>                  min ( <NL>                      set ( xrange ( p ) ) <NL>                      - <SPC> { <NL>                          x <SPC> ^ <SPC> y <NL>                          for <SPC> x , <SPC> y <SPC> in <SPC> itertools . izip ( <NL>                              g [ : <SPC> len ( g ) <SPC> / <SPC> 2 ] , <SPC> g [ - 2 : <SPC> - len ( g ) <SPC> / <SPC> 2 <SPC> - <SPC> 2 : <SPC> - 1 ] <NL>                          ) <NL>                      } <NL>                  ) , <NL>              ) <NL>          g_final <SPC> ^= <SPC> g [ p ] <NL> <TAB> return <SPC> g_final <SPC> > <SPC> 0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> canWin ( self , <SPC> s ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> canWinHelper ( consecutives ) : <NL>          consecutives <SPC> = <SPC> tuple ( <NL>              sorted ( c <SPC> for <SPC> c <SPC> in <SPC> consecutives <SPC> if <SPC> c <SPC> >= <SPC> 2 ) <NL>          ) <NL>          if <SPC> consecutives <SPC> not <SPC> in <SPC> lookup : <NL>              lookup [ consecutives ] <SPC> = <SPC> any ( <NL>                  not <SPC> canWinHelper ( <NL>                      consecutives [ : i ] <SPC> + <SPC> ( j , <SPC> c <SPC> - <SPC> 2 <SPC> - <SPC> j ) <SPC> + <SPC> consecutives [ i <SPC> + <SPC> 1 : ] <NL>                  ) <NL>                  for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( consecutives ) <NL>                  for <SPC> j <SPC> in <SPC> xrange ( c <SPC> - <SPC> 1 ) <NL>              ) <NL>          return <SPC> lookup [ consecutives ] <NL> <NL> <TAB> return <SPC> canWinHelper ( map ( len , <SPC> re . findall ( r"\+\++" , <SPC> s ) ) ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> canWin ( self , <SPC> s ) : <NL> <NL> <TAB> i , <SPC> n <SPC> = <SPC> 0 , <SPC> len ( s ) <SPC> - <SPC> 1 <NL> <TAB> is_win <SPC> = <SPC> False <NL> <TAB> while <SPC> not <SPC> is_win <SPC> and <SPC> i <SPC> < <SPC> n : <NL>          if <SPC> s [ i ] <SPC> == <SPC> "+" : <NL>              while <SPC> not <SPC> is_win <SPC> and <SPC> i <SPC> < <SPC> n <SPC> and <SPC> s [ i <SPC> + <SPC> 1 ] <SPC> == <SPC> "+" : <NL> <NL>                  is_win <SPC> = <SPC> not <SPC> self . canWin ( s [ : i ] <SPC> + <SPC> "--" <SPC> + <SPC> s [ i <SPC> + <SPC> 2 : ] ) <NL>                  i <SPC> += <SPC> 1 <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> is_win <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> generatePossibleNextMoves ( self , <SPC> s ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> i , <SPC> n <SPC> = <SPC> 0 , <SPC> len ( s ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> n : <NL>          if <SPC> s [ i ] <SPC> == <SPC> "+" : <NL>              while <SPC> i <SPC> < <SPC> n <SPC> and <SPC> s [ i <SPC> + <SPC> 1 ] <SPC> == <SPC> "+" : <NL>                  res . append ( s [ : i ] <SPC> + <SPC> "--" <SPC> + <SPC> s [ i <SPC> + <SPC> 2 : ] ) <NL>                  i <SPC> += <SPC> 1 <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> generatePossibleNextMoves ( self , <SPC> s ) : <NL> <NL> <TAB> return <SPC> [ <NL>          s [ : i ] <SPC> + <SPC> "--" <SPC> + <SPC> s [ i <SPC> + <SPC> 2 : ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> - <SPC> 1 ) <NL>          if <SPC> s [ i : <SPC> i <SPC> + <SPC> 2 ] <SPC> == <SPC> "++" <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minFlipsMonoIncr ( self , <SPC> S ) : <NL> <NL> <TAB> flip0 , <SPC> flip1 <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          flip0 <SPC> += <SPC> int ( c <SPC> == <SPC> "1" ) <NL>          flip1 <SPC> = <SPC> min ( flip0 , <SPC> flip1 <SPC> + <SPC> int ( c <SPC> == <SPC> "0" ) ) <NL> <TAB> return <SPC> flip1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> flipAndInvertImage ( self , <SPC> A ) : <NL> <NL> <TAB> for <SPC> row <SPC> in <SPC> A : <NL>          for <SPC> i <SPC> in <SPC> xrange ( ( len ( row ) <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 ) : <NL>              row [ i ] , <SPC> row [ ~ i ] <SPC> = <SPC> row [ ~ i ] <SPC> ^ <SPC> 1 , <SPC> row [ i ] <SPC> ^ <SPC> 1 <NL> <TAB> return <SPC> A <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> floodFill ( self , <SPC> image , <SPC> sr , <SPC> sc , <SPC> newColor ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> dfs ( image , <SPC> r , <SPC> c , <SPC> newColor , <SPC> color ) : <NL>          if <SPC> not <SPC> ( <NL>              0 <SPC> <= <SPC> r <SPC> < <SPC> len ( image ) <SPC> and <SPC> 0 <SPC> <= <SPC> c <SPC> < <SPC> len ( <NL>                  image [ 0 ] ) <SPC> and <SPC> image [ r ] [ c ] <SPC> == <SPC> color <NL>          ) : <NL>              return <NL> <NL>          image [ r ] [ c ] <SPC> = <SPC> newColor <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              dfs ( image , <SPC> r <SPC> + <SPC> d [ 0 ] , <SPC> c <SPC> + <SPC> d [ 1 ] , <SPC> newColor , <SPC> color ) <NL> <NL> <TAB> color <SPC> = <SPC> image [ sr ] [ sc ] <NL> <TAB> if <SPC> color <SPC> == <SPC> newColor : <NL>          return <SPC> image <NL> <TAB> dfs ( image , <SPC> sr , <SPC> sc , <SPC> newColor , <SPC> color ) <NL> <TAB> return <SPC> image <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> gardenNoAdj ( self , <SPC> N , <SPC> paths ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> N <NL> <TAB> G <SPC> = <SPC> [ [ ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( N ) ] <NL> <TAB> for <SPC> x , <SPC> y <SPC> in <SPC> paths : <NL>          G [ x <SPC> - <SPC> 1 ] . append ( y <SPC> - <SPC> 1 ) <NL>          G [ y <SPC> - <SPC> 1 ] . append ( x <SPC> - <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N ) : <NL>          result [ i ] <SPC> = <SPC> ( { 1 , <SPC> 2 , <SPC> 3 , <SPC> 4 } <SPC> - <SPC> { result [ j ] <SPC> for <SPC> j <SPC> in <SPC> G [ i ] } ) . pop ( ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canChoose ( self , <SPC> groups , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> getPrefix ( pattern ) : <NL>          prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>              while <SPC> j <SPC> + <SPC> 1 <SPC> > <SPC> 0 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              prefix [ i ] <SPC> = <SPC> j <NL>          return <SPC> prefix <NL> <NL> <TAB> def <SPC> KMP ( text , <SPC> pattern , <SPC> start ) : <NL>          prefix <SPC> = <SPC> getPrefix ( pattern ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> len ( text ) ) : <NL>              while <SPC> j <SPC> + <SPC> 1 <SPC> > <SPC> 0 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> text [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> text [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              if <SPC> j <SPC> + <SPC> 1 <SPC> == <SPC> len ( pattern ) : <NL>                  return <SPC> i <SPC> - <SPC> j <NL>          return <SPC> - 1 <NL> <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <TAB> for <SPC> group <SPC> in <SPC> groups : <NL>          pos <SPC> = <SPC> KMP ( nums , <SPC> group , <SPC> pos ) <NL>          if <SPC> pos <SPC> == <SPC> - 1 : <NL>              return <SPC> False <NL>          pos <SPC> += <SPC> len ( group ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestNumber ( self , <SPC> cost , <SPC> target ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> t <SPC> in <SPC> xrange ( 1 , <SPC> target <SPC> + <SPC> 1 ) : <NL>          dp . append ( - 1 ) <NL>          for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( cost ) : <NL>              if <SPC> t <SPC> - <SPC> c <SPC> < <SPC> 0 <SPC> or <SPC> dp [ t <SPC> - <SPC> c ] <SPC> < <SPC> 0 : <NL>                  continue <NL>              dp [ t ] <SPC> = <SPC> max ( dp [ t ] , <SPC> dp [ t <SPC> - <SPC> c ] <SPC> + <SPC> 1 ) <NL> <TAB> if <SPC> dp [ target ] <SPC> < <SPC> 0 : <NL>          return <SPC> "0" <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 9 ) ) : <NL>          while <SPC> target <SPC> >= <SPC> cost [ i ] <SPC> and <SPC> dp [ target ] <SPC> == <SPC> dp [ target <SPC> - <SPC> cost [ i ] ] <SPC> + <SPC> 1 : <NL>              target <SPC> -= <SPC> cost [ i ] <NL>              result . append ( i <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> "" . join ( map ( str , <SPC> result ) ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> largestNumber ( self , <SPC> cost , <SPC> target ) : <NL> <NL> <TAB> def <SPC> key ( bag ) : <NL>          return <SPC> sum ( bag ) , <SPC> bag <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> 9 ] <NL> <TAB> for <SPC> t <SPC> in <SPC> xrange ( 1 , <SPC> target <SPC> + <SPC> 1 ) : <NL>          dp . append ( [ ] ) <NL>          for <SPC> d , <SPC> c <SPC> in <SPC> enumerate ( cost ) : <NL>              if <SPC> t <SPC> < <SPC> c <SPC> or <SPC> not <SPC> dp [ t <SPC> - <SPC> c ] : <NL>                  continue <NL>              curr <SPC> = <SPC> dp [ t <SPC> - <SPC> c ] [ : ] <NL>              curr [ ~ d ] <SPC> += <SPC> 1 <NL>              if <SPC> key ( curr ) <SPC> > <SPC> key ( dp [ t ] ) : <NL>                  dp [ - 1 ] <SPC> = <SPC> curr <NL> <TAB> if <SPC> not <SPC> dp [ - 1 ] : <NL>          return <SPC> "0" <NL> <TAB> return <SPC> "" . join ( str ( 9 <SPC> - <SPC> i ) <SPC> * <SPC> c <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( dp [ - 1 ] ) ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> largestNumber ( self , <SPC> cost , <SPC> target ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> t <SPC> in <SPC> xrange ( 1 , <SPC> target <SPC> + <SPC> 1 ) : <NL>          dp . append ( - 1 ) <NL>          for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( cost ) : <NL>              if <SPC> t <SPC> - <SPC> c <SPC> < <SPC> 0 : <NL>                  continue <NL>              dp [ t ] <SPC> = <SPC> max ( dp [ t ] , <SPC> dp [ t <SPC> - <SPC> c ] <SPC> * <SPC> 10 <SPC> + <SPC> i <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> str ( max ( dp [ t ] , <SPC> 0 ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumFourDivisors ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          facs , <SPC> i <SPC> = <SPC> [ ] , <SPC> 1 <NL>          while <SPC> i <SPC> * <SPC> i <SPC> <= <SPC> num : <NL>              if <SPC> num <SPC> % <SPC> i : <NL>                  i <SPC> += <SPC> 1 <NL>                  continue <NL>              facs . append ( i ) <NL>              if <SPC> i <SPC> != <SPC> num <SPC> // <SPC> i : <NL>                  facs . append ( num <SPC> // <SPC> i ) <NL>                  if <SPC> len ( facs ) <SPC> > <SPC> 4 : <NL>                      break <NL>              i <SPC> += <SPC> 1 <NL>          if <SPC> len ( facs ) <SPC> == <SPC> 4 : <NL>              result <SPC> += <SPC> sum ( facs ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> sumFourDivisors ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> factorize ( x ) : <NL>          result <SPC> = <SPC> [ ] <NL>          d <SPC> = <SPC> 2 <NL>          while <SPC> d <SPC> * <SPC> d <SPC> <= <SPC> x : <NL>              e <SPC> = <SPC> 0 <NL>              while <SPC> x <SPC> % <SPC> d <SPC> == <SPC> 0 : <NL>                  x <SPC> //= <SPC> d <NL>                  e <SPC> += <SPC> 1 <NL>              if <SPC> e : <NL>                  result . append ( [ d , <SPC> e ] ) <NL>              d <SPC> += <SPC> 1 <SPC> if <SPC> d <SPC> == <SPC> 2 <SPC> else <SPC> 2 <NL>          if <SPC> x <SPC> > <SPC> 1 : <NL>              result . append ( [ x , <SPC> 1 ] ) <NL>          return <SPC> result <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> facs <SPC> in <SPC> itertools . imap ( factorize , <SPC> nums ) : <NL>          if <SPC> len ( facs ) <SPC> == <SPC> 1 <SPC> and <SPC> facs [ 0 ] [ 1 ] <SPC> == <SPC> 3 : <NL>              p <SPC> = <SPC> facs [ 0 ] [ 0 ] <NL>              result <SPC> += <SPC> ( p <SPC> ** <SPC> 4 <SPC> - <SPC> 1 ) <SPC> // <SPC> ( p <SPC> - <SPC> 1 ) <NL>          elif <SPC> len ( facs ) <SPC> == <SPC> 2 <SPC> and <SPC> facs [ 0 ] [ 1 ] <SPC> == <SPC> facs [ 1 ] [ 1 ] <SPC> == <SPC> 1 : <NL>              p , <SPC> q <SPC> = <SPC> facs [ 0 ] [ 0 ] , <SPC> facs [ 1 ] [ 0 ] <NL>              result <SPC> += <SPC> ( 1 <SPC> + <SPC> p ) <SPC> * <SPC> ( 1 <SPC> + <SPC> q ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> re <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fractionAddition ( self , <SPC> expression ) : <NL> <NL> <TAB> def <SPC> gcd ( a , <SPC> b ) : <NL>          while <SPC> b : <NL>              a , <SPC> b <SPC> = <SPC> b , <SPC> a <SPC> % <SPC> b <NL>          return <SPC> a <NL> <NL> <TAB> ints <SPC> = <SPC> map ( int , <SPC> re . findall ( "[+-]?\d+" , <SPC> expression ) ) <NL> <TAB> A , <SPC> B <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 0 , <SPC> len ( ints ) , <SPC> 2 ) : <NL>          a , <SPC> b <SPC> = <SPC> ints [ i ] , <SPC> ints [ i <SPC> + <SPC> 1 ] <NL>          A <SPC> = <SPC> A <SPC> * <SPC> b <SPC> + <SPC> a <SPC> * <SPC> B <NL>          B <SPC> *= <SPC> b <NL>          g <SPC> = <SPC> gcd ( A , <SPC> B ) <NL>          A <SPC> //= <SPC> g <NL>          B <SPC> //= <SPC> g <NL> <TAB> return <SPC> "%d/%d" <SPC> % <SPC> ( A , <SPC> B ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fractionToDecimal ( self , <SPC> numerator , <SPC> denominator ) : <NL> <NL> <TAB> result <SPC> = <SPC> "" <NL> <TAB> if <SPC> ( numerator <SPC> > <SPC> 0 <SPC> and <SPC> denominator <SPC> < <SPC> 0 ) <SPC> or <SPC> ( numerator <SPC> < <SPC> 0 <SPC> and <SPC> denominator <SPC> > <SPC> 0 ) : <NL>          result <SPC> = <SPC> "-" <NL> <NL> <TAB> dvd , <SPC> dvs <SPC> = <SPC> abs ( numerator ) , <SPC> abs ( denominator ) <NL> <TAB> result <SPC> += <SPC> str ( dvd <SPC> / <SPC> dvs ) <NL> <TAB> dvd <SPC> %= <SPC> dvs <NL> <NL> <TAB> if <SPC> dvd <SPC> > <SPC> 0 : <NL>          result <SPC> += <SPC> "." <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> while <SPC> dvd <SPC> and <SPC> dvd <SPC> not <SPC> in <SPC> lookup : <NL>          lookup [ dvd ] <SPC> = <SPC> len ( result ) <NL>          dvd <SPC> *= <SPC> 10 <NL>          result <SPC> += <SPC> str ( dvd <SPC> / <SPC> dvs ) <NL>          dvd <SPC> %= <SPC> dvs <NL> <NL> <TAB> if <SPC> dvd <SPC> in <SPC> lookup : <NL>          result <SPC> = <SPC> result [ : <SPC> lookup [ dvd ] ] <SPC> + <SPC> "(" <SPC> + <SPC> result [ lookup [ dvd ] : ] <SPC> + <SPC> ")" <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findRotateSteps ( self , <SPC> ring , <SPC> key ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( ring ) ) : <NL>          lookup [ ring [ i ] ] . append ( i ) <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( ring ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> prev <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( key ) <SPC> + <SPC> 1 ) : <NL>          dp [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> [ float ( "inf" ) ] <SPC> * <SPC> len ( ring ) <NL>          for <SPC> j <SPC> in <SPC> lookup [ key [ i <SPC> - <SPC> 1 ] ] : <NL>              for <SPC> k <SPC> in <SPC> prev : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> min ( <NL>                      dp [ i <SPC> % <SPC> 2 ] [ j ] , <NL>                      min ( <NL>                          ( k <SPC> + <SPC> len ( ring ) <SPC> - <SPC> j ) <SPC> % <SPC> len ( ring ) , <NL>                          ( j <SPC> + <SPC> len ( ring ) <SPC> - <SPC> k ) <SPC> % <SPC> len ( ring ) , <NL>                      ) <NL>                      + <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ k ] , <NL>                  ) <NL>          prev <SPC> = <SPC> lookup [ key [ i <SPC> - <SPC> 1 ] ] <NL> <TAB> return <SPC> min ( dp [ len ( key ) <SPC> % <SPC> 2 ] ) <SPC> + <SPC> len ( key ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findCircleNum ( self , <SPC> M ) : <NL> <NL> <TAB> class <SPC> UnionFind ( object ) : <NL>          def <SPC> __init__ ( self , <SPC> n ) : <NL>              self . set <SPC> = <SPC> range ( n ) <NL>              self . count <SPC> = <SPC> n <NL> <NL>          def <SPC> find_set ( self , <SPC> x ) : <NL>              if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>                  self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL>              return <SPC> self . set [ x ] <NL> <NL>          def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL>              x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL>              if <SPC> x_root <SPC> != <SPC> y_root : <NL>                  self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL>                  self . count <SPC> -= <SPC> 1 <NL> <NL> <TAB> circles <SPC> = <SPC> UnionFind ( len ( M ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( M ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( M ) ) : <NL>              if <SPC> M [ i ] [ j ] <SPC> and <SPC> i <SPC> != <SPC> j : <NL>                  circles . union_set ( i , <SPC> j ) <NL> <TAB> return <SPC> circles . count <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numFriendRequests ( self , <SPC> ages ) : <NL> <NL> <TAB> def <SPC> request ( a , <SPC> b ) : <NL>          return <SPC> 0.5 <SPC> * <SPC> a <SPC> + <SPC> 7 <SPC> < <SPC> b <SPC> <= <SPC> a <NL> <NL> <TAB> c <SPC> = <SPC> collections . Counter ( ages ) <NL> <TAB> return <SPC> sum ( <NL>          int ( request ( a , <SPC> b ) ) <SPC> * <SPC> c [ a ] <SPC> * <SPC> ( c [ b ] <SPC> - <SPC> int ( a <SPC> == <SPC> b ) ) <SPC> for <SPC> a <SPC> in <SPC> c <SPC> for <SPC> b <SPC> in <SPC> c <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canCross ( self , <SPC> stones ) : <NL> <NL> <TAB> if <SPC> stones [ 1 ] <SPC> != <SPC> 1 : <NL>          return <SPC> False <NL> <NL> <TAB> last_jump_units <SPC> = <SPC> { s : <SPC> set ( ) <SPC> for <SPC> s <SPC> in <SPC> stones } <NL> <TAB> last_jump_units [ 1 ] . add ( 1 ) <NL> <TAB> for <SPC> s <SPC> in <SPC> stones [ : - 1 ] : <NL>          for <SPC> j <SPC> in <SPC> last_jump_units [ s ] : <NL>              for <SPC> k <SPC> in <SPC> ( j <SPC> - <SPC> 1 , <SPC> j , <SPC> j <SPC> + <SPC> 1 ) : <NL>                  if <SPC> k <SPC> > <SPC> 0 <SPC> and <SPC> s <SPC> + <SPC> k <SPC> in <SPC> last_jump_units : <NL>                      last_jump_units [ s <SPC> + <SPC> k ] . add ( k ) <NL> <TAB> return <SPC> bool ( last_jump_units [ stones [ - 1 ] ] ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> frogPosition ( self , <SPC> n , <SPC> edges , <SPC> t , <SPC> target ) : <NL> <NL> <TAB> G <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          G [ u ] . append ( v ) <NL>          G [ v ] . append ( u ) <NL> <NL> <TAB> stk <SPC> = <SPC> [ ( t , <SPC> 1 , <SPC> 0 , <SPC> 1 ) ] <NL> <TAB> while <SPC> stk : <NL>          new_stk <SPC> = <SPC> [ ] <NL>          while <SPC> stk : <NL>              t , <SPC> node , <SPC> parent , <SPC> choices <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> not <SPC> t <SPC> or <SPC> not <SPC> ( len ( G [ node ] ) <SPC> - <SPC> ( parent <SPC> != <SPC> 0 ) ) : <NL>                  if <SPC> node <SPC> == <SPC> target : <NL>                      return <SPC> 1.0 <SPC> / <SPC> choices <NL>                  continue <NL>              for <SPC> child <SPC> in <SPC> G [ node ] : <NL>                  if <SPC> child <SPC> == <SPC> parent : <NL>                      continue <NL>                  new_stk . append ( <NL>                      ( t <SPC> - <SPC> 1 , <SPC> child , <SPC> node , <SPC> choices <SPC> * <NL>                       ( len ( G [ node ] ) <SPC> - <SPC> ( parent <SPC> != <SPC> 0 ) ) ) <NL>                  ) <NL>          stk <SPC> = <SPC> new_stk <NL> <TAB> return <SPC> 0.0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> frogPosition ( self , <SPC> n , <SPC> edges , <SPC> t , <SPC> target ) : <NL> <NL> <TAB> G <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          G [ u ] . append ( v ) <NL>          G [ v ] . append ( u ) <NL> <NL> <TAB> stk <SPC> = <SPC> [ ( t , <SPC> 1 , <SPC> 0 , <SPC> 1 ) ] <NL> <TAB> while <SPC> stk : <NL>          t , <SPC> node , <SPC> parent , <SPC> choices <SPC> = <SPC> stk . pop ( ) <NL>          if <SPC> not <SPC> t <SPC> or <SPC> not <SPC> ( len ( G [ node ] ) <SPC> - <SPC> ( parent <SPC> != <SPC> 0 ) ) : <NL>              if <SPC> node <SPC> == <SPC> target : <NL>                  return <SPC> 1.0 <SPC> / <SPC> choices <NL>              continue <NL>          for <SPC> child <SPC> in <SPC> G [ node ] : <NL>              if <SPC> child <SPC> == <SPC> parent : <NL>                  continue <NL>              stk . append ( <NL>                  ( t <SPC> - <SPC> 1 , <SPC> child , <SPC> node , <SPC> choices <SPC> * <SPC> ( len ( G [ node ] ) <SPC> - <SPC> ( parent <SPC> != <SPC> 0 ) ) ) <NL>              ) <NL> <TAB> return <SPC> 0.0 <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> frogPosition ( self , <SPC> n , <SPC> edges , <SPC> t , <SPC> target ) : <NL> <NL> <TAB> def <SPC> dfs ( G , <SPC> target , <SPC> t , <SPC> node , <SPC> parent ) : <NL>          if <SPC> not <SPC> t <SPC> or <SPC> not <SPC> ( len ( G [ node ] ) <SPC> - <SPC> ( parent <SPC> != <SPC> 0 ) ) : <NL>              return <SPC> int ( node <SPC> == <SPC> target ) <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> child <SPC> in <SPC> G [ node ] : <NL>              if <SPC> child <SPC> == <SPC> parent : <NL>                  continue <NL>              result <SPC> = <SPC> dfs ( G , <SPC> target , <SPC> t <SPC> - <SPC> 1 , <SPC> child , <SPC> node ) <NL>              if <SPC> result : <NL>                  break <NL>          return <SPC> result <SPC> * <SPC> ( len ( G [ node ] ) <SPC> - <SPC> ( parent <SPC> != <SPC> 0 ) ) <NL> <NL> <TAB> G <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          G [ u ] . append ( v ) <NL>          G [ v ] . append ( u ) <NL> <TAB> choices <SPC> = <SPC> dfs ( G , <SPC> target , <SPC> t , <SPC> 1 , <SPC> 0 ) <NL> <TAB> return <SPC> 1.0 <SPC> / <SPC> choices <SPC> if <SPC> choices <SPC> else <SPC> 0.0 <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> frogPosition ( self , <SPC> n , <SPC> edges , <SPC> t , <SPC> target ) : <NL> <NL> <TAB> def <SPC> dfs ( G , <SPC> target , <SPC> t , <SPC> node , <SPC> parent ) : <NL>          if <SPC> not <SPC> t <SPC> or <SPC> not <SPC> ( len ( G [ node ] ) <SPC> - <SPC> ( parent <SPC> != <SPC> 0 ) ) : <NL>              return <SPC> float ( node <SPC> == <SPC> target ) <NL>          for <SPC> child <SPC> in <SPC> G [ node ] : <NL>              if <SPC> child <SPC> == <SPC> parent : <NL>                  continue <NL>              result <SPC> = <SPC> dfs ( G , <SPC> target , <SPC> t <SPC> - <SPC> 1 , <SPC> child , <SPC> node ) <NL>              if <SPC> result : <NL>                  break <NL>          return <SPC> result <SPC> / <SPC> ( len ( G [ node ] ) <SPC> - <SPC> ( parent <SPC> != <SPC> 0 ) ) <NL> <NL> <TAB> G <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          G [ u ] . append ( v ) <NL>          G [ v ] . append ( u ) <NL> <TAB> return <SPC> dfs ( G , <SPC> target , <SPC> t , <SPC> 1 , <SPC> 0 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> totalFruit ( self , <SPC> tree ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> result , <SPC> i <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> j , <SPC> v <SPC> in <SPC> enumerate ( tree ) : <NL>          count [ v ] <SPC> += <SPC> 1 <NL>          while <SPC> len ( count ) <SPC> > <SPC> 2 : <NL>              count [ tree [ i ] ] <SPC> -= <SPC> 1 <NL>              if <SPC> count [ tree [ i ] ] <SPC> == <SPC> 0 : <NL>                  del <SPC> count [ tree [ i ] ] <NL>              i <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> max ( result , <SPC> j <SPC> - <SPC> i <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> furthestBuilding ( self , <SPC> heights , <SPC> bricks , <SPC> ladders ) : <NL> <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( heights ) <SPC> - <SPC> 1 ) : <NL>          diff <SPC> = <SPC> heights [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> heights [ i ] <NL>          if <SPC> diff <SPC> > <SPC> 0 : <NL>              heapq . heappush ( min_heap , <SPC> diff ) <NL>          if <SPC> len ( min_heap ) <SPC> <= <SPC> ladders : <NL>              continue <NL>          bricks <SPC> -= <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> bricks <SPC> < <SPC> 0 : <NL>              return <SPC> i <NL> <TAB> return <SPC> len ( heights ) <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> gameOfLife ( self , <SPC> board ) : <NL> <NL> <TAB> m <SPC> = <SPC> len ( board ) <NL> <TAB> n <SPC> = <SPC> len ( board [ 0 ] ) <SPC> if <SPC> m <SPC> else <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              count <SPC> = <SPC> 0 <NL> <NL>              for <SPC> I <SPC> in <SPC> xrange ( max ( i <SPC> - <SPC> 1 , <SPC> 0 ) , <SPC> min ( i <SPC> + <SPC> 2 , <SPC> m ) ) : <NL>                  for <SPC> J <SPC> in <SPC> xrange ( max ( j <SPC> - <SPC> 1 , <SPC> 0 ) , <SPC> min ( j <SPC> + <SPC> 2 , <SPC> n ) ) : <NL>                      count <SPC> += <SPC> board [ I ] [ J ] <SPC> & <SPC> 1 <NL> <NL>              if <SPC> ( count <SPC> == <SPC> 4 <SPC> and <SPC> board [ i ] [ j ] ) <SPC> or <SPC> count <SPC> == <SPC> 3 : <NL>                  board [ i ] [ j ] <SPC> |= <SPC> 2 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              board [ i ] [ j ] <SPC> >>= <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> canCompleteCircuit ( self , <SPC> gas , <SPC> cost ) : <NL> <TAB> start , <SPC> total_sum , <SPC> current_sum <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( gas ) ) : <NL>          diff <SPC> = <SPC> gas [ i ] <SPC> - <SPC> cost [ i ] <NL>          current_sum <SPC> += <SPC> diff <NL>          total_sum <SPC> += <SPC> diff <NL>          if <SPC> current_sum <SPC> < <SPC> 0 : <NL>              start <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>              current_sum <SPC> = <SPC> 0 <NL> <TAB> if <SPC> total_sum <SPC> >= <SPC> 0 : <NL>          return <SPC> start <NL> <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> generateAbbreviations ( self , <SPC> word ) : <NL> <NL> <TAB> def <SPC> generateAbbreviationsHelper ( word , <SPC> i , <SPC> cur , <SPC> res ) : <NL>          if <SPC> i <SPC> == <SPC> len ( word ) : <NL>              res . append ( "" . join ( cur ) ) <NL>              return <NL>          cur . append ( word [ i ] ) <NL>          generateAbbreviationsHelper ( word , <SPC> i <SPC> + <SPC> 1 , <SPC> cur , <SPC> res ) <NL>          cur . pop ( ) <NL>          if <SPC> not <SPC> cur <SPC> or <SPC> not <SPC> cur [ - 1 ] [ - 1 ] . isdigit ( ) : <NL>              for <SPC> l <SPC> in <SPC> xrange ( 1 , <SPC> len ( word ) <SPC> - <SPC> i <SPC> + <SPC> 1 ) : <NL>                  cur . append ( str ( l ) ) <NL>                  generateAbbreviationsHelper ( word , <SPC> i <SPC> + <SPC> l , <SPC> cur , <SPC> res ) <NL>                  cur . pop ( ) <NL> <NL> <TAB> res , <SPC> cur <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> generateAbbreviationsHelper ( word , <SPC> 0 , <SPC> cur , <SPC> res ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> generateTheString ( self , <SPC> n ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ "a" ] <SPC> * <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> result . append ( "a" <SPC> if <SPC> n <SPC> % <SPC> 2 <SPC> else <SPC> "b" ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> generateParenthesis ( self , <SPC> n ) : <NL> <NL> <TAB> result , <SPC> curr <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> stk <SPC> = <SPC> [ ( 1 , <SPC> ( n , <SPC> n ) ) ] <NL> <TAB> while <SPC> stk : <NL>          step , <SPC> args <SPC> = <SPC> stk . pop ( ) <NL>          if <SPC> step <SPC> == <SPC> 1 : <NL>              left , <SPC> right <SPC> = <SPC> args <NL>              if <SPC> left <SPC> == <SPC> 0 <SPC> and <SPC> right <SPC> == <SPC> 0 : <NL>                  result . append ( "" . join ( curr ) ) <NL>              if <SPC> left <SPC> < <SPC> right : <NL>                  stk . append ( ( 3 , <SPC> tuple ( ) ) ) <NL>                  stk . append ( ( 1 , <SPC> ( left , <SPC> right <SPC> - <SPC> 1 ) ) ) <NL>                  stk . append ( ( 2 , <SPC> ( ")" ) ) ) <NL>              if <SPC> left <SPC> > <SPC> 0 : <NL>                  stk . append ( ( 3 , <SPC> tuple ( ) ) ) <NL>                  stk . append ( ( 1 , <SPC> ( left <SPC> - <SPC> 1 , <SPC> right ) ) ) <NL>                  stk . append ( ( 2 , <SPC> ( "(" ) ) ) <NL>          elif <SPC> step <SPC> == <SPC> 2 : <NL>              curr . append ( args [ 0 ] ) <NL>          elif <SPC> step <SPC> == <SPC> 3 : <NL>              curr . pop ( ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> generateParenthesis ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> generateParenthesisRecu ( left , <SPC> right , <SPC> curr , <SPC> result ) : <NL>          if <SPC> left <SPC> == <SPC> 0 <SPC> and <SPC> right <SPC> == <SPC> 0 : <NL>              result . append ( "" . join ( curr ) ) <NL>          if <SPC> left <SPC> > <SPC> 0 : <NL>              curr . append ( "(" ) <NL>              generateParenthesisRecu ( left <SPC> - <SPC> 1 , <SPC> right , <SPC> curr , <SPC> result ) <NL>              curr . pop ( ) <NL>          if <SPC> left <SPC> < <SPC> right : <NL>              curr . append ( ")" ) <NL>              generateParenthesisRecu ( left , <SPC> right <SPC> - <SPC> 1 , <SPC> curr , <SPC> result ) <NL>              curr . pop ( ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> generateParenthesisRecu ( n , <SPC> n , <SPC> [ ] , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> random <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> radius , <SPC> x_center , <SPC> y_center ) : <NL> <NL> <TAB> self . __radius <SPC> = <SPC> radius <NL> <TAB> self . __x_center <SPC> = <SPC> x_center <NL> <TAB> self . __y_center <SPC> = <SPC> y_center <NL> <NL> <TAB> def <SPC> randPoint ( self ) : <NL> <NL> <TAB> r <SPC> = <SPC> ( self . __radius ) <SPC> * <SPC> math . sqrt ( random . uniform ( 0 , <SPC> 1 ) ) <NL> <TAB> theta <SPC> = <SPC> ( 2 <SPC> * <SPC> math . pi ) <SPC> * <SPC> random . uniform ( 0 , <SPC> 1 ) <NL> <TAB> return <SPC> ( <NL>          r <SPC> * <SPC> math . cos ( theta ) <SPC> + <SPC> self . __x_center , <NL>          r <SPC> * <SPC> math . sin ( theta ) <SPC> + <SPC> self . __y_center , <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> equalSubstring ( self , <SPC> s , <SPC> t , <SPC> maxCost ) : <NL> <NL> <TAB> left <SPC> = <SPC> 0 <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          maxCost <SPC> -= <SPC> abs ( ord ( s [ right ] ) <SPC> - <SPC> ord ( t [ right ] ) ) <NL>          if <SPC> maxCost <SPC> < <SPC> 0 : <NL>              maxCost <SPC> += <SPC> abs ( ord ( s [ left ] ) <SPC> - <SPC> ord ( t [ left ] ) ) <NL>              left <SPC> += <SPC> 1 <NL> <TAB> return <SPC> ( right <SPC> + <SPC> 1 ) <SPC> - <SPC> left <NL> <NL> <NL> nums <SPC> = <SPC> [ 0 , <SPC> 1 ] <NL> dp <SPC> = <SPC> [ 0 , <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getMaximumGenerated ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> + <SPC> 1 <SPC> > <SPC> len ( dp ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) , <SPC> n <SPC> + <SPC> 1 ) : <NL>              if <SPC> i <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>                  nums . append ( nums [ i <SPC> // <SPC> 2 ] ) <NL>              else : <NL>                  nums . append ( nums [ i <SPC> // <SPC> 2 ] <SPC> + <SPC> nums [ i <SPC> // <SPC> 2 <SPC> + <SPC> 1 ] ) <NL>              dp . append ( max ( dp [ - 1 ] , <SPC> nums [ - 1 ] ) ) <NL> <TAB> return <SPC> dp [ n ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> getMaximumGenerated ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> nums <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> nums [ 1 ] <SPC> = <SPC> 1 <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          if <SPC> i <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              nums [ i ] <SPC> = <SPC> nums [ i <SPC> // <SPC> 2 ] <NL>          else : <NL>              nums [ i ] <SPC> = <SPC> nums [ i <SPC> // <SPC> 2 ] <SPC> + <SPC> nums [ i <SPC> // <SPC> 2 <SPC> + <SPC> 1 ] <NL>          result <SPC> = <SPC> max ( result , <SPC> nums [ i ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSum ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> result , <SPC> sum1 , <SPC> sum2 <SPC> = <SPC> ( <NL>          0 , <NL>          0 , <NL>          0 , <NL> <TAB> ) <NL> <TAB> while <SPC> i <SPC> != <SPC> len ( nums1 ) <SPC> or <SPC> j <SPC> != <SPC> len ( nums2 ) : <NL>          if <SPC> i <SPC> != <SPC> len ( nums1 ) <SPC> and <SPC> ( j <SPC> == <SPC> len ( nums2 ) <SPC> or <SPC> nums1 [ i ] <SPC> < <SPC> nums2 [ j ] ) : <NL>              sum1 <SPC> += <SPC> nums1 [ i ] <NL>              i <SPC> += <SPC> 1 <NL>          elif <SPC> j <SPC> != <SPC> len ( nums2 ) <SPC> and <SPC> ( i <SPC> == <SPC> len ( nums1 ) <SPC> or <SPC> nums1 [ i ] <SPC> > <SPC> nums2 [ j ] ) : <NL>              sum2 <SPC> += <SPC> nums2 [ j ] <NL>              j <SPC> += <SPC> 1 <NL>          else : <NL>              result <SPC> = <SPC> ( result <SPC> + <SPC> ( max ( sum1 , <SPC> sum2 ) <SPC> + <SPC> nums1 [ i ] ) ) <SPC> % <SPC> MOD <NL>              sum1 , <SPC> sum2 <SPC> = <SPC> 0 , <SPC> 0 <NL>              i <SPC> += <SPC> 1 <NL>              j <SPC> += <SPC> 1 <NL> <TAB> return <SPC> ( result <SPC> + <SPC> max ( sum1 , <SPC> sum2 ) ) <SPC> % <SPC> MOD <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> watchedVideosByFriends ( self , <SPC> watchedVideos , <SPC> friends , <SPC> id , <SPC> level ) : <NL> <NL> <TAB> curr_level , <SPC> lookup <SPC> = <SPC> set ( [ id ] ) , <SPC> set ( [ id ] ) <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( level ) : <NL>          curr_level <SPC> = <SPC> set ( <NL>              j <SPC> for <SPC> i <SPC> in <SPC> curr_level <SPC> for <SPC> j <SPC> in <SPC> friends [ i ] <SPC> if <SPC> j <SPC> not <SPC> in <SPC> lookup <NL>          ) <NL>          lookup <SPC> |= <SPC> curr_level <NL> <TAB> count <SPC> = <SPC> collections . Counter ( <NL>          [ v <SPC> for <SPC> i <SPC> in <SPC> curr_level <SPC> for <SPC> v <SPC> in <SPC> watchedVideos [ i ] ] ) <NL> <TAB> return <SPC> sorted ( count . keys ( ) , <SPC> key = lambda <SPC> x : <SPC> ( count [ x ] , <SPC> x ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isIdealPermutation ( self , <SPC> A ) : <NL> <NL> <TAB> return <SPC> all ( abs ( v <SPC> - <SPC> i ) <SPC> <= <SPC> 1 <SPC> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( A ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> interpret ( self , <SPC> command ) : <NL> <NL> <TAB> result , <SPC> i <SPC> = <SPC> [ ] , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( command ) : <NL>          if <SPC> command [ i ] <SPC> == <SPC> "G" : <NL>              result <SPC> += <SPC> [ "G" ] <NL>              i <SPC> += <SPC> 1 <NL>          elif <SPC> command [ i ] <SPC> == <SPC> "(" <SPC> and <SPC> command [ i <SPC> + <SPC> 1 ] <SPC> == <SPC> ")" : <NL>              result <SPC> += <SPC> [ "o" ] <NL>              i <SPC> += <SPC> 2 <NL>          else : <NL>              result <SPC> += <SPC> [ "al" ] <NL>              i <SPC> += <SPC> 4 <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> toGoatLatin ( self , <SPC> S ) : <NL> <NL> <TAB> def <SPC> convert ( S ) : <NL>          vowel <SPC> = <SPC> set ( "aeiouAEIOU" ) <NL>          for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( S . split ( ) , <SPC> 1 ) : <NL>              if <SPC> word [ 0 ] <SPC> not <SPC> in <SPC> vowel : <NL>                  word <SPC> = <SPC> word [ 1 : ] <SPC> + <SPC> word [ : 1 ] <NL>              yield <SPC> word <SPC> + <SPC> "ma" <SPC> + <SPC> "a" <SPC> * <SPC> i <NL> <NL> <TAB> return <SPC> " " . join ( convert ( S ) ) <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . rank <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          stk . append ( x ) <NL>          x <SPC> = <SPC> self . set [ x ] <NL> <TAB> while <SPC> stk : <NL>          self . set [ stk . pop ( ) ] <SPC> = <SPC> x <NL> <TAB> return <SPC> x <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> if <SPC> self . rank [ x_root ] <SPC> < <SPC> self . rank [ y_root ] : <NL>          self . set [ x_root ] <SPC> = <SPC> y_root <NL> <TAB> elif <SPC> self . rank [ x_root ] <SPC> > <SPC> self . rank [ y_root ] : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL> <TAB> else : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL>          self . rank [ x_root ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> areConnected ( self , <SPC> n , <SPC> threshold , <SPC> queries ) : <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( n ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( threshold <SPC> + <SPC> 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL> <NL>          for <SPC> j <SPC> in <SPC> xrange ( 2 <SPC> * <SPC> i , <SPC> n <SPC> + <SPC> 1 , <SPC> i ) : <NL>              union_find . union_set ( i <SPC> - <SPC> 1 , <SPC> j <SPC> - <SPC> 1 ) <NL> <TAB> return <SPC> [ <NL>          union_find . find_set ( q [ 0 ] <SPC> - <SPC> 1 ) <SPC> == <SPC> union_find . find_set ( q [ 1 ] <SPC> - <SPC> 1 ) <NL>          for <SPC> q <SPC> in <SPC> queries <NL> <TAB> ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> validTree ( self , <SPC> n , <SPC> edges ) : <NL> <TAB> if <SPC> len ( edges ) <SPC> != <SPC> n <SPC> - <SPC> 1 : <NL>          return <SPC> False <NL> <NL> <TAB> neighbors <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          neighbors [ u ] . append ( v ) <NL>          neighbors [ v ] . append ( u ) <NL> <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ 0 ] ) <NL> <TAB> visited <SPC> = <SPC> set ( [ 0 ] ) <NL> <TAB> while <SPC> q : <NL>          curr <SPC> = <SPC> q . popleft ( ) <NL>          for <SPC> node <SPC> in <SPC> neighbors [ curr ] : <NL>              if <SPC> node <SPC> not <SPC> in <SPC> visited : <NL>                  visited . add ( node ) <NL>                  q . append ( node ) <NL> <NL> <TAB> return <SPC> len ( visited ) <SPC> == <SPC> n <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> validTree ( self , <SPC> n , <SPC> edges ) : <NL> <NL> <TAB> visited_from <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> n <NL> <TAB> neighbors <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          neighbors [ u ] . append ( v ) <NL>          neighbors [ v ] . append ( u ) <NL> <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ 0 ] ) <NL> <TAB> visited <SPC> = <SPC> set ( [ 0 ] ) <NL> <TAB> while <SPC> q : <NL>          i <SPC> = <SPC> q . popleft ( ) <NL>          for <SPC> node <SPC> in <SPC> neighbors [ i ] : <NL>              if <SPC> node <SPC> != <SPC> visited_from [ i ] : <NL>                  if <SPC> node <SPC> in <SPC> visited : <NL>                      return <SPC> False <NL>                  else : <NL>                      visited . add ( node ) <NL>                      visited_from [ node ] <SPC> = <SPC> i <NL>                      q . append ( node ) <NL> <TAB> return <SPC> len ( visited ) <SPC> == <SPC> n <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> grayCode ( self , <SPC> n ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          for <SPC> n <SPC> in <SPC> reversed ( result ) : <NL>              result . append ( 1 <SPC> << <SPC> i <SPC> | <SPC> n ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> grayCode ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> [ i <SPC> >> <SPC> 1 <SPC> ^ <SPC> i <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 <SPC> << <SPC> n ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> gcdOfStrings ( self , <SPC> str1 , <SPC> str2 ) : <NL> <NL> <TAB> def <SPC> check ( s , <SPC> common ) : <NL>          i <SPC> = <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> s : <NL>              if <SPC> c <SPC> != <SPC> common [ i ] : <NL>                  return <SPC> False <NL>              i <SPC> = <SPC> ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> len ( common ) <NL>          return <SPC> True <NL> <NL> <TAB> def <SPC> gcd ( a , <SPC> b ) : <NL>          while <SPC> b : <NL>              a , <SPC> b <SPC> = <SPC> b , <SPC> a <SPC> % <SPC> b <NL>          return <SPC> a <NL> <NL> <TAB> if <SPC> not <SPC> str1 <SPC> or <SPC> not <SPC> str2 : <NL>          return <SPC> "" <NL> <TAB> c <SPC> = <SPC> gcd ( len ( str1 ) , <SPC> len ( str2 ) ) <NL> <TAB> result <SPC> = <SPC> str1 [ : c ] <NL> <TAB> return <SPC> result <SPC> if <SPC> check ( str1 , <SPC> result ) <SPC> and <SPC> check ( str2 , <SPC> result ) <SPC> else <SPC> "" <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSumDivThree ( self , <SPC> nums ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 , <SPC> 0 , <SPC> 0 ] <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          for <SPC> i <SPC> in <SPC> [ num <SPC> + <SPC> x <SPC> for <SPC> x <SPC> in <SPC> dp ] : <NL>              dp [ i <SPC> % <SPC> 3 ] <SPC> = <SPC> max ( dp [ i <SPC> % <SPC> 3 ] , <SPC> i ) <NL> <TAB> return <SPC> dp [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> gridIllumination ( self , <SPC> N , <SPC> lamps , <SPC> queries ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ <NL>          ( 0 , <SPC> - 1 ) , <NL>          ( 0 , <SPC> 1 ) , <NL>          ( - 1 , <SPC> 0 ) , <NL>          ( 1 , <SPC> 0 ) , <NL>          ( - 1 , <SPC> - 1 ) , <NL>          ( 1 , <SPC> - 1 ) , <NL>          ( 1 , <SPC> - 1 ) , <NL>          ( 1 , <SPC> 1 ) , <NL> <TAB> ] <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> row <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> col <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> diag <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> anti <SPC> = <SPC> collections . defaultdict ( int ) <NL> <NL> <TAB> for <SPC> r , <SPC> c <SPC> in <SPC> lamps : <NL>          lookup . add ( ( r , <SPC> c ) ) <NL>          row [ r ] <SPC> += <SPC> 1 <NL>          col [ c ] <SPC> += <SPC> 1 <NL>          diag [ r <SPC> - <SPC> c ] <SPC> += <SPC> 1 <NL>          anti [ r <SPC> + <SPC> c ] <SPC> += <SPC> 1 <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> r , <SPC> c <SPC> in <SPC> queries : <NL>          if <SPC> row [ r ] <SPC> or <SPC> col [ c ] <SPC> or <SPC> diag [ r <SPC> - <SPC> c ] <SPC> or <SPC> anti [ r <SPC> + <SPC> c ] : <NL>              result . append ( 1 ) <NL>          else : <NL>              result . append ( 0 ) <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              nc , <SPC> nr <SPC> = <SPC> r <SPC> + <SPC> d [ 0 ] , <SPC> c <SPC> + <SPC> d [ 1 ] <NL>              if <SPC> not <SPC> ( 0 <SPC> <= <SPC> nr <SPC> < <SPC> N <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> N <SPC> and <SPC> ( nr , <SPC> nc ) <SPC> in <SPC> lookup ) : <NL>                  continue <NL>              lookup . remove ( ( nr , <SPC> nc ) ) <NL>              row [ nr ] <SPC> -= <SPC> 1 <NL>              col [ nc ] <SPC> -= <SPC> 1 <NL>              diag [ nr <SPC> - <SPC> nc ] <SPC> -= <SPC> 1 <NL>              anti [ nr <SPC> + <SPC> nc ] <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> groupAnagrams ( self , <SPC> strs ) : <NL> <NL> <TAB> anagrams_map , <SPC> result <SPC> = <SPC> collections . defaultdict ( list ) , <SPC> [ ] <NL> <TAB> for <SPC> s <SPC> in <SPC> strs : <NL>          sorted_str <SPC> = <SPC> ( "" ) . join ( sorted ( s ) ) <NL>          anagrams_map [ sorted_str ] . append ( s ) <NL> <TAB> for <SPC> anagram <SPC> in <SPC> anagrams_map . values ( ) : <NL>          anagram . sort ( ) <NL>          result . append ( anagram ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> groupStrings ( self , <SPC> strings ) : <NL> <TAB> groups <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> s <SPC> in <SPC> strings : <NL>          groups [ self . hashStr ( s ) ] . append ( s ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> key , <SPC> val <SPC> in <SPC> groups . iteritems ( ) : <NL>          result . append ( sorted ( val ) ) <NL> <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> hashStr ( self , <SPC> s ) : <NL> <TAB> base <SPC> = <SPC> ord ( s [ 0 ] ) <NL> <TAB> hashcode <SPC> = <SPC> "" <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> ord ( s [ i ] ) <SPC> - <SPC> base <SPC> >= <SPC> 0 : <NL>              hashcode <SPC> += <SPC> unichr ( ord ( "a" ) <SPC> + <SPC> ord ( s [ i ] ) <SPC> - <SPC> base ) <NL>          else : <NL>              hashcode <SPC> += <SPC> unichr ( ord ( "a" ) <SPC> + <SPC> ord ( s [ i ] ) <SPC> - <SPC> base <SPC> + <SPC> 26 ) <NL> <TAB> return <SPC> hashcode <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> groupThePeople ( self , <SPC> groupSizes ) : <NL> <NL> <TAB> groups , <SPC> result <SPC> = <SPC> collections . defaultdict ( list ) , <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> size <SPC> in <SPC> enumerate ( groupSizes ) : <NL>          groups [ size ] . append ( i ) <NL>          if <SPC> len ( groups [ size ] ) <SPC> == <SPC> size : <NL>              result . append ( groups . pop ( size ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSpecialEquivGroups ( self , <SPC> A ) : <NL> <NL> <TAB> def <SPC> count ( word ) : <NL>          result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 52 <NL>          for <SPC> i , <SPC> letter <SPC> in <SPC> enumerate ( word ) : <NL>              result [ ord ( letter ) <SPC> - <SPC> ord ( "a" ) <SPC> + <SPC> 26 <SPC> * <SPC> ( i <SPC> % <SPC> 2 ) ] <SPC> += <SPC> 1 <NL>          return <SPC> tuple ( result ) <NL> <NL> <TAB> return <SPC> len ( { count ( word ) <SPC> for <SPC> word <SPC> in <SPC> A } ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSatisfied ( self , <SPC> customers , <SPC> grumpy , <SPC> X ) : <NL> <NL> <TAB> result , <SPC> max_extra , <SPC> extra <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( customers ) ) : <NL>          result <SPC> += <SPC> 0 <SPC> if <SPC> grumpy [ i ] <SPC> else <SPC> customers [ i ] <NL>          extra <SPC> += <SPC> customers [ i ] <SPC> if <SPC> grumpy [ i ] <SPC> else <SPC> 0 <NL>          if <SPC> i <SPC> >= <SPC> X : <NL>              extra <SPC> -= <SPC> customers [ i <SPC> - <SPC> X ] <SPC> if <SPC> grumpy [ i <SPC> - <SPC> X ] <SPC> else <SPC> 0 <NL>          max_extra <SPC> = <SPC> max ( max_extra , <SPC> extra ) <NL> <TAB> return <SPC> result <SPC> + <SPC> max_extra <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getMoneyAmount ( self , <SPC> n ) : <NL> <NL> <TAB> pay <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( n ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> n ) : <NL>              pay [ i ] [ j ] <SPC> = <SPC> min ( <NL>                  k <SPC> + <SPC> 1 <SPC> + <SPC> max ( pay [ i ] [ k <SPC> - <SPC> 1 ] , <SPC> pay [ k <SPC> + <SPC> 1 ] [ j ] ) <SPC> for <SPC> k <SPC> in <SPC> xrange ( i , <SPC> j <SPC> + <SPC> 1 ) <NL>              ) <NL> <TAB> return <SPC> pay [ 0 ] [ n <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> guessNumber ( self , <SPC> n ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> n <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> guess ( mid ) <SPC> <= <SPC> 0 : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> ArrayReader ( object ) : <NL> <TAB> def <SPC> query ( self , <SPC> a , <SPC> b , <SPC> c , <SPC> d ) : <NL> <NL> <TAB> pass <NL> <NL> <TAB> def <SPC> length ( self ) : <NL> <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> guessMajority ( self , <SPC> reader ) : <NL> <NL> <TAB> count_a , <SPC> count_b , <SPC> idx_b <SPC> = <SPC> 1 , <SPC> 0 , <SPC> None <NL> <TAB> value_0_1_2_3 <SPC> = <SPC> reader . query ( 0 , <SPC> 1 , <SPC> 2 , <SPC> 3 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 4 , <SPC> reader . length ( ) ) ) : <NL>          value_0_1_2_i <SPC> = <SPC> reader . query ( 0 , <SPC> 1 , <SPC> 2 , <SPC> i ) <NL>          if <SPC> value_0_1_2_i <SPC> == <SPC> value_0_1_2_3 : <NL>              count_a <SPC> = <SPC> count_a <SPC> + <SPC> 1 <NL>          else : <NL>              count_b , <SPC> idx_b <SPC> = <SPC> count_b <SPC> + <SPC> 1 , <SPC> i <NL> <TAB> value_0_1_2_4 <SPC> = <SPC> value_0_1_2_i <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 3 ) : <NL>          value_a_b_3_4 <SPC> = <SPC> reader . query ( * [ v <SPC> for <SPC> v <SPC> in <SPC> [ 0 , <SPC> 1 , <SPC> 2 , <SPC> 3 , <SPC> 4 ] <SPC> if <SPC> v <SPC> != <SPC> i ] ) <NL>          if <SPC> value_a_b_3_4 <SPC> == <SPC> value_0_1_2_4 : <NL>              count_a <SPC> = <SPC> count_a <SPC> + <SPC> 1 <NL>          else : <NL>              count_b , <SPC> idx_b <SPC> = <SPC> count_b <SPC> + <SPC> 1 , <SPC> i <NL> <TAB> if <SPC> count_a <SPC> == <SPC> count_b : <NL>          return <SPC> - 1 <NL> <TAB> return <SPC> 3 <SPC> if <SPC> count_a <SPC> > <SPC> count_b <SPC> else <SPC> idx_b <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findSecretWord ( self , <SPC> wordlist , <SPC> master ) : <NL> <NL> <TAB> possible <SPC> = <SPC> range ( len ( wordlist ) ) <NL> <TAB> n <SPC> = <SPC> 0 <NL> <TAB> while <SPC> n <SPC> < <SPC> 6 : <NL>          count <SPC> = <SPC> [ collections . Counter ( w [ i ] <SPC> for <SPC> w <SPC> in <SPC> wordlist ) <NL>                   for <SPC> i <SPC> in <SPC> xrange ( 6 ) ] <NL>          guess <SPC> = <SPC> max ( <NL>              possible , <NL>              key = lambda <SPC> x : <SPC> sum ( count [ i ] [ c ] <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( wordlist [ x ] ) ) , <NL>          ) <NL>          n <SPC> = <SPC> master . guess ( wordlist [ guess ] ) <NL>          possible <SPC> = <SPC> [ <NL>              j <NL>              for <SPC> j <SPC> in <SPC> possible <NL>              if <SPC> sum ( a <SPC> == <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( wordlist [ guess ] , <SPC> wordlist [ j ] ) ) <NL>              == <SPC> n <NL>          ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findSecretWord ( self , <SPC> wordlist , <SPC> master ) : <NL> <NL> <TAB> def <SPC> solve ( H , <SPC> possible ) : <NL>          min_max_group , <SPC> best_guess <SPC> = <SPC> possible , <SPC> None <NL>          for <SPC> guess <SPC> in <SPC> possible : <NL>              groups <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 7 ) ] <NL>              for <SPC> j <SPC> in <SPC> possible : <NL>                  if <SPC> j <SPC> != <SPC> guess : <NL>                      groups [ H [ guess ] [ j ] ] . append ( j ) <NL>              max_group <SPC> = <SPC> max ( groups , <SPC> key = len ) <NL>              if <SPC> len ( max_group ) <SPC> < <SPC> len ( min_max_group ) : <NL>                  min_max_group , <SPC> best_guess <SPC> = <SPC> max_group , <SPC> guess <NL>          return <SPC> best_guess <NL> <NL> <TAB> H <SPC> = <SPC> [ <NL>          [ <NL>              sum ( a <SPC> == <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( wordlist [ i ] , <SPC> wordlist [ j ] ) ) <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( wordlist ) ) <NL>          ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( wordlist ) ) <NL> <TAB> ] <NL> <TAB> possible <SPC> = <SPC> range ( len ( wordlist ) ) <NL> <TAB> n <SPC> = <SPC> 0 <NL> <TAB> while <SPC> n <SPC> < <SPC> 6 : <NL>          guess <SPC> = <SPC> solve ( H , <SPC> possible ) <NL>          n <SPC> = <SPC> master . guess ( wordlist [ guess ] ) <NL>          possible <SPC> = <SPC> [ j <SPC> for <SPC> j <SPC> in <SPC> possible <SPC> if <SPC> H [ guess ] [ j ] <SPC> == <SPC> n ] <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> findSecretWord ( self , <SPC> wordlist , <SPC> master ) : <NL> <NL> <TAB> def <SPC> solve ( H , <SPC> possible ) : <NL>          min_max_group , <SPC> best_guess <SPC> = <SPC> possible , <SPC> None <NL>          for <SPC> guess <SPC> in <SPC> possible : <NL>              groups <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 7 ) ] <NL>              for <SPC> j <SPC> in <SPC> possible : <NL>                  if <SPC> j <SPC> != <SPC> guess : <NL>                      groups [ H [ guess ] [ j ] ] . append ( j ) <NL>              max_group <SPC> = <SPC> groups [ 0 ] <NL>              if <SPC> len ( max_group ) <SPC> < <SPC> len ( min_max_group ) : <NL>                  min_max_group , <SPC> best_guess <SPC> = <SPC> max_group , <SPC> guess <NL>          return <SPC> best_guess <NL> <NL> <TAB> H <SPC> = <SPC> [ <NL>          [ <NL>              sum ( a <SPC> == <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( wordlist [ i ] , <SPC> wordlist [ j ] ) ) <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( wordlist ) ) <NL>          ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( wordlist ) ) <NL> <TAB> ] <NL> <TAB> possible <SPC> = <SPC> range ( len ( wordlist ) ) <NL> <TAB> n <SPC> = <SPC> 0 <NL> <TAB> while <SPC> n <SPC> < <SPC> 6 : <NL>          guess <SPC> = <SPC> solve ( H , <SPC> possible ) <NL>          n <SPC> = <SPC> master . guess ( wordlist [ guess ] ) <NL>          possible <SPC> = <SPC> [ j <SPC> for <SPC> j <SPC> in <SPC> possible <SPC> if <SPC> H [ guess ] [ j ] <SPC> == <SPC> n ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> hIndex ( self , <SPC> citations ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( citations ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> n <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> ( left <SPC> + <SPC> right ) <SPC> / <SPC> 2 <NL>          if <SPC> citations [ mid ] <SPC> >= <SPC> n <SPC> - <SPC> mid : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> n <SPC> - <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> hIndex ( self , <SPC> citations ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( citations ) <NL> <TAB> count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> x <SPC> in <SPC> citations : <NL> <NL>          if <SPC> x <SPC> >= <SPC> n : <NL>              count [ n ] <SPC> += <SPC> 1 <NL>          else : <NL>              count [ x ] <SPC> += <SPC> 1 <NL> <NL> <TAB> h <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 0 , <SPC> n <SPC> + <SPC> 1 ) ) : <NL>          h <SPC> += <SPC> count [ i ] <NL>          if <SPC> h <SPC> >= <SPC> i : <NL>              return <SPC> i <NL> <TAB> return <SPC> h <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> hIndex ( self , <SPC> citations ) : <NL> <NL> <TAB> citations . sort ( reverse = True ) <NL> <TAB> h <SPC> = <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> citations : <NL>          if <SPC> x <SPC> >= <SPC> h <SPC> + <SPC> 1 : <NL>              h <SPC> += <SPC> 1 <NL>          else : <NL>              break <NL> <TAB> return <SPC> h <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> hIndex ( self , <SPC> citations ) : <NL> <NL> <TAB> return <SPC> sum ( x <SPC> >= <SPC> i <SPC> + <SPC> 1 <SPC> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( sorted ( citations , <SPC> reverse = True ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> hammingDistance ( self , <SPC> x , <SPC> y ) : <NL> <NL> <TAB> distance <SPC> = <SPC> 0 <NL> <TAB> z <SPC> = <SPC> x <SPC> ^ <SPC> y <NL> <TAB> while <SPC> z : <NL>          distance <SPC> += <SPC> 1 <NL>          z <SPC> &= <SPC> z <SPC> - <SPC> 1 <NL> <TAB> return <SPC> distance <NL> <NL> <TAB> def <SPC> hammingDistance2 ( self , <SPC> x , <SPC> y ) : <NL> <NL> <TAB> return <SPC> bin ( x <SPC> ^ <SPC> y ) . count ( "1" ) <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> Counter <NL> from <SPC> heapq <SPC> import <SPC> heapify , <SPC> heappop <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isNStraightHand ( self , <SPC> hand , <SPC> W ) : <NL> <NL> <TAB> if <SPC> len ( hand ) <SPC> % <SPC> W : <NL>          return <SPC> False <NL> <NL> <TAB> counts <SPC> = <SPC> Counter ( hand ) <NL> <TAB> min_heap <SPC> = <SPC> list ( hand ) <NL> <TAB> heapify ( min_heap ) <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( len ( min_heap ) <SPC> // <SPC> W ) : <NL>          while <SPC> counts [ min_heap [ 0 ] ] <SPC> == <SPC> 0 : <NL>              heappop ( min_heap ) <NL>          start <SPC> = <SPC> heappop ( min_heap ) <NL>          for <SPC> _ <SPC> in <SPC> xrange ( W ) : <NL>              counts [ start ] <SPC> -= <SPC> 1 <NL>              if <SPC> counts [ start ] <SPC> < <SPC> 0 : <NL>                  return <SPC> False <NL>              start <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfWays ( self , <SPC> num_people ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> def <SPC> inv ( x , <SPC> m ) : <NL>          return <SPC> pow ( x , <SPC> m <SPC> - <SPC> 2 , <SPC> m ) <NL> <NL> <TAB> def <SPC> nCr ( n , <SPC> k , <SPC> m ) : <NL>          if <SPC> n <SPC> - <SPC> k <SPC> < <SPC> k : <NL>              return <SPC> nCr ( n , <SPC> n <SPC> - <SPC> k , <SPC> m ) <NL>          result <SPC> = <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> k <SPC> + <SPC> 1 ) : <NL>              result <SPC> = <SPC> result <SPC> * <SPC> ( n <SPC> - <SPC> k <SPC> + <SPC> i ) <SPC> * <SPC> inv ( i , <SPC> m ) <SPC> % <SPC> m <NL>          return <SPC> result <NL> <NL> <TAB> n <SPC> = <SPC> num_people <SPC> // <SPC> 2 <NL> <TAB> return <SPC> nCr ( 2 <SPC> * <SPC> n , <SPC> n , <SPC> MOD ) <SPC> * <SPC> inv ( n <SPC> + <SPC> 1 , <SPC> MOD ) <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numberOfWays ( self , <SPC> num_people ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( num_people <SPC> // <SPC> 2 <SPC> + <SPC> 1 ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> num_people <SPC> // <SPC> 2 <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( k ) : <NL>              dp [ k ] <SPC> = <SPC> ( dp [ k ] <SPC> + <SPC> dp [ i ] <SPC> * <SPC> dp [ k <SPC> - <SPC> 1 <SPC> - <SPC> i ] ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> dp [ num_people <SPC> // <SPC> 2 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isHappy ( self , <SPC> n ) : <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> while <SPC> n <SPC> != <SPC> 1 <SPC> and <SPC> n <SPC> not <SPC> in <SPC> lookup : <NL>          lookup [ n ] <SPC> = <SPC> True <NL>          n <SPC> = <SPC> self . nextNumber ( n ) <NL> <TAB> return <SPC> n <SPC> == <SPC> 1 <NL> <NL> <TAB> def <SPC> nextNumber ( self , <SPC> n ) : <NL> <TAB> new <SPC> = <SPC> 0 <NL> <TAB> for <SPC> char <SPC> in <SPC> str ( n ) : <NL>          new <SPC> += <SPC> int ( char ) <SPC> ** <SPC> 2 <NL> <TAB> return <SPC> new <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findRadius ( self , <SPC> houses , <SPC> heaters ) : <NL> <NL> <TAB> heaters . sort ( ) <NL> <TAB> min_radius <SPC> = <SPC> 0 <NL> <TAB> for <SPC> house <SPC> in <SPC> houses : <NL>          equal_or_larger <SPC> = <SPC> bisect . bisect_left ( heaters , <SPC> house ) <NL>          curr_radius <SPC> = <SPC> float ( "inf" ) <NL>          if <SPC> equal_or_larger <SPC> != <SPC> len ( heaters ) : <NL>              curr_radius <SPC> = <SPC> heaters [ equal_or_larger ] <SPC> - <SPC> house <NL>          if <SPC> equal_or_larger <SPC> != <SPC> 0 : <NL>              smaller <SPC> = <SPC> equal_or_larger <SPC> - <SPC> 1 <NL>              curr_radius <SPC> = <SPC> min ( curr_radius , <SPC> house <SPC> - <SPC> heaters [ smaller ] ) <NL>          min_radius <SPC> = <SPC> max ( min_radius , <SPC> curr_radius ) <NL> <TAB> return <SPC> min_radius <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> heightChecker ( self , <SPC> heights ) : <NL> <NL> <TAB> return <SPC> sum ( i <SPC> != <SPC> j <SPC> for <SPC> i , <SPC> j <SPC> in <SPC> itertools . izip ( heights , <SPC> sorted ( heights ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> toHexspeak ( self , <SPC> num ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { 0 : <SPC> "O" , <SPC> 1 : <SPC> "I" } <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 6 ) : <NL>          lookup [ 10 <SPC> + <SPC> i ] <SPC> = <SPC> chr ( ord ( "A" ) <SPC> + <SPC> i ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> n <SPC> = <SPC> int ( num ) <NL> <TAB> while <SPC> n : <NL>          n , <SPC> r <SPC> = <SPC> divmod ( n , <SPC> 16 ) <NL>          if <SPC> r <SPC> not <SPC> in <SPC> lookup : <NL>              return <SPC> "ERROR" <NL>          result . append ( lookup [ r ] ) <NL> <TAB> return <SPC> "" . join ( reversed ( result ) ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> toHexspeak ( self , <SPC> num ) : <NL> <NL> <TAB> result <SPC> = <SPC> hex ( int ( num ) ) . upper ( ) [ 2 : ] . replace ( "0" , <SPC> "O" ) . replace ( "1" , <SPC> "I" ) <NL> <TAB> return <SPC> result <SPC> if <SPC> all ( c <SPC> in <SPC> "ABCDEFOI" <SPC> for <SPC> c <SPC> in <SPC> result ) <SPC> else <SPC> "ERROR" <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> highFive ( self , <SPC> items ) : <NL> <NL> <TAB> min_heaps <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> val <SPC> in <SPC> items : <NL>          heapq . heappush ( min_heaps [ i ] , <SPC> val ) <NL>          if <SPC> len ( min_heaps [ i ] ) <SPC> > <SPC> 5 : <NL>              heapq . heappop ( min_heaps [ i ] ) <NL> <TAB> return <SPC> [ [ i , <SPC> sum ( min_heaps [ i ] ) <SPC> // <SPC> len ( min_heaps [ i ] ) ] <SPC> for <SPC> i <SPC> in <SPC> sorted ( min_heaps ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> rob ( self , <SPC> nums ) : <NL> <TAB> if <SPC> len ( nums ) <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <NL> <TAB> if <SPC> len ( nums ) <SPC> == <SPC> 1 : <NL>          return <SPC> nums [ 0 ] <NL> <NL> <TAB> return <SPC> max ( <NL>          self . robRange ( nums , <SPC> 0 , <SPC> len ( nums ) <SPC> - <NL>                        1 ) , <SPC> self . robRange ( nums , <SPC> 1 , <SPC> len ( nums ) ) <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> robRange ( self , <SPC> nums , <SPC> start , <SPC> end ) : <NL> <TAB> num_i , <SPC> num_i_1 <SPC> = <SPC> nums [ start ] , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( start <SPC> + <SPC> 1 , <SPC> end ) : <NL>          num_i_1 , <SPC> num_i_2 <SPC> = <SPC> num_i , <SPC> num_i_1 <NL>          num_i <SPC> = <SPC> max ( nums [ i ] <SPC> + <SPC> num_i_2 , <SPC> num_i_1 ) <NL> <NL> <TAB> return <SPC> num_i <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rob ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> robHelper ( root ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> ( 0 , <SPC> 0 ) <NL>          left , <SPC> right <SPC> = <SPC> robHelper ( root . left ) , <SPC> robHelper ( root . right ) <NL>          return <SPC> ( root . val <SPC> + <SPC> left [ 1 ] <SPC> + <SPC> right [ 1 ] , <SPC> max ( left ) <SPC> + <SPC> max ( right ) ) <NL> <NL> <TAB> return <SPC> max ( robHelper ( root ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> rob ( self , <SPC> nums ) : <NL> <NL> <TAB> last , <SPC> now <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> nums : <NL>          last , <SPC> now <SPC> = <SPC> now , <SPC> max ( last <SPC> + <SPC> i , <SPC> now ) <NL> <TAB> return <SPC> now <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxNumberOfApples ( self , <SPC> arr ) : <NL> <NL> <TAB> LIMIT <SPC> = <SPC> 5000 <NL> <TAB> arr . sort ( ) <NL> <TAB> result , <SPC> total <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> arr : <NL>          if <SPC> total <SPC> + <SPC> x <SPC> > <SPC> LIMIT : <NL>              break <NL>          total <SPC> += <SPC> x <NL>          result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallerNumbersThanCurrent ( self , <SPC> nums ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( nums ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( max ( nums ) <SPC> + <SPC> 1 ) : <NL>          count [ i ] <SPC> += <SPC> count [ i <SPC> - <SPC> 1 ] <NL> <TAB> return <SPC> [ count [ i <SPC> - <SPC> 1 ] <SPC> for <SPC> i <SPC> in <SPC> nums ] <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> smallerNumbersThanCurrent ( self , <SPC> nums ) : <NL> <NL> <TAB> sorted_nums <SPC> = <SPC> sorted ( nums ) <NL> <TAB> return <SPC> [ bisect . bisect_left ( sorted_nums , <SPC> i ) <SPC> for <SPC> i <SPC> in <SPC> nums ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> AhoNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . children <SPC> = <SPC> collections . defaultdict ( AhoNode ) <NL> <TAB> self . indices <SPC> = <SPC> [ ] <NL> <TAB> self . suffix <SPC> = <SPC> None <NL> <TAB> self . output <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> AhoTrie ( object ) : <NL> <TAB> def <SPC> step ( self , <SPC> letter ) : <NL> <TAB> while <SPC> self . __node <SPC> and <SPC> letter <SPC> not <SPC> in <SPC> self . __node . children : <NL>          self . __node <SPC> = <SPC> self . __node . suffix <NL> <TAB> self . __node <SPC> = <SPC> self . __node . children [ letter ] <SPC> if <SPC> self . __node <SPC> else <SPC> self . __root <NL> <TAB> return <SPC> self . __get_ac_node_outputs ( self . __node ) <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> patterns ) : <NL> <TAB> self . __root <SPC> = <SPC> self . __create_ac_trie ( patterns ) <NL> <TAB> self . __node <SPC> = <SPC> self . __create_ac_suffix_and_output_links ( self . __root ) <NL> <NL> <TAB> def <SPC> __create_ac_trie ( self , <SPC> patterns ) : <NL> <TAB> root <SPC> = <SPC> AhoNode ( ) <NL> <TAB> for <SPC> i , <SPC> pattern <SPC> in <SPC> enumerate ( patterns ) : <NL>          node <SPC> = <SPC> root <NL>          for <SPC> c <SPC> in <SPC> pattern : <NL>              node <SPC> = <SPC> node . children [ c ] <NL>          node . indices . append ( i ) <NL> <TAB> return <SPC> root <NL> <NL> <TAB> def <SPC> __create_ac_suffix_and_output_links ( self , <SPC> root ) : <NL> <TAB> queue <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> node <SPC> in <SPC> root . children . itervalues ( ) : <NL>          queue . append ( node ) <NL>          node . suffix <SPC> = <SPC> root <NL> <NL> <TAB> while <SPC> queue : <NL>          node <SPC> = <SPC> queue . popleft ( ) <NL>          for <SPC> c , <SPC> child <SPC> in <SPC> node . children . iteritems ( ) : <NL>              queue . append ( child ) <NL>              suffix <SPC> = <SPC> node . suffix <NL>              while <SPC> suffix <SPC> and <SPC> c <SPC> not <SPC> in <SPC> suffix . children : <NL>                  suffix <SPC> = <SPC> suffix . suffix <NL>              child . suffix <SPC> = <SPC> suffix . children [ c ] <SPC> if <SPC> suffix <SPC> else <SPC> root <NL>              child . output <SPC> = <SPC> ( <NL>                  child . suffix <SPC> if <SPC> child . suffix . indices <SPC> else <SPC> child . suffix . output <NL>              ) <NL> <NL> <TAB> return <SPC> root <NL> <NL> <TAB> def <SPC> __get_ac_node_outputs ( self , <SPC> node ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> node . indices : <NL>          result . append ( i ) <NL> <TAB> output <SPC> = <SPC> node . output <NL> <TAB> while <SPC> output : <NL>          for <SPC> i <SPC> in <SPC> output . indices : <NL>              result . append ( i ) <NL>          output <SPC> = <SPC> output . output <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> entityParser ( self , <SPC> text ) : <NL> <NL> <TAB> patterns <SPC> = <SPC> [ "&quot;" , <SPC> "&apos;" , <SPC> "&amp;" , <SPC> "&gt;" , <SPC> "&lt;" , <SPC> "&frasl;" ] <NL> <TAB> chars <SPC> = <SPC> [ '"' , <SPC> "'" , <SPC> "&" , <SPC> ">" , <SPC> "<" , <SPC> "/" ] <NL> <TAB> trie <SPC> = <SPC> AhoTrie ( patterns ) <NL> <TAB> positions <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( text ) ) : <NL>          for <SPC> j <SPC> in <SPC> trie . step ( text [ i ] ) : <NL>              positions . append ( [ i <SPC> - <SPC> len ( patterns [ j ] ) <SPC> + <SPC> 1 , <SPC> j ] ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> != <SPC> len ( text ) : <NL>          if <SPC> j <SPC> == <SPC> len ( positions ) <SPC> or <SPC> i <SPC> != <SPC> positions [ j ] [ 0 ] : <NL>              result . append ( text [ i ] ) <NL>              i <SPC> += <SPC> 1 <NL>          else : <NL>              result . append ( chars [ positions [ j ] [ 1 ] ] ) <NL>              i <SPC> += <SPC> len ( patterns [ positions [ j ] [ 1 ] ] ) <NL>              j <SPC> += <SPC> 1 <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> entityParser ( self , <SPC> text ) : <NL> <NL> <TAB> patterns <SPC> = <SPC> [ "&quot;" , <SPC> "&apos;" , <SPC> "&amp;" , <SPC> "&gt;" , <SPC> "&lt;" , <SPC> "&frasl;" ] <NL> <TAB> chars <SPC> = <SPC> [ '"' , <SPC> "'" , <SPC> "&" , <SPC> ">" , <SPC> "<" , <SPC> "/" ] <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> != <SPC> len ( text ) : <NL>          if <SPC> text [ i ] <SPC> != <SPC> "&" : <NL>              result . append ( text [ i ] ) <NL>              i <SPC> += <SPC> 1 <NL>          else : <NL>              for <SPC> j , <SPC> pattern <SPC> in <SPC> enumerate ( patterns ) : <NL>                  if <SPC> pattern <SPC> == <SPC> text [ i : <SPC> i <SPC> + <SPC> len ( pattern ) ] : <NL>                      result . append ( chars [ j ] ) <NL>                      i <SPC> += <SPC> len ( pattern ) <NL>                      break <NL>              else : <NL>                  result . append ( text [ i ] ) <NL>                  i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestOverlap ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 2 <SPC> * <SPC> len ( A ) <SPC> - <SPC> 1 ) <SPC> ** <SPC> 2 <NL> <TAB> for <SPC> i , <SPC> row <SPC> in <SPC> enumerate ( A ) : <NL>          for <SPC> j , <SPC> v <SPC> in <SPC> enumerate ( row ) : <NL>              if <SPC> not <SPC> v : <NL>                  continue <NL>              for <SPC> i2 , <SPC> row2 <SPC> in <SPC> enumerate ( B ) : <NL>                  for <SPC> j2 , <SPC> v2 <SPC> in <SPC> enumerate ( row2 ) : <NL>                      if <SPC> not <SPC> v2 : <NL>                          continue <NL>                      count [ <NL>                          ( len ( A ) <SPC> - <SPC> 1 <SPC> + <SPC> i <SPC> - <SPC> i2 ) <SPC> * <SPC> ( 2 <SPC> * <SPC> len ( A ) <SPC> - <SPC> 1 ) <NL>                          + <SPC> len ( A ) <NL>                          - <SPC> 1 <NL>                          + <SPC> j <NL>                          - <SPC> j2 <NL>                      ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> max ( count ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> imageSmoother ( self , <SPC> M ) : <NL> <NL> <TAB> def <SPC> getGray ( M , <SPC> i , <SPC> j ) : <NL>          total , <SPC> count <SPC> = <SPC> 0 , <SPC> 0.0 <NL>          for <SPC> r <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) : <NL>              for <SPC> c <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) : <NL>                  ii , <SPC> jj <SPC> = <SPC> i <SPC> + <SPC> r , <SPC> j <SPC> + <SPC> c <NL>                  if <SPC> 0 <SPC> <= <SPC> ii <SPC> < <SPC> len ( M ) <SPC> and <SPC> 0 <SPC> <= <SPC> jj <SPC> < <SPC> len ( M [ 0 ] ) : <NL>                      total <SPC> += <SPC> M [ ii ] [ jj ] <NL>                      count <SPC> += <SPC> 1.0 <NL>          return <SPC> int ( total <SPC> / <SPC> count ) <NL> <NL> <TAB> result <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( M [ 0 ] ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( M ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( M ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( M [ 0 ] ) ) : <NL>              result [ i ] [ j ] <SPC> = <SPC> getGray ( M , <SPC> i , <SPC> j ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> MagicDictionary ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> self . trie <SPC> = <SPC> _trie ( ) <NL> <NL> <TAB> def <SPC> buildDict ( self , <SPC> dictionary ) : <NL> <NL> <TAB> for <SPC> word <SPC> in <SPC> dictionary : <NL>          reduce ( dict . __getitem__ , <SPC> word , <SPC> self . trie ) . setdefault ( "_end" ) <NL> <NL> <TAB> def <SPC> search ( self , <SPC> word ) : <NL> <NL> <TAB> def <SPC> find ( word , <SPC> curr , <SPC> i , <SPC> mistakeAllowed ) : <NL>          if <SPC> i <SPC> == <SPC> len ( word ) : <NL>              return <SPC> "_end" <SPC> in <SPC> curr <SPC> and <SPC> not <SPC> mistakeAllowed <NL> <NL>          if <SPC> word [ i ] <SPC> not <SPC> in <SPC> curr : <NL>              return <SPC> ( <NL>                  any ( find ( word , <SPC> curr [ c ] , <SPC> i <SPC> + <SPC> 1 , <SPC> False ) <NL>                      for <SPC> c <SPC> in <SPC> curr <SPC> if <SPC> c <SPC> != <SPC> "_end" ) <NL>                  if <SPC> mistakeAllowed <NL>                  else <SPC> False <NL>              ) <NL> <NL>          if <SPC> mistakeAllowed : <NL>              return <SPC> find ( word , <SPC> curr [ word [ i ] ] , <SPC> i <SPC> + <SPC> 1 , <SPC> True ) <SPC> or <SPC> any ( <NL>                  find ( word , <SPC> curr [ c ] , <SPC> i <SPC> + <SPC> 1 , <SPC> False ) <NL>                  for <SPC> c <SPC> in <SPC> curr <NL>                  if <SPC> c <SPC> not <SPC> in <SPC> ( "_end" , <SPC> word [ i ] ) <NL>              ) <NL>          return <SPC> find ( word , <SPC> curr [ word [ i ] ] , <SPC> i <SPC> + <SPC> 1 , <SPC> False ) <NL> <NL> <TAB> return <SPC> find ( word , <SPC> self . trie , <SPC> 0 , <SPC> True ) <NL> <NL> <NL> class <SPC> Queue ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . A , <SPC> self . B <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <TAB> self . A . append ( x ) <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <TAB> self . peek ( ) <NL> <TAB> return <SPC> self . B . pop ( ) <NL> <NL> <TAB> def <SPC> peek ( self ) : <NL> <TAB> if <SPC> not <SPC> self . B : <NL>          while <SPC> self . A : <NL>              self . B . append ( self . A . pop ( ) ) <NL> <TAB> return <SPC> self . B [ - 1 ] <NL> <NL> <TAB> def <SPC> empty ( self ) : <NL> <TAB> return <SPC> not <SPC> self . A <SPC> and <SPC> not <SPC> self . B <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> def <SPC> rand7 ( ) : <NL> <TAB> return <SPC> random . randint ( 1 , <SPC> 7 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __cache <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> rand10 ( self ) : <NL> <NL> <TAB> def <SPC> generate ( cache ) : <NL>          n <SPC> = <SPC> 32 <NL>          curr <SPC> = <SPC> sum ( ( rand7 ( ) <SPC> - <SPC> 1 ) <SPC> * <SPC> ( 7 <SPC> ** <SPC> i ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( n ) ) <NL>          rang <SPC> = <SPC> 7 <SPC> ** <SPC> n <NL>          while <SPC> curr <SPC> < <SPC> rang <SPC> // <SPC> 10 <SPC> * <SPC> 10 : <NL>              cache . append ( curr <SPC> % <SPC> 10 <SPC> + <SPC> 1 ) <NL>              curr <SPC> /= <SPC> 10 <NL>              rang <SPC> /= <SPC> 10 <NL> <NL> <TAB> while <SPC> not <SPC> self . __cache : <NL>          generate ( self . __cache ) <NL> <TAB> return <SPC> self . __cache . pop ( ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> rand10 ( self ) : <NL> <NL> <TAB> while <SPC> True : <NL>          x <SPC> = <SPC> ( rand7 ( ) <SPC> - <SPC> 1 ) <SPC> * <SPC> 7 <SPC> + <SPC> ( rand7 ( ) <SPC> - <SPC> 1 ) <NL>          if <SPC> x <SPC> < <SPC> 40 : <NL>              return <SPC> x <SPC> % <SPC> 10 <SPC> + <SPC> 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Queue ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . data <SPC> = <SPC> collections . deque ( ) <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <TAB> self . data . append ( x ) <NL> <NL> <TAB> def <SPC> peek ( self ) : <NL> <TAB> return <SPC> self . data [ 0 ] <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <TAB> return <SPC> self . data . popleft ( ) <NL> <NL> <TAB> def <SPC> size ( self ) : <NL> <TAB> return <SPC> len ( self . data ) <NL> <NL> <TAB> def <SPC> empty ( self ) : <NL> <TAB> return <SPC> len ( self . data ) <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Stack ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . q_ <SPC> = <SPC> Queue ( ) <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <TAB> self . q_ . push ( x ) <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( self . q_ . size ( ) <SPC> - <SPC> 1 ) : <NL>          self . q_ . push ( self . q_ . pop ( ) ) <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <TAB> self . q_ . pop ( ) <NL> <NL> <TAB> def <SPC> top ( self ) : <NL> <TAB> return <SPC> self . q_ . peek ( ) <NL> <NL> <TAB> def <SPC> empty ( self ) : <NL> <TAB> return <SPC> self . q_ . empty ( ) <NL> <NL> <NL> class <SPC> Stack2 ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . q_ <SPC> = <SPC> Queue ( ) <NL> <TAB> self . top_ <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <TAB> self . q_ . push ( x ) <NL> <TAB> self . top_ <SPC> = <SPC> x <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( self . q_ . size ( ) <SPC> - <SPC> 1 ) : <NL>          self . top_ <SPC> = <SPC> self . q_ . pop ( ) <NL>          self . q_ . push ( self . top_ ) <NL> <TAB> self . q_ . pop ( ) <NL> <NL> <TAB> def <SPC> top ( self ) : <NL> <TAB> return <SPC> self . top_ <NL> <NL> <TAB> def <SPC> empty ( self ) : <NL> <TAB> return <SPC> self . q_ . empty ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> strStr ( self , <SPC> haystack , <SPC> needle ) : <NL> <NL> <TAB> if <SPC> not <SPC> needle : <NL>          return <SPC> 0 <NL> <NL> <TAB> return <SPC> self . KMP ( haystack , <SPC> needle ) <NL> <NL> <TAB> def <SPC> KMP ( self , <SPC> text , <SPC> pattern ) : <NL> <TAB> prefix <SPC> = <SPC> self . getPrefix ( pattern ) <NL> <TAB> j <SPC> = <SPC> - 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( text ) ) : <NL>          while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> text [ i ] : <NL>              j <SPC> = <SPC> prefix [ j ] <NL>          if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> text [ i ] : <NL>              j <SPC> += <SPC> 1 <NL>          if <SPC> j <SPC> == <SPC> len ( pattern ) <SPC> - <SPC> 1 : <NL>              return <SPC> i <SPC> - <SPC> j <NL> <TAB> return <SPC> - 1 <NL> <NL> <TAB> def <SPC> getPrefix ( self , <SPC> pattern ) : <NL> <TAB> prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL> <TAB> j <SPC> = <SPC> - 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>          while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>              j <SPC> = <SPC> prefix [ j ] <NL>          if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>              j <SPC> += <SPC> 1 <NL>          prefix [ i ] <SPC> = <SPC> j <NL> <TAB> return <SPC> prefix <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> strStr ( self , <SPC> haystack , <SPC> needle ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( haystack ) <SPC> - <SPC> len ( needle ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> haystack [ i : <SPC> i <SPC> + <SPC> len ( needle ) ] <SPC> == <SPC> needle : <NL>              return <SPC> i <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> TrieNode ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . is_string <SPC> = <SPC> False <NL> <TAB> self . leaves <SPC> = <SPC> { } <NL> <NL> <NL> class <SPC> Trie ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . root <SPC> = <SPC> TrieNode ( ) <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> word ) : <NL> <TAB> cur <SPC> = <SPC> self . root <NL> <TAB> for <SPC> c <SPC> in <SPC> word : <NL>          if <SPC> not <SPC> c <SPC> in <SPC> cur . leaves : <NL>              cur . leaves [ c ] <SPC> = <SPC> TrieNode ( ) <NL>          cur <SPC> = <SPC> cur . leaves [ c ] <NL> <TAB> cur . is_string <SPC> = <SPC> True <NL> <NL> <TAB> def <SPC> search ( self , <SPC> word ) : <NL> <TAB> node <SPC> = <SPC> self . childSearch ( word ) <NL> <TAB> if <SPC> node : <NL>          return <SPC> node . is_string <NL> <TAB> return <SPC> False <NL> <NL> <TAB> def <SPC> startsWith ( self , <SPC> prefix ) : <NL> <TAB> return <SPC> self . childSearch ( prefix ) <SPC> is <SPC> not <SPC> None <NL> <NL> <TAB> def <SPC> childSearch ( self , <SPC> word ) : <NL> <TAB> cur <SPC> = <SPC> self . root <NL> <TAB> for <SPC> c <SPC> in <SPC> word : <NL>          if <SPC> c <SPC> in <SPC> cur . leaves : <NL>              cur <SPC> = <SPC> cur . leaves [ c ] <NL>          else : <NL>              return <SPC> None <NL> <TAB> return <SPC> cur <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sortString ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> count <SPC> = <SPC> [ ] , <SPC> [ 0 ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          count [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL> <TAB> while <SPC> len ( result ) <SPC> != <SPC> len ( s ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( len ( count ) ) : <NL>              if <SPC> not <SPC> count [ c ] : <NL>                  continue <NL>              result . append ( chr ( ord ( "a" ) <SPC> + <SPC> c ) ) <NL>              count [ c ] <SPC> -= <SPC> 1 <NL>          for <SPC> c <SPC> in <SPC> reversed ( xrange ( len ( count ) ) ) : <NL>              if <SPC> not <SPC> count [ c ] : <NL>                  continue <NL>              result . append ( chr ( ord ( "a" ) <SPC> + <SPC> c ) ) <NL>              count [ c ] <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> sortString ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> count , <SPC> desc <SPC> = <SPC> [ ] , <SPC> collections . Counter ( s ) , <SPC> False <NL> <TAB> while <SPC> count : <NL>          for <SPC> c <SPC> in <SPC> sorted ( count . keys ( ) , <SPC> reverse = desc ) : <NL>              result . append ( c ) <NL>              count [ c ] <SPC> -= <SPC> 1 <NL>              if <SPC> not <SPC> count [ c ] : <NL>                  del <SPC> count [ c ] <NL>          desc <SPC> = <SPC> not <SPC> desc <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> increasingBST ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> increasingBSTHelper ( root , <SPC> tail ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> tail <NL>          result <SPC> = <SPC> increasingBSTHelper ( root . left , <SPC> root ) <NL>          root . left <SPC> = <SPC> None <NL>          root . right <SPC> = <SPC> increasingBSTHelper ( root . right , <SPC> tail ) <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> increasingBSTHelper ( root , <SPC> None ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findSubsequences ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> findSubsequencesHelper ( nums , <SPC> pos , <SPC> seq , <SPC> result ) : <NL>          if <SPC> len ( seq ) <SPC> >= <SPC> 2 : <NL>              result . append ( list ( seq ) ) <NL>          lookup <SPC> = <SPC> set ( ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( pos , <SPC> len ( nums ) ) : <NL>              if <SPC> ( not <SPC> seq <SPC> or <SPC> nums [ i ] <SPC> >= <SPC> seq [ - 1 ] ) <SPC> and <SPC> nums [ i ] <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( nums [ i ] ) <NL>                  seq . append ( nums [ i ] ) <NL>                  findSubsequencesHelper ( nums , <SPC> i <SPC> + <SPC> 1 , <SPC> seq , <SPC> result ) <NL>                  seq . pop ( ) <NL> <NL> <TAB> result , <SPC> seq <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> findSubsequencesHelper ( nums , <SPC> 0 , <SPC> seq , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> increasingTriplet ( self , <SPC> nums ) : <NL> <NL> <TAB> min_num , <SPC> a , <SPC> b <SPC> = <SPC> float ( "inf" ) , <SPC> float ( "inf" ) , <SPC> float ( "inf" ) <NL> <TAB> for <SPC> c <SPC> in <SPC> nums : <NL>          if <SPC> min_num <SPC> >= <SPC> c : <NL>              min_num <SPC> = <SPC> c <NL>          elif <SPC> b <SPC> >= <SPC> c : <NL>              a , <SPC> b <SPC> = <SPC> min_num , <SPC> c <NL>          else : <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution_Generalization ( object ) : <NL> <TAB> def <SPC> increasingTriplet ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> increasingKUplet ( nums , <SPC> k ) : <NL>          inc <SPC> = <SPC> [ float ( "inf" ) ] <SPC> * <SPC> ( k <SPC> - <SPC> 1 ) <NL>          for <SPC> num <SPC> in <SPC> nums : <NL>              i <SPC> = <SPC> bisect . bisect_left ( inc , <SPC> num ) <NL>              if <SPC> i <SPC> >= <SPC> k <SPC> - <SPC> 1 : <NL>                  return <SPC> True <NL>              inc [ i ] <SPC> = <SPC> num <NL>          return <SPC> k <SPC> == <SPC> 0 <NL> <NL> <TAB> return <SPC> increasingKUplet ( nums , <SPC> 3 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> AhoNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . children <SPC> = <SPC> collections . defaultdict ( AhoNode ) <NL> <TAB> self . indices <SPC> = <SPC> [ ] <NL> <TAB> self . suffix <SPC> = <SPC> None <NL> <TAB> self . output <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> AhoTrie ( object ) : <NL> <TAB> def <SPC> step ( self , <SPC> letter ) : <NL> <TAB> while <SPC> self . __node <SPC> and <SPC> letter <SPC> not <SPC> in <SPC> self . __node . children : <NL>          self . __node <SPC> = <SPC> self . __node . suffix <NL> <TAB> self . __node <SPC> = <SPC> self . __node . children [ letter ] <SPC> if <SPC> self . __node <SPC> else <SPC> self . __root <NL> <TAB> return <SPC> self . __get_ac_node_outputs ( self . __node ) <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> patterns ) : <NL> <TAB> self . __root <SPC> = <SPC> self . __create_ac_trie ( patterns ) <NL> <TAB> self . __node <SPC> = <SPC> self . __create_ac_suffix_and_output_links ( self . __root ) <NL> <NL> <TAB> def <SPC> __create_ac_trie ( self , <SPC> patterns ) : <NL> <TAB> root <SPC> = <SPC> AhoNode ( ) <NL> <TAB> for <SPC> i , <SPC> pattern <SPC> in <SPC> enumerate ( patterns ) : <NL>          node <SPC> = <SPC> root <NL>          for <SPC> c <SPC> in <SPC> pattern : <NL>              node <SPC> = <SPC> node . children [ c ] <NL>          node . indices . append ( i ) <NL> <TAB> return <SPC> root <NL> <NL> <TAB> def <SPC> __create_ac_suffix_and_output_links ( self , <SPC> root ) : <NL> <TAB> queue <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> node <SPC> in <SPC> root . children . itervalues ( ) : <NL>          queue . append ( node ) <NL>          node . suffix <SPC> = <SPC> root <NL> <NL> <TAB> while <SPC> queue : <NL>          node <SPC> = <SPC> queue . popleft ( ) <NL>          for <SPC> c , <SPC> child <SPC> in <SPC> node . children . iteritems ( ) : <NL>              queue . append ( child ) <NL>              suffix <SPC> = <SPC> node . suffix <NL>              while <SPC> suffix <SPC> and <SPC> c <SPC> not <SPC> in <SPC> suffix . children : <NL>                  suffix <SPC> = <SPC> suffix . suffix <NL>              child . suffix <SPC> = <SPC> suffix . children [ c ] <SPC> if <SPC> suffix <SPC> else <SPC> root <NL>              child . output <SPC> = <SPC> ( <NL>                  child . suffix <SPC> if <SPC> child . suffix . indices <SPC> else <SPC> child . suffix . output <NL>              ) <NL> <NL> <TAB> return <SPC> root <NL> <NL> <TAB> def <SPC> __get_ac_node_outputs ( self , <SPC> node ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> node . indices : <NL>          result . append ( i ) <NL> <TAB> output <SPC> = <SPC> node . output <NL> <TAB> while <SPC> output : <NL>          for <SPC> i <SPC> in <SPC> output . indices : <NL>              result . append ( i ) <NL>          output <SPC> = <SPC> output . output <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> indexPairs ( self , <SPC> text , <SPC> words ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> reversed_words <SPC> = <SPC> [ w [ : : - 1 ] <SPC> for <SPC> w <SPC> in <SPC> words ] <NL> <TAB> trie <SPC> = <SPC> AhoTrie ( reversed_words ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( text ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> trie . step ( text [ i ] ) : <NL>              result . append ( [ i , <SPC> i <SPC> + <SPC> len ( reversed_words [ j ] ) <SPC> - <SPC> 1 ] ) <NL> <TAB> result . reverse ( ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> left , <SPC> right , <SPC> parent ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <TAB> self . parent <SPC> = <SPC> parent <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> inorderSuccessor ( self , <SPC> node ) : <NL> <NL> <TAB> if <SPC> not <SPC> node : <NL>          return <SPC> None <NL> <NL> <TAB> if <SPC> node . right : <NL>          node <SPC> = <SPC> node . right <NL>          while <SPC> node . left : <NL>              node <SPC> = <SPC> node . left <NL>          return <SPC> node <NL> <NL> <TAB> while <SPC> node . parent <SPC> and <SPC> node . parent . right <SPC> is <SPC> node : <NL>          node <SPC> = <SPC> node . parent <NL> <TAB> return <SPC> node . parent <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> inorderSuccessor ( self , <SPC> root , <SPC> p ) : <NL> <NL> <TAB> if <SPC> p <SPC> and <SPC> p . right : <NL>          p <SPC> = <SPC> p . right <NL>          while <SPC> p . left : <NL>              p <SPC> = <SPC> p . left <NL>          return <SPC> p <NL> <NL> <TAB> successor <SPC> = <SPC> None <NL> <TAB> while <SPC> root <SPC> and <SPC> root <SPC> != <SPC> p : <NL>          if <SPC> root . val <SPC> > <SPC> p . val : <NL>              successor <SPC> = <SPC> root <NL>              root <SPC> = <SPC> root . left <NL>          else : <NL>              root <SPC> = <SPC> root . right <NL> <NL> <TAB> return <SPC> successor <NL> <NL> <NL> from <SPC> random <SPC> import <SPC> randint <NL> from <SPC> collections <SPC> import <SPC> defaultdict <NL> <NL> <NL> class <SPC> RandomizedCollection ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . __list <SPC> = <SPC> [ ] <NL> <TAB> self . __used <SPC> = <SPC> defaultdict ( list ) <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> val ) : <NL> <NL> <TAB> has <SPC> = <SPC> val <SPC> in <SPC> self . __used <NL> <NL> <TAB> self . __list <SPC> += <SPC> ( ( val , <SPC> len ( self . __used [ val ] ) ) , ) <NL> <TAB> self . __used [ val ] <SPC> += <SPC> ( len ( self . __list ) <SPC> - <SPC> 1 , ) <NL> <NL> <TAB> return <SPC> not <SPC> has <NL> <NL> <TAB> def <SPC> remove ( self , <SPC> val ) : <NL> <NL> <TAB> if <SPC> val <SPC> not <SPC> in <SPC> self . __used : <NL>          return <SPC> False <NL> <NL> <TAB> self . __used [ self . __list [ - 1 ] [ 0 ] ] [ self . __list [ - 1 ] [ 1 ] ] <SPC> = <SPC> self . __used [ val ] [ - 1 ] <NL> <TAB> self . __list [ self . __used [ val ] [ - 1 ] ] , <SPC> self . __list [ - 1 ] <SPC> = <SPC> ( <NL>          self . __list [ - 1 ] , <NL>          self . __list [ self . __used [ val ] [ - 1 ] ] , <NL> <TAB> ) <NL> <NL> <TAB> self . __used [ val ] . pop ( ) <NL> <TAB> if <SPC> not <SPC> self . __used [ val ] : <NL>          self . __used . pop ( val ) <NL> <TAB> self . __list . pop ( ) <NL> <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> getRandom ( self ) : <NL> <NL> <TAB> return <SPC> self . __list [ randint ( 0 , <SPC> len ( self . __list ) <SPC> - <SPC> 1 ) ] [ 0 ] <NL> <NL> <NL> from <SPC> random <SPC> import <SPC> randint <NL> <NL> <NL> class <SPC> RandomizedSet ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . __set <SPC> = <SPC> [ ] <NL> <TAB> self . __used <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> val ) : <NL> <NL> <TAB> if <SPC> val <SPC> in <SPC> self . __used : <NL>          return <SPC> False <NL> <NL> <TAB> self . __set <SPC> += <SPC> ( val , ) <NL> <TAB> self . __used [ val ] <SPC> = <SPC> len ( self . __set ) <SPC> - <SPC> 1 <NL> <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> remove ( self , <SPC> val ) : <NL> <NL> <TAB> if <SPC> val <SPC> not <SPC> in <SPC> self . __used : <NL>          return <SPC> False <NL> <NL> <TAB> self . __used [ self . __set [ - 1 ] ] <SPC> = <SPC> self . __used [ val ] <NL> <TAB> self . __set [ self . __used [ val ] ] , <SPC> self . __set [ - 1 ] <SPC> = <SPC> ( <NL>          self . __set [ - 1 ] , <NL>          self . __set [ self . __used [ val ] ] , <NL> <TAB> ) <NL> <NL> <TAB> self . __used . pop ( val ) <NL> <TAB> self . __set . pop ( ) <NL> <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> getRandom ( self ) : <NL> <NL> <TAB> return <SPC> self . __set [ randint ( 0 , <SPC> len ( self . __set ) <SPC> - <SPC> 1 ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> insert ( self , <SPC> intervals , <SPC> newInterval ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( intervals ) <SPC> and <SPC> newInterval [ 0 ] <SPC> > <SPC> intervals [ i ] [ 1 ] : <NL>          result <SPC> += <SPC> ( intervals [ i ] , ) <NL>          i <SPC> += <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( intervals ) <SPC> and <SPC> newInterval [ 1 ] <SPC> >= <SPC> intervals [ i ] [ 0 ] : <NL>          newInterval <SPC> = <SPC> [ <NL>              min ( newInterval [ 0 ] , <SPC> intervals [ i ] [ 0 ] ) , <NL>              max ( newInterval [ 1 ] , <SPC> intervals [ i ] [ 1 ] ) , <NL>          ] <NL>          i <SPC> += <SPC> 1 <NL> <TAB> result . append ( newInterval ) <NL> <TAB> result . extend ( intervals [ i : ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> insertIntoBST ( self , <SPC> root , <SPC> val ) : <NL> <NL> <TAB> curr , <SPC> parent <SPC> = <SPC> root , <SPC> None <NL> <TAB> while <SPC> curr : <NL>          parent <SPC> = <SPC> curr <NL>          if <SPC> val <SPC> <= <SPC> curr . val : <NL>              curr <SPC> = <SPC> curr . left <NL>          else : <NL>              curr <SPC> = <SPC> curr . right <NL> <TAB> if <SPC> not <SPC> parent : <NL>          root <SPC> = <SPC> TreeNode ( val ) <NL> <TAB> elif <SPC> val <SPC> <= <SPC> parent . val : <NL>          parent . left <SPC> = <SPC> TreeNode ( val ) <NL> <TAB> else : <NL>          parent . right <SPC> = <SPC> TreeNode ( val ) <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> insertIntoBST ( self , <SPC> root , <SPC> val ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          root <SPC> = <SPC> TreeNode ( val ) <NL> <TAB> else : <NL>          if <SPC> val <SPC> <= <SPC> root . val : <NL>              root . left <SPC> = <SPC> self . insertIntoBST ( root . left , <SPC> val ) <NL>          else : <NL>              root . right <SPC> = <SPC> self . insertIntoBST ( root . right , <SPC> val ) <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> next ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . next <SPC> = <SPC> next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> insert ( self , <SPC> head , <SPC> insertVal ) : <NL> <NL> <TAB> def <SPC> insertAfter ( node , <SPC> val ) : <NL>          node . next <SPC> = <SPC> Node ( val , <SPC> node . next ) <NL> <NL> <TAB> if <SPC> not <SPC> head : <NL>          node <SPC> = <SPC> Node ( insertVal , <SPC> None ) <NL>          node . next <SPC> = <SPC> node <NL>          return <SPC> node <NL> <NL> <TAB> curr <SPC> = <SPC> head <NL> <TAB> while <SPC> True : <NL>          if <SPC> curr . val <SPC> < <SPC> curr . next . val : <NL>              if <SPC> curr . val <SPC> <= <SPC> insertVal <SPC> and <SPC> insertVal <SPC> <= <SPC> curr . next . val : <NL>                  insertAfter ( curr , <SPC> insertVal ) <NL>                  break <NL>          elif <SPC> curr . val <SPC> > <SPC> curr . next . val : <NL>              if <SPC> curr . val <SPC> <= <SPC> insertVal <SPC> or <SPC> insertVal <SPC> <= <SPC> curr . next . val : <NL>                  insertAfter ( curr , <SPC> insertVal ) <NL>                  break <NL>          else : <NL>              if <SPC> curr . next <SPC> == <SPC> head : <NL>                  insertAfter ( curr , <SPC> insertVal ) <NL>                  break <NL>          curr <SPC> = <SPC> curr . next <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> repr ( self . next ) ) <NL> <TAB> else : <NL>          return <SPC> "Nil" <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> insertionSortList ( self , <SPC> head ) : <NL> <TAB> if <SPC> head <SPC> is <SPC> None <SPC> or <SPC> self . isSorted ( head ) : <NL>          return <SPC> head <NL> <NL> <TAB> dummy <SPC> = <SPC> ListNode ( - 2147483648 ) <NL> <TAB> dummy . next <SPC> = <SPC> head <NL> <TAB> cur , <SPC> sorted_tail <SPC> = <SPC> head . next , <SPC> head <NL> <TAB> while <SPC> cur : <NL>          prev <SPC> = <SPC> dummy <NL>          while <SPC> prev . next . val <SPC> < <SPC> cur . val : <NL>              prev <SPC> = <SPC> prev . next <NL>          if <SPC> prev <SPC> == <SPC> sorted_tail : <NL>              cur , <SPC> sorted_tail <SPC> = <SPC> cur . next , <SPC> cur <NL>          else : <NL>              cur . next , <SPC> prev . next , <SPC> sorted_tail . next <SPC> = <SPC> prev . next , <SPC> cur , <SPC> cur . next <NL>              cur <SPC> = <SPC> sorted_tail . next <NL> <NL> <TAB> return <SPC> dummy . next <NL> <NL> <TAB> def <SPC> isSorted ( self , <SPC> head ) : <NL> <TAB> while <SPC> head <SPC> and <SPC> head . next : <NL>          if <SPC> head . val <SPC> > <SPC> head . next . val : <NL>              return <SPC> False <NL>          head <SPC> = <SPC> head . next <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sufficientSubset ( self , <SPC> root , <SPC> limit ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> None <NL> <TAB> if <SPC> not <SPC> root . left <SPC> and <SPC> not <SPC> root . right : <NL>          return <SPC> None <SPC> if <SPC> root . val <SPC> < <SPC> limit <SPC> else <SPC> root <NL> <TAB> root . left <SPC> = <SPC> self . sufficientSubset ( root . left , <SPC> limit <SPC> - <SPC> root . val ) <NL> <TAB> root . right <SPC> = <SPC> self . sufficientSubset ( root . right , <SPC> limit <SPC> - <SPC> root . val ) <NL> <TAB> if <SPC> not <SPC> root . left <SPC> and <SPC> not <SPC> root . right : <NL>          return <SPC> None <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> integerBreak ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> < <SPC> 4 : <NL>          return <SPC> n <SPC> - <SPC> 1 <NL> <NL> <TAB> res <SPC> = <SPC> 0 <NL> <TAB> if <SPC> n <SPC> % <SPC> 3 <SPC> == <SPC> 0 : <NL>          res <SPC> = <SPC> 3 <SPC> ** <SPC> ( n <SPC> // <SPC> 3 ) <NL> <TAB> elif <SPC> n <SPC> % <SPC> 3 <SPC> == <SPC> 2 : <NL>          res <SPC> = <SPC> 3 <SPC> ** <SPC> ( n <SPC> // <SPC> 3 ) <SPC> * <SPC> 2 <NL> <TAB> else : <NL>          res <SPC> = <SPC> 3 <SPC> ** <SPC> ( n <SPC> // <SPC> 3 <SPC> - <SPC> 1 ) <SPC> * <SPC> 4 <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> integerBreak ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> < <SPC> 4 : <NL>          return <SPC> n <SPC> - <SPC> 1 <NL> <NL> <TAB> res <SPC> = <SPC> [ 0 , <SPC> 1 , <SPC> 2 , <SPC> 3 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 4 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          res [ i <SPC> % <SPC> 4 ] <SPC> = <SPC> max ( res [ ( i <SPC> - <SPC> 2 ) <SPC> % <SPC> 4 ] <SPC> * <SPC> 2 , <SPC> res [ ( i <SPC> - <SPC> 3 ) <SPC> % <SPC> 4 ] <SPC> * <SPC> 3 ) <NL> <TAB> return <SPC> res [ n <SPC> % <SPC> 4 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> integerReplacement ( self , <SPC> n ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> n <SPC> != <SPC> 1 : <NL>          b <SPC> = <SPC> n <SPC> & <SPC> 3 <NL>          if <SPC> n <SPC> == <SPC> 3 : <NL>              n <SPC> -= <SPC> 1 <NL>          elif <SPC> b <SPC> == <SPC> 3 : <NL>              n <SPC> += <SPC> 1 <NL>          elif <SPC> b <SPC> == <SPC> 1 : <NL>              n <SPC> -= <SPC> 1 <NL>          else : <NL>              n <SPC> /= <SPC> 2 <NL>          result <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> integerReplacement ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> < <SPC> 4 : <NL>          return <SPC> [ 0 , <SPC> 0 , <SPC> 1 , <SPC> 2 ] [ n ] <NL> <TAB> if <SPC> n <SPC> % <SPC> 4 <SPC> in <SPC> ( 0 , <SPC> 2 ) : <NL>          return <SPC> self . integerReplacement ( n <SPC> / <SPC> 2 ) <SPC> + <SPC> 1 <NL> <TAB> elif <SPC> n <SPC> % <SPC> 4 <SPC> == <SPC> 1 : <NL>          return <SPC> self . integerReplacement ( ( n <SPC> - <SPC> 1 ) <SPC> / <SPC> 4 ) <SPC> + <SPC> 3 <NL> <TAB> else : <NL>          return <SPC> self . integerReplacement ( ( n <SPC> + <SPC> 1 ) <SPC> / <SPC> 4 ) <SPC> + <SPC> 3 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberToWords ( self , <SPC> num ) : <NL> <NL> <TAB> if <SPC> num <SPC> == <SPC> 0 : <NL>          return <SPC> "Zero" <NL> <NL> <TAB> lookup <SPC> = <SPC> { <NL>          0 : <SPC> "Zero" , <NL>          1 : <SPC> "One" , <NL>          2 : <SPC> "Two" , <NL>          3 : <SPC> "Three" , <NL>          4 : <SPC> "Four" , <NL>          5 : <SPC> "Five" , <NL>          6 : <SPC> "Six" , <NL>          7 : <SPC> "Seven" , <NL>          8 : <SPC> "Eight" , <NL>          9 : <SPC> "Nine" , <NL>          10 : <SPC> "Ten" , <NL>          11 : <SPC> "Eleven" , <NL>          12 : <SPC> "Twelve" , <NL>          13 : <SPC> "Thirteen" , <NL>          14 : <SPC> "Fourteen" , <NL>          15 : <SPC> "Fifteen" , <NL>          16 : <SPC> "Sixteen" , <NL>          17 : <SPC> "Seventeen" , <NL>          18 : <SPC> "Eighteen" , <NL>          19 : <SPC> "Nineteen" , <NL>          20 : <SPC> "Twenty" , <NL>          30 : <SPC> "Thirty" , <NL>          40 : <SPC> "Forty" , <NL>          50 : <SPC> "Fifty" , <NL>          60 : <SPC> "Sixty" , <NL>          70 : <SPC> "Seventy" , <NL>          80 : <SPC> "Eighty" , <NL>          90 : <SPC> "Ninety" , <NL> <TAB> } <NL> <TAB> unit <SPC> = <SPC> [ "" , <SPC> "Thousand" , <SPC> "Million" , <SPC> "Billion" ] <NL> <NL> <TAB> res , <SPC> i <SPC> = <SPC> [ ] , <SPC> 0 <NL> <TAB> while <SPC> num : <NL>          cur <SPC> = <SPC> num <SPC> % <SPC> 1000 <NL>          if <SPC> num <SPC> % <SPC> 1000 : <NL>              res . append ( self . threeDigits ( cur , <SPC> lookup , <SPC> unit [ i ] ) ) <NL>          num <SPC> //= <SPC> 1000 <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> " " . join ( res [ : : - 1 ] ) <NL> <NL> <TAB> def <SPC> threeDigits ( self , <SPC> num , <SPC> lookup , <SPC> unit ) : <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> num <SPC> / <SPC> 100 : <NL>          res <SPC> = <SPC> [ lookup [ num <SPC> / <SPC> 100 ] <SPC> + <SPC> " " <SPC> + <SPC> "Hundred" ] <NL> <TAB> if <SPC> num <SPC> % <SPC> 100 : <NL>          res . append ( self . twoDigits ( num <SPC> % <SPC> 100 , <SPC> lookup ) ) <NL> <TAB> if <SPC> unit <SPC> != <SPC> "" : <NL>          res . append ( unit ) <NL> <TAB> return <SPC> " " . join ( res ) <NL> <NL> <TAB> def <SPC> twoDigits ( self , <SPC> num , <SPC> lookup ) : <NL> <TAB> if <SPC> num <SPC> in <SPC> lookup : <NL>          return <SPC> lookup [ num ] <NL> <TAB> return <SPC> lookup [ ( num <SPC> / <SPC> 10 ) <SPC> * <SPC> 10 ] <SPC> + <SPC> " " <SPC> + <SPC> lookup [ num <SPC> % <SPC> 10 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> intToRoman ( self , <SPC> num ) : <NL> <NL> <TAB> numeral_map <SPC> = <SPC> { <NL>          1 : <SPC> "I" , <NL>          4 : <SPC> "IV" , <NL>          5 : <SPC> "V" , <NL>          9 : <SPC> "IX" , <NL>          10 : <SPC> "X" , <NL>          40 : <SPC> "XL" , <NL>          50 : <SPC> "L" , <NL>          90 : <SPC> "XC" , <NL>          100 : <SPC> "C" , <NL>          400 : <SPC> "CD" , <NL>          500 : <SPC> "D" , <NL>          900 : <SPC> "CM" , <NL>          1000 : <SPC> "M" , <NL> <TAB> } <NL> <TAB> keyset , <SPC> result <SPC> = <SPC> sorted ( numeral_map . keys ( ) ) , <SPC> [ ] <NL> <NL> <TAB> while <SPC> num <SPC> > <SPC> 0 : <NL>          for <SPC> key <SPC> in <SPC> reversed ( keyset ) : <NL>              while <SPC> num <SPC> / <SPC> key <SPC> > <SPC> 0 : <NL>                  num <SPC> -= <SPC> key <NL>                  result <SPC> += <SPC> numeral_map [ key ] <NL> <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isInterleave ( self , <SPC> s1 , <SPC> s2 , <SPC> s3 ) : <NL> <TAB> if <SPC> len ( s1 ) <SPC> + <SPC> len ( s2 ) <SPC> != <SPC> len ( s3 ) : <NL>          return <SPC> False <NL> <TAB> if <SPC> len ( s1 ) <SPC> > <SPC> len ( s2 ) : <NL>          return <SPC> self . isInterleave ( s2 , <SPC> s1 , <SPC> s3 ) <NL> <TAB> match <SPC> = <SPC> [ False <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( s1 ) <SPC> + <SPC> 1 ) ] <NL> <TAB> match [ 0 ] <SPC> = <SPC> True <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s1 ) <SPC> + <SPC> 1 ) : <NL>          match [ i ] <SPC> = <SPC> match [ i <SPC> - <SPC> 1 ] <SPC> and <SPC> s1 [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> s3 [ i <SPC> - <SPC> 1 ] <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( s2 ) <SPC> + <SPC> 1 ) : <NL>          match [ 0 ] <SPC> = <SPC> match [ 0 ] <SPC> and <SPC> s2 [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> s3 [ j <SPC> - <SPC> 1 ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s1 ) <SPC> + <SPC> 1 ) : <NL>              match [ i ] <SPC> = <SPC> ( match [ i <SPC> - <SPC> 1 ] <SPC> and <SPC> s1 [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> s3 [ i <SPC> + <SPC> j <SPC> - <SPC> 1 ] ) <SPC> or <SPC> ( <NL>                  match [ i ] <SPC> and <SPC> s2 [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> s3 [ i <SPC> + <SPC> j <SPC> - <SPC> 1 ] <NL>              ) <NL> <TAB> return <SPC> match [ - 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> isInterleave ( self , <SPC> s1 , <SPC> s2 , <SPC> s3 ) : <NL> <TAB> if <SPC> len ( s1 ) <SPC> + <SPC> len ( s2 ) <SPC> != <SPC> len ( s3 ) : <NL>          return <SPC> False <NL> <TAB> match <SPC> = <SPC> [ [ False <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( s2 ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( s1 ) <SPC> + <SPC> 1 ) ] <NL> <TAB> match [ 0 ] [ 0 ] <SPC> = <SPC> True <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s1 ) <SPC> + <SPC> 1 ) : <NL>          match [ i ] [ 0 ] <SPC> = <SPC> match [ i <SPC> - <SPC> 1 ] [ 0 ] <SPC> and <SPC> s1 [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> s3 [ i <SPC> - <SPC> 1 ] <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( s2 ) <SPC> + <SPC> 1 ) : <NL>          match [ 0 ] [ j ] <SPC> = <SPC> match [ 0 ] [ j <SPC> - <SPC> 1 ] <SPC> and <SPC> s2 [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> s3 [ j <SPC> - <SPC> 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s1 ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( s2 ) <SPC> + <SPC> 1 ) : <NL>              match [ i ] [ j ] <SPC> = <SPC> ( match [ i <SPC> - <SPC> 1 ] [ j ] <SPC> and <SPC> s1 [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> s3 [ i <SPC> + <SPC> j <SPC> - <SPC> 1 ] ) <SPC> or <SPC> ( <NL>                  match [ i ] [ j <SPC> - <SPC> 1 ] <SPC> and <SPC> s2 [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> s3 [ i <SPC> + <SPC> j <SPC> - <SPC> 1 ] <NL>              ) <NL> <TAB> return <SPC> match [ - 1 ] [ - 1 ] <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <NL> <TAB> def <SPC> isInterleave ( self , <SPC> s1 , <SPC> s2 , <SPC> s3 ) : <NL> <TAB> self . match <SPC> = <SPC> { } <NL> <TAB> if <SPC> len ( s1 ) <SPC> + <SPC> len ( s2 ) <SPC> != <SPC> len ( s3 ) : <NL>          return <SPC> False <NL> <TAB> return <SPC> self . isInterleaveRecu ( s1 , <SPC> s2 , <SPC> s3 , <SPC> 0 , <SPC> 0 , <SPC> 0 ) <NL> <NL> <TAB> def <SPC> isInterleaveRecu ( self , <SPC> s1 , <SPC> s2 , <SPC> s3 , <SPC> a , <SPC> b , <SPC> c ) : <NL> <TAB> if <SPC> repr ( [ a , <SPC> b ] ) <SPC> in <SPC> self . match . keys ( ) : <NL>          return <SPC> self . match [ repr ( [ a , <SPC> b ] ) ] <NL> <NL> <TAB> if <SPC> c <SPC> == <SPC> len ( s3 ) : <NL>          return <SPC> True <NL> <NL> <TAB> result <SPC> = <SPC> False <NL> <TAB> if <SPC> a <SPC> < <SPC> len ( s1 ) <SPC> and <SPC> s1 [ a ] <SPC> == <SPC> s3 [ c ] : <NL>          result <SPC> = <SPC> result <SPC> or <SPC> self . isInterleaveRecu ( s1 , <SPC> s2 , <SPC> s3 , <SPC> a <SPC> + <SPC> 1 , <SPC> b , <SPC> c <SPC> + <SPC> 1 ) <NL> <TAB> if <SPC> b <SPC> < <SPC> len ( s2 ) <SPC> and <SPC> s2 [ b ] <SPC> == <SPC> s3 [ c ] : <NL>          result <SPC> = <SPC> result <SPC> or <SPC> self . isInterleaveRecu ( s1 , <SPC> s2 , <SPC> s3 , <SPC> a , <SPC> b <SPC> + <SPC> 1 , <SPC> c <SPC> + <SPC> 1 ) <NL> <NL> <TAB> self . match [ repr ( [ a , <SPC> b ] ) ] <SPC> = <SPC> result <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> arraysIntersection ( self , <SPC> arr1 , <SPC> arr2 , <SPC> arr3 ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i , <SPC> j , <SPC> k <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> != <SPC> len ( arr1 ) <SPC> and <SPC> j <SPC> != <SPC> len ( arr2 ) <SPC> and <SPC> k <SPC> != <SPC> len ( arr3 ) : <NL>          if <SPC> arr1 [ i ] <SPC> == <SPC> arr2 [ j ] <SPC> == <SPC> arr3 [ k ] : <NL>              result . append ( arr1 [ i ] ) <NL>              i <SPC> += <SPC> 1 <NL>              j <SPC> += <SPC> 1 <NL>              k <SPC> += <SPC> 1 <NL>          else : <NL>              curr <SPC> = <SPC> max ( arr1 [ i ] , <SPC> arr2 [ j ] , <SPC> arr3 [ k ] ) <NL>              while <SPC> i <SPC> != <SPC> len ( arr1 ) <SPC> and <SPC> arr1 [ i ] <SPC> < <SPC> curr : <NL>                  i <SPC> += <SPC> 1 <NL>              while <SPC> j <SPC> != <SPC> len ( arr2 ) <SPC> and <SPC> arr2 [ j ] <SPC> < <SPC> curr : <NL>                  j <SPC> += <SPC> 1 <NL>              while <SPC> k <SPC> != <SPC> len ( arr3 ) <SPC> and <SPC> arr3 [ k ] <SPC> < <SPC> curr : <NL>                  k <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> arraysIntersection ( self , <SPC> arr1 , <SPC> arr2 , <SPC> arr3 ) : <NL> <NL> <TAB> intersect <SPC> = <SPC> reduce ( set . intersection , <SPC> map ( set , <SPC> [ arr2 , <SPC> arr3 ] ) ) <NL> <TAB> return <SPC> [ x <SPC> for <SPC> x <SPC> in <SPC> arr1 <SPC> if <SPC> x <SPC> in <SPC> intersect ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> intersect ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> if <SPC> len ( nums1 ) <SPC> > <SPC> len ( nums2 ) : <NL>          return <SPC> self . intersect ( nums2 , <SPC> nums1 ) <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> i <SPC> in <SPC> nums1 : <NL>          lookup [ i ] <SPC> += <SPC> 1 <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> nums2 : <NL>          if <SPC> lookup [ i ] <SPC> > <SPC> 0 : <NL>              res <SPC> += <SPC> ( i , ) <NL>              lookup [ i ] <SPC> -= <SPC> 1 <NL> <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> intersect2 ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> c <SPC> = <SPC> collections . Counter ( nums1 ) <SPC> & <SPC> collections . Counter ( nums2 ) <NL> <TAB> intersect <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> c : <NL>          intersect . extend ( [ i ] <SPC> * <SPC> c [ i ] ) <NL> <TAB> return <SPC> intersect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> intersect ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> if <SPC> len ( nums1 ) <SPC> > <SPC> len ( nums2 ) : <NL>          return <SPC> self . intersect ( nums2 , <SPC> nums1 ) <NL> <NL> <TAB> def <SPC> binary_search ( compare , <SPC> nums , <SPC> left , <SPC> right , <SPC> target ) : <NL>          while <SPC> left <SPC> < <SPC> right : <NL>              mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>              if <SPC> compare ( nums [ mid ] , <SPC> target ) : <NL>                  right <SPC> = <SPC> mid <NL>              else : <NL>                  left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          return <SPC> left <NL> <NL> <TAB> nums1 . sort ( ) , <SPC> nums2 . sort ( ) <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> left <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> nums1 : <NL>          left <SPC> = <SPC> binary_search ( lambda <SPC> x , <SPC> y : <SPC> x <SPC> >= <SPC> y , <SPC> nums2 , <SPC> left , <SPC> len ( nums2 ) , <SPC> i ) <NL>          if <SPC> left <SPC> != <SPC> len ( nums2 ) <SPC> and <SPC> nums2 [ left ] <SPC> == <SPC> i : <NL>              res <SPC> += <SPC> ( i , ) <NL>              left <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> intersect ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> nums1 . sort ( ) , <SPC> nums2 . sort ( ) <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <NL> <TAB> it1 , <SPC> it2 <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> it1 <SPC> < <SPC> len ( nums1 ) <SPC> and <SPC> it2 <SPC> < <SPC> len ( nums2 ) : <NL>          if <SPC> nums1 [ it1 ] <SPC> < <SPC> nums2 [ it2 ] : <NL>              it1 <SPC> += <SPC> 1 <NL>          elif <SPC> nums1 [ it1 ] <SPC> > <SPC> nums2 [ it2 ] : <NL>              it2 <SPC> += <SPC> 1 <NL>          else : <NL>              res <SPC> += <SPC> ( nums1 [ it1 ] , ) <NL>              it1 <SPC> += <SPC> 1 <NL>              it2 <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> intersect ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> nums1 . sort ( ) , <SPC> nums2 . sort ( ) <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <NL> <TAB> it1 , <SPC> it2 <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> it1 <SPC> < <SPC> len ( nums1 ) <SPC> and <SPC> it2 <SPC> < <SPC> len ( nums2 ) : <NL>          if <SPC> nums1 [ it1 ] <SPC> < <SPC> nums2 [ it2 ] : <NL>              it1 <SPC> += <SPC> 1 <NL>          elif <SPC> nums1 [ it1 ] <SPC> > <SPC> nums2 [ it2 ] : <NL>              it2 <SPC> += <SPC> 1 <NL>          else : <NL>              res <SPC> += <SPC> ( nums1 [ it1 ] , ) <NL>              it1 <SPC> += <SPC> 1 <NL>              it2 <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> intersection ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> if <SPC> len ( nums1 ) <SPC> > <SPC> len ( nums2 ) : <NL>          return <SPC> self . intersection ( nums2 , <SPC> nums1 ) <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> nums1 : <NL>          lookup . add ( i ) <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> nums2 : <NL>          if <SPC> i <SPC> in <SPC> lookup : <NL>              res <SPC> += <SPC> ( i , ) <NL>              lookup . discard ( i ) <NL> <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> intersection2 ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> return <SPC> list ( set ( nums1 ) <SPC> & <SPC> set ( nums2 ) ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> intersection ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> if <SPC> len ( nums1 ) <SPC> > <SPC> len ( nums2 ) : <NL>          return <SPC> self . intersection ( nums2 , <SPC> nums1 ) <NL> <NL> <TAB> def <SPC> binary_search ( compare , <SPC> nums , <SPC> left , <SPC> right , <SPC> target ) : <NL>          while <SPC> left <SPC> < <SPC> right : <NL>              mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>              if <SPC> compare ( nums [ mid ] , <SPC> target ) : <NL>                  right <SPC> = <SPC> mid <NL>              else : <NL>                  left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          return <SPC> left <NL> <NL> <TAB> nums1 . sort ( ) , <SPC> nums2 . sort ( ) <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> left <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> nums1 : <NL>          left <SPC> = <SPC> binary_search ( lambda <SPC> x , <SPC> y : <SPC> x <SPC> >= <SPC> y , <SPC> nums2 , <SPC> left , <SPC> len ( nums2 ) , <SPC> i ) <NL>          if <SPC> left <SPC> != <SPC> len ( nums2 ) <SPC> and <SPC> nums2 [ left ] <SPC> == <SPC> i : <NL>              res <SPC> += <SPC> ( i , ) <NL>              left <SPC> = <SPC> binary_search ( lambda <SPC> x , <SPC> y : <SPC> x <SPC> > <SPC> y , <NL>                                   nums2 , <SPC> left , <SPC> len ( nums2 ) , <SPC> i ) <NL> <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> intersection ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> nums1 . sort ( ) , <SPC> nums2 . sort ( ) <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <NL> <TAB> it1 , <SPC> it2 <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> it1 <SPC> < <SPC> len ( nums1 ) <SPC> and <SPC> it2 <SPC> < <SPC> len ( nums2 ) : <NL>          if <SPC> nums1 [ it1 ] <SPC> < <SPC> nums2 [ it2 ] : <NL>              it1 <SPC> += <SPC> 1 <NL>          elif <SPC> nums1 [ it1 ] <SPC> > <SPC> nums2 [ it2 ] : <NL>              it2 <SPC> += <SPC> 1 <NL>          else : <NL>              if <SPC> not <SPC> res <SPC> or <SPC> res [ - 1 ] <SPC> != <SPC> nums1 [ it1 ] : <NL>                  res <SPC> += <SPC> ( nums1 [ it1 ] , ) <NL>              it1 <SPC> += <SPC> 1 <NL>              it2 <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> getIntersectionNode ( self , <SPC> headA , <SPC> headB ) : <NL> <TAB> curA , <SPC> curB <SPC> = <SPC> headA , <SPC> headB <NL> <TAB> while <SPC> curA <SPC> != <SPC> curB : <NL>          curA <SPC> = <SPC> curA . next <SPC> if <SPC> curA <SPC> else <SPC> headB <NL>          curB <SPC> = <SPC> curB . next <SPC> if <SPC> curB <SPC> else <SPC> headA <NL> <TAB> return <SPC> curA <NL> <NL> <NL> class <SPC> Interval ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> s = 0 , <SPC> e = 0 ) : <NL> <TAB> self . start <SPC> = <SPC> s <NL> <TAB> self . end <SPC> = <SPC> e <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> intervalIntersection ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( A ) <SPC> and <SPC> j <SPC> < <SPC> len ( B ) : <NL>          left <SPC> = <SPC> max ( A [ i ] . start , <SPC> B [ j ] . start ) <NL>          right <SPC> = <SPC> min ( A [ i ] . end , <SPC> B [ j ] . end ) <NL>          if <SPC> left <SPC> <= <SPC> right : <NL>              result . append ( Interval ( left , <SPC> right ) ) <NL>          if <SPC> A [ i ] . end <SPC> < <SPC> B [ j ] . end : <NL>              i <SPC> += <SPC> 1 <NL>          else : <NL>              j <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution : <NL> <TAB> def <SPC> invalidTransactions ( self , <SPC> transactions ) : <NL> <TAB> AMOUNT , <SPC> MINUTES <SPC> = <SPC> 1000 , <SPC> 60 <NL> <TAB> trans <SPC> = <SPC> map ( <NL>          lambda <SPC> x : <SPC> ( x [ 0 ] , <SPC> int ( x [ 1 ] ) , <SPC> int ( x [ 2 ] ) , <SPC> x [ 3 ] ) , <NL>          ( transaction . split ( "," ) <SPC> for <SPC> transaction <SPC> in <SPC> transactions ) , <NL> <TAB> ) <NL> <TAB> trans . sort ( key = lambda <SPC> t : <SPC> t [ 1 ] ) <NL> <TAB> trans_indexes <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> t <SPC> in <SPC> enumerate ( trans ) : <NL>          trans_indexes [ t [ 0 ] ] . append ( i ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> name , <SPC> indexes <SPC> in <SPC> trans_indexes . iteritems ( ) : <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> i , <SPC> t_index <SPC> in <SPC> enumerate ( indexes ) : <NL>              t <SPC> = <SPC> trans [ t_index ] <NL>              if <SPC> t [ 2 ] <SPC> > <SPC> AMOUNT : <NL>                  result . append ( "{},{},{},{}" . format ( * t ) ) <NL>                  continue <NL>              while <SPC> ( <NL>                  left <SPC> + <NL>                      1 <SPC> < <SPC> len ( <NL>                          indexes ) <SPC> and <SPC> trans [ indexes [ left ] ] [ 1 ] <SPC> < <SPC> t [ 1 ] <SPC> - <SPC> MINUTES <NL>              ) : <NL>                  left <SPC> += <SPC> 1 <NL>              while <SPC> ( <NL>                  right <SPC> + <SPC> 1 <SPC> < <SPC> len ( indexes ) <NL>                  and <SPC> trans [ indexes [ right <SPC> + <SPC> 1 ] ] [ 1 ] <SPC> <= <SPC> t [ 1 ] <SPC> + <SPC> MINUTES <NL>              ) : <NL>                  right <SPC> += <SPC> 1 <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right <SPC> + <SPC> 1 ) : <NL>                  if <SPC> trans [ indexes [ i ] ] [ 3 ] <SPC> != <SPC> t [ 3 ] : <NL>                      result . append ( "{},{},{},{}" . format ( * t ) ) <NL>                      break <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Queue ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . data <SPC> = <SPC> collections . deque ( ) <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <TAB> self . data . append ( x ) <NL> <NL> <TAB> def <SPC> peek ( self ) : <NL> <TAB> return <SPC> self . data [ 0 ] <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <TAB> return <SPC> self . data . popleft ( ) <NL> <NL> <TAB> def <SPC> size ( self ) : <NL> <TAB> return <SPC> len ( self . data ) <NL> <NL> <TAB> def <SPC> empty ( self ) : <NL> <TAB> return <SPC> len ( self . data ) <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> invertTree ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> not <SPC> None : <NL>          nodes <SPC> = <SPC> Queue ( ) <NL>          nodes . push ( root ) <NL>          while <SPC> not <SPC> nodes . empty ( ) : <NL>              node <SPC> = <SPC> nodes . pop ( ) <NL>              node . left , <SPC> node . right <SPC> = <SPC> node . right , <SPC> node . left <NL>              if <SPC> node . left <SPC> is <SPC> not <SPC> None : <NL>                  nodes . push ( node . left ) <NL>              if <SPC> node . right <SPC> is <SPC> not <SPC> None : <NL>                  nodes . push ( node . right ) <NL> <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> invertTree ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> not <SPC> None : <NL>          nodes <SPC> = <SPC> [ ] <NL>          nodes . append ( root ) <NL>          while <SPC> nodes : <NL>              node <SPC> = <SPC> nodes . pop ( ) <NL>              node . left , <SPC> node . right <SPC> = <SPC> node . right , <SPC> node . left <NL>              if <SPC> node . left <SPC> is <SPC> not <SPC> None : <NL>                  nodes . append ( node . left ) <NL>              if <SPC> node . right <SPC> is <SPC> not <SPC> None : <NL>                  nodes . append ( node . right ) <NL> <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <NL> <TAB> def <SPC> invertTree ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> not <SPC> None : <NL>          root . left , <SPC> root . right <SPC> = <SPC> self . invertTree ( root . right ) , <SPC> self . invertTree ( <NL>              root . left <NL>          ) <NL> <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> ipToCIDR ( self , <SPC> ip , <SPC> n ) : <NL> <NL> <TAB> def <SPC> ipToInt ( ip ) : <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> ip . split ( "." ) : <NL>              result <SPC> = <SPC> 256 <SPC> * <SPC> result <SPC> + <SPC> int ( i ) <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> intToIP ( n ) : <NL>          return <SPC> "." . join ( str ( ( n <SPC> >> <SPC> i ) <SPC> % <SPC> 256 ) <SPC> for <SPC> i <SPC> in <SPC> ( 24 , <SPC> 16 , <SPC> 8 , <SPC> 0 ) ) <NL> <NL> <TAB> start <SPC> = <SPC> ipToInt ( ip ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> n : <NL>          mask <SPC> = <SPC> max ( 33 <SPC> - <SPC> ( start <SPC> & <SPC> ~ ( start <SPC> - <SPC> 1 ) ) . bit_length ( ) , <NL>                     33 <SPC> - <SPC> n . bit_length ( ) ) <NL>          result . append ( intToIP ( start ) <SPC> + <SPC> "/" <SPC> + <SPC> str ( mask ) ) <NL>          start <SPC> += <SPC> 1 <SPC> << <SPC> ( 32 <SPC> - <SPC> mask ) <NL>          n <SPC> -= <SPC> 1 <SPC> << <SPC> ( 32 <SPC> - <SPC> mask ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMaximizedCapital ( self , <SPC> k , <SPC> W , <SPC> Profits , <SPC> Capital ) : <NL> <NL> <TAB> curr <SPC> = <SPC> [ ] <NL> <TAB> future <SPC> = <SPC> sorted ( zip ( Capital , <SPC> Profits ) , <SPC> reverse = True ) <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( k ) : <NL>          while <SPC> future <SPC> and <SPC> future [ - 1 ] [ 0 ] <SPC> <= <SPC> W : <NL>              heapq . heappush ( curr , <SPC> - future . pop ( ) [ 1 ] ) <NL>          if <SPC> curr : <NL>              W <SPC> -= <SPC> heapq . heappop ( curr ) <NL> <TAB> return <SPC> W <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isBipartite ( self , <SPC> graph ) : <NL> <NL> <TAB> color <SPC> = <SPC> { } <NL> <TAB> for <SPC> node <SPC> in <SPC> xrange ( len ( graph ) ) : <NL>          if <SPC> node <SPC> in <SPC> color : <NL>              continue <NL>          stack <SPC> = <SPC> [ node ] <NL>          color [ node ] <SPC> = <SPC> 0 <NL>          while <SPC> stack : <NL>              curr <SPC> = <SPC> stack . pop ( ) <NL>              for <SPC> neighbor <SPC> in <SPC> graph [ curr ] : <NL>                  if <SPC> neighbor <SPC> not <SPC> in <SPC> color : <NL>                      stack . append ( neighbor ) <NL>                      color [ neighbor ] <SPC> = <SPC> color [ curr ] <SPC> ^ <SPC> 1 <NL>                  elif <SPC> color [ neighbor ] <SPC> == <SPC> color [ curr ] : <NL>                      return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isSubsequence ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> if <SPC> not <SPC> s : <NL>          return <SPC> True <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> t : <NL>          if <SPC> c <SPC> == <SPC> s [ i ] : <NL>              i <SPC> += <SPC> 1 <NL>          if <SPC> i <SPC> == <SPC> len ( s ) : <NL>              break <NL> <TAB> return <SPC> i <SPC> == <SPC> len ( s ) <NL> <NL> <NL> import <SPC> operator <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> islandPerimeter ( self , <SPC> grid ) : <NL> <NL> <TAB> count , <SPC> repeat <SPC> = <SPC> 0 , <SPC> 0 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ i ] ) ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> == <SPC> 1 : <NL>                  count <SPC> += <SPC> 1 <NL>                  if <SPC> i <SPC> != <SPC> 0 <SPC> and <SPC> grid [ i <SPC> - <SPC> 1 ] [ j ] <SPC> == <SPC> 1 : <NL>                      repeat <SPC> += <SPC> 1 <NL>                  if <SPC> j <SPC> != <SPC> 0 <SPC> and <SPC> grid [ i ] [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> 1 : <NL>                      repeat <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> 4 <SPC> * <SPC> count <SPC> - <SPC> 2 <SPC> * <SPC> repeat <NL> <NL> <TAB> def <SPC> islandPerimeter2 ( self , <SPC> grid ) : <NL> <TAB> return <SPC> sum ( <NL>          sum ( map ( operator . ne , <SPC> [ 0 ] <SPC> + <SPC> row , <SPC> row <SPC> + <SPC> [ 0 ] ) ) <NL>          for <SPC> row <SPC> in <SPC> grid <SPC> + <SPC> map ( list , <SPC> zip ( * grid ) ) <NL> <TAB> ) <NL> <NL> <NL> from <SPC> itertools <SPC> import <SPC> izip <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isIsomorphic ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> if <SPC> len ( s ) <SPC> != <SPC> len ( t ) : <NL>          return <SPC> False <NL> <NL> <TAB> s2t , <SPC> t2s <SPC> = <SPC> { } , <SPC> { } <NL> <TAB> for <SPC> p , <SPC> w <SPC> in <SPC> izip ( s , <SPC> t ) : <NL>          if <SPC> w <SPC> not <SPC> in <SPC> s2t <SPC> and <SPC> p <SPC> not <SPC> in <SPC> t2s : <NL>              s2t [ w ] <SPC> = <SPC> p <NL>              t2s [ p ] <SPC> = <SPC> w <NL>          elif <SPC> w <SPC> not <SPC> in <SPC> s2t <SPC> or <SPC> s2t [ w ] <SPC> != <SPC> p : <NL> <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isIsomorphic ( self , <SPC> s , <SPC> t ) : <NL> <TAB> if <SPC> len ( s ) <SPC> != <SPC> len ( t ) : <NL>          return <SPC> False <NL> <NL> <TAB> return <SPC> self . halfIsom ( s , <SPC> t ) <SPC> and <SPC> self . halfIsom ( t , <SPC> s ) <NL> <NL> <TAB> def <SPC> halfIsom ( self , <SPC> s , <SPC> t ) : <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> s [ i ] <SPC> not <SPC> in <SPC> lookup : <NL>              lookup [ s [ i ] ] <SPC> = <SPC> t [ i ] <NL>          elif <SPC> lookup [ s [ i ] ] <SPC> != <SPC> t [ i ] : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> CombinationIterator ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> characters , <SPC> combinationLength ) : <NL> <NL> <TAB> self . __it <SPC> = <SPC> itertools . combinations ( characters , <SPC> combinationLength ) <NL> <TAB> self . __curr <SPC> = <SPC> None <NL> <TAB> self . __last <SPC> = <SPC> characters [ - combinationLength : ] <NL> <NL> <TAB> def <SPC> next ( self ) : <NL> <NL> <TAB> self . __curr <SPC> = <SPC> "" . join ( self . __it . next ( ) ) <NL> <TAB> return <SPC> self . __curr <NL> <NL> <TAB> def <SPC> hasNext ( self ) : <NL> <NL> <TAB> return <SPC> self . __curr <SPC> != <SPC> self . __last <NL> <NL> <NL> import <SPC> functools <NL> <NL> <NL> class <SPC> CombinationIterator2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> characters , <SPC> combinationLength ) : <NL> <NL> <TAB> self . __characters <SPC> = <SPC> characters <NL> <TAB> self . __combinationLength <SPC> = <SPC> combinationLength <NL> <TAB> self . __it <SPC> = <SPC> self . __iterative_backtracking ( ) <NL> <TAB> self . __curr <SPC> = <SPC> None <NL> <TAB> self . __last <SPC> = <SPC> characters [ - combinationLength : ] <NL> <NL> <TAB> def <SPC> __iterative_backtracking ( self ) : <NL> <NL> <TAB> def <SPC> conquer ( ) : <NL>          if <SPC> len ( curr ) <SPC> == <SPC> self . __combinationLength : <NL>              return <SPC> curr <NL> <NL> <TAB> def <SPC> prev_divide ( c ) : <NL>          curr . append ( c ) <NL> <NL> <TAB> def <SPC> divide ( i ) : <NL>          if <SPC> len ( curr ) <SPC> != <SPC> self . __combinationLength : <NL>              for <SPC> j <SPC> in <SPC> reversed ( <NL>                  xrange ( <NL>                      i , <NL>                      len ( self . __characters ) <NL>                      - <SPC> ( self . __combinationLength <SPC> - <SPC> len ( curr ) <SPC> - <SPC> 1 ) , <NL>                  ) <NL>              ) : <NL>                  stk . append ( functools . partial ( post_divide ) ) <NL>                  stk . append ( functools . partial ( divide , <SPC> j <SPC> + <SPC> 1 ) ) <NL>                  stk . append ( functools . partial ( <NL>                      prev_divide , <SPC> self . __characters [ j ] ) ) <NL>          stk . append ( functools . partial ( conquer ) ) <NL> <NL> <TAB> def <SPC> post_divide ( ) : <NL>          curr . pop ( ) <NL> <NL> <TAB> curr <SPC> = <SPC> [ ] <NL> <TAB> stk <SPC> = <SPC> [ functools . partial ( divide , <SPC> 0 ) ] <NL> <TAB> while <SPC> stk : <NL>          result <SPC> = <SPC> stk . pop ( ) ( ) <NL>          if <SPC> result <SPC> is <SPC> not <SPC> None : <NL>              yield <SPC> result <NL> <NL> <TAB> def <SPC> next ( self ) : <NL> <NL> <TAB> self . __curr <SPC> = <SPC> "" . join ( next ( self . __it ) ) <NL> <TAB> return <SPC> self . __curr <NL> <NL> <TAB> def <SPC> hasNext ( self ) : <NL> <NL> <TAB> return <SPC> self . __curr <SPC> != <SPC> self . __last <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numJewelsInStones ( self , <SPC> J , <SPC> S ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( J ) <NL> <TAB> return <SPC> sum ( s <SPC> in <SPC> lookup <SPC> for <SPC> s <SPC> in <SPC> S ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> jump ( self , <SPC> A ) : <NL> <TAB> jump_count <SPC> = <SPC> 0 <NL> <TAB> reachable <SPC> = <SPC> 0 <NL> <TAB> curr_reachable <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> length <SPC> in <SPC> enumerate ( A ) : <NL>          if <SPC> i <SPC> > <SPC> reachable : <NL>              return <SPC> - 1 <NL>          if <SPC> i <SPC> > <SPC> curr_reachable : <NL>              curr_reachable <SPC> = <SPC> reachable <NL>              jump_count <SPC> += <SPC> 1 <NL>          reachable <SPC> = <SPC> max ( reachable , <SPC> i <SPC> + <SPC> length ) <NL> <TAB> return <SPC> jump_count <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canReach ( self , <SPC> arr , <SPC> start ) : <NL> <NL> <TAB> q , <SPC> lookup <SPC> = <SPC> collections . deque ( [ start ] ) , <SPC> set ( [ start ] ) <NL> <TAB> while <SPC> q : <NL>          i <SPC> = <SPC> q . popleft ( ) <NL>          if <SPC> not <SPC> arr [ i ] : <NL>              return <SPC> True <NL>          for <SPC> j <SPC> in <SPC> [ i <SPC> - <SPC> arr [ i ] , <SPC> i <SPC> + <SPC> arr [ i ] ] : <NL>              if <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> len ( arr ) <SPC> and <SPC> j <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( j ) <NL>                  q . append ( j ) <NL> <TAB> return <SPC> False <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minJumps ( self , <SPC> arr ) : <NL> <NL> <TAB> groups <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( arr ) : <NL>          groups [ x ] . append ( i ) <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ ( 0 , <SPC> 0 ) ] ) <NL> <TAB> lookup <SPC> = <SPC> set ( [ 0 ] ) <NL> <TAB> while <SPC> q : <NL>          pos , <SPC> step <SPC> = <SPC> q . popleft ( ) <NL>          if <SPC> pos <SPC> == <SPC> len ( arr ) <SPC> - <SPC> 1 : <NL>              break <NL>          neighbors <SPC> = <SPC> set ( groups [ arr [ pos ] ] <SPC> + <SPC> [ pos <SPC> - <SPC> 1 , <SPC> pos <SPC> + <SPC> 1 ] ) <NL>          groups [ arr [ pos ] ] <SPC> = <SPC> [ ] <NL>          for <SPC> p <SPC> in <SPC> neighbors : <NL>              if <SPC> p <SPC> in <SPC> lookup <SPC> or <SPC> not <SPC> 0 <SPC> <= <SPC> p <SPC> < <SPC> len ( arr ) : <NL>                  continue <NL>              lookup . add ( p ) <NL>              q . append ( ( p , <SPC> step <SPC> + <SPC> 1 ) ) <NL> <TAB> return <SPC> step <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxJumps ( self , <SPC> arr , <SPC> d ) : <NL> <NL> <TAB> def <SPC> dp ( arr , <SPC> d , <SPC> i , <SPC> left , <SPC> right , <SPC> lookup ) : <NL>          if <SPC> lookup [ i ] : <NL>              return <SPC> lookup [ i ] <NL>          lookup [ i ] <SPC> = <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> itertools . chain ( left [ i ] , <SPC> right [ i ] ) : <NL> <NL>              lookup [ i ] <SPC> = <SPC> max ( lookup [ i ] , <SPC> dp ( arr , <SPC> d , <SPC> j , <SPC> left , <SPC> right , <SPC> lookup ) <SPC> + <SPC> 1 ) <NL>          return <SPC> lookup [ i ] <NL> <NL> <TAB> left , <SPC> decreasing_dq <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( arr ) ) ] , <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( arr ) ) : <NL>          if <SPC> decreasing_dq <SPC> and <SPC> i <SPC> - <SPC> decreasing_dq [ 0 ] <SPC> == <SPC> d <SPC> + <SPC> 1 : <NL>              decreasing_dq . popleft ( ) <NL>          while <SPC> decreasing_dq <SPC> and <SPC> arr [ decreasing_dq [ - 1 ] ] <SPC> < <SPC> arr [ i ] : <NL>              if <SPC> left [ i ] <SPC> and <SPC> arr [ left [ i ] [ - 1 ] ] <SPC> != <SPC> arr [ decreasing_dq [ - 1 ] ] : <NL>                  left [ i ] <SPC> = <SPC> [ ] <NL>              left [ i ] . append ( decreasing_dq . pop ( ) ) <NL>          decreasing_dq . append ( i ) <NL> <TAB> right , <SPC> decreasing_dq <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( arr ) ) ] , <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( arr ) ) ) : <NL>          if <SPC> decreasing_dq <SPC> and <SPC> decreasing_dq [ 0 ] <SPC> - <SPC> i <SPC> == <SPC> d <SPC> + <SPC> 1 : <NL>              decreasing_dq . popleft ( ) <NL>          while <SPC> decreasing_dq <SPC> and <SPC> arr [ decreasing_dq [ - 1 ] ] <SPC> < <SPC> arr [ i ] : <NL>              if <SPC> right [ i ] <SPC> and <SPC> arr [ right [ i ] [ - 1 ] ] <SPC> != <SPC> arr [ decreasing_dq [ - 1 ] ] : <NL>                  right [ i ] <SPC> = <SPC> [ ] <NL>              right [ i ] . append ( decreasing_dq . pop ( ) ) <NL>          decreasing_dq . append ( i ) <NL> <NL> <TAB> lookup <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( arr ) <NL> <TAB> return <SPC> max ( <NL>          itertools . imap ( <NL>              lambda <SPC> x : <SPC> dp ( arr , <SPC> d , <SPC> x , <SPC> left , <SPC> right , <SPC> lookup ) , <SPC> xrange ( len ( arr ) ) <NL>          ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxJumps ( self , <SPC> arr , <SPC> d ) : <NL> <NL> <TAB> left , <SPC> decreasing_stk <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( arr ) ) ] , <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( arr ) ) : <NL>          while <SPC> decreasing_stk <SPC> and <SPC> arr [ decreasing_stk [ - 1 ] ] <SPC> < <SPC> arr [ i ] : <NL>              if <SPC> i <SPC> - <SPC> decreasing_stk [ - 1 ] <SPC> <= <SPC> d : <NL>                  if <SPC> left [ i ] <SPC> and <SPC> arr [ left [ i ] [ - 1 ] ] <SPC> != <SPC> arr [ decreasing_stk [ - 1 ] ] : <NL>                      left [ i ] <SPC> = <SPC> [ ] <NL>                  left [ i ] . append ( decreasing_stk [ - 1 ] ) <NL>              decreasing_stk . pop ( ) <NL>          decreasing_stk . append ( i ) <NL> <TAB> right , <SPC> decreasing_stk <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( arr ) ) ] , <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( arr ) ) ) : <NL>          while <SPC> decreasing_stk <SPC> and <SPC> arr [ decreasing_stk [ - 1 ] ] <SPC> < <SPC> arr [ i ] : <NL>              if <SPC> decreasing_stk [ - 1 ] <SPC> - <SPC> i <SPC> <= <SPC> d : <NL>                  if <SPC> right [ i ] <SPC> and <SPC> arr [ right [ i ] [ - 1 ] ] <SPC> != <SPC> arr [ decreasing_stk [ - 1 ] ] : <NL>                      right [ i ] <SPC> = <SPC> [ ] <NL>                  right [ i ] . append ( decreasing_stk [ - 1 ] ) <NL>              decreasing_stk . pop ( ) <NL>          decreasing_stk . append ( i ) <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( arr ) <NL> <TAB> for <SPC> a , <SPC> i <SPC> in <SPC> sorted ( [ a , <SPC> i ] <SPC> for <SPC> i , <SPC> a <SPC> in <SPC> enumerate ( arr ) ) : <NL>          dp [ i ] <SPC> = <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> itertools . chain ( left [ i ] , <SPC> right [ i ] ) : <NL> <NL>              dp [ i ] <SPC> = <SPC> max ( dp [ i ] , <SPC> dp [ j ] <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> max ( dp ) <NL> <NL> <NL> class <SPC> SegmentTree ( object ) : <NL> <TAB> def <SPC> __init__ ( <NL>          self , <NL>          N , <NL>          build_fn = lambda <SPC> x , <SPC> y : <SPC> [ y ] <SPC> * <SPC> ( 2 <SPC> * <SPC> x ) , <NL>          query_fn = max , <NL>          update_fn = lambda <SPC> x , <SPC> y : <SPC> y , <NL>          default_val = 0 , <NL> <TAB> ) : <NL> <TAB> self . N <SPC> = <SPC> N <NL> <TAB> self . H <SPC> = <SPC> ( N <SPC> - <SPC> 1 ) . bit_length ( ) <NL> <TAB> self . query_fn <SPC> = <SPC> query_fn <NL> <TAB> self . update_fn <SPC> = <SPC> update_fn <NL> <TAB> self . default_val <SPC> = <SPC> default_val <NL> <TAB> self . tree <SPC> = <SPC> build_fn ( N , <SPC> default_val ) <NL> <TAB> self . lazy <SPC> = <SPC> [ None ] <SPC> * <SPC> N <NL> <NL> <TAB> def <SPC> __apply ( self , <SPC> x , <SPC> val ) : <NL> <TAB> self . tree [ x ] <SPC> = <SPC> self . update_fn ( self . tree [ x ] , <SPC> val ) <NL> <TAB> if <SPC> x <SPC> < <SPC> self . N : <NL>          self . lazy [ x ] <SPC> = <SPC> self . update_fn ( self . lazy [ x ] , <SPC> val ) <NL> <NL> <TAB> def <SPC> update ( self , <SPC> L , <SPC> R , <SPC> h ) : <NL> <NL> <TAB> def <SPC> pull ( x ) : <NL>          while <SPC> x <SPC> > <SPC> 1 : <NL>              x <SPC> //= <SPC> 2 <NL>              self . tree [ x ] <SPC> = <SPC> self . query_fn ( <NL>                  self . tree [ x <SPC> * <SPC> 2 ] , <SPC> self . tree [ x <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] ) <NL>              if <SPC> self . lazy [ x ] <SPC> is <SPC> not <SPC> None : <NL>                  self . tree [ x ] <SPC> = <SPC> self . update_fn ( self . tree [ x ] , <SPC> self . lazy [ x ] ) <NL> <NL> <TAB> L <SPC> += <SPC> self . N <NL> <TAB> R <SPC> += <SPC> self . N <NL> <TAB> L0 , <SPC> R0 <SPC> = <SPC> L , <SPC> R <NL> <TAB> while <SPC> L <SPC> <= <SPC> R : <NL>          if <SPC> L <SPC> & <SPC> 1 : <NL>              self . __apply ( L , <SPC> h ) <NL>              L <SPC> += <SPC> 1 <NL>          if <SPC> R <SPC> & <SPC> 1 <SPC> == <SPC> 0 : <NL>              self . __apply ( R , <SPC> h ) <NL>              R <SPC> -= <SPC> 1 <NL>          L <SPC> //= <SPC> 2 <NL>          R <SPC> //= <SPC> 2 <NL> <TAB> pull ( L0 ) <NL> <TAB> pull ( R0 ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> L , <SPC> R ) : <NL> <NL> <TAB> def <SPC> push ( x ) : <NL>          n <SPC> = <SPC> 2 <SPC> ** <SPC> self . H <NL>          while <SPC> n <SPC> != <SPC> 1 : <NL>              y <SPC> = <SPC> x <SPC> // <SPC> n <NL>              if <SPC> self . lazy [ y ] <SPC> is <SPC> not <SPC> None : <NL>                  self . __apply ( y <SPC> * <SPC> 2 , <SPC> self . lazy [ y ] ) <NL>                  self . __apply ( y <SPC> * <SPC> 2 <SPC> + <SPC> 1 , <SPC> self . lazy [ y ] ) <NL>                  self . lazy [ y ] <SPC> = <SPC> None <NL>              n <SPC> //= <SPC> 2 <NL> <NL> <TAB> result <SPC> = <SPC> self . default_val <NL> <TAB> if <SPC> L <SPC> > <SPC> R : <NL>          return <SPC> result <NL> <NL> <TAB> L <SPC> += <SPC> self . N <NL> <TAB> R <SPC> += <SPC> self . N <NL> <TAB> push ( L ) <NL> <TAB> push ( R ) <NL> <TAB> while <SPC> L <SPC> <= <SPC> R : <NL>          if <SPC> L <SPC> & <SPC> 1 : <NL>              result <SPC> = <SPC> self . query_fn ( result , <SPC> self . tree [ L ] ) <NL>              L <SPC> += <SPC> 1 <NL>          if <SPC> R <SPC> & <SPC> 1 <SPC> == <SPC> 0 : <NL>              result <SPC> = <SPC> self . query_fn ( result , <SPC> self . tree [ R ] ) <NL>              R <SPC> -= <SPC> 1 <NL>          L <SPC> //= <SPC> 2 <NL>          R <SPC> //= <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> __str__ ( self ) : <NL> <TAB> showList <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . N ) : <NL>          showList . append ( self . query ( i , <SPC> i ) ) <NL> <TAB> return <SPC> "," . join ( map ( str , <SPC> showList ) ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> maxJumps ( self , <SPC> arr , <SPC> d ) : <NL> <NL> <TAB> left , <SPC> decreasing_stk <SPC> = <SPC> range ( len ( arr ) ) , <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( arr ) ) : <NL>          while <SPC> decreasing_stk <SPC> and <SPC> arr [ decreasing_stk [ - 1 ] ] <SPC> < <SPC> arr [ i ] : <NL>              if <SPC> i <SPC> - <SPC> decreasing_stk [ - 1 ] <SPC> <= <SPC> d : <NL>                  left [ i ] <SPC> = <SPC> decreasing_stk [ - 1 ] <NL>              decreasing_stk . pop ( ) <NL>          decreasing_stk . append ( i ) <NL> <TAB> right , <SPC> decreasing_stk <SPC> = <SPC> range ( len ( arr ) ) , <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( arr ) ) ) : <NL>          while <SPC> decreasing_stk <SPC> and <SPC> arr [ decreasing_stk [ - 1 ] ] <SPC> < <SPC> arr [ i ] : <NL>              if <SPC> decreasing_stk [ - 1 ] <SPC> - <SPC> i <SPC> <= <SPC> d : <NL>                  right [ i ] <SPC> = <SPC> decreasing_stk [ - 1 ] <NL>              decreasing_stk . pop ( ) <NL>          decreasing_stk . append ( i ) <NL> <NL> <TAB> segment_tree <SPC> = <SPC> SegmentTree ( len ( arr ) ) <NL> <TAB> for <SPC> _ , <SPC> i <SPC> in <SPC> sorted ( [ x , <SPC> i ] <SPC> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( arr ) ) : <NL>          segment_tree . update ( i , <SPC> i , <SPC> segment_tree . query ( left [ i ] , <SPC> right [ i ] ) <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> segment_tree . query ( 0 , <SPC> len ( arr ) <SPC> - <SPC> 1 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxResult ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> score <SPC> = <SPC> 0 <NL> <TAB> dq <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          if <SPC> dq <SPC> and <SPC> dq [ 0 ] [ 0 ] <SPC> == <SPC> i <SPC> - <SPC> k <SPC> - <SPC> 1 : <NL>              dq . popleft ( ) <NL>          score <SPC> = <SPC> num <SPC> if <SPC> not <SPC> dq <SPC> else <SPC> dq [ 0 ] [ 1 ] <SPC> + <SPC> num <NL>          while <SPC> dq <SPC> and <SPC> dq [ - 1 ] [ 1 ] <SPC> <= <SPC> score : <NL>              dq . pop ( ) <NL>          dq . append ( ( i , <SPC> score ) ) <NL> <TAB> return <SPC> score <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> canJump ( self , <SPC> A ) : <NL> <TAB> reachable <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> length <SPC> in <SPC> enumerate ( A ) : <NL>          if <SPC> i <SPC> > <SPC> reachable : <NL>              break <NL>          reachable <SPC> = <SPC> max ( reachable , <SPC> i <SPC> + <SPC> length ) <NL> <TAB> return <SPC> reachable <SPC> >= <SPC> len ( A ) <SPC> - <SPC> 1 <NL> <NL> <NL> from <SPC> random <SPC> import <SPC> randint <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kClosest ( self , <SPC> points , <SPC> K ) : <NL> <NL> <TAB> def <SPC> dist ( point ) : <NL>          return <SPC> point [ 0 ] <SPC> ** <SPC> 2 <SPC> + <SPC> point [ 1 ] <SPC> ** <SPC> 2 <NL> <NL> <TAB> def <SPC> kthElement ( nums , <SPC> k , <SPC> compare ) : <NL>          def <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare ) : <NL>              new_pivot_idx <SPC> = <SPC> left <NL>              nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>                  if <SPC> compare ( nums [ i ] , <SPC> nums [ right ] ) : <NL>                      nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                      new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>              nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>              return <SPC> new_pivot_idx <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> PartitionAroundPivot ( <NL>                  left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare <NL>              ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> k : <NL>                  return <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> k : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> kthElement ( points , <SPC> K <SPC> - <SPC> 1 , <SPC> lambda <SPC> a , <SPC> b : <SPC> dist ( a ) <SPC> < <SPC> dist ( b ) ) <NL> <TAB> return <SPC> points [ : K ] <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> kClosest ( self , <SPC> points , <SPC> K ) : <NL> <NL> <TAB> def <SPC> dist ( point ) : <NL>          return <SPC> point [ 0 ] <SPC> ** <SPC> 2 <SPC> + <SPC> point [ 1 ] <SPC> ** <SPC> 2 <NL> <NL> <TAB> max_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> point <SPC> in <SPC> points : <NL>          heapq . heappush ( max_heap , <SPC> ( - dist ( point ) , <SPC> point ) ) <NL>          if <SPC> len ( max_heap ) <SPC> > <SPC> K : <NL>              heapq . heappop ( max_heap ) <NL> <TAB> return <SPC> [ heapq . heappop ( max_heap ) [ 1 ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( max_heap ) ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kConcatenationMaxSum ( self , <SPC> arr , <SPC> k ) : <NL> <NL> <TAB> def <SPC> max_sub_k_array ( arr , <SPC> k ) : <NL>          result , <SPC> curr <SPC> = <SPC> float ( "-inf" ) , <SPC> float ( "-inf" ) <NL>          for <SPC> _ <SPC> in <SPC> xrange ( k ) : <NL>              for <SPC> x <SPC> in <SPC> arr : <NL>                  curr <SPC> = <SPC> max ( curr <SPC> + <SPC> x , <SPC> x ) <NL>                  result <SPC> = <SPC> max ( result , <SPC> curr ) <NL>          return <SPC> result <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> if <SPC> k <SPC> == <SPC> 1 : <NL>          return <SPC> max ( max_sub_k_array ( arr , <SPC> 1 ) , <SPC> 0 ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> ( max ( max_sub_k_array ( arr , <SPC> 2 ) , <SPC> 0 ) <SPC> + <SPC> ( k <SPC> - <SPC> 2 ) <SPC> * <SPC> max ( sum ( arr ) , <SPC> 0 ) ) <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findPairs ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> if <SPC> k <SPC> < <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> result , <SPC> lookup <SPC> = <SPC> set ( ) , <SPC> set ( ) <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          if <SPC> num <SPC> - <SPC> k <SPC> in <SPC> lookup : <NL>              result . add ( num <SPC> - <SPC> k ) <NL>          if <SPC> num <SPC> + <SPC> k <SPC> in <SPC> lookup : <NL>              result . add ( num ) <NL>          lookup . add ( num ) <NL> <TAB> return <SPC> len ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kEmptySlots ( self , <SPC> flowers , <SPC> k ) : <NL> <NL> <TAB> days <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( flowers ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( flowers ) ) : <NL>          days [ flowers [ i ] <SPC> - <SPC> 1 ] <SPC> = <SPC> i <NL> <TAB> result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> i , <SPC> left , <SPC> right <SPC> = <SPC> 0 , <SPC> 0 , <SPC> k <SPC> + <SPC> 1 <NL> <TAB> while <SPC> right <SPC> < <SPC> len ( days ) : <NL>          if <SPC> days [ i ] <SPC> < <SPC> days [ left ] <SPC> or <SPC> days [ i ] <SPC> <= <SPC> days [ right ] : <NL>              if <SPC> i <SPC> == <SPC> right : <NL>                  result <SPC> = <SPC> min ( result , <SPC> max ( days [ left ] , <SPC> days [ right ] ) ) <NL>              left , <SPC> right <SPC> = <SPC> i , <SPC> k <SPC> + <SPC> 1 <SPC> + <SPC> i <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> - 1 <SPC> if <SPC> result <SPC> == <SPC> float ( "inf" ) <SPC> else <SPC> result <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kInversePairs ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> M <SPC> = <SPC> 1000000007 <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( k <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          dp [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( k <SPC> + <SPC> 1 ) <NL>          dp [ i <SPC> % <SPC> 2 ] [ 0 ] <SPC> = <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> k <SPC> + <SPC> 1 ) : <NL>              dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> ( dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] ) <SPC> % <SPC> M <NL>              if <SPC> j <SPC> - <SPC> i <SPC> >= <SPC> 0 : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> ( dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> - <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> i ] ) <SPC> % <SPC> M <NL> <TAB> return <SPC> dp [ n <SPC> % <SPC> 2 ] [ k ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kSimilarity ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> def <SPC> neighbors ( s , <SPC> B ) : <NL>          for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>              if <SPC> c <SPC> != <SPC> B [ i ] : <NL>                  break <NL>          t <SPC> = <SPC> list ( s ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( s ) ) : <NL>              if <SPC> t [ j ] <SPC> == <SPC> B [ i ] : <NL>                  t [ i ] , <SPC> t [ j ] <SPC> = <SPC> t [ j ] , <SPC> t [ i ] <NL>                  yield <SPC> "" . join ( t ) <NL>                  t [ j ] , <SPC> t [ i ] <SPC> = <SPC> t [ i ] , <SPC> t [ j ] <NL> <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ A ] ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> q : <NL>          for <SPC> _ <SPC> in <SPC> xrange ( len ( q ) ) : <NL>              s <SPC> = <SPC> q . popleft ( ) <NL>              if <SPC> s <SPC> == <SPC> B : <NL>                  return <SPC> result <NL>              for <SPC> t <SPC> in <SPC> neighbors ( s , <SPC> B ) : <NL>                  if <SPC> t <SPC> not <SPC> in <SPC> lookup : <NL>                      lookup . add ( t ) <NL>                      q . append ( t ) <NL>          result <SPC> += <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findKthNumber ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <NL> <TAB> cnts <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 10 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> 10 ) : <NL>          cnts [ i ] <SPC> = <SPC> cnts [ i <SPC> - <SPC> 1 ] <SPC> * <SPC> 10 <SPC> + <SPC> 1 <NL> <NL> <TAB> nums <SPC> = <SPC> [ ] <NL> <TAB> i <SPC> = <SPC> n <NL> <TAB> while <SPC> i : <NL>          nums . append ( i <SPC> % <SPC> 10 ) <NL>          i <SPC> /= <SPC> 10 <NL> <NL> <TAB> total , <SPC> target <SPC> = <SPC> n , <SPC> 0 <NL> <TAB> i <SPC> = <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> i <SPC> >= <SPC> 0 <SPC> and <SPC> k <SPC> > <SPC> 0 : <NL>          target <SPC> = <SPC> target <SPC> * <SPC> 10 <SPC> + <SPC> nums [ i ] <NL>          start <SPC> = <SPC> int ( i <SPC> == <SPC> len ( nums ) <SPC> - <SPC> 1 ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( start , <SPC> 10 ) : <NL>              candidate <SPC> = <SPC> result <SPC> * <SPC> 10 <SPC> + <SPC> j <NL>              if <SPC> candidate <SPC> < <SPC> target : <NL>                  num <SPC> = <SPC> cnts [ i <SPC> + <SPC> 1 ] <NL>              elif <SPC> candidate <SPC> > <SPC> target : <NL>                  num <SPC> = <SPC> cnts [ i ] <NL>              else : <NL>                  num <SPC> = <SPC> total <SPC> - <SPC> cnts [ i <SPC> + <SPC> 1 ] <SPC> * <SPC> ( j <SPC> - <SPC> start ) <SPC> - <SPC> cnts [ i ] <SPC> * <SPC> ( 9 <SPC> - <SPC> j ) <NL>              if <SPC> k <SPC> > <SPC> num : <NL>                  k <SPC> -= <SPC> num <NL>              else : <NL>                  result <SPC> = <SPC> candidate <NL>                  k <SPC> -= <SPC> 1 <NL>                  total <SPC> = <SPC> num <SPC> - <SPC> 1 <NL>                  break <NL>          i <SPC> -= <SPC> 1 <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findKthNumber ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> def <SPC> count ( n , <SPC> prefix ) : <NL>          result , <SPC> number <SPC> = <SPC> 0 , <SPC> 1 <NL>          while <SPC> prefix <SPC> <= <SPC> n : <NL>              result <SPC> += <SPC> number <NL>              prefix <SPC> *= <SPC> 10 <NL>              number <SPC> *= <SPC> 10 <NL>          result <SPC> -= <SPC> max ( number <SPC> / <SPC> 10 <SPC> - <SPC> ( n <SPC> - <SPC> prefix <SPC> / <SPC> 10 <SPC> + <SPC> 1 ) , <SPC> 0 ) <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> findKthNumberHelper ( n , <SPC> k , <SPC> cur , <SPC> index ) : <NL>          if <SPC> cur : <NL>              index <SPC> += <SPC> 1 <NL>              if <SPC> index <SPC> == <SPC> k : <NL>                  return <SPC> ( cur , <SPC> index ) <NL> <NL>          i <SPC> = <SPC> int ( cur <SPC> == <SPC> 0 ) <NL>          while <SPC> i <SPC> <= <SPC> 9 : <NL>              cur <SPC> = <SPC> cur <SPC> * <SPC> 10 <SPC> + <SPC> i <NL>              cnt <SPC> = <SPC> count ( n , <SPC> cur ) <NL>              if <SPC> k <SPC> > <SPC> cnt <SPC> + <SPC> index : <NL>                  index <SPC> += <SPC> cnt <NL>              elif <SPC> cur <SPC> <= <SPC> n : <NL>                  result <SPC> = <SPC> findKthNumberHelper ( n , <SPC> k , <SPC> cur , <SPC> index ) <NL>                  if <SPC> result [ 0 ] : <NL>                      return <SPC> result <NL>              i <SPC> += <SPC> 1 <NL>              cur <SPC> /= <SPC> 10 <NL>          return <SPC> ( 0 , <SPC> index ) <NL> <NL> <TAB> return <SPC> findKthNumberHelper ( n , <SPC> k , <SPC> 0 , <SPC> 0 ) [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kthSmallestPrimeFraction ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> def <SPC> check ( mid , <SPC> A , <SPC> K , <SPC> result ) : <NL>          tmp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 <NL>          count <SPC> = <SPC> 0 <NL>          j <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>              while <SPC> j <SPC> < <SPC> len ( A ) : <NL>                  if <SPC> i <SPC> < <SPC> j <SPC> and <SPC> A [ i ] <SPC> < <SPC> A [ j ] <SPC> * <SPC> mid : <NL>                      if <SPC> tmp [ 0 ] <SPC> == <SPC> 0 <SPC> or <SPC> tmp [ 0 ] <SPC> * <SPC> A [ j ] <SPC> < <SPC> tmp [ 1 ] <SPC> * <SPC> A [ i ] : <NL>                          tmp [ 0 ] <SPC> = <SPC> A [ i ] <NL>                          tmp [ 1 ] <SPC> = <SPC> A [ j ] <NL>                      break <NL>                  j <SPC> += <SPC> 1 <NL>              count <SPC> += <SPC> len ( A ) <SPC> - <SPC> j <NL>          if <SPC> count <SPC> == <SPC> K : <NL>              result [ : ] <SPC> = <SPC> tmp <NL>          return <SPC> count <SPC> >= <SPC> K <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0.0 , <SPC> 1.0 <NL> <TAB> while <SPC> right <SPC> - <SPC> left <SPC> > <SPC> 1e-8 : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2.0 <NL>          if <SPC> check ( mid , <SPC> A , <SPC> K , <SPC> result ) : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <NL>          if <SPC> result : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kthGrammar ( self , <SPC> N , <SPC> K ) : <NL> <NL> <TAB> def <SPC> bitCount ( n ) : <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> n : <NL>              n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL>              result <SPC> += <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> bitCount ( K <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findWords ( self , <SPC> words ) : <NL> <NL> <TAB> rows <SPC> = <SPC> [ <NL>          set ( [ "q" , <SPC> "w" , <SPC> "e" , <SPC> "r" , <SPC> "t" , <SPC> "y" , <SPC> "u" , <SPC> "i" , <SPC> "o" , <SPC> "p" ] ) , <NL>          set ( [ "a" , <SPC> "s" , <SPC> "d" , <SPC> "f" , <SPC> "g" , <SPC> "h" , <SPC> "j" , <SPC> "k" , <SPC> "l" ] ) , <NL>          set ( [ "z" , <SPC> "x" , <SPC> "c" , <SPC> "v" , <SPC> "b" , <SPC> "n" , <SPC> "m" ] ) , <NL> <TAB> ] <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          k <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( rows ) ) : <NL>              if <SPC> word [ 0 ] . lower ( ) <SPC> in <SPC> rows [ i ] : <NL>                  k <SPC> = <SPC> i <NL>                  break <NL>          for <SPC> c <SPC> in <SPC> word : <NL>              if <SPC> c . lower ( ) <SPC> not <SPC> in <SPC> rows [ k ] : <NL>                  break <NL>          else : <NL>              result . append ( word ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findWords ( self , <SPC> words ) : <NL> <NL> <TAB> keyboard_rows <SPC> = <SPC> [ "qwertyuiop" , <SPC> "asdfghjkl" , <SPC> "zxcvbnm" ] <NL> <TAB> single_row_words <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          for <SPC> row <SPC> in <SPC> keyboard_rows : <NL>              if <SPC> all ( letter <SPC> in <SPC> row <SPC> for <SPC> letter <SPC> in <SPC> word . lower ( ) ) : <NL>                  single_row_words . append ( word ) <NL> <TAB> return <SPC> single_row_words <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canVisitAllRooms ( self , <SPC> rooms ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( [ 0 ] ) <NL> <TAB> stack <SPC> = <SPC> [ 0 ] <NL> <TAB> while <SPC> stack : <NL>          node <SPC> = <SPC> stack . pop ( ) <NL>          for <SPC> nei <SPC> in <SPC> rooms [ node ] : <NL>              if <SPC> nei <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( nei ) <NL>                  if <SPC> len ( lookup ) <SPC> == <SPC> len ( rooms ) : <NL>                      return <SPC> True <NL>                  stack . append ( nei ) <NL> <TAB> return <SPC> len ( lookup ) <SPC> == <SPC> len ( rooms ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kidsWithCandies ( self , <SPC> candies , <SPC> extraCandies ) : <NL> <NL> <TAB> max_num <SPC> = <SPC> max ( candies ) <NL> <TAB> return <SPC> [ x <SPC> + <SPC> extraCandies <SPC> >= <SPC> max_num <SPC> for <SPC> x <SPC> in <SPC> candies ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> killProcess ( self , <SPC> pid , <SPC> ppid , <SPC> kill ) : <NL> <NL> <TAB> def <SPC> killAll ( pid , <SPC> children , <SPC> killed ) : <NL>          killed . append ( pid ) <NL>          for <SPC> child <SPC> in <SPC> children [ pid ] : <NL>              killAll ( child , <SPC> children , <SPC> killed ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> children <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( pid ) ) : <NL>          children [ ppid [ i ] ] . add ( pid [ i ] ) <NL> <TAB> killAll ( kill , <SPC> children , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> killProcess ( self , <SPC> pid , <SPC> ppid , <SPC> kill ) : <NL> <NL> <TAB> def <SPC> killAll ( pid , <SPC> children , <SPC> killed ) : <NL>          killed . append ( pid ) <NL>          for <SPC> child <SPC> in <SPC> children [ pid ] : <NL>              killAll ( child , <SPC> children , <SPC> killed ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> children <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( pid ) ) : <NL>          children [ ppid [ i ] ] . add ( pid [ i ] ) <NL> <TAB> q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> q . append ( kill ) <NL> <TAB> while <SPC> q : <NL>          p <SPC> = <SPC> q . popleft ( ) <NL>          result . append ( p ) <NL>          for <SPC> child <SPC> in <SPC> children [ p ] : <NL>              q . append ( child ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> knightDialer ( self , <SPC> N ) : <NL> <NL> <TAB> def <SPC> matrix_expo ( A , <SPC> K ) : <NL>          result <SPC> = <SPC> [ [ int ( i <SPC> == <SPC> j ) <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>                    for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>          while <SPC> K : <NL>              if <SPC> K <SPC> % <SPC> 2 : <NL>                  result <SPC> = <SPC> matrix_mult ( result , <SPC> A ) <NL>              A <SPC> = <SPC> matrix_mult ( A , <SPC> A ) <NL>              K <SPC> /= <SPC> 2 <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> matrix_mult ( A , <SPC> B ) : <NL>          ZB <SPC> = <SPC> zip ( * B ) <NL>          return <SPC> [ <NL>              [ sum ( a <SPC> * <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( row , <SPC> col ) ) <SPC> % <SPC> M <SPC> for <SPC> col <SPC> in <SPC> ZB ] <NL>              for <SPC> row <SPC> in <SPC> A <NL>          ] <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> T <SPC> = <SPC> [ <NL>          [ 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 0 , <SPC> 0 ] , <NL>          [ 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 1 , <SPC> 0 ] , <NL>          [ 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 1 ] , <NL>          [ 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 1 , <SPC> 0 ] , <NL>          [ 1 , <SPC> 0 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 1 ] , <NL>          [ 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 ] , <NL>          [ 1 , <SPC> 1 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 0 ] , <NL>          [ 0 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 0 , <SPC> 0 ] , <NL>          [ 0 , <SPC> 1 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 ] , <NL>          [ 0 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 ] , <NL> <TAB> ] <NL> <TAB> return <SPC> sum ( map ( sum , <SPC> matrix_expo ( T , <SPC> N <SPC> - <SPC> 1 ) ) ) <SPC> % <SPC> M <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> knightDialer ( self , <SPC> N ) : <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> moves <SPC> = <SPC> [ <NL>          [ 4 , <SPC> 6 ] , <NL>          [ 6 , <SPC> 8 ] , <NL>          [ 7 , <SPC> 9 ] , <NL>          [ 4 , <SPC> 8 ] , <NL>          [ 3 , <SPC> 9 , <SPC> 0 ] , <NL>          [ ] , <NL>          [ 1 , <SPC> 7 , <SPC> 0 ] , <NL>          [ 2 , <SPC> 6 ] , <NL>          [ 1 , <SPC> 3 ] , <NL>          [ 2 , <SPC> 4 ] , <NL> <TAB> ] <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 1 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 10 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N <SPC> - <SPC> 1 ) : <NL>          dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 10 <NL>          for <SPC> j <SPC> in <SPC> xrange ( 10 ) : <NL>              for <SPC> nei <SPC> in <SPC> moves [ j ] : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ nei ] <SPC> += <SPC> dp [ i <SPC> % <SPC> 2 ] [ j ] <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ nei ] <SPC> %= <SPC> M <NL> <TAB> return <SPC> sum ( dp [ ( N <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] ) <SPC> % <SPC> M <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> knightProbability ( self , <SPC> N , <SPC> K , <SPC> r , <SPC> c ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ <NL>          [ 1 , <SPC> 2 ] , <NL>          [ 1 , <SPC> - 2 ] , <NL>          [ 2 , <SPC> 1 ] , <NL>          [ 2 , <SPC> - 1 ] , <NL>          [ - 1 , <SPC> 2 ] , <NL>          [ - 1 , <SPC> - 2 ] , <NL>          [ - 2 , <SPC> 1 ] , <NL>          [ - 2 , <SPC> - 1 ] , <NL> <TAB> ] <NL> <TAB> dp <SPC> = <SPC> [ [ [ 1 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( N ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( N ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> step <SPC> in <SPC> xrange ( 1 , <SPC> K <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( N ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( N ) : <NL>                  dp [ step <SPC> % <SPC> 2 ] [ i ] [ j ] <SPC> = <SPC> 0 <NL>                  for <SPC> direction <SPC> in <SPC> directions : <NL>                      rr , <SPC> cc <SPC> = <SPC> i <SPC> + <SPC> direction [ 0 ] , <SPC> j <SPC> + <SPC> direction [ 1 ] <NL>                      if <SPC> 0 <SPC> <= <SPC> cc <SPC> < <SPC> N <SPC> and <SPC> 0 <SPC> <= <SPC> rr <SPC> < <SPC> N : <NL>                          dp [ step <SPC> % <SPC> 2 ] [ i ] [ j ] <SPC> += <SPC> 0.125 <SPC> *                              dp [ ( step <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ rr ] [ cc ] <NL> <NL> <TAB> return <SPC> dp [ K <SPC> % <SPC> 2 ] [ r ] [ c ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minEatingSpeed ( self , <SPC> piles , <SPC> H ) : <NL> <NL> <TAB> def <SPC> possible ( piles , <SPC> H , <SPC> K ) : <NL>          return <SPC> sum ( ( pile <SPC> - <SPC> 1 ) <SPC> // <SPC> K <SPC> + <SPC> 1 <SPC> for <SPC> pile <SPC> in <SPC> piles ) <SPC> <= <SPC> H <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> max ( piles ) <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> possible ( piles , <SPC> H , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> TreeAncestor ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n , <SPC> parent ) : <NL> <NL> <TAB> par <SPC> = <SPC> [ [ p ] <SPC> if <SPC> p <SPC> != <SPC> - 1 <SPC> else <SPC> [ ] <SPC> for <SPC> p <SPC> in <SPC> parent ] <NL> <TAB> q <SPC> = <SPC> [ par [ i ] <SPC> for <SPC> i , <SPC> p <SPC> in <SPC> enumerate ( parent ) <SPC> if <SPC> p <SPC> != <SPC> - 1 ] <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> q : <NL>          new_q <SPC> = <SPC> [ ] <NL>          for <SPC> p <SPC> in <SPC> q : <NL>              if <SPC> not <SPC> ( i <SPC> < <SPC> len ( par [ p [ i ] ] ) ) : <NL>                  continue <NL>              p . append ( par [ p [ i ] ] [ i ] ) <NL>              new_q . append ( p ) <NL>          q <SPC> = <SPC> new_q <NL>          i <SPC> += <SPC> 1 <NL> <TAB> self . __parent <SPC> = <SPC> par <NL> <NL> <TAB> def <SPC> getKthAncestor ( self , <SPC> node , <SPC> k ) : <NL> <NL> <TAB> par , <SPC> i , <SPC> pow_i_of_2 <SPC> = <SPC> self . __parent , <SPC> 0 , <SPC> 1 <NL> <TAB> while <SPC> pow_i_of_2 <SPC> <= <SPC> k : <NL>          if <SPC> k <SPC> & <SPC> pow_i_of_2 : <NL>              if <SPC> not <SPC> ( i <SPC> < <SPC> len ( par [ node ] ) ) : <NL>                  return <SPC> - 1 <NL>              node <SPC> = <SPC> par [ node ] [ i ] <NL>          i <SPC> += <SPC> 1 <NL>          pow_i_of_2 <SPC> *= <SPC> 2 <NL> <TAB> return <SPC> node <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> KthLargest ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> k , <SPC> nums ) : <NL> <NL> <TAB> self . __k <SPC> = <SPC> k <NL> <TAB> self . __min_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> n <SPC> in <SPC> nums : <NL>          self . add ( n ) <NL> <NL> <TAB> def <SPC> add ( self , <SPC> val ) : <NL> <NL> <TAB> heapq . heappush ( self . __min_heap , <SPC> val ) <NL> <TAB> if <SPC> len ( self . __min_heap ) <SPC> > <SPC> self . __k : <NL>          heapq . heappop ( self . __min_heap ) <NL> <TAB> return <SPC> self . __min_heap [ 0 ] <NL> <NL> <NL> from <SPC> random <SPC> import <SPC> randint <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findKthLargest ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> nth_element ( nums , <SPC> n , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) : <NL>          def <SPC> tri_partition ( nums , <SPC> left , <SPC> right , <SPC> target , <SPC> compare ) : <NL>              mid <SPC> = <SPC> left <NL>              while <SPC> mid <SPC> <= <SPC> right : <NL>                  if <SPC> nums [ mid ] <SPC> == <SPC> target : <NL>                      mid <SPC> += <SPC> 1 <NL>                  elif <SPC> compare ( nums [ mid ] , <SPC> target ) : <NL>                      nums [ left ] , <SPC> nums [ mid ] <SPC> = <SPC> nums [ mid ] , <SPC> nums [ left ] <NL>                      left <SPC> += <SPC> 1 <NL>                      mid <SPC> += <SPC> 1 <NL>                  else : <NL>                      nums [ mid ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ mid ] <NL>                      right <SPC> -= <SPC> 1 <NL>              return <SPC> left , <SPC> right <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> randint ( left , <SPC> right ) <NL>              pivot_left , <SPC> pivot_right <SPC> = <SPC> tri_partition ( <NL>                  nums , <SPC> left , <SPC> right , <SPC> nums [ pivot_idx ] , <SPC> compare <NL>              ) <NL>              if <SPC> pivot_left <SPC> <= <SPC> n <SPC> <= <SPC> pivot_right : <NL>                  return <NL>              elif <SPC> pivot_left <SPC> > <SPC> n : <NL>                  right <SPC> = <SPC> pivot_left <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> pivot_right <SPC> + <SPC> 1 <NL> <NL> <TAB> nth_element ( nums , <SPC> k <SPC> - <SPC> 1 , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> > <SPC> b ) <NL> <TAB> return <SPC> nums [ k <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> findKthLargest ( self , <SPC> nums , <SPC> k ) : <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          pivot_idx <SPC> = <SPC> randint ( left , <SPC> right ) <NL>          new_pivot_idx <SPC> = <SPC> self . PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) <NL>          if <SPC> new_pivot_idx <SPC> == <SPC> k <SPC> - <SPC> 1 : <NL>              return <SPC> nums [ new_pivot_idx ] <NL>          elif <SPC> new_pivot_idx <SPC> > <SPC> k <SPC> - <SPC> 1 : <NL>              right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> def <SPC> PartitionAroundPivot ( self , <SPC> left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) : <NL> <TAB> pivot_value <SPC> = <SPC> nums [ pivot_idx ] <NL> <TAB> new_pivot_idx <SPC> = <SPC> left <NL> <TAB> nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>          if <SPC> nums [ i ] <SPC> > <SPC> pivot_value : <NL>              nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>              new_pivot_idx <SPC> += <SPC> 1 <NL> <NL> <TAB> nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL> <TAB> return <SPC> new_pivot_idx <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findKthPositive ( self , <SPC> arr , <SPC> k ) : <NL> <NL> <TAB> def <SPC> check ( arr , <SPC> k , <SPC> x ) : <NL>          return <SPC> arr [ x ] <SPC> - <SPC> ( x <SPC> + <SPC> 1 ) <SPC> < <SPC> k <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( arr ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( arr , <SPC> k , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> ( <NL>          right <SPC> + <SPC> 1 <SPC> + <SPC> k <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> kthSmallest ( self , <SPC> root , <SPC> k ) : <NL> <TAB> s , <SPC> cur , <SPC> rank <SPC> = <SPC> [ ] , <SPC> root , <SPC> 0 <NL> <NL> <TAB> while <SPC> s <SPC> or <SPC> cur : <NL>          if <SPC> cur : <NL>              s . append ( cur ) <NL>              cur <SPC> = <SPC> cur . left <NL>          else : <NL>              cur <SPC> = <SPC> s . pop ( ) <NL>              rank <SPC> += <SPC> 1 <NL>              if <SPC> rank <SPC> == <SPC> k : <NL>                  return <SPC> cur . val <NL>              cur <SPC> = <SPC> cur . right <NL> <NL> <TAB> return <SPC> float ( "-inf" ) <NL> <NL> <NL> from <SPC> itertools <SPC> import <SPC> islice <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> kthSmallest ( self , <SPC> root , <SPC> k ) : <NL> <NL> <TAB> def <SPC> gen_inorder ( root ) : <NL>          if <SPC> root : <NL>              for <SPC> n <SPC> in <SPC> gen_inorder ( root . left ) : <NL>                  yield <SPC> n <NL> <NL>              yield <SPC> root . val <NL> <NL>              for <SPC> n <SPC> in <SPC> gen_inorder ( root . right ) : <NL>                  yield <SPC> n <NL> <NL> <TAB> return <SPC> next ( islice ( gen_inorder ( root ) , <SPC> k <SPC> - <SPC> 1 , <SPC> k ) ) <NL> <NL> <NL> from <SPC> heapq <SPC> import <SPC> heappush , <SPC> heappop <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kthSmallest ( self , <SPC> matrix , <SPC> k ) : <NL> <NL> <TAB> kth_smallest <SPC> = <SPC> 0 <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( i , <SPC> j ) : <NL>          if <SPC> len ( matrix ) <SPC> > <SPC> len ( matrix [ 0 ] ) : <NL>              if <SPC> i <SPC> < <SPC> len ( matrix [ 0 ] ) <SPC> and <SPC> j <SPC> < <SPC> len ( matrix ) : <NL>                  heappush ( min_heap , <SPC> [ matrix [ j ] [ i ] , <SPC> i , <SPC> j ] ) <NL>          else : <NL>              if <SPC> i <SPC> < <SPC> len ( matrix ) <SPC> and <SPC> j <SPC> < <SPC> len ( matrix [ 0 ] ) : <NL>                  heappush ( min_heap , <SPC> [ matrix [ i ] [ j ] , <SPC> i , <SPC> j ] ) <NL> <NL> <TAB> push ( 0 , <SPC> 0 ) <NL> <TAB> while <SPC> min_heap <SPC> and <SPC> k <SPC> > <SPC> 0 : <NL>          kth_smallest , <SPC> i , <SPC> j <SPC> = <SPC> heappop ( min_heap ) <NL>          push ( i , <SPC> j <SPC> + <SPC> 1 ) <NL>          if <SPC> j <SPC> == <SPC> 0 : <NL>              push ( i <SPC> + <SPC> 1 , <SPC> 0 ) <NL>          k <SPC> -= <SPC> 1 <NL> <NL> <TAB> return <SPC> kth_smallest <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kthSmallestPath ( self , <SPC> destination , <SPC> k ) : <NL> <NL> <TAB> def <SPC> nCr ( n , <SPC> r ) : <NL>          if <SPC> n <SPC> < <SPC> r : <NL>              return <SPC> 0 <NL>          if <SPC> n <SPC> - <SPC> r <SPC> < <SPC> r : <NL>              return <SPC> nCr ( n , <SPC> n <SPC> - <SPC> r ) <NL>          c <SPC> = <SPC> 1 <NL>          for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> r <SPC> + <SPC> 1 ) : <NL>              c <SPC> *= <SPC> n <SPC> - <SPC> k <SPC> + <SPC> 1 <NL>              c <SPC> //= <SPC> k <NL>          return <SPC> c <NL> <NL> <TAB> r , <SPC> c <SPC> = <SPC> destination <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> r <SPC> + <SPC> c : <NL>          count <SPC> = <SPC> nCr ( r <SPC> + <SPC> ( c <SPC> - <SPC> 1 ) , <SPC> r ) <NL>          if <SPC> ( <NL>              k <SPC> <= <SPC> count <NL>          ) : <NL>              c <SPC> -= <SPC> 1 <NL>              result . append ( "H" ) <NL>          else : <NL>              k <SPC> -= <SPC> count <NL>              r <SPC> -= <SPC> 1 <NL>              result . append ( "V" ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findKthNumber ( self , <SPC> m , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> def <SPC> count ( target , <SPC> m , <SPC> n ) : <NL>          return <SPC> sum ( min ( target <SPC> // <SPC> i , <SPC> n ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> m <SPC> + <SPC> 1 ) ) <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> m <SPC> * <SPC> n <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> count ( mid , <SPC> m , <SPC> n ) <SPC> >= <SPC> k : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largest1BorderedSquare ( self , <SPC> grid ) : <NL> <NL> <TAB> top , <SPC> left <SPC> = <SPC> [ a [ : ] <SPC> for <SPC> a <SPC> in <SPC> grid ] , <SPC> [ a [ : ] <SPC> for <SPC> a <SPC> in <SPC> grid ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> not <SPC> grid [ i ] [ j ] : <NL>                  continue <NL>              if <SPC> i : <NL>                  top [ i ] [ j ] <SPC> = <SPC> top [ i <SPC> - <SPC> 1 ] [ j ] <SPC> + <SPC> 1 <NL>              if <SPC> j : <NL>                  left [ i ] [ j ] <SPC> = <SPC> left [ i ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 <NL> <TAB> for <SPC> l <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> min ( len ( grid ) , <SPC> len ( grid [ 0 ] ) ) <SPC> + <SPC> 1 ) ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) <SPC> - <SPC> l <SPC> + <SPC> 1 ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) <SPC> - <SPC> l <SPC> + <SPC> 1 ) : <NL>                  if <SPC> ( <NL>                      min ( <NL>                          top [ i <SPC> + <SPC> l <SPC> - <SPC> 1 ] [ j ] , <NL>                          top [ i <SPC> + <SPC> l <SPC> - <SPC> 1 ] [ j <SPC> + <SPC> l <SPC> - <SPC> 1 ] , <NL>                          left [ i ] [ j <SPC> + <SPC> l <SPC> - <SPC> 1 ] , <NL>                          left [ i <SPC> + <SPC> l <SPC> - <SPC> 1 ] [ j <SPC> + <SPC> l <SPC> - <SPC> 1 ] , <NL>                      ) <NL>                      >= <SPC> l <NL>                  ) : <NL>                      return <SPC> l <SPC> * <SPC> l <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestBSTSubtree ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <NL> <TAB> max_size <SPC> = <SPC> [ 1 ] <NL> <NL> <TAB> def <SPC> largestBSTSubtreeHelper ( root ) : <NL>          if <SPC> root . left <SPC> is <SPC> None <SPC> and <SPC> root . right <SPC> is <SPC> None : <NL>              return <SPC> 1 , <SPC> root . val , <SPC> root . val <NL> <NL>          left_size , <SPC> left_min , <SPC> left_max <SPC> = <SPC> 0 , <SPC> root . val , <SPC> root . val <NL>          if <SPC> root . left <SPC> is <SPC> not <SPC> None : <NL>              left_size , <SPC> left_min , <SPC> left_max <SPC> = <SPC> largestBSTSubtreeHelper ( root . left ) <NL> <NL>          right_size , <SPC> right_min , <SPC> right_max <SPC> = <SPC> 0 , <SPC> root . val , <SPC> root . val <NL>          if <SPC> root . right <SPC> is <SPC> not <SPC> None : <NL>              right_size , <SPC> right_min , <SPC> right_max <SPC> = <SPC> largestBSTSubtreeHelper ( <NL>                  root . right ) <NL> <NL>          size <SPC> = <SPC> 0 <NL>          if <SPC> ( <NL>              ( root . left <SPC> is <SPC> None <SPC> or <SPC> left_size <SPC> > <SPC> 0 ) <NL>              and <SPC> ( root . right <SPC> is <SPC> None <SPC> or <SPC> right_size <SPC> > <SPC> 0 ) <NL>              and <SPC> left_max <SPC> <= <SPC> root . val <SPC> <= <SPC> right_min <NL>          ) : <NL>              size <SPC> = <SPC> 1 <SPC> + <SPC> left_size <SPC> + <SPC> right_size <NL>              max_size [ 0 ] <SPC> = <SPC> max ( max_size [ 0 ] , <SPC> size ) <NL> <NL>          return <SPC> size , <SPC> left_min , <SPC> right_max <NL> <NL> <TAB> largestBSTSubtreeHelper ( root ) <NL> <TAB> return <SPC> max_size [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . size <SPC> = <SPC> [ 1 ] <SPC> * <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> self . size [ max ( x_root , <SPC> y_root ) ] <SPC> += <SPC> self . size [ min ( x_root , <SPC> y_root ) ] <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestComponentSize ( self , <SPC> A ) : <NL> <NL> <TAB> def <SPC> primeFactors ( i ) : <NL>          result <SPC> = <SPC> [ ] <NL>          d <SPC> = <SPC> 2 <NL>          if <SPC> i <SPC> % <SPC> d <SPC> == <SPC> 0 : <NL>              while <SPC> i <SPC> % <SPC> d <SPC> == <SPC> 0 : <NL>                  i <SPC> //= <SPC> d <NL>              result . append ( d ) <NL>          d <SPC> = <SPC> 3 <NL>          while <SPC> d <SPC> * <SPC> d <SPC> <= <SPC> i : <NL>              if <SPC> i <SPC> % <SPC> d <SPC> == <SPC> 0 : <NL>                  while <SPC> i <SPC> % <SPC> d <SPC> == <SPC> 0 : <NL>                      i <SPC> //= <SPC> d <NL>                  result . append ( d ) <NL>              d <SPC> += <SPC> 2 <NL>          if <SPC> i <SPC> > <SPC> 2 : <NL>              result . append ( i ) <NL>          return <SPC> result <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( A ) ) <NL> <TAB> nodesWithCommonFactor <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          for <SPC> factor <SPC> in <SPC> primeFactors ( A [ i ] ) : <NL>              if <SPC> factor <SPC> not <SPC> in <SPC> nodesWithCommonFactor : <NL>                  nodesWithCommonFactor [ factor ] <SPC> = <SPC> i <NL>              union_find . union_set ( nodesWithCommonFactor [ factor ] , <SPC> i ) <NL> <TAB> return <SPC> max ( union_find . size ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestDivisibleSubset ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> not <SPC> nums : <NL>          return <SPC> [ ] <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> dp <SPC> = <SPC> [ 1 ] <SPC> * <SPC> len ( nums ) <NL> <TAB> prev <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( nums ) <NL> <TAB> largest_idx <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i ) : <NL>              if <SPC> nums [ i ] <SPC> % <SPC> nums [ j ] <SPC> == <SPC> 0 : <NL>                  if <SPC> dp [ i ] <SPC> < <SPC> dp [ j ] <SPC> + <SPC> 1 : <NL>                      dp [ i ] <SPC> = <SPC> dp [ j ] <SPC> + <SPC> 1 <NL>                      prev [ i ] <SPC> = <SPC> j <NL>          if <SPC> dp [ largest_idx ] <SPC> < <SPC> dp [ i ] : <NL>              largest_idx <SPC> = <SPC> i <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i <SPC> = <SPC> largest_idx <NL> <TAB> while <SPC> i <SPC> != <SPC> - 1 : <NL>          result . append ( nums [ i ] ) <NL>          i <SPC> = <SPC> prev [ i ] <NL> <TAB> return <SPC> result [ : : - 1 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestMerge ( self , <SPC> word1 , <SPC> word2 ) : <NL> <NL> <TAB> q1 <SPC> = <SPC> collections . deque ( word1 ) <NL> <TAB> q2 <SPC> = <SPC> collections . deque ( word2 ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> q1 <SPC> or <SPC> q2 : <NL>          if <SPC> q1 <SPC> > <SPC> q2 : <NL>              result . append ( q1 . popleft ( ) ) <NL>          else : <NL>              result . append ( q2 . popleft ( ) ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestMultipleOfThree ( self , <SPC> digits ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { <NL>          0 : <SPC> [ ] , <NL>          1 : <SPC> [ ( 1 , ) , <SPC> ( 4 , ) , <SPC> ( 7 , ) , <SPC> ( 2 , <SPC> 2 ) , <SPC> ( 5 , <SPC> 2 ) , <SPC> ( 5 , <SPC> 5 ) , <SPC> ( 8 , <SPC> 2 ) , <SPC> ( 8 , <SPC> 5 ) , <SPC> ( 8 , <SPC> 8 ) ] , <NL>          2 : <SPC> [ ( 2 , ) , <SPC> ( 5 , ) , <SPC> ( 8 , ) , <SPC> ( 1 , <SPC> 1 ) , <SPC> ( 4 , <SPC> 1 ) , <SPC> ( 4 , <SPC> 4 ) , <SPC> ( 7 , <SPC> 1 ) , <SPC> ( 7 , <SPC> 4 ) , <SPC> ( 7 , <SPC> 7 ) ] , <NL> <TAB> } <NL> <TAB> count <SPC> = <SPC> collections . Counter ( digits ) <NL> <TAB> for <SPC> deletes <SPC> in <SPC> lookup [ sum ( digits ) <SPC> % <SPC> 3 ] : <NL>          delete_count <SPC> = <SPC> collections . Counter ( deletes ) <NL>          if <SPC> all ( count [ k ] <SPC> >= <SPC> v <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> delete_count . iteritems ( ) ) : <NL>              for <SPC> k , <SPC> v <SPC> in <SPC> delete_count . iteritems ( ) : <NL>                  count [ k ] <SPC> -= <SPC> v <NL>              break <NL> <TAB> result <SPC> = <SPC> "" . join ( str ( d ) <SPC> * <SPC> count [ d ] <SPC> for <SPC> d <SPC> in <SPC> reversed ( xrange ( 10 ) ) ) <NL> <TAB> return <SPC> "0" <SPC> if <SPC> result <SPC> and <SPC> result [ 0 ] <SPC> == <SPC> "0" <SPC> else <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> largestMultipleOfThree ( self , <SPC> digits ) : <NL> <NL> <TAB> def <SPC> candidates_gen ( r ) : <NL>          if <SPC> r <SPC> == <SPC> 0 : <NL>              return <NL>          for <SPC> i <SPC> in <SPC> xrange ( 10 ) : <NL>              yield <SPC> [ i ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( 10 ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 ) : <NL>                  yield <SPC> [ i , <SPC> j ] <NL> <NL> <TAB> count , <SPC> r <SPC> = <SPC> collections . Counter ( digits ) , <SPC> sum ( digits ) <SPC> % <SPC> 3 <NL> <TAB> for <SPC> deletes <SPC> in <SPC> candidates_gen ( r ) : <NL>          delete_count <SPC> = <SPC> collections . Counter ( deletes ) <NL>          if <SPC> sum ( deletes ) <SPC> % <SPC> 3 <SPC> == <SPC> r <SPC> and <SPC> all ( <NL>              count [ k ] <SPC> >= <SPC> v <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> delete_count . iteritems ( ) <NL>          ) : <NL>              for <SPC> k , <SPC> v <SPC> in <SPC> delete_count . iteritems ( ) : <NL>                  count [ k ] <SPC> -= <SPC> v <NL>              break <NL> <TAB> result <SPC> = <SPC> "" . join ( str ( d ) <SPC> * <SPC> count [ d ] <SPC> for <SPC> d <SPC> in <SPC> reversed ( xrange ( 10 ) ) ) <NL> <TAB> return <SPC> "0" <SPC> if <SPC> result <SPC> and <SPC> result [ 0 ] <SPC> == <SPC> "0" <SPC> else <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> dominantIndex ( self , <SPC> nums ) : <NL> <NL> <TAB> m <SPC> = <SPC> max ( nums ) <NL> <TAB> if <SPC> all ( m <SPC> >= <SPC> 2 <SPC> * <SPC> x <SPC> for <SPC> x <SPC> in <SPC> nums <SPC> if <SPC> x <SPC> != <SPC> m ) : <NL>          return <SPC> nums . index ( m ) <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> largestNumber ( self , <SPC> num ) : <NL> <TAB> num <SPC> = <SPC> [ str ( x ) <SPC> for <SPC> x <SPC> in <SPC> num ] <NL> <TAB> num . sort ( cmp = lambda <SPC> x , <SPC> y : <SPC> cmp ( y <SPC> + <SPC> x , <SPC> x <SPC> + <SPC> y ) ) <NL> <TAB> largest <SPC> = <SPC> "" . join ( num ) <NL> <TAB> return <SPC> largest . lstrip ( "0" ) <SPC> or <SPC> "0" <NL> <NL> <NL> class <SPC> Solution_TLE ( object ) : <NL> <TAB> def <SPC> largestPalindrome ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 1 : <NL>          return <SPC> 9 <NL> <NL> <TAB> upper , <SPC> lower <SPC> = <SPC> 10 <SPC> ** <SPC> n <SPC> - <SPC> 1 , <SPC> 10 <SPC> ** <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( lower , <SPC> upper <SPC> + <SPC> 1 ) ) : <NL>          candidate <SPC> = <SPC> int ( str ( i ) <SPC> + <SPC> str ( i ) [ : : - 1 ] ) <NL>          j <SPC> = <SPC> upper <NL>          while <SPC> j <SPC> * <SPC> j <SPC> >= <SPC> candidate : <NL>              if <SPC> candidate <SPC> % <SPC> j <SPC> == <SPC> 0 : <NL>                  return <SPC> candidate <SPC> % <SPC> 1337 <NL>              j <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestPerimeter ( self , <SPC> A ) : <NL> <NL> <TAB> A . sort ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( A ) <SPC> - <SPC> 2 ) ) : <NL>          if <SPC> A [ i ] <SPC> + <SPC> A [ i <SPC> + <SPC> 1 ] <SPC> > <SPC> A [ i <SPC> + <SPC> 2 ] : <NL>              return <SPC> A [ i ] <SPC> + <SPC> A [ i <SPC> + <SPC> 1 ] <SPC> + <SPC> A [ i <SPC> + <SPC> 2 ] <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> orderOfLargestPlusSign ( self , <SPC> N , <SPC> mines ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { tuple ( mine ) <SPC> for <SPC> mine <SPC> in <SPC> mines } <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> N <SPC> for <SPC> _ <SPC> in <SPC> xrange ( N ) ] <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N ) : <NL>          l <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( N ) : <NL>              l <SPC> = <SPC> 0 <SPC> if <SPC> ( i , <SPC> j ) <SPC> in <SPC> lookup <SPC> else <SPC> l <SPC> + <SPC> 1 <NL>              dp [ i ] [ j ] <SPC> = <SPC> l <NL>          l <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( N ) ) : <NL>              l <SPC> = <SPC> 0 <SPC> if <SPC> ( i , <SPC> j ) <SPC> in <SPC> lookup <SPC> else <SPC> l <SPC> + <SPC> 1 <NL>              dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> l ) <NL> <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( N ) : <NL>          l <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( N ) : <NL>              l <SPC> = <SPC> 0 <SPC> if <SPC> ( i , <SPC> j ) <SPC> in <SPC> lookup <SPC> else <SPC> l <SPC> + <SPC> 1 <NL>              dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> l ) <NL>          l <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( N ) ) : <NL>              l <SPC> = <SPC> 0 <SPC> if <SPC> ( i , <SPC> j ) <SPC> in <SPC> lookup <SPC> else <SPC> l <SPC> + <SPC> 1 <NL>              dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> l ) <NL>              result <SPC> = <SPC> max ( result , <SPC> dp [ i ] [ j ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestRectangleArea ( self , <SPC> heights ) : <NL> <NL> <TAB> stk , <SPC> result , <SPC> i <SPC> = <SPC> [ - 1 ] , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( heights ) <SPC> + <SPC> 1 ) : <NL>          while <SPC> stk [ - 1 ] <SPC> != <SPC> - 1 <SPC> and <SPC> ( <NL>              i <SPC> == <SPC> len ( heights ) <SPC> or <SPC> heights [ stk [ - 1 ] ] <SPC> >= <SPC> heights [ i ] <NL>          ) : <NL>              result <SPC> = <SPC> max ( result , <SPC> heights [ stk . pop ( ) ] <SPC> * <SPC> ( ( i <SPC> - <SPC> 1 ) <SPC> - <SPC> stk [ - 1 ] ) ) <NL>          stk . append ( i ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestSubarray ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> left , <SPC> right , <SPC> l <SPC> = <SPC> 0 , <SPC> 1 , <SPC> 0 <NL> <TAB> while <SPC> right <SPC> + <SPC> k <SPC> - <SPC> 1 <SPC> < <SPC> len ( nums ) <SPC> and <SPC> right <SPC> + <SPC> l <SPC> < <SPC> len ( nums ) : <NL>          if <SPC> nums [ left <SPC> + <SPC> l ] <SPC> == <SPC> nums [ right <SPC> + <SPC> l ] : <NL>              l <SPC> += <SPC> 1 <NL>              continue <NL>          if <SPC> nums [ left <SPC> + <SPC> l ] <SPC> > <SPC> nums [ right <SPC> + <SPC> l ] : <NL>              right <SPC> += <SPC> l <SPC> + <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> max ( right , <SPC> min ( left <SPC> + <SPC> l <SPC> + <SPC> 1 , <SPC> len ( nums ) <SPC> - <SPC> k ) ) <NL>              right <SPC> = <SPC> left <SPC> + <SPC> 1 <NL>          l <SPC> = <SPC> 0 <NL> <TAB> return <SPC> nums [ left : <SPC> left <SPC> + <SPC> k ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestSubmatrix ( self , <SPC> matrix ) : <NL> <NL> <TAB> for <SPC> c <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) : <NL>          h <SPC> = <SPC> 0 <NL>          for <SPC> r <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>              h <SPC> = <SPC> h <SPC> + <SPC> 1 <SPC> if <SPC> matrix [ r ] [ c ] <SPC> == <SPC> 1 <SPC> else <SPC> 0 <NL>              matrix [ r ] [ c ] <SPC> = <SPC> h <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> row <SPC> in <SPC> matrix : <NL>          row . sort ( ) <NL>          for <SPC> c <SPC> in <SPC> xrange ( len ( row ) ) : <NL>              result <SPC> = <SPC> max ( result , <SPC> ( len ( row ) <SPC> - <SPC> c ) <SPC> * <SPC> row [ c ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxLengthBetweenEqualCharacters ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> lookup <SPC> = <SPC> - 1 , <SPC> { } <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          result <SPC> = <SPC> max ( result , <SPC> i <SPC> - <SPC> lookup . setdefault ( c , <SPC> i ) <SPC> - <SPC> 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestSumOfAverages ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> accum_sum <SPC> = <SPC> [ A [ 0 ] ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) ) : <NL>          accum_sum . append ( A [ i ] <SPC> + <SPC> accum_sum [ - 1 ] ) <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( A ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> K <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( k <SPC> - <SPC> 1 , <SPC> len ( A ) ) : <NL>              if <SPC> k <SPC> == <SPC> 1 : <NL>                  dp [ k <SPC> % <SPC> 2 ] [ i ] <SPC> = <SPC> float ( accum_sum [ i ] ) <SPC> / <SPC> ( i <SPC> + <SPC> 1 ) <NL>              else : <NL>                  for <SPC> j <SPC> in <SPC> xrange ( k <SPC> - <SPC> 2 , <SPC> i ) : <NL>                      dp [ k <SPC> % <SPC> 2 ] [ i ] <SPC> = <SPC> max ( <NL>                          dp [ k <SPC> % <SPC> 2 ] [ i ] , <NL>                          dp [ ( k <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <NL>                          + <SPC> float ( accum_sum [ i ] <SPC> - <SPC> accum_sum [ j ] ) <SPC> / <SPC> ( i <SPC> - <SPC> j ) , <NL>                      ) <NL> <TAB> return <SPC> dp [ K <SPC> % <SPC> 2 ] [ - 1 ] <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestTimeFromDigits ( self , <SPC> A ) : <NL> <NL> <TAB> result <SPC> = <SPC> "" <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          A [ i ] <SPC> *= <SPC> - 1 <NL> <TAB> A . sort ( ) <NL> <TAB> for <SPC> h1 , <SPC> h2 , <SPC> m1 , <SPC> m2 <SPC> in <SPC> itertools . permutations ( A ) : <NL>          hours <SPC> = <SPC> - ( 10 <SPC> * <SPC> h1 <SPC> + <SPC> h2 ) <NL>          mins <SPC> = <SPC> - ( 10 <SPC> * <SPC> m1 <SPC> + <SPC> m2 ) <NL>          if <SPC> 0 <SPC> <= <SPC> hours <SPC> < <SPC> 24 <SPC> and <SPC> 0 <SPC> <= <SPC> mins <SPC> < <SPC> 60 : <NL>              result <SPC> = <SPC> "{:02}:{:02}" . format ( hours , <SPC> mins ) <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestTriangleArea ( self , <SPC> points ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( points ) <SPC> - <SPC> 2 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( points ) <SPC> - <SPC> 1 ) : <NL>              for <SPC> k <SPC> in <SPC> xrange ( j <SPC> + <SPC> 1 , <SPC> len ( points ) ) : <NL>                  result <SPC> = <SPC> max ( <NL>                      result , <NL>                      0.5 <NL>                      * <SPC> abs ( <NL>                          points [ i ] [ 0 ] <SPC> * <SPC> points [ j ] [ 1 ] <NL>                          + <SPC> points [ j ] [ 0 ] <SPC> * <SPC> points [ k ] [ 1 ] <NL>                          + <SPC> points [ k ] [ 0 ] <SPC> * <SPC> points [ i ] [ 1 ] <NL>                          - <SPC> points [ j ] [ 0 ] <SPC> * <SPC> points [ i ] [ 1 ] <NL>                          - <SPC> points [ k ] [ 0 ] <SPC> * <SPC> points [ j ] [ 1 ] <NL>                          - <SPC> points [ i ] [ 0 ] <SPC> * <SPC> points [ k ] [ 1 ] <NL>                      ) , <NL>                  ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestUniqueNumber ( self , <SPC> A ) : <NL> <NL> <TAB> A . append ( - 1 ) <NL> <TAB> return <SPC> max ( k <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> collections . Counter ( A ) . items ( ) <SPC> if <SPC> v <SPC> == <SPC> 1 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestValsFromLabels ( self , <SPC> values , <SPC> labels , <SPC> num_wanted , <SPC> use_limit ) : <NL> <NL> <TAB> counts <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> val_labs <SPC> = <SPC> zip ( values , <SPC> labels ) <NL> <TAB> val_labs . sort ( reverse = True ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> val , <SPC> lab <SPC> in <SPC> val_labs : <NL>          if <SPC> counts [ lab ] <SPC> >= <SPC> use_limit : <NL>              continue <NL>          result <SPC> += <SPC> val <NL>          counts [ lab ] <SPC> += <SPC> 1 <NL>          num_wanted <SPC> -= <SPC> 1 <NL>          if <SPC> num_wanted <SPC> == <SPC> 0 : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getLastMoment ( self , <SPC> n , <SPC> left , <SPC> right ) : <NL> <NL> <TAB> return <SPC> max ( max ( left <SPC> or <SPC> [ 0 ] ) , <SPC> n <SPC> - <SPC> min ( right <SPC> or <SPC> [ n ] ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lastStoneWeightII ( self , <SPC> stones ) : <NL> <NL> <TAB> dp <SPC> = <SPC> { 0 } <NL> <TAB> for <SPC> stone <SPC> in <SPC> stones : <NL>          dp <SPC> |= <SPC> { stone <SPC> + <SPC> i <SPC> for <SPC> i <SPC> in <SPC> dp } <NL> <TAB> S <SPC> = <SPC> sum ( stones ) <NL> <TAB> return <SPC> min ( abs ( i <SPC> - <SPC> ( S <SPC> - <SPC> i ) ) <SPC> for <SPC> i <SPC> in <SPC> dp ) <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lastStoneWeight ( self , <SPC> stones ) : <NL> <NL> <TAB> max_heap <SPC> = <SPC> [ - x <SPC> for <SPC> x <SPC> in <SPC> stones ] <NL> <TAB> heapq . heapify ( max_heap ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( stones ) <SPC> - <SPC> 1 ) : <NL>          x , <SPC> y <SPC> = <SPC> - heapq . heappop ( max_heap ) , <SPC> - heapq . heappop ( max_heap ) <NL>          heapq . heappush ( max_heap , <SPC> - abs ( x <SPC> - <SPC> y ) ) <NL> <TAB> return <SPC> - max_heap [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lastSubstring ( self , <SPC> s ) : <NL> <NL> <TAB> left , <SPC> right , <SPC> l <SPC> = <SPC> 0 , <SPC> 1 , <SPC> 0 <NL> <TAB> while <SPC> right <SPC> + <SPC> l <SPC> < <SPC> len ( s ) : <NL>          if <SPC> s [ left <SPC> + <SPC> l ] <SPC> == <SPC> s [ right <SPC> + <SPC> l ] : <NL>              l <SPC> += <SPC> 1 <NL>              continue <NL>          if <SPC> s [ left <SPC> + <SPC> l ] <SPC> > <SPC> s [ right <SPC> + <SPC> l ] : <NL>              right <SPC> += <SPC> l <SPC> + <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> max ( right , <SPC> left <SPC> + <SPC> l <SPC> + <SPC> 1 ) <NL>              right <SPC> = <SPC> left <SPC> + <SPC> 1 <NL>          l <SPC> = <SPC> 0 <NL> <TAB> return <SPC> s [ left : ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> lastSubstring ( self , <SPC> s ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          count [ s [ i ] ] . append ( i ) <NL> <NL> <TAB> max_c <SPC> = <SPC> max ( count . iterkeys ( ) ) <NL> <TAB> starts <SPC> = <SPC> { } <NL> <TAB> for <SPC> i <SPC> in <SPC> count [ max_c ] : <NL>          starts [ i ] <SPC> = <SPC> i <SPC> + <SPC> 1 <NL> <TAB> while <SPC> len ( starts ) <SPC> - <SPC> 1 <SPC> > <SPC> 0 : <NL>          lookup <SPC> = <SPC> set ( ) <NL>          next_count <SPC> = <SPC> collections . defaultdict ( list ) <NL>          for <SPC> start , <SPC> end <SPC> in <SPC> starts . iteritems ( ) : <NL>              if <SPC> end <SPC> == <SPC> len ( s ) : <NL>                  lookup . add ( start ) <NL>                  continue <NL>              next_count [ s [ end ] ] . append ( start ) <NL>              if <SPC> end <SPC> in <SPC> starts : <NL>                  lookup . add ( end ) <NL>          next_starts <SPC> = <SPC> { } <NL>          max_c <SPC> = <SPC> max ( next_count . iterkeys ( ) ) <NL>          for <SPC> start <SPC> in <SPC> next_count [ max_c ] : <NL>              if <SPC> start <SPC> not <SPC> in <SPC> lookup : <NL>                  next_starts [ start ] <SPC> = <SPC> starts [ start ] <SPC> + <SPC> 1 <NL>          starts <SPC> = <SPC> next_starts <NL> <TAB> return <SPC> s [ next ( starts . iterkeys ( ) ) : ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumTime ( self , <SPC> time ) : <NL> <NL> <TAB> result <SPC> = <SPC> list ( time ) <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( time ) : <NL>          if <SPC> c <SPC> != <SPC> "?" : <NL>              continue <NL>          if <SPC> i <SPC> == <SPC> 0 : <NL>              result [ i ] <SPC> = <SPC> "2" <SPC> if <SPC> result [ i <SPC> + <SPC> 1 ] <SPC> in <SPC> "?0123" <SPC> else <SPC> "1" <NL>          elif <SPC> i <SPC> == <SPC> 1 : <NL>              result [ i ] <SPC> = <SPC> "3" <SPC> if <SPC> result [ 0 ] <SPC> == <SPC> "2" <SPC> else <SPC> "9" <NL>          elif <SPC> i <SPC> == <SPC> 3 : <NL>              result [ i ] <SPC> = <SPC> "5" <NL>          elif <SPC> i <SPC> == <SPC> 4 : <NL>              result [ i ] <SPC> = <SPC> "9" <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> leafSimilar ( self , <SPC> root1 , <SPC> root2 ) : <NL> <NL> <TAB> def <SPC> dfs ( node ) : <NL>          if <SPC> not <SPC> node : <NL>              return <NL>          if <SPC> not <SPC> node . left <SPC> and <SPC> not <SPC> node . right : <NL>              yield <SPC> node . val <NL>          for <SPC> i <SPC> in <SPC> dfs ( node . left ) : <NL>              yield <SPC> i <NL>          for <SPC> i <SPC> in <SPC> dfs ( node . right ) : <NL>              yield <SPC> i <NL> <NL> <TAB> return <SPC> all ( a <SPC> == <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip_longest ( dfs ( root1 ) , <SPC> dfs ( root2 ) ) ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLeastNumOfUniqueInts ( self , <SPC> arr , <SPC> k ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( arr ) <NL> <TAB> result , <SPC> count_count <SPC> = <SPC> len ( count ) , <SPC> collections . Counter ( count . itervalues ( ) ) <NL> <TAB> for <SPC> c <SPC> in <SPC> xrange ( 1 , <SPC> len ( arr ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> k <SPC> < <SPC> c <SPC> * <SPC> count_count [ c ] : <NL>              result <SPC> -= <SPC> k <SPC> // <SPC> c <NL>              break <NL>          k <SPC> -= <SPC> c <SPC> * <SPC> count_count [ c ] <NL>          result <SPC> -= <SPC> count_count [ c ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> leastOpsExpressTarget ( self , <SPC> x , <SPC> target ) : <NL> <NL> <TAB> pos , <SPC> neg , <SPC> k <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> target : <NL>          target , <SPC> r <SPC> = <SPC> divmod ( target , <SPC> x ) <NL>          if <SPC> k : <NL>              pos , <SPC> neg <SPC> = <SPC> min ( r <SPC> * <SPC> k <SPC> + <SPC> pos , <SPC> ( r <SPC> + <SPC> 1 ) <SPC> * <SPC> k <SPC> + <SPC> neg ) , <SPC> min ( <NL>                  ( x <SPC> - <SPC> r ) <SPC> * <SPC> k <SPC> + <SPC> pos , <SPC> ( x <SPC> - <SPC> r <SPC> - <SPC> 1 ) <SPC> * <SPC> k <SPC> + <SPC> neg <NL>              ) <NL>          else : <NL>              pos , <SPC> neg <SPC> = <SPC> r <SPC> * <SPC> 2 , <SPC> ( x <SPC> - <SPC> r ) <SPC> * <SPC> 2 <NL>          k <SPC> += <SPC> 1 <NL> <TAB> return <SPC> min ( pos , <SPC> k <SPC> + <SPC> neg ) <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> BinaryMatrix ( object ) : <NL> <TAB> def <SPC> get ( self , <SPC> row , <SPC> col ) : <NL> <TAB> pass <NL> <NL> <TAB> def <SPC> dimensions ( self ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> leftMostColumnWithOne ( self , <SPC> binaryMatrix ) : <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> binaryMatrix . dimensions ( ) <NL> <TAB> r , <SPC> c <SPC> = <SPC> 0 , <SPC> n <SPC> - <SPC> 1 <NL> <TAB> while <SPC> r <SPC> < <SPC> m <SPC> and <SPC> c <SPC> >= <SPC> 0 : <NL>          if <SPC> not <SPC> binaryMatrix . get ( r , <SPC> c ) : <NL>              r <SPC> += <SPC> 1 <NL>          else : <NL>              c <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> c <SPC> + <SPC> 1 <SPC> if <SPC> c <SPC> + <SPC> 1 <SPC> != <SPC> n <SPC> else <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lemonadeChange ( self , <SPC> bills ) : <NL> <NL> <TAB> coins <SPC> = <SPC> [ 20 , <SPC> 10 , <SPC> 5 ] <NL> <TAB> counts <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> bill <SPC> in <SPC> bills : <NL>          counts [ bill ] <SPC> += <SPC> 1 <NL>          change <SPC> = <SPC> bill <SPC> - <SPC> coins [ - 1 ] <NL>          for <SPC> coin <SPC> in <SPC> coins : <NL>              if <SPC> change <SPC> == <SPC> 0 : <NL>                  break <NL>              if <SPC> change <SPC> >= <SPC> coin : <NL>                  count <SPC> = <SPC> min ( counts [ coin ] , <SPC> change <SPC> // <SPC> coin ) <NL>                  counts [ coin ] <SPC> -= <SPC> count <NL>                  change <SPC> -= <SPC> coin <SPC> * <SPC> count <NL>          if <SPC> change <SPC> != <SPC> 0 : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> lemonadeChange ( self , <SPC> bills ) : <NL> <NL> <TAB> five , <SPC> ten <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> bill <SPC> in <SPC> bills : <NL>          if <SPC> bill <SPC> == <SPC> 5 : <NL>              five <SPC> += <SPC> 1 <NL>          elif <SPC> bill <SPC> == <SPC> 10 : <NL>              if <SPC> not <SPC> five : <NL>                  return <SPC> False <NL>              five <SPC> -= <SPC> 1 <NL>              ten <SPC> += <SPC> 1 <NL>          else : <NL>              if <SPC> ten <SPC> and <SPC> five : <NL>                  ten <SPC> -= <SPC> 1 <NL>                  five <SPC> -= <SPC> 1 <NL>              elif <SPC> five <SPC> >= <SPC> 3 : <NL>                  five <SPC> -= <SPC> 3 <NL>              else : <NL>                  return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> lengthOfLastWord ( self , <SPC> s ) : <NL> <TAB> length <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( s ) : <NL>          if <SPC> i <SPC> == <SPC> " " : <NL>              if <SPC> length : <NL>                  break <NL>          else : <NL>              length <SPC> += <SPC> 1 <NL> <TAB> return <SPC> length <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> lengthOfLastWord ( self , <SPC> s ) : <NL> <TAB> return <SPC> len ( s . strip ( ) . split ( " " ) [ - 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lenLongestFibSubseq ( self , <SPC> A ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( A ) <NL> <TAB> result <SPC> = <SPC> 2 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( A ) ) : <NL>              x , <SPC> y , <SPC> l <SPC> = <SPC> A [ i ] , <SPC> A [ j ] , <SPC> 2 <NL>              while <SPC> x <SPC> + <SPC> y <SPC> in <SPC> lookup : <NL>                  x , <SPC> y , <SPC> l <SPC> = <SPC> y , <SPC> x <SPC> + <SPC> y , <SPC> l <SPC> + <SPC> 1 <NL>              result <SPC> = <SPC> max ( result , <SPC> l ) <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> > <SPC> 2 <SPC> else <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> letterCasePermutation ( self , <SPC> S ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ [ ] ] <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          if <SPC> c . isalpha ( ) : <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( result ) ) : <NL>                  result . append ( result [ i ] [ : ] ) <NL>                  result [ i ] . append ( c . lower ( ) ) <NL>                  result [ - 1 ] . append ( c . upper ( ) ) <NL>          else : <NL>              for <SPC> s <SPC> in <SPC> result : <NL>                  s . append ( c ) <NL> <TAB> return <SPC> map ( "" . join , <SPC> result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> letterCombinations ( self , <SPC> digits ) : <NL> <NL> <TAB> if <SPC> not <SPC> digits : <NL>          return <SPC> [ ] <NL> <NL> <TAB> lookup <SPC> = <SPC> [ "" , <SPC> "" , <SPC> "abc" , <SPC> "def" , <SPC> "ghi" , <SPC> "jkl" , <SPC> "mno" , <SPC> "pqrs" , <SPC> "tuv" , <SPC> "wxyz" ] <NL> <TAB> total <SPC> = <SPC> 1 <NL> <TAB> for <SPC> digit <SPC> in <SPC> digits : <NL>          total <SPC> *= <SPC> len ( lookup [ int ( digit ) ] ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( total ) : <NL>          base , <SPC> curr <SPC> = <SPC> total , <SPC> [ ] <NL>          for <SPC> digit <SPC> in <SPC> digits : <NL>              choices <SPC> = <SPC> lookup [ int ( digit ) ] <NL>              base <SPC> //= <SPC> len ( choices ) <NL>              curr . append ( choices [ ( i <SPC> // <SPC> base ) <SPC> % <SPC> len ( choices ) ] ) <NL>          result . append ( "" . join ( curr ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> letterCombinations ( self , <SPC> digits ) : <NL> <NL> <TAB> if <SPC> not <SPC> digits : <NL>          return <SPC> [ ] <NL> <NL> <TAB> result <SPC> = <SPC> [ "" ] <NL> <TAB> lookup <SPC> = <SPC> [ "" , <SPC> "" , <SPC> "abc" , <SPC> "def" , <SPC> "ghi" , <SPC> "jkl" , <SPC> "mno" , <SPC> "pqrs" , <SPC> "tuv" , <SPC> "wxyz" ] <NL> <TAB> for <SPC> digit <SPC> in <SPC> reversed ( digits ) : <NL>          choices <SPC> = <SPC> lookup [ int ( digit ) ] <NL>          m , <SPC> n <SPC> = <SPC> len ( choices ) , <SPC> len ( result ) <NL>          result . extend ( [ result [ i <SPC> % <SPC> n ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( n , <SPC> m <SPC> * <SPC> n ) ] ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( m <SPC> * <SPC> n ) : <NL>              result [ i ] <SPC> = <SPC> choices [ i <SPC> // <SPC> n ] <SPC> + <SPC> result [ i ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> letterCombinations ( self , <SPC> digits ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> [ "" , <SPC> "" , <SPC> "abc" , <SPC> "def" , <SPC> "ghi" , <SPC> "jkl" , <SPC> "mno" , <SPC> "pqrs" , <SPC> "tuv" , <SPC> "wxyz" ] <NL> <NL> <TAB> def <SPC> letterCombinationsRecu ( result , <SPC> digits , <SPC> curr , <SPC> n ) : <NL>          if <SPC> n <SPC> == <SPC> len ( digits ) : <NL>              result . append ( "" . join ( curr ) ) <NL>              return <NL>          for <SPC> choice <SPC> in <SPC> lookup [ int ( digits [ n ] ) ] : <NL>              curr . append ( choice ) <NL>              letterCombinationsRecu ( result , <SPC> digits , <SPC> curr , <SPC> n <SPC> + <SPC> 1 ) <NL>              curr . pop ( ) <NL> <NL> <TAB> if <SPC> not <SPC> digits : <NL>          return <SPC> [ ] <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> letterCombinationsRecu ( result , <SPC> digits , <SPC> [ ] , <SPC> 0 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numTilePossibilities ( self , <SPC> tiles ) : <NL> <NL> <TAB> fact <SPC> = <SPC> [ 0.0 ] <SPC> * <SPC> ( len ( tiles ) <SPC> + <SPC> 1 ) <NL> <TAB> fact [ 0 ] <SPC> = <SPC> 1.0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( tiles ) <SPC> + <SPC> 1 ) : <NL>          fact [ i ] <SPC> = <SPC> fact [ i <SPC> - <SPC> 1 ] <SPC> * <SPC> i <NL> <TAB> count <SPC> = <SPC> collections . Counter ( tiles ) <NL> <NL> <TAB> coeff <SPC> = <SPC> [ 0.0 ] <SPC> * <SPC> ( len ( tiles ) <SPC> + <SPC> 1 ) <NL> <TAB> coeff [ 0 ] <SPC> = <SPC> 1.0 <NL> <TAB> for <SPC> i <SPC> in <SPC> count . itervalues ( ) : <NL>          new_coeff <SPC> = <SPC> [ 0.0 ] <SPC> * <SPC> ( len ( tiles ) <SPC> + <SPC> 1 ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( coeff ) ) : <NL>              for <SPC> k <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 ) : <NL>                  if <SPC> k <SPC> + <SPC> j <SPC> >= <SPC> len ( new_coeff ) : <NL>                      break <NL>                  new_coeff [ j <SPC> + <SPC> k ] <SPC> += <SPC> coeff [ j ] <SPC> * <SPC> 1.0 <SPC> / <SPC> fact [ k ] <NL>          coeff <SPC> = <SPC> new_coeff <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( coeff ) ) : <NL>          result <SPC> += <SPC> int ( round ( coeff [ i ] <SPC> * <SPC> fact [ i ] ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numTilePossibilities ( self , <SPC> tiles ) : <NL> <NL> <TAB> def <SPC> backtracking ( counter ) : <NL>          total <SPC> = <SPC> 0 <NL>          for <SPC> k , <SPC> v <SPC> in <SPC> counter . iteritems ( ) : <NL>              if <SPC> not <SPC> v : <NL>                  continue <NL>              counter [ k ] <SPC> -= <SPC> 1 <NL>              total <SPC> += <SPC> 1 <SPC> + <SPC> backtracking ( counter ) <NL>              counter [ k ] <SPC> += <SPC> 1 <NL>          return <SPC> total <NL> <NL> <TAB> return <SPC> backtracking ( collections . Counter ( tiles ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lexicalOrder ( self , <SPC> n ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <NL> <TAB> i <SPC> = <SPC> 1 <NL> <TAB> while <SPC> len ( result ) <SPC> < <SPC> n : <NL>          k <SPC> = <SPC> 0 <NL>          while <SPC> i <SPC> * <SPC> 10 <SPC> ** <SPC> k <SPC> <= <SPC> n : <NL>              result . append ( i <SPC> * <SPC> 10 <SPC> ** <SPC> k ) <NL>              k <SPC> += <SPC> 1 <NL> <NL>          num <SPC> = <SPC> result [ - 1 ] <SPC> + <SPC> 1 <NL>          while <SPC> num <SPC> <= <SPC> n <SPC> and <SPC> num <SPC> % <SPC> 10 : <NL>              result . append ( num ) <NL>              num <SPC> += <SPC> 1 <NL> <NL>          if <SPC> not <SPC> num <SPC> % <SPC> 10 : <NL>              num <SPC> -= <SPC> 1 <NL>          else : <NL>              num <SPC> /= <SPC> 10 <NL> <NL>          while <SPC> num <SPC> % <SPC> 10 <SPC> == <SPC> 9 : <NL>              num <SPC> /= <SPC> 10 <NL> <NL>          i <SPC> = <SPC> num <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ max ( x_root , <SPC> y_root ) ] <SPC> = <SPC> min ( x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestEquivalentString ( self , <SPC> A , <SPC> B , <SPC> S ) : <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( 26 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          union_find . union_set ( ord ( A [ i ] ) <SPC> - <SPC> ord ( "a" ) , <SPC> ord ( B [ i ] ) <SPC> - <SPC> ord ( "a" ) ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( S ) ) : <NL>          parent <SPC> = <SPC> union_find . find_set ( ord ( S [ i ] ) <SPC> - <SPC> ord ( "a" ) ) <NL>          result . append ( chr ( parent <SPC> + <SPC> ord ( "a" ) ) ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLexSmallestString ( self , <SPC> s , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> def <SPC> less ( s , <SPC> i , <SPC> j ) : <NL>          for <SPC> k <SPC> in <SPC> xrange ( len ( s ) ) : <NL>              if <SPC> s [ ( k <SPC> + <SPC> i ) <SPC> % <SPC> len ( s ) ] <SPC> != <SPC> s [ ( k <SPC> + <SPC> j ) <SPC> % <SPC> len ( s ) ] : <NL>                  return <SPC> s [ ( k <SPC> + <SPC> i ) <SPC> % <SPC> len ( s ) ] <SPC> < <SPC> s [ ( k <SPC> + <SPC> j ) <SPC> % <SPC> len ( s ) ] <NL>          return <SPC> False <NL> <NL> <TAB> s <SPC> = <SPC> list ( s ) <NL> <TAB> result <SPC> = <SPC> s [ : ] <NL> <TAB> even <SPC> = <SPC> [ False ] <SPC> * <SPC> 10 <NL> <TAB> while <SPC> not <SPC> even [ int ( s [ 0 ] ) ] : <NL>          even [ int ( s [ 0 ] ) ] <SPC> = <SPC> True <NL>          odd <SPC> = <SPC> [ False ] <SPC> * <SPC> 10 <NL>          while <SPC> not <SPC> odd [ int ( s [ 1 ] ) ] : <NL>              odd [ int ( s [ 1 ] ) ] <SPC> = <SPC> True <NL>              best_rotate <SPC> = <SPC> 0 <NL>              lookup <SPC> = <SPC> [ False ] <SPC> * <SPC> len ( s ) <NL>              i <SPC> = <SPC> b <NL>              while <SPC> not <SPC> lookup [ i ] : <NL>                  lookup [ i ] <SPC> = <SPC> True <NL>                  if <SPC> less ( s , <SPC> i , <SPC> best_rotate ) : <NL>                      best_rotate <SPC> = <SPC> i <NL>                  i <SPC> = <SPC> ( i <SPC> + <SPC> b ) <SPC> % <SPC> len ( s ) <NL>              result <SPC> = <SPC> min ( result , <SPC> s [ best_rotate : ] <SPC> + <SPC> s [ : best_rotate ] ) <NL>              for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) , <SPC> 2 ) : <NL>                  s [ k ] <SPC> = <SPC> str ( ( int ( s [ k ] ) <SPC> + <SPC> a ) <SPC> % <SPC> 10 ) <NL>          if <SPC> b <SPC> % <SPC> 2 : <NL>              for <SPC> k <SPC> in <SPC> xrange ( 0 , <SPC> len ( s ) , <SPC> 2 ) : <NL>                  s [ k ] <SPC> = <SPC> str ( ( int ( s [ k ] ) <SPC> + <SPC> a ) <SPC> % <SPC> 10 ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findLexSmallestString ( self , <SPC> s , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> q , <SPC> lookup , <SPC> result <SPC> = <SPC> collections . deque ( [ s ] ) , <SPC> { s } , <SPC> s <NL> <TAB> while <SPC> q : <NL>          curr <SPC> = <SPC> q . popleft ( ) <NL>          if <SPC> curr <SPC> < <SPC> result : <NL>              result <SPC> = <SPC> curr <NL>          add_a <SPC> = <SPC> list ( curr ) <NL>          for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( add_a ) : <NL>              if <SPC> i <SPC> % <SPC> 2 : <NL>                  add_a [ i ] <SPC> = <SPC> str ( ( int ( c ) <SPC> + <SPC> a ) <SPC> % <SPC> 10 ) <NL>          add_a <SPC> = <SPC> "" . join ( add_a ) <NL>          if <SPC> add_a <SPC> not <SPC> in <SPC> lookup : <NL>              lookup . add ( add_a ) <NL>              q . append ( add_a ) <NL>          rotate_b <SPC> = <SPC> curr [ b : ] <SPC> + <SPC> curr [ : b ] <NL>          if <SPC> rotate_b <SPC> not <SPC> in <SPC> lookup : <NL>              lookup . add ( rotate_b ) <NL>              q . append ( rotate_b ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> LFUCache ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> capacity ) : <NL> <NL> <TAB> self . __capa <SPC> = <SPC> capacity <NL> <TAB> self . __size <SPC> = <SPC> 0 <NL> <TAB> self . __min_freq <SPC> = <SPC> float ( "inf" ) <NL> <TAB> self . __freq_to_nodes <SPC> = <SPC> collections . defaultdict ( collections . OrderedDict ) <NL> <TAB> self . __key_to_freq <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> get ( self , <SPC> key ) : <NL> <NL> <TAB> if <SPC> key <SPC> not <SPC> in <SPC> self . __key_to_freq : <NL>          return <SPC> - 1 <NL> <TAB> value <SPC> = <SPC> self . __freq_to_nodes [ self . __key_to_freq [ key ] ] [ key ] <NL> <TAB> self . __update ( key , <SPC> value ) <NL> <TAB> return <SPC> value <NL> <NL> <TAB> def <SPC> put ( self , <SPC> key , <SPC> value ) : <NL> <NL> <TAB> if <SPC> self . __capa <SPC> <= <SPC> 0 : <NL>          return <NL> <NL> <TAB> if <SPC> key <SPC> not <SPC> in <SPC> self . __key_to_freq <SPC> and <SPC> self . __size <SPC> == <SPC> self . __capa : <NL>          del <SPC> self . __key_to_freq [ <NL>              self . __freq_to_nodes [ self . __min_freq ] . popitem ( last = False ) [ 0 ] <NL>          ] <NL>          if <SPC> not <SPC> self . __freq_to_nodes [ self . __min_freq ] : <NL>              del <SPC> self . __freq_to_nodes [ self . __min_freq ] <NL>          self . __size <SPC> -= <SPC> 1 <NL> <TAB> self . __update ( key , <SPC> value ) <NL> <NL> <TAB> def <SPC> __update ( self , <SPC> key , <SPC> value ) : <NL> <TAB> freq <SPC> = <SPC> 0 <NL> <TAB> if <SPC> key <SPC> in <SPC> self . __key_to_freq : <NL>          freq <SPC> = <SPC> self . __key_to_freq [ key ] <NL>          del <SPC> self . __freq_to_nodes [ freq ] [ key ] <NL>          if <SPC> not <SPC> self . __freq_to_nodes [ freq ] : <NL>              del <SPC> self . __freq_to_nodes [ freq ] <NL>              if <SPC> self . __min_freq <SPC> == <SPC> freq : <NL>                  self . __min_freq <SPC> += <SPC> 1 <NL>          self . __size <SPC> -= <SPC> 1 <NL> <NL> <TAB> freq <SPC> += <SPC> 1 <NL> <TAB> self . __min_freq <SPC> = <SPC> min ( self . __min_freq , <SPC> freq ) <NL> <TAB> self . __key_to_freq [ key ] <SPC> = <SPC> freq <NL> <TAB> self . __freq_to_nodes [ freq ] [ key ] <SPC> = <SPC> value <NL> <TAB> self . __size <SPC> += <SPC> 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> key , <SPC> value , <SPC> freq ) : <NL> <TAB> self . key <SPC> = <SPC> key <NL> <TAB> self . val <SPC> = <SPC> value <NL> <TAB> self . freq <SPC> = <SPC> freq <NL> <TAB> self . next <SPC> = <SPC> None <NL> <TAB> self . prev <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> LinkedList ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . head <SPC> = <SPC> None <NL> <TAB> self . tail <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> append ( self , <SPC> node ) : <NL> <TAB> node . next , <SPC> node . prev <SPC> = <SPC> None , <SPC> None <NL> <TAB> if <SPC> self . head <SPC> is <SPC> None : <NL>          self . head <SPC> = <SPC> node <NL> <TAB> else : <NL>          self . tail . next <SPC> = <SPC> node <NL>          node . prev <SPC> = <SPC> self . tail <NL> <TAB> self . tail <SPC> = <SPC> node <NL> <NL> <TAB> def <SPC> delete ( self , <SPC> node ) : <NL> <TAB> if <SPC> node . prev : <NL>          node . prev . next <SPC> = <SPC> node . next <NL> <TAB> else : <NL>          self . head <SPC> = <SPC> node . next <NL> <TAB> if <SPC> node . next : <NL>          node . next . prev <SPC> = <SPC> node . prev <NL> <TAB> else : <NL>          self . tail <SPC> = <SPC> node . prev <NL> <TAB> node . next , <SPC> node . prev <SPC> = <SPC> None , <SPC> None <NL> <NL> <NL> class <SPC> LFUCache2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> capacity ) : <NL> <NL> <TAB> self . __capa <SPC> = <SPC> capacity <NL> <TAB> self . __size <SPC> = <SPC> 0 <NL> <TAB> self . __min_freq <SPC> = <SPC> float ( "inf" ) <NL> <TAB> self . __freq_to_nodes <SPC> = <SPC> collections . defaultdict ( LinkedList ) <NL> <TAB> self . __key_to_node <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> get ( self , <SPC> key ) : <NL> <NL> <TAB> if <SPC> key <SPC> not <SPC> in <SPC> self . __key_to_node : <NL>          return <SPC> - 1 <NL> <TAB> value <SPC> = <SPC> self . __key_to_node [ key ] . val <NL> <TAB> self . __update ( key , <SPC> value ) <NL> <TAB> return <SPC> value <NL> <NL> <TAB> def <SPC> put ( self , <SPC> key , <SPC> value ) : <NL> <NL> <TAB> if <SPC> self . __capa <SPC> <= <SPC> 0 : <NL>          return <NL> <NL> <TAB> if <SPC> key <SPC> not <SPC> in <SPC> self . __key_to_node <SPC> and <SPC> self . __size <SPC> == <SPC> self . __capa : <NL>          del <SPC> self . __key_to_node [ self . __freq_to_nodes [ self . __min_freq ] . head . key ] <NL>          self . __freq_to_nodes [ self . __min_freq ] . delete ( <NL>              self . __freq_to_nodes [ self . __min_freq ] . head <NL>          ) <NL>          if <SPC> not <SPC> self . __freq_to_nodes [ self . __min_freq ] . head : <NL>              del <SPC> self . __freq_to_nodes [ self . __min_freq ] <NL>          self . __size <SPC> -= <SPC> 1 <NL> <TAB> self . __update ( key , <SPC> value ) <NL> <NL> <TAB> def <SPC> __update ( self , <SPC> key , <SPC> value ) : <NL> <TAB> freq <SPC> = <SPC> 0 <NL> <TAB> if <SPC> key <SPC> in <SPC> self . __key_to_node : <NL>          old_node <SPC> = <SPC> self . __key_to_node [ key ] <NL>          freq <SPC> = <SPC> old_node . freq <NL>          self . __freq_to_nodes [ freq ] . delete ( old_node ) <NL>          if <SPC> not <SPC> self . __freq_to_nodes [ freq ] . head : <NL>              del <SPC> self . __freq_to_nodes [ freq ] <NL>              if <SPC> self . __min_freq <SPC> == <SPC> freq : <NL>                  self . __min_freq <SPC> += <SPC> 1 <NL>          self . __size <SPC> -= <SPC> 1 <NL> <NL> <TAB> freq <SPC> += <SPC> 1 <NL> <TAB> self . __min_freq <SPC> = <SPC> min ( self . __min_freq , <SPC> freq ) <NL> <TAB> self . __key_to_node [ key ] <SPC> = <SPC> ListNode ( key , <SPC> value , <SPC> freq ) <NL> <TAB> self . __freq_to_nodes [ freq ] . append ( self . __key_to_node [ key ] ) <NL> <TAB> self . __size <SPC> += <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> licenseKeyFormatting ( self , <SPC> S , <SPC> K ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( S ) ) ) : <NL>          if <SPC> S [ i ] <SPC> == <SPC> "-" : <NL>              continue <NL>          if <SPC> len ( result ) <SPC> % <SPC> ( K <SPC> + <SPC> 1 ) <SPC> == <SPC> K : <NL>              result <SPC> += <SPC> "-" <NL>          result <SPC> += <SPC> S [ i ] . upper ( ) <NL> <TAB> return <SPC> "" . join ( reversed ( result ) ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isReflected ( self , <SPC> points ) : <NL> <NL> <TAB> if <SPC> not <SPC> points : <NL>          return <SPC> True <NL> <TAB> groups_by_y <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> float ( "inf" ) , <SPC> float ( "-inf" ) <NL> <TAB> for <SPC> p <SPC> in <SPC> points : <NL>          groups_by_y [ p [ 1 ] ] . add ( p [ 0 ] ) <NL>          left , <SPC> right <SPC> = <SPC> min ( left , <SPC> p [ 0 ] ) , <SPC> max ( right , <SPC> p [ 0 ] ) <NL> <TAB> mid <SPC> = <SPC> left <SPC> + <SPC> right <NL> <TAB> for <SPC> group <SPC> in <SPC> groups_by_y . values ( ) : <NL>          for <SPC> x <SPC> in <SPC> group : <NL>              if <SPC> mid <SPC> - <SPC> x <SPC> not <SPC> in <SPC> group : <NL>                  return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isReflected ( self , <SPC> points ) : <NL> <NL> <TAB> if <SPC> not <SPC> points : <NL>          return <SPC> True <NL> <TAB> points . sort ( ) <NL> <NL> <TAB> points [ len ( points ) <SPC> / <SPC> 2 : ] <SPC> = <SPC> sorted ( <NL>          points [ len ( points ) <SPC> / <SPC> 2 : ] , <NL>          lambda <SPC> x , <SPC> y : <SPC> y [ 1 ] <SPC> - <SPC> x [ 1 ] <SPC> if <SPC> x [ 0 ] <SPC> == <SPC> y [ 0 ] <SPC> else <SPC> x [ 0 ] <SPC> - <SPC> y [ 0 ] , <NL> <TAB> ) <NL> <TAB> mid <SPC> = <SPC> points [ 0 ] [ 0 ] <SPC> + <SPC> points [ - 1 ] [ 0 ] <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( points ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          if <SPC> ( mid <SPC> != <SPC> points [ left ] [ 0 ] <SPC> + <SPC> points [ right ] [ 0 ] ) <SPC> or <SPC> ( <NL>              points [ left ] [ 0 ] <SPC> != <SPC> points [ right ] [ 0 ] <NL>              and <SPC> points [ left ] [ 1 ] <SPC> != <SPC> points [ right ] [ 1 ] <NL>          ) : <NL>              return <SPC> False <NL>          left <SPC> += <SPC> 1 <NL>          right <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numComponents ( self , <SPC> head , <SPC> G ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( G ) <NL> <TAB> dummy <SPC> = <SPC> ListNode ( - 1 ) <NL> <TAB> dummy . next <SPC> = <SPC> head <NL> <TAB> curr <SPC> = <SPC> dummy <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> curr <SPC> and <SPC> curr . next : <NL>          if <SPC> curr . val <SPC> not <SPC> in <SPC> lookup <SPC> and <SPC> curr . next . val <SPC> in <SPC> lookup : <NL>              result <SPC> += <SPC> 1 <NL>          curr <SPC> = <SPC> curr . next <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __str__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{}" . format ( self . val ) <NL> <TAB> else : <NL>          return <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> detectCycle ( self , <SPC> head ) : <NL> <TAB> fast , <SPC> slow <SPC> = <SPC> head , <SPC> head <NL> <TAB> while <SPC> fast <SPC> and <SPC> fast . next : <NL>          fast , <SPC> slow <SPC> = <SPC> fast . next . next , <SPC> slow . next <NL>          if <SPC> fast <SPC> is <SPC> slow : <NL>              fast <SPC> = <SPC> head <NL>              while <SPC> fast <SPC> is <SPC> not <SPC> slow : <NL>                  fast , <SPC> slow <SPC> = <SPC> fast . next , <SPC> slow . next <NL>              return <SPC> fast <NL> <TAB> return <SPC> None <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> hasCycle ( self , <SPC> head ) : <NL> <TAB> fast , <SPC> slow <SPC> = <SPC> head , <SPC> head <NL> <TAB> while <SPC> fast <SPC> and <SPC> fast . next : <NL>          fast , <SPC> slow <SPC> = <SPC> fast . next . next , <SPC> slow . next <NL>          if <SPC> fast <SPC> is <SPC> slow : <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isSubPath ( self , <SPC> head , <SPC> root ) : <NL> <NL> <TAB> def <SPC> getPrefix ( head ) : <NL>          pattern , <SPC> prefix <SPC> = <SPC> [ head . val ] , <SPC> [ - 1 ] <NL>          j <SPC> = <SPC> - 1 <NL>          node <SPC> = <SPC> head . next <NL>          while <SPC> node : <NL>              while <SPC> j <SPC> + <SPC> 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> node . val : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> node . val : <NL>                  j <SPC> += <SPC> 1 <NL>              pattern . append ( node . val ) <NL>              prefix . append ( j ) <NL>              node <SPC> = <SPC> node . next <NL>          return <SPC> pattern , <SPC> prefix <NL> <NL> <TAB> def <SPC> dfs ( pattern , <SPC> prefix , <SPC> root , <SPC> j ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> False <NL>          while <SPC> j <SPC> + <SPC> 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> root . val : <NL>              j <SPC> = <SPC> prefix [ j ] <NL>          if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> root . val : <NL>              j <SPC> += <SPC> 1 <NL>          if <SPC> j <SPC> + <SPC> 1 <SPC> == <SPC> len ( pattern ) : <NL>              return <SPC> True <NL>          return <SPC> dfs ( pattern , <SPC> prefix , <SPC> root . left , <SPC> j ) <SPC> or <SPC> dfs ( <NL>              pattern , <SPC> prefix , <SPC> root . right , <SPC> j <NL>          ) <NL> <NL> <TAB> if <SPC> not <SPC> head : <NL>          return <SPC> True <NL> <TAB> pattern , <SPC> prefix <SPC> = <SPC> getPrefix ( head ) <NL> <TAB> return <SPC> dfs ( pattern , <SPC> prefix , <SPC> root , <SPC> - 1 ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isSubPath ( self , <SPC> head , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( head , <SPC> root ) : <NL>          if <SPC> not <SPC> head : <NL>              return <SPC> True <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> False <NL>          return <SPC> root . val <SPC> == <SPC> head . val <SPC> and <SPC> ( <NL>              dfs ( head . next , <SPC> root . left ) <SPC> or <SPC> dfs ( head . next , <SPC> root . right ) <NL>          ) <NL> <NL> <TAB> if <SPC> not <SPC> head : <NL>          return <SPC> True <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> False <NL> <TAB> return <SPC> ( <NL>          dfs ( head , <SPC> root ) <NL>          or <SPC> self . isSubPath ( head , <SPC> root . left ) <NL>          or <SPC> self . isSubPath ( head , <SPC> root . right ) <NL> <TAB> ) <NL> <NL> <NL> from <SPC> random <SPC> import <SPC> randint <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> head ) : <NL> <NL> <TAB> self . __head <SPC> = <SPC> head <NL> <NL> <TAB> def <SPC> getRandom ( self ) : <NL> <NL> <TAB> reservoir <SPC> = <SPC> - 1 <NL> <TAB> curr , <SPC> n <SPC> = <SPC> self . __head , <SPC> 0 <NL> <TAB> while <SPC> curr : <NL>          reservoir <SPC> = <SPC> curr . val <SPC> if <SPC> randint ( 1 , <SPC> n <SPC> + <SPC> 1 ) <SPC> == <SPC> 1 <SPC> else <SPC> reservoir <NL>          curr , <SPC> n <SPC> = <SPC> curr . next , <SPC> n <SPC> + <SPC> 1 <NL> <TAB> return <SPC> reservoir <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Logger ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . __dq <SPC> = <SPC> collections . deque ( ) <NL> <TAB> self . __printed <SPC> = <SPC> set ( ) <NL> <NL> <TAB> def <SPC> shouldPrintMessage ( self , <SPC> timestamp , <SPC> message ) : <NL> <NL> <TAB> while <SPC> self . __dq <SPC> and <SPC> self . __dq [ 0 ] [ 0 ] <SPC> <= <SPC> timestamp <SPC> - <SPC> 10 : <NL>          self . __printed . remove ( self . __dq . popleft ( ) [ 1 ] ) <NL> <TAB> if <SPC> message <SPC> in <SPC> self . __printed : <NL>          return <SPC> False <NL> <TAB> self . __dq . append ( ( timestamp , <SPC> message ) ) <NL> <TAB> self . __printed . add ( message ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLonelyPixel ( self , <SPC> picture ) : <NL> <NL> <TAB> rows , <SPC> cols <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( picture ) , <SPC> [ 0 ] <SPC> * <SPC> len ( picture [ 0 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( picture ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( picture [ 0 ] ) ) : <NL>              if <SPC> picture [ i ] [ j ] <SPC> == <SPC> "B" : <NL>                  rows [ i ] <SPC> += <SPC> 1 <NL>                  cols [ j ] <SPC> += <SPC> 1 <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( picture ) ) : <NL>          if <SPC> rows [ i ] <SPC> == <SPC> 1 : <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( picture [ 0 ] ) ) : <NL>                  result <SPC> += <SPC> picture [ i ] [ j ] <SPC> == <SPC> "B" <SPC> and <SPC> cols [ j ] <SPC> == <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findLonelyPixel ( self , <SPC> picture ) : <NL> <NL> <TAB> return <SPC> sum ( <NL>          col . count ( "B" ) <SPC> == <SPC> 1 <SPC> == <SPC> picture [ col . index ( "B" ) ] . count ( "B" ) <NL>          for <SPC> col <SPC> in <SPC> zip ( * picture ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findBlackPixel ( self , <SPC> picture , <SPC> N ) : <NL> <NL> <TAB> rows , <SPC> cols <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( picture ) , <SPC> [ 0 ] <SPC> * <SPC> len ( picture [ 0 ] ) <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( picture ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( picture [ 0 ] ) ) : <NL>              if <SPC> picture [ i ] [ j ] <SPC> == <SPC> "B" : <NL>                  rows [ i ] <SPC> += <SPC> 1 <NL>                  cols [ j ] <SPC> += <SPC> 1 <NL>          lookup [ tuple ( picture [ i ] ) ] <SPC> += <SPC> 1 <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( picture ) ) : <NL>          if <SPC> rows [ i ] <SPC> == <SPC> N <SPC> and <SPC> lookup [ tuple ( picture [ i ] ) ] <SPC> == <SPC> N : <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( picture [ 0 ] ) ) : <NL>                  result <SPC> += <SPC> picture [ i ] [ j ] <SPC> == <SPC> "B" <SPC> and <SPC> cols [ j ] <SPC> == <SPC> N <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findBlackPixel ( self , <SPC> picture , <SPC> N ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . Counter ( map ( tuple , <SPC> picture ) ) <NL> <TAB> cols <SPC> = <SPC> [ col . count ( "B" ) <SPC> for <SPC> col <SPC> in <SPC> zip ( * picture ) ] <NL> <TAB> return <SPC> sum ( <NL>          N <SPC> * <SPC> zip ( row , <SPC> cols ) . count ( ( "B" , <SPC> N ) ) <NL>          for <SPC> row , <SPC> cnt <SPC> in <SPC> lookup . iteritems ( ) <NL>          if <SPC> cnt <SPC> == <SPC> N <SPC> == <SPC> row . count ( "B" ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isLongPressedName ( self , <SPC> name , <SPC> typed ) : <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( typed ) ) : <NL>          if <SPC> i <SPC> < <SPC> len ( name ) <SPC> and <SPC> name [ i ] <SPC> == <SPC> typed [ j ] : <NL>              i <SPC> += <SPC> 1 <NL>          elif <SPC> j <SPC> == <SPC> 0 <SPC> or <SPC> typed [ j ] <SPC> != <SPC> typed [ j <SPC> - <SPC> 1 ] : <NL>              return <SPC> False <NL> <TAB> return <SPC> i <SPC> == <SPC> len ( name ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lengthLongestPath ( self , <SPC> input ) : <NL> <NL> <TAB> def <SPC> split_iter ( s , <SPC> tok ) : <NL>          start <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>              if <SPC> s [ i ] <SPC> == <SPC> tok : <NL>                  yield <SPC> s [ start : i ] <NL>                  start <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>          yield <SPC> s [ start : ] <NL> <NL> <TAB> max_len <SPC> = <SPC> 0 <NL> <TAB> path_len <SPC> = <SPC> { 0 : <SPC> 0 } <NL> <TAB> for <SPC> line <SPC> in <SPC> split_iter ( input , <SPC> "\n" ) : <NL>          name <SPC> = <SPC> line . lstrip ( "\t" ) <NL>          depth <SPC> = <SPC> len ( line ) <SPC> - <SPC> len ( name ) <NL>          if <SPC> "." <SPC> in <SPC> name : <NL>              max_len <SPC> = <SPC> max ( max_len , <SPC> path_len [ depth ] <SPC> + <SPC> len ( name ) ) <NL>          else : <NL>              path_len [ depth <SPC> + <SPC> 1 ] <SPC> = <SPC> path_len [ depth ] <SPC> + <SPC> len ( name ) <SPC> + <SPC> 1 <NL> <TAB> return <SPC> max_len <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestArithSeqLength ( self , <SPC> A ) : <NL> <NL> <TAB> dp <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) <SPC> - <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( A ) ) : <NL>              v <SPC> = <SPC> A [ j ] <SPC> - <SPC> A [ i ] <NL>              dp [ v , <SPC> j ] <SPC> = <SPC> max ( dp [ v , <SPC> j ] , <SPC> dp [ v , <SPC> i ] <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> max ( dp . values ( ) ) <SPC> + <SPC> 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestSubsequence ( self , <SPC> arr , <SPC> difference ) : <NL> <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( arr ) ) : <NL>          lookup [ arr [ i ] ] <SPC> = <SPC> lookup [ arr [ i ] <SPC> - <SPC> difference ] <SPC> + <SPC> 1 <NL>          result <SPC> = <SPC> max ( result , <SPC> lookup [ arr [ i ] ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestDecomposition ( self , <SPC> text ) : <NL> <NL> <TAB> def <SPC> compare ( text , <SPC> l , <SPC> s1 , <SPC> s2 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( l ) : <NL>              if <SPC> text [ s1 <SPC> + <SPC> i ] <SPC> != <SPC> text [ s2 <SPC> + <SPC> i ] : <NL>                  return <SPC> False <NL>          return <SPC> True <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> D <SPC> = <SPC> 26 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> left , <SPC> right , <SPC> l , <SPC> pow_D <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( text ) ) : <NL>          left <SPC> = <SPC> ( D <SPC> * <SPC> left <SPC> + <SPC> ( ord ( text [ i ] ) <SPC> - <SPC> ord ( "a" ) ) ) <SPC> % <SPC> MOD <NL>          right <SPC> = <SPC> ( pow_D <SPC> * <SPC> ( ord ( text [ - 1 <SPC> - <SPC> i ] ) <SPC> - <SPC> ord ( "a" ) ) <SPC> + <SPC> right ) <SPC> % <SPC> MOD <NL>          l <SPC> += <SPC> 1 <NL>          pow_D <SPC> = <SPC> ( pow_D <SPC> * <SPC> D ) <SPC> % <SPC> MOD <NL>          if <SPC> left <SPC> == <SPC> right <SPC> and <SPC> compare ( text , <SPC> l , <SPC> i <SPC> - <SPC> l <SPC> + <SPC> 1 , <SPC> len ( text ) <SPC> - <SPC> 1 <SPC> - <SPC> i ) : <NL>              result <SPC> += <SPC> 1 <NL>              left , <SPC> right , <SPC> l , <SPC> pow_D <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestCommonPrefix ( self , <SPC> strs ) : <NL> <NL> <TAB> if <SPC> not <SPC> strs : <NL>          return <SPC> "" <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( strs [ 0 ] ) ) : <NL>          for <SPC> string <SPC> in <SPC> strs [ 1 : ] : <NL>              if <SPC> i <SPC> >= <SPC> len ( string ) <SPC> or <SPC> string [ i ] <SPC> != <SPC> strs [ 0 ] [ i ] : <NL>                  return <SPC> strs [ 0 ] [ : i ] <NL> <TAB> return <SPC> strs [ 0 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> longestCommonPrefix ( self , <SPC> strs ) : <NL> <NL> <TAB> prefix <SPC> = <SPC> "" <NL> <NL> <TAB> for <SPC> chars <SPC> in <SPC> zip ( * strs ) : <NL>          if <SPC> all ( c <SPC> == <SPC> chars [ 0 ] <SPC> for <SPC> c <SPC> in <SPC> chars ) : <NL>              prefix <SPC> += <SPC> chars [ 0 ] <NL>          else : <NL>              return <SPC> prefix <NL> <NL> <TAB> return <SPC> prefix <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestCommonSubsequence ( self , <SPC> text1 , <SPC> text2 ) : <NL> <NL> <TAB> if <SPC> len ( text1 ) <SPC> < <SPC> len ( text2 ) : <NL>          return <SPC> self . longestCommonSubsequence ( text2 , <SPC> text1 ) <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( text2 ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( text1 ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( text2 ) <SPC> + <SPC> 1 ) : <NL>              dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> ( <NL>                  dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 <NL>                  if <SPC> text1 [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> text2 [ j <SPC> - <SPC> 1 ] <NL>                  else <SPC> max ( dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <SPC> dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] ) <NL>              ) <NL> <TAB> return <SPC> dp [ len ( text1 ) <SPC> % <SPC> 2 ] [ len ( text2 ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> longestConsecutive ( self , <SPC> num ) : <NL> <TAB> result , <SPC> lengths <SPC> = <SPC> 1 , <SPC> { key : <SPC> 0 <SPC> for <SPC> key <SPC> in <SPC> num } <NL> <TAB> for <SPC> i <SPC> in <SPC> num : <NL>          if <SPC> lengths [ i ] <SPC> == <SPC> 0 : <NL>              lengths [ i ] <SPC> = <SPC> 1 <NL>              left , <SPC> right <SPC> = <SPC> lengths . get ( i <SPC> - <SPC> 1 , <SPC> 0 ) , <SPC> lengths . get ( i <SPC> + <SPC> 1 , <SPC> 0 ) <NL>              length <SPC> = <SPC> 1 <SPC> + <SPC> left <SPC> + <SPC> right <NL>              result , <SPC> lengths [ i <SPC> - <SPC> left ] , <SPC> lengths [ i <SPC> + <SPC> right ] <SPC> = <SPC> ( <NL>                  max ( result , <SPC> length ) , <NL>                  length , <NL>                  length , <NL>              ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLengthOfLCIS ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> count <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> i <SPC> == <SPC> 0 <SPC> or <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> nums [ i ] : <NL>              count <SPC> += <SPC> 1 <NL>              result <SPC> = <SPC> max ( result , <SPC> count ) <NL>          else : <NL>              count <SPC> = <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestSubarray ( self , <SPC> nums , <SPC> limit ) : <NL> <NL> <TAB> max_dq , <SPC> min_dq <SPC> = <SPC> collections . deque ( ) , <SPC> collections . deque ( ) <NL> <TAB> left <SPC> = <SPC> 0 <NL> <TAB> for <SPC> right , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          while <SPC> max_dq <SPC> and <SPC> nums [ max_dq [ - 1 ] ] <SPC> <= <SPC> num : <NL>              max_dq . pop ( ) <NL>          max_dq . append ( right ) <NL>          while <SPC> min_dq <SPC> and <SPC> nums [ min_dq [ - 1 ] ] <SPC> >= <SPC> num : <NL>              min_dq . pop ( ) <NL>          min_dq . append ( right ) <NL>          if <SPC> nums [ max_dq [ 0 ] ] <SPC> - <SPC> nums [ min_dq [ 0 ] ] <SPC> > <SPC> limit : <NL>              if <SPC> max_dq [ 0 ] <SPC> == <SPC> left : <NL>                  max_dq . popleft ( ) <NL>              if <SPC> min_dq [ 0 ] <SPC> == <SPC> left : <NL>                  min_dq . popleft ( ) <NL>              left <SPC> += <SPC> 1 <NL> <TAB> return <SPC> len ( nums ) <SPC> - <SPC> left <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> longestSubarray ( self , <SPC> nums , <SPC> limit ) : <NL> <NL> <TAB> max_dq , <SPC> min_dq <SPC> = <SPC> collections . deque ( ) , <SPC> collections . deque ( ) <NL> <TAB> result , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> right , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          while <SPC> max_dq <SPC> and <SPC> nums [ max_dq [ - 1 ] ] <SPC> <= <SPC> num : <NL>              max_dq . pop ( ) <NL>          max_dq . append ( right ) <NL>          while <SPC> min_dq <SPC> and <SPC> nums [ min_dq [ - 1 ] ] <SPC> >= <SPC> num : <NL>              min_dq . pop ( ) <NL>          min_dq . append ( right ) <NL>          while <SPC> ( <NL>              nums [ max_dq [ 0 ] ] <SPC> - <SPC> nums [ min_dq [ 0 ] ] <SPC> > <SPC> limit <NL>          ) : <NL>              if <SPC> max_dq [ 0 ] <SPC> == <SPC> left : <NL>                  max_dq . popleft ( ) <NL>              if <SPC> min_dq [ 0 ] <SPC> == <SPC> left : <NL>                  min_dq . popleft ( ) <NL>              left <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> max ( result , <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestDupSubstring ( self , <SPC> S ) : <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> D <SPC> = <SPC> 26 <NL> <NL> <TAB> def <SPC> check ( S , <SPC> L ) : <NL>          p <SPC> = <SPC> pow ( D , <SPC> L , <SPC> M ) <NL>          curr <SPC> = <SPC> reduce ( lambda <SPC> x , <SPC> y : <SPC> ( D <SPC> * <SPC> x <SPC> + <SPC> ord ( y ) <SPC> - <SPC> ord ( "a" ) ) <SPC> % <SPC> M , <SPC> S [ : L ] , <SPC> 0 ) <NL>          lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL>          lookup [ curr ] . append ( L <SPC> - <SPC> 1 ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( L , <SPC> len ( S ) ) : <NL>              curr <SPC> = <SPC> ( <NL>                  ( D <SPC> * <SPC> curr ) <SPC> % <SPC> M <NL>                  + <SPC> ord ( S [ i ] ) <NL>                  - <SPC> ord ( "a" ) <NL>                  - <SPC> ( ( ord ( S [ i <SPC> - <SPC> L ] ) <SPC> - <SPC> ord ( "a" ) ) <SPC> * <SPC> p ) <SPC> % <SPC> M <NL>              ) <SPC> % <SPC> M <NL>              if <SPC> curr <SPC> in <SPC> lookup : <NL>                  for <SPC> j <SPC> in <SPC> lookup [ <NL>                      curr <NL>                  ] : <NL>                      if <SPC> S [ j <SPC> - <SPC> L <SPC> + <SPC> 1 : <SPC> j <SPC> + <SPC> 1 ] <SPC> == <SPC> S [ i <SPC> - <SPC> L <SPC> + <SPC> 1 : <SPC> i <SPC> + <SPC> 1 ] : <NL>                          return <SPC> i <SPC> - <SPC> L <SPC> + <SPC> 1 <NL>              lookup [ curr ] . append ( i ) <NL>          return <SPC> 0 <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> len ( S ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( S , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> result <SPC> = <SPC> check ( S , <SPC> right ) <NL> <TAB> return <SPC> S [ result : <SPC> result <SPC> + <SPC> right ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestPrefix ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> getPrefix ( pattern ) : <NL>          prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>              while <SPC> j <SPC> != <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              prefix [ i ] <SPC> = <SPC> j <NL>          return <SPC> prefix <NL> <NL> <TAB> return <SPC> s [ : <SPC> getPrefix ( s ) [ - 1 ] <SPC> + <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> longestPrefix ( self , <SPC> s ) : <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> D <SPC> = <SPC> 26 <NL> <NL> <TAB> def <SPC> check ( l , <SPC> s ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( l ) : <NL>              if <SPC> s [ i ] <SPC> != <SPC> s [ len ( s ) <SPC> - <SPC> l <SPC> + <SPC> i ] : <NL>                  return <SPC> False <NL>          return <SPC> True <NL> <NL> <TAB> result , <SPC> prefix , <SPC> suffix , <SPC> power <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> - <SPC> 1 ) : <NL>          prefix <SPC> = <SPC> ( prefix <SPC> * <SPC> D <SPC> + <SPC> ( ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ) ) <SPC> % <SPC> M <NL>          suffix <SPC> = <SPC> ( suffix <SPC> + <SPC> ( ord ( s [ len ( s ) <SPC> - <SPC> ( i <SPC> + <SPC> 1 ) ] ) <SPC> - <SPC> ord ( "a" ) ) <SPC> * <SPC> power ) <SPC> % <SPC> M <NL>          power <SPC> = <SPC> ( power <SPC> * <SPC> D ) <SPC> % <SPC> M <NL>          if <SPC> prefix <SPC> == <SPC> suffix : <NL> <NL>              result <SPC> = <SPC> i <SPC> + <SPC> 1 <NL> <TAB> return <SPC> s [ : result ] <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestDiverseString ( self , <SPC> a , <SPC> b , <SPC> c ) : <NL> <NL> <TAB> max_heap <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> a : <NL>          heapq . heappush ( max_heap , <SPC> ( - a , <SPC> "a" ) ) <NL> <TAB> if <SPC> b : <NL>          heapq . heappush ( max_heap , <SPC> ( - b , <SPC> "b" ) ) <NL> <TAB> if <SPC> c : <NL>          heapq . heappush ( max_heap , <SPC> ( - c , <SPC> "c" ) ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> max_heap : <NL>          count1 , <SPC> c1 <SPC> = <SPC> heapq . heappop ( max_heap ) <NL>          if <SPC> len ( result ) <SPC> >= <SPC> 2 <SPC> and <SPC> result [ - 1 ] <SPC> == <SPC> result [ - 2 ] <SPC> == <SPC> c1 : <NL>              if <SPC> not <SPC> max_heap : <NL>                  return <SPC> "" . join ( result ) <NL>              count2 , <SPC> c2 <SPC> = <SPC> heapq . heappop ( max_heap ) <NL>              result . append ( c2 ) <NL>              count2 <SPC> += <SPC> 1 <NL>              if <SPC> count2 : <NL>                  heapq . heappush ( max_heap , <SPC> ( count2 , <SPC> c2 ) ) <NL>              heapq . heappush ( max_heap , <SPC> ( count1 , <SPC> c1 ) ) <NL>              continue <NL>          result . append ( c1 ) <NL>          count1 <SPC> += <SPC> 1 <NL>          if <SPC> count1 <SPC> != <SPC> 0 : <NL>              heapq . heappush ( max_heap , <SPC> ( count1 , <SPC> c1 ) ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> longestDiverseString ( self , <SPC> a , <SPC> b , <SPC> c ) : <NL> <NL> <TAB> choices <SPC> = <SPC> [ [ a , <SPC> "a" ] , <SPC> [ b , <SPC> "b" ] , <SPC> [ c , <SPC> "c" ] ] <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( a <SPC> + <SPC> b <SPC> + <SPC> c ) : <NL>          choices . sort ( reverse = True ) <NL>          for <SPC> i , <SPC> ( x , <SPC> c ) <SPC> in <SPC> enumerate ( choices ) : <NL>              if <SPC> x <SPC> and <SPC> result [ - 2 : ] <SPC> != <SPC> [ c , <SPC> c ] : <NL>                  result . append ( c ) <NL>                  choices [ i ] [ 0 ] <SPC> -= <SPC> 1 <NL>                  break <NL>          else : <NL>              break <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLHS ( self , <SPC> nums ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          lookup [ num ] <SPC> += <SPC> 1 <NL>          for <SPC> diff <SPC> in <SPC> [ - 1 , <SPC> 1 ] : <NL>              if <SPC> ( num <SPC> + <SPC> diff ) <SPC> in <SPC> lookup : <NL>                  result <SPC> = <SPC> max ( result , <SPC> lookup [ num ] <SPC> + <SPC> lookup [ num <SPC> + <SPC> diff ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestIncreasingPath ( self , <SPC> matrix ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <SPC> 0 <NL> <NL> <TAB> in_degree <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( matrix [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( matrix ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) : <NL>              for <SPC> di , <SPC> dj <SPC> in <SPC> directions : <NL>                  ni , <SPC> nj <SPC> = <SPC> i <SPC> + <SPC> di , <SPC> j <SPC> + <SPC> dj <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> ni <SPC> < <SPC> len ( matrix ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nj <SPC> < <SPC> len ( matrix [ 0 ] ) <NL>                      and <SPC> matrix [ ni ] [ nj ] <SPC> > <SPC> matrix [ i ] [ j ] <NL>                  ) : <NL>                      continue <NL>                  in_degree [ i ] [ j ] <SPC> += <SPC> 1 <NL> <TAB> q <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) : <NL>              if <SPC> not <SPC> in_degree [ i ] [ j ] : <NL>                  q . append ( ( i , <SPC> j ) ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> q : <NL>          new_q <SPC> = <SPC> [ ] <NL>          for <SPC> i , <SPC> j <SPC> in <SPC> q : <NL>              for <SPC> di , <SPC> dj <SPC> in <SPC> directions : <NL>                  ni , <SPC> nj <SPC> = <SPC> i <SPC> + <SPC> di , <SPC> j <SPC> + <SPC> dj <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> ni <SPC> < <SPC> len ( matrix ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nj <SPC> < <SPC> len ( matrix [ 0 ] ) <NL>                      and <SPC> matrix [ i ] [ j ] <SPC> > <SPC> matrix [ ni ] [ nj ] <NL>                  ) : <NL>                      continue <NL>                  in_degree [ ni ] [ nj ] <SPC> -= <SPC> 1 <NL>                  if <SPC> not <SPC> in_degree [ ni ] [ nj ] : <NL>                      new_q . append ( ( ni , <SPC> nj ) ) <NL>          q <SPC> = <SPC> new_q <NL>          result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> longestIncreasingPath ( self , <SPC> matrix ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> longestpath ( matrix , <SPC> i , <SPC> j , <SPC> max_lengths ) : <NL>          if <SPC> max_lengths [ i ] [ j ] : <NL>              return <SPC> max_lengths [ i ] [ j ] <NL>          max_depth <SPC> = <SPC> 0 <NL>          for <SPC> di , <SPC> dj <SPC> in <SPC> directions : <NL>              x , <SPC> y <SPC> = <SPC> i <SPC> + <SPC> di , <SPC> j <SPC> + <SPC> dj <NL>              if <SPC> ( <NL>                  0 <SPC> <= <SPC> x <SPC> < <SPC> len ( matrix ) <NL>                  and <SPC> 0 <SPC> <= <SPC> y <SPC> < <SPC> len ( matrix [ 0 ] ) <NL>                  and <SPC> matrix [ x ] [ y ] <SPC> < <SPC> matrix [ i ] [ j ] <NL>              ) : <NL>                  max_depth <SPC> = <SPC> max ( max_depth , <SPC> longestpath ( <NL>                      matrix , <SPC> x , <SPC> y , <SPC> max_lengths ) ) <NL>          max_lengths [ i ] [ j ] <SPC> = <SPC> max_depth <SPC> + <SPC> 1 <NL>          return <SPC> max_lengths [ i ] [ j ] <NL> <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <SPC> 0 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> max_lengths <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) ] <NL>                     for <SPC> _ <SPC> in <SPC> xrange ( len ( matrix ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) : <NL>              result <SPC> = <SPC> max ( result , <SPC> longestpath ( matrix , <SPC> i , <SPC> j , <SPC> max_lengths ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lengthOfLIS ( self , <SPC> nums ) : <NL> <NL> <TAB> LIS <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> insert ( target ) : <NL>          left <SPC> = <SPC> bisect . bisect_left ( LIS , <SPC> target ) <NL> <NL>          if <SPC> left <SPC> == <SPC> len ( LIS ) : <NL>              LIS . append ( target ) <NL>          else : <NL>              LIS [ left ] <SPC> = <SPC> target <NL> <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          insert ( num ) <NL> <TAB> return <SPC> len ( LIS ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> lengthOfLIS ( self , <SPC> nums ) : <NL> <NL> <TAB> LIS <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> insert ( target ) : <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( LIS ) <SPC> - <SPC> 1 <NL> <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>              if <SPC> LIS [ mid ] <SPC> >= <SPC> target : <NL>                  right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL>          if <SPC> left <SPC> == <SPC> len ( LIS ) : <NL>              LIS . append ( target ) <NL>          else : <NL>              LIS [ left ] <SPC> = <SPC> target <NL> <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          insert ( num ) <NL> <NL> <TAB> return <SPC> len ( LIS ) <NL> <NL> <NL> class <SPC> SegmentTree ( object ) : <NL> <TAB> def <SPC> __init__ ( <NL>          self , <NL>          N , <NL>          build_fn = lambda <SPC> x , <SPC> y : <SPC> [ y ] <SPC> * <SPC> ( 2 <SPC> * <SPC> x ) , <NL>          query_fn = lambda <SPC> x , <SPC> y : <SPC> y <NL>          if <SPC> x <SPC> is <SPC> None <NL>          else <SPC> max ( x , <SPC> y ) , <NL>          update_fn = lambda <SPC> x , <SPC> y : <SPC> y , <NL>          default_val = 0 , <NL> <TAB> ) : <NL> <TAB> self . N <SPC> = <SPC> N <NL> <TAB> self . H <SPC> = <SPC> ( N <SPC> - <SPC> 1 ) . bit_length ( ) <NL> <TAB> self . query_fn <SPC> = <SPC> query_fn <NL> <TAB> self . update_fn <SPC> = <SPC> update_fn <NL> <TAB> self . default_val <SPC> = <SPC> default_val <NL> <TAB> self . tree <SPC> = <SPC> build_fn ( N , <SPC> default_val ) <NL> <TAB> self . lazy <SPC> = <SPC> [ None ] <SPC> * <SPC> N <NL> <NL> <TAB> def <SPC> __apply ( self , <SPC> x , <SPC> val ) : <NL> <TAB> self . tree [ x ] <SPC> = <SPC> self . update_fn ( self . tree [ x ] , <SPC> val ) <NL> <TAB> if <SPC> x <SPC> < <SPC> self . N : <NL>          self . lazy [ x ] <SPC> = <SPC> self . update_fn ( self . lazy [ x ] , <SPC> val ) <NL> <NL> <TAB> def <SPC> update ( self , <SPC> L , <SPC> R , <SPC> h ) : <NL> <NL> <TAB> def <SPC> pull ( x ) : <NL>          while <SPC> x <SPC> > <SPC> 1 : <NL>              x <SPC> //= <SPC> 2 <NL>              self . tree [ x ] <SPC> = <SPC> self . query_fn ( <NL>                  self . tree [ x <SPC> * <SPC> 2 ] , <SPC> self . tree [ x <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] ) <NL>              if <SPC> self . lazy [ x ] <SPC> is <SPC> not <SPC> None : <NL>                  self . tree [ x ] <SPC> = <SPC> self . update_fn ( self . tree [ x ] , <SPC> self . lazy [ x ] ) <NL> <NL> <TAB> L <SPC> += <SPC> self . N <NL> <TAB> R <SPC> += <SPC> self . N <NL> <TAB> L0 , <SPC> R0 <SPC> = <SPC> L , <SPC> R <NL> <TAB> while <SPC> L <SPC> <= <SPC> R : <NL>          if <SPC> L <SPC> & <SPC> 1 : <NL>              self . __apply ( L , <SPC> h ) <NL>              L <SPC> += <SPC> 1 <NL>          if <SPC> R <SPC> & <SPC> 1 <SPC> == <SPC> 0 : <NL>              self . __apply ( R , <SPC> h ) <NL>              R <SPC> -= <SPC> 1 <NL>          L <SPC> //= <SPC> 2 <NL>          R <SPC> //= <SPC> 2 <NL> <TAB> pull ( L0 ) <NL> <TAB> pull ( R0 ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> L , <SPC> R ) : <NL> <NL> <TAB> def <SPC> push ( x ) : <NL>          n <SPC> = <SPC> 2 <SPC> ** <SPC> self . H <NL>          while <SPC> n <SPC> != <SPC> 1 : <NL>              y <SPC> = <SPC> x <SPC> // <SPC> n <NL>              if <SPC> self . lazy [ y ] <SPC> is <SPC> not <SPC> None : <NL>                  self . __apply ( y <SPC> * <SPC> 2 , <SPC> self . lazy [ y ] ) <NL>                  self . __apply ( y <SPC> * <SPC> 2 <SPC> + <SPC> 1 , <SPC> self . lazy [ y ] ) <NL>                  self . lazy [ y ] <SPC> = <SPC> None <NL>              n <SPC> //= <SPC> 2 <NL> <NL> <TAB> result <SPC> = <SPC> None <NL> <TAB> if <SPC> L <SPC> > <SPC> R : <NL>          return <SPC> result <NL> <NL> <TAB> L <SPC> += <SPC> self . N <NL> <TAB> R <SPC> += <SPC> self . N <NL> <TAB> push ( L ) <NL> <TAB> push ( R ) <NL> <TAB> while <SPC> L <SPC> <= <SPC> R : <NL>          if <SPC> L <SPC> & <SPC> 1 : <NL>              result <SPC> = <SPC> self . query_fn ( result , <SPC> self . tree [ L ] ) <NL>              L <SPC> += <SPC> 1 <NL>          if <SPC> R <SPC> & <SPC> 1 <SPC> == <SPC> 0 : <NL>              result <SPC> = <SPC> self . query_fn ( result , <SPC> self . tree [ R ] ) <NL>              R <SPC> -= <SPC> 1 <NL>          L <SPC> //= <SPC> 2 <NL>          R <SPC> //= <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> __str__ ( self ) : <NL> <TAB> showList <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . N ) : <NL>          showList . append ( self . query ( i , <SPC> i ) ) <NL> <TAB> return <SPC> "," . join ( map ( str , <SPC> showList ) ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> lengthOfLIS ( self , <SPC> nums ) : <NL> <NL> <TAB> sorted_nums <SPC> = <SPC> sorted ( set ( nums ) ) <NL> <TAB> lookup <SPC> = <SPC> { num : <SPC> i <SPC> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( sorted_nums ) } <NL> <TAB> segment_tree <SPC> = <SPC> SegmentTree ( len ( lookup ) ) <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          segment_tree . update ( <NL>              lookup [ num ] , <NL>              lookup [ num ] , <NL>              segment_tree . query ( 0 , <SPC> lookup [ num ] <SPC> - <SPC> 1 ) <SPC> + <NL>              1 <SPC> if <SPC> lookup [ num ] <SPC> >= <SPC> 1 <SPC> else <SPC> 1 , <NL>          ) <NL> <TAB> return <SPC> segment_tree . query ( 0 , <SPC> len ( lookup ) <SPC> - <SPC> 1 ) <SPC> if <SPC> len ( lookup ) <SPC> >= <SPC> 1 <SPC> else <SPC> 0 <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> lengthOfLIS ( self , <SPC> nums ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          dp . append ( 1 ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( i ) : <NL>              if <SPC> nums [ j ] <SPC> < <SPC> nums [ i ] : <NL>                  dp [ i ] <SPC> = <SPC> max ( dp [ i ] , <SPC> dp [ j ] <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> max ( dp ) <SPC> if <SPC> dp <SPC> else <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestLine ( self , <SPC> M ) : <NL> <NL> <TAB> if <SPC> not <SPC> M : <NL>          return <SPC> 0 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> dp <SPC> = <SPC> [ [ [ 0 ] <SPC> * <SPC> 4 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( M [ 0 ] ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( M ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( M [ 0 ] ) ) : <NL>              dp [ i <SPC> % <SPC> 2 ] [ j ] [ : ] <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 4 <NL>              if <SPC> M [ i ] [ j ] <SPC> == <SPC> 1 : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] [ 0 ] <SPC> = <SPC> dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] [ 0 ] <SPC> + <SPC> 1 <SPC> if <SPC> j <SPC> > <SPC> 0 <SPC> else <SPC> 1 <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] [ 1 ] <SPC> = <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] [ 1 ] <SPC> + <SPC> 1 <SPC> if <SPC> i <SPC> > <SPC> 0 <SPC> else <SPC> 1 <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] [ 2 ] <SPC> = <SPC> ( <NL>                      dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] [ 2 ] <SPC> + <SPC> 1 <SPC> if <SPC> ( i <SPC> > <SPC> 0 <SPC> and <SPC> j <SPC> > <SPC> 0 ) <SPC> else <SPC> 1 <NL>                  ) <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] [ 3 ] <SPC> = <SPC> ( <NL>                      dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] [ 3 ] <SPC> + <SPC> 1 <NL>                      if <SPC> ( i <SPC> > <SPC> 0 <SPC> and <SPC> j <SPC> < <SPC> len ( M [ 0 ] ) <SPC> - <SPC> 1 ) <NL>                      else <SPC> 1 <NL>                  ) <NL>                  result <SPC> = <SPC> max ( result , <SPC> max ( dp [ i <SPC> % <SPC> 2 ] [ j ] ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestMountain ( self , <SPC> A ) : <NL> <NL> <TAB> result , <SPC> up_len , <SPC> down_len <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) ) : <NL>          if <SPC> ( down_len <SPC> and <SPC> A [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> A [ i ] ) <SPC> or <SPC> A [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> A [ i ] : <NL>              up_len , <SPC> down_len <SPC> = <SPC> 0 , <SPC> 0 <NL>          up_len <SPC> += <SPC> A [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> A [ i ] <NL>          down_len <SPC> += <SPC> A [ i <SPC> - <SPC> 1 ] <SPC> > <SPC> A [ i ] <NL>          if <SPC> up_len <SPC> and <SPC> down_len : <NL>              result <SPC> = <SPC> max ( result , <SPC> up_len <SPC> + <SPC> down_len <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestNiceSubstring ( self , <SPC> s ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( list ( s ) ) <NL> <TAB> prev <SPC> = <SPC> - 1 <NL> <TAB> result <SPC> = <SPC> "" <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> not <SPC> ( i <SPC> == <SPC> len ( s ) <SPC> or <SPC> s [ i ] <SPC> not <SPC> in <SPC> lookup <SPC> or <SPC> s [ i ] . swapcase ( ) <SPC> not <SPC> in <SPC> lookup ) : <NL>              continue <NL>          if <SPC> prev <SPC> == <SPC> - 1 <SPC> and <SPC> i <SPC> == <SPC> len ( s ) : <NL>              return <SPC> s <NL>          tmp <SPC> = <SPC> self . longestNiceSubstring ( s [ prev <SPC> + <SPC> 1 : <SPC> i ] ) <NL>          if <SPC> len ( tmp ) <SPC> > <SPC> len ( result ) : <NL>              result <SPC> = <SPC> tmp <NL>          prev <SPC> = <SPC> i <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestPalindrome ( self , <SPC> s ) : <NL> <NL> <TAB> odds <SPC> = <SPC> 0 <NL> <TAB> for <SPC> k , <SPC> v <SPC> in <SPC> collections . Counter ( s ) . iteritems ( ) : <NL>          odds <SPC> += <SPC> v <SPC> & <SPC> 1 <NL> <TAB> return <SPC> len ( s ) <SPC> - <SPC> odds <SPC> + <SPC> int ( odds <SPC> > <SPC> 0 ) <NL> <NL> <TAB> def <SPC> longestPalindrome2 ( self , <SPC> s ) : <NL> <NL> <TAB> odd <SPC> = <SPC> sum ( map ( lambda <SPC> x : <SPC> x <SPC> & <SPC> 1 , <SPC> collections . Counter ( s ) . values ( ) ) ) <NL> <TAB> return <SPC> len ( s ) <SPC> - <SPC> odd <SPC> + <SPC> int ( odd <SPC> > <SPC> 0 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestPalindromeSubseq ( self , <SPC> s ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ [ 0 ] <SPC> * <SPC> 26 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( s ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( s ) ) : <NL>              if <SPC> i <SPC> == <SPC> j <SPC> - <SPC> 1 : <NL>                  if <SPC> s [ j ] <SPC> == <SPC> s [ i ] : <NL>                      dp [ i <SPC> % <SPC> 2 ] [ j ] [ ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> 2 <NL>              else : <NL>                  for <SPC> k <SPC> in <SPC> xrange ( 26 ) : <NL>                      if <SPC> s [ j ] <SPC> == <SPC> s [ i ] <SPC> and <SPC> ord ( s [ j ] ) <SPC> - <SPC> ord ( "a" ) <SPC> != <SPC> k : <NL>                          dp [ i <SPC> % <SPC> 2 ] [ j ] [ ord ( s [ j ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> max ( <NL>                              dp [ i <SPC> % <SPC> 2 ] [ j ] [ ord ( s [ j ] ) <SPC> - <SPC> ord ( "a" ) ] , <NL>                              dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] [ k ] <SPC> + <SPC> 2 , <NL>                          ) <NL>                      dp [ i <SPC> % <SPC> 2 ] [ j ] [ k ] <SPC> = <SPC> max ( <NL>                          dp [ i <SPC> % <SPC> 2 ] [ j ] [ k ] , <NL>                          dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] [ k ] , <NL>                          dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] [ k ] , <NL>                          dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] [ k ] , <NL>                      ) <NL> <TAB> return <SPC> max ( dp [ 0 ] [ - 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestPalindromeSubseq ( self , <SPC> s ) : <NL> <NL> <TAB> if <SPC> s <SPC> == <SPC> s [ : : - 1 ] : <NL>          return <SPC> len ( s ) <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 1 ] <SPC> * <SPC> len ( s ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( s ) ) : <NL>              if <SPC> s [ i ] <SPC> == <SPC> s [ j ] : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> 2 <SPC> + <SPC> dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <NL>                                        2 ] [ j <SPC> - <SPC> 1 ] <SPC> if <SPC> i <SPC> + <SPC> 1 <SPC> <= <SPC> j <SPC> - <SPC> 1 <SPC> else <SPC> 2 <NL>              else : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> max ( dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <SPC> dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] ) <NL> <TAB> return <SPC> dp [ 0 ] [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestPalindrome ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> preProcess ( s ) : <NL>          if <SPC> not <SPC> s : <NL>              return <SPC> [ "^" , <SPC> "$" ] <NL>          T <SPC> = <SPC> [ "^" ] <NL>          for <SPC> c <SPC> in <SPC> s : <NL>              T <SPC> += <SPC> [ "#" , <SPC> c ] <NL>          T <SPC> += <SPC> [ "#" , <SPC> "$" ] <NL>          return <SPC> T <NL> <NL> <TAB> T <SPC> = <SPC> preProcess ( s ) <NL> <TAB> P <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( T ) <NL> <TAB> center , <SPC> right <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( T ) <SPC> - <SPC> 1 ) : <NL>          i_mirror <SPC> = <SPC> 2 <SPC> * <SPC> center <SPC> - <SPC> i <NL>          if <SPC> right <SPC> > <SPC> i : <NL>              P [ i ] <SPC> = <SPC> min ( right <SPC> - <SPC> i , <SPC> P [ i_mirror ] ) <NL>          else : <NL>              P [ i ] <SPC> = <SPC> 0 <NL> <NL>          while <SPC> T [ i <SPC> + <SPC> 1 <SPC> + <SPC> P [ i ] ] <SPC> == <SPC> T [ i <SPC> - <SPC> 1 <SPC> - <SPC> P [ i ] ] : <NL>              P [ i ] <SPC> += <SPC> 1 <NL> <NL>          if <SPC> i <SPC> + <SPC> P [ i ] <SPC> > <SPC> right : <NL>              center , <SPC> right <SPC> = <SPC> i , <SPC> i <SPC> + <SPC> P [ i ] <NL> <NL> <TAB> max_i <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( T ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> P [ i ] <SPC> > <SPC> P [ max_i ] : <NL>              max_i <SPC> = <SPC> i <NL> <TAB> start <SPC> = <SPC> ( max_i <SPC> - <SPC> 1 <SPC> - <SPC> P [ max_i ] ) <SPC> / <SPC> 2 <NL> <TAB> return <SPC> s [ start : <SPC> start <SPC> + <SPC> P [ max_i ] ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> longestPalindrome ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> expand ( s , <SPC> left , <SPC> right ) : <NL>          while <SPC> left <SPC> >= <SPC> 0 <SPC> and <SPC> right <SPC> < <SPC> len ( s ) <SPC> and <SPC> s [ left ] <SPC> == <SPC> s [ right ] : <NL>              left <SPC> -= <SPC> 1 <NL>              right <SPC> += <SPC> 1 <NL>          return <SPC> ( right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <SPC> - <SPC> 2 <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> - 1 , <SPC> - 2 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          l <SPC> = <SPC> max ( expand ( s , <SPC> i , <SPC> i ) , <SPC> expand ( s , <SPC> i , <SPC> i <SPC> + <SPC> 1 ) ) <NL>          if <SPC> l <SPC> > <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 : <NL>              right <SPC> = <SPC> i <SPC> + <SPC> l <SPC> // <SPC> 2 <NL>              left <SPC> = <SPC> right <SPC> - <SPC> l <SPC> + <SPC> 1 <NL> <TAB> return <SPC> s [ left : <SPC> right <SPC> + <SPC> 1 ] <SPC> if <SPC> left <SPC> >= <SPC> 0 <SPC> else <SPC> "" <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> characterReplacement ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> result , <SPC> max_count <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> count <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          count [ s [ i ] ] <SPC> += <SPC> 1 <NL>          max_count <SPC> = <SPC> max ( max_count , <SPC> count [ s [ i ] ] ) <NL>          if <SPC> result <SPC> - <SPC> max_count <SPC> >= <SPC> k : <NL>              count [ s [ i <SPC> - <SPC> result ] ] <SPC> -= <SPC> 1 <NL>          else : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestRepeatingSubstring ( self , <SPC> S ) : <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> D <SPC> = <SPC> 26 <NL> <NL> <TAB> def <SPC> check ( S , <SPC> L ) : <NL>          p <SPC> = <SPC> pow ( D , <SPC> L , <SPC> M ) <NL>          curr <SPC> = <SPC> reduce ( lambda <SPC> x , <SPC> y : <SPC> ( D <SPC> * <SPC> x <SPC> + <SPC> ord ( y ) <SPC> - <SPC> ord ( "a" ) ) <SPC> % <SPC> M , <SPC> S [ : L ] , <SPC> 0 ) <NL>          lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL>          lookup [ curr ] . append ( L <SPC> - <SPC> 1 ) <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( L , <SPC> len ( S ) ) : <NL>              curr <SPC> = <SPC> ( <NL>                  ( D <SPC> * <SPC> curr ) <SPC> % <SPC> M <NL>                  + <SPC> ord ( S [ i ] ) <NL>                  - <SPC> ord ( "a" ) <NL>                  - <SPC> ( ( ord ( S [ i <SPC> - <SPC> L ] ) <SPC> - <SPC> ord ( "a" ) ) <SPC> * <SPC> p ) <SPC> % <SPC> M <NL>              ) <SPC> % <SPC> M <NL>              if <SPC> curr <SPC> in <SPC> lookup : <NL>                  for <SPC> j <SPC> in <SPC> lookup [ curr ] : <NL>                      if <SPC> S [ j <SPC> - <SPC> L <SPC> + <SPC> 1 : <SPC> j <SPC> + <SPC> 1 ] <SPC> == <SPC> S [ i <SPC> - <SPC> L <SPC> + <SPC> 1 : <SPC> i <SPC> + <SPC> 1 ] : <NL>                          if <SPC> result <SPC> == <SPC> 0 : <NL>                              result <SPC> = <SPC> i <NL>                          return <SPC> result <SPC> - <SPC> L <SPC> + <SPC> 1 <NL>              lookup [ curr ] . append ( i ) <NL>          return <SPC> result <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( S ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( S , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> right <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestStrChain ( self , <SPC> words ) : <NL> <NL> <TAB> words . sort ( key = len ) <NL> <TAB> dp <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> w <SPC> in <SPC> words : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( w ) ) : <NL>              dp [ w ] <SPC> = <SPC> max ( dp [ w ] , <SPC> dp [ w [ : i ] <SPC> + <SPC> w [ i <SPC> + <SPC> 1 : ] ] <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> max ( dp . itervalues ( ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestSubarray ( self , <SPC> nums ) : <NL> <NL> <TAB> count , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          count <SPC> += <SPC> nums [ right ] <SPC> == <SPC> 0 <NL>          if <SPC> count <SPC> >= <SPC> 2 : <NL>              count <SPC> -= <SPC> nums [ left ] <SPC> == <SPC> 0 <NL>              left <SPC> += <SPC> 1 <NL> <TAB> return <SPC> ( right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> longestSubarray ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> count , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          count <SPC> += <SPC> nums [ right ] <SPC> == <SPC> 0 <NL>          while <SPC> count <SPC> >= <SPC> 2 : <NL>              count <SPC> -= <SPC> nums [ left ] <SPC> == <SPC> 0 <NL>              left <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> max ( result , <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> result <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestSubstring ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> def <SPC> longestSubstringHelper ( s , <SPC> k , <SPC> start , <SPC> end ) : <NL>          count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> end ) : <NL>              count [ ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL>          max_len <SPC> = <SPC> 0 <NL>          i <SPC> = <SPC> start <NL>          while <SPC> i <SPC> < <SPC> end : <NL>              while <SPC> i <SPC> < <SPC> end <SPC> and <SPC> count [ ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> < <SPC> k : <NL>                  i <SPC> += <SPC> 1 <NL>              j <SPC> = <SPC> i <NL>              while <SPC> j <SPC> < <SPC> end <SPC> and <SPC> count [ ord ( s [ j ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> >= <SPC> k : <NL>                  j <SPC> += <SPC> 1 <NL> <NL>              if <SPC> i <SPC> == <SPC> start <SPC> and <SPC> j <SPC> == <SPC> end : <NL>                  return <SPC> end <SPC> - <SPC> start <NL> <NL>              max_len <SPC> = <SPC> max ( max_len , <SPC> longestSubstringHelper ( s , <SPC> k , <SPC> i , <SPC> j ) ) <NL>              i <SPC> = <SPC> j <NL>          return <SPC> max_len <NL> <NL> <TAB> return <SPC> longestSubstringHelper ( s , <SPC> k , <SPC> 0 , <SPC> len ( s ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lengthOfLongestSubstringKDistinct ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> longest , <SPC> start , <SPC> distinct_count , <SPC> visited <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 256 ) ] <NL> <TAB> for <SPC> i , <SPC> char <SPC> in <SPC> enumerate ( s ) : <NL>          if <SPC> visited [ ord ( char ) ] <SPC> == <SPC> 0 : <NL>              distinct_count <SPC> += <SPC> 1 <NL>          visited [ ord ( char ) ] <SPC> += <SPC> 1 <NL>          while <SPC> distinct_count <SPC> > <SPC> k : <NL>              visited [ ord ( s [ start ] ) ] <SPC> -= <SPC> 1 <NL>              if <SPC> visited [ ord ( s [ start ] ) ] <SPC> == <SPC> 0 : <NL>                  distinct_count <SPC> -= <SPC> 1 <NL>              start <SPC> += <SPC> 1 <NL>          longest <SPC> = <SPC> max ( longest , <SPC> i <SPC> - <SPC> start <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> longest <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> Counter <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> lengthOfLongestSubstringKDistinct ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> counter <SPC> = <SPC> Counter ( ) <NL> <TAB> left , <SPC> max_length <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> right , <SPC> char <SPC> in <SPC> enumerate ( s ) : <NL>          counter [ char ] <SPC> += <SPC> 1 <NL>          while <SPC> len ( counter ) <SPC> > <SPC> k : <NL>              counter [ s [ left ] ] <SPC> -= <SPC> 1 <NL>              if <SPC> counter [ s [ left ] ] <SPC> == <SPC> 0 : <NL>                  del <SPC> counter [ s [ left ] ] <NL>              left <SPC> += <SPC> 1 <NL>          max_length <SPC> = <SPC> max ( max_length , <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> max_length <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> lengthOfLongestSubstringTwoDistinct ( self , <SPC> s ) : <NL> <TAB> longest , <SPC> start , <SPC> distinct_count , <SPC> visited <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 256 ) ] <NL> <TAB> for <SPC> i , <SPC> char <SPC> in <SPC> enumerate ( s ) : <NL>          if <SPC> visited [ ord ( char ) ] <SPC> == <SPC> 0 : <NL>              distinct_count <SPC> += <SPC> 1 <NL>          visited [ ord ( char ) ] <SPC> += <SPC> 1 <NL>          while <SPC> distinct_count <SPC> > <SPC> 2 : <NL>              visited [ ord ( s [ start ] ) ] <SPC> -= <SPC> 1 <NL>              if <SPC> visited [ ord ( s [ start ] ) ] <SPC> == <SPC> 0 : <NL>                  distinct_count <SPC> -= <SPC> 1 <NL>              start <SPC> += <SPC> 1 <NL>          longest <SPC> = <SPC> max ( longest , <SPC> i <SPC> - <SPC> start <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> longest <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> Counter <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> lengthOfLongestSubstringTwoDistinct ( self , <SPC> s ) : <NL> <NL> <TAB> counter <SPC> = <SPC> Counter ( ) <NL> <TAB> left , <SPC> max_length <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> right , <SPC> char <SPC> in <SPC> enumerate ( s ) : <NL>          counter [ char ] <SPC> += <SPC> 1 <NL>          while <SPC> len ( counter ) <SPC> > <SPC> 2 : <NL>              counter [ s [ left ] ] <SPC> -= <SPC> 1 <NL>              if <SPC> counter [ s [ left ] ] <SPC> == <SPC> 0 : <NL>                  del <SPC> counter [ s [ left ] ] <NL>              left <SPC> += <SPC> 1 <NL>          max_length <SPC> = <SPC> max ( max_length , <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> max_length <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lengthOfLongestSubstring ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> s [ right ] <SPC> in <SPC> lookup : <NL>              left <SPC> = <SPC> max ( left , <SPC> lookup [ s [ right ] ] <SPC> + <SPC> 1 ) <NL>          lookup [ s [ right ] ] <SPC> = <SPC> right <NL>          result <SPC> = <SPC> max ( result , <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxTurbulenceSize ( self , <SPC> A ) : <NL> <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> start <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) ) : <NL>          if <SPC> i <SPC> == <SPC> len ( A ) <SPC> - <SPC> 1 <SPC> or <SPC> cmp ( A [ i <SPC> - <SPC> 1 ] , <SPC> A [ i ] ) <SPC> * <SPC> cmp ( A [ i ] , <SPC> A [ i <SPC> + <SPC> 1 ] ) <SPC> != <SPC> - 1 : <NL>              result <SPC> = <SPC> max ( result , <SPC> i <SPC> - <SPC> start <SPC> + <SPC> 1 ) <NL>              start <SPC> = <SPC> i <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLUSlength ( self , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> if <SPC> a <SPC> == <SPC> b : <NL>          return <SPC> - 1 <NL> <TAB> return <SPC> max ( len ( a ) , <SPC> len ( b ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLUSlength ( self , <SPC> strs ) : <NL> <NL> <TAB> def <SPC> isSubsequence ( a , <SPC> b ) : <NL>          i <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( b ) ) : <NL>              if <SPC> i <SPC> >= <SPC> len ( a ) : <NL>                  break <NL>              if <SPC> a [ i ] <SPC> == <SPC> b [ j ] : <NL>                  i <SPC> += <SPC> 1 <NL>          return <SPC> i <SPC> == <SPC> len ( a ) <NL> <NL> <TAB> strs . sort ( key = len , <SPC> reverse = True ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( strs ) ) : <NL>          all_of <SPC> = <SPC> True <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( strs ) ) : <NL>              if <SPC> len ( strs [ j ] ) <SPC> < <SPC> len ( strs [ i ] ) : <NL>                  break <NL>              if <SPC> i <SPC> != <SPC> j <SPC> and <SPC> isSubsequence ( strs [ i ] , <SPC> strs [ j ] ) : <NL>                  all_of <SPC> = <SPC> False <NL>                  break <NL>          if <SPC> all_of : <NL>              return <SPC> len ( strs [ i ] ) <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestUnivaluePath ( self , <SPC> root ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <NL> <TAB> def <SPC> dfs ( node ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> 0 <NL>          left , <SPC> right <SPC> = <SPC> dfs ( node . left ) , <SPC> dfs ( node . right ) <NL>          left <SPC> = <SPC> ( left <SPC> + <SPC> 1 ) <SPC> if <SPC> node . left <SPC> and <SPC> node . left . val <SPC> == <SPC> node . val <SPC> else <SPC> 0 <NL>          right <SPC> = <SPC> ( right <SPC> + <SPC> 1 ) <SPC> if <SPC> node . right <SPC> and <SPC> node . right . val <SPC> == <SPC> node . val <SPC> else <SPC> 0 <NL>          result [ 0 ] <SPC> = <SPC> max ( result [ 0 ] , <SPC> left <SPC> + <SPC> right ) <NL>          return <SPC> max ( left , <SPC> right ) <NL> <NL> <TAB> dfs ( root ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestValidParentheses ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> length ( it , <SPC> start , <SPC> c ) : <NL>          depth , <SPC> longest <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> it : <NL>              if <SPC> s [ i ] <SPC> == <SPC> c : <NL>                  depth <SPC> += <SPC> 1 <NL>              else : <NL>                  depth <SPC> -= <SPC> 1 <NL>                  if <SPC> depth <SPC> < <SPC> 0 : <NL>                      start , <SPC> depth <SPC> = <SPC> i , <SPC> 0 <NL>                  elif <SPC> depth <SPC> == <SPC> 0 : <NL>                      longest <SPC> = <SPC> max ( longest , <SPC> abs ( i <SPC> - <SPC> start ) ) <NL>          return <SPC> longest <NL> <NL> <TAB> return <SPC> max ( <NL>          length ( xrange ( len ( s ) ) , <SPC> - 1 , <SPC> "(" ) , <NL>          length ( reversed ( xrange ( len ( s ) ) ) , <SPC> len ( s ) , <SPC> ")" ) , <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> longestValidParentheses ( self , <SPC> s ) : <NL> <TAB> longest , <SPC> last , <SPC> indices <SPC> = <SPC> 0 , <SPC> - 1 , <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>              indices . append ( i ) <NL>          elif <SPC> not <SPC> indices : <NL>              last <SPC> = <SPC> i <NL>          else : <NL>              indices . pop ( ) <NL>              if <SPC> not <SPC> indices : <NL>                  longest <SPC> = <SPC> max ( longest , <SPC> i <SPC> - <SPC> last ) <NL>              else : <NL>                  longest <SPC> = <SPC> max ( longest , <SPC> i <SPC> - <SPC> indices [ - 1 ] ) <NL> <TAB> return <SPC> longest <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestWPI ( self , <SPC> hours ) : <NL> <NL> <TAB> result , <SPC> accu <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> h <SPC> in <SPC> enumerate ( hours ) : <NL>          accu <SPC> = <SPC> accu <SPC> + <SPC> 1 <SPC> if <SPC> h <SPC> > <SPC> 8 <SPC> else <SPC> accu <SPC> - <SPC> 1 <NL>          if <SPC> accu <SPC> > <SPC> 0 : <NL>              result <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>          elif <SPC> accu <SPC> - <SPC> 1 <SPC> in <SPC> lookup : <NL> <NL>              result <SPC> = <SPC> max ( result , <SPC> i <SPC> - <SPC> lookup [ accu <SPC> - <SPC> 1 ] ) <NL>          lookup . setdefault ( accu , <SPC> i ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLongestWord ( self , <SPC> s , <SPC> d ) : <NL> <NL> <TAB> d . sort ( key = lambda <SPC> x : <SPC> ( - len ( x ) , <SPC> x ) ) <NL> <TAB> for <SPC> word <SPC> in <SPC> d : <NL>          i <SPC> = <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> s : <NL>              if <SPC> i <SPC> < <SPC> len ( word ) <SPC> and <SPC> word [ i ] <SPC> == <SPC> c : <NL>                  i <SPC> += <SPC> 1 <NL>          if <SPC> i <SPC> == <SPC> len ( word ) : <NL>              return <SPC> word <NL> <TAB> return <SPC> "" <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> defaultdict <NL> from <SPC> operator <SPC> import <SPC> getitem <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestWord ( self , <SPC> words ) : <NL> <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> defaultdict ( _trie ) <NL> <TAB> trie <SPC> = <SPC> _trie ( ) <NL> <TAB> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          reduce ( getitem , <SPC> word , <SPC> trie ) [ "_end" ] <SPC> = <SPC> i <NL> <NL> <TAB> stack <SPC> = <SPC> trie . values ( ) <NL> <TAB> result <SPC> = <SPC> "" <NL> <TAB> while <SPC> stack : <NL>          curr <SPC> = <SPC> stack . pop ( ) <NL>          if <SPC> "_end" <SPC> in <SPC> curr : <NL>              word <SPC> = <SPC> words [ curr [ "_end" ] ] <NL>              if <SPC> len ( word ) <SPC> > <SPC> len ( result ) <SPC> or <SPC> ( <NL>                  len ( word ) <SPC> == <SPC> len ( result ) <SPC> and <SPC> word <SPC> < <SPC> result <NL>              ) : <NL>                  result <SPC> = <SPC> word <NL>              stack <SPC> += <SPC> [ curr [ letter ] <SPC> for <SPC> letter <SPC> in <SPC> curr <SPC> if <SPC> letter <SPC> != <SPC> "_end" ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestZigZag ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> result ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> [ - 1 , <SPC> - 1 ] <NL>          left , <SPC> right <SPC> = <SPC> dfs ( node . left , <SPC> result ) , <SPC> dfs ( node . right , <SPC> result ) <NL>          result [ 0 ] <SPC> = <SPC> max ( result [ 0 ] , <SPC> left [ 1 ] <SPC> + <SPC> 1 , <SPC> right [ 0 ] <SPC> + <SPC> 1 ) <NL>          return <SPC> [ left [ 1 ] <SPC> + <SPC> 1 , <SPC> right [ 0 ] <SPC> + <SPC> 1 ] <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> dfs ( root , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> loudAndRich ( self , <SPC> richer , <SPC> quiet ) : <NL> <NL> <TAB> def <SPC> dfs ( graph , <SPC> quiet , <SPC> node , <SPC> result ) : <NL>          if <SPC> result [ node ] <SPC> is <SPC> None : <NL>              result [ node ] <SPC> = <SPC> node <NL>              for <SPC> nei <SPC> in <SPC> graph [ node ] : <NL>                  smallest_person <SPC> = <SPC> dfs ( graph , <SPC> quiet , <SPC> nei , <SPC> result ) <NL>                  if <SPC> quiet [ smallest_person ] <SPC> < <SPC> quiet [ result [ node ] ] : <NL>                      result [ node ] <SPC> = <SPC> smallest_person <NL>          return <SPC> result [ node ] <NL> <NL> <TAB> graph <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( quiet ) ) ] <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> richer : <NL>          graph [ v ] . append ( u ) <NL> <TAB> result <SPC> = <SPC> [ None ] <SPC> * <SPC> len ( quiet ) <NL> <TAB> return <SPC> map ( lambda <SPC> x : <SPC> dfs ( graph , <SPC> quiet , <SPC> x , <SPC> result ) , <SPC> xrange ( len ( quiet ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> lowestCommonAncestor ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <TAB> s , <SPC> b <SPC> = <SPC> sorted ( [ p . val , <SPC> q . val ] ) <NL> <TAB> while <SPC> not <SPC> s <SPC> <= <SPC> root . val <SPC> <= <SPC> b : <NL> <NL>          root <SPC> = <SPC> root . left <SPC> if <SPC> s <SPC> <= <SPC> root . val <SPC> else <SPC> root . right <NL> <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lowestCommonAncestor ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> def <SPC> iter_dfs ( node , <SPC> p , <SPC> q ) : <NL>          result <SPC> = <SPC> None <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> ( node , <SPC> [ 0 ] ) ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  node , <SPC> ret <SPC> = <SPC> params <NL>                  if <SPC> not <SPC> node : <NL>                      continue <NL>                  ret1 , <SPC> ret2 <SPC> = <SPC> [ 0 ] , <SPC> [ 0 ] <NL>                  stk . append ( ( 2 , <SPC> ( node , <SPC> ret1 , <SPC> ret2 , <SPC> ret ) ) ) <NL>                  stk . append ( ( 1 , <SPC> ( node . right , <SPC> ret2 ) ) ) <NL>                  stk . append ( ( 1 , <SPC> ( node . left , <SPC> ret1 ) ) ) <NL>              elif <SPC> step <SPC> == <SPC> 2 : <NL>                  node , <SPC> ret1 , <SPC> ret2 , <SPC> ret <SPC> = <SPC> params <NL>                  curr <SPC> = <SPC> int ( node <SPC> == <SPC> p <SPC> or <SPC> node <SPC> == <SPC> q ) <NL>                  if <SPC> curr <SPC> + <SPC> ret1 [ 0 ] <SPC> + <SPC> ret2 [ 0 ] <SPC> == <SPC> 2 <SPC> and <SPC> not <SPC> result : <NL>                      result <SPC> = <SPC> node <NL>                  ret [ 0 ] <SPC> = <SPC> curr <SPC> + <SPC> ret1 [ 0 ] <SPC> + <SPC> ret2 [ 0 ] <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> iter_dfs ( root , <SPC> p , <SPC> q ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> lowestCommonAncestor ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> p , <SPC> q , <SPC> result ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> 0 <NL>          left <SPC> = <SPC> dfs ( node . left , <SPC> p , <SPC> q , <SPC> result ) <NL>          right <SPC> = <SPC> dfs ( node . right , <SPC> p , <SPC> q , <SPC> result ) <NL>          curr <SPC> = <SPC> int ( node <SPC> == <SPC> p <SPC> or <SPC> node <SPC> == <SPC> q ) <NL>          if <SPC> curr <SPC> + <SPC> left <SPC> + <SPC> right <SPC> == <SPC> 2 <SPC> and <SPC> not <SPC> result [ 0 ] : <NL>              result [ 0 ] <SPC> = <SPC> node <NL>          return <SPC> curr <SPC> + <SPC> left <SPC> + <SPC> right <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> dfs ( root , <SPC> p , <SPC> q , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Node : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lowestCommonAncestor ( self , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> a , <SPC> b <SPC> = <SPC> p , <SPC> q <NL> <TAB> while <SPC> a <SPC> != <SPC> b : <NL>          a <SPC> = <SPC> a . parent <SPC> if <SPC> a <SPC> else <SPC> q <NL>          b <SPC> = <SPC> b . parent <SPC> if <SPC> b <SPC> else <SPC> p <NL> <TAB> return <SPC> a <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> lowestCommonAncestor ( self , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> def <SPC> depth ( node ) : <NL>          d <SPC> = <SPC> 0 <NL>          while <SPC> node : <NL>              node <SPC> = <SPC> node . parent <NL>              d <SPC> += <SPC> 1 <NL>          return <SPC> d <NL> <NL> <TAB> p_d , <SPC> q_d <SPC> = <SPC> depth ( p ) , <SPC> depth ( q ) <NL> <TAB> while <SPC> p_d <SPC> > <SPC> q_d : <NL>          p <SPC> = <SPC> p . parent <NL>          p_d <SPC> -= <SPC> 1 <NL> <TAB> while <SPC> p_d <SPC> < <SPC> q_d : <NL>          q <SPC> = <SPC> q . parent <NL>          q_d <SPC> -= <SPC> 1 <NL> <TAB> while <SPC> p <SPC> != <SPC> q : <NL>          p <SPC> = <SPC> p . parent <NL>          q <SPC> = <SPC> q . parent <NL> <TAB> return <SPC> p <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lowestCommonAncestor ( self , <SPC> root , <SPC> nodes ) : <NL> <NL> <TAB> def <SPC> iter_dfs ( root , <SPC> lookup ) : <NL>          result <SPC> = <SPC> [ 0 ] <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> ( root , <SPC> result ) ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> args <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  node , <SPC> ret <SPC> = <SPC> args <NL>                  if <SPC> not <SPC> node <SPC> or <SPC> node <SPC> in <SPC> lookup : <NL>                      ret [ 0 ] <SPC> = <SPC> node <NL>                      continue <NL>                  ret1 , <SPC> ret2 <SPC> = <SPC> [ None ] , <SPC> [ None ] <NL>                  stk . append ( ( 2 , <SPC> ( node , <SPC> ret1 , <SPC> ret2 , <SPC> ret ) ) ) <NL>                  stk . append ( ( 1 , <SPC> ( node . right , <SPC> ret2 ) ) ) <NL>                  stk . append ( ( 1 , <SPC> ( node . left , <SPC> ret1 ) ) ) <NL>              elif <SPC> step <SPC> == <SPC> 2 : <NL>                  node , <SPC> ret1 , <SPC> ret2 , <SPC> ret <SPC> = <SPC> args <NL>                  if <SPC> ret1 [ 0 ] <SPC> and <SPC> ret2 [ 0 ] : <NL>                      ret [ 0 ] <SPC> = <SPC> node <NL>                  else : <NL>                      ret [ 0 ] <SPC> = <SPC> ret1 [ 0 ] <SPC> or <SPC> ret2 [ 0 ] <NL>          return <SPC> result [ 0 ] <NL> <NL> <TAB> return <SPC> iter_dfs ( root , <SPC> set ( nodes ) ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> lowestCommonAncestor ( self , <SPC> root , <SPC> nodes ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> lookup ) : <NL>          if <SPC> not <SPC> node <SPC> or <SPC> node <SPC> in <SPC> lookup : <NL>              return <SPC> node <NL>          left , <SPC> right <SPC> = <SPC> dfs ( node . left , <SPC> lookup ) , <SPC> dfs ( node . right , <SPC> lookup ) <NL>          if <SPC> left <SPC> and <SPC> right : <NL>              return <SPC> node <NL>          return <SPC> left <SPC> or <SPC> right <NL> <NL> <TAB> return <SPC> dfs ( root , <SPC> set ( nodes ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> lowestCommonAncestor ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <TAB> if <SPC> root <SPC> in <SPC> ( None , <SPC> p , <SPC> q ) : <NL>          return <SPC> root <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> [ <NL>          self . lowestCommonAncestor ( child , <SPC> p , <SPC> q ) <SPC> for <SPC> child <SPC> in <SPC> ( root . left , <SPC> root . right ) <NL> <TAB> ] <NL> <NL> <TAB> return <SPC> root <SPC> if <SPC> left <SPC> and <SPC> right <SPC> else <SPC> left <SPC> or <SPC> right <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> lcaDeepestLeaves ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> lcaDeepestLeavesHelper ( root ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 , <SPC> None <NL>          d1 , <SPC> lca1 <SPC> = <SPC> lcaDeepestLeavesHelper ( root . left ) <NL>          d2 , <SPC> lca2 <SPC> = <SPC> lcaDeepestLeavesHelper ( root . right ) <NL>          if <SPC> d1 <SPC> > <SPC> d2 : <NL>              return <SPC> d1 <SPC> + <SPC> 1 , <SPC> lca1 <NL>          if <SPC> d1 <SPC> < <SPC> d2 : <NL>              return <SPC> d2 <SPC> + <SPC> 1 , <SPC> lca2 <NL>          return <SPC> d1 <SPC> + <SPC> 1 , <SPC> root <NL> <NL> <TAB> return <SPC> lcaDeepestLeavesHelper ( root ) [ 1 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> LRUCache ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> capacity ) : <NL> <TAB> self . cache <SPC> = <SPC> collections . OrderedDict ( ) <NL> <TAB> self . capacity <SPC> = <SPC> capacity <NL> <NL> <TAB> def <SPC> get ( self , <SPC> key ) : <NL> <TAB> if <SPC> key <SPC> not <SPC> in <SPC> self . cache : <NL>          return <SPC> - 1 <NL> <TAB> val <SPC> = <SPC> self . cache [ key ] <NL> <TAB> self . __update ( key , <SPC> val ) <NL> <TAB> return <SPC> val <NL> <NL> <TAB> def <SPC> put ( self , <SPC> key , <SPC> val ) : <NL> <TAB> if <SPC> key <SPC> not <SPC> in <SPC> self . cache <SPC> and <SPC> len ( self . cache ) <SPC> == <SPC> self . capacity : <NL>          self . cache . popitem ( last = False ) <NL> <TAB> self . __update ( key , <SPC> val ) <NL> <NL> <TAB> def <SPC> __update ( self , <SPC> key , <SPC> val ) : <NL> <TAB> if <SPC> key <SPC> in <SPC> self . cache : <NL>          del <SPC> self . cache [ key ] <NL> <TAB> self . cache [ key ] <SPC> = <SPC> val <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> key , <SPC> val ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . key <SPC> = <SPC> key <NL> <TAB> self . next <SPC> = <SPC> None <NL> <TAB> self . prev <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> LinkedList ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . head <SPC> = <SPC> None <NL> <TAB> self . tail <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> node ) : <NL> <TAB> node . next , <SPC> node . prev <SPC> = <SPC> None , <SPC> None <NL> <TAB> if <SPC> self . head <SPC> is <SPC> None : <NL>          self . head <SPC> = <SPC> node <NL> <TAB> else : <NL>          self . tail . next <SPC> = <SPC> node <NL>          node . prev <SPC> = <SPC> self . tail <NL> <TAB> self . tail <SPC> = <SPC> node <NL> <NL> <TAB> def <SPC> delete ( self , <SPC> node ) : <NL> <TAB> if <SPC> node . prev : <NL>          node . prev . next <SPC> = <SPC> node . next <NL> <TAB> else : <NL>          self . head <SPC> = <SPC> node . next <NL> <TAB> if <SPC> node . next : <NL>          node . next . prev <SPC> = <SPC> node . prev <NL> <TAB> else : <NL>          self . tail <SPC> = <SPC> node . prev <NL> <TAB> node . next , <SPC> node . prev <SPC> = <SPC> None , <SPC> None <NL> <NL> <NL> class <SPC> LRUCache2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> capacity ) : <NL> <TAB> self . list <SPC> = <SPC> LinkedList ( ) <NL> <TAB> self . dict <SPC> = <SPC> { } <NL> <TAB> self . capacity <SPC> = <SPC> capacity <NL> <NL> <TAB> def <SPC> get ( self , <SPC> key ) : <NL> <TAB> if <SPC> key <SPC> not <SPC> in <SPC> self . dict : <NL>          return <SPC> - 1 <NL> <TAB> val <SPC> = <SPC> self . dict [ key ] . val <NL> <TAB> self . __update ( key , <SPC> val ) <NL> <TAB> return <SPC> val <NL> <NL> <TAB> def <SPC> put ( self , <SPC> key , <SPC> val ) : <NL> <TAB> if <SPC> key <SPC> not <SPC> in <SPC> self . dict <SPC> and <SPC> len ( self . dict ) <SPC> == <SPC> self . capacity : <NL>          del <SPC> self . dict [ self . list . head . key ] <NL>          self . list . delete ( self . list . head ) <NL> <TAB> self . __update ( key , <SPC> val ) <NL> <NL> <TAB> def <SPC> __update ( self , <SPC> key , <SPC> val ) : <NL> <TAB> if <SPC> key <SPC> in <SPC> self . dict : <NL>          self . list . delete ( self . dict [ key ] ) <NL> <TAB> node <SPC> = <SPC> ListNode ( key , <SPC> val ) <NL> <TAB> self . list . insert ( node ) <NL> <TAB> self . dict [ key ] <SPC> = <SPC> node <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> luckyNumbers ( self , <SPC> matrix ) : <NL> <NL> <TAB> rows <SPC> = <SPC> map ( min , <SPC> matrix ) <NL> <TAB> cols <SPC> = <SPC> map ( max , <SPC> itertools . izip ( * matrix ) ) <NL> <TAB> return <SPC> [ <NL>          cell <NL>          for <SPC> i , <SPC> row <SPC> in <SPC> enumerate ( matrix ) <NL>          for <SPC> j , <SPC> cell <SPC> in <SPC> enumerate ( row ) <NL>          if <SPC> rows [ i ] <SPC> == <SPC> cols [ j ] <NL> <TAB> ] <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> luckyNumbers ( self , <SPC> matrix ) : <NL> <NL> <TAB> return <SPC> list ( set ( map ( min , <SPC> matrix ) ) <SPC> & <SPC> set ( map ( max , <SPC> itertools . izip ( * matrix ) ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numMagicSquaresInside ( self , <SPC> grid ) : <NL> <NL> <TAB> def <SPC> magic ( grid , <SPC> r , <SPC> c ) : <NL>          expect <SPC> = <SPC> k <SPC> * <SPC> ( k <SPC> ** <SPC> 2 <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 <NL>          nums <SPC> = <SPC> set ( ) <NL>          min_num <SPC> = <SPC> float ( "inf" ) <NL>          sum_diag , <SPC> sum_anti <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( k ) : <NL>              sum_diag <SPC> += <SPC> grid [ r <SPC> + <SPC> i ] [ c <SPC> + <SPC> i ] <NL>              sum_anti <SPC> += <SPC> grid [ r <SPC> + <SPC> i ] [ c <SPC> + <SPC> k <SPC> - <SPC> 1 <SPC> - <SPC> i ] <NL>              sum_r , <SPC> sum_c <SPC> = <SPC> 0 , <SPC> 0 <NL>              for <SPC> j <SPC> in <SPC> xrange ( k ) : <NL>                  min_num <SPC> = <SPC> min ( min_num , <SPC> grid [ r <SPC> + <SPC> i ] [ c <SPC> + <SPC> j ] ) <NL>                  nums . add ( grid [ r <SPC> + <SPC> i ] [ c <SPC> + <SPC> j ] ) <NL>                  sum_r <SPC> += <SPC> grid [ r <SPC> + <SPC> i ] [ c <SPC> + <SPC> j ] <NL>                  sum_c <SPC> += <SPC> grid [ r <SPC> + <SPC> j ] [ c <SPC> + <SPC> i ] <NL>              if <SPC> not <SPC> ( sum_r <SPC> == <SPC> sum_c <SPC> == <SPC> expect ) : <NL>                  return <SPC> False <NL>          return <SPC> ( <NL>              sum_diag <SPC> == <SPC> sum_anti <SPC> == <SPC> expect <SPC> and <SPC> len ( <NL>                  nums ) <SPC> == <SPC> k <SPC> ** <SPC> 2 <SPC> and <SPC> min_num <SPC> == <SPC> 1 <NL>          ) <NL> <NL> <TAB> k <SPC> = <SPC> 3 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> r <SPC> in <SPC> xrange ( len ( grid ) <SPC> - <SPC> k <SPC> + <SPC> 1 ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( len ( grid [ r ] ) <SPC> - <SPC> k <SPC> + <SPC> 1 ) : <NL>              if <SPC> magic ( grid , <SPC> r , <SPC> c ) : <NL>                  result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> magicalString ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> gen ( ) : <NL>          for <SPC> c <SPC> in <SPC> 1 , <SPC> 2 , <SPC> 2 : <NL>              yield <SPC> c <NL>          for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( gen ( ) ) : <NL>              if <SPC> i <SPC> > <SPC> 1 : <NL>                  for <SPC> _ <SPC> in <SPC> xrange ( c ) : <NL>                      yield <SPC> i <SPC> % <SPC> 2 <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> sum ( c <SPC> & <SPC> 1 <SPC> for <SPC> c <SPC> in <SPC> itertools . islice ( gen ( ) , <SPC> n ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxDistance ( self , <SPC> position , <SPC> m ) : <NL> <NL> <TAB> def <SPC> check ( position , <SPC> m , <SPC> x ) : <NL>          count , <SPC> prev <SPC> = <SPC> 1 , <SPC> position [ 0 ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( position ) ) : <NL>              if <SPC> position [ i ] <SPC> - <SPC> prev <SPC> >= <SPC> x : <NL>                  count <SPC> += <SPC> 1 <NL>                  prev <SPC> = <SPC> position [ i ] <NL>          return <SPC> count <SPC> >= <SPC> m <NL> <NL> <TAB> position . sort ( ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> position [ - 1 ] <SPC> - <SPC> position [ 0 ] <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( position , <SPC> m , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> right <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> majorityElement ( self , <SPC> nums ) : <NL> <NL> <TAB> k , <SPC> n , <SPC> cnts <SPC> = <SPC> 3 , <SPC> len ( nums ) , <SPC> collections . defaultdict ( int ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> nums : <NL>          cnts [ i ] <SPC> += <SPC> 1 <NL> <NL>          if <SPC> len ( cnts ) <SPC> == <SPC> k : <NL>              for <SPC> j <SPC> in <SPC> cnts . keys ( ) : <NL>                  cnts [ j ] <SPC> -= <SPC> 1 <NL>                  if <SPC> cnts [ j ] <SPC> == <SPC> 0 : <NL>                      del <SPC> cnts [ j ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> cnts . keys ( ) : <NL>          cnts [ i ] <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> nums : <NL>          if <SPC> i <SPC> in <SPC> cnts : <NL>              cnts [ i ] <SPC> += <SPC> 1 <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> cnts . keys ( ) : <NL>          if <SPC> cnts [ i ] <SPC> > <SPC> n <SPC> / <SPC> k : <NL>              result . append ( i ) <NL> <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> majorityElement2 ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> [ i [ 0 ] <SPC> for <SPC> i <SPC> in <SPC> collections . Counter ( nums ) . items ( ) <SPC> if <SPC> i [ 1 ] <SPC> > <SPC> len ( nums ) <SPC> / <SPC> 3 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> majorityElement ( self , <SPC> nums ) : <NL> <NL> <TAB> idx , <SPC> cnt <SPC> = <SPC> 0 , <SPC> 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( nums ) ) : <NL>          if <SPC> nums [ idx ] <SPC> == <SPC> nums [ i ] : <NL>              cnt <SPC> += <SPC> 1 <NL>          else : <NL>              cnt <SPC> -= <SPC> 1 <NL>              if <SPC> cnt <SPC> == <SPC> 0 : <NL>                  idx <SPC> = <SPC> i <NL>                  cnt <SPC> = <SPC> 1 <NL> <NL> <TAB> return <SPC> nums [ idx ] <NL> <NL> <TAB> def <SPC> majorityElement2 ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> sorted ( <NL>          collections . Counter ( nums ) . items ( ) , <SPC> key = lambda <SPC> a : <SPC> a [ 1 ] , <SPC> reverse = True <NL> <TAB> ) [ 0 ] [ 0 ] <NL> <NL> <TAB> def <SPC> majorityElement3 ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> collections . Counter ( nums ) . most_common ( 1 ) [ 0 ] [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> makeArrayIncreasing ( self , <SPC> arr1 , <SPC> arr2 ) : <NL> <NL> <TAB> arr2 <SPC> = <SPC> sorted ( set ( arr2 ) ) <NL> <TAB> dp <SPC> = <SPC> { 0 : <SPC> - 1 } <NL> <TAB> for <SPC> val1 <SPC> in <SPC> arr1 : <NL>          next_dp <SPC> = <SPC> collections . defaultdict ( lambda : <SPC> float ( "inf" ) ) <NL>          for <SPC> cost , <SPC> val <SPC> in <SPC> dp . iteritems ( ) : <NL>              if <SPC> val <SPC> < <SPC> val1 : <NL>                  next_dp [ cost ] <SPC> = <SPC> min ( next_dp [ cost ] , <SPC> val1 ) <NL>              k <SPC> = <SPC> bisect . bisect_right ( arr2 , <SPC> val ) <NL>              if <SPC> k <SPC> == <SPC> len ( arr2 ) : <NL>                  continue <NL>              next_dp [ cost <SPC> + <SPC> 1 ] <SPC> = <SPC> min ( next_dp [ cost <SPC> + <SPC> 1 ] , <SPC> arr2 [ k ] ) <NL>          dp <SPC> = <SPC> next_dp <NL>          if <SPC> not <SPC> dp : <NL>              return <SPC> - 1 <NL> <TAB> return <SPC> min ( dp . iterkeys ( ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minSubarray ( self , <SPC> nums , <SPC> p ) : <NL> <NL> <TAB> residue <SPC> = <SPC> sum ( nums ) <SPC> % <SPC> p <NL> <TAB> if <SPC> not <SPC> residue : <NL>          return <SPC> 0 <NL> <TAB> result <SPC> = <SPC> len ( nums ) <NL> <TAB> curr , <SPC> lookup <SPC> = <SPC> 0 , <SPC> { 0 : <SPC> - 1 } <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          curr <SPC> = <SPC> ( curr <SPC> + <SPC> num ) <SPC> % <SPC> p <NL>          lookup [ curr ] <SPC> = <SPC> i <NL>          if <SPC> ( curr <SPC> - <SPC> residue ) <SPC> % <SPC> p <SPC> in <SPC> lookup : <NL>              result <SPC> = <SPC> min ( result , <SPC> i <SPC> - <SPC> lookup [ ( curr <SPC> - <SPC> residue ) <SPC> % <SPC> p ] ) <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> < <SPC> len ( nums ) <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> makeGood ( self , <SPC> s ) : <NL> <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> ch <SPC> in <SPC> s : <NL>          counter_ch <SPC> = <SPC> ch . upper ( ) <SPC> if <SPC> ch . islower ( ) <SPC> else <SPC> ch . lower ( ) <NL>          if <SPC> stk <SPC> and <SPC> stk [ - 1 ] <SPC> == <SPC> counter_ch : <NL>              stk . pop ( ) <NL>          else : <NL>              stk . append ( ch ) <NL> <TAB> return <SPC> "" . join ( stk ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minChanges ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> one_are_not_from_nums ( nums , <SPC> cnts ) : <NL>          mxs <SPC> = <SPC> [ cnts [ i ] . most_common ( 1 ) [ 0 ] [ 1 ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( k ) ] <NL>          return <SPC> len ( nums ) <SPC> - <SPC> ( sum ( mxs ) <SPC> - <SPC> min ( mxs ) ) <NL> <NL> <TAB> def <SPC> all_are_from_nums ( nums , <SPC> cnts ) : <NL>          dp <SPC> = <SPC> { 0 : <SPC> 0 } <NL>          for <SPC> cnt <SPC> in <SPC> cnts : <NL>              new_dp <SPC> = <SPC> collections . defaultdict ( int ) <NL>              for <SPC> x <SPC> in <SPC> dp . iterkeys ( ) : <NL>                  for <SPC> y <SPC> in <SPC> cnt . iterkeys ( ) : <NL>                      new_dp [ x <SPC> ^ <SPC> y ] <SPC> = <SPC> max ( new_dp [ x <SPC> ^ <SPC> y ] , <SPC> dp [ x ] <SPC> + <SPC> cnt [ y ] ) <NL>              dp <SPC> = <SPC> new_dp <NL>          return <SPC> len ( nums ) <SPC> - <SPC> dp [ 0 ] <NL> <NL> <TAB> cnts <SPC> = <SPC> [ <NL>          collections . Counter ( nums [ j ] <SPC> for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> len ( nums ) , <SPC> k ) ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( k ) <NL> <TAB> ] <NL> <TAB> return <SPC> min ( one_are_not_from_nums ( nums , <SPC> cnts ) , <SPC> all_are_from_nums ( nums , <SPC> cnts ) ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canBeEqual ( self , <SPC> target , <SPC> arr ) : <NL> <NL> <TAB> return <SPC> collections . Counter ( target ) <SPC> == <SPC> collections . Counter ( arr ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> canBeEqual ( self , <SPC> target , <SPC> arr ) : <NL> <NL> <TAB> target . sort ( ) , <SPC> arr . sort ( ) <NL> <TAB> return <SPC> target <SPC> == <SPC> arr <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestIsland ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> dfs ( r , <SPC> c , <SPC> index , <SPC> grid ) : <NL>          if <SPC> not <SPC> ( 0 <SPC> <= <SPC> r <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> c <SPC> < <SPC> len ( grid [ 0 ] ) <SPC> and <SPC> grid [ r ] [ c ] <SPC> == <SPC> 1 ) : <NL>              return <SPC> 0 <NL>          result <SPC> = <SPC> 1 <NL>          grid [ r ] [ c ] <SPC> = <SPC> index <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              result <SPC> += <SPC> dfs ( r <SPC> + <SPC> d [ 0 ] , <SPC> c <SPC> + <SPC> d [ 1 ] , <SPC> index , <SPC> grid ) <NL>          return <SPC> result <NL> <NL> <TAB> area <SPC> = <SPC> { } <NL> <TAB> index <SPC> = <SPC> 2 <NL> <TAB> for <SPC> r <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( len ( grid [ r ] ) ) : <NL>              if <SPC> grid [ r ] [ c ] <SPC> == <SPC> 1 : <NL>                  area [ index ] <SPC> = <SPC> dfs ( r , <SPC> c , <SPC> index , <SPC> grid ) <NL>                  index <SPC> += <SPC> 1 <NL> <NL> <TAB> result <SPC> = <SPC> max ( area . values ( ) <SPC> or <SPC> [ 0 ] ) <NL> <TAB> for <SPC> r <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( len ( grid [ r ] ) ) : <NL>              if <SPC> grid [ r ] [ c ] <SPC> == <SPC> 0 : <NL>                  seen <SPC> = <SPC> set ( ) <NL>                  for <SPC> d <SPC> in <SPC> directions : <NL>                      nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> d [ 0 ] , <SPC> c <SPC> + <SPC> d [ 1 ] <NL>                      if <SPC> not <SPC> ( <NL>                          0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( grid ) <NL>                          and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                          and <SPC> grid [ nr ] [ nc ] <SPC> > <SPC> 1 <NL>                      ) : <NL>                          continue <NL>                      seen . add ( grid [ nr ] [ nc ] ) <NL>                  result <SPC> = <SPC> max ( result , <SPC> 1 <SPC> + <SPC> sum ( area [ i ] <SPC> for <SPC> i <SPC> in <SPC> seen ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getFolderNames ( self , <SPC> names ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> result , <SPC> lookup <SPC> = <SPC> [ ] , <SPC> set ( ) <NL> <TAB> for <SPC> name <SPC> in <SPC> names : <NL>          while <SPC> True : <NL>              name_with_suffix <SPC> = <SPC> ( <NL>                  "{}({})" . format ( name , <SPC> count [ name ] ) <SPC> if <SPC> count [ name ] <SPC> else <SPC> name <NL>              ) <NL>              count [ name ] <SPC> += <SPC> 1 <NL>              if <SPC> name_with_suffix <SPC> not <SPC> in <SPC> lookup : <NL>                  break <NL>          result . append ( name_with_suffix ) <NL>          lookup . add ( name_with_suffix ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> highestPeak ( self , <SPC> isWater ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 1 , <SPC> 0 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( 0 , <SPC> - 1 ) ] <NL> <NL> <TAB> q <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( isWater ) : <NL>          for <SPC> c , <SPC> cell <SPC> in <SPC> enumerate ( row ) : <NL>              row [ c ] <SPC> -= <SPC> 1 <NL>              if <SPC> not <SPC> cell : <NL>                  continue <NL>              q . append ( ( r , <SPC> c ) ) <NL> <TAB> while <SPC> q : <NL>          new_q <SPC> = <SPC> [ ] <NL>          for <SPC> r , <SPC> c <SPC> in <SPC> q : <NL>              for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                  nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr , <SPC> c <SPC> + <SPC> dc <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( isWater ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( isWater [ 0 ] ) <NL>                      and <SPC> isWater [ nr ] [ nc ] <SPC> == <SPC> - 1 <NL>                  ) : <NL>                      continue <NL>                  isWater [ nr ] [ nc ] <SPC> = <SPC> isWater [ r ] [ c ] <SPC> + <SPC> 1 <NL>                  q . append ( ( nr , <SPC> nc ) ) <NL>          q <SPC> = <SPC> new_q <NL> <TAB> return <SPC> isWater <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> highestPeak ( self , <SPC> isWater ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 1 , <SPC> 0 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( 0 , <SPC> - 1 ) ] <NL> <NL> <TAB> q , <SPC> heights <SPC> = <SPC> [ ] , <SPC> [ [ - 1 ] <SPC> * <SPC> len ( isWater [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( isWater ) ) ] <NL> <TAB> for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( isWater ) : <NL>          for <SPC> c , <SPC> cell <SPC> in <SPC> enumerate ( row ) : <NL>              if <SPC> not <SPC> cell : <NL>                  continue <NL>              heights [ r ] [ c ] <SPC> = <SPC> 0 <NL>              q . append ( ( r , <SPC> c ) ) <NL> <TAB> while <SPC> q : <NL>          new_q <SPC> = <SPC> [ ] <NL>          for <SPC> r , <SPC> c <SPC> in <SPC> q : <NL>              for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                  nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr , <SPC> c <SPC> + <SPC> dc <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( isWater ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( isWater [ 0 ] ) <NL>                      and <SPC> heights [ nr ] [ nc ] <SPC> == <SPC> - 1 <NL>                  ) : <NL>                      continue <NL>                  heights [ nr ] [ nc ] <SPC> = <SPC> heights [ r ] [ c ] <SPC> + <SPC> 1 <NL>                  q . append ( ( nr , <SPC> nc ) ) <NL>          q <SPC> = <SPC> new_q <NL> <TAB> return <SPC> heights <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> MapSum ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> self . __root <SPC> = <SPC> _trie ( ) <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> key , <SPC> val ) : <NL> <NL> <TAB> curr <SPC> = <SPC> self . __root <NL> <TAB> for <SPC> c <SPC> in <SPC> key : <NL>          curr <SPC> = <SPC> curr [ c ] <NL> <TAB> delta <SPC> = <SPC> val <NL> <TAB> if <SPC> "_end" <SPC> in <SPC> curr : <NL>          delta <SPC> -= <SPC> curr [ "_end" ] <NL> <NL> <TAB> curr <SPC> = <SPC> self . __root <NL> <TAB> for <SPC> c <SPC> in <SPC> key : <NL>          curr <SPC> = <SPC> curr [ c ] <NL>          if <SPC> "_count" <SPC> in <SPC> curr : <NL>              curr [ "_count" ] <SPC> += <SPC> delta <NL>          else : <NL>              curr [ "_count" ] <SPC> = <SPC> delta <NL> <TAB> curr [ "_end" ] <SPC> = <SPC> val <NL> <NL> <TAB> def <SPC> sum ( self , <SPC> prefix ) : <NL> <NL> <TAB> curr <SPC> = <SPC> self . __root <NL> <TAB> for <SPC> c <SPC> in <SPC> prefix : <NL>          if <SPC> c <SPC> not <SPC> in <SPC> curr : <NL>              return <SPC> 0 <NL>          curr <SPC> = <SPC> curr [ c ] <NL> <TAB> return <SPC> curr [ "_count" ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maskPII ( self , <SPC> S ) : <NL> <NL> <TAB> if <SPC> "@" <SPC> in <SPC> S : <NL>          first , <SPC> after <SPC> = <SPC> S . split ( "@" ) <NL>          return <SPC> "{}*****{}@{}" . format ( first [ 0 ] , <SPC> first [ - 1 ] , <SPC> after ) . lower ( ) <NL> <NL> <TAB> digits <SPC> = <SPC> filter ( lambda <SPC> x : <SPC> x . isdigit ( ) , <SPC> S ) <NL> <TAB> local <SPC> = <SPC> "***-***-{}" . format ( digits [ - 4 : ] ) <NL> <TAB> if <SPC> len ( digits ) <SPC> == <SPC> 10 : <NL>          return <SPC> local <NL> <TAB> return <SPC> "+{}-{}" . format ( "*" <SPC> * <SPC> ( len ( digits ) <SPC> - <SPC> 10 ) , <SPC> local ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> makesquare ( self , <SPC> nums ) : <NL> <NL> <TAB> total_len <SPC> = <SPC> sum ( nums ) <NL> <TAB> if <SPC> total_len <SPC> % <SPC> 4 : <NL>          return <SPC> False <NL> <NL> <TAB> side_len <SPC> = <SPC> total_len <SPC> / <SPC> 4 <NL> <TAB> fullset <SPC> = <SPC> ( 1 <SPC> << <SPC> len ( nums ) ) <SPC> - <SPC> 1 <NL> <NL> <TAB> used_subsets <SPC> = <SPC> [ ] <NL> <TAB> valid_half_subsets <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 1 <SPC> << <SPC> len ( nums ) ) <NL> <NL> <TAB> for <SPC> subset <SPC> in <SPC> xrange ( fullset <SPC> + <SPC> 1 ) : <NL>          subset_total_len <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>              if <SPC> subset <SPC> & <SPC> ( 1 <SPC> << <SPC> i ) : <NL>                  subset_total_len <SPC> += <SPC> nums [ i ] <NL> <NL>          if <SPC> subset_total_len <SPC> == <SPC> side_len : <NL>              for <SPC> used_subset <SPC> in <SPC> used_subsets : <NL>                  if <SPC> ( used_subset <SPC> & <SPC> subset ) <SPC> == <SPC> 0 : <NL>                      valid_half_subset <SPC> = <SPC> used_subset <SPC> | <SPC> subset <NL>                      valid_half_subsets [ valid_half_subset ] <SPC> = <SPC> True <NL>                      if <SPC> valid_half_subsets [ fullset <SPC> ^ <SPC> valid_half_subset ] : <NL>                          return <SPC> True <NL>              used_subsets . append ( subset ) <NL> <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> matrixBlockSum ( self , <SPC> mat , <SPC> K ) : <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( mat ) , <SPC> len ( mat [ 0 ] ) <NL> <TAB> accu <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              accu [ i <SPC> + <SPC> 1 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> ( <NL>                  accu [ i <SPC> + <SPC> 1 ] [ j ] <SPC> + <SPC> accu [ i ] [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> accu [ i ] [ j ] <SPC> + <SPC> mat [ i ] [ j ] <NL>              ) <NL> <TAB> result <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              r1 , <SPC> c1 , <SPC> r2 , <SPC> c2 <SPC> = <SPC> ( <NL>                  max ( i <SPC> - <SPC> K , <SPC> 0 ) , <NL>                  max ( j <SPC> - <SPC> K , <SPC> 0 ) , <NL>                  min ( i <SPC> + <SPC> K <SPC> + <SPC> 1 , <SPC> m ) , <NL>                  min ( j <SPC> + <SPC> K <SPC> + <SPC> 1 , <SPC> n ) , <NL>              ) <NL>              result [ i ] [ j ] <SPC> = <SPC> accu [ r2 ] [ c2 ] <SPC> -                  accu [ r1 ] [ c2 ] <SPC> - <SPC> accu [ r2 ] [ c1 ] <SPC> + <SPC> accu [ r1 ] [ c1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> allCellsDistOrder ( self , <SPC> R , <SPC> C , <SPC> r0 , <SPC> c0 ) : <NL> <NL> <TAB> def <SPC> append ( R , <SPC> C , <SPC> r , <SPC> c , <SPC> result ) : <NL>          if <SPC> 0 <SPC> <= <SPC> r <SPC> < <SPC> R <SPC> and <SPC> 0 <SPC> <= <SPC> c <SPC> < <SPC> C : <NL>              result . append ( [ r , <SPC> c ] ) <NL> <NL> <TAB> result <SPC> = <SPC> [ [ r0 , <SPC> c0 ] ] <NL> <TAB> for <SPC> d <SPC> in <SPC> xrange ( 1 , <SPC> R <SPC> + <SPC> C ) : <NL>          append ( R , <SPC> C , <SPC> r0 <SPC> - <SPC> d , <SPC> c0 , <SPC> result ) <NL>          for <SPC> x <SPC> in <SPC> xrange ( - d <SPC> + <SPC> 1 , <SPC> d ) : <NL>              append ( R , <SPC> C , <SPC> r0 <SPC> + <SPC> x , <SPC> c0 <SPC> + <SPC> abs ( x ) <SPC> - <SPC> d , <SPC> result ) <NL>              append ( R , <SPC> C , <SPC> r0 <SPC> + <SPC> x , <SPC> c0 <SPC> + <SPC> d <SPC> - <SPC> abs ( x ) , <SPC> result ) <NL>          append ( R , <SPC> C , <SPC> r0 <SPC> + <SPC> d , <SPC> c0 , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> diagonalSum ( self , <SPC> mat ) : <NL> <NL> <TAB> return <SPC> sum ( mat [ i ] [ i ] <SPC> + <SPC> mat [ ~ i ] [ i ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( mat ) ) ) <SPC> - <SPC> ( <NL>          mat [ len ( mat ) <SPC> // <SPC> 2 ] [ len ( mat ) <SPC> // <SPC> 2 ] <SPC> if <SPC> len ( mat ) <SPC> % <SPC> 2 <SPC> == <SPC> 1 <SPC> else <SPC> 0 <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxAreaOfIsland ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ [ - 1 , <SPC> 0 ] , <SPC> [ 1 , <SPC> 0 ] , <SPC> [ 0 , <SPC> 1 ] , <SPC> [ 0 , <SPC> - 1 ] ] <NL> <NL> <TAB> def <SPC> dfs ( i , <SPC> j , <SPC> grid , <SPC> area ) : <NL>          if <SPC> not <SPC> ( 0 <SPC> <= <SPC> i <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> len ( grid [ 0 ] ) <SPC> and <SPC> grid [ i ] [ j ] <SPC> > <SPC> 0 ) : <NL>              return <SPC> False <NL>          grid [ i ] [ j ] <SPC> *= <SPC> - 1 <NL>          area [ 0 ] <SPC> += <SPC> 1 <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              dfs ( i <SPC> + <SPC> d [ 0 ] , <SPC> j <SPC> + <SPC> d [ 1 ] , <SPC> grid , <SPC> area ) <NL>          return <SPC> True <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              area <SPC> = <SPC> [ 0 ] <NL>              if <SPC> dfs ( i , <SPC> j , <SPC> grid , <SPC> area ) : <NL>                  result <SPC> = <SPC> max ( result , <SPC> area [ 0 ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxChunksToSorted ( self , <SPC> arr ) : <NL> <NL> <TAB> result , <SPC> increasing_stk <SPC> = <SPC> 0 , <SPC> [ ] <NL> <TAB> for <SPC> num <SPC> in <SPC> arr : <NL>          max_num <SPC> = <SPC> num <SPC> if <SPC> not <SPC> increasing_stk <SPC> else <SPC> max ( increasing_stk [ - 1 ] , <SPC> num ) <NL>          while <SPC> increasing_stk <SPC> and <SPC> increasing_stk [ - 1 ] <SPC> > <SPC> num : <NL>              increasing_stk . pop ( ) <NL>          increasing_stk . append ( max_num ) <NL> <TAB> return <SPC> len ( increasing_stk ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxChunksToSorted ( self , <SPC> arr ) : <NL> <NL> <TAB> def <SPC> compare ( i1 , <SPC> i2 ) : <NL>          return <SPC> arr [ i1 ] <SPC> - <SPC> arr [ i2 ] <SPC> if <SPC> arr [ i1 ] <SPC> != <SPC> arr [ i2 ] <SPC> else <SPC> i1 <SPC> - <SPC> i2 <NL> <NL> <TAB> idxs <SPC> = <SPC> [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( arr ) ) ] <NL> <TAB> result , <SPC> max_i <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( sorted ( idxs , <SPC> cmp = compare ) ) : <NL>          max_i <SPC> = <SPC> max ( max_i , <SPC> v ) <NL>          if <SPC> max_i <SPC> == <SPC> i : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxChunksToSorted ( self , <SPC> arr ) : <NL> <NL> <TAB> result , <SPC> max_i <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( arr ) : <NL>          max_i <SPC> = <SPC> max ( max_i , <SPC> v ) <NL>          if <SPC> max_i <SPC> == <SPC> i : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxChunksToSorted ( self , <SPC> arr ) : <NL> <NL> <TAB> result , <SPC> increasing_stk <SPC> = <SPC> 0 , <SPC> [ ] <NL> <TAB> for <SPC> num <SPC> in <SPC> arr : <NL>          max_num <SPC> = <SPC> num <SPC> if <SPC> not <SPC> increasing_stk <SPC> else <SPC> max ( increasing_stk [ - 1 ] , <SPC> num ) <NL>          while <SPC> increasing_stk <SPC> and <SPC> increasing_stk [ - 1 ] <SPC> > <SPC> num : <NL>              increasing_stk . pop ( ) <NL>          increasing_stk . append ( max_num ) <NL> <TAB> return <SPC> len ( increasing_stk ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMaxConsecutiveOnes ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> prev , <SPC> curr <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> n <SPC> in <SPC> nums : <NL>          if <SPC> n <SPC> == <SPC> 0 : <NL>              result <SPC> = <SPC> max ( result , <SPC> prev <SPC> + <SPC> curr <SPC> + <SPC> 1 ) <NL>              prev , <SPC> curr <SPC> = <SPC> curr , <SPC> 0 <NL>          else : <NL>              curr <SPC> += <SPC> 1 <NL> <TAB> return <SPC> min ( max ( result , <SPC> prev <SPC> + <SPC> curr <SPC> + <SPC> 1 ) , <SPC> len ( nums ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestOnes ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> result , <SPC> i <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          K <SPC> -= <SPC> int ( A [ j ] <SPC> == <SPC> 0 ) <NL>          while <SPC> K <SPC> < <SPC> 0 : <NL>              K <SPC> += <SPC> int ( A [ i ] <SPC> == <SPC> 0 ) <NL>              i <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> max ( result , <SPC> j <SPC> - <SPC> i <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMaxConsecutiveOnes ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> local_max <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> n <SPC> in <SPC> nums : <NL>          local_max <SPC> = <SPC> local_max <SPC> + <SPC> 1 <SPC> if <SPC> n <SPC> else <SPC> 0 <NL>          result <SPC> = <SPC> max ( result , <SPC> local_max ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxDiff ( self , <SPC> num ) : <NL> <NL> <TAB> digits <SPC> = <SPC> str ( num ) <NL> <TAB> for <SPC> b <SPC> in <SPC> digits : <NL>          if <SPC> b <SPC> < <SPC> "9" : <NL>              break <NL> <TAB> if <SPC> digits [ 0 ] <SPC> != <SPC> "1" : <NL>          a <SPC> = <SPC> digits [ 0 ] <NL> <TAB> else : <NL>          for <SPC> a <SPC> in <SPC> digits : <NL>              if <SPC> a <SPC> > <SPC> "1" : <NL>                  break <NL> <TAB> return <SPC> int ( digits . replace ( b , <SPC> "9" ) ) <SPC> - <SPC> int ( <NL>          digits . replace ( a , <SPC> "1" <SPC> if <SPC> digits [ 0 ] <SPC> != <SPC> "1" <SPC> else <SPC> "0" ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxDotProduct ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> if <SPC> len ( nums1 ) <SPC> < <SPC> len ( nums2 ) : <NL>          return <SPC> self . maxDotProduct ( nums2 , <SPC> nums1 ) <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( nums2 ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums1 ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( nums2 ) ) : <NL>              dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> nums1 [ i ] <SPC> * <SPC> nums2 [ j ] <NL>              if <SPC> i <SPC> and <SPC> j : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> += <SPC> max ( dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] , <SPC> 0 ) <NL>              if <SPC> i : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> max ( dp [ i <SPC> % <SPC> 2 ] [ j ] , <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] ) <NL>              if <SPC> j : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> max ( dp [ i <SPC> % <SPC> 2 ] [ j ] , <SPC> dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] ) <NL> <TAB> return <SPC> dp [ ( len ( nums1 ) <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ - 1 ] <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxIncreaseKeepingSkyline ( self , <SPC> grid ) : <NL> <NL> <TAB> row_maxes <SPC> = <SPC> [ max ( row ) <SPC> for <SPC> row <SPC> in <SPC> grid ] <NL> <TAB> col_maxes <SPC> = <SPC> [ max ( col ) <SPC> for <SPC> col <SPC> in <SPC> itertools . izip ( * grid ) ] <NL> <NL> <TAB> return <SPC> sum ( <NL>          min ( row_maxes [ r ] , <SPC> col_maxes [ c ] ) <SPC> - <SPC> val <NL>          for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( grid ) <NL>          for <SPC> c , <SPC> val <SPC> in <SPC> enumerate ( row ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxOperations ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> nums : <NL>          if <SPC> k <SPC> - <SPC> x <SPC> in <SPC> count <SPC> and <SPC> count [ k <SPC> - <SPC> x ] : <NL>              count [ k <SPC> - <SPC> x ] <SPC> -= <SPC> 1 <NL>              result <SPC> += <SPC> 1 <NL>          else : <NL>              count [ x ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Point ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> a = 0 , <SPC> b = 0 ) : <NL> <TAB> self . x <SPC> = <SPC> a <NL> <TAB> self . y <SPC> = <SPC> b <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxPoints ( self , <SPC> points ) : <NL> <NL> <TAB> max_points <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> start <SPC> in <SPC> enumerate ( points ) : <NL>          slope_count , <SPC> same <SPC> = <SPC> collections . defaultdict ( int ) , <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( points ) ) : <NL>              end <SPC> = <SPC> points [ j ] <NL>              if <SPC> start . x <SPC> == <SPC> end . x <SPC> and <SPC> start . y <SPC> == <SPC> end . y : <NL>                  same <SPC> += <SPC> 1 <NL>              else : <NL>                  slope <SPC> = <SPC> float ( "inf" ) <NL>                  if <SPC> start . x <SPC> - <SPC> end . x <SPC> != <SPC> 0 : <NL>                      slope <SPC> = <SPC> ( start . y <SPC> - <SPC> end . y ) <SPC> * <SPC> 1.0 <SPC> / <SPC> ( start . x <SPC> - <SPC> end . x ) <NL>                  slope_count [ slope ] <SPC> += <SPC> 1 <NL> <NL>          current_max <SPC> = <SPC> same <NL>          for <SPC> slope <SPC> in <SPC> slope_count : <NL>              current_max <SPC> = <SPC> max ( current_max , <SPC> slope_count [ slope ] <SPC> + <SPC> same ) <NL> <NL>          max_points <SPC> = <SPC> max ( max_points , <SPC> current_max ) <NL> <NL> <TAB> return <SPC> max_points <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> MaxStack ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . __idx_to_val <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> self . __val_to_idxs <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> self . __top <SPC> = <SPC> None <NL> <TAB> self . __max <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <NL> <TAB> idx <SPC> = <SPC> self . __val_to_idxs [ self . __top ] [ - 1 ] <SPC> + <SPC> 1 <SPC> if <SPC> self . __val_to_idxs <SPC> else <SPC> 0 <NL> <TAB> self . __idx_to_val [ idx ] <SPC> = <SPC> x <NL> <TAB> self . __val_to_idxs [ x ] . append ( idx ) <NL> <TAB> self . __top <SPC> = <SPC> x <NL> <TAB> self . __max <SPC> = <SPC> max ( self . __max , <SPC> x ) <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <NL> <TAB> val <SPC> = <SPC> self . __top <NL> <TAB> self . __remove ( val ) <NL> <TAB> return <SPC> val <NL> <NL> <TAB> def <SPC> top ( self ) : <NL> <NL> <TAB> return <SPC> self . __top <NL> <NL> <TAB> def <SPC> peekMax ( self ) : <NL> <NL> <TAB> return <SPC> self . __max <NL> <NL> <TAB> def <SPC> popMax ( self ) : <NL> <NL> <TAB> val <SPC> = <SPC> self . __max <NL> <TAB> self . __remove ( val ) <NL> <TAB> return <SPC> val <NL> <NL> <TAB> def <SPC> __remove ( self , <SPC> val ) : <NL> <TAB> idx <SPC> = <SPC> self . __val_to_idxs [ val ] [ - 1 ] <NL> <TAB> self . __val_to_idxs [ val ] . pop ( ) <NL> <TAB> if <SPC> not <SPC> self . __val_to_idxs [ val ] : <NL>          del <SPC> self . __val_to_idxs [ val ] <NL> <TAB> del <SPC> self . __idx_to_val [ idx ] <NL> <TAB> if <SPC> val <SPC> == <SPC> self . __top : <NL>          self . __top <SPC> = <SPC> ( <NL>              self . __idx_to_val [ max ( self . __idx_to_val . keys ( ) ) ] <NL>              if <SPC> self . __idx_to_val <NL>              else <SPC> None <NL>          ) <NL> <TAB> if <SPC> val <SPC> == <SPC> self . __max : <NL>          self . __max <SPC> = <SPC> max ( self . __val_to_idxs . keys ( ) <NL>                           ) <SPC> if <SPC> self . __val_to_idxs <SPC> else <SPC> None <NL> <NL> <NL> from <SPC> bisect <SPC> import <SPC> bisect_left , <SPC> insort <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSumSubmatrix ( self , <SPC> matrix , <SPC> k ) : <NL> <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <SPC> 0 <NL> <NL> <TAB> m <SPC> = <SPC> min ( len ( matrix ) , <SPC> len ( matrix [ 0 ] ) ) <NL> <TAB> n <SPC> = <SPC> max ( len ( matrix ) , <SPC> len ( matrix [ 0 ] ) ) <NL> <TAB> result <SPC> = <SPC> float ( "-inf" ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          sums <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> m ) : <NL>              for <SPC> l <SPC> in <SPC> xrange ( n ) : <NL>                  sums [ l ] <SPC> += <SPC> matrix [ j ] [ l ] <SPC> if <SPC> m <SPC> == <SPC> len ( matrix ) <SPC> else <SPC> matrix [ l ] [ j ] <NL> <NL>              accu_sum_set , <SPC> accu_sum <SPC> = <SPC> [ 0 ] , <SPC> 0 <NL>              for <SPC> sum <SPC> in <SPC> sums : <NL>                  accu_sum <SPC> += <SPC> sum <NL>                  it <SPC> = <SPC> bisect_left ( accu_sum_set , <SPC> accu_sum <SPC> - <SPC> k ) <NL>                  if <SPC> it <SPC> != <SPC> len ( accu_sum_set ) : <NL>                      result <SPC> = <SPC> max ( result , <SPC> accu_sum <SPC> - <SPC> accu_sum_set [ it ] ) <NL>                  insort ( accu_sum_set , <SPC> accu_sum ) <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution_TLE ( object ) : <NL> <TAB> def <SPC> maxSumSubmatrix ( self , <SPC> matrix , <SPC> k ) : <NL> <NL> <TAB> class <SPC> BST ( object ) : <NL>          def <SPC> __init__ ( self , <SPC> val ) : <NL>              self . val <SPC> = <SPC> val <NL>              self . left <SPC> = <SPC> None <NL>              self . right <SPC> = <SPC> None <NL> <NL>          def <SPC> insert ( self , <SPC> val ) : <NL>              curr <SPC> = <SPC> self <NL>              while <SPC> curr : <NL>                  if <SPC> curr . val <SPC> >= <SPC> val : <NL>                      if <SPC> curr . left : <NL>                          curr <SPC> = <SPC> curr . left <NL>                      else : <NL>                          curr . left <SPC> = <SPC> BST ( val ) <NL>                          return <NL>                  else : <NL>                      if <SPC> curr . right : <NL>                          curr <SPC> = <SPC> curr . right <NL>                      else : <NL>                          curr . right <SPC> = <SPC> BST ( val ) <NL>                          return <NL> <NL>          def <SPC> lower_bound ( self , <SPC> val ) : <NL>              result , <SPC> curr <SPC> = <SPC> None , <SPC> self <NL>              while <SPC> curr : <NL>                  if <SPC> curr . val <SPC> >= <SPC> val : <NL>                      result , <SPC> curr <SPC> = <SPC> curr , <SPC> curr . left <NL>                  else : <NL>                      curr <SPC> = <SPC> curr . right <NL>              return <SPC> result <NL> <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <SPC> 0 <NL> <NL> <TAB> m <SPC> = <SPC> min ( len ( matrix ) , <SPC> len ( matrix [ 0 ] ) ) <NL> <TAB> n <SPC> = <SPC> max ( len ( matrix ) , <SPC> len ( matrix [ 0 ] ) ) <NL> <TAB> result <SPC> = <SPC> float ( "-inf" ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          sums <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> m ) : <NL>              for <SPC> l <SPC> in <SPC> xrange ( n ) : <NL>                  sums [ l ] <SPC> += <SPC> matrix [ j ] [ l ] <SPC> if <SPC> m <SPC> == <SPC> len ( matrix ) <SPC> else <SPC> matrix [ l ] [ j ] <NL> <NL>              accu_sum_set <SPC> = <SPC> BST ( 0 ) <NL>              accu_sum <SPC> = <SPC> 0 <NL>              for <SPC> sum <SPC> in <SPC> sums : <NL>                  accu_sum <SPC> += <SPC> sum <NL>                  node <SPC> = <SPC> accu_sum_set . lower_bound ( accu_sum <SPC> - <SPC> k ) <NL>                  if <SPC> node : <NL>                      result <SPC> = <SPC> max ( result , <SPC> accu_sum <SPC> - <SPC> node . val ) <NL>                  accu_sum_set . insert ( accu_sum ) <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMaxValueOfEquation ( self , <SPC> points , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> float ( "-inf" ) <NL> <TAB> dq <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i , <SPC> ( x , <SPC> y ) <SPC> in <SPC> enumerate ( points ) : <NL>          while <SPC> dq <SPC> and <SPC> points [ dq [ 0 ] ] [ 0 ] <SPC> < <SPC> x <SPC> - <SPC> k : <NL>              dq . popleft ( ) <NL>          if <SPC> dq : <NL>              result <SPC> = <SPC> max ( result , <SPC> ( points [ dq [ 0 ] ] [ 1 ] <SPC> - <SPC> points [ dq [ 0 ] ] [ 0 ] ) <SPC> + <SPC> y <SPC> + <SPC> x ) <NL>          while <SPC> dq <SPC> and <SPC> points [ dq [ - 1 ] ] [ 1 ] <SPC> - <SPC> points [ dq [ - 1 ] ] [ 0 ] <SPC> <= <SPC> y <SPC> - <SPC> x : <NL>              dq . pop ( ) <NL>          dq . append ( i ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximalNetworkRank ( self , <SPC> n , <SPC> roads ) : <NL> <NL> <TAB> MAX_N <SPC> = <SPC> 100 <NL> <TAB> MAX_NUM <SPC> = <SPC> MAX_N <SPC> - <SPC> 1 <NL> <NL> <TAB> def <SPC> counting_sort ( <NL>          arr , <SPC> key = lambda <SPC> x : <SPC> x , <SPC> reverse = False <NL> <TAB> ) : <NL>          count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( MAX_NUM <SPC> + <SPC> 1 ) <NL>          for <SPC> x <SPC> in <SPC> arr : <NL>              count [ key ( x ) ] <SPC> += <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( count ) ) : <NL>              count [ i ] <SPC> += <SPC> count [ i <SPC> - <SPC> 1 ] <NL>          result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( arr ) <NL>          if <SPC> not <SPC> reverse : <NL>              for <SPC> x <SPC> in <SPC> reversed ( arr ) : <NL>                  count [ key ( x ) ] <SPC> -= <SPC> 1 <NL>                  result [ count [ key ( x ) ] ] <SPC> = <SPC> x <NL>          else : <NL>              for <SPC> x <SPC> in <SPC> arr : <NL>                  count [ key ( x ) ] <SPC> -= <SPC> 1 <NL>                  result [ count [ key ( x ) ] ] <SPC> = <SPC> x <NL>              result . reverse ( ) <NL>          return <SPC> result <NL> <NL> <TAB> degree <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> a , <SPC> b <SPC> in <SPC> roads : <NL>          degree [ a ] <SPC> += <SPC> 1 <NL>          degree [ b ] <SPC> += <SPC> 1 <NL>          adj [ a ] . add ( b ) <NL>          adj [ b ] . add ( a ) <NL> <TAB> sorted_idx <SPC> = <SPC> counting_sort ( <NL>          xrange ( n ) , <SPC> key = lambda <SPC> x : <SPC> degree [ x ] , <SPC> reverse = True ) <NL> <TAB> m <SPC> = <SPC> 2 <NL> <TAB> while <SPC> m <SPC> < <SPC> n : <NL>          if <SPC> degree [ sorted_idx [ m ] ] <SPC> != <SPC> degree [ sorted_idx [ 1 ] ] : <NL>              break <NL>          m <SPC> += <SPC> 1 <NL> <TAB> result <SPC> = <SPC> ( <NL>          degree [ sorted_idx [ 0 ] ] <SPC> + <SPC> degree [ sorted_idx [ 1 ] ] <SPC> - <SPC> 1 <NL> <TAB> ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m <SPC> - <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> m ) : <NL>              if <SPC> ( <NL>                  degree [ sorted_idx [ i ] ] <NL>                  + <SPC> degree [ sorted_idx [ j ] ] <NL>                  - <SPC> int ( sorted_idx [ i ] <SPC> in <SPC> adj <SPC> and <SPC> sorted_idx [ j ] <NL>                        in <SPC> adj [ sorted_idx [ i ] ] ) <NL>                  > <SPC> result <NL>              ) : <NL>                  return <SPC> ( <NL>                      degree [ sorted_idx [ i ] ] <NL>                      + <SPC> degree [ sorted_idx [ j ] ] <NL>                      - <SPC> int ( <NL>                          sorted_idx [ i ] <SPC> in <SPC> adj <SPC> and <SPC> sorted_idx [ j ] <SPC> in <SPC> adj [ sorted_idx [ i ] ] <NL>                      ) <NL>                  ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maximalNetworkRank ( self , <SPC> n , <SPC> roads ) : <NL> <NL> <TAB> degree <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> a , <SPC> b <SPC> in <SPC> roads : <NL>          degree [ a ] <SPC> += <SPC> 1 <NL>          degree [ b ] <SPC> += <SPC> 1 <NL>          adj [ a ] . add ( b ) <NL>          adj [ b ] . add ( a ) <NL> <TAB> sorted_idx <SPC> = <SPC> range ( n ) <NL> <TAB> sorted_idx . sort ( key = lambda <SPC> x : <SPC> - degree [ x ] ) <NL> <TAB> m <SPC> = <SPC> 2 <NL> <TAB> while <SPC> m <SPC> < <SPC> n : <NL>          if <SPC> degree [ sorted_idx [ m ] ] <SPC> != <SPC> degree [ sorted_idx [ 1 ] ] : <NL>              break <NL>          m <SPC> += <SPC> 1 <NL> <TAB> result <SPC> = <SPC> ( <NL>          degree [ sorted_idx [ 0 ] ] <SPC> + <SPC> degree [ sorted_idx [ 1 ] ] <SPC> - <SPC> 1 <NL> <TAB> ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m <SPC> - <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> m ) : <NL>              if <SPC> ( <NL>                  degree [ sorted_idx [ i ] ] <NL>                  + <SPC> degree [ sorted_idx [ j ] ] <NL>                  - <SPC> int ( sorted_idx [ i ] <SPC> in <SPC> adj <SPC> and <SPC> sorted_idx [ j ] <NL>                        in <SPC> adj [ sorted_idx [ i ] ] ) <NL>                  > <SPC> result <NL>              ) : <NL>                  return <SPC> ( <NL>                      degree [ sorted_idx [ i ] ] <NL>                      + <SPC> degree [ sorted_idx [ j ] ] <NL>                      - <SPC> int ( <NL>                          sorted_idx [ i ] <SPC> in <SPC> adj <SPC> and <SPC> sorted_idx [ j ] <SPC> in <SPC> adj [ sorted_idx [ i ] ] <NL>                      ) <NL>                  ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> maximalNetworkRank ( self , <SPC> n , <SPC> roads ) : <NL> <NL> <TAB> degree <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> a , <SPC> b <SPC> in <SPC> roads : <NL>          degree [ a ] <SPC> += <SPC> 1 <NL>          degree [ b ] <SPC> += <SPC> 1 <NL>          adj [ a ] . add ( b ) <NL>          adj [ b ] . add ( a ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n <SPC> - <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> n ) : <NL>              result <SPC> = <SPC> max ( <NL>                  result , <SPC> degree [ i ] <SPC> + <SPC> degree [ j ] <SPC> - <SPC> int ( i <SPC> in <SPC> adj <SPC> and <SPC> j <SPC> in <SPC> adj [ i ] ) <NL>              ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximalRectangle ( self , <SPC> matrix ) : <NL> <NL> <TAB> def <SPC> largestRectangleArea ( heights ) : <NL>          stk , <SPC> result , <SPC> i <SPC> = <SPC> [ - 1 ] , <SPC> 0 , <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( heights ) <SPC> + <SPC> 1 ) : <NL>              while <SPC> stk [ - 1 ] <SPC> != <SPC> - 1 <SPC> and <SPC> ( <NL>                  i <SPC> == <SPC> len ( heights ) <SPC> or <SPC> heights [ stk [ - 1 ] ] <SPC> >= <SPC> heights [ i ] <NL>              ) : <NL>                  result <SPC> = <SPC> max ( result , <SPC> heights [ stk . pop ( ) ] <SPC> * <SPC> ( ( i <SPC> - <SPC> 1 ) <SPC> - <SPC> stk [ - 1 ] ) ) <NL>              stk . append ( i ) <NL>          return <SPC> result <NL> <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <SPC> 0 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> heights <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( matrix [ 0 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) : <NL>              heights [ j ] <SPC> = <SPC> heights [ j ] <SPC> + <SPC> 1 <SPC> if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> "1" <SPC> else <SPC> 0 <NL>          result <SPC> = <SPC> max ( result , <SPC> largestRectangleArea ( heights ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maximalRectangle ( self , <SPC> matrix ) : <NL> <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <SPC> 0 <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> m <SPC> = <SPC> len ( matrix ) <NL> <TAB> n <SPC> = <SPC> len ( matrix [ 0 ] ) <NL> <TAB> L <SPC> = <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> H <SPC> = <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> R <SPC> = <SPC> [ n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          left <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> "1" : <NL>                  L [ j ] <SPC> = <SPC> max ( L [ j ] , <SPC> left ) <NL>                  H [ j ] <SPC> += <SPC> 1 <NL>              else : <NL>                  L [ j ] <SPC> = <SPC> 0 <NL>                  H [ j ] <SPC> = <SPC> 0 <NL>                  R [ j ] <SPC> = <SPC> n <NL>                  left <SPC> = <SPC> j <SPC> + <SPC> 1 <NL> <NL>          right <SPC> = <SPC> n <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( n ) ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> "1" : <NL>                  R [ j ] <SPC> = <SPC> min ( R [ j ] , <SPC> right ) <NL>                  result <SPC> = <SPC> max ( result , <SPC> H [ j ] <SPC> * <SPC> ( R [ j ] <SPC> - <SPC> L [ j ] ) ) <NL>              else : <NL>                  right <SPC> = <SPC> j <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maximalSquare ( self , <SPC> matrix ) : <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <SPC> 0 <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( matrix ) , <SPC> len ( matrix [ 0 ] ) <NL> <TAB> size <SPC> = <SPC> [ [ 0 <SPC> for <SPC> j <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> max_size <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>          if <SPC> matrix [ 0 ] [ j ] <SPC> == <SPC> "1" : <NL>              size [ 0 ] [ j ] <SPC> = <SPC> 1 <NL>          max_size <SPC> = <SPC> max ( max_size , <SPC> size [ 0 ] [ j ] ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> m ) : <NL>          if <SPC> matrix [ i ] [ 0 ] <SPC> == <SPC> "1" : <NL>              size [ i <SPC> % <SPC> 2 ] [ 0 ] <SPC> = <SPC> 1 <NL>          else : <NL>              size [ i <SPC> % <SPC> 2 ] [ 0 ] <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> "1" : <NL>                  size [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> ( <NL>                      min ( <NL>                          size [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] , <NL>                          size [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <NL>                          size [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] , <NL>                      ) <NL>                      + <SPC> 1 <NL>                  ) <NL>                  max_size <SPC> = <SPC> max ( max_size , <SPC> size [ i <SPC> % <SPC> 2 ] [ j ] ) <NL>              else : <NL>                  size [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> 0 <NL> <NL> <TAB> return <SPC> max_size <SPC> * <SPC> max_size <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> maximalSquare ( self , <SPC> matrix ) : <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <SPC> 0 <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( matrix ) , <SPC> len ( matrix [ 0 ] ) <NL> <TAB> size <SPC> = <SPC> [ [ 0 <SPC> for <SPC> j <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( m ) ] <NL> <TAB> max_size <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>          if <SPC> matrix [ 0 ] [ j ] <SPC> == <SPC> "1" : <NL>              size [ 0 ] [ j ] <SPC> = <SPC> 1 <NL>          max_size <SPC> = <SPC> max ( max_size , <SPC> size [ 0 ] [ j ] ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> m ) : <NL>          if <SPC> matrix [ i ] [ 0 ] <SPC> == <SPC> "1" : <NL>              size [ i ] [ 0 ] <SPC> = <SPC> 1 <NL>          else : <NL>              size [ i ] [ 0 ] <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> "1" : <NL>                  size [ i ] [ j ] <SPC> = <SPC> ( <NL>                      min ( size [ i ] [ j <SPC> - <SPC> 1 ] , <SPC> size [ i <SPC> - <SPC> 1 ] [ j ] , <SPC> size [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] ) <SPC> + <SPC> 1 <NL>                  ) <NL>                  max_size <SPC> = <SPC> max ( max_size , <SPC> size [ i ] [ j ] ) <NL>              else : <NL>                  size [ i ] [ j ] <SPC> = <SPC> 0 <NL> <NL> <TAB> return <SPC> max_size <SPC> * <SPC> max_size <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <NL> <TAB> def <SPC> maximalSquare ( self , <SPC> matrix ) : <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <SPC> 0 <NL> <NL> <TAB> H , <SPC> W <SPC> = <SPC> 0 , <SPC> 1 <NL> <NL> <TAB> table <SPC> = <SPC> [ [ [ 0 , <SPC> 0 ] <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) ] <NL>               for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( matrix ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( matrix [ i ] ) ) ) : <NL> <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> "1" : <NL>                  h , <SPC> w <SPC> = <SPC> 1 , <SPC> 1 <NL>                  if <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( matrix ) : <NL>                      h <SPC> = <SPC> table [ i <SPC> + <SPC> 1 ] [ j ] [ H ] <SPC> + <SPC> 1 <NL>                  if <SPC> j <SPC> + <SPC> 1 <SPC> < <SPC> len ( matrix [ i ] ) : <NL>                      w <SPC> = <SPC> table [ i ] [ j <SPC> + <SPC> 1 ] [ W ] <SPC> + <SPC> 1 <NL>                  table [ i ] [ j ] <SPC> = <SPC> [ h , <SPC> w ] <NL> <NL> <TAB> s <SPC> = <SPC> [ [ 0 <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) ] <NL> <TAB> max_square_area <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( matrix ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( matrix [ i ] ) ) ) : <NL>              side <SPC> = <SPC> min ( table [ i ] [ j ] [ H ] , <SPC> table [ i ] [ j ] [ W ] ) <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> "1" : <NL> <NL>                  if <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( matrix ) <SPC> and <SPC> j <SPC> + <SPC> 1 <SPC> < <SPC> len ( matrix [ i <SPC> + <SPC> 1 ] ) : <NL>                      side <SPC> = <SPC> min ( s [ i <SPC> + <SPC> 1 ] [ j <SPC> + <SPC> 1 ] <SPC> + <SPC> 1 , <SPC> side ) <NL>                  s [ i ] [ j ] <SPC> = <SPC> side <NL>                  max_square_area <SPC> = <SPC> max ( max_square_area , <SPC> side <SPC> * <SPC> side ) <NL> <NL> <TAB> return <SPC> max_square_area <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxDistToClosest ( self , <SPC> seats ) : <NL> <NL> <TAB> prev , <SPC> result <SPC> = <SPC> - 1 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( seats ) ) : <NL>          if <SPC> seats [ i ] : <NL>              if <SPC> prev <SPC> < <SPC> 0 : <NL>                  result <SPC> = <SPC> i <NL>              else : <NL>                  result <SPC> = <SPC> max ( result , <SPC> ( i <SPC> - <SPC> prev ) <SPC> // <SPC> 2 ) <NL>              prev <SPC> = <SPC> i <NL> <TAB> return <SPC> max ( result , <SPC> len ( seats ) <SPC> - <SPC> 1 <SPC> - <SPC> prev ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getMaxGridHappiness ( self , <SPC> m , <SPC> n , <SPC> introvertsCount , <SPC> extrovertsCount ) : <NL> <NL> <TAB> def <SPC> left ( curr ) : <NL>          return <SPC> curr [ - 1 ] <SPC> if <SPC> len ( curr ) <SPC> % <SPC> n <SPC> else <SPC> 0 <NL> <NL> <TAB> def <SPC> up ( curr ) : <NL>          return <SPC> curr [ - n ] <SPC> if <SPC> len ( curr ) <SPC> >= <SPC> n <SPC> else <SPC> 0 <NL> <NL> <TAB> def <SPC> count_total ( curr , <SPC> t , <SPC> total ) : <NL>          return <SPC> ( <NL>              total <NL>              - <SPC> 30 <SPC> * <SPC> ( ( left ( curr ) <SPC> == <SPC> 1 ) <SPC> + <SPC> ( up ( curr ) <SPC> == <SPC> 1 ) ) <NL>              + <SPC> 20 <SPC> * <SPC> ( ( left ( curr ) <SPC> == <SPC> 2 ) <SPC> + <SPC> ( up ( curr ) <SPC> == <SPC> 2 ) ) <NL>              + <SPC> ( 120 <SPC> - <SPC> 30 <SPC> * <SPC> ( ( left ( curr ) <SPC> != <SPC> 0 ) <SPC> + <SPC> ( up ( curr ) <SPC> != <SPC> 0 ) ) ) <SPC> * <SPC> ( t <SPC> == <SPC> 1 ) <NL>              + <SPC> ( 40 <SPC> + <SPC> 20 <SPC> * <SPC> ( ( left ( curr ) <SPC> != <SPC> 0 ) <SPC> + <SPC> ( up ( curr ) <SPC> != <SPC> 0 ) ) ) <SPC> * <SPC> ( t <SPC> == <SPC> 2 ) <NL>          ) <NL> <NL> <TAB> def <SPC> iter_backtracking ( i , <SPC> e ) : <NL>          result <SPC> = <SPC> 0 <NL>          curr <SPC> = <SPC> [ ] <NL>          stk <SPC> = <SPC> [ ( 2 , <SPC> ( i , <SPC> e , <SPC> 0 ) ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 2 : <NL>                  i , <SPC> e , <SPC> total <SPC> = <SPC> params <NL>                  if <SPC> len ( curr ) <SPC> == <SPC> m <SPC> * <SPC> n <SPC> or <SPC> ( i <SPC> == <SPC> 0 <SPC> and <SPC> e <SPC> == <SPC> 0 ) : <NL>                      result <SPC> = <SPC> max ( result , <SPC> total ) <NL>                      continue <NL>                  if <SPC> total <SPC> + <SPC> ( i <SPC> + <SPC> e ) <SPC> * <SPC> 120 <SPC> < <SPC> result : <NL>                      continue <NL>                  if <SPC> e <SPC> > <SPC> 0 : <NL>                      stk . append ( ( 3 , <SPC> tuple ( ) ) ) <NL>                      stk . append ( ( 2 , <SPC> ( i , <SPC> e <SPC> - <SPC> 1 , <SPC> count_total ( curr , <SPC> 2 , <SPC> total ) ) ) ) <NL>                      stk . append ( ( 1 , <SPC> ( 2 , ) ) ) <NL>                  if <SPC> i <SPC> > <SPC> 0 : <NL>                      stk . append ( ( 3 , <SPC> tuple ( ) ) ) <NL>                      stk . append ( ( 2 , <SPC> ( i <SPC> - <SPC> 1 , <SPC> e , <SPC> count_total ( curr , <SPC> 1 , <SPC> total ) ) ) ) <NL>                      stk . append ( ( 1 , <SPC> ( 1 , ) ) ) <NL>                  if <SPC> left ( curr ) <SPC> or <SPC> up ( <NL>                      curr <NL>                  ) : <NL>                      stk . append ( ( 3 , <SPC> tuple ( ) ) ) <NL>                      stk . append ( ( 2 , <SPC> ( i , <SPC> e , <SPC> total ) ) ) <NL>                      stk . append ( ( 1 , <SPC> ( 0 , ) ) ) <NL>              elif <SPC> step <SPC> == <SPC> 1 : <NL>                  x <SPC> = <SPC> params [ 0 ] <NL>                  curr . append ( x ) <NL>              elif <SPC> step <SPC> == <SPC> 3 : <NL>                  curr . pop ( ) <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> iter_backtracking ( introvertsCount , <SPC> extrovertsCount ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> getMaxGridHappiness ( self , <SPC> m , <SPC> n , <SPC> introvertsCount , <SPC> extrovertsCount ) : <NL> <NL> <TAB> def <SPC> left ( curr ) : <NL>          return <SPC> curr [ - 1 ] <SPC> if <SPC> len ( curr ) <SPC> % <SPC> n <SPC> else <SPC> 0 <NL> <NL> <TAB> def <SPC> up ( curr ) : <NL>          return <SPC> curr [ - n ] <SPC> if <SPC> len ( curr ) <SPC> >= <SPC> n <SPC> else <SPC> 0 <NL> <NL> <TAB> def <SPC> count_total ( curr , <SPC> t , <SPC> total ) : <NL>          return <SPC> ( <NL>              total <NL>              - <SPC> 30 <SPC> * <SPC> ( ( left ( curr ) <SPC> == <SPC> 1 ) <SPC> + <SPC> ( up ( curr ) <SPC> == <SPC> 1 ) ) <NL>              + <SPC> 20 <SPC> * <SPC> ( ( left ( curr ) <SPC> == <SPC> 2 ) <SPC> + <SPC> ( up ( curr ) <SPC> == <SPC> 2 ) ) <NL>              + <SPC> ( 120 <SPC> - <SPC> 30 <SPC> * <SPC> ( ( left ( curr ) <SPC> != <SPC> 0 ) <SPC> + <SPC> ( up ( curr ) <SPC> != <SPC> 0 ) ) ) <SPC> * <SPC> ( t <SPC> == <SPC> 1 ) <NL>              + <SPC> ( 40 <SPC> + <SPC> 20 <SPC> * <SPC> ( ( left ( curr ) <SPC> != <SPC> 0 ) <SPC> + <SPC> ( up ( curr ) <SPC> != <SPC> 0 ) ) ) <SPC> * <SPC> ( t <SPC> == <SPC> 2 ) <NL>          ) <NL> <NL> <TAB> def <SPC> backtracking ( i , <SPC> e , <SPC> total , <SPC> curr , <SPC> result ) : <NL>          if <SPC> len ( curr ) <SPC> == <SPC> m <SPC> * <SPC> n <SPC> or <SPC> ( i <SPC> == <SPC> 0 <SPC> and <SPC> e <SPC> == <SPC> 0 ) : <NL>              result [ 0 ] <SPC> = <SPC> max ( result [ 0 ] , <SPC> total ) <NL>              return <NL>          if <SPC> total <SPC> + <SPC> ( i <SPC> + <SPC> e ) <SPC> * <SPC> 120 <SPC> < <SPC> result [ 0 ] : <NL>              return <NL>          if <SPC> left ( curr ) <SPC> or <SPC> up ( curr ) : <NL>              curr . append ( 0 ) <NL>              backtracking ( i , <SPC> e , <SPC> total , <SPC> curr , <SPC> result ) <NL>              curr . pop ( ) <NL>          if <SPC> i <SPC> > <SPC> 0 : <NL>              new_total <SPC> = <SPC> count_total ( curr , <SPC> 1 , <SPC> total ) <NL>              curr . append ( 1 ) <NL>              backtracking ( i <SPC> - <SPC> 1 , <SPC> e , <SPC> new_total , <SPC> curr , <SPC> result ) <NL>              curr . pop ( ) <NL>          if <SPC> e <SPC> > <SPC> 0 : <NL>              new_total <SPC> = <SPC> count_total ( curr , <SPC> 2 , <SPC> total ) <NL>              curr . append ( 2 ) <NL>              backtracking ( i , <SPC> e <SPC> - <SPC> 1 , <SPC> new_total , <SPC> curr , <SPC> result ) <NL>              curr . pop ( ) <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> backtracking ( introvertsCount , <SPC> extrovertsCount , <SPC> 0 , <SPC> [ ] , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> longestPalindrome ( self , <SPC> word1 , <SPC> word2 ) : <NL> <NL> <TAB> s <SPC> = <SPC> word1 <SPC> + <SPC> word2 <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( s ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( s ) ) ] <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          dp [ j ] [ j ] <SPC> = <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( j ) ) : <NL>              if <SPC> s [ i ] <SPC> == <SPC> s [ j ] : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> 2 <SPC> if <SPC> i <SPC> + <SPC> 1 <SPC> == <SPC> j <SPC> else <SPC> dp [ i <SPC> + <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> 2 <NL>                  if <SPC> i <SPC> < <SPC> len ( word1 ) <SPC> <= <SPC> j : <NL>                      result <SPC> = <SPC> max ( result , <SPC> dp [ i ] [ j ] ) <NL>              else : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> max ( dp [ i <SPC> + <SPC> 1 ] [ j ] , <SPC> dp [ i ] [ j <SPC> - <SPC> 1 ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> longestPalindrome ( self , <SPC> word1 , <SPC> word2 ) : <NL> <NL> <TAB> s <SPC> = <SPC> word1 <SPC> + <SPC> word2 <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( s ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( s ) ) ] <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          dp [ j ] [ j ] <SPC> = <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( j ) ) : <NL>              if <SPC> s [ i ] <SPC> == <SPC> s [ j ] : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> 2 <SPC> if <SPC> i <SPC> + <SPC> 1 <SPC> == <SPC> j <SPC> else <SPC> dp [ i <SPC> + <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> 2 <NL>              else : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> max ( dp [ i <SPC> + <SPC> 1 ] [ j ] , <SPC> dp [ i ] [ j <SPC> - <SPC> 1 ] ) <NL> <TAB> return <SPC> max ( <NL>          [ <NL>              dp [ i ] [ j ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( word1 ) ) <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( word1 ) , <SPC> len ( s ) ) <NL>              if <SPC> s [ i ] <SPC> == <SPC> s [ j ] <NL>          ] <NL>          or <SPC> [ 0 ] <NL> <TAB> ) <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largestSumAfterKNegations ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> def <SPC> kthElement ( nums , <SPC> k , <SPC> compare ) : <NL>          def <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare ) : <NL>              new_pivot_idx <SPC> = <SPC> left <NL>              nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>                  if <SPC> compare ( nums [ i ] , <SPC> nums [ right ] ) : <NL>                      nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                      new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>              nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>              return <SPC> new_pivot_idx <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> PartitionAroundPivot ( <NL>                  left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare <NL>              ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> k : <NL>                  return <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> k : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> kthElement ( A , <SPC> K , <SPC> lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) <NL> <TAB> remain <SPC> = <SPC> K <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( K ) : <NL>          if <SPC> A [ i ] <SPC> < <SPC> 0 : <NL>              A [ i ] <SPC> = <SPC> - A [ i ] <NL>              remain <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> sum ( A ) <SPC> - <SPC> ( ( remain ) <SPC> % <SPC> 2 ) <SPC> * <SPC> min ( A ) <SPC> * <SPC> 2 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> largestSumAfterKNegations ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> A . sort ( ) <NL> <TAB> remain <SPC> = <SPC> K <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( K ) : <NL>          if <SPC> A [ i ] <SPC> >= <SPC> 0 : <NL>              break <NL>          A [ i ] <SPC> = <SPC> - A [ i ] <NL>          remain <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> sum ( A ) <SPC> - <SPC> ( remain <SPC> % <SPC> 2 ) <SPC> * <SPC> min ( A ) <SPC> * <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumBeauty ( self , <SPC> flowers ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <NL> <TAB> result <SPC> = <SPC> float ( "-inf" ) <NL> <TAB> for <SPC> i , <SPC> f <SPC> in <SPC> enumerate ( flowers ) : <NL>          prefix . append ( prefix [ - 1 ] <SPC> + <SPC> f <SPC> if <SPC> f <SPC> > <SPC> 0 <SPC> else <SPC> prefix [ - 1 ] ) <NL>          if <SPC> not <SPC> f <SPC> in <SPC> lookup : <NL>              lookup [ f ] <SPC> = <SPC> i <NL>              continue <NL>          result <SPC> = <SPC> max ( <NL>              result , <NL>              2 <SPC> * <SPC> f <SPC> + <SPC> prefix [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ lookup [ f ] ] <NL>              if <SPC> f <SPC> < <SPC> 0 <NL>              else <SPC> prefix [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ lookup [ f ] ] , <NL>          ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximum69Number ( self , <SPC> num ) : <NL> <NL> <TAB> curr , <SPC> base , <SPC> change <SPC> = <SPC> num , <SPC> 3 , <SPC> 0 <NL> <TAB> while <SPC> curr : <NL>          if <SPC> curr <SPC> % <SPC> 10 <SPC> == <SPC> 6 : <NL>              change <SPC> = <SPC> base <NL>          base <SPC> *= <SPC> 10 <NL>          curr <SPC> //= <SPC> 10 <NL> <TAB> return <SPC> num <SPC> + <SPC> change <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maximum69Number ( self , <SPC> num ) : <NL> <NL> <TAB> return <SPC> int ( str ( num ) . replace ( "6" , <SPC> "9" , <SPC> 1 ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxAbsoluteSum ( self , <SPC> nums ) : <NL> <NL> <TAB> curr <SPC> = <SPC> mx <SPC> = <SPC> mn <SPC> = <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          curr <SPC> += <SPC> num <NL>          mx <SPC> = <SPC> max ( mx , <SPC> curr ) <NL>          mn <SPC> = <SPC> min ( mn , <SPC> curr ) <NL> <TAB> return <SPC> mx <SPC> - <SPC> mn <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxArea ( self , <SPC> h , <SPC> w , <SPC> horizontalCuts , <SPC> verticalCuts ) : <NL> <NL> <TAB> def <SPC> max_len ( l , <SPC> cuts ) : <NL>          cuts . sort ( ) <NL>          l <SPC> = <SPC> max ( cuts [ 0 ] <SPC> - <SPC> 0 , <SPC> l <SPC> - <SPC> cuts [ - 1 ] ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( cuts ) ) : <NL>              l <SPC> = <SPC> max ( l , <SPC> cuts [ i ] <SPC> - <SPC> cuts [ i <SPC> - <SPC> 1 ] ) <NL>          return <SPC> l <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> return <SPC> max_len ( h , <SPC> horizontalCuts ) <SPC> * <SPC> max_len ( w , <SPC> verticalCuts ) <SPC> % <SPC> MOD <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxAverageRatio ( self , <SPC> classes , <SPC> extraStudents ) : <NL> <NL> <TAB> def <SPC> profit ( a , <SPC> b ) : <NL>          return <SPC> float ( a <SPC> + <SPC> 1 ) <SPC> / <SPC> ( b <SPC> + <SPC> 1 ) <SPC> - <SPC> float ( a ) <SPC> / <SPC> b <NL> <NL> <TAB> max_heap <SPC> = <SPC> [ ( - profit ( a , <SPC> b ) , <SPC> a , <SPC> b ) <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> classes ] <NL> <TAB> heapq . heapify ( max_heap ) <NL> <TAB> while <SPC> extraStudents : <NL>          v , <SPC> a , <SPC> b <SPC> = <SPC> heapq . heappop ( max_heap ) <NL>          a , <SPC> b <SPC> = <SPC> a <SPC> + <SPC> 1 , <SPC> b <SPC> + <SPC> 1 <NL>          heapq . heappush ( max_heap , <SPC> ( - profit ( a , <SPC> b ) , <SPC> a , <SPC> b ) ) <NL>          extraStudents <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> sum ( float ( a ) <SPC> / <SPC> b <SPC> for <SPC> v , <SPC> a , <SPC> b <SPC> in <SPC> max_heap ) <SPC> / <SPC> len ( classes ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMaxAverage ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> total <SPC> = <SPC> sum ( nums [ : k ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k , <SPC> len ( nums ) ) : <NL>          total <SPC> += <SPC> nums [ i ] <SPC> - <SPC> nums [ i <SPC> - <SPC> k ] <NL>          result <SPC> = <SPC> max ( result , <SPC> total ) <NL> <TAB> return <SPC> float ( result ) <SPC> / <SPC> k <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMaxAverage ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> getDelta ( avg , <SPC> nums , <SPC> k ) : <NL>          accu <SPC> = <SPC> [ 0.0 ] <SPC> * <SPC> ( len ( nums ) <SPC> + <SPC> 1 ) <NL>          minval_pos <SPC> = <SPC> None <NL>          delta <SPC> = <SPC> 0.0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>              accu [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> nums [ i ] <SPC> + <SPC> accu [ i ] <SPC> - <SPC> avg <NL>              if <SPC> i <SPC> >= <SPC> ( k <SPC> - <SPC> 1 ) : <NL>                  if <SPC> minval_pos <SPC> == <SPC> None <SPC> or <SPC> accu [ i <SPC> - <SPC> k <SPC> + <SPC> 1 ] <SPC> < <SPC> accu [ minval_pos ] : <NL>                      minval_pos <SPC> = <SPC> i <SPC> - <SPC> k <SPC> + <SPC> 1 <NL>                  if <SPC> accu [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> accu [ minval_pos ] <SPC> >= <SPC> 0 : <NL>                      delta <SPC> = <SPC> max ( <NL>                          delta , <NL>                          ( accu [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> accu [ minval_pos ] ) <SPC> / <NL>                          ( i <SPC> + <SPC> 1 <SPC> - <SPC> minval_pos ) , <NL>                      ) <NL>          return <SPC> delta <NL> <NL> <TAB> left , <SPC> delta <SPC> = <SPC> min ( nums ) , <SPC> float ( "inf" ) <NL> <TAB> while <SPC> delta <SPC> > <SPC> 1e-5 : <NL>          delta <SPC> = <SPC> getDelta ( left , <SPC> nums , <SPC> k ) <NL>          left <SPC> += <SPC> delta <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumAverageSubtree ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> maximumAverageSubtreeHelper ( root , <SPC> result ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> [ 0.0 , <SPC> 0 ] <NL>          s1 , <SPC> n1 <SPC> = <SPC> maximumAverageSubtreeHelper ( root . left , <SPC> result ) <NL>          s2 , <SPC> n2 <SPC> = <SPC> maximumAverageSubtreeHelper ( root . right , <SPC> result ) <NL>          s <SPC> = <SPC> s1 <SPC> + <SPC> s2 <SPC> + <SPC> root . val <NL>          n <SPC> = <SPC> n1 <SPC> + <SPC> n2 <SPC> + <SPC> 1 <NL>          result [ 0 ] <SPC> = <SPC> max ( result [ 0 ] , <SPC> s <SPC> / <SPC> n ) <NL>          return <SPC> [ s , <SPC> n ] <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> maximumAverageSubtreeHelper ( root , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumBinaryString ( self , <SPC> binary ) : <NL> <NL> <TAB> result <SPC> = <SPC> list ( binary ) <NL> <TAB> zeros <SPC> = <SPC> ones <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( result ) : <NL>          if <SPC> c <SPC> == <SPC> "0" : <NL>              zeros <SPC> += <SPC> 1 <NL>          elif <SPC> zeros <SPC> == <SPC> 0 : <NL>              ones <SPC> += <SPC> 1 <NL>          result [ i ] <SPC> = <SPC> "1" <NL> <TAB> if <SPC> ones <SPC> != <SPC> len ( result ) : <NL>          result [ zeros <SPC> + <SPC> ones <SPC> - <SPC> 1 ] <SPC> = <SPC> "0" <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> insertIntoMaxTree ( self , <SPC> root , <SPC> val ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> TreeNode ( val ) <NL> <NL> <TAB> if <SPC> val <SPC> > <SPC> root . val : <NL>          node <SPC> = <SPC> TreeNode ( val ) <NL>          node . left <SPC> = <SPC> root <NL>          return <SPC> node <NL> <NL> <TAB> curr <SPC> = <SPC> root <NL> <TAB> while <SPC> curr . right <SPC> and <SPC> curr . right . val <SPC> > <SPC> val : <NL>          curr <SPC> = <SPC> curr . right <NL> <TAB> node <SPC> = <SPC> TreeNode ( val ) <NL> <TAB> curr . right , <SPC> node . left <SPC> = <SPC> node , <SPC> curr . right <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> constructMaximumBinaryTree ( self , <SPC> nums ) : <NL> <NL> <TAB> nodeStack <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          node <SPC> = <SPC> TreeNode ( num ) <NL>          while <SPC> nodeStack <SPC> and <SPC> num <SPC> > <SPC> nodeStack [ - 1 ] . val : <NL>              node . left <SPC> = <SPC> nodeStack . pop ( ) <NL>          if <SPC> nodeStack : <NL>              nodeStack [ - 1 ] . right <SPC> = <SPC> node <NL>          nodeStack . append ( node ) <NL> <TAB> return <SPC> nodeStack [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxCandies ( self , <SPC> status , <SPC> candies , <SPC> keys , <SPC> containedBoxes , <SPC> initialBoxes ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> q <SPC> = <SPC> collections . deque ( initialBoxes ) <NL> <TAB> while <SPC> q : <NL>          changed <SPC> = <SPC> False <NL>          for <SPC> _ <SPC> in <SPC> xrange ( len ( q ) ) : <NL>              box <SPC> = <SPC> q . popleft ( ) <NL>              if <SPC> not <SPC> status [ box ] : <NL>                  q . append ( box ) <NL>                  continue <NL>              changed <SPC> = <SPC> True <NL>              result <SPC> += <SPC> candies [ box ] <NL>              for <SPC> contained_key <SPC> in <SPC> keys [ box ] : <NL>                  status [ contained_key ] <SPC> = <SPC> 1 <NL>              for <SPC> contained_box <SPC> in <SPC> containedBoxes [ box ] : <NL>                  q . append ( contained_box ) <NL>          if <SPC> not <SPC> changed : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maxDepth ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <TAB> else : <NL>          return <SPC> max ( self . maxDepth ( root . left ) , <SPC> self . maxDepth ( root . right ) ) <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> children ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . children <SPC> = <SPC> children <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxDepth ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> 0 <NL> <TAB> depth <SPC> = <SPC> 0 <NL> <TAB> for <SPC> child <SPC> in <SPC> root . children : <NL>          depth <SPC> = <SPC> max ( depth , <SPC> self . maxDepth ( child ) ) <NL> <TAB> return <SPC> 1 <SPC> + <SPC> depth <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxAncestorDiff ( self , <SPC> root ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> stack <SPC> = <SPC> [ ( root , <SPC> 0 , <SPC> float ( "inf" ) ) ] <NL> <TAB> while <SPC> stack : <NL>          node , <SPC> mx , <SPC> mn <SPC> = <SPC> stack . pop ( ) <NL>          if <SPC> not <SPC> node : <NL>              continue <NL>          result <SPC> = <SPC> max ( result , <SPC> mx <SPC> - <SPC> node . val , <SPC> node . val <SPC> - <SPC> mn ) <NL>          mx <SPC> = <SPC> max ( mx , <SPC> node . val ) <NL>          mn <SPC> = <SPC> min ( mn , <SPC> node . val ) <NL>          stack . append ( ( node . left , <SPC> mx , <SPC> mn ) ) <NL>          stack . append ( ( node . right , <SPC> mx , <SPC> mn ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxAncestorDiff ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> maxAncestorDiffHelper ( node , <SPC> mx , <SPC> mn ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> 0 <NL>          result <SPC> = <SPC> max ( mx <SPC> - <SPC> node . val , <SPC> node . val <SPC> - <SPC> mn ) <NL>          mx <SPC> = <SPC> max ( mx , <SPC> node . val ) <NL>          mn <SPC> = <SPC> min ( mn , <SPC> node . val ) <NL>          result <SPC> = <SPC> max ( result , <SPC> maxAncestorDiffHelper ( node . left , <SPC> mx , <SPC> mn ) ) <NL>          result <SPC> = <SPC> max ( result , <SPC> maxAncestorDiffHelper ( node . right , <SPC> mx , <SPC> mn ) ) <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> maxAncestorDiffHelper ( root , <SPC> 0 , <SPC> float ( "inf" ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxDistance ( self , <SPC> arrays ) : <NL> <NL> <TAB> result , <SPC> min_val , <SPC> max_val <SPC> = <SPC> 0 , <SPC> arrays [ 0 ] [ 0 ] , <SPC> arrays [ 0 ] [ - 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( arrays ) ) : <NL>          result <SPC> = <SPC> max ( result , <SPC> max ( <NL>              max_val <SPC> - <SPC> arrays [ i ] [ 0 ] , <SPC> arrays [ i ] [ - 1 ] <SPC> - <SPC> min_val ) ) <NL>          min_val <SPC> = <SPC> min ( min_val , <SPC> arrays [ i ] [ 0 ] ) <NL>          max_val <SPC> = <SPC> max ( max_val , <SPC> arrays [ i ] [ - 1 ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxEqualFreq ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> count <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> freq <SPC> = <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( nums ) <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i , <SPC> n <SPC> in <SPC> enumerate ( nums , <SPC> 1 ) : <NL>          freq [ count [ n ] ] <SPC> -= <SPC> 1 <NL>          freq [ count [ n ] <SPC> + <SPC> 1 ] <SPC> += <SPC> 1 <NL>          count [ n ] <SPC> += <SPC> 1 <NL>          c <SPC> = <SPC> count [ n ] <NL>          if <SPC> freq [ c ] <SPC> * <SPC> c <SPC> == <SPC> i <SPC> and <SPC> i <SPC> < <SPC> len ( nums ) : <NL>              result <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>          remain <SPC> = <SPC> i <SPC> - <SPC> freq [ c ] <SPC> * <SPC> c <NL>          if <SPC> freq [ remain ] <SPC> == <SPC> 1 <SPC> and <SPC> remain <SPC> in <SPC> [ 1 , <SPC> c <SPC> + <SPC> 1 ] : <NL>              result <SPC> = <SPC> i <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumUniqueSubarray ( self , <SPC> nums ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( nums ) <SPC> + <SPC> 1 ) <NL> <TAB> result , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> right , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          prefix [ right <SPC> + <SPC> 1 ] <SPC> = <SPC> prefix [ right ] <SPC> + <SPC> num <NL>          if <SPC> num <SPC> in <SPC> lookup : <NL>              left <SPC> = <SPC> max ( left , <SPC> lookup [ num ] <SPC> + <SPC> 1 ) <NL>          lookup [ num ] <SPC> = <SPC> right <NL>          result <SPC> = <SPC> max ( result , <SPC> prefix [ right <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ left ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> FontInfo ( object ) : <NL> <TAB> def <SPC> getWidth ( self , <SPC> fontSize , <SPC> ch ) : <NL> <NL> <TAB> pass <NL> <NL> <TAB> def <SPC> getHeight ( self , <SPC> fontSize ) : <NL> <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxFont ( self , <SPC> text , <SPC> w , <SPC> h , <SPC> fonts , <SPC> fontInfo ) : <NL> <NL> <TAB> def <SPC> check ( count , <SPC> w , <SPC> h , <SPC> fonts , <SPC> fontInfo , <SPC> x ) : <NL>          return <SPC> ( <NL>              fontInfo . getHeight ( fonts [ x ] ) <SPC> <= <SPC> h <NL>              and <SPC> sum ( <NL>                  cnt <SPC> * <SPC> fontInfo . getWidth ( fonts [ x ] , <SPC> c ) <SPC> for <SPC> c , <SPC> cnt <SPC> in <SPC> count . iteritems ( ) <NL>              ) <NL>              <= <SPC> w <NL>          ) <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( text ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( fonts ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( count , <SPC> w , <SPC> h , <SPC> fonts , <SPC> fontInfo , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> fonts [ right ] <SPC> if <SPC> right <SPC> >= <SPC> 0 <SPC> else <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> FreqStack ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __freq <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> self . __group <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> self . __maxfreq <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <NL> <TAB> self . __freq [ x ] <SPC> += <SPC> 1 <NL> <TAB> if <SPC> self . __freq [ x ] <SPC> > <SPC> self . __maxfreq : <NL>          self . __maxfreq <SPC> = <SPC> self . __freq [ x ] <NL> <TAB> self . __group [ self . __freq [ x ] ] . append ( x ) <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <NL> <TAB> x <SPC> = <SPC> self . __group [ self . __maxfreq ] . pop ( ) <NL> <TAB> if <SPC> not <SPC> self . __group [ self . __maxfreq ] : <NL>          self . __group . pop ( self . __maxfreq ) <NL>          self . __maxfreq <SPC> -= <SPC> 1 <NL> <TAB> self . __freq [ x ] <SPC> -= <SPC> 1 <NL> <TAB> if <SPC> not <SPC> self . __freq [ x ] : <NL>          self . __freq . pop ( x ) <NL> <TAB> return <SPC> x <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumGap ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> len ( nums ) <SPC> < <SPC> 2 : <NL>          return <SPC> 0 <NL> <NL> <TAB> max_val , <SPC> min_val <SPC> = <SPC> max ( nums ) , <SPC> min ( nums ) <NL> <TAB> gap <SPC> = <SPC> max ( 1 , <SPC> ( max_val <SPC> - <SPC> min_val ) <SPC> / <SPC> ( len ( nums ) <SPC> - <SPC> 1 ) ) <NL> <TAB> bucket_size <SPC> = <SPC> ( max_val <SPC> - <SPC> min_val ) <SPC> / <SPC> gap <SPC> + <SPC> 1 <NL> <TAB> bucket <SPC> = <SPC> [ <NL>          { "min" : <SPC> float ( "inf" ) , <SPC> "max" : <SPC> float ( "-inf" ) } <SPC> for <SPC> _ <SPC> in <SPC> xrange ( bucket_size ) <NL> <TAB> ] <NL> <NL> <TAB> for <SPC> n <SPC> in <SPC> nums : <NL> <NL>          if <SPC> n <SPC> in <SPC> ( max_val , <SPC> min_val ) : <NL>              continue <NL>          i <SPC> = <SPC> ( n <SPC> - <SPC> min_val ) <SPC> / <SPC> gap <NL>          bucket [ i ] [ "min" ] <SPC> = <SPC> min ( bucket [ i ] [ "min" ] , <SPC> n ) <NL>          bucket [ i ] [ "max" ] <SPC> = <SPC> max ( bucket [ i ] [ "max" ] , <SPC> n ) <NL> <NL> <TAB> max_gap , <SPC> pre_bucket_max <SPC> = <SPC> 0 , <SPC> min_val <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( bucket_size ) : <NL> <NL>          if <SPC> bucket [ i ] [ "min" ] <SPC> == <SPC> float ( "inf" ) <SPC> and <SPC> bucket [ i ] [ "max" ] <SPC> == <SPC> float ( "-inf" ) : <NL>              continue <NL>          max_gap <SPC> = <SPC> max ( max_gap , <SPC> bucket [ i ] [ "min" ] <SPC> - <SPC> pre_bucket_max ) <NL>          pre_bucket_max <SPC> = <SPC> bucket [ i ] [ "max" ] <NL> <NL> <TAB> max_gap <SPC> = <SPC> max ( max_gap , <SPC> max_val <SPC> - <SPC> pre_bucket_max ) <NL> <NL> <TAB> return <SPC> max_gap <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maximumGap ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> len ( nums ) <SPC> < <SPC> 2 : <NL>          return <SPC> 0 <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> pre <SPC> = <SPC> nums [ 0 ] <NL> <TAB> max_gap <SPC> = <SPC> float ( "-inf" ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> nums : <NL>          max_gap <SPC> = <SPC> max ( max_gap , <SPC> i <SPC> - <SPC> pre ) <NL>          pre <SPC> = <SPC> i <NL> <TAB> return <SPC> max_gap <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxHeight ( self , <SPC> cuboids ) : <NL> <NL> <TAB> for <SPC> cuboid <SPC> in <SPC> cuboids : <NL>          cuboid . sort ( ) <NL> <TAB> cuboids . append ( [ 0 , <SPC> 0 , <SPC> 0 ] ) <NL> <TAB> cuboids . sort ( ) <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( cuboids ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( cuboids ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i ) : <NL>              if <SPC> all ( cuboids [ j ] [ k ] <SPC> <= <SPC> cuboids [ i ] [ k ] <SPC> for <SPC> k <SPC> in <SPC> xrange ( 3 ) ) : <NL>                  dp [ i ] <SPC> = <SPC> max ( dp [ i ] , <SPC> dp [ j ] <SPC> + <SPC> cuboids [ i ] [ 2 ] ) <NL> <TAB> return <SPC> max ( dp ) <NL> <NL> <NL> power <SPC> = <SPC> [ 1 ] <NL> log2 <SPC> = <SPC> { 1 : <SPC> 0 } <NL> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> 26 ) : <NL> <TAB> power . append ( power [ - 1 ] <SPC> << <SPC> 1 ) <NL> <TAB> log2 [ power [ i ] ] <SPC> = <SPC> i <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxLength ( self , <SPC> arr ) : <NL> <NL> <TAB> def <SPC> bitset ( s ) : <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> s : <NL>              if <SPC> result <SPC> & <SPC> power [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] : <NL>                  return <SPC> 0 <NL>              result <SPC> |= <SPC> power [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> number_of_one ( n ) : <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> n : <NL>              n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL>              result <SPC> += <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> x <SPC> in <SPC> arr : <NL>          x_set <SPC> = <SPC> bitset ( x ) <NL>          if <SPC> not <SPC> x_set : <NL>              continue <NL>          curr_len <SPC> = <SPC> len ( dp ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( curr_len ) : <NL>              if <SPC> dp [ i ] <SPC> & <SPC> x_set : <NL>                  continue <NL>              dp . append ( dp [ i ] <SPC> | <SPC> x_set ) <NL> <TAB> return <SPC> max ( number_of_one ( s_set ) <SPC> for <SPC> s_set <SPC> in <SPC> dp ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxLength ( self , <SPC> arr ) : <NL> <NL> <TAB> def <SPC> bitset ( s ) : <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> s : <NL>              if <SPC> result <SPC> & <SPC> power [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] : <NL>                  return <SPC> 0 <NL>              result <SPC> |= <SPC> power [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <NL>          return <SPC> result <NL> <NL> <TAB> bitsets <SPC> = <SPC> [ bitset ( x ) <SPC> for <SPC> x <SPC> in <SPC> arr ] <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( power [ len ( arr ) ] ) : <NL>          curr_bitset , <SPC> curr_len <SPC> = <SPC> 0 , <SPC> 0 <NL>          while <SPC> i : <NL>              j <SPC> = <SPC> i <SPC> & <SPC> - i <NL>              i <SPC> ^= <SPC> j <NL>              j <SPC> = <SPC> log2 [ j ] <NL>              if <SPC> not <SPC> bitsets [ j ] <SPC> or <SPC> ( curr_bitset <SPC> & <SPC> bitsets [ j ] ) : <NL>                  break <NL>              curr_bitset <SPC> |= <SPC> bitsets [ j ] <NL>              curr_len <SPC> += <SPC> len ( arr [ j ] ) <NL>          else : <NL>              result <SPC> = <SPC> max ( result , <SPC> curr_len ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLongestChain ( self , <SPC> pairs ) : <NL> <NL> <TAB> pairs . sort ( key = lambda <SPC> x : <SPC> x [ 1 ] ) <NL> <TAB> cnt , <SPC> i <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( pairs ) ) : <NL>          if <SPC> j <SPC> == <SPC> 0 <SPC> or <SPC> pairs [ i ] [ 1 ] <SPC> < <SPC> pairs [ j ] [ 0 ] : <NL>              cnt <SPC> += <SPC> 1 <NL>              i <SPC> = <SPC> j <NL> <TAB> return <SPC> cnt <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLength ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> if <SPC> len ( A ) <SPC> < <SPC> len ( B ) : <NL>          return <SPC> self . findLength ( B , <SPC> A ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( len ( B ) <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( B ) ) : <NL>              if <SPC> A [ i ] <SPC> == <SPC> B [ j ] : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> + <SPC> 1 <NL>              else : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> 0 <NL>          result <SPC> = <SPC> max ( result , <SPC> max ( dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findLength ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> if <SPC> len ( A ) <SPC> > <SPC> len ( B ) : <NL>          return <SPC> self . findLength ( B , <SPC> A ) <NL> <TAB> M , <SPC> p <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 , <SPC> 113 <NL> <TAB> p_inv <SPC> = <SPC> pow ( p , <SPC> M <SPC> - <SPC> 2 , <SPC> M ) <NL> <NL> <TAB> def <SPC> check ( guess ) : <NL>          def <SPC> rolling_hashes ( source , <SPC> length ) : <NL>              if <SPC> length <SPC> == <SPC> 0 : <NL>                  yield <SPC> 0 , <SPC> 0 <NL>                  return <NL> <NL>              val , <SPC> power <SPC> = <SPC> 0 , <SPC> 1 <NL>              for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( source ) : <NL>                  val <SPC> = <SPC> ( val <SPC> + <SPC> x <SPC> * <SPC> power ) <SPC> % <SPC> M <NL>                  if <SPC> i <SPC> < <SPC> length <SPC> - <SPC> 1 : <NL>                      power <SPC> = <SPC> ( power <SPC> * <SPC> p ) <SPC> % <SPC> M <NL>                  else : <NL>                      yield <SPC> val , <SPC> i <SPC> - <SPC> ( length <SPC> - <SPC> 1 ) <NL>                      val <SPC> = <SPC> ( val <SPC> - <SPC> source [ i <SPC> - <SPC> ( length <SPC> - <SPC> 1 ) ] ) <SPC> * <SPC> p_inv <SPC> % <SPC> M <NL> <NL>          hashes <SPC> = <SPC> collections . defaultdict ( list ) <NL>          for <SPC> hash_val , <SPC> i <SPC> in <SPC> rolling_hashes ( A , <SPC> guess ) : <NL>              hashes [ hash_val ] . append ( i ) <NL>          for <SPC> hash_val , <SPC> j <SPC> in <SPC> rolling_hashes ( B , <SPC> guess ) : <NL>              if <SPC> any ( A [ i : <SPC> i <SPC> + <SPC> guess ] <SPC> == <SPC> B [ j : <SPC> j <SPC> + <SPC> guess ] <SPC> for <SPC> i <SPC> in <SPC> hashes [ hash_val ] ) : <NL>                  return <SPC> True <NL>          return <SPC> False <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> min ( len ( A ) , <SPC> len ( B ) ) <SPC> + <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> not <SPC> check ( mid ) : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> findLength ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> if <SPC> len ( A ) <SPC> > <SPC> len ( B ) : <NL>          return <SPC> self . findLength ( B , <SPC> A ) <NL> <NL> <TAB> def <SPC> check ( length ) : <NL>          lookup <SPC> = <SPC> set ( A [ i : <SPC> i <SPC> + <SPC> length ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) <SPC> - <SPC> length <SPC> + <SPC> 1 ) ) <NL>          return <SPC> any ( B [ j : <SPC> j <SPC> + <SPC> length ] <SPC> in <SPC> lookup <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( B ) <SPC> - <SPC> length <SPC> + <SPC> 1 ) ) <NL> <NL> <TAB> A <SPC> = <SPC> "" . join ( map ( chr , <SPC> A ) ) <NL> <TAB> B <SPC> = <SPC> "" . join ( map ( chr , <SPC> B ) ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> min ( len ( A ) , <SPC> len ( B ) ) <SPC> + <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> not <SPC> check ( mid ) : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getMaxLen ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> neg_cnt , <SPC> last_zero_pos , <SPC> first_valid_neg_pos <SPC> = <SPC> 0 , <SPC> 0 , <SPC> - 1 , <SPC> - 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> nums [ i ] <SPC> == <SPC> 0 : <NL>              neg_cnt <SPC> = <SPC> 0 <NL>              last_zero_pos <SPC> = <SPC> i <NL>              first_valid_neg_pos <SPC> = <SPC> - 1 <NL>              continue <NL>          if <SPC> nums [ i ] <SPC> < <SPC> 0 : <NL>              if <SPC> first_valid_neg_pos <SPC> == <SPC> - 1 : <NL>                  first_valid_neg_pos <SPC> = <SPC> i <NL>              neg_cnt <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> max ( <NL>              result , <SPC> i <SPC> - <SPC> ( last_zero_pos <SPC> if <SPC> neg_cnt <SPC> % <NL>                           2 <SPC> == <SPC> 0 <SPC> else <SPC> first_valid_neg_pos ) <NL>          ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxLevelSum ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> i , <SPC> level_sums ) : <NL>          if <SPC> not <SPC> node : <NL>              return <NL>          if <SPC> i <SPC> == <SPC> len ( level_sums ) : <NL>              level_sums . append ( 0 ) <NL>          level_sums [ i ] <SPC> += <SPC> node . val <NL>          dfs ( node . left , <SPC> i <SPC> + <SPC> 1 , <SPC> level_sums ) <NL>          dfs ( node . right , <SPC> i <SPC> + <SPC> 1 , <SPC> level_sums ) <NL> <NL> <TAB> level_sums <SPC> = <SPC> [ ] <NL> <TAB> dfs ( root , <SPC> 0 , <SPC> level_sums ) <NL> <TAB> return <SPC> level_sums . index ( max ( level_sums ) ) <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxLevelSum ( self , <SPC> root ) : <NL> <NL> <TAB> result , <SPC> level , <SPC> max_total <SPC> = <SPC> 0 , <SPC> 1 , <SPC> float ( "-inf" ) <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ root ] ) <NL> <TAB> while <SPC> q : <NL>          total <SPC> = <SPC> 0 <NL>          for <SPC> _ <SPC> in <SPC> xrange ( len ( q ) ) : <NL>              node <SPC> = <SPC> q . popleft ( ) <NL>              total <SPC> += <SPC> node . val <NL>              if <SPC> node . left : <NL>                  q . append ( node . left ) <NL>              if <SPC> node . right : <NL>                  q . append ( node . right ) <NL>          if <SPC> total <SPC> > <SPC> max_total : <NL>              result , <SPC> max_total <SPC> = <SPC> level , <SPC> total <NL>          level <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxDepth ( self , <SPC> s ) : <NL> <NL> <TAB> result <SPC> = <SPC> curr <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          if <SPC> c <SPC> == <SPC> "(" : <NL>              curr <SPC> += <SPC> 1 <NL>              result <SPC> = <SPC> max ( result , <SPC> curr ) <NL>          elif <SPC> c <SPC> == <SPC> ")" : <NL>              curr <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxDepthAfterSplit ( self , <SPC> seq ) : <NL> <NL> <TAB> return <SPC> [ ( i <SPC> & <SPC> 1 ) <SPC> ^ <SPC> ( seq [ i ] <SPC> == <SPC> "(" ) <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( seq ) ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxDepthAfterSplit ( self , <SPC> seq ) : <NL> <NL> <TAB> A , <SPC> B <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( seq ) <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( seq ) : <NL>          point <SPC> = <SPC> 1 <SPC> if <SPC> c <SPC> == <SPC> "(" <SPC> else <SPC> - 1 <NL>          if <SPC> ( point <SPC> == <SPC> 1 <SPC> and <SPC> A <SPC> <= <SPC> B ) <SPC> or <SPC> ( point <SPC> == <SPC> - 1 <SPC> and <SPC> A <SPC> >= <SPC> B ) : <NL>              A <SPC> += <SPC> point <NL>          else : <NL>              B <SPC> += <SPC> point <NL>              result [ i ] <SPC> = <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProductPath ( self , <SPC> grid ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> max_dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( grid [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> min_dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( grid [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ i ] ) ) : <NL>              if <SPC> i <SPC> == <SPC> 0 <SPC> and <SPC> j <SPC> == <SPC> 0 : <NL>                  max_dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> min_dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> grid [ i ] [ j ] <NL>                  continue <NL>              curr_max <SPC> = <SPC> max ( <NL>                  max_dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <SPC> if <SPC> i <SPC> > <SPC> 0 <SPC> else <SPC> max_dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] , <NL>                  max_dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] <SPC> if <SPC> j <SPC> > <SPC> 0 <SPC> else <SPC> max_dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <NL>              ) <NL>              curr_min <SPC> = <SPC> min ( <NL>                  min_dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <SPC> if <SPC> i <SPC> > <SPC> 0 <SPC> else <SPC> min_dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] , <NL>                  min_dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] <SPC> if <SPC> j <SPC> > <SPC> 0 <SPC> else <SPC> min_dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <NL>              ) <NL>              if <SPC> grid [ i ] [ j ] <SPC> < <SPC> 0 : <NL>                  curr_max , <SPC> curr_min <SPC> = <SPC> curr_min , <SPC> curr_max <NL>              max_dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> curr_max <SPC> * <SPC> grid [ i ] [ j ] <NL>              min_dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> curr_min <SPC> * <SPC> grid [ i ] [ j ] <NL> <TAB> return <SPC> ( <NL>          max_dp [ ( len ( grid ) <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ - 1 ] <SPC> % <SPC> MOD <NL>          if <SPC> max_dp [ ( len ( grid ) <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ - 1 ] <SPC> >= <SPC> 0 <NL>          else <SPC> - 1 <NL> <TAB> ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumRequests ( self , <SPC> n , <SPC> requests ) : <NL> <NL> <TAB> for <SPC> k <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( requests ) <SPC> + <SPC> 1 ) ) : <NL>          for <SPC> c <SPC> in <SPC> itertools . combinations ( xrange ( len ( requests ) ) , <SPC> k ) : <NL>              change <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL>              for <SPC> i <SPC> in <SPC> c : <NL>                  change [ requests [ i ] [ 0 ] ] <SPC> -= <SPC> 1 <NL>                  change [ requests [ i ] [ 1 ] ] <SPC> += <SPC> 1 <NL>              if <SPC> all ( c <SPC> == <SPC> 0 <SPC> for <SPC> c <SPC> in <SPC> change ) : <NL>                  return <SPC> k <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maximumRequests ( self , <SPC> n , <SPC> requests ) : <NL> <NL> <TAB> def <SPC> evaluate ( n , <SPC> requests , <SPC> mask ) : <NL>          change <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL>          base , <SPC> count <SPC> = <SPC> 1 , <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( requests ) ) : <NL>              if <SPC> base <SPC> & <SPC> mask : <NL>                  change [ requests [ i ] [ 0 ] ] <SPC> -= <SPC> 1 <NL>                  change [ requests [ i ] [ 1 ] ] <SPC> += <SPC> 1 <NL>                  count <SPC> += <SPC> 1 <NL>              base <SPC> <<= <SPC> 1 <NL>          return <SPC> count <SPC> if <SPC> all ( c <SPC> == <SPC> 0 <SPC> for <SPC> c <SPC> in <SPC> change ) <SPC> else <SPC> 0 <NL> <NL> <TAB> return <SPC> max ( evaluate ( n , <SPC> requests , <SPC> i ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 <SPC> << <SPC> len ( requests ) ) ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxNumberOfBalloons ( self , <SPC> text ) : <NL> <NL> <TAB> TARGET <SPC> = <SPC> "balloon" <NL> <TAB> source_count <SPC> = <SPC> collections . Counter ( text ) <NL> <TAB> target_count <SPC> = <SPC> collections . Counter ( TARGET ) <NL> <TAB> return <SPC> min ( source_count [ c ] <SPC> // <SPC> target_count [ c ] <SPC> for <SPC> c <SPC> in <SPC> target_count . iterkeys ( ) ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countBalls ( self , <SPC> lowLimit , <SPC> highLimit ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( lowLimit , <SPC> highLimit <SPC> + <SPC> 1 ) : <NL>          count [ sum ( itertools . imap ( int , <SPC> str ( i ) ) ) ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> max ( count . itervalues ( ) ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxCoins ( self , <SPC> piles ) : <NL> <NL> <TAB> piles . sort ( ) <NL> <TAB> return <SPC> sum ( itertools . islice ( piles , <SPC> len ( piles ) <SPC> // <SPC> 3 , <SPC> len ( piles ) , <SPC> 2 ) ) <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numPoints ( self , <SPC> points , <SPC> r ) : <NL> <NL> <TAB> def <SPC> count_points ( points , <SPC> r , <SPC> i ) : <NL>          angles <SPC> = <SPC> [ ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( points ) ) : <NL>              if <SPC> i <SPC> == <SPC> j : <NL>                  continue <NL>              dx , <SPC> dy <SPC> = <SPC> points [ i ] [ 0 ] <SPC> - <SPC> points [ j ] [ 0 ] , <SPC> points [ i ] [ 1 ] <SPC> - <SPC> points [ j ] [ 1 ] <NL>              d <SPC> = <SPC> math . sqrt ( dx <SPC> ** <SPC> 2 <SPC> + <SPC> dy <SPC> ** <SPC> 2 ) <NL>              if <SPC> d <SPC> > <SPC> 2 <SPC> * <SPC> r : <NL>                  continue <NL>              delta , <SPC> angle <SPC> = <SPC> math . acos ( d <SPC> / <SPC> ( 2 <SPC> * <SPC> r ) ) , <SPC> math . atan2 ( dy , <SPC> dx ) <NL>              angles . append ( ( angle <SPC> - <SPC> delta , <SPC> 0 ) <NL>                            ) , <SPC> angles . append ( ( angle <SPC> + <SPC> delta , <SPC> 1 ) ) <NL>          angles . sort ( ) <NL>          result , <SPC> count <SPC> = <SPC> 1 , <SPC> 1 <NL>          for <SPC> _ , <SPC> is_closed <SPC> in <SPC> angles : <NL>              if <SPC> not <SPC> is_closed : <NL>                  count <SPC> += <SPC> 1 <NL>              else : <NL>                  count <SPC> -= <SPC> 1 <NL>              result <SPC> = <SPC> max ( result , <SPC> count ) <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> max ( count_points ( points , <SPC> r , <SPC> i ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( points ) ) ) <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> eatenApples ( self , <SPC> apples , <SPC> days ) : <NL> <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <TAB> result <SPC> = <SPC> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( apples ) <SPC> or <SPC> min_heap : <NL>          if <SPC> i <SPC> < <SPC> len ( apples ) <SPC> and <SPC> apples [ i ] <SPC> > <SPC> 0 : <NL>              heapq . heappush ( min_heap , <SPC> [ i <SPC> + <SPC> days [ i ] , <SPC> i ] ) <NL>          while <SPC> min_heap <SPC> and <SPC> ( min_heap [ 0 ] [ 0 ] <SPC> <= <SPC> i <SPC> or <SPC> apples [ min_heap [ 0 ] [ 1 ] ] <SPC> == <SPC> 0 ) : <NL>              heapq . heappop ( min_heap ) <NL>          if <SPC> min_heap : <NL>              apples [ min_heap [ 0 ] [ 1 ] ] <SPC> -= <SPC> 1 <NL>              result <SPC> += <SPC> 1 <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxValue ( self , <SPC> events , <SPC> k ) : <NL> <NL> <TAB> events . sort ( key = lambda <SPC> x : <SPC> x [ 1 ] ) <NL> <TAB> sorted_ends <SPC> = <SPC> [ x [ 1 ] <SPC> for <SPC> x <SPC> in <SPC> events ] <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( k <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( events ) <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( events ) <SPC> + <SPC> 1 ) : <NL>          prev_i_m_1 <SPC> = <SPC> bisect . bisect_left ( sorted_ends , <SPC> events [ i <SPC> - <SPC> 1 ] [ 0 ] ) <SPC> - <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> k <SPC> + <SPC> 1 ) : <NL>              dp [ i ] [ j ] <SPC> = <SPC> max ( <NL>                  dp [ i <SPC> - <SPC> 1 ] [ j ] , <SPC> dp [ prev_i_m_1 <SPC> + <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> events [ i <SPC> - <SPC> 1 ] [ 2 ] <NL>              ) <NL> <TAB> return <SPC> dp [ - 1 ] [ - 1 ] <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxValue ( self , <SPC> events , <SPC> k ) : <NL> <NL> <TAB> events . sort ( ) <NL> <TAB> sorted_starts <SPC> = <SPC> [ x [ 0 ] <SPC> for <SPC> x <SPC> in <SPC> events ] <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( k <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( events ) <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( events ) ) ) : <NL>          next_i <SPC> = <SPC> bisect . bisect_right ( sorted_starts , <SPC> events [ i ] [ 1 ] ) <SPC> - <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> k <SPC> + <SPC> 1 ) : <NL>              dp [ i ] [ j ] <SPC> = <SPC> max ( dp [ i <SPC> + <SPC> 1 ] [ j ] , <SPC> dp [ next_i <SPC> + <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> events [ i ] [ 2 ] ) <NL> <TAB> return <SPC> dp [ 0 ] [ - 1 ] <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxEvents ( self , <SPC> events ) : <NL> <NL> <TAB> events . sort ( reverse = True ) <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> d <SPC> in <SPC> xrange ( 1 , <SPC> max ( events , <SPC> key = lambda <SPC> x : <SPC> x [ 1 ] ) [ 1 ] <SPC> + <SPC> 1 ) : <NL>          while <SPC> events <SPC> and <SPC> events [ - 1 ] [ 0 ] <SPC> == <SPC> d : <NL>              heapq . heappush ( min_heap , <SPC> events . pop ( ) [ 1 ] ) <NL>          while <SPC> min_heap <SPC> and <SPC> min_heap [ 0 ] <SPC> == <SPC> d <SPC> - <SPC> 1 : <NL>              heapq . heappop ( min_heap ) <NL>          if <SPC> not <SPC> min_heap : <NL>              continue <NL>          heapq . heappop ( min_heap ) <NL>          result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxNonOverlapping ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { 0 : <SPC> - 1 } <NL> <TAB> result , <SPC> accu , <SPC> right <SPC> = <SPC> 0 , <SPC> 0 , <SPC> - 1 <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          accu <SPC> += <SPC> num <NL>          if <SPC> accu <SPC> - <SPC> target <SPC> in <SPC> lookup <SPC> and <SPC> lookup [ accu <SPC> - <SPC> target ] <SPC> >= <SPC> right : <NL>              right <SPC> = <SPC> i <NL>              result <SPC> += <SPC> 1 <NL>          lookup [ accu ] <SPC> = <SPC> i <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxNumOfSubstrings ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> find_right_from_left ( s , <SPC> first , <SPC> last , <SPC> left ) : <NL>          right , <SPC> i <SPC> = <SPC> last [ ord ( s [ left ] ) <SPC> - <SPC> ord ( "a" ) ] , <SPC> left <NL>          while <SPC> i <SPC> <= <SPC> right : <NL>              if <SPC> first [ ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> < <SPC> left : <NL>                  return <SPC> - 1 <NL>              right <SPC> = <SPC> max ( right , <SPC> last [ ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ] ) <NL>              i <SPC> += <SPC> 1 <NL>          return <SPC> right <NL> <NL> <TAB> first , <SPC> last <SPC> = <SPC> [ float ( "inf" ) ] <SPC> * <SPC> 26 , <SPC> [ float ( "-inf" ) ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          first [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> min ( first [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] , <SPC> i ) <NL>          last [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> max ( last [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] , <SPC> i ) <NL> <TAB> result <SPC> = <SPC> [ "" ] <NL> <TAB> right <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> left , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          if <SPC> left <SPC> != <SPC> first [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] : <NL>              continue <NL>          new_right <SPC> = <SPC> find_right_from_left ( s , <SPC> first , <SPC> last , <SPC> left ) <NL>          if <SPC> new_right <SPC> == <SPC> - 1 : <NL>              continue <NL>          if <SPC> left <SPC> > <SPC> right : <NL>              result . append ( "" ) <NL>          right <SPC> = <SPC> new_right <NL>          result [ - 1 ] <SPC> = <SPC> s [ left : <SPC> right <SPC> + <SPC> 1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxNumOfSubstrings ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> find_right_from_left ( s , <SPC> first , <SPC> last , <SPC> left ) : <NL>          right , <SPC> i <SPC> = <SPC> last [ ord ( s [ left ] ) <SPC> - <SPC> ord ( "a" ) ] , <SPC> left <NL>          while <SPC> i <SPC> <= <SPC> right : <NL>              if <SPC> first [ ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> < <SPC> left : <NL>                  return <SPC> - 1 <NL>              right <SPC> = <SPC> max ( right , <SPC> last [ ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ] ) <NL>              i <SPC> += <SPC> 1 <NL>          return <SPC> right <NL> <NL> <TAB> first , <SPC> last <SPC> = <SPC> [ float ( "inf" ) ] <SPC> * <SPC> 26 , <SPC> [ float ( "-inf" ) ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          first [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> min ( first [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] , <SPC> i ) <NL>          last [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> max ( last [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] , <SPC> i ) <NL> <TAB> intervals <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> xrange ( len ( first ) ) : <NL>          if <SPC> first [ c ] <SPC> == <SPC> float ( "inf" ) : <NL>              continue <NL>          left , <SPC> right <SPC> = <SPC> first [ c ] , <SPC> find_right_from_left ( s , <SPC> first , <SPC> last , <SPC> first [ c ] ) <NL>          if <SPC> right <SPC> != <SPC> - 1 : <NL>              intervals . append ( ( right , <SPC> left ) ) <NL> <TAB> intervals . sort ( ) <NL> <TAB> result , <SPC> prev <SPC> = <SPC> [ ] , <SPC> - 1 <NL> <TAB> for <SPC> right , <SPC> left <SPC> in <SPC> intervals : <NL>          if <SPC> left <SPC> <= <SPC> prev : <NL>              continue <NL>          result . append ( s [ left : <SPC> right <SPC> + <SPC> 1 ] ) <NL>          prev <SPC> = <SPC> right <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxFreq ( self , <SPC> s , <SPC> maxLetters , <SPC> minSize , <SPC> maxSize ) : <NL> <NL> <TAB> M , <SPC> p <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 , <SPC> 113 <NL> <TAB> power , <SPC> rolling_hash <SPC> = <SPC> pow ( p , <SPC> minSize <SPC> - <SPC> 1 , <SPC> M ) , <SPC> 0 <NL> <NL> <TAB> left <SPC> = <SPC> 0 <NL> <TAB> lookup , <SPC> count <SPC> = <SPC> collections . defaultdict ( int ) , <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          count [ s [ right ] ] <SPC> += <SPC> 1 <NL>          if <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <SPC> > <SPC> minSize : <NL>              count [ s [ left ] ] <SPC> -= <SPC> 1 <NL>              rolling_hash <SPC> = <SPC> ( rolling_hash <SPC> - <SPC> ord ( s [ left ] ) <SPC> * <SPC> power ) <SPC> % <SPC> M <NL>              if <SPC> count [ s [ left ] ] <SPC> == <SPC> 0 : <NL>                  count . pop ( s [ left ] ) <NL>              left <SPC> += <SPC> 1 <NL>          rolling_hash <SPC> = <SPC> ( rolling_hash <SPC> * <SPC> p <SPC> + <SPC> ord ( s [ right ] ) ) <SPC> % <SPC> M <NL>          if <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <SPC> == <SPC> minSize <SPC> and <SPC> len ( count ) <SPC> <= <SPC> maxLetters : <NL>              lookup [ rolling_hash ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> max ( lookup . values ( ) <SPC> or <SPC> [ 0 ] ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxFreq ( self , <SPC> s , <SPC> maxLetters , <SPC> minSize , <SPC> maxSize ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( minSize <SPC> - <SPC> 1 , <SPC> len ( s ) ) : <NL>          word <SPC> = <SPC> s [ right <SPC> - <SPC> minSize <SPC> + <SPC> 1 : <SPC> right <SPC> + <SPC> 1 ] <NL>          if <SPC> word <SPC> in <SPC> lookup : <NL>              lookup [ word ] <SPC> += <SPC> 1 <NL>          elif <SPC> len ( collections . Counter ( word ) ) <SPC> <= <SPC> maxLetters : <NL>              lookup [ word ] <SPC> = <SPC> 1 <NL> <TAB> return <SPC> max ( lookup . values ( ) <SPC> or <SPC> [ 0 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumNumberOfOnes ( self , <SPC> width , <SPC> height , <SPC> sideLength , <SPC> maxOnes ) : <NL> <NL> <TAB> if <SPC> width <SPC> < <SPC> height : <NL>          width , <SPC> height <SPC> = <SPC> height , <SPC> width <NL> <NL> <TAB> R , <SPC> r <SPC> = <SPC> divmod ( height , <SPC> sideLength ) <NL> <TAB> C , <SPC> c <SPC> = <SPC> divmod ( width , <SPC> sideLength ) <NL> <TAB> assert <SPC> R <SPC> <= <SPC> C <NL> <TAB> area_counts <SPC> = <SPC> [ <NL>          ( r <SPC> * <SPC> c , <SPC> ( R <SPC> + <SPC> 1 ) <SPC> * <SPC> ( C <SPC> + <SPC> 1 ) ) , <NL>          ( r <SPC> * <SPC> ( sideLength <SPC> - <SPC> c ) , <SPC> ( R <SPC> + <SPC> 1 ) <SPC> * <SPC> C ) , <NL>          ( ( sideLength <SPC> - <SPC> r ) <SPC> * <SPC> c , <SPC> R <SPC> * <SPC> ( C <SPC> + <SPC> 1 ) ) , <NL>          ( ( sideLength <SPC> - <SPC> r ) <SPC> * <SPC> ( sideLength <SPC> - <SPC> c ) , <SPC> R <SPC> * <SPC> C ) , <NL> <TAB> ] <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> area , <SPC> count <SPC> in <SPC> area_counts : <NL>          area <SPC> = <SPC> min ( maxOnes , <SPC> area ) <NL>          result <SPC> += <SPC> count <SPC> * <SPC> area <NL>          maxOnes <SPC> -= <SPC> area <NL>          if <SPC> not <SPC> maxOnes : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> visiblePoints ( self , <SPC> points , <SPC> angle , <SPC> location ) : <NL> <NL> <TAB> arr , <SPC> extra <SPC> = <SPC> [ ] , <SPC> 0 <NL> <TAB> for <SPC> p <SPC> in <SPC> points : <NL>          if <SPC> p <SPC> == <SPC> location : <NL>              extra <SPC> += <SPC> 1 <NL>              continue <NL>          arr . append ( math . atan2 ( p [ 1 ] <SPC> - <SPC> location [ 1 ] , <SPC> p [ 0 ] <SPC> - <SPC> location [ 0 ] ) ) <NL> <TAB> arr . sort ( ) <NL> <TAB> arr . extend ( [ x <SPC> + <SPC> 2.0 <SPC> * <SPC> math . pi <SPC> for <SPC> x <SPC> in <SPC> arr ] ) <NL> <TAB> d <SPC> = <SPC> 2.0 <SPC> * <SPC> math . pi <SPC> * <SPC> ( angle <SPC> / <SPC> 360.0 ) <NL> <TAB> left <SPC> = <SPC> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( arr ) ) : <NL>          while <SPC> arr [ right ] <SPC> - <SPC> arr [ left ] <SPC> > <SPC> d : <NL>              left <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> max ( result , <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> result <SPC> + <SPC> extra <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxVowels ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> VOWELS <SPC> = <SPC> set ( "aeiou" ) <NL> <TAB> result <SPC> = <SPC> curr <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          curr <SPC> += <SPC> c <SPC> in <SPC> VOWELS <NL>          if <SPC> i <SPC> >= <SPC> k : <NL>              curr <SPC> -= <SPC> s [ i <SPC> - <SPC> k ] <SPC> in <SPC> VOWELS <NL>          result <SPC> = <SPC> max ( result , <SPC> curr ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxAbsValExpr ( self , <SPC> arr1 , <SPC> arr2 ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c1 <SPC> in <SPC> [ 1 , <SPC> - 1 ] : <NL>          for <SPC> c2 <SPC> in <SPC> [ 1 , <SPC> - 1 ] : <NL>              min_prev <SPC> = <SPC> float ( "inf" ) <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( arr1 ) ) : <NL>                  curr <SPC> = <SPC> c1 <SPC> * <SPC> arr1 [ i ] <SPC> + <SPC> c2 <SPC> * <SPC> arr2 [ i ] <SPC> + <SPC> i <NL>                  result <SPC> = <SPC> max ( result , <SPC> curr <SPC> - <SPC> min_prev ) <NL>                  min_prev <SPC> = <SPC> min ( min_prev , <SPC> curr ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxAbsValExpr ( self , <SPC> arr1 , <SPC> arr2 ) : <NL> <NL> <TAB> return <SPC> max ( <NL>          max ( c1 <SPC> * <SPC> arr1 [ i ] <SPC> + <SPC> c2 <SPC> * <SPC> arr2 [ i ] <SPC> + <SPC> i <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( arr1 ) ) ) <NL>          - <SPC> min ( c1 <SPC> * <SPC> arr1 [ i ] <SPC> + <SPC> c2 <SPC> * <SPC> arr2 [ i ] <SPC> + <SPC> i <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( arr1 ) ) ) <NL>          for <SPC> c1 <SPC> in <SPC> [ 1 , <SPC> - 1 ] <NL>          for <SPC> c2 <SPC> in <SPC> [ 1 , <SPC> - 1 ] <NL> <TAB> ) <NL> <NL> <NL> import <SPC> itertools <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxPerformance ( self , <SPC> n , <SPC> speed , <SPC> efficiency , <SPC> k ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> result , <SPC> s_sum <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> e , <SPC> s <SPC> in <SPC> sorted ( itertools . izip ( efficiency , <SPC> speed ) , <SPC> reverse = True ) : <NL>          s_sum <SPC> += <SPC> s <NL>          heapq . heappush ( min_heap , <SPC> s ) <NL>          if <SPC> len ( min_heap ) <SPC> > <SPC> k : <NL>              s_sum <SPC> -= <SPC> heapq . heappop ( min_heap ) <NL>          result <SPC> = <SPC> max ( result , <SPC> s_sum <SPC> * <SPC> e ) <NL> <TAB> return <SPC> result <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxScore ( self , <SPC> cardPoints , <SPC> k ) : <NL> <NL> <TAB> result , <SPC> total , <SPC> curr , <SPC> left <SPC> = <SPC> float ( "inf" ) , <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> right , <SPC> point <SPC> in <SPC> enumerate ( cardPoints ) : <NL>          total <SPC> += <SPC> point <NL>          curr <SPC> += <SPC> point <NL>          if <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <SPC> > <SPC> len ( cardPoints ) <SPC> - <SPC> k : <NL>              curr <SPC> -= <SPC> cardPoints [ left ] <NL>              left <SPC> += <SPC> 1 <NL>          if <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <SPC> == <SPC> len ( cardPoints ) <SPC> - <SPC> k : <NL>              result <SPC> = <SPC> min ( result , <SPC> curr ) <NL> <TAB> return <SPC> total <SPC> - <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProduct ( self , <SPC> root ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> def <SPC> dfs ( root , <SPC> total , <SPC> result ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 <NL>          subtotal <SPC> = <SPC> ( <NL>              dfs ( root . left , <SPC> total , <SPC> result ) <NL>              + <SPC> dfs ( root . right , <SPC> total , <SPC> result ) <NL>              + <SPC> root . val <NL>          ) <NL>          result [ 0 ] <SPC> = <SPC> max ( result [ 0 ] , <SPC> subtotal <SPC> * <SPC> ( total <SPC> - <SPC> subtotal ) ) <NL>          return <SPC> subtotal <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> dfs ( root , <SPC> dfs ( root , <SPC> 0 , <SPC> result ) , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumProduct ( self , <SPC> nums ) : <NL> <NL> <TAB> min1 , <SPC> min2 <SPC> = <SPC> float ( "inf" ) , <SPC> float ( "inf" ) <NL> <TAB> max1 , <SPC> max2 , <SPC> max3 <SPC> = <SPC> float ( "-inf" ) , <SPC> float ( "-inf" ) , <SPC> float ( "-inf" ) <NL> <NL> <TAB> for <SPC> n <SPC> in <SPC> nums : <NL>          if <SPC> n <SPC> <= <SPC> min1 : <NL>              min2 <SPC> = <SPC> min1 <NL>              min1 <SPC> = <SPC> n <NL>          elif <SPC> n <SPC> <= <SPC> min2 : <NL>              min2 <SPC> = <SPC> n <NL> <NL>          if <SPC> n <SPC> >= <SPC> max1 : <NL>              max3 <SPC> = <SPC> max2 <NL>              max2 <SPC> = <SPC> max1 <NL>              max1 <SPC> = <SPC> n <NL>          elif <SPC> n <SPC> >= <SPC> max2 : <NL>              max3 <SPC> = <SPC> max2 <NL>              max2 <SPC> = <SPC> n <NL>          elif <SPC> n <SPC> >= <SPC> max3 : <NL>              max3 <SPC> = <SPC> n <NL> <NL> <TAB> return <SPC> max ( min1 <SPC> * <SPC> min2 <SPC> * <SPC> max1 , <SPC> max1 <SPC> * <SPC> max2 <SPC> * <SPC> max3 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProduct ( self , <SPC> nums ) : <NL> <NL> <TAB> m1 <SPC> = <SPC> m2 <SPC> = <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          if <SPC> num <SPC> > <SPC> m1 : <NL>              m1 , <SPC> m2 <SPC> = <SPC> num , <SPC> m1 <NL>          elif <SPC> num <SPC> > <SPC> m2 : <NL>              m2 <SPC> = <SPC> num <NL> <TAB> return <SPC> ( m1 <SPC> - <SPC> 1 ) <SPC> * <SPC> ( m2 <SPC> - <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProduct ( self , <SPC> words ) : <NL> <NL> <TAB> def <SPC> counting_sort ( words ) : <NL>          k <SPC> = <SPC> 1000 <NL>          buckets <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( k ) ] <NL>          for <SPC> word <SPC> in <SPC> words : <NL>              buckets [ len ( word ) ] . append ( word ) <NL>          res <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( k ) ) : <NL>              if <SPC> buckets [ i ] : <NL>                  res <SPC> += <SPC> buckets [ i ] <NL>          return <SPC> res <NL> <NL> <TAB> words <SPC> = <SPC> counting_sort ( words ) <NL> <TAB> bits <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( words ) <NL> <TAB> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          for <SPC> c <SPC> in <SPC> word : <NL>              bits [ i ] <SPC> |= <SPC> 1 <SPC> << <SPC> ( ord ( c ) <SPC> - <SPC> ord ( "a" ) ) <NL> <NL> <TAB> max_product <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> len ( words [ i ] ) <SPC> ** <SPC> 2 <SPC> <= <SPC> max_product : <NL>              break <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( words ) ) : <NL>              if <SPC> len ( words [ i ] ) <SPC> * <SPC> len ( words [ j ] ) <SPC> <= <SPC> max_product : <NL>                  break <NL>              if <SPC> not <SPC> ( bits [ i ] <SPC> & <SPC> bits [ j ] ) : <NL>                  max_product <SPC> = <SPC> len ( words [ i ] ) <SPC> * <SPC> len ( words [ j ] ) <NL> <TAB> return <SPC> max_product <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxProduct ( self , <SPC> words ) : <NL> <NL> <TAB> words . sort ( key = lambda <SPC> x : <SPC> len ( x ) , <SPC> reverse = True ) <NL> <TAB> bits <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( words ) <NL> <TAB> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          for <SPC> c <SPC> in <SPC> word : <NL>              bits [ i ] <SPC> |= <SPC> 1 <SPC> << <SPC> ( ord ( c ) <SPC> - <SPC> ord ( "a" ) ) <NL> <NL> <TAB> max_product <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> len ( words [ i ] ) <SPC> ** <SPC> 2 <SPC> <= <SPC> max_product : <NL>              break <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( words ) ) : <NL>              if <SPC> len ( words [ i ] ) <SPC> * <SPC> len ( words [ j ] ) <SPC> <= <SPC> max_product : <NL>                  break <NL>              if <SPC> not <SPC> ( bits [ i ] <SPC> & <SPC> bits [ j ] ) : <NL>                  max_product <SPC> = <SPC> len ( words [ i ] ) <SPC> * <SPC> len ( words [ j ] ) <NL> <TAB> return <SPC> max_product <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> maxProduct ( self , <SPC> A ) : <NL> <TAB> global_max , <SPC> local_max , <SPC> local_min <SPC> = <SPC> float ( "-inf" ) , <SPC> 1 , <SPC> 1 <NL> <TAB> for <SPC> x <SPC> in <SPC> A : <NL>          local_max , <SPC> local_min <SPC> = <SPC> max ( x , <SPC> local_max <SPC> * <SPC> x , <SPC> local_min <SPC> * <SPC> x ) , <SPC> min ( <NL>              x , <SPC> local_max <SPC> * <SPC> x , <SPC> local_min <SPC> * <SPC> x <NL>          ) <NL>          global_max <SPC> = <SPC> max ( global_max , <SPC> local_max ) <NL> <TAB> return <SPC> global_max <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> maxProduct ( self , <SPC> A ) : <NL> <TAB> global_max , <SPC> local_max , <SPC> local_min <SPC> = <SPC> float ( "-inf" ) , <SPC> 1 , <SPC> 1 <NL> <TAB> for <SPC> x <SPC> in <SPC> A : <NL>          local_max <SPC> = <SPC> max ( 1 , <SPC> local_max ) <NL>          if <SPC> x <SPC> > <SPC> 0 : <NL>              local_max , <SPC> local_min <SPC> = <SPC> local_max <SPC> * <SPC> x , <SPC> local_min <SPC> * <SPC> x <NL>          else : <NL>              local_max , <SPC> local_min <SPC> = <SPC> local_min <SPC> * <SPC> x , <SPC> local_max <SPC> * <SPC> x <NL>          global_max <SPC> = <SPC> max ( global_max , <SPC> local_max ) <NL> <TAB> return <SPC> global_max <NL> <NL> <NL> import <SPC> itertools <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> jobScheduling ( self , <SPC> startTime , <SPC> endTime , <SPC> profit ) : <NL> <NL> <TAB> jobs <SPC> = <SPC> sorted ( itertools . izip ( endTime , <SPC> startTime , <SPC> profit ) ) <NL> <TAB> dp <SPC> = <SPC> [ ( 0 , <SPC> 0 ) ] <NL> <TAB> for <SPC> e , <SPC> s , <SPC> p <SPC> in <SPC> jobs : <NL>          i <SPC> = <SPC> bisect . bisect_right ( dp , <SPC> ( s <SPC> + <SPC> 1 , <SPC> 0 ) ) <SPC> - <SPC> 1 <NL>          if <SPC> dp [ i ] [ 1 ] <SPC> + <SPC> p <SPC> > <SPC> dp [ - 1 ] [ 1 ] : <NL>              dp . append ( ( e , <SPC> dp [ i ] [ 1 ] <SPC> + <SPC> p ) ) <NL> <TAB> return <SPC> dp [ - 1 ] [ 1 ] <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> jobScheduling ( self , <SPC> startTime , <SPC> endTime , <SPC> profit ) : <NL> <NL> <TAB> min_heap <SPC> = <SPC> zip ( startTime , <SPC> endTime , <SPC> profit ) <NL> <TAB> heapq . heapify ( min_heap ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> min_heap : <NL>          s , <SPC> e , <SPC> p <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> s <SPC> < <SPC> e : <NL>              heapq . heappush ( min_heap , <SPC> ( e , <SPC> s , <SPC> result <SPC> + <SPC> p ) ) <NL>          else : <NL>              result <SPC> = <SPC> max ( result , <SPC> p ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minOperationsMaxProfit ( self , <SPC> customers , <SPC> boardingCost , <SPC> runningCost ) : <NL> <NL> <TAB> max_run <SPC> = <SPC> - 1 <NL> <TAB> i <SPC> = <SPC> max_prof <SPC> = <SPC> prof <SPC> = <SPC> waiting <SPC> = <SPC> 0 <NL> <TAB> run <SPC> = <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( customers ) <SPC> or <SPC> waiting <SPC> > <SPC> 0 : <NL>          if <SPC> i <SPC> < <SPC> len ( customers ) : <NL>              waiting <SPC> += <SPC> customers [ i ] <NL>              i <SPC> += <SPC> 1 <NL>          boarding <SPC> = <SPC> min ( waiting , <SPC> 4 ) <NL>          waiting <SPC> -= <SPC> boarding <NL>          prof <SPC> += <SPC> boarding <SPC> * <SPC> boardingCost <SPC> - <SPC> runningCost <NL>          if <SPC> prof <SPC> > <SPC> max_prof : <NL>              max_prof <SPC> = <SPC> prof <NL>              max_run <SPC> = <SPC> run <NL>          run <SPC> += <SPC> 1 <NL> <TAB> return <SPC> max_run <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxRepeating ( self , <SPC> sequence , <SPC> word ) : <NL> <NL> <TAB> def <SPC> getPrefix ( pattern ) : <NL>          prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>              while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              prefix [ i ] <SPC> = <SPC> j <NL>          return <SPC> prefix <NL> <NL> <TAB> if <SPC> len ( sequence ) <SPC> < <SPC> len ( word ) : <NL>          return <SPC> 0 <NL> <NL> <TAB> prefix <SPC> = <SPC> getPrefix ( word ) <NL> <TAB> result , <SPC> count , <SPC> j , <SPC> prev <SPC> = <SPC> 0 , <SPC> 0 , <SPC> - 1 , <SPC> - 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( sequence ) ) : <NL>          while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> word [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> sequence [ i ] : <NL>              j <SPC> = <SPC> prefix [ j ] <NL>          if <SPC> word [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> sequence [ i ] : <NL>              j <SPC> += <SPC> 1 <NL>          if <SPC> j <SPC> + <SPC> 1 <SPC> == <SPC> len ( word ) : <NL>              count <SPC> = <SPC> count <SPC> + <SPC> 1 <SPC> if <SPC> i <SPC> - <SPC> prev <SPC> == <SPC> len ( word ) <SPC> else <SPC> 1 <NL>              result <SPC> = <SPC> max ( result , <SPC> count ) <NL>              j , <SPC> prev <SPC> = <SPC> - 1 , <SPC> i <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxRepeating ( self , <SPC> sequence , <SPC> word ) : <NL> <NL> <TAB> def <SPC> getPrefix ( pattern ) : <NL>          prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>              while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              prefix [ i ] <SPC> = <SPC> j <NL>          return <SPC> prefix <NL> <NL> <TAB> if <SPC> len ( sequence ) <SPC> < <SPC> len ( word ) : <NL>          return <SPC> 0 <NL> <NL> <TAB> new_word <SPC> = <SPC> word <SPC> * <SPC> ( len ( sequence ) <SPC> // <SPC> len ( word ) ) <NL> <TAB> prefix <SPC> = <SPC> getPrefix ( new_word ) <NL> <TAB> result , <SPC> j <SPC> = <SPC> 0 , <SPC> - 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( sequence ) ) : <NL>          while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> new_word [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> sequence [ i ] : <NL>              j <SPC> = <SPC> prefix [ j ] <NL>          if <SPC> new_word [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> sequence [ i ] : <NL>              j <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> max ( result , <SPC> j <SPC> + <SPC> 1 ) <NL>          if <SPC> j <SPC> + <SPC> 1 <SPC> == <SPC> len ( new_word ) : <NL>              break <NL> <TAB> return <SPC> result <SPC> // <SPC> len ( word ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxScore ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> zeros , <SPC> ones <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> s [ i ] <SPC> == <SPC> "0" : <NL>              zeros <SPC> += <SPC> 1 <NL>          else : <NL>              ones <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> max ( result , <SPC> zeros <SPC> - <SPC> ones ) <NL> <TAB> return <SPC> result <SPC> + <SPC> ones <SPC> + <SPC> ( s [ 0 ] <SPC> == <SPC> "0" ) <SPC> + <SPC> ( s [ - 1 ] <SPC> == <SPC> "1" ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumScore ( self , <SPC> nums , <SPC> multipliers ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( multipliers ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> l , <SPC> m <SPC> in <SPC> enumerate ( <NL>          reversed ( multipliers ) , <SPC> start = len ( nums ) <SPC> - <SPC> len ( multipliers ) <NL> <TAB> ) : <NL>          dp <SPC> = <SPC> [ <NL>              max ( m <SPC> * <SPC> nums [ i ] <SPC> + <SPC> dp [ i <SPC> + <SPC> 1 ] , <SPC> m <SPC> * <SPC> nums [ i <SPC> + <SPC> l ] <SPC> + <SPC> dp [ i ] ) <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( dp ) <SPC> - <SPC> 1 ) <NL>          ] <NL> <TAB> return <SPC> dp [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumScore ( self , <SPC> a , <SPC> b , <SPC> c ) : <NL> <NL> <TAB> return <SPC> min ( ( a <SPC> + <SPC> b <SPC> + <SPC> c ) <SPC> // <SPC> 2 , <SPC> a <SPC> + <SPC> b <SPC> + <SPC> c <SPC> - <SPC> max ( a , <SPC> b , <SPC> c ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumGain ( self , <SPC> s , <SPC> x , <SPC> y ) : <NL> <NL> <TAB> def <SPC> score ( s , <SPC> a , <SPC> x ) : <NL>          i <SPC> = <SPC> result <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( s ) ) : <NL>              s [ i ] <SPC> = <SPC> s [ j ] <NL>              i <SPC> += <SPC> 1 <NL>              if <SPC> i <SPC> >= <SPC> 2 <SPC> and <SPC> s [ i <SPC> - <SPC> 2 : <SPC> i ] <SPC> == <SPC> a : <NL>                  i <SPC> -= <SPC> 2 <NL>                  result <SPC> += <SPC> x <NL>          s [ : ] <SPC> = <SPC> s [ : i ] <NL>          return <SPC> result <NL> <NL> <TAB> s , <SPC> a , <SPC> b <SPC> = <SPC> list ( s ) , <SPC> list ( "ab" ) , <SPC> list ( "ba" ) <NL> <TAB> if <SPC> x <SPC> < <SPC> y : <NL>          x , <SPC> y <SPC> = <SPC> y , <SPC> x <NL>          a , <SPC> b <SPC> = <SPC> b , <SPC> a <NL> <TAB> return <SPC> score ( s , <SPC> a , <SPC> x ) <SPC> + <SPC> score ( s , <SPC> b , <SPC> y ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumScore ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> curr <SPC> = <SPC> nums [ k ] <NL> <TAB> left <SPC> = <SPC> right <SPC> = <SPC> k <NL> <TAB> while <SPC> left <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <SPC> or <SPC> right <SPC> + <SPC> 1 <SPC> < <SPC> len ( nums ) : <NL> <NL>          if <SPC> ( nums [ left <SPC> - <SPC> 1 ] <SPC> if <SPC> left <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <SPC> else <SPC> 0 ) <SPC> <= <SPC> ( <NL>              nums [ right <SPC> + <SPC> 1 ] <SPC> if <SPC> right <SPC> + <SPC> 1 <SPC> < <SPC> len ( nums ) <SPC> else <SPC> 0 <NL>          ) : <NL>              right <SPC> += <SPC> 1 <NL>          else : <NL>              left <SPC> -= <SPC> 1 <NL>          curr <SPC> = <SPC> min ( curr , <SPC> nums [ left ] , <SPC> nums [ right ] ) <NL>          result <SPC> = <SPC> max ( result , <SPC> curr <SPC> * <SPC> ( right <SPC> - <SPC> left <SPC> + <SPC> 1 ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maximumScore ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> score ( nums , <SPC> k ) : <NL>          prefix <SPC> = <SPC> [ nums [ k ] ] <SPC> * <SPC> ( k <SPC> + <SPC> 1 ) <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( k ) ) : <NL>              prefix [ i ] <SPC> = <SPC> min ( prefix [ i <SPC> + <SPC> 1 ] , <SPC> nums [ i ] ) <NL>          result <SPC> = <SPC> right <SPC> = <SPC> nums [ k ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( k <SPC> + <SPC> 1 , <SPC> len ( nums ) ) : <NL>              right <SPC> = <SPC> min ( right , <SPC> nums [ j ] ) <NL>              i <SPC> = <SPC> bisect . bisect_left ( prefix , <SPC> right ) <NL>              if <SPC> i <SPC> >= <SPC> 0 : <NL>                  result <SPC> = <SPC> max ( result , <SPC> right <SPC> * <SPC> ( j <SPC> - <SPC> i <SPC> + <SPC> 1 ) ) <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> max ( score ( nums , <SPC> k ) , <SPC> score ( nums [ : : - 1 ] , <SPC> len ( nums ) <SPC> - <SPC> 1 <SPC> - <SPC> k ) ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxScoreWords ( self , <SPC> words , <SPC> letters , <SPC> score ) : <NL> <NL> <TAB> def <SPC> backtracking ( <NL>          words , <SPC> word_scores , <SPC> word_counts , <SPC> curr , <SPC> curr_score , <SPC> letter_count , <SPC> result <NL> <TAB> ) : <NL>          result [ 0 ] <SPC> = <SPC> max ( result [ 0 ] , <SPC> curr_score ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( curr , <SPC> len ( words ) ) : <NL>              if <SPC> any ( letter_count [ c ] <SPC> < <SPC> word_counts [ i ] [ c ] <SPC> for <SPC> c <SPC> in <SPC> word_counts [ i ] ) : <NL>                  continue <NL>              backtracking ( <NL>                  words , <NL>                  word_scores , <NL>                  word_counts , <NL>                  i <SPC> + <SPC> 1 , <NL>                  curr_score <SPC> + <SPC> word_scores [ i ] , <NL>                  letter_count <SPC> - <SPC> word_counts [ i ] , <NL>                  result , <NL>              ) <NL> <NL> <TAB> letter_count <SPC> = <SPC> collections . Counter ( letters ) <NL> <TAB> word_counts <SPC> = <SPC> map ( collections . Counter , <SPC> words ) <NL> <TAB> word_scores <SPC> = <SPC> [ <NL>          sum ( score [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> for <SPC> c <SPC> in <SPC> words [ i ] ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) ) <NL> <TAB> ] <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> backtracking ( words , <SPC> word_scores , <SPC> word_counts , <SPC> 0 , <SPC> 0 , <SPC> letter_count , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSideLength ( self , <SPC> mat , <SPC> threshold ) : <NL> <NL> <TAB> def <SPC> check ( dp , <SPC> mid , <SPC> threshold ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( mid , <SPC> len ( dp ) ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( mid , <SPC> len ( dp [ 0 ] ) ) : <NL>                  if <SPC> ( <NL>                      dp [ i ] [ j ] <NL>                      - <SPC> dp [ i <SPC> - <SPC> mid ] [ j ] <NL>                      - <SPC> dp [ i ] [ j <SPC> - <SPC> mid ] <NL>                      + <SPC> dp [ i <SPC> - <SPC> mid ] [ j <SPC> - <SPC> mid ] <NL>                      <= <SPC> threshold <NL>                  ) : <NL>                      return <SPC> True <NL>          return <SPC> False <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( mat [ 0 ] ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( mat ) <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( mat ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( mat [ 0 ] ) <SPC> + <SPC> 1 ) : <NL>              dp [ i ] [ j ] <SPC> = <SPC> ( <NL>                  dp [ i <SPC> - <SPC> 1 ] [ j ] <SPC> + <SPC> dp [ i ] [ j <SPC> - <SPC> 1 ] <SPC> - <NL>                  dp [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> mat [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <NL>              ) <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> min ( len ( mat ) , <SPC> len ( mat [ 0 ] ) <SPC> + <SPC> 1 ) <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( dp , <SPC> mid , <SPC> threshold ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSubArrayLen ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> sums <SPC> = <SPC> { } <NL> <TAB> cur_sum , <SPC> max_len <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          cur_sum <SPC> += <SPC> nums [ i ] <NL>          if <SPC> cur_sum <SPC> == <SPC> k : <NL>              max_len <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>          elif <SPC> cur_sum <SPC> - <SPC> k <SPC> in <SPC> sums : <NL>              max_len <SPC> = <SPC> max ( max_len , <SPC> i <SPC> - <SPC> sums [ cur_sum <SPC> - <SPC> k ] ) <NL>          if <SPC> cur_sum <SPC> not <SPC> in <SPC> sums : <NL>              sums [ cur_sum ] <SPC> = <SPC> i <NL> <TAB> return <SPC> max_len <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> def <SPC> bipartiteMatch ( graph ) : <NL> <NL> <TAB> matching <SPC> = <SPC> { } <NL> <TAB> for <SPC> u <SPC> in <SPC> graph : <NL> <TAB> for <SPC> v <SPC> in <SPC> graph [ u ] : <NL>          if <SPC> v <SPC> not <SPC> in <SPC> matching : <NL>              matching [ v ] <SPC> = <SPC> u <NL>              break <NL> <NL> <TAB> while <SPC> 1 : <NL> <NL> <TAB> preds <SPC> = <SPC> { } <NL> <TAB> unmatched <SPC> = <SPC> [ ] <NL> <TAB> pred <SPC> = <SPC> dict ( [ ( u , <SPC> unmatched ) <SPC> for <SPC> u <SPC> in <SPC> graph ] ) <NL> <TAB> for <SPC> v <SPC> in <SPC> matching : <NL>          del <SPC> pred [ matching [ v ] ] <NL> <TAB> layer <SPC> = <SPC> list ( pred ) <NL> <NL> <TAB> while <SPC> layer <SPC> and <SPC> not <SPC> unmatched : <NL>          newLayer <SPC> = <SPC> { } <NL>          for <SPC> u <SPC> in <SPC> layer : <NL>              for <SPC> v <SPC> in <SPC> graph [ u ] : <NL>                  if <SPC> v <SPC> not <SPC> in <SPC> preds : <NL>                      newLayer . setdefault ( v , <SPC> [ ] ) . append ( u ) <NL>          layer <SPC> = <SPC> [ ] <NL>          for <SPC> v <SPC> in <SPC> newLayer : <NL>              preds [ v ] <SPC> = <SPC> newLayer [ v ] <NL>              if <SPC> v <SPC> in <SPC> matching : <NL>                  layer . append ( matching [ v ] ) <NL>                  pred [ matching [ v ] ] <SPC> = <SPC> v <NL>              else : <NL>                  unmatched . append ( v ) <NL> <NL> <TAB> if <SPC> not <SPC> unmatched : <NL>          unlayered <SPC> = <SPC> { } <NL>          for <SPC> u <SPC> in <SPC> graph : <NL>              for <SPC> v <SPC> in <SPC> graph [ u ] : <NL>                  if <SPC> v <SPC> not <SPC> in <SPC> preds : <NL>                      unlayered [ v ] <SPC> = <SPC> None <NL>          return <SPC> ( matching , <SPC> list ( pred ) , <SPC> list ( unlayered ) ) <NL> <NL> <TAB> def <SPC> recurse ( v ) : <NL>          if <SPC> v <SPC> in <SPC> preds : <NL>              L <SPC> = <SPC> preds [ v ] <NL>              del <SPC> preds [ v ] <NL>              for <SPC> u <SPC> in <SPC> L : <NL>                  if <SPC> u <SPC> in <SPC> pred : <NL>                      pu <SPC> = <SPC> pred [ u ] <NL>                      del <SPC> pred [ u ] <NL>                      if <SPC> pu <SPC> is <SPC> unmatched <SPC> or <SPC> recurse ( pu ) : <NL>                          matching [ v ] <SPC> = <SPC> u <NL>                          return <SPC> 1 <NL>          return <SPC> 0 <NL> <NL> <TAB> for <SPC> v <SPC> in <SPC> unmatched : <NL>          recurse ( v ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxStudents ( self , <SPC> seats ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( - 1 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 1 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 1 ) ] <NL> <TAB> E , <SPC> count <SPC> = <SPC> collections . defaultdict ( list ) , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( seats ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( seats [ 0 ] ) ) : <NL>              if <SPC> seats [ i ] [ j ] <SPC> != <SPC> "." : <NL>                  continue <NL>              count <SPC> += <SPC> 1 <NL>              if <SPC> j <SPC> % <SPC> 2 : <NL>                  continue <NL>              for <SPC> dx , <SPC> dy <SPC> in <SPC> directions : <NL>                  ni , <SPC> nj <SPC> = <SPC> i <SPC> + <SPC> dx , <SPC> j <SPC> + <SPC> dy <NL>                  if <SPC> ( <NL>                      0 <SPC> <= <SPC> ni <SPC> < <SPC> len ( seats ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nj <SPC> < <SPC> len ( seats [ 0 ] ) <NL>                      and <SPC> seats [ ni ] [ nj ] <SPC> == <SPC> "." <NL>                  ) : <NL>                      E [ i <SPC> * <SPC> len ( seats [ 0 ] ) <SPC> + <SPC> j ] . append ( ni <SPC> * <SPC> len ( seats [ 0 ] ) <SPC> + <SPC> nj ) <NL> <TAB> return <SPC> count <SPC> - <SPC> len ( bipartiteMatch ( E ) [ 0 ] ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxStudents ( self , <SPC> seats ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( - 1 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 1 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 1 ) ] <NL> <NL> <TAB> def <SPC> dfs ( seats , <SPC> e , <SPC> lookup , <SPC> matching ) : <NL>          i , <SPC> j <SPC> = <SPC> e <NL>          for <SPC> dx , <SPC> dy <SPC> in <SPC> directions : <NL>              ni , <SPC> nj <SPC> = <SPC> i <SPC> + <SPC> dx , <SPC> j <SPC> + <SPC> dy <NL>              if <SPC> ( <NL>                  0 <SPC> <= <SPC> ni <SPC> < <SPC> len ( seats ) <NL>                  and <SPC> 0 <SPC> <= <SPC> nj <SPC> < <SPC> len ( seats [ 0 ] ) <NL>                  and <SPC> seats [ ni ] [ nj ] <SPC> == <SPC> "." <NL>                  and <SPC> not <SPC> lookup [ ni ] [ nj ] <NL>              ) : <NL>                  lookup [ ni ] [ nj ] <SPC> = <SPC> True <NL>                  if <SPC> matching [ ni ] [ nj ] <SPC> == <SPC> - 1 <SPC> or <SPC> dfs ( <NL>                      seats , <SPC> matching [ ni ] [ nj ] , <SPC> lookup , <SPC> matching <NL>                  ) : <NL>                      matching [ ni ] [ nj ] <SPC> = <SPC> e <NL>                      return <SPC> True <NL>          return <SPC> False <NL> <NL> <TAB> def <SPC> Hungarian ( seats ) : <NL>          result <SPC> = <SPC> 0 <NL>          matching <SPC> = <SPC> [ [ - 1 ] <SPC> * <SPC> len ( seats [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( seats ) ) ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( seats ) ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( 0 , <SPC> len ( seats [ 0 ] ) , <SPC> 2 ) : <NL>                  if <SPC> seats [ i ] [ j ] <SPC> != <SPC> "." : <NL>                      continue <NL>                  lookup <SPC> = <SPC> [ [ False ] <SPC> * <SPC> len ( seats [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( seats ) ) ] <NL>                  if <SPC> dfs ( seats , <SPC> ( i , <SPC> j ) , <SPC> lookup , <SPC> matching ) : <NL>                      result <SPC> += <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( seats ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( seats [ 0 ] ) ) : <NL>              if <SPC> seats [ i ] [ j ] <SPC> == <SPC> "." : <NL>                  count <SPC> += <SPC> 1 <NL> <TAB> return <SPC> count <SPC> - <SPC> Hungarian ( seats ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> maxStudents ( self , <SPC> seats ) : <NL> <NL> <TAB> def <SPC> popcount ( n ) : <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> n : <NL>              n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL>              result <SPC> += <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> dp <SPC> = <SPC> { 0 : <SPC> 0 } <NL> <TAB> for <SPC> row <SPC> in <SPC> seats : <NL>          invalid_mask <SPC> = <SPC> sum ( 1 <SPC> << <SPC> c <SPC> for <SPC> c , <SPC> v <SPC> in <SPC> enumerate ( row ) <SPC> if <SPC> v <SPC> == <SPC> "#" ) <NL>          new_dp <SPC> = <SPC> { } <NL>          for <SPC> mask1 , <SPC> v1 <SPC> in <SPC> dp . iteritems ( ) : <NL>              for <SPC> mask2 <SPC> in <SPC> xrange ( 1 <SPC> << <SPC> len ( seats [ 0 ] ) ) : <NL>                  if <SPC> ( <NL>                      ( mask2 <SPC> & <SPC> invalid_mask ) <NL>                      or <SPC> ( mask2 <SPC> & <SPC> ( mask1 <SPC> << <SPC> 1 ) ) <NL>                      or <SPC> ( mask2 <SPC> & <SPC> ( mask1 <SPC> >> <SPC> 1 ) ) <NL>                      or <SPC> ( mask2 <SPC> & <SPC> ( mask2 <SPC> << <SPC> 1 ) ) <NL>                      or <SPC> ( mask2 <SPC> & <SPC> ( mask2 <SPC> >> <SPC> 1 ) ) <NL>                  ) : <NL>                      continue <NL>                  new_dp [ mask2 ] <SPC> = <SPC> max ( new_dp . get ( mask2 , <SPC> 0 ) , <SPC> v1 <SPC> + <SPC> popcount ( mask2 ) ) <NL>          dp <SPC> = <SPC> new_dp <NL> <TAB> return <SPC> max ( dp . itervalues ( ) ) <SPC> if <SPC> dp <SPC> else <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSumAfterOperation ( self , <SPC> nums ) : <NL> <NL> <TAB> prev_with_square <SPC> = <SPC> prev_without_square <SPC> = <SPC> 0 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          without_square <SPC> = <SPC> max ( num , <SPC> num <SPC> + <SPC> prev_without_square ) <NL>          with_square <SPC> = <SPC> max ( <NL>              num <SPC> * <SPC> num , <SPC> num <SPC> * <SPC> num <SPC> + <SPC> prev_without_square , <SPC> num <SPC> + <SPC> prev_with_square <NL>          ) <NL>          result <SPC> = <SPC> max ( result , <SPC> with_square ) <NL>          prev_with_square , <SPC> prev_without_square <SPC> = <SPC> with_square , <SPC> without_square <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumSum ( self , <SPC> arr ) : <NL> <NL> <TAB> result , <SPC> prev , <SPC> curr <SPC> = <SPC> float ( "-inf" ) , <SPC> float ( "-inf" ) , <SPC> float ( "-inf" ) <NL> <TAB> for <SPC> x <SPC> in <SPC> arr : <NL>          curr <SPC> = <SPC> max ( prev , <SPC> curr <SPC> + <SPC> x , <SPC> x ) <NL>          result <SPC> = <SPC> max ( result , <SPC> curr ) <NL>          prev <SPC> = <SPC> max ( prev <SPC> + <SPC> x , <SPC> x ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSubArray ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> curr <SPC> = <SPC> float ( "-inf" ) , <SPC> float ( "-inf" ) <NL> <TAB> for <SPC> x <SPC> in <SPC> nums : <NL>          curr <SPC> = <SPC> max ( curr <SPC> + <SPC> x , <SPC> x ) <NL>          result <SPC> = <SPC> max ( result , <SPC> curr ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSumBST ( self , <SPC> root ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> stk <SPC> = <SPC> [ [ root , <SPC> None , <SPC> [ ] ] ] <NL> <TAB> while <SPC> stk : <NL>          node , <SPC> tmp , <SPC> ret <SPC> = <SPC> stk . pop ( ) <NL>          if <SPC> tmp : <NL>              lvalid , <SPC> lsum , <SPC> lmin , <SPC> lmax <SPC> = <SPC> tmp [ 0 ] <NL>              rvalid , <SPC> rsum , <SPC> rmin , <SPC> rmax <SPC> = <SPC> tmp [ 1 ] <NL>              if <SPC> lvalid <SPC> and <SPC> rvalid <SPC> and <SPC> lmax <SPC> < <SPC> node . val <SPC> < <SPC> rmin : <NL>                  total <SPC> = <SPC> lsum <SPC> + <SPC> node . val <SPC> + <SPC> rsum <NL>                  result <SPC> = <SPC> max ( result , <SPC> total ) <NL>                  ret [ : ] <SPC> = <SPC> [ True , <SPC> total , <SPC> min ( <NL>                      lmin , <SPC> node . val ) , <SPC> max ( node . val , <SPC> rmax ) ] <NL>                  continue <NL>              ret [ : ] <SPC> = <SPC> [ False , <SPC> 0 , <SPC> 0 , <SPC> 0 ] <NL>              continue <NL>          if <SPC> not <SPC> node : <NL>              ret [ : ] <SPC> = <SPC> [ True , <SPC> 0 , <SPC> float ( "inf" ) , <SPC> float ( "-inf" ) ] <NL>              continue <NL>          new_tmp <SPC> = <SPC> [ [ ] , <SPC> [ ] ] <NL>          stk . append ( [ node , <SPC> new_tmp , <SPC> ret ] ) <NL>          stk . append ( [ node . right , <SPC> None , <SPC> new_tmp [ 1 ] ] ) <NL>          stk . append ( [ node . left , <SPC> None , <SPC> new_tmp [ 0 ] ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxSumBST ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> result ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> True , <SPC> 0 , <SPC> float ( "inf" ) , <SPC> float ( "-inf" ) <NL>          lvalid , <SPC> lsum , <SPC> lmin , <SPC> lmax <SPC> = <SPC> dfs ( node . left , <SPC> result ) <NL>          rvalid , <SPC> rsum , <SPC> rmin , <SPC> rmax <SPC> = <SPC> dfs ( node . right , <SPC> result ) <NL>          if <SPC> lvalid <SPC> and <SPC> rvalid <SPC> and <SPC> lmax <SPC> < <SPC> node . val <SPC> < <SPC> rmin : <NL>              total <SPC> = <SPC> lsum <SPC> + <SPC> node . val <SPC> + <SPC> rsum <NL>              result [ 0 ] <SPC> = <SPC> max ( result [ 0 ] , <SPC> total ) <NL>              return <SPC> True , <SPC> total , <SPC> min ( lmin , <SPC> node . val ) , <SPC> max ( node . val , <SPC> rmax ) <NL>          return <SPC> False , <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> dfs ( root , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSubarraySumCircular ( self , <SPC> A ) : <NL> <NL> <TAB> total , <SPC> max_sum , <SPC> cur_max , <SPC> min_sum , <SPC> cur_min <SPC> = <SPC> 0 , <SPC> -          float ( "inf" ) , <SPC> 0 , <SPC> float ( "inf" ) , <SPC> 0 <NL> <TAB> for <SPC> a <SPC> in <SPC> A : <NL>          cur_max <SPC> = <SPC> max ( cur_max <SPC> + <SPC> a , <SPC> a ) <NL>          max_sum <SPC> = <SPC> max ( max_sum , <SPC> cur_max ) <NL>          cur_min <SPC> = <SPC> min ( cur_min <SPC> + <SPC> a , <SPC> a ) <NL>          min_sum <SPC> = <SPC> min ( min_sum , <SPC> cur_min ) <NL>          total <SPC> += <SPC> a <NL> <TAB> return <SPC> max ( max_sum , <SPC> total <SPC> - <SPC> min_sum ) <SPC> if <SPC> max_sum <SPC> >= <SPC> 0 <SPC> else <SPC> max_sum <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSumRangeQuery ( self , <SPC> nums , <SPC> requests ) : <NL> <NL> <TAB> def <SPC> addmod ( a , <SPC> b , <SPC> mod ) : <NL>          a <SPC> %= <SPC> mod <NL>          b <SPC> %= <SPC> mod <NL>          if <SPC> mod <SPC> - <SPC> a <SPC> <= <SPC> b : <NL>              b <SPC> -= <SPC> mod <NL>          return <SPC> a <SPC> + <SPC> b <NL> <NL> <TAB> def <SPC> mulmod ( a , <SPC> b , <SPC> mod ) : <NL>          a <SPC> %= <SPC> mod <NL>          b <SPC> %= <SPC> mod <NL>          if <SPC> a <SPC> < <SPC> b : <NL>              a , <SPC> b <SPC> = <SPC> b , <SPC> a <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> b <SPC> > <SPC> 0 : <NL>              if <SPC> b <SPC> % <SPC> 2 <SPC> == <SPC> 1 : <NL>                  result <SPC> = <SPC> addmod ( result , <SPC> a , <SPC> mod ) <NL>              a <SPC> = <SPC> addmod ( a , <SPC> a , <SPC> mod ) <NL>              b <SPC> //= <SPC> 2 <NL>          return <SPC> result <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( nums ) <NL> <TAB> for <SPC> start , <SPC> end <SPC> in <SPC> requests : <NL>          count [ start ] <SPC> += <SPC> 1 <NL>          if <SPC> end <SPC> + <SPC> 1 <SPC> < <SPC> len ( count ) : <NL>              count [ end <SPC> + <SPC> 1 ] <SPC> -= <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( count ) ) : <NL>          count [ i ] <SPC> += <SPC> count [ i <SPC> - <SPC> 1 ] <NL> <TAB> nums . sort ( ) <NL> <TAB> count . sort ( ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> ( num , <SPC> c ) <SPC> in <SPC> enumerate ( itertools . izip ( nums , <SPC> count ) ) : <NL> <NL>          result <SPC> = <SPC> ( result <SPC> + <SPC> num <SPC> * <SPC> c ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSumOfThreeSubarrays ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( nums ) <NL> <TAB> accu <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          accu . append ( accu [ - 1 ] <SPC> + <SPC> num ) <NL> <NL> <TAB> left_pos <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> total <SPC> = <SPC> accu [ k ] <SPC> - <SPC> accu [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k , <SPC> n ) : <NL>          if <SPC> accu [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> accu [ i <SPC> + <SPC> 1 <SPC> - <SPC> k ] <SPC> > <SPC> total : <NL>              left_pos [ i ] <SPC> = <SPC> i <SPC> + <SPC> 1 <SPC> - <SPC> k <NL>              total <SPC> = <SPC> accu [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> accu [ i <SPC> + <SPC> 1 <SPC> - <SPC> k ] <NL>          else : <NL>              left_pos [ i ] <SPC> = <SPC> left_pos [ i <SPC> - <SPC> 1 ] <NL> <NL> <TAB> right_pos <SPC> = <SPC> [ n <SPC> - <SPC> k ] <SPC> * <SPC> n <NL> <TAB> total <SPC> = <SPC> accu [ n ] <SPC> - <SPC> accu [ n <SPC> - <SPC> k ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( n <SPC> - <SPC> k ) ) : <NL>          if <SPC> accu [ i <SPC> + <SPC> k ] <SPC> - <SPC> accu [ i ] <SPC> > <SPC> total : <NL>              right_pos [ i ] <SPC> = <SPC> i <NL>              total <SPC> = <SPC> accu [ i <SPC> + <SPC> k ] <SPC> - <SPC> accu [ i ] <NL>          else : <NL>              right_pos [ i ] <SPC> = <SPC> right_pos [ i <SPC> + <SPC> 1 ] <NL> <NL> <TAB> result , <SPC> max_sum <SPC> = <SPC> [ ] , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k , <SPC> n <SPC> - <SPC> 2 <SPC> * <SPC> k <SPC> + <SPC> 1 ) : <NL>          left , <SPC> right <SPC> = <SPC> left_pos [ i <SPC> - <SPC> 1 ] , <SPC> right_pos [ i <SPC> + <SPC> k ] <NL>          total <SPC> = <SPC> ( <NL>              ( accu [ i <SPC> + <SPC> k ] <SPC> - <SPC> accu [ i ] ) <NL>              + <SPC> ( accu [ left <SPC> + <SPC> k ] <SPC> - <SPC> accu [ left ] ) <NL>              + <SPC> ( accu [ right <SPC> + <SPC> k ] <SPC> - <SPC> accu [ right ] ) <NL>          ) <NL>          if <SPC> total <SPC> > <SPC> max_sum : <NL>              max_sum <SPC> = <SPC> total <NL>              result <SPC> = <SPC> [ left , <SPC> i , <SPC> right ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSumTwoNoOverlap ( self , <SPC> A , <SPC> L , <SPC> M ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) ) : <NL>          A [ i ] <SPC> += <SPC> A [ i <SPC> - <SPC> 1 ] <NL> <TAB> result , <SPC> L_max , <SPC> M_max <SPC> = <SPC> A [ L <SPC> + <SPC> M <SPC> - <SPC> 1 ] , <SPC> A [ L <SPC> - <SPC> 1 ] , <SPC> A [ M <SPC> - <SPC> 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( L <SPC> + <SPC> M , <SPC> len ( A ) ) : <NL>          L_max <SPC> = <SPC> max ( L_max , <SPC> A [ i <SPC> - <SPC> M ] <SPC> - <SPC> A [ i <SPC> - <SPC> L <SPC> - <SPC> M ] ) <NL>          M_max <SPC> = <SPC> max ( M_max , <SPC> A [ i <SPC> - <SPC> L ] <SPC> - <SPC> A [ i <SPC> - <SPC> L <SPC> - <SPC> M ] ) <NL>          result <SPC> = <SPC> max ( result , <SPC> L_max <SPC> + <SPC> A [ i ] <SPC> - <SPC> A [ i <SPC> - <SPC> M ] , <SPC> M_max <SPC> + <SPC> A [ i ] <SPC> - <SPC> A [ i <SPC> - <SPC> L ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumSwap ( self , <SPC> num ) : <NL> <NL> <TAB> digits <SPC> = <SPC> list ( str ( num ) ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> max_idx <SPC> = <SPC> len ( digits ) <SPC> - <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( digits ) ) ) : <NL>          if <SPC> digits [ i ] <SPC> > <SPC> digits [ max_idx ] : <NL>              max_idx <SPC> = <SPC> i <NL>          elif <SPC> digits [ max_idx ] <SPC> > <SPC> digits [ i ] : <NL>              left , <SPC> right <SPC> = <SPC> i , <SPC> max_idx <NL> <TAB> digits [ left ] , <SPC> digits [ right ] <SPC> = <SPC> digits [ right ] , <SPC> digits [ left ] <NL> <TAB> return <SPC> int ( "" . join ( digits ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumUnits ( self , <SPC> boxTypes , <SPC> truckSize ) : <NL> <NL> <TAB> boxTypes . sort ( key = lambda <SPC> x : <SPC> x [ 1 ] , <SPC> reverse = True ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> box , <SPC> units <SPC> in <SPC> boxTypes : <NL>          if <SPC> truckSize <SPC> > <SPC> box : <NL>              truckSize <SPC> -= <SPC> box <NL>              result <SPC> += <SPC> box <SPC> * <SPC> units <NL>          else : <NL>              result <SPC> += <SPC> truckSize <SPC> * <SPC> units <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxVacationDays ( self , <SPC> flights , <SPC> days ) : <NL> <NL> <TAB> if <SPC> not <SPC> days <SPC> or <SPC> not <SPC> flights : <NL>          return <SPC> 0 <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( days ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> week <SPC> in <SPC> reversed ( xrange ( len ( days [ 0 ] ) ) ) : <NL>          for <SPC> cur_city <SPC> in <SPC> xrange ( len ( days ) ) : <NL>              dp [ week <SPC> % <SPC> 2 ] [ cur_city ] <SPC> = <SPC> ( <NL>                  days [ cur_city ] [ week ] <SPC> + <SPC> dp [ ( week <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ cur_city ] <NL>              ) <NL>              for <SPC> dest_city <SPC> in <SPC> xrange ( len ( days ) ) : <NL>                  if <SPC> flights [ cur_city ] [ dest_city ] <SPC> == <SPC> 1 : <NL>                      dp [ week <SPC> % <SPC> 2 ] [ cur_city ] <SPC> = <SPC> max ( <NL>                          dp [ week <SPC> % <SPC> 2 ] [ cur_city ] , <NL>                          days [ dest_city ] [ week ] <SPC> + <SPC> dp [ ( week <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ dest_city ] , <NL>                      ) <NL> <TAB> return <SPC> dp [ 0 ] [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> widthOfBinaryTree ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> i , <SPC> depth , <SPC> leftmosts ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> 0 <NL>          if <SPC> depth <SPC> >= <SPC> len ( leftmosts ) : <NL>              leftmosts . append ( i ) <NL>          return <SPC> max ( <NL>              i <SPC> - <SPC> leftmosts [ depth ] <SPC> + <SPC> 1 , <NL>              dfs ( node . left , <SPC> i <SPC> * <SPC> 2 , <SPC> depth <SPC> + <SPC> 1 , <SPC> leftmosts ) , <NL>              dfs ( node . right , <SPC> i <SPC> * <SPC> 2 <SPC> + <SPC> 1 , <SPC> depth <SPC> + <SPC> 1 , <SPC> leftmosts ) , <NL>          ) <NL> <NL> <TAB> leftmosts <SPC> = <SPC> [ ] <NL> <TAB> return <SPC> dfs ( root , <SPC> 1 , <SPC> 0 , <SPC> leftmosts ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxWidthRamp ( self , <SPC> A ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> s <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> A : <NL>          if <SPC> not <SPC> s <SPC> or <SPC> A [ s [ - 1 ] ] <SPC> > <SPC> A [ i ] : <NL>              s . append ( i ) <NL> <TAB> for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( A ) ) ) : <NL>          while <SPC> s <SPC> and <SPC> A [ s [ - 1 ] ] <SPC> <= <SPC> A [ j ] : <NL>              result <SPC> = <SPC> max ( result , <SPC> j <SPC> - <SPC> s . pop ( ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMaximumXOR ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 32 ) ) : <NL>          result <SPC> <<= <SPC> 1 <NL>          prefixes <SPC> = <SPC> set ( ) <NL>          for <SPC> n <SPC> in <SPC> nums : <NL>              prefixes . add ( n <SPC> >> <SPC> i ) <NL>          for <SPC> p <SPC> in <SPC> prefixes : <NL>              if <SPC> ( result <SPC> | <SPC> 1 ) <SPC> ^ <SPC> p <SPC> in <SPC> prefixes : <NL>                  result <SPC> += <SPC> 1 <NL>                  break <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Trie ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __root <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> num ) : <NL> <TAB> node <SPC> = <SPC> self . __root <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 32 ) ) : <NL>          curr <SPC> = <SPC> ( num <SPC> >> <SPC> i ) <SPC> & <SPC> 1 <NL>          if <SPC> curr <SPC> not <SPC> in <SPC> node : <NL>              node [ curr ] <SPC> = <SPC> { } <NL>          node <SPC> = <SPC> node [ curr ] <NL> <NL> <TAB> def <SPC> query ( self , <SPC> num ) : <NL> <TAB> if <SPC> not <SPC> self . __root : <NL>          return <SPC> - 1 <NL> <TAB> node , <SPC> result <SPC> = <SPC> self . __root , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 32 ) ) : <NL>          curr <SPC> = <SPC> ( num <SPC> >> <SPC> i ) <SPC> & <SPC> 1 <NL>          if <SPC> 1 <SPC> ^ <SPC> curr <SPC> in <SPC> node : <NL>              node <SPC> = <SPC> node [ 1 <SPC> ^ <SPC> curr ] <NL>              result <SPC> |= <SPC> 1 <SPC> << <SPC> i <NL>          else : <NL>              node <SPC> = <SPC> node [ curr ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximizeXor ( self , <SPC> nums , <SPC> queries ) : <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> queries <SPC> = <SPC> sorted ( enumerate ( queries ) , <SPC> key = lambda <SPC> x : <SPC> x [ 1 ] [ 1 ] ) <NL> <TAB> trie <SPC> = <SPC> Trie ( ) <NL> <TAB> result <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( queries ) <NL> <TAB> j <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> ( x , <SPC> m ) <SPC> in <SPC> queries : <NL>          while <SPC> j <SPC> < <SPC> len ( nums ) <SPC> and <SPC> nums [ j ] <SPC> <= <SPC> m : <NL>              trie . insert ( nums [ j ] ) <NL>              j <SPC> += <SPC> 1 <NL>          result [ i ] <SPC> = <SPC> trie . query ( x ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> trimMean ( self , <SPC> arr ) : <NL> <NL> <TAB> P <SPC> = <SPC> 20 <NL> <NL> <TAB> def <SPC> nth_element ( nums , <SPC> n , <SPC> left = 0 , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) : <NL>          def <SPC> tri_partition ( nums , <SPC> left , <SPC> right , <SPC> target , <SPC> compare ) : <NL>              mid <SPC> = <SPC> left <NL>              while <SPC> mid <SPC> <= <SPC> right : <NL>                  if <SPC> nums [ mid ] <SPC> == <SPC> target : <NL>                      mid <SPC> += <SPC> 1 <NL>                  elif <SPC> compare ( nums [ mid ] , <SPC> target ) : <NL>                      nums [ left ] , <SPC> nums [ mid ] <SPC> = <SPC> nums [ mid ] , <SPC> nums [ left ] <NL>                      left <SPC> += <SPC> 1 <NL>                      mid <SPC> += <SPC> 1 <NL>                  else : <NL>                      nums [ mid ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ mid ] <NL>                      right <SPC> -= <SPC> 1 <NL>              return <SPC> left , <SPC> right <NL> <NL>          right <SPC> = <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              pivot_left , <SPC> pivot_right <SPC> = <SPC> tri_partition ( <NL>                  nums , <SPC> left , <SPC> right , <SPC> nums [ pivot_idx ] , <SPC> compare <NL>              ) <NL>              if <SPC> pivot_left <SPC> <= <SPC> n <SPC> <= <SPC> pivot_right : <NL>                  return <NL>              elif <SPC> pivot_left <SPC> > <SPC> n : <NL>                  right <SPC> = <SPC> pivot_left <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> pivot_right <SPC> + <SPC> 1 <NL> <NL> <TAB> k <SPC> = <SPC> len ( arr ) <SPC> // <SPC> P <NL> <TAB> nth_element ( arr , <SPC> k <SPC> - <SPC> 1 ) <NL> <TAB> nth_element ( arr , <SPC> len ( arr ) <SPC> - <SPC> k , <SPC> left = k ) <NL> <TAB> return <SPC> float ( sum ( arr [ i ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( k , <SPC> len ( arr ) <SPC> - <SPC> k ) ) ) <SPC> / <SPC> ( len ( arr ) <SPC> - <SPC> 2 <SPC> * <SPC> k ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMedianSortedArrays ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> len1 , <SPC> len2 <SPC> = <SPC> len ( nums1 ) , <SPC> len ( nums2 ) <NL> <TAB> if <SPC> ( len1 <SPC> + <SPC> len2 ) <SPC> % <SPC> 2 <SPC> == <SPC> 1 : <NL>          return <SPC> self . getKth ( nums1 , <SPC> nums2 , <SPC> ( len1 <SPC> + <SPC> len2 ) <SPC> / <SPC> 2 <SPC> + <SPC> 1 ) <NL> <TAB> else : <NL>          return <SPC> ( <NL>              self . getKth ( nums1 , <SPC> nums2 , <SPC> ( len1 <SPC> + <SPC> len2 ) <SPC> / <SPC> 2 ) <NL>              + <SPC> self . getKth ( nums1 , <SPC> nums2 , <SPC> ( len1 <SPC> + <SPC> len2 ) <SPC> / <SPC> 2 <SPC> + <SPC> 1 ) <NL>          ) <SPC> * <SPC> 0.5 <NL> <NL> <TAB> def <SPC> getKth ( self , <SPC> A , <SPC> B , <SPC> k ) : <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( A ) , <SPC> len ( B ) <NL> <TAB> if <SPC> m <SPC> > <SPC> n : <NL>          return <SPC> self . getKth ( B , <SPC> A , <SPC> k ) <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> m <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> 0 <SPC> <= <SPC> k <SPC> - <SPC> 1 <SPC> - <SPC> mid <SPC> < <SPC> n <SPC> and <SPC> A [ mid ] <SPC> >= <SPC> B [ k <SPC> - <SPC> 1 <SPC> - <SPC> mid ] : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> Ai_minus_1 <SPC> = <SPC> A [ left <SPC> - <SPC> 1 ] <SPC> if <SPC> left <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <SPC> else <SPC> float ( "-inf" ) <NL> <TAB> Bj <SPC> = <SPC> B [ k <SPC> - <SPC> 1 <SPC> - <SPC> left ] <SPC> if <SPC> k <SPC> - <SPC> 1 <SPC> - <SPC> left <SPC> >= <SPC> 0 <SPC> else <SPC> float ( "-inf" ) <NL> <NL> <TAB> return <SPC> max ( Ai_minus_1 , <SPC> Bj ) <NL> <NL> <NL> class <SPC> Solution_Generic ( object ) : <NL> <TAB> def <SPC> findMedianSortedArrays ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> array <SPC> = <SPC> [ nums1 , <SPC> nums2 ] <NL> <TAB> total <SPC> = <SPC> sum ( len ( nums ) <SPC> for <SPC> nums <SPC> in <SPC> array ) <NL> <TAB> if <SPC> total <SPC> % <SPC> 2 <SPC> == <SPC> 1 : <NL>          return <SPC> self . getKth ( array , <SPC> total <SPC> // <SPC> 2 <SPC> + <SPC> 1 ) <NL> <TAB> else : <NL>          return <SPC> ( <NL>              self . getKth ( array , <SPC> total <SPC> // <SPC> 2 ) <SPC> + <SPC> self . getKth ( array , <SPC> total <SPC> // <SPC> 2 <SPC> + <SPC> 1 ) <NL>          ) <SPC> * <SPC> 0.5 <NL> <NL> <TAB> def <SPC> getKth ( self , <SPC> arrays , <SPC> k ) : <NL> <NL> <TAB> def <SPC> binary_search ( array , <SPC> left , <SPC> right , <SPC> target , <SPC> check ) : <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>              if <SPC> check ( array , <SPC> mid , <SPC> target ) : <NL>                  right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          return <SPC> left <NL> <NL> <TAB> def <SPC> check ( arrays , <SPC> num , <SPC> target ) : <NL>          res <SPC> = <SPC> 0 <NL>          for <SPC> array <SPC> in <SPC> arrays : <NL>              if <SPC> array : <NL>                  res <SPC> += <SPC> binary_search ( <NL>                      array , <SPC> 0 , <SPC> len ( array ) <SPC> - <NL>                      1 , <SPC> num , <SPC> lambda <SPC> array , <SPC> x , <SPC> y : <SPC> array [ x ] <SPC> > <SPC> y <NL>                  ) <NL>          return <SPC> res <SPC> >= <SPC> target <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> float ( "inf" ) , <SPC> float ( "-inf" ) <NL> <TAB> for <SPC> array <SPC> in <SPC> arrays : <NL>          if <SPC> array : <NL>              left <SPC> = <SPC> min ( left , <SPC> array [ 0 ] ) <NL>              right <SPC> = <SPC> max ( right , <SPC> array [ - 1 ] ) <NL> <TAB> return <SPC> binary_search ( arrays , <SPC> left , <SPC> right , <SPC> k , <SPC> check ) <NL> <NL> <NL> class <SPC> Solution_3 ( object ) : <NL> <TAB> def <SPC> findMedianSortedArrays ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> if <SPC> A <SPC> is <SPC> None <SPC> and <SPC> B <SPC> is <SPC> None : <NL>          return <SPC> - 1.0 <NL> <TAB> lenA <SPC> = <SPC> len ( A ) <NL> <TAB> lenB <SPC> = <SPC> len ( B ) <NL> <TAB> lenn <SPC> = <SPC> lenA <SPC> + <SPC> lenB <NL> <NL> <TAB> indexA , <SPC> indexB , <SPC> indexC <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> C <SPC> = <SPC> [ False <SPC> for <SPC> i <SPC> in <SPC> xrange ( lenn ) ] <NL> <TAB> while <SPC> indexA <SPC> < <SPC> lenA <SPC> and <SPC> indexB <SPC> < <SPC> lenB : <NL>          if <SPC> A [ indexA ] <SPC> < <SPC> B [ indexB ] : <NL>              C [ indexC ] <SPC> = <SPC> A [ indexA ] <NL>              indexC <SPC> += <SPC> 1 <NL>              indexA <SPC> += <SPC> 1 <NL>          else : <NL>              C [ indexC ] <SPC> = <SPC> B [ indexB ] <NL>              indexC <SPC> += <SPC> 1 <NL>              indexB <SPC> += <SPC> 1 <NL> <NL> <TAB> while <SPC> indexA <SPC> < <SPC> lenA : <NL>          C [ indexC ] <SPC> = <SPC> A [ indexA ] <NL>          indexC <SPC> += <SPC> 1 <NL>          indexA <SPC> += <SPC> 1 <NL> <NL> <TAB> while <SPC> indexB <SPC> < <SPC> lenB : <NL>          C [ indexC ] <SPC> = <SPC> B [ indexB ] <NL>          indexC <SPC> += <SPC> 1 <NL>          indexB <SPC> += <SPC> 1 <NL> <NL> <TAB> indexM1 <SPC> = <SPC> ( lenn <SPC> - <SPC> 1 ) <SPC> / <SPC> 2 <NL> <TAB> indexM2 <SPC> = <SPC> lenn <SPC> / <SPC> 2 <NL> <NL> <TAB> if <SPC> lenn <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>          return <SPC> ( C [ indexM1 ] <SPC> + <SPC> C [ indexM2 ] ) <SPC> / <SPC> 2.0 <NL> <TAB> else : <NL>          return <SPC> C [ indexM2 ] <SPC> / <SPC> 1.0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> minMeetingRooms ( self , <SPC> intervals ) : <NL> <TAB> result , <SPC> curr <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> line <SPC> = <SPC> [ x <SPC> for <SPC> i , <SPC> j <SPC> in <SPC> intervals <SPC> for <SPC> x <SPC> in <SPC> [ [ i , <SPC> 1 ] , <SPC> [ j , <SPC> - 1 ] ] ] <NL> <TAB> line . sort ( ) <NL> <TAB> for <SPC> _ , <SPC> num <SPC> in <SPC> line : <NL>          curr <SPC> += <SPC> num <NL>          result <SPC> = <SPC> max ( result , <SPC> curr ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> minMeetingRooms ( self , <SPC> intervals ) : <NL> <TAB> starts , <SPC> ends <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> for <SPC> start , <SPC> end <SPC> in <SPC> intervals : <NL>          starts . append ( start ) <NL>          ends . append ( end ) <NL> <NL> <TAB> starts . sort ( ) <NL> <TAB> ends . sort ( ) <NL> <NL> <TAB> s , <SPC> e <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> min_rooms , <SPC> cnt_rooms <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> s <SPC> < <SPC> len ( starts ) : <NL>          if <SPC> starts [ s ] <SPC> < <SPC> ends [ e ] : <NL>              cnt_rooms <SPC> += <SPC> 1 <NL> <NL>              min_rooms <SPC> = <SPC> max ( min_rooms , <SPC> cnt_rooms ) <NL>              s <SPC> += <SPC> 1 <NL>          else : <NL>              cnt_rooms <SPC> -= <SPC> 1 <NL>              e <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> min_rooms <NL> <NL> <NL> from <SPC> heapq <SPC> import <SPC> heappush , <SPC> heappop <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> minMeetingRooms ( self , <SPC> intervals ) : <NL> <NL> <TAB> if <SPC> not <SPC> intervals : <NL>          return <SPC> 0 <NL> <NL> <TAB> intervals . sort ( key = lambda <SPC> x : <SPC> x [ 0 ] ) <NL> <TAB> free_rooms <SPC> = <SPC> [ ] <NL> <NL> <TAB> heappush ( free_rooms , <SPC> intervals [ 0 ] [ 1 ] ) <NL> <TAB> for <SPC> interval <SPC> in <SPC> intervals [ 1 : ] : <NL>          if <SPC> free_rooms [ 0 ] <SPC> <= <SPC> interval [ 0 ] : <NL>              heappop ( free_rooms ) <NL> <NL>          heappush ( free_rooms , <SPC> interval [ 1 ] ) <NL> <NL> <TAB> return <SPC> len ( free_rooms ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canAttendMeetings ( self , <SPC> intervals ) : <NL> <NL> <TAB> intervals . sort ( key = lambda <SPC> x : <SPC> x [ 0 ] ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( intervals ) ) : <NL>          if <SPC> intervals [ i ] [ 0 ] <SPC> < <SPC> intervals [ i <SPC> - <SPC> 1 ] [ 1 ] : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minAvailableDuration ( self , <SPC> slots1 , <SPC> slots2 , <SPC> duration ) : <NL> <NL> <TAB> min_heap <SPC> = <SPC> list ( <NL>          filter ( lambda <SPC> slot : <SPC> slot [ 1 ] <SPC> - <SPC> slot [ 0 ] <SPC> >= <SPC> duration , <SPC> slots1 <SPC> + <SPC> slots2 ) <NL> <TAB> ) <NL> <TAB> heapq . heapify ( min_heap ) <NL> <TAB> while <SPC> len ( min_heap ) <SPC> > <SPC> 1 : <NL>          left <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          right <SPC> = <SPC> min_heap [ 0 ] <NL>          if <SPC> left [ 1 ] <SPC> - <SPC> right [ 0 ] <SPC> >= <SPC> duration : <NL>              return <SPC> [ right [ 0 ] , <SPC> right [ 0 ] <SPC> + <SPC> duration ] <NL> <TAB> return <SPC> [ ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minAvailableDuration ( self , <SPC> slots1 , <SPC> slots2 , <SPC> duration ) : <NL> <NL> <TAB> slots1 . sort ( key = lambda <SPC> x : <SPC> x [ 0 ] ) <NL> <TAB> slots2 . sort ( key = lambda <SPC> x : <SPC> x [ 0 ] ) <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( slots1 ) <SPC> and <SPC> j <SPC> < <SPC> len ( slots2 ) : <NL>          left <SPC> = <SPC> max ( slots1 [ i ] [ 0 ] , <SPC> slots2 [ j ] [ 0 ] ) <NL>          right <SPC> = <SPC> min ( slots1 [ i ] [ 1 ] , <SPC> slots2 [ j ] [ 1 ] ) <NL>          if <SPC> left <SPC> + <SPC> duration <SPC> <= <SPC> right : <NL>              return <SPC> [ left , <SPC> left <SPC> + <SPC> duration ] <NL>          if <SPC> slots1 [ i ] [ 1 ] <SPC> < <SPC> slots2 [ j ] [ 1 ] : <NL>              i <SPC> += <SPC> 1 <NL>          else : <NL>              j <SPC> += <SPC> 1 <NL> <TAB> return <SPC> [ ] <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> next = None ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mergeInBetween ( self , <SPC> list1 , <SPC> a , <SPC> b , <SPC> list2 ) : <NL> <NL> <TAB> prev_first , <SPC> last <SPC> = <SPC> None , <SPC> list1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( b ) : <NL>          if <SPC> i <SPC> == <SPC> a <SPC> - <SPC> 1 : <NL>              prev_first <SPC> = <SPC> last <NL>          last <SPC> = <SPC> last . next <NL> <TAB> prev_first . next <SPC> = <SPC> list2 <NL> <TAB> while <SPC> list2 . next : <NL>          list2 <SPC> = <SPC> list2 . next <NL> <TAB> list2 . next <SPC> = <SPC> last . next <NL> <TAB> last . next <SPC> = <SPC> None <NL> <TAB> return <SPC> list1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> merge ( self , <SPC> intervals ) : <NL> <NL> <TAB> intervals . sort ( ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> interval <SPC> in <SPC> intervals : <NL>          if <SPC> not <SPC> result <SPC> or <SPC> interval [ 0 ] <SPC> > <SPC> result [ - 1 ] [ 1 ] : <NL>              result . append ( interval ) <NL>          else : <NL>              result [ - 1 ] [ 1 ] <SPC> = <SPC> max ( result [ - 1 ] [ 1 ] , <SPC> interval [ 1 ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> self . next ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mergeKLists ( self , <SPC> lists ) : <NL> <NL> <TAB> def <SPC> mergeTwoLists ( l1 , <SPC> l2 ) : <NL>          curr <SPC> = <SPC> dummy <SPC> = <SPC> ListNode ( 0 ) <NL>          while <SPC> l1 <SPC> and <SPC> l2 : <NL>              if <SPC> l1 . val <SPC> < <SPC> l2 . val : <NL>                  curr . next <SPC> = <SPC> l1 <NL>                  l1 <SPC> = <SPC> l1 . next <NL>              else : <NL>                  curr . next <SPC> = <SPC> l2 <NL>                  l2 <SPC> = <SPC> l2 . next <NL>              curr <SPC> = <SPC> curr . next <NL>          curr . next <SPC> = <SPC> l1 <SPC> or <SPC> l2 <NL>          return <SPC> dummy . next <NL> <NL> <TAB> if <SPC> not <SPC> lists : <NL>          return <SPC> None <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( lists ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> right <SPC> > <SPC> 0 : <NL>          lists [ left ] <SPC> = <SPC> mergeTwoLists ( lists [ left ] , <SPC> lists [ right ] ) <NL>          left <SPC> += <SPC> 1 <NL>          right <SPC> -= <SPC> 1 <NL>          if <SPC> left <SPC> >= <SPC> right : <NL>              left <SPC> = <SPC> 0 <NL> <TAB> return <SPC> lists [ 0 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> mergeKLists ( self , <SPC> lists ) : <NL> <NL> <TAB> def <SPC> mergeTwoLists ( l1 , <SPC> l2 ) : <NL>          curr <SPC> = <SPC> dummy <SPC> = <SPC> ListNode ( 0 ) <NL>          while <SPC> l1 <SPC> and <SPC> l2 : <NL>              if <SPC> l1 . val <SPC> < <SPC> l2 . val : <NL>                  curr . next <SPC> = <SPC> l1 <NL>                  l1 <SPC> = <SPC> l1 . next <NL>              else : <NL>                  curr . next <SPC> = <SPC> l2 <NL>                  l2 <SPC> = <SPC> l2 . next <NL>              curr <SPC> = <SPC> curr . next <NL>          curr . next <SPC> = <SPC> l1 <SPC> or <SPC> l2 <NL>          return <SPC> dummy . next <NL> <NL> <TAB> def <SPC> mergeKListsHelper ( lists , <SPC> begin , <SPC> end ) : <NL>          if <SPC> begin <SPC> > <SPC> end : <NL>              return <SPC> None <NL>          if <SPC> begin <SPC> == <SPC> end : <NL>              return <SPC> lists [ begin ] <NL>          return <SPC> mergeTwoLists ( <NL>              mergeKListsHelper ( lists , <SPC> begin , <SPC> ( begin <SPC> + <SPC> end ) <SPC> / <SPC> 2 ) , <NL>              mergeKListsHelper ( lists , <SPC> ( begin <SPC> + <SPC> end ) <SPC> / <SPC> 2 <SPC> + <SPC> 1 , <SPC> end ) , <NL>          ) <NL> <NL> <TAB> return <SPC> mergeKListsHelper ( lists , <SPC> 0 , <SPC> len ( lists ) <SPC> - <SPC> 1 ) <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <NL> <TAB> def <SPC> mergeKLists ( self , <SPC> lists ) : <NL> <TAB> dummy <SPC> = <SPC> ListNode ( 0 ) <NL> <TAB> current <SPC> = <SPC> dummy <NL> <NL> <TAB> heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> sorted_list <SPC> in <SPC> lists : <NL>          if <SPC> sorted_list : <NL>              heapq . heappush ( heap , <SPC> ( sorted_list . val , <SPC> sorted_list ) ) <NL> <NL> <TAB> while <SPC> heap : <NL>          smallest <SPC> = <SPC> heapq . heappop ( heap ) [ 1 ] <NL>          current . next <SPC> = <SPC> smallest <NL>          current <SPC> = <SPC> current . next <NL>          if <SPC> smallest . next : <NL>              heapq . heappush ( heap , <SPC> ( smallest . next . val , <SPC> smallest . next ) ) <NL> <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> merge ( self , <SPC> A , <SPC> m , <SPC> B , <SPC> n ) : <NL> <TAB> last , <SPC> i , <SPC> j <SPC> = <SPC> m <SPC> + <SPC> n <SPC> - <SPC> 1 , <SPC> m <SPC> - <SPC> 1 , <SPC> n <SPC> - <SPC> 1 <NL> <NL> <TAB> while <SPC> i <SPC> >= <SPC> 0 <SPC> and <SPC> j <SPC> >= <SPC> 0 : <NL>          if <SPC> A [ i ] <SPC> > <SPC> B [ j ] : <NL>              A [ last ] <SPC> = <SPC> A [ i ] <NL>              last , <SPC> i <SPC> = <SPC> last <SPC> - <SPC> 1 , <SPC> i <SPC> - <SPC> 1 <NL>          else : <NL>              A [ last ] <SPC> = <SPC> B [ j ] <NL>              last , <SPC> j <SPC> = <SPC> last <SPC> - <SPC> 1 , <SPC> j <SPC> - <SPC> 1 <NL> <NL> <TAB> while <SPC> j <SPC> >= <SPC> 0 : <NL>          A [ last ] <SPC> = <SPC> B [ j ] <NL>          last , <SPC> j <SPC> = <SPC> last <SPC> - <SPC> 1 , <SPC> j <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mergeAlternately ( self , <SPC> word1 , <SPC> word2 ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( word1 ) <SPC> or <SPC> i <SPC> < <SPC> len ( word2 ) : <NL>          if <SPC> i <SPC> < <SPC> len ( word1 ) : <NL>              result . append ( word1 [ i ] ) <NL>          if <SPC> i <SPC> < <SPC> len ( word2 ) : <NL>              result . append ( word2 [ i ] ) <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mergeTrees ( self , <SPC> t1 , <SPC> t2 ) : <NL> <NL> <TAB> if <SPC> t1 <SPC> is <SPC> None : <NL>          return <SPC> t2 <NL> <TAB> if <SPC> t2 <SPC> is <SPC> None : <NL>          return <SPC> t1 <NL> <TAB> t1 . val <SPC> += <SPC> t2 . val <NL> <TAB> t1 . left <SPC> = <SPC> self . mergeTrees ( t1 . left , <SPC> t2 . left ) <NL> <TAB> t1 . right <SPC> = <SPC> self . mergeTrees ( t1 . right , <SPC> t2 . right ) <NL> <TAB> return <SPC> t1 <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> self . next ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mergeTwoLists ( self , <SPC> l1 , <SPC> l2 ) : <NL> <NL> <TAB> curr <SPC> = <SPC> dummy <SPC> = <SPC> ListNode ( 0 ) <NL> <TAB> while <SPC> l1 <SPC> and <SPC> l2 : <NL>          if <SPC> l1 . val <SPC> < <SPC> l2 . val : <NL>              curr . next <SPC> = <SPC> l1 <NL>              l1 <SPC> = <SPC> l1 . next <NL>          else : <NL>              curr . next <SPC> = <SPC> l2 <NL>              l2 <SPC> = <SPC> l2 . next <NL>          curr <SPC> = <SPC> curr . next <NL> <TAB> curr . next <SPC> = <SPC> l1 <SPC> or <SPC> l2 <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> middleNode ( self , <SPC> head ) : <NL> <NL> <TAB> slow , <SPC> fast <SPC> = <SPC> head , <SPC> head <NL> <TAB> while <SPC> fast <SPC> and <SPC> fast . next : <NL>          slow , <SPC> fast <SPC> = <SPC> slow . next , <SPC> fast . next . next <NL> <TAB> return <SPC> slow <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minCostClimbingStairs ( self , <SPC> cost ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 3 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( cost ) ) ) : <NL>          dp [ i <SPC> % <SPC> 3 ] <SPC> = <SPC> cost [ i ] <SPC> + <SPC> min ( dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 3 ] , <SPC> dp [ ( i <SPC> + <SPC> 2 ) <SPC> % <SPC> 3 ] ) <NL> <TAB> return <SPC> min ( dp [ 0 ] , <SPC> dp [ 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minCostConnectPoints ( self , <SPC> points ) : <NL> <NL> <TAB> result , <SPC> u <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> dist <SPC> = <SPC> [ float ( "inf" ) ] <SPC> * <SPC> len ( points ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( len ( points ) <SPC> - <SPC> 1 ) : <NL>          x0 , <SPC> y0 <SPC> = <SPC> points [ u ] <NL>          lookup . add ( u ) <NL>          for <SPC> v , <SPC> ( x , <SPC> y ) <SPC> in <SPC> enumerate ( points ) : <NL>              if <SPC> v <SPC> in <SPC> lookup : <NL>                  continue <NL>              dist [ v ] <SPC> = <SPC> min ( dist [ v ] , <SPC> abs ( x <SPC> - <SPC> x0 ) <SPC> + <SPC> abs ( y <SPC> - <SPC> y0 ) ) <NL>          val , <SPC> u <SPC> = <SPC> min ( ( val , <SPC> v ) <SPC> for <SPC> v , <SPC> val <SPC> in <SPC> enumerate ( dist ) ) <NL>          dist [ u ] <SPC> = <SPC> float ( "inf" ) <NL>          result <SPC> += <SPC> val <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . rank <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          stk . append ( x ) <NL>          x <SPC> = <SPC> self . set [ x ] <NL> <TAB> while <SPC> stk : <NL>          self . set [ stk . pop ( ) ] <SPC> = <SPC> x <NL> <TAB> return <SPC> x <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> if <SPC> self . rank [ x_root ] <SPC> < <SPC> self . rank [ y_root ] : <NL>          self . set [ x_root ] <SPC> = <SPC> y_root <NL> <TAB> elif <SPC> self . rank [ x_root ] <SPC> > <SPC> self . rank [ y_root ] : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL> <TAB> else : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL>          self . rank [ x_root ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minCostConnectPoints ( self , <SPC> points ) : <NL> <NL> <TAB> edges <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> u <SPC> in <SPC> xrange ( len ( points ) ) : <NL>          for <SPC> v <SPC> in <SPC> xrange ( u <SPC> + <SPC> 1 , <SPC> len ( points ) ) : <NL>              edges . append ( <NL>                  ( <NL>                      u , <NL>                      v , <NL>                      abs ( points [ v ] [ 0 ] <SPC> - <SPC> points [ u ] [ 0 ] ) <NL>                      + <SPC> abs ( points [ v ] [ 1 ] <SPC> - <SPC> points [ u ] [ 1 ] ) , <NL>                  ) <NL>              ) <NL> <TAB> edges . sort ( key = lambda <SPC> x : <SPC> x [ 2 ] ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( points ) ) <NL> <TAB> for <SPC> u , <SPC> v , <SPC> val <SPC> in <SPC> edges : <NL>          if <SPC> union_find . union_set ( u , <SPC> v ) : <NL>              result <SPC> += <SPC> val <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> MinStack ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . min <SPC> = <SPC> None <NL> <TAB> self . stack <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <TAB> if <SPC> not <SPC> self . stack : <NL>          self . stack . append ( 0 ) <NL>          self . min <SPC> = <SPC> x <NL> <TAB> else : <NL>          self . stack . append ( x <SPC> - <SPC> self . min ) <NL>          if <SPC> x <SPC> < <SPC> self . min : <NL>              self . min <SPC> = <SPC> x <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <TAB> x <SPC> = <SPC> self . stack . pop ( ) <NL> <TAB> if <SPC> x <SPC> < <SPC> 0 : <NL>          self . min <SPC> = <SPC> self . min <SPC> - <SPC> x <NL> <NL> <TAB> def <SPC> top ( self ) : <NL> <TAB> x <SPC> = <SPC> self . stack [ - 1 ] <NL> <TAB> if <SPC> x <SPC> > <SPC> 0 : <NL>          return <SPC> x <SPC> + <SPC> self . min <NL> <TAB> else : <NL>          return <SPC> self . min <NL> <NL> <TAB> def <SPC> getMin ( self ) : <NL> <TAB> return <SPC> self . min <NL> <NL> <NL> class <SPC> MinStack2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . stack , <SPC> self . minStack <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <TAB> self . stack . append ( x ) <NL> <TAB> if <SPC> len ( self . minStack ) : <NL>          if <SPC> x <SPC> < <SPC> self . minStack [ - 1 ] [ 0 ] : <NL>              self . minStack . append ( [ x , <SPC> 1 ] ) <NL>          elif <SPC> x <SPC> == <SPC> self . minStack [ - 1 ] [ 0 ] : <NL>              self . minStack [ - 1 ] [ 1 ] <SPC> += <SPC> 1 <NL> <TAB> else : <NL>          self . minStack . append ( [ x , <SPC> 1 ] ) <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <TAB> x <SPC> = <SPC> self . stack . pop ( ) <NL> <TAB> if <SPC> x <SPC> == <SPC> self . minStack [ - 1 ] [ 0 ] : <NL>          self . minStack [ - 1 ] [ 1 ] <SPC> -= <SPC> 1 <NL>          if <SPC> self . minStack [ - 1 ] [ 1 ] <SPC> == <SPC> 0 : <NL>              self . minStack . pop ( ) <NL> <NL> <TAB> def <SPC> top ( self ) : <NL> <TAB> return <SPC> self . stack [ - 1 ] <NL> <NL> <TAB> def <SPC> getMin ( self ) : <NL> <TAB> return <SPC> self . minStack [ - 1 ] [ 0 ] <NL> <NL> <NL> class <SPC> MinStack3 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . stack <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> push ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . stack : <NL>          current_min <SPC> = <SPC> min ( x , <SPC> self . stack [ - 1 ] [ 0 ] ) <NL>          self . stack . append ( ( current_min , <SPC> x ) ) <NL> <TAB> else : <NL>          self . stack . append ( ( x , <SPC> x ) ) <NL> <NL> <TAB> def <SPC> pop ( self ) : <NL> <TAB> return <SPC> self . stack . pop ( ) [ 1 ] <NL> <NL> <TAB> def <SPC> top ( self ) : <NL> <TAB> return <SPC> self . stack [ - 1 ] [ 1 ] <NL> <NL> <TAB> def <SPC> getMin ( self ) : <NL> <TAB> return <SPC> self . stack [ - 1 ] [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> updateBoard ( self , <SPC> board , <SPC> click ) : <NL> <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ click ] ) <NL> <TAB> while <SPC> q : <NL>          row , <SPC> col <SPC> = <SPC> q . popleft ( ) <NL>          if <SPC> board [ row ] [ col ] <SPC> == <SPC> "M" : <NL>              board [ row ] [ col ] <SPC> = <SPC> "X" <NL>          else : <NL>              count <SPC> = <SPC> 0 <NL>              for <SPC> i <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) : <NL>                  for <SPC> j <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) : <NL>                      if <SPC> i <SPC> == <SPC> 0 <SPC> and <SPC> j <SPC> == <SPC> 0 : <NL>                          continue <NL>                      r , <SPC> c <SPC> = <SPC> row <SPC> + <SPC> i , <SPC> col <SPC> + <SPC> j <NL>                      if <SPC> not <SPC> ( 0 <SPC> <= <SPC> r <SPC> < <SPC> len ( board ) ) <SPC> or <SPC> not <SPC> ( 0 <SPC> <= <SPC> c <SPC> < <SPC> len ( board [ r ] ) ) : <NL>                          continue <NL>                      if <SPC> board [ r ] [ c ] <SPC> == <SPC> "M" <SPC> or <SPC> board [ r ] [ c ] <SPC> == <SPC> "X" : <NL>                          count <SPC> += <SPC> 1 <NL> <NL>              if <SPC> count : <NL>                  board [ row ] [ col ] <SPC> = <SPC> chr ( count <SPC> + <SPC> ord ( "0" ) ) <NL>              else : <NL>                  board [ row ] [ col ] <SPC> = <SPC> "B" <NL>                  for <SPC> i <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) : <NL>                      for <SPC> j <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) : <NL>                          if <SPC> i <SPC> == <SPC> 0 <SPC> and <SPC> j <SPC> == <SPC> 0 : <NL>                              continue <NL>                          r , <SPC> c <SPC> = <SPC> row <SPC> + <SPC> i , <SPC> col <SPC> + <SPC> j <NL>                          if <SPC> not <SPC> ( 0 <SPC> <= <SPC> r <SPC> < <SPC> len ( board ) ) <SPC> or <SPC> not <SPC> ( <NL>                              0 <SPC> <= <SPC> c <SPC> < <SPC> len ( board [ r ] ) <NL>                          ) : <NL>                              continue <NL>                          if <SPC> board [ r ] [ c ] <SPC> == <SPC> "E" : <NL>                              q . append ( ( r , <SPC> c ) ) <NL>                              board [ r ] [ c ] <SPC> = <SPC> " " <NL> <NL> <TAB> return <SPC> board <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> updateBoard ( self , <SPC> board , <SPC> click ) : <NL> <NL> <TAB> row , <SPC> col <SPC> = <SPC> click [ 0 ] , <SPC> click [ 1 ] <NL> <TAB> if <SPC> board [ row ] [ col ] <SPC> == <SPC> "M" : <NL>          board [ row ] [ col ] <SPC> = <SPC> "X" <NL> <TAB> else : <NL>          count <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) : <NL>                  if <SPC> i <SPC> == <SPC> 0 <SPC> and <SPC> j <SPC> == <SPC> 0 : <NL>                      continue <NL>                  r , <SPC> c <SPC> = <SPC> row <SPC> + <SPC> i , <SPC> col <SPC> + <SPC> j <NL>                  if <SPC> not <SPC> ( 0 <SPC> <= <SPC> r <SPC> < <SPC> len ( board ) ) <SPC> or <SPC> not <SPC> ( 0 <SPC> <= <SPC> c <SPC> < <SPC> len ( board [ r ] ) ) : <NL>                      continue <NL>                  if <SPC> board [ r ] [ c ] <SPC> == <SPC> "M" <SPC> or <SPC> board [ r ] [ c ] <SPC> == <SPC> "X" : <NL>                      count <SPC> += <SPC> 1 <NL> <NL>          if <SPC> count : <NL>              board [ row ] [ col ] <SPC> = <SPC> chr ( count <SPC> + <SPC> ord ( "0" ) ) <NL>          else : <NL>              board [ row ] [ col ] <SPC> = <SPC> "B" <NL>              for <SPC> i <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) : <NL>                  for <SPC> j <SPC> in <SPC> xrange ( - 1 , <SPC> 2 ) : <NL>                      if <SPC> i <SPC> == <SPC> 0 <SPC> and <SPC> j <SPC> == <SPC> 0 : <NL>                          continue <NL>                      r , <SPC> c <SPC> = <SPC> row <SPC> + <SPC> i , <SPC> col <SPC> + <SPC> j <NL>                      if <SPC> not <SPC> ( 0 <SPC> <= <SPC> r <SPC> < <SPC> len ( board ) ) <SPC> or <SPC> not <SPC> ( 0 <SPC> <= <SPC> c <SPC> < <SPC> len ( board [ r ] ) ) : <NL>                          continue <NL>                      if <SPC> board [ r ] [ c ] <SPC> == <SPC> "E" : <NL>                          self . updateBoard ( board , <SPC> ( r , <SPC> c ) ) <NL> <NL> <TAB> return <SPC> board <NL> <NL> <NL> class <SPC> NestedInteger ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> value = None ) : <NL> <NL> <TAB> def <SPC> isInteger ( self ) : <NL> <NL> <TAB> def <SPC> add ( self , <SPC> elem ) : <NL> <NL> <TAB> def <SPC> setInteger ( self , <SPC> value ) : <NL> <NL> <TAB> def <SPC> getInteger ( self ) : <NL> <NL> <TAB> def <SPC> getList ( self ) : <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> deserialize ( self , <SPC> s ) : <NL> <TAB> if <SPC> not <SPC> s : <NL>          return <SPC> NestedInteger ( ) <NL> <NL> <TAB> if <SPC> s [ 0 ] <SPC> != <SPC> "[" : <NL>          return <SPC> NestedInteger ( int ( s ) ) <NL> <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> s [ j ] <SPC> == <SPC> "[" : <NL>              stk <SPC> += <SPC> ( NestedInteger ( ) , ) <NL>              i <SPC> = <SPC> j <SPC> + <SPC> 1 <NL>          elif <SPC> s [ j ] <SPC> in <SPC> ",]" : <NL>              if <SPC> s [ j <SPC> - <SPC> 1 ] . isdigit ( ) : <NL>                  stk [ - 1 ] . add ( NestedInteger ( int ( s [ i : j ] ) ) ) <NL>              if <SPC> s [ j ] <SPC> == <SPC> "]" <SPC> and <SPC> len ( stk ) <SPC> > <SPC> 1 : <NL>                  cur <SPC> = <SPC> stk [ - 1 ] <NL>                  stk . pop ( ) <NL>                  stk [ - 1 ] . add ( cur ) <NL>              i <SPC> = <SPC> j <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> stk [ - 1 ] <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumDeviation ( self , <SPC> nums ) : <NL> <NL> <TAB> max_heap <SPC> = <SPC> [ - num <SPC> * <SPC> 2 <SPC> if <SPC> num <SPC> % <SPC> 2 <SPC> else <SPC> - num <SPC> for <SPC> num <SPC> in <SPC> nums ] <NL> <TAB> heapq . heapify ( max_heap ) <NL> <TAB> min_elem <SPC> = <SPC> - max ( max_heap ) <NL> <TAB> result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> while <SPC> len ( max_heap ) <SPC> == <SPC> len ( nums ) : <NL>          num <SPC> = <SPC> - heapq . heappop ( max_heap ) <NL>          result <SPC> = <SPC> min ( result , <SPC> num <SPC> - <SPC> min_elem ) <NL>          if <SPC> not <SPC> num <SPC> % <SPC> 2 : <NL>              min_elem <SPC> = <SPC> min ( min_elem , <SPC> num <SPC> // <SPC> 2 ) <NL>              heapq . heappush ( max_heap , <SPC> - num <SPC> // <SPC> 2 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumHammingDistance ( self , <SPC> source , <SPC> target , <SPC> allowedSwaps ) : <NL> <NL> <TAB> def <SPC> iter_flood_fill ( adj , <SPC> node , <SPC> lookup , <SPC> idxs ) : <NL>          stk <SPC> = <SPC> [ node ] <NL>          while <SPC> stk : <NL>              node <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> node <SPC> in <SPC> lookup : <NL>                  continue <NL>              lookup . add ( node ) <NL>              idxs . append ( node ) <NL>              for <SPC> child <SPC> in <SPC> adj [ node ] : <NL>                  stk . append ( child ) <NL> <NL> <TAB> adj <SPC> = <SPC> [ set ( ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( source ) ) ] <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> allowedSwaps : <NL>          adj [ i ] . add ( j ) <NL>          adj [ j ] . add ( i ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( source ) ) : <NL>          if <SPC> i <SPC> in <SPC> lookup : <NL>              continue <NL>          idxs <SPC> = <SPC> [ ] <NL>          iter_flood_fill ( adj , <SPC> i , <SPC> lookup , <SPC> idxs ) <NL>          source_cnt <SPC> = <SPC> collections . Counter ( [ source [ i ] <SPC> for <SPC> i <SPC> in <SPC> idxs ] ) <NL>          target_cnt <SPC> = <SPC> collections . Counter ( [ target [ i ] <SPC> for <SPC> i <SPC> in <SPC> idxs ] ) <NL>          diff <SPC> = <SPC> source_cnt <SPC> - <SPC> target_cnt <NL>          result <SPC> += <SPC> sum ( diff . itervalues ( ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . rank <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          stk . append ( x ) <NL>          x <SPC> = <SPC> self . set [ x ] <NL> <TAB> while <SPC> stk : <NL>          self . set [ stk . pop ( ) ] <SPC> = <SPC> x <NL> <TAB> return <SPC> x <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> if <SPC> self . rank [ x_root ] <SPC> < <SPC> self . rank [ y_root ] : <NL>          self . set [ x_root ] <SPC> = <SPC> y_root <NL> <TAB> elif <SPC> self . rank [ x_root ] <SPC> > <SPC> self . rank [ y_root ] : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL> <TAB> else : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL>          self . rank [ x_root ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minimumHammingDistance ( self , <SPC> source , <SPC> target , <SPC> allowedSwaps ) : <NL> <NL> <TAB> uf <SPC> = <SPC> UnionFind ( len ( source ) ) <NL> <TAB> for <SPC> x , <SPC> y <SPC> in <SPC> allowedSwaps : <NL>          uf . union_set ( x , <SPC> y ) <NL> <TAB> groups <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( source ) ) : <NL>          groups [ uf . find_set ( i ) ] . add ( i ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> idxs <SPC> in <SPC> groups . itervalues ( ) : <NL>          source_cnt <SPC> = <SPC> collections . Counter ( [ source [ i ] <SPC> for <SPC> i <SPC> in <SPC> idxs ] ) <NL>          target_cnt <SPC> = <SPC> collections . Counter ( [ target [ i ] <SPC> for <SPC> i <SPC> in <SPC> idxs ] ) <NL>          diff <SPC> = <SPC> source_cnt <SPC> - <SPC> target_cnt <NL>          result <SPC> += <SPC> sum ( diff . itervalues ( ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minMalwareSpread ( self , <SPC> graph , <SPC> initial ) : <NL> <NL> <TAB> initial_set <SPC> = <SPC> set ( initial ) <NL> <TAB> clean <SPC> = <SPC> [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( graph ) ) <SPC> if <SPC> i <SPC> not <SPC> in <SPC> initial_set ] <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( graph ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( clean ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( clean ) ) : <NL>              if <SPC> graph [ clean [ i ] ] [ clean [ j ] ] <SPC> == <SPC> 1 : <NL>                  union_find . union_set ( clean [ i ] , <SPC> clean [ j ] ) <NL> <TAB> union_size <SPC> = <SPC> collections . Counter ( <NL>          union_find . find_set ( i ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( graph ) ) <NL> <TAB> ) <NL> <NL> <TAB> shared_union <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> i <SPC> in <SPC> initial : <NL>          for <SPC> j <SPC> in <SPC> clean : <NL>              if <SPC> graph [ i ] [ j ] <SPC> == <SPC> 1 : <NL>                  x <SPC> = <SPC> union_find . find_set ( j ) <NL>                  shared_union [ x ] . add ( i ) <NL> <NL> <TAB> result , <SPC> total <SPC> = <SPC> float ( "inf" ) , <SPC> float ( "-inf" ) <NL> <TAB> for <SPC> i <SPC> in <SPC> initial : <NL>          lookup <SPC> = <SPC> set ( ) <NL>          curr <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> clean : <NL>              if <SPC> graph [ i ] [ j ] <SPC> == <SPC> 1 : <NL>                  x <SPC> = <SPC> union_find . find_set ( j ) <NL>                  if <SPC> len ( shared_union [ x ] ) <SPC> == <SPC> 1 <SPC> and <SPC> x <SPC> not <SPC> in <SPC> lookup : <NL>                      curr <SPC> += <SPC> union_size [ x ] <NL>                      lookup . add ( x ) <NL>          if <SPC> curr <SPC> > <SPC> total <SPC> or <SPC> ( curr <SPC> == <SPC> total <SPC> and <SPC> i <SPC> < <SPC> result ) : <NL>              total <SPC> = <SPC> curr <NL>              result <SPC> = <SPC> i <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minMalwareSpread ( self , <SPC> graph , <SPC> initial ) : <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( graph ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( graph ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( graph ) ) : <NL>              if <SPC> graph [ i ] [ j ] <SPC> == <SPC> 1 : <NL>                  union_find . union_set ( i , <SPC> j ) <NL> <TAB> union_size <SPC> = <SPC> collections . Counter ( <NL>          union_find . find_set ( i ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( graph ) ) <NL> <TAB> ) <NL> <TAB> malware_count <SPC> = <SPC> collections . Counter ( <NL>          union_find . find_set ( i ) <SPC> for <SPC> i <SPC> in <SPC> initial ) <NL> <TAB> return <SPC> min ( <NL>          initial , <NL>          key = lambda <SPC> x : <SPC> [ <NL>              malware_count [ union_find . find_set ( x ) ] <SPC> > <SPC> 1 , <NL>              - union_size [ union_find . find_set ( x ) ] , <NL>              x , <NL>          ] , <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minmaxGasDist ( self , <SPC> stations , <SPC> K ) : <NL> <NL> <TAB> def <SPC> possible ( stations , <SPC> K , <SPC> guess ) : <NL>          return <SPC> ( <NL>              sum ( <NL>                  int ( ( stations [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> stations [ i ] ) <SPC> / <SPC> guess ) <NL>                  for <SPC> i <SPC> in <SPC> xrange ( len ( stations ) <SPC> - <SPC> 1 ) <NL>              ) <NL>              <= <SPC> K <NL>          ) <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> 10 <SPC> ** <SPC> 8 <NL> <TAB> while <SPC> right <SPC> - <SPC> left <SPC> > <SPC> 1e-6 : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2.0 <NL>          if <SPC> possible ( mid ) : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <NL> <TAB> return <SPC> left <NL> <NL> <NL> import <SPC> math <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimizeError ( self , <SPC> prices , <SPC> target ) : <NL> <NL> <TAB> def <SPC> kthElement ( nums , <SPC> k , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) : <NL>          def <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare ) : <NL>              new_pivot_idx <SPC> = <SPC> left <NL>              nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>                  if <SPC> compare ( nums [ i ] , <SPC> nums [ right ] ) : <NL>                      nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                      new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>              nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>              return <SPC> new_pivot_idx <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> PartitionAroundPivot ( <NL>                  left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare <NL>              ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> k : <NL>                  return <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> k : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> errors <SPC> = <SPC> [ ] <NL> <TAB> lower , <SPC> upper <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> p <SPC> in <SPC> enumerate ( map ( float , <SPC> prices ) ) : <NL>          lower <SPC> += <SPC> int ( math . floor ( p ) ) <NL>          upper <SPC> += <SPC> int ( math . ceil ( p ) ) <NL>          if <SPC> p <SPC> != <SPC> math . floor ( p ) : <NL>              errors . append ( p <SPC> - <SPC> math . floor ( p ) ) <NL> <TAB> if <SPC> not <SPC> lower <SPC> <= <SPC> target <SPC> <= <SPC> upper : <NL>          return <SPC> "-1" <NL> <NL> <TAB> lower_round_count <SPC> = <SPC> upper <SPC> - <SPC> target <NL> <TAB> kthElement ( errors , <SPC> lower_round_count ) <NL> <TAB> result <SPC> = <SPC> 0.0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( errors ) ) : <NL>          if <SPC> i <SPC> < <SPC> lower_round_count : <NL>              result <SPC> += <SPC> errors [ i ] <NL>          else : <NL>              result <SPC> += <SPC> 1.0 <SPC> - <SPC> errors [ i ] <NL> <TAB> return <SPC> "{:.3f}" . format ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getMinimumDifference ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> inorderTraversal ( root , <SPC> prev , <SPC> result ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> ( result , <SPC> prev ) <NL> <NL>          result , <SPC> prev <SPC> = <SPC> inorderTraversal ( root . left , <SPC> prev , <SPC> result ) <NL>          if <SPC> prev : <NL>              result <SPC> = <SPC> min ( result , <SPC> root . val <SPC> - <SPC> prev . val ) <NL>          return <SPC> inorderTraversal ( root . right , <SPC> root , <SPC> result ) <NL> <NL> <TAB> return <SPC> inorderTraversal ( root , <SPC> None , <SPC> float ( "inf" ) ) [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumAbsDifference ( self , <SPC> arr ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> min_diff <SPC> = <SPC> float ( "inf" ) <NL> <TAB> arr . sort ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( arr ) <SPC> - <SPC> 1 ) : <NL>          diff <SPC> = <SPC> arr [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> arr [ i ] <NL>          if <SPC> diff <SPC> < <SPC> min_diff : <NL>              min_diff <SPC> = <SPC> diff <NL>              result <SPC> = <SPC> [ [ arr [ i ] , <SPC> arr [ i <SPC> + <SPC> 1 ] ] ] <NL>          elif <SPC> diff <SPC> == <SPC> min_diff : <NL>              result . append ( [ arr [ i ] , <SPC> arr [ i <SPC> + <SPC> 1 ] ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minAddToMakeValid ( self , <SPC> S ) : <NL> <NL> <TAB> add , <SPC> bal , <SPC> = <SPC> ( <NL>          0 , <NL>          0 , <NL> <TAB> ) <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          bal <SPC> += <SPC> 1 <SPC> if <SPC> c <SPC> == <SPC> "(" <SPC> else <SPC> - 1 <NL>          if <SPC> bal <SPC> == <SPC> - 1 : <NL>              add <SPC> += <SPC> 1 <NL>              bal <SPC> += <SPC> 1 <NL> <TAB> return <SPC> add <SPC> + <SPC> bal <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minMoves ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> moves ( i , <SPC> j ) : <NL>          return <SPC> prefix [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ i ] <NL> <NL> <TAB> idxs <SPC> = <SPC> [ i <SPC> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( nums ) <SPC> if <SPC> x ] <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( idxs ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( idxs ) ) : <NL>          prefix [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> prefix [ i ] <SPC> + <SPC> idxs [ i ] <NL> <TAB> result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( idxs ) <SPC> - <SPC> k <SPC> + <SPC> 1 ) : <NL>          result <SPC> = <SPC> min ( <NL>              result , <SPC> - moves ( i , <SPC> i <SPC> + <SPC> k <SPC> // <SPC> 2 <SPC> - <SPC> 1 ) <SPC> + <NL>              moves ( i <SPC> + <SPC> ( k <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 , <SPC> i <SPC> + <SPC> k <SPC> - <SPC> 1 ) <NL>          ) <NL> <TAB> result <SPC> -= <SPC> ( k <SPC> // <SPC> 2 ) <SPC> * <SPC> ( <NL>          ( k <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 <NL> <TAB> ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minAreaFreeRect ( self , <SPC> points ) : <NL> <NL> <TAB> points . sort ( ) <NL> <TAB> points <SPC> = <SPC> [ complex ( * z ) <SPC> for <SPC> z <SPC> in <SPC> points ] <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> P , <SPC> Q <SPC> in <SPC> itertools . combinations ( points , <SPC> 2 ) : <NL>          lookup [ P <SPC> - <SPC> Q ] . append ( ( P <SPC> + <SPC> Q ) <SPC> / <SPC> 2 ) <NL> <NL> <TAB> result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> A , <SPC> candidates <SPC> in <SPC> lookup . iteritems ( ) : <NL>          for <SPC> P , <SPC> Q <SPC> in <SPC> itertools . combinations ( candidates , <SPC> 2 ) : <NL>              if <SPC> A . real <SPC> * <SPC> ( P <SPC> - <SPC> Q ) . real <SPC> + <SPC> A . imag <SPC> * <SPC> ( P <SPC> - <SPC> Q ) . imag <SPC> == <SPC> 0.0 : <NL>                  result <SPC> = <SPC> min ( result , <SPC> abs ( A ) <SPC> * <SPC> abs ( P <SPC> - <SPC> Q ) ) <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> < <SPC> float ( "inf" ) <SPC> else <SPC> 0.0 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minAreaRect ( self , <SPC> points ) : <NL> <NL> <TAB> nx <SPC> = <SPC> len ( set ( x <SPC> for <SPC> x , <SPC> y <SPC> in <SPC> points ) ) <NL> <TAB> ny <SPC> = <SPC> len ( set ( y <SPC> for <SPC> x , <SPC> y <SPC> in <SPC> points ) ) <NL> <NL> <TAB> p <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> if <SPC> nx <SPC> > <SPC> ny : <NL>          for <SPC> x , <SPC> y <SPC> in <SPC> points : <NL>              p [ x ] . append ( y ) <NL> <TAB> else : <NL>          for <SPC> x , <SPC> y <SPC> in <SPC> points : <NL>              p [ y ] . append ( x ) <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> x <SPC> in <SPC> sorted ( p ) : <NL>          p [ x ] . sort ( ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( p [ x ] ) ) : <NL>              for <SPC> i <SPC> in <SPC> xrange ( j ) : <NL>                  y1 , <SPC> y2 <SPC> = <SPC> p [ x ] [ i ] , <SPC> p [ x ] [ j ] <NL>                  if <SPC> ( y1 , <SPC> y2 ) <SPC> in <SPC> lookup : <NL>                      result <SPC> = <SPC> min ( result , <SPC> ( x <SPC> - <SPC> lookup [ y1 , <SPC> y2 ] ) <SPC> * <SPC> ( y2 <SPC> - <SPC> y1 ) ) <NL>                  lookup [ y1 , <SPC> y2 ] <SPC> = <SPC> x <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> != <SPC> float ( "inf" ) <SPC> else <SPC> 0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minAreaRect ( self , <SPC> points ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> x1 , <SPC> y1 <SPC> in <SPC> points : <NL>          for <SPC> x2 , <SPC> y2 <SPC> in <SPC> lookup : <NL>              if <SPC> ( x1 , <SPC> y2 ) <SPC> in <SPC> lookup <SPC> and <SPC> ( x2 , <SPC> y1 ) <SPC> in <SPC> lookup : <NL>                  result <SPC> = <SPC> min ( result , <SPC> abs ( x1 <SPC> - <SPC> x2 ) <SPC> * <SPC> abs ( y1 <SPC> - <SPC> y2 ) ) <NL>          lookup . add ( ( x1 , <SPC> y1 ) ) <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> != <SPC> float ( "inf" ) <SPC> else <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumDeleteSum ( self , <SPC> s1 , <SPC> s2 ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( len ( s2 ) <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( s2 ) ) : <NL>          dp [ 0 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> dp [ 0 ] [ j ] <SPC> + <SPC> ord ( s2 [ j ] ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s1 ) ) : <NL>          dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ 0 ] <SPC> = <SPC> dp [ i <SPC> % <SPC> 2 ] [ 0 ] <SPC> + <SPC> ord ( s1 [ i ] ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( s2 ) ) : <NL>              if <SPC> s1 [ i ] <SPC> == <SPC> s2 [ j ] : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> dp [ i <SPC> % <SPC> 2 ] [ j ] <NL>              else : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> min ( <NL>                      dp [ i <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> + <NL>                      ord ( s1 [ i ] ) , <SPC> dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <SPC> + <SPC> ord ( s2 [ j ] ) <NL>                  ) <NL> <NL> <TAB> return <SPC> dp [ len ( s1 ) <SPC> % <SPC> 2 ] [ - 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minimumDeleteSum ( self , <SPC> s1 , <SPC> s2 ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( len ( s2 ) <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( s1 ) <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s1 ) ) : <NL>          dp [ i <SPC> + <SPC> 1 ] [ 0 ] <SPC> = <SPC> dp [ i ] [ 0 ] <SPC> + <SPC> ord ( s1 [ i ] ) <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( s2 ) ) : <NL>          dp [ 0 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> dp [ 0 ] [ j ] <SPC> + <SPC> ord ( s2 [ j ] ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s1 ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( s2 ) ) : <NL>              if <SPC> s1 [ i ] <SPC> == <SPC> s2 [ j ] : <NL>                  dp [ i <SPC> + <SPC> 1 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> dp [ i ] [ j ] <NL>              else : <NL>                  dp [ i <SPC> + <SPC> 1 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> min ( <NL>                      dp [ i ] [ j <SPC> + <SPC> 1 ] <SPC> + <SPC> ord ( s1 [ i ] ) , <SPC> dp [ i <SPC> + <SPC> 1 ] [ j ] <SPC> + <SPC> ord ( s2 [ j ] ) <NL>                  ) <NL> <NL> <TAB> return <SPC> dp [ - 1 ] [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minOperations ( self , <SPC> s ) : <NL> <NL> <TAB> cnt <SPC> = <SPC> sum ( int ( c ) <SPC> == <SPC> i <SPC> % <SPC> 2 <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( s ) ) <NL> <TAB> return <SPC> min ( cnt , <SPC> len ( s ) <SPC> - <SPC> cnt ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mincostTickets ( self , <SPC> days , <SPC> costs ) : <NL> <NL> <TAB> durations <SPC> = <SPC> [ 1 , <SPC> 7 , <SPC> 30 ] <NL> <TAB> W <SPC> = <SPC> durations [ - 1 ] <NL> <TAB> dp <SPC> = <SPC> [ float ( "inf" ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( W ) ] <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 0 <NL> <TAB> last_buy_days <SPC> = <SPC> [ 0 , <SPC> 0 , <SPC> 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( days ) <SPC> + <SPC> 1 ) : <NL>          dp [ i <SPC> % <SPC> W ] <SPC> = <SPC> float ( "inf" ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( durations ) ) : <NL>              while <SPC> ( <NL>                  i <SPC> - <SPC> 1 <SPC> < <SPC> len ( days ) <NL>                  and <SPC> days [ i <SPC> - <SPC> 1 ] <SPC> > <SPC> days [ last_buy_days [ j ] ] <SPC> + <SPC> durations [ j ] <SPC> - <SPC> 1 <NL>              ) : <NL>                  last_buy_days [ j ] <SPC> += <SPC> 1 <NL>              dp [ i <SPC> % <SPC> W ] <SPC> = <SPC> min ( dp [ i <SPC> % <SPC> W ] , <SPC> dp [ last_buy_days [ j ] <SPC> % <SPC> W ] <SPC> + <SPC> costs [ j ] ) <NL> <TAB> return <SPC> dp [ len ( days ) <SPC> % <SPC> W ] <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> connectSticks ( self , <SPC> sticks ) : <NL> <NL> <TAB> heapq . heapify ( sticks ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> len ( sticks ) <SPC> > <SPC> 1 : <NL>          x , <SPC> y <SPC> = <SPC> heapq . heappop ( sticks ) , <SPC> heapq . heappop ( sticks ) <NL>          result <SPC> += <SPC> x <SPC> + <SPC> y <NL>          heapq . heappush ( sticks , <SPC> x <SPC> + <SPC> y ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> connectTwoGroups ( self , <SPC> cost ) : <NL> <NL> <TAB> total <SPC> = <SPC> 2 <SPC> ** <SPC> len ( cost [ 0 ] ) <NL> <TAB> dp <SPC> = <SPC> [ [ float ( "inf" ) ] <SPC> * <SPC> total <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( cost ) ) : <NL>          dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] <SPC> = <SPC> [ float ( "inf" ) ] <SPC> * <SPC> total <NL>          for <SPC> mask <SPC> in <SPC> xrange ( total ) : <NL>              base <SPC> = <SPC> 1 <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( cost [ 0 ] ) ) : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ mask <SPC> | <SPC> base ] <SPC> = <SPC> min ( <NL>                      dp [ i <SPC> % <SPC> 2 ] [ mask <SPC> | <SPC> base ] , <SPC> cost [ i ] [ j ] <SPC> + <SPC> dp [ i <SPC> % <SPC> 2 ] [ mask ] <NL>                  ) <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ mask <SPC> | <SPC> base ] <SPC> = <SPC> min ( <NL>                      dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ mask <SPC> | <SPC> base ] , <SPC> cost [ i ] [ j ] <SPC> + <SPC> dp [ i <SPC> % <SPC> 2 ] [ mask ] <NL>                  ) <NL>                  base <SPC> <<= <SPC> 1 <NL> <TAB> return <SPC> dp [ len ( cost ) <SPC> % <SPC> 2 ] [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minCost ( self , <SPC> n , <SPC> cuts ) : <NL> <NL> <TAB> sorted_cuts <SPC> = <SPC> sorted ( cuts <SPC> + <SPC> [ 0 , <SPC> n ] ) <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( sorted_cuts ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( sorted_cuts ) ) ] <NL> <TAB> for <SPC> l <SPC> in <SPC> xrange ( 2 , <SPC> len ( sorted_cuts ) ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( sorted_cuts ) <SPC> - <SPC> l ) : <NL>              dp [ i ] [ i <SPC> + <SPC> l ] <SPC> = <SPC> ( <NL>                  min ( dp [ i ] [ j ] <SPC> + <SPC> dp [ j ] [ i <SPC> + <SPC> l ] <SPC> for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> i <SPC> + <SPC> l ) ) <NL>                  + <SPC> sorted_cuts [ i <SPC> + <SPC> l ] <NL>                  - <SPC> sorted_cuts [ i ] <NL>              ) <NL> <TAB> return <SPC> dp [ 0 ] [ len ( sorted_cuts ) <SPC> - <SPC> 1 ] <NL> <NL> <NL> import <SPC> itertools <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mincostToHireWorkers ( self , <SPC> quality , <SPC> wage , <SPC> K ) : <NL> <NL> <TAB> result , <SPC> qsum <SPC> = <SPC> float ( "inf" ) , <SPC> 0 <NL> <TAB> max_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> r , <SPC> q <SPC> in <SPC> sorted ( [ float ( w ) <SPC> / <SPC> q , <SPC> q ] <SPC> for <SPC> w , <SPC> q <SPC> in <SPC> itertools . izip ( wage , <SPC> quality ) ) : <NL>          qsum <SPC> += <SPC> q <NL>          heapq . heappush ( max_heap , <SPC> - q ) <NL>          if <SPC> len ( max_heap ) <SPC> > <SPC> K : <NL>              qsum <SPC> -= <SPC> - heapq . heappop ( max_heap ) <NL>          if <SPC> len ( max_heap ) <SPC> == <SPC> K : <NL>              result <SPC> = <SPC> min ( result , <SPC> qsum <SPC> * <SPC> r ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minCost ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> a_star ( grid , <SPC> b , <SPC> t ) : <NL>          R , <SPC> C <SPC> = <SPC> len ( grid ) , <SPC> len ( grid [ 0 ] ) <NL>          f , <SPC> dh <SPC> = <SPC> 0 , <SPC> 1 <NL>          closer , <SPC> detour <SPC> = <SPC> [ b ] , <SPC> [ ] <NL>          lookup <SPC> = <SPC> set ( ) <NL>          while <SPC> closer <SPC> or <SPC> detour : <NL>              if <SPC> not <SPC> closer : <NL>                  f <SPC> += <SPC> dh <NL>                  closer , <SPC> detour <SPC> = <SPC> detour , <SPC> closer <NL>              b <SPC> = <SPC> closer . pop ( ) <NL>              if <SPC> b <SPC> == <SPC> t : <NL>                  return <SPC> f <NL>              if <SPC> b <SPC> in <SPC> lookup : <NL>                  continue <NL>              lookup . add ( b ) <NL>              for <SPC> nd , <SPC> ( dr , <SPC> dc ) <SPC> in <SPC> enumerate ( directions , <SPC> 1 ) : <NL>                  nb <SPC> = <SPC> ( b [ 0 ] <SPC> + <SPC> dr , <SPC> b [ 1 ] <SPC> + <SPC> dc ) <NL>                  if <SPC> not <SPC> ( 0 <SPC> <= <SPC> nb [ 0 ] <SPC> < <SPC> R <SPC> and <SPC> 0 <SPC> <= <SPC> nb [ 1 ] <SPC> < <SPC> C <SPC> and <SPC> nb <SPC> not <SPC> in <SPC> lookup ) : <NL>                      continue <NL>                  ( closer <SPC> if <SPC> nd <SPC> == <SPC> grid [ b [ 0 ] ] [ b [ 1 ] ] <SPC> else <SPC> detour ) . append ( nb ) <NL>          return <SPC> - 1 <NL> <NL> <TAB> return <SPC> a_star ( grid , <SPC> ( 0 , <SPC> 0 ) , <SPC> ( len ( grid ) <SPC> - <SPC> 1 , <SPC> len ( grid [ 0 ] ) <SPC> - <SPC> 1 ) ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minCost ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> R , <SPC> C <SPC> = <SPC> len ( grid ) , <SPC> len ( grid [ 0 ] ) <NL> <TAB> b , <SPC> t <SPC> = <SPC> ( 0 , <SPC> 0 ) , <SPC> ( R <SPC> - <SPC> 1 , <SPC> C <SPC> - <SPC> 1 ) <NL> <TAB> dq <SPC> = <SPC> collections . deque ( [ ( b , <SPC> 0 ) ] ) <NL> <TAB> lookup <SPC> = <SPC> { b : <SPC> 0 } <NL> <TAB> while <SPC> dq : <NL>          b , <SPC> d <SPC> = <SPC> dq . popleft ( ) <NL>          if <SPC> b <SPC> == <SPC> t : <NL>              return <SPC> d <NL>          if <SPC> lookup [ b ] <SPC> < <SPC> d : <NL>              continue <NL>          for <SPC> nd , <SPC> ( dr , <SPC> dc ) <SPC> in <SPC> enumerate ( directions , <SPC> 1 ) : <NL>              nb <SPC> = <SPC> ( b [ 0 ] <SPC> + <SPC> dr , <SPC> b [ 1 ] <SPC> + <SPC> dc ) <NL>              cost <SPC> = <SPC> 1 <SPC> if <SPC> nd <SPC> != <SPC> grid [ b [ 0 ] ] [ b [ 1 ] ] <SPC> else <SPC> 0 <NL>              if <SPC> not <SPC> ( <NL>                  0 <SPC> <= <SPC> nb [ 0 ] <SPC> < <SPC> R <NL>                  and <SPC> 0 <SPC> <= <SPC> nb [ 1 ] <SPC> < <SPC> C <NL>                  and <SPC> ( nb <SPC> not <SPC> in <SPC> lookup <SPC> or <SPC> lookup [ nb ] <SPC> > <SPC> d <SPC> + <SPC> cost ) <NL>              ) : <NL>                  continue <NL>              lookup [ nb ] <SPC> = <SPC> d <SPC> + <SPC> cost <NL>              if <SPC> not <SPC> cost : <NL>                  dq . appendleft ( ( nb , <SPC> d ) ) <NL>              else : <NL>                  dq . append ( ( nb , <SPC> d <SPC> + <SPC> cost ) ) <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mergeStones ( self , <SPC> stones , <SPC> K ) : <NL> <NL> <TAB> if <SPC> ( len ( stones ) <SPC> - <SPC> 1 ) <SPC> % <SPC> ( K <SPC> - <SPC> 1 ) : <NL>          return <SPC> - 1 <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> x <SPC> in <SPC> stones : <NL>          prefix . append ( prefix [ - 1 ] <SPC> + <SPC> x ) <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( stones ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( stones ) ) ] <NL> <TAB> for <SPC> l <SPC> in <SPC> xrange ( K <SPC> - <SPC> 1 , <SPC> len ( stones ) ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( stones ) <SPC> - <SPC> l ) : <NL>              dp [ i ] [ i <SPC> + <SPC> l ] <SPC> = <SPC> min ( <NL>                  dp [ i ] [ j ] <SPC> + <SPC> dp [ j <SPC> + <SPC> 1 ] [ i <SPC> + <SPC> l ] <SPC> for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> i <SPC> + <SPC> l , <SPC> K <SPC> - <SPC> 1 ) <NL>              ) <NL>              if <SPC> l <SPC> % <SPC> ( K <SPC> - <SPC> 1 ) <SPC> == <SPC> 0 : <NL>                  dp [ i ] [ i <SPC> + <SPC> l ] <SPC> += <SPC> prefix [ i <SPC> + <SPC> l <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ i ] <NL> <TAB> return <SPC> dp [ 0 ] [ len ( stones ) <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mctFromLeafValues ( self , <SPC> arr ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> stk <SPC> = <SPC> [ float ( "inf" ) ] <NL> <TAB> for <SPC> x <SPC> in <SPC> arr : <NL>          while <SPC> stk [ - 1 ] <SPC> <= <SPC> x : <NL>              result <SPC> += <SPC> stk . pop ( ) <SPC> * <SPC> min ( stk [ - 1 ] , <SPC> x ) <NL>          stk . append ( x ) <NL> <TAB> while <SPC> len ( stk ) <SPC> > <SPC> 2 : <NL>          result <SPC> += <SPC> stk . pop ( ) <SPC> * <SPC> stk [ - 1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minTrioDegree ( self , <SPC> n , <SPC> edges ) : <NL> <NL> <TAB> adj <SPC> = <SPC> [ set ( ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n <SPC> + <SPC> 1 ) ] <NL> <TAB> degree <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          adj [ min ( u , <SPC> v ) ] . add ( max ( u , <SPC> v ) ) <NL>          degree [ u ] <SPC> += <SPC> 1 <NL>          degree [ v ] <SPC> += <SPC> 1 <NL> <TAB> result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> u <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          for <SPC> v <SPC> in <SPC> adj [ u ] : <NL>              for <SPC> w <SPC> in <SPC> adj [ u ] : <NL>                  if <SPC> v <SPC> < <SPC> w <SPC> and <SPC> w <SPC> in <SPC> adj [ v ] : <NL>                      result <SPC> = <SPC> min ( result , <SPC> degree [ u ] <SPC> + <SPC> degree [ v ] <SPC> + <SPC> degree [ w ] <SPC> - <SPC> 6 ) <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> != <SPC> float ( "inf" ) <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minCost ( self , <SPC> s , <SPC> cost ) : <NL> <NL> <TAB> result <SPC> = <SPC> accu <SPC> = <SPC> max_cost <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> i <SPC> and <SPC> s [ i ] <SPC> != <SPC> s [ i <SPC> - <SPC> 1 ] : <NL>              result <SPC> += <SPC> accu <SPC> - <SPC> max_cost <NL>              accu <SPC> = <SPC> max_cost <SPC> = <SPC> 0 <NL>          accu <SPC> += <SPC> cost [ i ] <NL>          max_cost <SPC> = <SPC> max ( max_cost , <SPC> cost [ i ] ) <NL> <TAB> result <SPC> += <SPC> accu <SPC> - <SPC> max_cost <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> string <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDeletions ( self , <SPC> s ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( s ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> c <SPC> in <SPC> string . ascii_lowercase : <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> count [ c ] <SPC> + <SPC> 1 ) ) : <NL>              if <SPC> i <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( i ) <NL>                  break <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumDeletions ( self , <SPC> s ) : <NL> <NL> <TAB> result <SPC> = <SPC> b_cnt <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          if <SPC> c <SPC> == <SPC> "b" : <NL>              b_cnt <SPC> += <SPC> 1 <NL>          elif <SPC> b_cnt : <NL>              b_cnt <SPC> -= <SPC> 1 <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> minDepth ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <NL> <TAB> if <SPC> root . left <SPC> and <SPC> root . right : <NL>          return <SPC> min ( self . minDepth ( root . left ) , <SPC> self . minDepth ( root . right ) ) <SPC> + <SPC> 1 <NL> <TAB> else : <NL>          return <SPC> max ( self . minDepth ( root . left ) , <SPC> self . minDepth ( root . right ) ) <SPC> + <SPC> 1 <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDifference ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> nth_element ( nums , <SPC> left , <SPC> n , <SPC> right , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) : <NL>          def <SPC> partition_around_pivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare ) : <NL>              new_pivot_idx <SPC> = <SPC> left <NL>              nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>                  if <SPC> compare ( nums [ i ] , <SPC> nums [ right ] ) : <NL>                      nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                      new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>              nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>              return <SPC> new_pivot_idx <NL> <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> partition_around_pivot ( <NL>                  left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare <NL>              ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> n : <NL>                  return <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> n : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> k <SPC> = <SPC> 4 <NL> <TAB> if <SPC> len ( nums ) <SPC> <= <SPC> k : <NL>          return <SPC> 0 <NL> <TAB> nth_element ( nums , <SPC> 0 , <SPC> k , <SPC> len ( nums ) <SPC> - <SPC> 1 ) <NL> <TAB> nums [ : k ] <SPC> = <SPC> sorted ( nums [ : k ] ) <NL> <TAB> nth_element ( nums , <SPC> k , <SPC> max ( k , <SPC> len ( nums ) <SPC> - <SPC> k ) , <SPC> len ( nums ) <SPC> - <SPC> 1 ) <NL> <TAB> nums [ - k : ] <SPC> = <SPC> sorted ( nums [ - k : ] ) <NL> <TAB> return <SPC> min ( nums [ - k <SPC> + <SPC> i ] <SPC> - <SPC> nums [ i ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( k ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDifficulty ( self , <SPC> jobDifficulty , <SPC> d ) : <NL> <NL> <TAB> if <SPC> len ( jobDifficulty ) <SPC> < <SPC> d : <NL>          return <SPC> - 1 <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ float ( "inf" ) ] <SPC> * <SPC> len ( jobDifficulty ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( d ) ] <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> jobDifficulty [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( jobDifficulty ) ) : <NL>          dp [ 0 ] [ i ] <SPC> = <SPC> max ( dp [ 0 ] [ i <SPC> - <SPC> 1 ] , <SPC> jobDifficulty [ i ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> d ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> len ( jobDifficulty ) ) : <NL>              curr_max <SPC> = <SPC> jobDifficulty [ j ] <NL>              for <SPC> k <SPC> in <SPC> reversed ( xrange ( i , <SPC> j <SPC> + <SPC> 1 ) ) : <NL>                  curr_max <SPC> = <SPC> max ( curr_max , <SPC> jobDifficulty [ k ] ) <NL>                  dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> dp [ i <SPC> - <SPC> 1 ] [ k <SPC> - <SPC> 1 ] <SPC> + <SPC> curr_max ) <NL> <TAB> return <SPC> dp [ d <SPC> - <SPC> 1 ] [ len ( jobDifficulty ) <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDiffInBST ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node ) : <NL>          if <SPC> not <SPC> node : <NL>              return <NL>          dfs ( node . left ) <NL>          self . result <SPC> = <SPC> min ( self . result , <SPC> node . val <SPC> - <SPC> self . prev ) <NL>          self . prev <SPC> = <SPC> node . val <NL>          dfs ( node . right ) <NL> <NL> <TAB> self . prev <SPC> = <SPC> float ( "-inf" ) <NL> <TAB> self . result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> dfs ( root ) <NL> <TAB> return <SPC> self . result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumDistance ( self , <SPC> word ) : <NL> <NL> <TAB> def <SPC> distance ( a , <SPC> b ) : <NL>          return <SPC> abs ( a <SPC> // <SPC> 6 <SPC> - <SPC> b <SPC> // <SPC> 6 ) <SPC> + <SPC> abs ( a <SPC> % <SPC> 6 <SPC> - <SPC> b <SPC> % <SPC> 6 ) <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( word ) <SPC> - <SPC> 1 ) : <NL>          b , <SPC> c <SPC> = <SPC> ord ( word [ i ] ) <SPC> - <SPC> ord ( "A" ) , <SPC> ord ( word [ i <SPC> + <SPC> 1 ] ) <SPC> - <SPC> ord ( "A" ) <NL>          dp [ b ] <SPC> = <SPC> max ( dp [ a ] <SPC> - <SPC> distance ( a , <SPC> c ) <SPC> + <SPC> distance ( b , <SPC> c ) <NL>                      for <SPC> a <SPC> in <SPC> xrange ( 26 ) ) <NL> <TAB> return <SPC> sum ( <NL>          distance ( ord ( word [ i ] ) <SPC> - <SPC> ord ( "A" ) , <SPC> ord ( word [ i <SPC> + <SPC> 1 ] ) <SPC> - <SPC> ord ( "A" ) ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( word ) <SPC> - <SPC> 1 ) <NL> <TAB> ) <SPC> - <SPC> max ( dp ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minimumDistance ( self , <SPC> word ) : <NL> <NL> <TAB> def <SPC> distance ( a , <SPC> b ) : <NL>          if <SPC> - 1 <SPC> in <SPC> [ a , <SPC> b ] : <NL>              return <SPC> 0 <NL>          return <SPC> abs ( a <SPC> // <SPC> 6 <SPC> - <SPC> b <SPC> // <SPC> 6 ) <SPC> + <SPC> abs ( a <SPC> % <SPC> 6 <SPC> - <SPC> b <SPC> % <SPC> 6 ) <NL> <NL> <TAB> dp <SPC> = <SPC> { ( - 1 , <SPC> - 1 ) : <SPC> 0 } <NL> <TAB> for <SPC> c <SPC> in <SPC> word : <NL>          c <SPC> = <SPC> ord ( c ) <SPC> - <SPC> ord ( "A" ) <NL>          new_dp <SPC> = <SPC> { } <NL>          for <SPC> a , <SPC> b <SPC> in <SPC> dp : <NL>              new_dp [ c , <SPC> b ] <SPC> = <SPC> min ( <NL>                  new_dp . get ( ( c , <SPC> b ) , <SPC> float ( "inf" ) ) , <SPC> dp [ a , <SPC> b ] <SPC> + <SPC> distance ( a , <SPC> c ) <NL>              ) <NL>              new_dp [ a , <SPC> c ] <SPC> = <SPC> min ( <NL>                  new_dp . get ( ( a , <SPC> c ) , <SPC> float ( "inf" ) ) , <SPC> dp [ a , <SPC> b ] <SPC> + <SPC> distance ( b , <SPC> c ) <NL>              ) <NL>          dp <SPC> = <SPC> new_dp <NL> <TAB> return <SPC> min ( dp . itervalues ( ) ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDominoRotations ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> intersect <SPC> = <SPC> reduce ( set . __and__ , <SPC> [ set ( d ) <SPC> for <SPC> d <SPC> in <SPC> itertools . izip ( A , <SPC> B ) ] ) <NL> <TAB> if <SPC> not <SPC> intersect : <NL>          return <SPC> - 1 <NL> <TAB> x <SPC> = <SPC> intersect . pop ( ) <NL> <TAB> return <SPC> min ( len ( A ) <SPC> - <SPC> A . count ( x ) , <SPC> len ( B ) <SPC> - <SPC> B . count ( x ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minElements ( self , <SPC> nums , <SPC> limit , <SPC> goal ) : <NL> <NL> <TAB> return <SPC> ( abs ( sum ( nums ) <SPC> - <SPC> goal ) <SPC> + <SPC> ( limit <SPC> - <SPC> 1 ) ) <SPC> // <SPC> limit <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestFactorization ( self , <SPC> a ) : <NL> <NL> <TAB> if <SPC> a <SPC> < <SPC> 2 : <NL>          return <SPC> a <NL> <TAB> result , <SPC> mul <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 2 , <SPC> 10 ) ) : <NL>          while <SPC> a <SPC> % <SPC> i <SPC> == <SPC> 0 : <NL>              a <SPC> /= <SPC> i <NL>              result <SPC> = <SPC> mul <SPC> * <SPC> i <SPC> + <SPC> result <NL>              mul <SPC> *= <SPC> 10 <NL> <TAB> return <SPC> result <SPC> if <SPC> a <SPC> == <SPC> 1 <SPC> and <SPC> result <SPC> < <SPC> 2 <SPC> ** <SPC> 31 <SPC> else <SPC> 0 <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minFallingPathSum ( self , <SPC> arr ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( arr ) ) : <NL>          smallest_two <SPC> = <SPC> heapq . nsmallest ( 2 , <SPC> arr [ i <SPC> - <SPC> 1 ] ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( arr [ 0 ] ) ) : <NL>              arr [ i ] [ j ] <SPC> += <SPC> ( <NL>                  smallest_two [ 1 ] <NL>                  if <SPC> arr [ i <SPC> - <SPC> 1 ] [ j ] <SPC> == <SPC> smallest_two [ 0 ] <NL>                  else <SPC> smallest_two [ 0 ] <NL>              ) <NL> <TAB> return <SPC> min ( arr [ - 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minFallingPathSum ( self , <SPC> A ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( A [ i ] ) ) : <NL>              A [ i ] [ j ] <SPC> += <SPC> min ( A [ i <SPC> - <SPC> 1 ] [ max ( j <SPC> - <SPC> 1 , <SPC> 0 ) : <SPC> j <SPC> + <SPC> 2 ] ) <NL> <TAB> return <SPC> min ( A [ - 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minFlips ( self , <SPC> a , <SPC> b , <SPC> c ) : <NL> <NL> <TAB> def <SPC> number_of_1_bits ( n ) : <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> n : <NL>              n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL>              result <SPC> += <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> number_of_1_bits ( ( a <SPC> | <SPC> b ) <SPC> ^ <SPC> c ) <SPC> + <SPC> number_of_1_bits ( a <SPC> & <SPC> b <SPC> & <SPC> ~ c ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minFlips ( self , <SPC> a , <SPC> b , <SPC> c ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 31 ) : <NL>          a_i , <SPC> b_i , <SPC> c_i <SPC> = <SPC> map ( lambda <SPC> x : <SPC> x <SPC> & <SPC> 1 , <SPC> [ a , <SPC> b , <SPC> c ] ) <NL>          if <SPC> ( a_i <SPC> | <SPC> b_i ) <SPC> != <SPC> c_i : <NL>              result <SPC> += <SPC> 2 <SPC> if <SPC> a_i <SPC> == <SPC> b_i <SPC> == <SPC> 1 <SPC> else <SPC> 1 <NL>          a , <SPC> b , <SPC> c <SPC> = <SPC> a <SPC> >> <SPC> 1 , <SPC> b <SPC> >> <SPC> 1 , <SPC> c <SPC> >> <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> deque <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minMutation ( self , <SPC> start , <SPC> end , <SPC> bank ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> b <SPC> in <SPC> bank : <NL>          lookup [ b ] <SPC> = <SPC> False <NL> <NL> <TAB> q <SPC> = <SPC> deque ( [ ( start , <SPC> 0 ) ] ) <NL> <TAB> while <SPC> q : <NL>          cur , <SPC> level <SPC> = <SPC> q . popleft ( ) <NL>          if <SPC> cur <SPC> == <SPC> end : <NL>              return <SPC> level <NL> <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( cur ) ) : <NL>              for <SPC> c <SPC> in <SPC> [ "A" , <SPC> "T" , <SPC> "C" , <SPC> "G" ] : <NL>                  if <SPC> cur [ i ] <SPC> == <SPC> c : <NL>                      continue <NL> <NL>                  next_str <SPC> = <SPC> cur [ : i ] <SPC> + <SPC> c <SPC> + <SPC> cur [ i <SPC> + <SPC> 1 : ] <NL>                  if <SPC> next_str <SPC> in <SPC> lookup <SPC> and <SPC> lookup [ next_str ] <SPC> == <SPC> False : <NL>                      q . append ( ( next_str , <SPC> level <SPC> + <SPC> 1 ) ) <NL>                      lookup [ next_str ] <SPC> = <SPC> True <NL> <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMinHeightTrees ( self , <SPC> n , <SPC> edges ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 1 : <NL>          return <SPC> [ 0 ] <NL> <NL> <TAB> neighbors <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          neighbors [ u ] . add ( v ) <NL>          neighbors [ v ] . add ( u ) <NL> <NL> <TAB> pre_level , <SPC> unvisited <SPC> = <SPC> [ ] , <SPC> set ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          if <SPC> len ( neighbors [ i ] ) <SPC> == <SPC> 1 : <NL>              pre_level . append ( i ) <NL>          unvisited . add ( i ) <NL> <NL> <TAB> while <SPC> len ( unvisited ) <SPC> > <SPC> 2 : <NL>          cur_level <SPC> = <SPC> [ ] <NL>          for <SPC> u <SPC> in <SPC> pre_level : <NL>              unvisited . remove ( u ) <NL>              for <SPC> v <SPC> in <SPC> neighbors [ u ] : <NL>                  if <SPC> v <SPC> in <SPC> unvisited : <NL>                      neighbors [ v ] . remove ( u ) <NL>                      if <SPC> len ( neighbors [ v ] ) <SPC> == <SPC> 1 : <NL>                          cur_level . append ( v ) <NL>          pre_level <SPC> = <SPC> cur_level <NL> <NL> <TAB> return <SPC> list ( unvisited ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumIncompatibility ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> inf <SPC> = <SPC> ( len ( nums ) <SPC> - <SPC> 1 ) <SPC> * <SPC> ( len ( nums ) <SPC> // <SPC> k ) <SPC> + <SPC> 1 <NL> <NL> <TAB> def <SPC> backtracking ( nums , <SPC> d , <SPC> lookup ) : <NL>          if <SPC> not <SPC> nums : <NL>              return <SPC> 0 <NL>          if <SPC> nums <SPC> not <SPC> in <SPC> lookup : <NL>              ret <SPC> = <SPC> inf <NL>              for <SPC> new_nums <SPC> in <SPC> itertools . combinations ( nums , <SPC> d ) : <NL>                  new_nums_set <SPC> = <SPC> set ( new_nums ) <NL>                  if <SPC> len ( new_nums_set ) <SPC> < <SPC> d : <NL>                      continue <NL>                  left <SPC> = <SPC> [ ] <NL>                  for <SPC> num <SPC> in <SPC> nums : <NL>                      if <SPC> num <SPC> in <SPC> new_nums_set : <NL>                          new_nums_set . remove ( num ) <NL>                          continue <NL>                      left . append ( num ) <NL>                  ret <SPC> = <SPC> min ( <NL>                      ret , <NL>                      max ( new_nums ) <NL>                      - <SPC> min ( new_nums ) <NL>                      + <SPC> backtracking ( tuple ( left ) , <SPC> d , <SPC> lookup ) , <NL>                  ) <NL>              lookup [ nums ] <SPC> = <SPC> ret <NL>          return <SPC> lookup [ nums ] <NL> <NL> <TAB> result <SPC> = <SPC> backtracking ( tuple ( nums ) , <SPC> len ( nums ) <SPC> // <SPC> k , <SPC> { } ) <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> != <SPC> inf <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution_TLE ( object ) : <NL> <TAB> def <SPC> minimumIncompatibility ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> inf <SPC> = <SPC> ( len ( nums ) <SPC> - <SPC> 1 ) <SPC> * <SPC> ( len ( nums ) <SPC> // <SPC> k ) <SPC> + <SPC> 1 <NL> <TAB> POW <SPC> = <SPC> [ 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          POW . append ( POW [ - 1 ] <SPC> << <SPC> 1 ) <NL> <NL> <TAB> def <SPC> popcount ( n ) : <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> n : <NL>              n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL>              result <SPC> += <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> find_candidates ( nums , <SPC> k ) : <NL>          total <SPC> = <SPC> POW [ len ( nums ) ] <SPC> - <SPC> 1 <NL>          m <SPC> = <SPC> len ( nums ) <SPC> // <SPC> k <NL>          result <SPC> = <SPC> [ inf ] <SPC> * <SPC> ( total <SPC> + <SPC> 1 ) <NL>          for <SPC> mask <SPC> in <SPC> xrange ( total <SPC> + <SPC> 1 ) : <NL>              if <SPC> popcount ( mask ) <SPC> != <SPC> m : <NL>                  continue <NL>              lookup <SPC> = <SPC> 0 <NL>              mx , <SPC> mn <SPC> = <SPC> 0 , <SPC> inf <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>                  if <SPC> mask <SPC> & <SPC> POW [ i ] <SPC> == <SPC> 0 : <NL>                      continue <NL>                  if <SPC> lookup <SPC> & <SPC> POW [ nums [ i ] ] : <NL>                      break <NL>                  lookup <SPC> |= <SPC> POW [ nums [ i ] ] <NL>                  mx <SPC> = <SPC> max ( mx , <SPC> nums [ i ] ) <NL>                  mn <SPC> = <SPC> min ( mn , <SPC> nums [ i ] ) <NL>              else : <NL>                  result [ mask ] <SPC> = <SPC> mx <SPC> - <SPC> mn <NL>          return <SPC> result <NL> <NL> <TAB> candidates <SPC> = <SPC> find_candidates ( nums , <SPC> k ) <NL> <TAB> m <SPC> = <SPC> len ( nums ) <SPC> // <SPC> k <NL> <TAB> total <SPC> = <SPC> POW [ len ( nums ) ] <SPC> - <SPC> 1 <NL> <TAB> dp <SPC> = <SPC> [ inf ] <SPC> * <SPC> ( total <SPC> + <SPC> 1 ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> mask <SPC> in <SPC> xrange ( total <SPC> + <SPC> 1 ) : <NL>          if <SPC> popcount ( mask ) <SPC> % <SPC> m <SPC> != <SPC> 0 : <NL>              continue <NL> <NL>          submask <SPC> = <SPC> mask <NL>          while <SPC> submask : <NL>              dp [ mask ] <SPC> = <SPC> min ( dp [ mask ] , <SPC> dp [ mask <SPC> - <SPC> submask ] <SPC> + <SPC> candidates [ submask ] ) <NL>              submask <SPC> = <SPC> ( submask <SPC> - <SPC> 1 ) <SPC> & <SPC> mask <NL> <TAB> return <SPC> dp [ - 1 ] <SPC> if <SPC> dp [ - 1 ] <SPC> != <SPC> inf <SPC> else <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> sortedcontainers <NL> <NL> <NL> class <SPC> Solution_Wrong_Greedy_SortedList ( object ) : <NL> <TAB> def <SPC> minimumIncompatibility ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> greedy ( nums , <SPC> k , <SPC> is_reversed ) : <NL>          count <SPC> = <SPC> collections . Counter ( nums ) <NL>          if <SPC> max ( count . itervalues ( ) ) <SPC> > <SPC> k : <NL>              return <SPC> - 1 <NL>          ordered_set <SPC> = <SPC> sortedcontainers . SortedList ( count . iterkeys ( ) ) <NL>          freq_to_nodes <SPC> = <SPC> collections . defaultdict ( collections . OrderedDict ) <NL>          for <SPC> x <SPC> in <SPC> ordered_set : <NL>              freq_to_nodes [ count [ x ] ] [ x ] <SPC> = <SPC> count [ x ] <NL>          stks <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( k ) ] <NL>          curr <SPC> = <SPC> 0 <NL>          while <SPC> ordered_set : <NL>              if <SPC> ( <NL>                  len ( stks ) <SPC> - <SPC> curr <SPC> in <SPC> freq_to_nodes <NL>              ) : <NL>                  for <SPC> x <SPC> in <SPC> freq_to_nodes [ <NL>                      len ( stks ) <SPC> - <SPC> curr <NL>                  ] . iterkeys ( ) : <NL>                      for <SPC> i <SPC> in <SPC> xrange ( curr , <SPC> len ( stks ) ) : <NL>                          stks [ i ] . append ( x ) <NL>                      count . pop ( x ) <NL>                      ordered_set . remove ( x ) <NL>                  freq_to_nodes . pop ( len ( stks ) <SPC> - <SPC> curr ) <NL> <NL>              to_remove <SPC> = <SPC> [ ] <NL>              direction <SPC> = <SPC> ( lambda <SPC> x : <SPC> x ) <SPC> if <SPC> not <SPC> is_reversed <SPC> else <SPC> reversed <NL>              for <SPC> x <SPC> in <SPC> direction ( ordered_set ) : <NL>                  stks [ curr ] . append ( x ) <NL>                  freq_to_nodes [ count [ x ] ] . pop ( x ) <NL>                  if <SPC> not <SPC> freq_to_nodes [ count [ x ] ] : <NL>                      freq_to_nodes . pop ( count [ x ] ) <NL>                  count [ x ] <SPC> -= <SPC> 1 <NL>                  if <SPC> not <SPC> count [ x ] : <NL>                      count . pop ( x ) <NL>                      to_remove . append ( x ) <NL>                  else : <NL>                      freq_to_nodes [ count [ x ] ] [ x ] <SPC> = <SPC> count [ x ] <NL>                  if <SPC> len ( stks [ curr ] ) <SPC> == <SPC> len ( nums ) <SPC> // <SPC> k : <NL>                      curr <SPC> += <SPC> 1 <NL>                      break <NL>              for <SPC> x <SPC> in <SPC> to_remove : <NL>                  ordered_set . remove ( x ) <NL>          return <SPC> sum ( [ max ( stk ) <SPC> - <SPC> min ( stk ) <SPC> for <SPC> stk <SPC> in <SPC> stks ] ) <NL> <NL> <TAB> return <SPC> min ( <NL>          greedy ( nums , <SPC> k , <SPC> False ) , <SPC> greedy ( nums , <SPC> k , <SPC> True ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> from <SPC> random <SPC> import <SPC> randint , <SPC> seed <NL> <NL> <NL> class <SPC> SkipNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> level = 0 , <SPC> val = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . nexts <SPC> = <SPC> [ None ] <SPC> * <SPC> level <NL> <TAB> self . prevs <SPC> = <SPC> [ None ] <SPC> * <SPC> level <NL> <NL> <NL> class <SPC> SkipList ( object ) : <NL> <TAB> P_NUMERATOR , <SPC> P_DENOMINATOR <SPC> = <SPC> 1 , <SPC> 2 <NL> <TAB> MAX_LEVEL <SPC> = <SPC> 32 <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> end = float ( "inf" ) , <SPC> can_duplicated = False , <SPC> cmp = lambda <SPC> x , <SPC> y : <SPC> x <SPC> < <SPC> y ) : <NL> <TAB> seed ( 0 ) <NL> <TAB> self . __head <SPC> = <SPC> SkipNode ( ) <NL> <TAB> self . __len <SPC> = <SPC> 0 <NL> <TAB> self . __can_duplicated <SPC> = <SPC> can_duplicated <NL> <TAB> self . __cmp <SPC> = <SPC> cmp <NL> <TAB> self . add ( end ) <NL> <TAB> self . __end <SPC> = <SPC> self . find ( end ) <NL> <NL> <TAB> def <SPC> begin ( self ) : <NL> <TAB> return <SPC> self . __head . nexts [ 0 ] <NL> <NL> <TAB> def <SPC> end ( self ) : <NL> <TAB> return <SPC> self . __end <NL> <NL> <TAB> def <SPC> lower_bound ( self , <SPC> target ) : <NL> <TAB> return <SPC> self . __lower_bound ( target , <SPC> self . __find_prev_nodes ( target ) ) <NL> <NL> <TAB> def <SPC> find ( self , <SPC> target ) : <NL> <TAB> return <SPC> self . __find ( target , <SPC> self . __find_prev_nodes ( target ) ) <NL> <NL> <TAB> def <SPC> add ( self , <SPC> val ) : <NL> <TAB> if <SPC> not <SPC> self . __can_duplicated <SPC> and <SPC> self . find ( val ) : <NL>          return <SPC> self . find ( val ) , <SPC> False <NL> <TAB> node <SPC> = <SPC> SkipNode ( self . __random_level ( ) , <SPC> val ) <NL> <TAB> if <SPC> len ( self . __head . nexts ) <SPC> < <SPC> len ( node . nexts ) : <NL>          self . __head . nexts . extend ( <NL>              [ None ] <SPC> * <SPC> ( len ( node . nexts ) <SPC> - <SPC> len ( self . __head . nexts ) ) <NL>          ) <NL> <TAB> prevs <SPC> = <SPC> self . __find_prev_nodes ( val ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( node . nexts ) ) : <NL>          node . nexts [ i ] <SPC> = <SPC> prevs [ i ] . nexts [ i ] <NL>          if <SPC> prevs [ i ] . nexts [ i ] : <NL>              prevs [ i ] . nexts [ i ] . prevs [ i ] <SPC> = <SPC> node <NL>          prevs [ i ] . nexts [ i ] <SPC> = <SPC> node <NL>          node . prevs [ i ] <SPC> = <SPC> prevs [ i ] <NL> <TAB> self . __len <SPC> += <SPC> 1 <NL> <TAB> return <SPC> node <SPC> if <SPC> self . __can_duplicated <SPC> else <SPC> ( node , <SPC> True ) <NL> <NL> <TAB> def <SPC> remove ( self , <SPC> it ) : <NL> <TAB> prevs <SPC> = <SPC> it . prevs <NL> <TAB> curr <SPC> = <SPC> self . __find ( it . val , <SPC> prevs ) <NL> <TAB> if <SPC> not <SPC> curr : <NL>          return <SPC> self . __end <NL> <TAB> self . __len <SPC> -= <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( curr . nexts ) ) ) : <NL>          prevs [ i ] . nexts [ i ] <SPC> = <SPC> curr . nexts [ i ] <NL>          if <SPC> curr . nexts [ i ] : <NL>              curr . nexts [ i ] . prevs [ i ] <SPC> = <SPC> prevs [ i ] <NL>          if <SPC> not <SPC> self . __head . nexts [ i ] : <NL>              self . __head . nexts . pop ( ) <NL> <TAB> return <SPC> curr . nexts [ 0 ] <NL> <NL> <TAB> def <SPC> __lower_bound ( self , <SPC> val , <SPC> prevs ) : <NL> <TAB> if <SPC> prevs : <NL>          candidate <SPC> = <SPC> prevs [ 0 ] . nexts [ 0 ] <NL>          if <SPC> candidate : <NL>              return <SPC> candidate <NL> <TAB> return <SPC> None <NL> <NL> <TAB> def <SPC> __find ( self , <SPC> val , <SPC> prevs ) : <NL> <TAB> candidate <SPC> = <SPC> self . __lower_bound ( val , <SPC> prevs ) <NL> <TAB> if <SPC> candidate <SPC> and <SPC> candidate . val <SPC> == <SPC> val : <NL>          return <SPC> candidate <NL> <TAB> return <SPC> None <NL> <NL> <TAB> def <SPC> __find_prev_nodes ( self , <SPC> val ) : <NL> <TAB> prevs <SPC> = <SPC> [ None ] <SPC> * <SPC> len ( self . __head . nexts ) <NL> <TAB> curr <SPC> = <SPC> self . __head <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( self . __head . nexts ) ) ) : <NL>          while <SPC> curr . nexts [ i ] <SPC> and <SPC> self . __cmp ( curr . nexts [ i ] . val , <SPC> val ) : <NL>              curr <SPC> = <SPC> curr . nexts [ i ] <NL>          prevs [ i ] <SPC> = <SPC> curr <NL> <TAB> return <SPC> prevs <NL> <NL> <TAB> def <SPC> __random_level ( self ) : <NL> <TAB> level <SPC> = <SPC> 1 <NL> <TAB> while <SPC> ( <NL>          randint ( 1 , <SPC> SkipList . P_DENOMINATOR ) <SPC> <= <SPC> SkipList . P_NUMERATOR <NL>          and <SPC> level <SPC> < <SPC> SkipList . MAX_LEVEL <NL> <TAB> ) : <NL>          level <SPC> += <SPC> 1 <NL> <TAB> return <SPC> level <NL> <NL> <TAB> def <SPC> __iter__ ( self ) : <NL> <TAB> it <SPC> = <SPC> self . begin ( ) <NL> <TAB> while <SPC> it <SPC> != <SPC> self . end ( ) : <NL>          yield <SPC> it . val <NL>          it <SPC> = <SPC> it . nexts [ 0 ] <NL> <NL> <TAB> def <SPC> __len__ ( self ) : <NL> <TAB> return <SPC> self . __len <SPC> - <SPC> 1 <NL> <NL> <TAB> def <SPC> __str__ ( self ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( self . __head . nexts ) ) ) : <NL>          result . append ( [ ] ) <NL>          curr <SPC> = <SPC> self . __head . nexts [ i ] <NL>          while <SPC> curr : <NL>              result [ - 1 ] . append ( str ( curr . val ) ) <NL>              curr <SPC> = <SPC> curr . nexts [ i ] <NL> <TAB> return <SPC> "\n" . join ( map ( lambda <SPC> x : <SPC> "->" . join ( x ) , <SPC> result ) ) <NL> <NL> <NL> class <SPC> Solution_Wrong_Greedy_SkipList ( object ) : <NL> <TAB> def <SPC> minimumIncompatibility ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> greedy ( nums , <SPC> k , <SPC> is_reversed ) : <NL>          count <SPC> = <SPC> collections . Counter ( nums ) <NL>          if <SPC> max ( count . itervalues ( ) ) <SPC> > <SPC> k : <NL>              return <SPC> - 1 <NL>          ordered_set <SPC> = <SPC> ( <NL>              SkipList ( ) <NL>              if <SPC> not <SPC> is_reversed <NL>              else <SPC> SkipList ( end = float ( "-inf" ) , <SPC> cmp = lambda <SPC> x , <SPC> y : <SPC> x <SPC> > <SPC> y ) <NL>          ) <NL>          freq_to_nodes <SPC> = <SPC> collections . defaultdict ( collections . OrderedDict ) <NL>          for <SPC> x <SPC> in <SPC> sorted ( count . keys ( ) , <SPC> reverse = is_reversed ) : <NL>              ordered_set . add ( x ) <NL>              freq_to_nodes [ count [ x ] ] [ x ] <SPC> = <SPC> count [ x ] <NL>          stks <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( k ) ] <NL>          curr <SPC> = <SPC> 0 <NL>          while <SPC> ordered_set : <NL>              if <SPC> ( <NL>                  len ( stks ) <SPC> - <SPC> curr <SPC> in <SPC> freq_to_nodes <NL>              ) : <NL>                  for <SPC> x <SPC> in <SPC> freq_to_nodes [ <NL>                      len ( stks ) <SPC> - <SPC> curr <NL>                  ] . iterkeys ( ) : <NL>                      for <SPC> i <SPC> in <SPC> xrange ( curr , <SPC> len ( stks ) ) : <NL>                          stks [ i ] . append ( x ) <NL>                      count . pop ( x ) <NL>                      ordered_set . remove ( ordered_set . find ( x ) ) <NL>                  freq_to_nodes . pop ( len ( stks ) <SPC> - <SPC> curr ) <NL> <NL>              it <SPC> = <SPC> ordered_set . begin ( ) <NL>              while <SPC> it <SPC> != <SPC> ordered_set . end ( ) : <NL>                  x <SPC> = <SPC> it . val <NL>                  stks [ curr ] . append ( x ) <NL>                  freq_to_nodes [ count [ x ] ] . pop ( x ) <NL>                  if <SPC> not <SPC> freq_to_nodes [ count [ x ] ] : <NL>                      freq_to_nodes . pop ( count [ x ] ) <NL>                  count [ x ] <SPC> -= <SPC> 1 <NL>                  if <SPC> not <SPC> count [ x ] : <NL>                      count . pop ( x ) <NL>                      it <SPC> = <SPC> ordered_set . remove ( it ) <NL>                  else : <NL>                      freq_to_nodes [ count [ x ] ] [ x ] <SPC> = <SPC> count [ x ] <NL>                      it <SPC> = <SPC> it . nexts [ 0 ] <NL>                  if <SPC> len ( stks [ curr ] ) <SPC> == <SPC> len ( nums ) <SPC> // <SPC> k : <NL>                      curr <SPC> += <SPC> 1 <NL>                      break <NL>          return <SPC> sum ( [ max ( stk ) <SPC> - <SPC> min ( stk ) <SPC> for <SPC> stk <SPC> in <SPC> stks ] ) <NL> <NL> <TAB> return <SPC> min ( <NL>          greedy ( nums , <SPC> k , <SPC> False ) , <SPC> greedy ( nums , <SPC> k , <SPC> True ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution_Wrong_Greedy ( object ) : <NL> <TAB> def <SPC> minimumIncompatibility ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> greedy ( nums , <SPC> k , <SPC> is_reversed ) : <NL>          count <SPC> = <SPC> collections . Counter ( nums ) <NL>          if <SPC> max ( count . itervalues ( ) ) <SPC> > <SPC> k : <NL>              return <SPC> - 1 <NL>          sorted_keys <SPC> = <SPC> sorted ( count . keys ( ) , <SPC> reverse = is_reversed ) <NL>          stks <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( k ) ] <NL>          curr , <SPC> remain <SPC> = <SPC> 0 , <SPC> len ( nums ) <NL>          while <SPC> ( <NL>              remain <NL>          ) : <NL>              for <SPC> ( <NL>                  x <NL>              ) <SPC> in <SPC> ( <NL>                  sorted_keys <NL>              ) : <NL>                  if <SPC> count [ x ] <SPC> != <SPC> len ( stks ) <SPC> - <SPC> curr : <NL>                      continue <NL>                  for <SPC> i <SPC> in <SPC> xrange ( curr , <SPC> len ( stks ) ) : <NL>                      stks [ i ] . append ( x ) <NL>                  remain <SPC> -= <SPC> count [ x ] <NL>                  count [ x ] <SPC> = <SPC> 0 <NL> <NL>              for <SPC> x <SPC> in <SPC> sorted_keys : <NL>                  if <SPC> not <SPC> count [ x ] : <NL>                      continue <NL>                  stks [ curr ] . append ( x ) <NL>                  remain <SPC> -= <SPC> 1 <NL>                  count [ x ] <SPC> -= <SPC> 1 <NL>                  if <SPC> len ( stks [ curr ] ) <SPC> == <SPC> len ( nums ) <SPC> // <SPC> k : <NL>                      curr <SPC> += <SPC> 1 <NL>                      break <NL>          return <SPC> sum ( [ max ( stk ) <SPC> - <SPC> min ( stk ) <SPC> for <SPC> stk <SPC> in <SPC> stks ] ) <NL> <NL> <TAB> return <SPC> min ( <NL>          greedy ( nums , <SPC> k , <SPC> False ) , <SPC> greedy ( nums , <SPC> k , <SPC> True ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minIncrementForUnique ( self , <SPC> A ) : <NL> <NL> <TAB> A . sort ( ) <NL> <TAB> A . append ( float ( "inf" ) ) <NL> <TAB> result , <SPC> duplicate <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) ) : <NL>          if <SPC> A [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> A [ i ] : <NL>              duplicate <SPC> += <SPC> 1 <NL>              result <SPC> -= <SPC> A [ i ] <NL>          else : <NL>              move <SPC> = <SPC> min ( duplicate , <SPC> A [ i ] <SPC> - <SPC> A [ i <SPC> - <SPC> 1 ] <SPC> - <SPC> 1 ) <NL>              duplicate <SPC> -= <SPC> move <NL>              result <SPC> += <SPC> move <SPC> * <SPC> A [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> move <SPC> * <SPC> ( move <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findRestaurant ( self , <SPC> list1 , <SPC> list2 ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> s <SPC> in <SPC> enumerate ( list1 ) : <NL>          lookup [ s ] <SPC> = <SPC> i <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> min_sum <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> j , <SPC> s <SPC> in <SPC> enumerate ( list2 ) : <NL>          if <SPC> j <SPC> > <SPC> min_sum : <NL>              break <NL>          if <SPC> s <SPC> in <SPC> lookup : <NL>              if <SPC> j <SPC> + <SPC> lookup [ s ] <SPC> < <SPC> min_sum : <NL>                  result <SPC> = <SPC> [ s ] <NL>                  min_sum <SPC> = <SPC> j <SPC> + <SPC> lookup [ s ] <NL>              elif <SPC> j <SPC> + <SPC> lookup [ s ] <SPC> == <SPC> min_sum : <NL>                  result . append ( s ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumEffort ( self , <SPC> tasks ) : <NL> <NL> <TAB> tasks . sort ( key = lambda <SPC> x : <SPC> x [ 1 ] <SPC> - <SPC> x [ 0 ] ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> ( <NL>          a , <NL>          m , <NL> <TAB> ) <SPC> in <SPC> ( <NL>          tasks <NL> <TAB> ) : <NL>          result <SPC> = <SPC> max ( result <SPC> + <SPC> a , <SPC> m ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minimumEffort ( self , <SPC> tasks ) : <NL> <NL> <TAB> tasks . sort ( key = lambda <SPC> x : <SPC> x [ 0 ] <SPC> - <SPC> x [ 1 ] ) <NL> <TAB> result <SPC> = <SPC> curr <SPC> = <SPC> 0 <NL> <TAB> for <SPC> ( <NL>          a , <NL>          m , <NL> <TAB> ) <SPC> in <SPC> ( <NL>          tasks <NL> <TAB> ) : <NL>          result <SPC> += <SPC> max ( m <SPC> - <SPC> curr , <SPC> 0 ) <NL>          curr <SPC> = <SPC> max ( curr , <SPC> m ) <SPC> - <SPC> a <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minInsertions ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> longestCommonSubsequence ( text1 , <SPC> text2 ) : <NL>          if <SPC> len ( text1 ) <SPC> < <SPC> len ( text2 ) : <NL>              return <SPC> self . longestCommonSubsequence ( text2 , <SPC> text1 ) <NL>          dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( text2 ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( text1 ) <SPC> + <SPC> 1 ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( text2 ) <SPC> + <SPC> 1 ) : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> ( <NL>                      dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 <NL>                      if <SPC> text1 [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> text2 [ j <SPC> - <SPC> 1 ] <NL>                      else <SPC> max ( dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <SPC> dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] ) <NL>                  ) <NL>          return <SPC> dp [ len ( text1 ) <SPC> % <SPC> 2 ] [ len ( text2 ) ] <NL> <NL> <TAB> return <SPC> len ( s ) <SPC> - <SPC> longestCommonSubsequence ( s , <SPC> s [ : : - 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minInsertions ( self , <SPC> s ) : <NL> <NL> <TAB> add , <SPC> bal <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          if <SPC> c <SPC> == <SPC> "(" : <NL>              if <SPC> bal <SPC> > <SPC> 0 <SPC> and <SPC> bal <SPC> % <SPC> 2 : <NL>                  add <SPC> += <SPC> 1 <NL>                  bal <SPC> -= <SPC> 1 <NL>              bal <SPC> += <SPC> 2 <NL>          else : <NL>              bal <SPC> -= <SPC> 1 <NL>              if <SPC> bal <SPC> < <SPC> 0 : <NL>                  add <SPC> += <SPC> 1 <NL>                  bal <SPC> += <SPC> 2 <NL> <TAB> return <SPC> add <SPC> + <SPC> bal <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumJumps ( self , <SPC> forbidden , <SPC> a , <SPC> b , <SPC> x ) : <NL> <NL> <TAB> max_f <SPC> = <SPC> max ( forbidden ) <NL> <TAB> max_val <SPC> = <SPC> ( <NL>          x <SPC> + <SPC> b <SPC> if <SPC> a <SPC> >= <SPC> b <SPC> else <SPC> max ( x , <SPC> max_f ) <SPC> + <SPC> a <SPC> + <SPC> ( b <SPC> + <SPC> a ) <NL> <TAB> ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> pos <SPC> in <SPC> forbidden : <NL>          lookup . add ( ( pos , <SPC> True ) ) <NL>          lookup . add ( ( pos , <SPC> False ) ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> q <SPC> = <SPC> [ ( 0 , <SPC> True ) ] <NL> <TAB> lookup . add ( ( 0 , <SPC> True ) ) <NL> <TAB> while <SPC> q : <NL>          new_q <SPC> = <SPC> [ ] <NL>          for <SPC> pos , <SPC> can_back <SPC> in <SPC> q : <NL>              if <SPC> pos <SPC> == <SPC> x : <NL>                  return <SPC> result <NL>              if <SPC> pos <SPC> + <SPC> a <SPC> <= <SPC> max_val <SPC> and <SPC> ( pos <SPC> + <SPC> a , <SPC> True ) <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( ( pos <SPC> + <SPC> a , <SPC> True ) ) <NL>                  new_q . append ( ( pos <SPC> + <SPC> a , <SPC> True ) ) <NL>              if <SPC> not <SPC> can_back : <NL>                  continue <NL>              if <SPC> pos <SPC> - <SPC> b <SPC> >= <SPC> 0 <SPC> and <SPC> ( pos <SPC> - <SPC> b , <SPC> False ) <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( ( pos <SPC> - <SPC> b , <SPC> False ) ) <NL>                  new_q . append ( ( pos <SPC> - <SPC> b , <SPC> False ) ) <NL>          q <SPC> = <SPC> new_q <NL>          result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minKnightMoves ( self , <SPC> x , <SPC> y ) : <NL> <NL> <TAB> x , <SPC> y <SPC> = <SPC> abs ( x ) , <SPC> abs ( y ) <NL> <TAB> if <SPC> x <SPC> < <SPC> y : <NL>          x , <SPC> y <SPC> = <SPC> y , <SPC> x <NL> <TAB> lookup <SPC> = <SPC> { ( 0 , <SPC> 0 ) : <SPC> 0 , <SPC> ( 1 , <SPC> 0 ) : <SPC> 3 , <SPC> ( 2 , <SPC> 2 ) : <SPC> 4 } <NL> <TAB> if <SPC> ( x , <SPC> y ) <SPC> in <SPC> lookup : <NL>          return <SPC> lookup [ ( x , <SPC> y ) ] <NL> <TAB> k <SPC> = <SPC> x <SPC> - <SPC> y <NL> <TAB> if <SPC> y <SPC> > <SPC> k : <NL> <NL>          return <SPC> k <SPC> - <SPC> 2 <SPC> * <SPC> ( ( k <SPC> - <SPC> y ) <SPC> // <SPC> 3 ) <NL> <NL> <TAB> return <SPC> k <SPC> - <SPC> 2 <SPC> * <SPC> ( ( k <SPC> - <SPC> y ) <SPC> // <SPC> 4 ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __lookup <SPC> = <SPC> { ( 0 , <SPC> 0 ) : <SPC> 0 , <SPC> ( 1 , <SPC> 1 ) : <SPC> 2 , <SPC> ( 1 , <SPC> 0 ) : <SPC> 3 } <NL> <NL> <TAB> def <SPC> minKnightMoves ( self , <SPC> x , <SPC> y ) : <NL> <NL> <TAB> def <SPC> dp ( x , <SPC> y ) : <NL>          x , <SPC> y <SPC> = <SPC> abs ( x ) , <SPC> abs ( y ) <NL>          if <SPC> x <SPC> < <SPC> y : <NL>              x , <SPC> y <SPC> = <SPC> y , <SPC> x <NL>          if <SPC> ( <NL>              x , <NL>              y , <NL>          ) <SPC> not <SPC> in <SPC> self . __lookup : <NL>              self . __lookup [ ( x , <SPC> y ) ] <SPC> = <SPC> min ( dp ( x <SPC> - <SPC> 1 , <SPC> y <SPC> - <SPC> 2 ) , <SPC> dp ( x <SPC> - <SPC> 2 , <SPC> y <SPC> - <SPC> 1 ) ) <SPC> + <SPC> 1 <NL>          return <SPC> self . __lookup [ ( x , <SPC> y ) ] <NL> <NL> <TAB> return <SPC> dp ( x , <SPC> y ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumLength ( self , <SPC> s ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( s ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          if <SPC> s [ left ] <SPC> != <SPC> s [ right ] : <NL>              break <NL>          c <SPC> = <SPC> s [ left ] <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              if <SPC> s [ left ] <SPC> != <SPC> c : <NL>                  break <NL>              left <SPC> += <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              if <SPC> s [ right ] <SPC> != <SPC> c : <NL>                  break <NL>              right <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumSize ( self , <SPC> nums , <SPC> maxOperations ) : <NL> <NL> <TAB> def <SPC> check ( nums , <SPC> maxOperations , <SPC> x ) : <NL>          return <SPC> sum ( ( num <SPC> + <SPC> x <SPC> - <SPC> 1 ) <SPC> // <SPC> x <SPC> - <SPC> 1 <SPC> for <SPC> num <SPC> in <SPC> nums ) <SPC> <= <SPC> maxOperations <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> max ( nums ) <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> check ( nums , <SPC> maxOperations , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> from <SPC> random <SPC> import <SPC> randint <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minMoves2 ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> kthElement ( nums , <SPC> k ) : <NL>          def <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) : <NL>              pivot_value <SPC> = <SPC> nums [ pivot_idx ] <NL>              new_pivot_idx <SPC> = <SPC> left <NL>              nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>                  if <SPC> nums [ i ] <SPC> > <SPC> pivot_value : <NL>                      nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                      new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>              nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>              return <SPC> new_pivot_idx <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> k : <NL>                  return <SPC> nums [ new_pivot_idx ] <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> k : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> median <SPC> = <SPC> kthElement ( nums , <SPC> len ( nums ) <SPC> // <SPC> 2 ) <NL> <TAB> return <SPC> sum ( abs ( num <SPC> - <SPC> median ) <SPC> for <SPC> num <SPC> in <SPC> nums ) <NL> <NL> <TAB> def <SPC> minMoves22 ( self , <SPC> nums ) : <NL> <NL> <TAB> median <SPC> = <SPC> sorted ( nums ) [ len ( nums ) <SPC> / <SPC> 2 ] <NL> <TAB> return <SPC> sum ( abs ( num <SPC> - <SPC> median ) <SPC> for <SPC> num <SPC> in <SPC> nums ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minMoves ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> sum ( nums ) <SPC> - <SPC> len ( nums ) <SPC> * <SPC> min ( nums ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minMoves ( self , <SPC> nums , <SPC> limit ) : <NL> <NL> <TAB> diff <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 2 <SPC> * <SPC> ( limit <SPC> + <SPC> 1 ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) <SPC> // <SPC> 2 ) : <NL>          left , <SPC> right <SPC> = <SPC> nums [ i ] , <SPC> nums [ - 1 <SPC> - <SPC> i ] <NL>          diff [ <NL>              min ( left , <SPC> right ) <SPC> + <SPC> 1 <NL>          ] <SPC> -= <SPC> 1 <NL>          diff [ <NL>              left <SPC> + <SPC> right <NL>          ] <SPC> -= <SPC> 1 <NL>          diff [ <NL>              left <SPC> + <SPC> right <SPC> + <SPC> 1 <NL>          ] <SPC> += <SPC> 1 <NL>          diff [ <NL>              max ( left , <SPC> right ) <SPC> + <SPC> limit <SPC> + <SPC> 1 <NL>          ] <SPC> += <SPC> 1 <NL> <TAB> result <SPC> = <SPC> count <SPC> = <SPC> len ( nums ) <NL> <TAB> for <SPC> total <SPC> in <SPC> xrange ( 2 , <SPC> 2 <SPC> * <SPC> limit <SPC> + <SPC> 1 ) : <NL>          count <SPC> += <SPC> diff [ total ] <NL>          result <SPC> = <SPC> min ( result , <SPC> count ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minPushBox ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> dot ( a , <SPC> b ) : <NL>          return <SPC> a [ 0 ] <SPC> * <SPC> b [ 0 ] <SPC> + <SPC> a [ 1 ] <SPC> * <SPC> b [ 1 ] <NL> <NL> <TAB> def <SPC> can_reach ( grid , <SPC> b , <SPC> p , <SPC> t ) : <NL>          closer , <SPC> detour <SPC> = <SPC> [ p ] , <SPC> [ ] <NL>          lookup <SPC> = <SPC> set ( [ b ] ) <NL>          while <SPC> closer <SPC> or <SPC> detour : <NL>              if <SPC> not <SPC> closer : <NL>                  closer , <SPC> detour <SPC> = <SPC> detour , <SPC> closer <NL>              p <SPC> = <SPC> closer . pop ( ) <NL>              if <SPC> p <SPC> == <SPC> t : <NL>                  return <SPC> True <NL>              if <SPC> p <SPC> in <SPC> lookup : <NL>                  continue <NL>              lookup . add ( p ) <NL>              for <SPC> dx , <SPC> dy <SPC> in <SPC> directions : <NL>                  np <SPC> = <SPC> ( p [ 0 ] <SPC> + <SPC> dx , <SPC> p [ 1 ] <SPC> + <SPC> dy ) <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> np [ 0 ] <SPC> < <SPC> len ( grid ) <NL>                      and <SPC> 0 <SPC> <= <SPC> np [ 1 ] <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                      and <SPC> grid [ np [ 0 ] ] [ np [ 1 ] ] <SPC> != <SPC> "#" <NL>                      and <SPC> np <SPC> not <SPC> in <SPC> lookup <NL>                  ) : <NL>                      continue <NL>                  ( <NL>                      closer <NL>                      if <SPC> dot ( ( dx , <SPC> dy ) , <SPC> ( t [ 0 ] <SPC> - <SPC> p [ 0 ] , <SPC> t [ 1 ] <SPC> - <SPC> p [ 1 ] ) ) <SPC> > <SPC> 0 <NL>                      else <SPC> detour <NL>                  ) . append ( np ) <NL>          return <SPC> False <NL> <NL> <TAB> def <SPC> g ( a , <SPC> b ) : <NL>          return <SPC> abs ( a [ 0 ] <SPC> - <SPC> b [ 0 ] ) <SPC> + <SPC> abs ( a [ 1 ] <SPC> - <SPC> b [ 1 ] ) <NL> <NL> <TAB> def <SPC> a_star ( grid , <SPC> b , <SPC> p , <SPC> t ) : <NL>          f , <SPC> dh <SPC> = <SPC> g ( b , <SPC> t ) , <SPC> 2 <NL>          closer , <SPC> detour <SPC> = <SPC> [ ( b , <SPC> p ) ] , <SPC> [ ] <NL>          lookup <SPC> = <SPC> set ( ) <NL>          while <SPC> closer <SPC> or <SPC> detour : <NL>              if <SPC> not <SPC> closer : <NL>                  f <SPC> += <SPC> dh <NL>                  closer , <SPC> detour <SPC> = <SPC> detour , <SPC> closer <NL>              b , <SPC> p <SPC> = <SPC> closer . pop ( ) <NL>              if <SPC> b <SPC> == <SPC> t : <NL>                  return <SPC> f <NL>              if <SPC> ( b , <SPC> p ) <SPC> in <SPC> lookup : <NL>                  continue <NL>              lookup . add ( ( b , <SPC> p ) ) <NL>              for <SPC> dx , <SPC> dy <SPC> in <SPC> directions : <NL>                  nb , <SPC> np <SPC> = <SPC> ( b [ 0 ] <SPC> + <SPC> dx , <SPC> b [ 1 ] <SPC> + <SPC> dy ) , <SPC> ( b [ 0 ] <SPC> - <SPC> dx , <SPC> b [ 1 ] <SPC> - <SPC> dy ) <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> nb [ 0 ] <SPC> < <SPC> len ( grid ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nb [ 1 ] <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                      and <SPC> 0 <SPC> <= <SPC> np [ 0 ] <SPC> < <SPC> len ( grid ) <NL>                      and <SPC> 0 <SPC> <= <SPC> np [ 1 ] <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                      and <SPC> grid [ nb [ 0 ] ] [ nb [ 1 ] ] <SPC> != <SPC> "#" <NL>                      and <SPC> grid [ np [ 0 ] ] [ np [ 1 ] ] <SPC> != <SPC> "#" <NL>                      and <SPC> ( nb , <SPC> b ) <SPC> not <SPC> in <SPC> lookup <NL>                      and <SPC> can_reach ( grid , <SPC> b , <SPC> p , <SPC> np ) <NL>                  ) : <NL>                      continue <NL>                  ( <NL>                      closer <NL>                      if <SPC> dot ( ( dx , <SPC> dy ) , <SPC> ( t [ 0 ] <SPC> - <SPC> b [ 0 ] , <SPC> t [ 1 ] <SPC> - <SPC> b [ 1 ] ) ) <SPC> > <SPC> 0 <NL>                      else <SPC> detour <NL>                  ) . append ( ( nb , <SPC> b ) ) <NL>          return <SPC> - 1 <NL> <NL> <TAB> b , <SPC> p , <SPC> t <SPC> = <SPC> None , <SPC> None , <SPC> None <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> == <SPC> "B" : <NL>                  b <SPC> = <SPC> ( i , <SPC> j ) <NL>              elif <SPC> grid [ i ] [ j ] <SPC> == <SPC> "S" : <NL>                  p <SPC> = <SPC> ( i , <SPC> j ) <NL>              elif <SPC> grid [ i ] [ j ] <SPC> == <SPC> "T" : <NL>                  t <SPC> = <SPC> ( i , <SPC> j ) <NL> <TAB> return <SPC> a_star ( grid , <SPC> b , <SPC> p , <SPC> t ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumMoves ( self , <SPC> grid ) : <NL> <NL> <TAB> level , <SPC> q , <SPC> lookup <SPC> = <SPC> 0 , <SPC> [ ( 0 , <SPC> 0 , <SPC> False ) ] , <SPC> set ( ) <NL> <TAB> while <SPC> q : <NL>          next_q <SPC> = <SPC> [ ] <NL>          for <SPC> r , <SPC> c , <SPC> is_vertical <SPC> in <SPC> q : <NL>              if <SPC> ( r , <SPC> c , <SPC> is_vertical ) <SPC> in <SPC> lookup : <NL>                  continue <NL>              if <SPC> ( r , <SPC> c , <SPC> is_vertical ) <SPC> == <SPC> ( len ( grid ) <SPC> - <SPC> 1 , <SPC> len ( grid ) <SPC> - <SPC> 2 , <SPC> False ) : <NL>                  return <SPC> level <NL>              lookup . add ( ( r , <SPC> c , <SPC> is_vertical ) ) <NL>              if <SPC> not <SPC> is_vertical : <NL>                  if <SPC> c <SPC> + <SPC> 2 <SPC> != <SPC> len ( grid [ 0 ] ) <SPC> and <SPC> grid [ r ] [ c <SPC> + <SPC> 2 ] <SPC> == <SPC> 0 : <NL>                      next_q . append ( ( r , <SPC> c <SPC> + <SPC> 1 , <SPC> is_vertical ) ) <NL>                  if <SPC> ( <NL>                      r <SPC> + <SPC> 1 <SPC> != <SPC> len ( grid ) <NL>                      and <SPC> grid [ r <SPC> + <SPC> 1 ] [ c ] <SPC> == <SPC> 0 <NL>                      and <SPC> grid [ r <SPC> + <SPC> 1 ] [ c <SPC> + <SPC> 1 ] <SPC> == <SPC> 0 <NL>                  ) : <NL>                      next_q . append ( ( r <SPC> + <SPC> 1 , <SPC> c , <SPC> is_vertical ) ) <NL>                      next_q . append ( ( r , <SPC> c , <SPC> not <SPC> is_vertical ) ) <NL>              else : <NL>                  if <SPC> r <SPC> + <SPC> 2 <SPC> != <SPC> len ( grid ) <SPC> and <SPC> grid [ r <SPC> + <SPC> 2 ] [ c ] <SPC> == <SPC> 0 : <NL>                      next_q . append ( ( r <SPC> + <SPC> 1 , <SPC> c , <SPC> is_vertical ) ) <NL>                  if <SPC> ( <NL>                      c <SPC> + <SPC> 1 <SPC> != <SPC> len ( grid ) <NL>                      and <SPC> grid [ r ] [ c <SPC> + <SPC> 1 ] <SPC> == <SPC> 0 <NL>                      and <SPC> grid [ r <SPC> + <SPC> 1 ] [ c <SPC> + <SPC> 1 ] <SPC> == <SPC> 0 <NL>                  ) : <NL>                      next_q . append ( ( r , <SPC> c <SPC> + <SPC> 1 , <SPC> is_vertical ) ) <NL>                      next_q . append ( ( r , <SPC> c , <SPC> not <SPC> is_vertical ) ) <NL>          q <SPC> = <SPC> next_q <NL>          level <SPC> += <SPC> 1 <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMinArrowShots ( self , <SPC> points ) : <NL> <NL> <TAB> if <SPC> not <SPC> points : <NL>          return <SPC> 0 <NL> <NL> <TAB> points . sort ( ) <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( points ) : <NL>          j <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>          right_bound <SPC> = <SPC> points [ i ] [ 1 ] <NL>          while <SPC> j <SPC> < <SPC> len ( points ) <SPC> and <SPC> points [ j ] [ 0 ] <SPC> <= <SPC> right_bound : <NL>              right_bound <SPC> = <SPC> min ( right_bound , <SPC> points [ j ] [ 1 ] ) <NL>              j <SPC> += <SPC> 1 <NL>          result <SPC> += <SPC> 1 <NL>          i <SPC> = <SPC> j <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDays ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> floodfill ( grid , <SPC> i , <SPC> j , <SPC> lookup ) : <NL>          stk <SPC> = <SPC> [ ( i , <SPC> j ) ] <NL>          lookup [ i ] [ j ] <SPC> = <SPC> 1 <NL>          while <SPC> stk : <NL>              i , <SPC> j <SPC> = <SPC> stk . pop ( ) <NL>              for <SPC> di , <SPC> dj <SPC> in <SPC> directions : <NL>                  ni , <SPC> nj <SPC> = <SPC> i <SPC> + <SPC> di , <SPC> j <SPC> + <SPC> dj <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> ni <SPC> < <SPC> len ( grid ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nj <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                      and <SPC> grid [ ni ] [ nj ] <NL>                      and <SPC> not <SPC> lookup [ ni ] [ nj ] <NL>                  ) : <NL>                      continue <NL>                  lookup [ ni ] [ nj ] <SPC> = <SPC> 1 <NL>                  stk . append ( ( ni , <SPC> nj ) ) <NL> <NL> <TAB> def <SPC> count_islands ( grid ) : <NL>          lookup <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( grid [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( grid ) ) ] <NL>          island_cnt <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>                  if <SPC> grid [ i ] [ j ] <SPC> == <SPC> 0 <SPC> or <SPC> lookup [ i ] [ j ] : <NL>                      continue <NL>                  island_cnt <SPC> += <SPC> 1 <NL>                  floodfill ( grid , <SPC> i , <SPC> j , <SPC> lookup ) <NL>          return <SPC> island_cnt <NL> <NL> <TAB> if <SPC> count_islands ( grid ) <SPC> != <SPC> 1 : <NL>          return <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> == <SPC> 0 : <NL>                  continue <NL>              grid [ i ] [ j ] <SPC> = <SPC> 0 <NL>              island_cnt <SPC> = <SPC> count_islands ( grid ) <NL>              grid [ i ] [ j ] <SPC> = <SPC> 1 <NL>              if <SPC> island_cnt <SPC> != <SPC> 1 : <NL>                  return <SPC> 1 <NL> <TAB> return <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDays ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> memoization ( lookup , <SPC> i ) : <NL>          if <SPC> i <SPC> <= <SPC> 1 : <NL>              return <SPC> i <NL>          if <SPC> i <SPC> not <SPC> in <SPC> lookup : <NL>              lookup [ i ] <SPC> = <SPC> 1 <SPC> + <SPC> min ( <NL>                  i <SPC> % <SPC> 2 <SPC> + <SPC> memoization ( lookup , <SPC> i <SPC> // <SPC> 2 ) , <NL>                  i <SPC> % <SPC> 3 <SPC> + <SPC> memoization ( lookup , <SPC> i <SPC> // <SPC> 3 ) , <NL>              ) <NL>          return <SPC> lookup [ i ] <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> return <SPC> memoization ( lookup , <SPC> n ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minDays ( self , <SPC> n ) : <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> q , <SPC> lookup <SPC> = <SPC> [ n ] , <SPC> set ( [ n ] ) <NL> <TAB> while <SPC> q : <NL>          new_q <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> q : <NL>              if <SPC> not <SPC> i : <NL>                  return <SPC> result <NL>              if <SPC> i <SPC> - <SPC> 1 <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( i <SPC> - <SPC> 1 ) <NL>                  new_q . append ( i <SPC> - <SPC> 1 ) <NL>              if <SPC> i <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> and <SPC> i <SPC> // <SPC> 2 <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( i <SPC> // <SPC> 2 ) <NL>                  new_q . append ( i <SPC> // <SPC> 2 ) <NL>              if <SPC> i <SPC> % <SPC> 3 <SPC> == <SPC> 0 <SPC> and <SPC> i <SPC> // <SPC> 3 <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( i <SPC> // <SPC> 3 ) <NL>                  new_q . append ( i <SPC> // <SPC> 3 ) <NL>          result <SPC> += <SPC> 1 <NL>          q <SPC> = <SPC> new_q <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDays ( self , <SPC> bloomDay , <SPC> m , <SPC> k ) : <NL> <NL> <TAB> def <SPC> check ( bloomDay , <SPC> m , <SPC> k , <SPC> x ) : <NL>          result <SPC> = <SPC> count <SPC> = <SPC> 0 <NL>          for <SPC> d <SPC> in <SPC> bloomDay : <NL>              count <SPC> = <SPC> count <SPC> + <SPC> 1 <SPC> if <SPC> d <SPC> <= <SPC> x <SPC> else <SPC> 0 <NL>              if <SPC> count <SPC> == <SPC> k : <NL>                  count <SPC> = <SPC> 0 <NL>                  result <SPC> += <SPC> 1 <NL>                  if <SPC> result <SPC> == <SPC> m : <NL>                      break <NL>          return <SPC> result <SPC> >= <SPC> m <NL> <NL> <TAB> if <SPC> m <SPC> * <SPC> k <SPC> > <SPC> len ( bloomDay ) : <NL>          return <SPC> - 1 <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> max ( bloomDay ) <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> check ( bloomDay , <SPC> m , <SPC> k , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minFlips ( self , <SPC> mat ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 0 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> start <SPC> = <SPC> sum ( <NL>          val <SPC> << <SPC> r <SPC> * <SPC> len ( mat [ 0 ] ) <SPC> + <SPC> c <NL>          for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( mat ) <NL>          for <SPC> c , <SPC> val <SPC> in <SPC> enumerate ( row ) <NL> <TAB> ) <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ ( start , <SPC> 0 ) ] ) <NL> <TAB> lookup <SPC> = <SPC> { start } <NL> <TAB> while <SPC> q : <NL>          state , <SPC> step <SPC> = <SPC> q . popleft ( ) <NL>          if <SPC> not <SPC> state : <NL>              return <SPC> step <NL>          for <SPC> r <SPC> in <SPC> xrange ( len ( mat ) ) : <NL>              for <SPC> c <SPC> in <SPC> xrange ( len ( mat [ 0 ] ) ) : <NL>                  new_state <SPC> = <SPC> state <NL>                  for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                      nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr , <SPC> c <SPC> + <SPC> dc <NL>                      if <SPC> 0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( mat ) <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( mat [ 0 ] ) : <NL>                          new_state <SPC> ^= <SPC> 1 <SPC> << <SPC> nr <SPC> * <SPC> len ( mat [ 0 ] ) <SPC> + <SPC> nc <NL>                  if <SPC> new_state <SPC> in <SPC> lookup : <NL>                      continue <NL>                  lookup . add ( new_state ) <NL>                  q . append ( ( new_state , <SPC> step <SPC> + <SPC> 1 ) ) <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minNumberOfFrogs ( self , <SPC> croakOfFrogs ) : <NL> <NL> <TAB> S <SPC> = <SPC> "croak" <NL> <TAB> lookup <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( S ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> croakOfFrogs : <NL>          i <SPC> = <SPC> S . find ( c ) <NL>          lookup [ i ] <SPC> += <SPC> 1 <NL>          if <SPC> lookup [ i <SPC> - <SPC> 1 ] : <NL>              lookup [ i <SPC> - <SPC> 1 ] <SPC> -= <SPC> 1 <NL>          elif <SPC> i <SPC> == <SPC> 0 : <NL>              result <SPC> += <SPC> 1 <NL>          else : <NL>              return <SPC> - 1 <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> == <SPC> lookup [ - 1 ] <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minNumberOperations ( self , <SPC> target ) : <NL> <NL> <TAB> return <SPC> target [ 0 ] <SPC> + <SPC> sum ( <NL>          max ( target [ i ] <SPC> - <SPC> target [ i <SPC> - <SPC> 1 ] , <SPC> 0 ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( target ) ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minNumberOperations ( self , <SPC> target ) : <NL> <NL> <TAB> return <SPC> sum ( max ( b <SPC> - <SPC> a , <SPC> 0 ) <SPC> for <SPC> b , <SPC> a <SPC> in <SPC> itertools . izip ( target , <SPC> [ 0 ] <SPC> + <SPC> target ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minKBitFlips ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> result , <SPC> curr <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          if <SPC> i <SPC> >= <SPC> K : <NL>              curr <SPC> -= <SPC> A [ i <SPC> - <SPC> K ] <SPC> // <SPC> 2 <NL>          if <SPC> curr <SPC> & <SPC> 1 <SPC> ^ <SPC> A [ i ] <SPC> == <SPC> 0 : <NL>              if <SPC> i <SPC> + <SPC> K <SPC> > <SPC> len ( A ) : <NL>                  return <SPC> - 1 <NL>              A [ i ] <SPC> += <SPC> 2 <NL>              curr , <SPC> result <SPC> = <SPC> curr <SPC> + <SPC> 1 , <SPC> result <SPC> + <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minOperations ( self , <SPC> boxes ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( boxes ) <NL> <TAB> for <SPC> direction <SPC> in <SPC> ( lambda <SPC> x : <SPC> x , <SPC> reversed ) : <NL>          cnt <SPC> = <SPC> accu <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> direction ( xrange ( len ( boxes ) ) ) : <NL>              result [ i ] <SPC> += <SPC> accu <NL>              if <SPC> boxes [ i ] <SPC> == <SPC> "1" : <NL>                  cnt <SPC> += <SPC> 1 <NL>              accu <SPC> += <SPC> cnt <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumTeachings ( self , <SPC> n , <SPC> languages , <SPC> friendships ) : <NL> <NL> <TAB> language_sets <SPC> = <SPC> map ( set , <SPC> languages ) <NL> <TAB> candidates <SPC> = <SPC> set ( <NL>          i <SPC> - <SPC> 1 <NL>          for <SPC> u , <SPC> v <SPC> in <SPC> friendships <NL>          if <SPC> not <SPC> language_sets [ u <SPC> - <SPC> 1 ] <SPC> & <SPC> language_sets [ v <SPC> - <SPC> 1 ] <NL>          for <SPC> i <SPC> in <SPC> [ u , <SPC> v ] <NL> <TAB> ) <NL> <TAB> count <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> candidates : <NL>          count <SPC> += <SPC> collections . Counter ( languages [ i ] ) <NL> <TAB> return <SPC> len ( candidates ) <SPC> - <SPC> max ( count . values ( ) <SPC> + <SPC> [ 0 ] ) <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minRefuelStops ( self , <SPC> target , <SPC> startFuel , <SPC> stations ) : <NL> <NL> <TAB> max_heap <SPC> = <SPC> [ ] <NL> <TAB> stations . append ( ( target , <SPC> float ( "inf" ) ) ) <NL> <NL> <TAB> result <SPC> = <SPC> prev <SPC> = <SPC> 0 <NL> <TAB> for <SPC> location , <SPC> capacity <SPC> in <SPC> stations : <NL>          startFuel <SPC> -= <SPC> location <SPC> - <SPC> prev <NL>          while <SPC> max_heap <SPC> and <SPC> startFuel <SPC> < <SPC> 0 : <NL>              startFuel <SPC> += <SPC> - heapq . heappop ( max_heap ) <NL>              result <SPC> += <SPC> 1 <NL>          if <SPC> startFuel <SPC> < <SPC> 0 : <NL>              return <SPC> - 1 <NL>          heapq . heappush ( max_heap , <SPC> - capacity ) <NL>          prev <SPC> = <SPC> location <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumMountainRemovals ( self , <SPC> nums ) : <NL> <NL> <TAB> left_lis_len <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( nums ) <NL> <TAB> lis <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) <SPC> - <SPC> 1 ) : <NL>          j <SPC> = <SPC> bisect . bisect_left ( lis , <SPC> nums [ i ] ) <NL>          if <SPC> j <SPC> == <SPC> len ( lis ) : <NL>              lis . append ( nums [ i ] ) <NL>          else : <NL>              lis [ j ] <SPC> = <SPC> nums [ i ] <NL>          left_lis_len [ i ] <SPC> = <SPC> j <NL> <TAB> max_len <SPC> = <SPC> 0 <NL> <TAB> lis <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( nums ) ) ) : <NL>          j <SPC> = <SPC> bisect . bisect_left ( lis , <SPC> nums [ i ] ) <NL>          if <SPC> j <SPC> == <SPC> len ( lis ) : <NL>              lis . append ( nums [ i ] ) <NL>          else : <NL>              lis [ j ] <SPC> = <SPC> nums [ i ] <NL>          if <SPC> i <SPC> < <SPC> len ( nums ) <SPC> - <SPC> 1 : <NL>              max_len <SPC> = <SPC> max ( max_len , <SPC> left_lis_len [ i ] <SPC> + <SPC> j ) <NL> <TAB> return <SPC> len ( nums ) <SPC> - <SPC> ( 1 <SPC> + <SPC> max_len ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minSteps ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> diff <SPC> = <SPC> collections . Counter ( s ) <SPC> - <SPC> collections . Counter ( t ) <NL> <TAB> return <SPC> sum ( diff . itervalues ( ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minTaps ( self , <SPC> n , <SPC> ranges ) : <NL> <NL> <TAB> def <SPC> jump_game ( A ) : <NL>          jump_count , <SPC> reachable , <SPC> curr_reachable <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL>          for <SPC> i , <SPC> length <SPC> in <SPC> enumerate ( A ) : <NL>              if <SPC> i <SPC> > <SPC> reachable : <NL>                  return <SPC> - 1 <NL>              if <SPC> i <SPC> > <SPC> curr_reachable : <NL>                  curr_reachable <SPC> = <SPC> reachable <NL>                  jump_count <SPC> += <SPC> 1 <NL>              reachable <SPC> = <SPC> max ( reachable , <SPC> i <SPC> + <SPC> length ) <NL>          return <SPC> jump_count <NL> <NL> <TAB> max_range <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i , <SPC> r <SPC> in <SPC> enumerate ( ranges ) : <NL>          left , <SPC> right <SPC> = <SPC> max ( i <SPC> - <SPC> r , <SPC> 0 ) , <SPC> min ( i <SPC> + <SPC> r , <SPC> n ) <NL>          max_range [ left ] <SPC> = <SPC> max ( max_range [ left ] , <SPC> right <SPC> - <SPC> left ) <NL> <TAB> return <SPC> jump_game ( max_range ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findSmallestSetOfVertices ( self , <SPC> n , <SPC> edges ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          lookup . add ( v ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          if <SPC> i <SPC> not <SPC> in <SPC> lookup : <NL>              result . append ( i ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minOperations ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> popcount ( n ) : <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> n : <NL>              n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL>              result <SPC> += <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> result , <SPC> max_len <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          result <SPC> += <SPC> popcount ( num ) <NL>          max_len <SPC> = <SPC> max ( max_len , <SPC> num . bit_length ( ) ) <NL> <TAB> return <SPC> result <SPC> + <SPC> max_len <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumOneBitOperations ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> gray_to_binary ( n ) : <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> n : <NL>              result <SPC> ^= <SPC> n <NL>              n <SPC> >>= <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> gray_to_binary ( n ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minimumOneBitOperations ( self , <SPC> n ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> n : <NL>          result <SPC> = <SPC> - result <SPC> - <SPC> ( n <SPC> ^ <SPC> ( n <SPC> - <SPC> 1 ) ) <NL>          n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL> <TAB> return <SPC> abs ( result ) <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minOperations ( self , <SPC> target , <SPC> arr ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { x : <SPC> i <SPC> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( target ) } <NL> <TAB> lis <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> x <SPC> in <SPC> arr : <NL>          if <SPC> x <SPC> not <SPC> in <SPC> lookup : <NL>              continue <NL>          i <SPC> = <SPC> bisect . bisect_left ( lis , <SPC> lookup [ x ] ) <NL>          if <SPC> i <SPC> == <SPC> len ( lis ) : <NL>              lis . append ( lookup [ x ] ) <NL>          else : <NL>              lis [ i ] <SPC> = <SPC> lookup [ x ] <NL> <TAB> return <SPC> len ( target ) <SPC> - <SPC> len ( lis ) <NL> <NL> <NL> class <SPC> SegmentTree ( object ) : <NL> <TAB> def <SPC> __init__ ( <NL>          self , <NL>          N , <NL>          build_fn = lambda <SPC> x , <SPC> y : <SPC> [ y ] <SPC> * <SPC> ( 2 <SPC> * <SPC> x ) , <NL>          query_fn = lambda <SPC> x , <SPC> y : <SPC> y <NL>          if <SPC> x <SPC> is <SPC> None <NL>          else <SPC> max ( x , <SPC> y ) , <NL>          update_fn = lambda <SPC> x , <SPC> y : <SPC> y , <NL>          default_val = 0 , <NL> <TAB> ) : <NL> <TAB> self . N <SPC> = <SPC> N <NL> <TAB> self . H <SPC> = <SPC> ( N <SPC> - <SPC> 1 ) . bit_length ( ) <NL> <TAB> self . query_fn <SPC> = <SPC> query_fn <NL> <TAB> self . update_fn <SPC> = <SPC> update_fn <NL> <TAB> self . default_val <SPC> = <SPC> default_val <NL> <TAB> self . tree <SPC> = <SPC> build_fn ( N , <SPC> default_val ) <NL> <TAB> self . lazy <SPC> = <SPC> [ None ] <SPC> * <SPC> N <NL> <NL> <TAB> def <SPC> __apply ( self , <SPC> x , <SPC> val ) : <NL> <TAB> self . tree [ x ] <SPC> = <SPC> self . update_fn ( self . tree [ x ] , <SPC> val ) <NL> <TAB> if <SPC> x <SPC> < <SPC> self . N : <NL>          self . lazy [ x ] <SPC> = <SPC> self . update_fn ( self . lazy [ x ] , <SPC> val ) <NL> <NL> <TAB> def <SPC> update ( self , <SPC> L , <SPC> R , <SPC> h ) : <NL> <NL> <TAB> def <SPC> pull ( x ) : <NL>          while <SPC> x <SPC> > <SPC> 1 : <NL>              x <SPC> //= <SPC> 2 <NL>              self . tree [ x ] <SPC> = <SPC> self . query_fn ( <NL>                  self . tree [ x <SPC> * <SPC> 2 ] , <SPC> self . tree [ x <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] ) <NL>              if <SPC> self . lazy [ x ] <SPC> is <SPC> not <SPC> None : <NL>                  self . tree [ x ] <SPC> = <SPC> self . update_fn ( self . tree [ x ] , <SPC> self . lazy [ x ] ) <NL> <NL> <TAB> L <SPC> += <SPC> self . N <NL> <TAB> R <SPC> += <SPC> self . N <NL> <TAB> L0 , <SPC> R0 <SPC> = <SPC> L , <SPC> R <NL> <TAB> while <SPC> L <SPC> <= <SPC> R : <NL>          if <SPC> L <SPC> & <SPC> 1 : <NL>              self . __apply ( L , <SPC> h ) <NL>              L <SPC> += <SPC> 1 <NL>          if <SPC> R <SPC> & <SPC> 1 <SPC> == <SPC> 0 : <NL>              self . __apply ( R , <SPC> h ) <NL>              R <SPC> -= <SPC> 1 <NL>          L <SPC> //= <SPC> 2 <NL>          R <SPC> //= <SPC> 2 <NL> <TAB> pull ( L0 ) <NL> <TAB> pull ( R0 ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> L , <SPC> R ) : <NL> <NL> <TAB> def <SPC> push ( x ) : <NL>          n <SPC> = <SPC> 2 <SPC> ** <SPC> self . H <NL>          while <SPC> n <SPC> != <SPC> 1 : <NL>              y <SPC> = <SPC> x <SPC> // <SPC> n <NL>              if <SPC> self . lazy [ y ] <SPC> is <SPC> not <SPC> None : <NL>                  self . __apply ( y <SPC> * <SPC> 2 , <SPC> self . lazy [ y ] ) <NL>                  self . __apply ( y <SPC> * <SPC> 2 <SPC> + <SPC> 1 , <SPC> self . lazy [ y ] ) <NL>                  self . lazy [ y ] <SPC> = <SPC> None <NL>              n <SPC> //= <SPC> 2 <NL> <NL> <TAB> result <SPC> = <SPC> None <NL> <TAB> if <SPC> L <SPC> > <SPC> R : <NL>          return <SPC> result <NL> <NL> <TAB> L <SPC> += <SPC> self . N <NL> <TAB> R <SPC> += <SPC> self . N <NL> <TAB> push ( L ) <NL> <TAB> push ( R ) <NL> <TAB> while <SPC> L <SPC> <= <SPC> R : <NL>          if <SPC> L <SPC> & <SPC> 1 : <NL>              result <SPC> = <SPC> self . query_fn ( result , <SPC> self . tree [ L ] ) <NL>              L <SPC> += <SPC> 1 <NL>          if <SPC> R <SPC> & <SPC> 1 <SPC> == <SPC> 0 : <NL>              result <SPC> = <SPC> self . query_fn ( result , <SPC> self . tree [ R ] ) <NL>              R <SPC> -= <SPC> 1 <NL>          L <SPC> //= <SPC> 2 <NL>          R <SPC> //= <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> __str__ ( self ) : <NL> <TAB> showList <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . N ) : <NL>          showList . append ( self . query ( i , <SPC> i ) ) <NL> <TAB> return <SPC> "," . join ( map ( str , <SPC> showList ) ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minOperations ( self , <SPC> target , <SPC> arr ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { x : <SPC> i <SPC> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( target ) } <NL> <TAB> st <SPC> = <SPC> SegmentTree ( len ( lookup ) ) <NL> <TAB> for <SPC> x <SPC> in <SPC> arr : <NL>          if <SPC> x <SPC> not <SPC> in <SPC> lookup : <NL>              continue <NL>          st . update ( <NL>              lookup [ x ] , <NL>              lookup [ x ] , <NL>              st . query ( 0 , <SPC> lookup [ x ] <SPC> - <SPC> 1 ) <SPC> + <SPC> 1 <SPC> if <SPC> lookup [ x ] <SPC> >= <SPC> 1 <SPC> else <SPC> 1 , <NL>          ) <NL> <TAB> return <SPC> len ( target ) <SPC> - <SPC> ( st . query ( 0 , <SPC> len ( lookup ) <SPC> - <SPC> 1 ) <SPC> if <SPC> len ( lookup ) <SPC> >= <SPC> 1 <SPC> else <SPC> 0 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minOperations ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> ( n <SPC> // <SPC> 2 ) <SPC> * <SPC> ( ( n <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minOperations ( self , <SPC> nums , <SPC> x ) : <NL> <NL> <TAB> target <SPC> = <SPC> sum ( nums ) <SPC> - <SPC> x <NL> <TAB> result <SPC> = <SPC> - 1 <NL> <TAB> curr <SPC> = <SPC> left <SPC> = <SPC> 0 <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          curr <SPC> += <SPC> nums [ right ] <NL>          while <SPC> left <SPC> < <SPC> len ( nums ) <SPC> and <SPC> curr <SPC> > <SPC> target : <NL>              curr <SPC> -= <SPC> nums [ left ] <NL>              left <SPC> += <SPC> 1 <NL>          if <SPC> curr <SPC> == <SPC> target : <NL>              result <SPC> = <SPC> max ( result , <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> len ( nums ) <SPC> - <SPC> result <SPC> if <SPC> result <SPC> != <SPC> - 1 <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> minPathSum ( self , <SPC> grid ) : <NL> <TAB> sum <SPC> = <SPC> list ( grid [ 0 ] ) <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( grid [ 0 ] ) ) : <NL>          sum [ j ] <SPC> = <SPC> sum [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> grid [ 0 ] [ j ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( grid ) ) : <NL>          sum [ 0 ] <SPC> += <SPC> grid [ i ] [ 0 ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( grid [ 0 ] ) ) : <NL>              sum [ j ] <SPC> = <SPC> min ( sum [ j <SPC> - <SPC> 1 ] , <SPC> sum [ j ] ) <SPC> + <SPC> grid [ i ] [ j ] <NL> <NL> <TAB> return <SPC> sum [ - 1 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> BIT ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . __bit <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <NL> <TAB> def <SPC> add ( self , <SPC> i , <SPC> val ) : <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( self . __bit ) : <NL>          self . __bit [ i ] <SPC> += <SPC> val <NL>          i <SPC> += <SPC> i <SPC> & <SPC> - i <NL> <NL> <TAB> def <SPC> sum ( self , <SPC> i ) : <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> > <SPC> 0 : <NL>          result <SPC> += <SPC> self . __bit [ i ] <NL>          i <SPC> -= <SPC> i <SPC> & <SPC> - i <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minInteger ( self , <SPC> num , <SPC> k ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> bit <SPC> = <SPC> BIT ( len ( num ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( num ) ) ) : <NL>          bit . add ( i <SPC> + <SPC> 1 , <SPC> 1 ) <NL>          lookup [ int ( num [ i ] ) ] . append ( i <SPC> + <SPC> 1 ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( len ( num ) ) : <NL>          for <SPC> d <SPC> in <SPC> xrange ( 10 ) : <NL>              if <SPC> lookup [ d ] <SPC> and <SPC> bit . sum ( lookup [ d ] [ - 1 ] <SPC> - <SPC> 1 ) <SPC> <= <SPC> k : <NL>                  k <SPC> -= <SPC> bit . sum ( lookup [ d ] [ - 1 ] <SPC> - <SPC> 1 ) <NL>                  bit . add ( lookup [ d ] . pop ( ) , <SPC> - 1 ) <NL>                  result . append ( d ) <NL>                  break <NL> <TAB> return <SPC> "" . join ( map ( str , <SPC> result ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minRemoveToMakeValid ( self , <SPC> s ) : <NL> <NL> <TAB> result <SPC> = <SPC> list ( s ) <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( result ) : <NL>          if <SPC> v <SPC> == <SPC> "(" : <NL>              count <SPC> += <SPC> 1 <NL>          elif <SPC> v <SPC> == <SPC> ")" : <NL>              if <SPC> count : <NL>                  count <SPC> -= <SPC> 1 <NL>              else : <NL>                  result [ i ] <SPC> = <SPC> "" <NL> <TAB> if <SPC> count : <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( result ) ) ) : <NL>              if <SPC> result [ i ] <SPC> == <SPC> "(" : <NL>                  result [ i ] <SPC> = <SPC> "" <NL>                  count <SPC> -= <SPC> 1 <NL>                  if <SPC> not <SPC> count : <NL>                      break <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minScoreTriangulation ( self , <SPC> A ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( A ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( A ) ) ] <NL> <TAB> for <SPC> p <SPC> in <SPC> xrange ( 3 , <SPC> len ( A ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( A ) <SPC> - <SPC> p <SPC> + <SPC> 1 ) : <NL>              j <SPC> = <SPC> i <SPC> + <SPC> p <SPC> - <SPC> 1 <NL>              dp [ i ] [ j ] <SPC> = <SPC> float ( "inf" ) <NL>              for <SPC> k <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> j ) : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> dp [ i ] [ k ] <SPC> + <SPC> dp [ k ] <NL>                                 [ j ] <SPC> + <SPC> A [ i ] <SPC> * <SPC> A [ j ] <SPC> * <SPC> A [ k ] ) <NL> <TAB> return <SPC> dp [ 0 ] [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> minSubArrayLen ( self , <SPC> s , <SPC> nums ) : <NL> <TAB> start <SPC> = <SPC> 0 <NL> <TAB> sum <SPC> = <SPC> 0 <NL> <TAB> min_size <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          sum <SPC> += <SPC> nums [ i ] <NL>          while <SPC> sum <SPC> >= <SPC> s : <NL>              min_size <SPC> = <SPC> min ( min_size , <SPC> i <SPC> - <SPC> start <SPC> + <SPC> 1 ) <NL>              sum <SPC> -= <SPC> nums [ start ] <NL>              start <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> min_size <SPC> if <SPC> min_size <SPC> != <SPC> float ( "inf" ) <SPC> else <SPC> 0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> minSubArrayLen ( self , <SPC> s , <SPC> nums ) : <NL> <TAB> min_size <SPC> = <SPC> float ( "inf" ) <NL> <TAB> sum_from_start <SPC> = <SPC> [ n <SPC> for <SPC> n <SPC> in <SPC> nums ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( sum_from_start ) <SPC> - <SPC> 1 ) : <NL>          sum_from_start [ i <SPC> + <SPC> 1 ] <SPC> += <SPC> sum_from_start [ i ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( sum_from_start ) ) : <NL>          end <SPC> = <SPC> self . binarySearch ( <NL>              lambda <SPC> x , <SPC> y : <SPC> x <SPC> <= <SPC> y , <NL>              sum_from_start , <NL>              i , <NL>              len ( sum_from_start ) , <NL>              sum_from_start [ i ] <SPC> - <SPC> nums [ i ] <SPC> + <SPC> s , <NL>          ) <NL>          if <SPC> end <SPC> < <SPC> len ( sum_from_start ) : <NL>              min_size <SPC> = <SPC> min ( min_size , <SPC> end <SPC> - <SPC> i <SPC> + <SPC> 1 ) <NL> <NL> <TAB> return <SPC> min_size <SPC> if <SPC> min_size <SPC> != <SPC> float ( "inf" ) <SPC> else <SPC> 0 <NL> <NL> <TAB> def <SPC> binarySearch ( self , <SPC> compare , <SPC> A , <SPC> start , <SPC> end , <SPC> target ) : <NL> <TAB> while <SPC> start <SPC> < <SPC> end : <NL>          mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> / <SPC> 2 <NL>          if <SPC> compare ( target , <SPC> A [ mid ] ) : <NL>              end <SPC> = <SPC> mid <NL>          else : <NL>              start <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> start <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minSubsequence ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> total , <SPC> curr <SPC> = <SPC> [ ] , <SPC> sum ( nums ) , <SPC> 0 <NL> <TAB> nums . sort ( reverse = True ) <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( nums ) : <NL>          curr <SPC> += <SPC> x <NL>          if <SPC> curr <SPC> > <SPC> total <SPC> - <SPC> curr : <NL>              break <NL> <TAB> return <SPC> nums [ : <SPC> i <SPC> + <SPC> 1 ] <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minSwaps ( self , <SPC> grid ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> target <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( grid ) ) ) : <NL>          row_idx <SPC> = <SPC> len ( grid ) <SPC> - <SPC> 1 <SPC> - <SPC> target <NL>          while <SPC> row_idx <SPC> < <SPC> len ( grid ) : <NL>              row <SPC> = <SPC> grid [ row_idx ] <NL>              if <SPC> not <SPC> sum ( itertools . islice ( row , <SPC> len ( row ) <SPC> - <SPC> target , <SPC> len ( row ) ) ) : <NL>                  break <NL>              row_idx <SPC> += <SPC> 1 <NL>          else : <NL>              return <SPC> - 1 <NL>          while <SPC> row_idx <SPC> != <SPC> len ( grid ) <SPC> - <SPC> 1 <SPC> - <SPC> target : <NL>              grid [ row_idx ] , <SPC> grid [ row_idx <SPC> - <SPC> 1 ] <SPC> = <SPC> grid [ row_idx <SPC> - <SPC> 1 ] , <SPC> grid [ row_idx ] <NL>              result <SPC> += <SPC> 1 <NL>              row_idx <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minSwaps ( self , <SPC> data ) : <NL> <NL> <TAB> total_count <SPC> = <SPC> sum ( data ) <NL> <TAB> result , <SPC> count , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( data ) ) : <NL>          count <SPC> += <SPC> data [ i ] <NL>          if <SPC> i <SPC> - <SPC> left <SPC> + <SPC> 1 <SPC> > <SPC> total_count : <NL>              count <SPC> -= <SPC> data [ left ] <NL>              left <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> max ( result , <SPC> count ) <NL> <TAB> return <SPC> total_count <SPC> - <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minSwap ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> dp_no_swap , <SPC> dp_swap <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 , <SPC> [ 1 ] <SPC> * <SPC> 2 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) ) : <NL>          dp_no_swap [ i <SPC> % <SPC> 2 ] , <SPC> dp_swap [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> float ( "inf" ) , <SPC> float ( "inf" ) <NL>          if <SPC> A [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> A [ i ] <SPC> and <SPC> B [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> B [ i ] : <NL>              dp_no_swap [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> min ( dp_no_swap [ i <SPC> % <SPC> 2 ] , <SPC> dp_no_swap [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] ) <NL>              dp_swap [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> min ( dp_swap [ i <SPC> % <SPC> 2 ] , <SPC> dp_swap [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] <SPC> + <SPC> 1 ) <NL>          if <SPC> A [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> B [ i ] <SPC> and <SPC> B [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> A [ i ] : <NL>              dp_no_swap [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> min ( dp_no_swap [ i <SPC> % <SPC> 2 ] , <SPC> dp_swap [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] ) <NL>              dp_swap [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> min ( dp_swap [ i <SPC> % <SPC> 2 ] , <SPC> dp_no_swap [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> min ( dp_no_swap [ ( len ( A ) <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] , <SPC> dp_swap [ ( len ( A ) <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumSwap ( self , <SPC> s1 , <SPC> s2 ) : <NL> <NL> <TAB> x1 , <SPC> y1 <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s1 ) ) : <NL>          if <SPC> s1 [ i ] <SPC> == <SPC> s2 [ i ] : <NL>              continue <NL>          x1 <SPC> += <SPC> int ( s1 [ i ] <SPC> == <SPC> "x" ) <NL>          y1 <SPC> += <SPC> int ( s1 [ i ] <SPC> == <SPC> "y" ) <NL> <TAB> if <SPC> x1 <SPC> % <SPC> 2 <SPC> != <SPC> y1 <SPC> % <SPC> 2 : <NL>          return <SPC> - 1 <NL> <NL> <TAB> return <SPC> ( x1 <SPC> // <SPC> 2 <SPC> + <SPC> y1 <SPC> // <SPC> 2 ) <SPC> + <SPC> ( x1 <SPC> % <SPC> 2 <SPC> + <SPC> y1 <SPC> % <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMinDifference ( self , <SPC> timePoints ) : <NL> <NL> <TAB> minutes <SPC> = <SPC> map ( lambda <SPC> x : <SPC> int ( x [ : 2 ] ) <SPC> * <SPC> 60 <SPC> + <SPC> int ( x [ 3 : ] ) , <SPC> timePoints ) <NL> <TAB> minutes . sort ( ) <NL> <TAB> return <SPC> min ( <NL>          ( y <SPC> - <SPC> x ) <SPC> % <SPC> ( 24 <SPC> * <SPC> 60 ) <SPC> for <SPC> x , <SPC> y <SPC> in <SPC> zip ( minutes , <SPC> minutes [ 1 : ] <SPC> + <SPC> minutes [ : 1 ] ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minBuildTime ( self , <SPC> blocks , <SPC> split ) : <NL> <NL> <TAB> heapq . heapify ( blocks ) <NL> <TAB> while <SPC> len ( blocks ) <SPC> != <SPC> 1 : <NL>          x , <SPC> y <SPC> = <SPC> heapq . heappop ( blocks ) , <SPC> heapq . heappop ( blocks ) <NL>          heapq . heappush ( blocks , <SPC> y <SPC> + <SPC> split ) <NL> <TAB> return <SPC> heapq . heappop ( blocks ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minTime ( self , <SPC> n , <SPC> edges , <SPC> hasApple ) : <NL> <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          graph [ u ] . append ( v ) <NL>          graph [ v ] . append ( u ) <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 , <SPC> 0 ] <NL> <TAB> s <SPC> = <SPC> [ ( 1 , <SPC> ( - 1 , <SPC> 0 , <SPC> result ) ) ] <NL> <TAB> while <SPC> s : <NL>          step , <SPC> params <SPC> = <SPC> s . pop ( ) <NL>          if <SPC> step <SPC> == <SPC> 1 : <NL>              par , <SPC> node , <SPC> ret <SPC> = <SPC> params <NL>              ret [ : ] <SPC> = <SPC> [ 0 , <SPC> int ( hasApple [ node ] ) ] <NL>              for <SPC> nei <SPC> in <SPC> reversed ( graph [ node ] ) : <NL>                  if <SPC> nei <SPC> == <SPC> par : <NL>                      continue <NL>                  new_ret <SPC> = <SPC> [ 0 , <SPC> 0 ] <NL>                  s . append ( ( 2 , <SPC> ( new_ret , <SPC> ret ) ) ) <NL>                  s . append ( ( 1 , <SPC> ( node , <SPC> nei , <SPC> new_ret ) ) ) <NL>          else : <NL>              new_ret , <SPC> ret <SPC> = <SPC> params <NL>              ret [ 0 ] <SPC> += <SPC> new_ret [ 0 ] <SPC> + <SPC> new_ret [ 1 ] <NL>              ret [ 1 ] <SPC> |= <SPC> bool ( new_ret [ 0 ] <SPC> + <SPC> new_ret [ 1 ] ) <NL> <TAB> return <SPC> 2 <SPC> * <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution_Recu ( object ) : <NL> <TAB> def <SPC> minTime ( self , <SPC> n , <SPC> edges , <SPC> hasApple ) : <NL> <NL> <TAB> def <SPC> dfs ( graph , <SPC> par , <SPC> node , <SPC> hasApple ) : <NL>          result , <SPC> extra <SPC> = <SPC> 0 , <SPC> int ( hasApple [ node ] ) <NL>          for <SPC> nei <SPC> in <SPC> graph [ node ] : <NL>              if <SPC> nei <SPC> == <SPC> par : <NL>                  continue <NL>              count , <SPC> found <SPC> = <SPC> dfs ( graph , <SPC> node , <SPC> nei , <SPC> hasApple ) <NL>              result <SPC> += <SPC> count <SPC> + <SPC> found <NL>              extra <SPC> |= <SPC> bool ( count <SPC> + <SPC> found ) <NL>          return <SPC> result , <SPC> extra <NL> <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          graph [ u ] . append ( v ) <NL>          graph [ v ] . append ( u ) <NL> <TAB> return <SPC> 2 <SPC> * <SPC> dfs ( graph , <SPC> - 1 , <SPC> 0 , <SPC> hasApple ) [ 0 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minTime ( self , <SPC> n , <SPC> edges , <SPC> hasApple ) : <NL> <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          graph [ u ] . append ( v ) <NL>          graph [ v ] . append ( u ) <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> s <SPC> = <SPC> [ ( 1 , <SPC> ( - 1 , <SPC> 0 , <SPC> result ) ) ] <NL> <TAB> while <SPC> s : <NL>          step , <SPC> params <SPC> = <SPC> s . pop ( ) <NL>          if <SPC> step <SPC> == <SPC> 1 : <NL>              par , <SPC> node , <SPC> ret <SPC> = <SPC> params <NL>              tmp <SPC> = <SPC> [ int ( hasApple [ node ] ) ] <NL>              s . append ( ( 3 , <SPC> ( tmp , <SPC> ret ) ) ) <NL>              for <SPC> nei <SPC> in <SPC> reversed ( graph [ node ] ) : <NL>                  if <SPC> nei <SPC> == <SPC> par : <NL>                      continue <NL>                  new_ret <SPC> = <SPC> [ 0 ] <NL>                  s . append ( ( 2 , <SPC> ( new_ret , <SPC> tmp , <SPC> ret ) ) ) <NL>                  s . append ( ( 1 , <SPC> ( node , <SPC> nei , <SPC> new_ret ) ) ) <NL>          elif <SPC> step <SPC> == <SPC> 2 : <NL>              new_ret , <SPC> tmp , <SPC> ret <SPC> = <SPC> params <NL>              ret [ 0 ] <SPC> += <SPC> new_ret [ 0 ] <NL>              tmp [ 0 ] <SPC> |= <SPC> bool ( new_ret [ 0 ] ) <NL>          else : <NL>              tmp , <SPC> ret <SPC> = <SPC> params <NL>              ret [ 0 ] <SPC> += <SPC> tmp [ 0 ] <NL> <TAB> return <SPC> 2 <SPC> * <SPC> max ( result [ 0 ] <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <NL> class <SPC> Solution2_Recu ( object ) : <NL> <TAB> def <SPC> minTime ( self , <SPC> n , <SPC> edges , <SPC> hasApple ) : <NL> <NL> <TAB> def <SPC> dfs ( graph , <SPC> par , <SPC> node , <SPC> has_subtree ) : <NL>          result , <SPC> extra <SPC> = <SPC> 0 , <SPC> int ( hasApple [ node ] ) <NL>          for <SPC> nei <SPC> in <SPC> graph [ node ] : <NL>              if <SPC> nei <SPC> == <SPC> par : <NL>                  continue <NL>              count <SPC> = <SPC> dfs ( graph , <SPC> node , <SPC> nei , <SPC> hasApple ) <NL>              result <SPC> += <SPC> count <NL>              extra <SPC> |= <SPC> bool ( count ) <NL>          return <SPC> result <SPC> + <SPC> extra <NL> <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          graph [ u ] . append ( v ) <NL>          graph [ v ] . append ( u ) <NL> <TAB> return <SPC> 2 <SPC> * <SPC> max ( dfs ( graph , <SPC> - 1 , <SPC> 0 , <SPC> hasApple ) <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minTimeToVisitAllPoints ( self , <SPC> points ) : <NL> <NL> <TAB> return <SPC> sum ( <NL>          max ( <NL>              abs ( points [ i <SPC> + <SPC> 1 ] [ 0 ] <SPC> - <SPC> points [ i ] [ 0 ] ) , <NL>              abs ( points [ i <SPC> + <SPC> 1 ] [ 1 ] <SPC> - <SPC> points [ i ] [ 1 ] ) , <NL>          ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( points ) <SPC> - <SPC> 1 ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minAbbreviation ( self , <SPC> target , <SPC> dictionary ) : <NL> <NL> <TAB> def <SPC> bits_to_abbr_len ( targets , <SPC> bits ) : <NL>          total <SPC> = <SPC> 0 <NL>          pre <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( target ) ) : <NL>              if <SPC> bits <SPC> & <SPC> 1 : <NL>                  if <SPC> i <SPC> - <SPC> pre <SPC> > <SPC> 0 : <NL>                      total <SPC> += <SPC> len ( str ( i <SPC> - <SPC> pre ) ) <NL>                  pre <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>                  total <SPC> += <SPC> 1 <NL>              elif <SPC> i <SPC> == <SPC> len ( target ) <SPC> - <SPC> 1 : <NL>                  total <SPC> += <SPC> len ( str ( i <SPC> - <SPC> pre <SPC> + <SPC> 1 ) ) <NL>              bits <SPC> >>= <SPC> 1 <NL>          return <SPC> total <NL> <NL> <TAB> def <SPC> bits_to_abbr ( targets , <SPC> bits ) : <NL>          abbr <SPC> = <SPC> [ ] <NL>          pre <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( target ) ) : <NL>              if <SPC> bits <SPC> & <SPC> 1 : <NL>                  if <SPC> i <SPC> - <SPC> pre <SPC> > <SPC> 0 : <NL>                      abbr . append ( str ( i <SPC> - <SPC> pre ) ) <NL>                  pre <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>                  abbr . append ( target [ i ] ) <NL>              elif <SPC> i <SPC> == <SPC> len ( target ) <SPC> - <SPC> 1 : <NL>                  abbr . append ( str ( i <SPC> - <SPC> pre <SPC> + <SPC> 1 ) ) <NL>              bits <SPC> >>= <SPC> 1 <NL>          return <SPC> "" . join ( abbr ) <NL> <NL> <TAB> diffs <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> word <SPC> in <SPC> dictionary : <NL>          if <SPC> len ( word ) <SPC> != <SPC> len ( target ) : <NL>              continue <NL>          diffs . append ( sum ( 2 <SPC> ** <SPC> i <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( word ) <SPC> if <SPC> target [ i ] <SPC> != <SPC> c ) ) <NL> <NL> <TAB> if <SPC> not <SPC> diffs : <NL>          return <SPC> str ( len ( target ) ) <NL> <NL> <TAB> result <SPC> = <SPC> 2 <SPC> ** <SPC> len ( target ) <SPC> - <SPC> 1 <NL> <TAB> for <SPC> mask <SPC> in <SPC> xrange ( 2 <SPC> ** <SPC> len ( target ) ) : <NL>          if <SPC> all ( d <SPC> & <SPC> mask <SPC> for <SPC> d <SPC> in <SPC> diffs ) <SPC> and <SPC> bits_to_abbr_len ( <NL>              target , <SPC> mask <NL>          ) <SPC> < <SPC> bits_to_abbr_len ( target , <SPC> result ) : <NL>              result <SPC> = <SPC> mask <NL> <TAB> return <SPC> bits_to_abbr ( target , <SPC> result ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minAbbreviation ( self , <SPC> target , <SPC> dictionary ) : <NL> <NL> <TAB> def <SPC> bits_to_abbr ( targets , <SPC> bits ) : <NL>          abbr <SPC> = <SPC> [ ] <NL>          pre <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( target ) ) : <NL>              if <SPC> bits <SPC> & <SPC> 1 : <NL>                  if <SPC> i <SPC> - <SPC> pre <SPC> > <SPC> 0 : <NL>                      abbr . append ( str ( i <SPC> - <SPC> pre ) ) <NL>                  pre <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>                  abbr . append ( target [ i ] ) <NL>              elif <SPC> i <SPC> == <SPC> len ( target ) <SPC> - <SPC> 1 : <NL>                  abbr . append ( str ( i <SPC> - <SPC> pre <SPC> + <SPC> 1 ) ) <NL>              bits <SPC> >>= <SPC> 1 <NL>          return <SPC> "" . join ( abbr ) <NL> <NL> <TAB> diffs <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> word <SPC> in <SPC> dictionary : <NL>          if <SPC> len ( word ) <SPC> != <SPC> len ( target ) : <NL>              continue <NL>          diffs . append ( sum ( 2 <SPC> ** <SPC> i <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( word ) <SPC> if <SPC> target [ i ] <SPC> != <SPC> c ) ) <NL> <NL> <TAB> if <SPC> not <SPC> diffs : <NL>          return <SPC> str ( len ( target ) ) <NL> <NL> <TAB> result <SPC> = <SPC> target <NL> <TAB> for <SPC> mask <SPC> in <SPC> xrange ( 2 <SPC> ** <SPC> len ( target ) ) : <NL>          abbr <SPC> = <SPC> bits_to_abbr ( target , <SPC> mask ) <NL>          if <SPC> all ( d <SPC> & <SPC> mask <SPC> for <SPC> d <SPC> in <SPC> diffs ) <SPC> and <SPC> len ( abbr ) <SPC> < <SPC> len ( result ) : <NL>              result <SPC> = <SPC> abbr <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minStartValue ( self , <SPC> nums ) : <NL> <NL> <TAB> min_prefix , <SPC> prefix <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          prefix <SPC> += <SPC> num <NL>          min_prefix <SPC> = <SPC> min ( min_prefix , <SPC> prefix ) <NL> <TAB> return <SPC> 1 <SPC> - <SPC> min_prefix <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minWindow ( self , <SPC> S , <SPC> T ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> [ [ None <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 26 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( S ) <SPC> + <SPC> 1 ) ] <NL> <TAB> find_char_next_pos <SPC> = <SPC> [ None ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( S ) ) ) : <NL>          find_char_next_pos [ ord ( S [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>          lookup [ i ] <SPC> = <SPC> list ( find_char_next_pos ) <NL> <NL> <TAB> min_i , <SPC> min_len <SPC> = <SPC> None , <SPC> float ( "inf" ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( S ) ) : <NL>          if <SPC> S [ i ] <SPC> != <SPC> T [ 0 ] : <NL>              continue <NL>          start <SPC> = <SPC> i <NL>          for <SPC> c <SPC> in <SPC> T : <NL>              start <SPC> = <SPC> lookup [ start ] [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <NL>              if <SPC> start <SPC> == <SPC> None : <NL>                  break <NL>          else : <NL>              if <SPC> start <SPC> - <SPC> i <SPC> < <SPC> min_len : <NL>                  min_i , <SPC> min_len <SPC> = <SPC> i , <SPC> start <SPC> - <SPC> i <NL> <TAB> return <SPC> S [ min_i : <SPC> min_i <SPC> + <SPC> min_len ] <SPC> if <SPC> min_i <SPC> is <SPC> not <SPC> None <SPC> else <SPC> "" <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minWindow ( self , <SPC> S , <SPC> T ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ None <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( S ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> j , <SPC> c <SPC> in <SPC> enumerate ( S ) : <NL>          if <SPC> c <SPC> == <SPC> T [ 0 ] : <NL>              dp [ 0 ] [ j ] <SPC> = <SPC> j <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( T ) ) : <NL>          prev <SPC> = <SPC> None <NL>          dp [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> [ None ] <SPC> * <SPC> len ( S ) <NL>          for <SPC> j , <SPC> c <SPC> in <SPC> enumerate ( S ) : <NL>              if <SPC> prev <SPC> is <SPC> not <SPC> None <SPC> and <SPC> c <SPC> == <SPC> T [ i ] : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> prev <NL>              if <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <SPC> is <SPC> not <SPC> None : <NL>                  prev <SPC> = <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <NL> <NL> <TAB> start , <SPC> end <SPC> = <SPC> 0 , <SPC> len ( S ) <NL> <TAB> for <SPC> j , <SPC> i <SPC> in <SPC> enumerate ( dp [ ( len ( T ) <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] ) : <NL>          if <SPC> i <SPC> >= <SPC> 0 <SPC> and <SPC> j <SPC> - <SPC> i <SPC> < <SPC> end <SPC> - <SPC> start : <NL>              start , <SPC> end <SPC> = <SPC> i , <SPC> j <NL> <TAB> return <SPC> S [ start : <SPC> end <SPC> + <SPC> 1 ] <SPC> if <SPC> end <SPC> < <SPC> len ( S ) <SPC> else <SPC> "" <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minWindow ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> count , <SPC> remain <SPC> = <SPC> collections . Counter ( t ) , <SPC> len ( t ) <NL> <TAB> i , <SPC> left , <SPC> right <SPC> = <SPC> 0 , <SPC> - 1 , <SPC> - 1 <NL> <TAB> for <SPC> j , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          remain <SPC> -= <SPC> count [ c ] <SPC> > <SPC> 0 <NL>          count [ c ] <SPC> -= <SPC> 1 <NL>          if <SPC> remain : <NL>              continue <NL>          while <SPC> count [ s [ i ] ] <SPC> < <SPC> 0 : <NL>              count [ s [ i ] ] <SPC> += <SPC> 1 <NL>              i <SPC> += <SPC> 1 <NL>          if <SPC> right <SPC> == <SPC> - 1 <SPC> or <SPC> j <SPC> - <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 : <NL>              left , <SPC> right <SPC> = <SPC> i , <SPC> j <NL> <TAB> return <SPC> s [ left : <SPC> right <SPC> + <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minWindow ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> current_count <SPC> = <SPC> [ 0 <SPC> for <SPC> i <SPC> in <SPC> xrange ( 52 ) ] <NL> <TAB> expected_count <SPC> = <SPC> [ 0 <SPC> for <SPC> i <SPC> in <SPC> xrange ( 52 ) ] <NL> <NL> <TAB> for <SPC> char <SPC> in <SPC> t : <NL>          expected_count [ ord ( char ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL> <NL> <TAB> i , <SPC> count , <SPC> start , <SPC> min_width , <SPC> min_start <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> float ( "inf" ) , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( s ) : <NL>          current_count [ ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL>          if <SPC> ( <NL>              current_count [ ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <NL>              <= <SPC> expected_count [ ord ( s [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <NL>          ) : <NL>              count <SPC> += <SPC> 1 <NL> <NL>          if <SPC> count <SPC> == <SPC> len ( t ) : <NL>              while <SPC> ( <NL>                  expected_count [ ord ( s [ start ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> == <SPC> 0 <NL>                  or <SPC> current_count [ ord ( s [ start ] ) <SPC> - <SPC> ord ( "a" ) ] <NL>                  > <SPC> expected_count [ ord ( s [ start ] ) <SPC> - <SPC> ord ( "a" ) ] <NL>              ) : <NL>                  current_count [ ord ( s [ start ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> -= <SPC> 1 <NL>                  start <SPC> += <SPC> 1 <NL> <NL>              if <SPC> min_width <SPC> > <SPC> i <SPC> - <SPC> start <SPC> + <SPC> 1 : <NL>                  min_width <SPC> = <SPC> i <SPC> - <SPC> start <SPC> + <SPC> 1 <NL>                  min_start <SPC> = <SPC> start <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> if <SPC> min_width <SPC> == <SPC> float ( "inf" ) : <NL>          return <SPC> "" <NL> <NL> <TAB> return <SPC> s [ min_start : <SPC> min_start <SPC> + <SPC> min_width ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mirrorReflection ( self , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> return <SPC> 2 <SPC> if <SPC> ( p <SPC> & <SPC> - p ) <SPC> > <SPC> ( q <SPC> & <SPC> - q ) <SPC> else <SPC> 0 <SPC> if <SPC> ( p <SPC> & <SPC> - p ) <SPC> < <SPC> ( q <SPC> & <SPC> - q ) <SPC> else <SPC> 1 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> mirrorReflection ( self , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> def <SPC> gcd ( a , <SPC> b ) : <NL>          while <SPC> b : <NL>              a , <SPC> b <SPC> = <SPC> b , <SPC> a <SPC> % <SPC> b <NL>          return <SPC> a <NL> <NL> <TAB> lcm <SPC> = <SPC> p <SPC> * <SPC> q <SPC> // <SPC> gcd ( p , <SPC> q ) <NL> <NL> <TAB> if <SPC> lcm <SPC> // <SPC> p <SPC> % <SPC> 2 <SPC> == <SPC> 1 : <NL>          if <SPC> lcm <SPC> // <SPC> q <SPC> % <SPC> 2 <SPC> == <SPC> 1 : <NL>              return <SPC> 1 <NL>          return <SPC> 2 <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> missingElement ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> missing_count ( nums , <SPC> x ) : <NL>          return <SPC> ( nums [ x ] <SPC> - <SPC> nums [ 0 ] <SPC> + <SPC> 1 ) <SPC> - <SPC> ( x <SPC> - <SPC> 0 <SPC> + <SPC> 1 ) <NL> <NL> <TAB> def <SPC> check ( nums , <SPC> k , <SPC> x ) : <NL>          return <SPC> k <SPC> > <SPC> missing_count ( nums , <SPC> x ) <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( nums , <SPC> k , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> assert <SPC> check ( nums , <SPC> k , <SPC> right ) <NL> <TAB> return <SPC> nums [ right ] <SPC> + <SPC> ( k <SPC> - <SPC> missing_count ( nums , <SPC> right ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> missingNumber ( self , <SPC> arr ) : <NL> <NL> <TAB> def <SPC> check ( arr , <SPC> d , <SPC> x ) : <NL>          return <SPC> arr [ x ] <SPC> != <SPC> arr [ 0 ] <SPC> + <SPC> d <SPC> * <SPC> x <NL> <NL> <TAB> d <SPC> = <SPC> ( arr [ - 1 ] <SPC> - <SPC> arr [ 0 ] ) <SPC> // <SPC> len ( arr ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( arr ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> check ( arr , <SPC> d , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> arr [ 0 ] <SPC> + <SPC> d <SPC> * <SPC> left <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> missingNumber ( self , <SPC> arr ) : <NL> <NL> <TAB> return <SPC> ( min ( arr ) <SPC> + <SPC> max ( arr ) ) <SPC> * <SPC> ( len ( arr ) <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 <SPC> - <SPC> sum ( arr ) <NL> <NL> <NL> import <SPC> operator <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> missingNumber ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> reduce ( operator . xor , <SPC> nums , <SPC> reduce ( operator . xor , <SPC> xrange ( len ( nums ) <SPC> + <SPC> 1 ) ) ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> missingNumber ( self , <SPC> nums ) : <NL> <TAB> return <SPC> sum ( xrange ( len ( nums ) <SPC> + <SPC> 1 ) ) <SPC> - <SPC> sum ( nums ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMissingRanges ( self , <SPC> nums , <SPC> lower , <SPC> upper ) : <NL> <NL> <TAB> def <SPC> getRange ( lower , <SPC> upper ) : <NL>          if <SPC> lower <SPC> == <SPC> upper : <NL>              return <SPC> "{}" . format ( lower ) <NL>          else : <NL>              return <SPC> "{}->{}" . format ( lower , <SPC> upper ) <NL> <NL> <TAB> ranges <SPC> = <SPC> [ ] <NL> <TAB> pre <SPC> = <SPC> lower <SPC> - <SPC> 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> i <SPC> == <SPC> len ( nums ) : <NL>              cur <SPC> = <SPC> upper <SPC> + <SPC> 1 <NL>          else : <NL>              cur <SPC> = <SPC> nums [ i ] <NL>          if <SPC> cur <SPC> - <SPC> pre <SPC> >= <SPC> 2 : <NL>              ranges . append ( getRange ( pre <SPC> + <SPC> 1 , <SPC> cur <SPC> - <SPC> 1 ) ) <NL> <NL>          pre <SPC> = <SPC> cur <NL> <NL> <TAB> return <SPC> ranges <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> monotoneIncreasingDigits ( self , <SPC> N ) : <NL> <NL> <TAB> nums <SPC> = <SPC> map ( int , <SPC> list ( str ( N ) ) ) <NL> <TAB> leftmost_inverted_idx <SPC> = <SPC> len ( nums ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( nums ) ) ) : <NL>          if <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> > <SPC> nums [ i ] : <NL>              leftmost_inverted_idx <SPC> = <SPC> i <NL>              nums [ i <SPC> - <SPC> 1 ] <SPC> -= <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( leftmost_inverted_idx , <SPC> len ( nums ) ) : <NL>          nums [ i ] <SPC> = <SPC> 9 <NL> <TAB> return <SPC> int ( "" . join ( map ( str , <SPC> nums ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isMonotonic ( self , <SPC> A ) : <NL> <NL> <TAB> inc , <SPC> dec <SPC> = <SPC> False , <SPC> False <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> A [ i ] <SPC> < <SPC> A [ i <SPC> + <SPC> 1 ] : <NL>              inc <SPC> = <SPC> True <NL>          elif <SPC> A [ i ] <SPC> > <SPC> A [ i <SPC> + <SPC> 1 ] : <NL>              dec <SPC> = <SPC> True <NL> <TAB> return <SPC> not <SPC> inc <SPC> or <SPC> not <SPC> dec <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mostCommonWord ( self , <SPC> paragraph , <SPC> banned ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( banned ) <NL> <TAB> counts <SPC> = <SPC> collections . Counter ( <NL>          word . strip ( "!?',." ) <SPC> for <SPC> word <SPC> in <SPC> paragraph . lower ( ) . split ( ) <NL> <TAB> ) <NL> <NL> <TAB> result <SPC> = <SPC> "" <NL> <TAB> for <SPC> word <SPC> in <SPC> counts : <NL>          if <SPC> ( not <SPC> result <SPC> or <SPC> counts [ word ] <SPC> > <SPC> counts [ result ] ) <SPC> and <SPC> word <SPC> not <SPC> in <SPC> lookup : <NL>              result <SPC> = <SPC> word <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findFrequentTreeSum ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> countSubtreeSumHelper ( root , <SPC> counts ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 <NL>          total <SPC> = <SPC> ( <NL>              root . val <NL>              + <SPC> countSubtreeSumHelper ( root . left , <SPC> counts ) <NL>              + <SPC> countSubtreeSumHelper ( root . right , <SPC> counts ) <NL>          ) <NL>          counts [ total ] <SPC> += <SPC> 1 <NL>          return <SPC> total <NL> <NL> <TAB> counts <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> countSubtreeSumHelper ( root , <SPC> counts ) <NL> <TAB> max_count <SPC> = <SPC> max ( counts . values ( ) ) <SPC> if <SPC> counts <SPC> else <SPC> 0 <NL> <TAB> return <SPC> [ total <SPC> for <SPC> total , <SPC> count <SPC> in <SPC> counts . iteritems ( ) <SPC> if <SPC> count <SPC> == <SPC> max_count ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProfitAssignment ( self , <SPC> difficulty , <SPC> profit , <SPC> worker ) : <NL> <NL> <TAB> jobs <SPC> = <SPC> zip ( difficulty , <SPC> profit ) <NL> <TAB> jobs . sort ( ) <NL> <TAB> worker . sort ( ) <NL> <TAB> result , <SPC> i , <SPC> max_profit <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> ability <SPC> in <SPC> worker : <NL>          while <SPC> i <SPC> < <SPC> len ( jobs ) <SPC> and <SPC> jobs [ i ] [ 0 ] <SPC> <= <SPC> ability : <NL>              max_profit <SPC> = <SPC> max ( max_profit , <SPC> jobs [ i ] [ 1 ] ) <NL>              i <SPC> += <SPC> 1 <NL>          result <SPC> += <SPC> max_profit <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeStones ( self , <SPC> stones ) : <NL> <NL> <TAB> MAX_ROW <SPC> = <SPC> 10000 <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( 2 <SPC> * <SPC> MAX_ROW ) <NL> <TAB> for <SPC> r , <SPC> c <SPC> in <SPC> stones : <NL>          union_find . union_set ( r , <SPC> c <SPC> + <SPC> MAX_ROW ) <NL> <TAB> return <SPC> len ( stones ) <SPC> - <SPC> len ( { union_find . find_set ( r ) <SPC> for <SPC> r , <SPC> _ <SPC> in <SPC> stones } ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mostVisited ( self , <SPC> n , <SPC> rounds ) : <NL> <NL> <TAB> return <SPC> range ( rounds [ 0 ] , <SPC> rounds [ - 1 ] <SPC> + <SPC> 1 ) <SPC> or <SPC> range ( 1 , <SPC> rounds [ - 1 ] <SPC> + <SPC> 1 ) <SPC> + <SPC> range ( <NL>          rounds [ 0 ] , <SPC> n <SPC> + <SPC> 1 <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = None , <SPC> children = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . children <SPC> = <SPC> children <SPC> if <SPC> children <SPC> is <SPC> not <SPC> None <SPC> else <SPC> [ ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> moveSubTree ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> def <SPC> iter_find_parents ( node , <SPC> parent , <SPC> p , <SPC> q , <SPC> is_ancestor , <SPC> lookup ) : <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> [ node , <SPC> None , <SPC> False ] ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  node , <SPC> parent , <SPC> is_ancestor <SPC> = <SPC> params <NL>                  if <SPC> node <SPC> in <SPC> ( p , <SPC> q ) : <NL>                      lookup [ node ] <SPC> = <SPC> parent <NL>                      if <SPC> len ( lookup ) <SPC> == <SPC> 2 : <NL>                          return <SPC> is_ancestor <NL>                  stk . append ( ( 2 , <SPC> [ node , <SPC> is_ancestor , <SPC> reversed ( node . children ) ] ) ) <NL>              else : <NL>                  node , <SPC> is_ancestor , <SPC> it <SPC> = <SPC> params <NL>                  child <SPC> = <SPC> next ( it , <SPC> None ) <NL>                  if <SPC> not <SPC> child : <NL>                      continue <NL>                  stk . append ( ( 2 , <SPC> [ node , <SPC> is_ancestor , <SPC> it ] ) ) <NL>                  stk . append ( ( 1 , <SPC> [ child , <SPC> node , <SPC> is_ancestor <SPC> or <SPC> node <SPC> == <SPC> p ] ) ) <NL>          assert <SPC> False <NL>          return <SPC> False <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> is_ancestor <SPC> = <SPC> iter_find_parents ( root , <SPC> None , <SPC> p , <SPC> q , <SPC> False , <SPC> lookup ) <NL> <TAB> if <SPC> p <SPC> in <SPC> lookup <SPC> and <SPC> lookup [ p ] <SPC> == <SPC> q : <NL>          return <SPC> root <NL> <TAB> q . children . append ( p ) <NL> <TAB> if <SPC> not <SPC> is_ancestor : <NL>          lookup [ p ] . children . remove ( p ) <NL> <TAB> else : <NL>          lookup [ q ] . children . remove ( q ) <NL>          if <SPC> p <SPC> == <SPC> root : <NL>              root <SPC> = <SPC> q <NL>          else : <NL>              lookup [ p ] . children [ lookup [ p ] . children . index ( p ) ] <SPC> = <SPC> q <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution_Recu ( object ) : <NL> <TAB> def <SPC> moveSubTree ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> def <SPC> find_parents ( node , <SPC> parent , <SPC> p , <SPC> q , <SPC> is_ancestor , <SPC> lookup ) : <NL>          if <SPC> node <SPC> in <SPC> ( p , <SPC> q ) : <NL>              lookup [ node ] <SPC> = <SPC> parent <NL>              if <SPC> len ( lookup ) <SPC> == <SPC> 2 : <NL>                  return <SPC> True , <SPC> is_ancestor <NL>          for <SPC> child <SPC> in <SPC> node . children : <NL>              found , <SPC> new_is_ancestor <SPC> = <SPC> find_parents ( <NL>                  child , <SPC> node , <SPC> p , <SPC> q , <SPC> is_ancestor <SPC> or <SPC> node <SPC> == <SPC> p , <SPC> lookup <NL>              ) <NL>              if <SPC> found : <NL>                  return <SPC> True , <SPC> new_is_ancestor <NL>          return <SPC> False , <SPC> False <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> is_ancestor <SPC> = <SPC> find_parents ( root , <SPC> None , <SPC> p , <SPC> q , <SPC> False , <SPC> lookup ) [ 1 ] <NL> <TAB> if <SPC> p <SPC> in <SPC> lookup <SPC> and <SPC> lookup [ p ] <SPC> == <SPC> q : <NL>          return <SPC> root <NL> <TAB> q . children . append ( p ) <NL> <TAB> if <SPC> not <SPC> is_ancestor : <NL>          lookup [ p ] . children . remove ( p ) <NL> <TAB> else : <NL>          lookup [ q ] . children . remove ( q ) <NL>          if <SPC> p <SPC> == <SPC> root : <NL>              root <SPC> = <SPC> q <NL>          else : <NL>              lookup [ p ] . children [ lookup [ p ] . children . index ( p ) ] <SPC> = <SPC> q <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> moveSubTree ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> def <SPC> iter_find_parents ( node , <SPC> parent , <SPC> p , <SPC> q , <SPC> lookup ) : <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> [ node , <SPC> None ] ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  node , <SPC> parent <SPC> = <SPC> params <NL>                  if <SPC> node <SPC> in <SPC> ( p , <SPC> q ) : <NL>                      lookup [ node ] <SPC> = <SPC> parent <NL>                      if <SPC> len ( lookup ) <SPC> == <SPC> 2 : <NL>                          return <NL>                  stk . append ( ( 2 , <SPC> [ node , <SPC> reversed ( node . children ) ] ) ) <NL>              else : <NL>                  node , <SPC> it <SPC> = <SPC> params <NL>                  child <SPC> = <SPC> next ( it , <SPC> None ) <NL>                  if <SPC> not <SPC> child : <NL>                      continue <NL>                  stk . append ( ( 2 , <SPC> [ node , <SPC> it ] ) ) <NL>                  stk . append ( ( 1 , <SPC> [ child , <SPC> node ] ) ) <NL> <NL> <TAB> def <SPC> iter_is_ancestor ( node , <SPC> q ) : <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> [ node ] ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  node <SPC> = <SPC> params [ 0 ] <NL>                  stk . append ( ( 2 , <SPC> [ reversed ( node . children ) ] ) ) <NL>              else : <NL>                  it <SPC> = <SPC> params [ 0 ] <NL>                  child <SPC> = <SPC> next ( it , <SPC> None ) <NL>                  if <SPC> not <SPC> child : <NL>                      continue <NL>                  if <SPC> child <SPC> == <SPC> q : <NL>                      return <SPC> True <NL>                  stk . append ( ( 2 , <SPC> [ it ] ) ) <NL>                  stk . append ( ( 1 , <SPC> [ child ] ) ) <NL>          return <SPC> False <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> iter_find_parents ( root , <SPC> None , <SPC> p , <SPC> q , <SPC> lookup ) <NL> <TAB> if <SPC> p <SPC> in <SPC> lookup <SPC> and <SPC> lookup [ p ] <SPC> == <SPC> q : <NL>          return <SPC> root <NL> <TAB> q . children . append ( p ) <NL> <TAB> if <SPC> not <SPC> iter_is_ancestor ( p , <SPC> q ) : <NL>          lookup [ p ] . children . remove ( p ) <NL> <TAB> else : <NL>          lookup [ q ] . children . remove ( q ) <NL>          if <SPC> p <SPC> == <SPC> root : <NL>              root <SPC> = <SPC> q <NL>          else : <NL>              lookup [ p ] . children [ lookup [ p ] . children . index ( p ) ] <SPC> = <SPC> q <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution2_Recu ( object ) : <NL> <TAB> def <SPC> moveSubTree ( self , <SPC> root , <SPC> p , <SPC> q ) : <NL> <NL> <TAB> def <SPC> find_parents ( node , <SPC> parent , <SPC> p , <SPC> q , <SPC> lookup ) : <NL>          if <SPC> node <SPC> in <SPC> ( p , <SPC> q ) : <NL>              lookup [ node ] <SPC> = <SPC> parent <NL>              if <SPC> len ( lookup ) <SPC> == <SPC> 2 : <NL>                  return <SPC> True <NL>          for <SPC> child <SPC> in <SPC> node . children : <NL>              if <SPC> find_parents ( child , <SPC> node , <SPC> p , <SPC> q , <SPC> lookup ) : <NL>                  return <SPC> True <NL>          return <SPC> False <NL> <NL> <TAB> def <SPC> is_ancestor ( node , <SPC> q ) : <NL>          for <SPC> child <SPC> in <SPC> node . children : <NL>              if <SPC> node <SPC> == <SPC> q <SPC> or <SPC> is_ancestor ( child , <SPC> q ) : <NL>                  return <SPC> True <NL>          return <SPC> False <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> find_parents ( root , <SPC> None , <SPC> p , <SPC> q , <SPC> lookup ) <NL> <TAB> if <SPC> p <SPC> in <SPC> lookup <SPC> and <SPC> lookup [ p ] <SPC> == <SPC> q : <NL>          return <SPC> root <NL> <TAB> q . children . append ( p ) <NL> <TAB> if <SPC> not <SPC> is_ancestor ( p , <SPC> q ) : <NL>          lookup [ p ] . children . remove ( p ) <NL> <TAB> else : <NL>          lookup [ q ] . children . remove ( q ) <NL>          if <SPC> p <SPC> == <SPC> root : <NL>              root <SPC> = <SPC> q <NL>          else : <NL>              lookup [ p ] . children [ lookup [ p ] . children . index ( p ) ] <SPC> = <SPC> q <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> moveZeroes ( self , <SPC> nums ) : <NL> <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> nums [ i ] : <NL>              nums [ i ] , <SPC> nums [ pos ] <SPC> = <SPC> nums [ pos ] , <SPC> nums [ i ] <NL>              pos <SPC> += <SPC> 1 <NL> <NL> <TAB> def <SPC> moveZeroes2 ( self , <SPC> nums ) : <NL> <NL> <TAB> nums . sort ( cmp = lambda <SPC> a , <SPC> b : <SPC> 0 <SPC> if <SPC> b <SPC> else <SPC> - 1 ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> moveZeroes ( self , <SPC> nums ) : <NL> <NL> <TAB> pos <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> nums [ i ] : <NL>              nums [ pos ] <SPC> = <SPC> nums [ i ] <NL>              pos <SPC> += <SPC> 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( pos , <SPC> len ( nums ) ) : <NL>          nums [ i ] <SPC> = <SPC> 0 <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> deque <NL> <NL> <NL> class <SPC> MovingAverage ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> size ) : <NL> <NL> <TAB> self . __size <SPC> = <SPC> size <NL> <TAB> self . __sum <SPC> = <SPC> 0 <NL> <TAB> self . __q <SPC> = <SPC> deque ( ) <NL> <NL> <TAB> def <SPC> next ( self , <SPC> val ) : <NL> <NL> <TAB> if <SPC> len ( self . __q ) <SPC> == <SPC> self . __size : <NL>          self . __sum <SPC> -= <SPC> self . __q . popleft ( ) <NL> <TAB> self . __sum <SPC> += <SPC> val <NL> <TAB> self . __q . append ( val ) <NL> <TAB> return <SPC> 1.0 <SPC> * <SPC> self . __sum <SPC> / <SPC> len ( self . __q ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numMovesStonesII ( self , <SPC> stones ) : <NL> <NL> <TAB> stones . sort ( ) <NL> <TAB> left , <SPC> min_moves <SPC> = <SPC> 0 , <SPC> float ( "inf" ) <NL> <TAB> max_moves <SPC> = <SPC> max ( stones [ - 1 ] <SPC> - <SPC> stones [ 1 ] , <SPC> stones [ - 2 ] <SPC> - <SPC> stones [ 0 ] ) <SPC> - <SPC> ( <NL>          len ( stones ) <SPC> - <SPC> 2 <NL> <TAB> ) <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( stones ) ) : <NL>          while <SPC> stones [ right ] <SPC> - <SPC> stones [ left ] <SPC> + <SPC> 1 <SPC> > <SPC> len ( <NL>              stones <NL>          ) : <NL>              left <SPC> += <SPC> 1 <NL>          if <SPC> ( <NL>              len ( stones ) <SPC> - <SPC> ( right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <SPC> == <SPC> 1 <NL>              and <SPC> stones [ right ] <SPC> - <SPC> stones [ left ] <SPC> + <SPC> 1 <SPC> == <SPC> len ( stones ) <SPC> - <SPC> 1 <NL>          ) : <NL>              min_moves <SPC> = <SPC> min ( min_moves , <SPC> 2 ) <NL>          else : <NL>              min_moves <SPC> = <SPC> min ( <NL>                  min_moves , <SPC> len ( stones ) <SPC> - <SPC> ( right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <NL>              ) <NL> <TAB> return <SPC> [ min_moves , <SPC> max_moves ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numMovesStones ( self , <SPC> a , <SPC> b , <SPC> c ) : <NL> <NL> <TAB> s <SPC> = <SPC> [ a , <SPC> b , <SPC> c ] <NL> <TAB> s . sort ( ) <NL> <TAB> if <SPC> s [ 0 ] <SPC> + <SPC> 1 <SPC> == <SPC> s [ 1 ] <SPC> and <SPC> s [ 1 ] <SPC> + <SPC> 1 <SPC> == <SPC> s [ 2 ] : <NL>          return <SPC> [ 0 , <SPC> 0 ] <NL> <TAB> return <SPC> [ 1 <SPC> if <SPC> s [ 0 ] <SPC> + <SPC> 2 <SPC> >= <SPC> s [ 1 ] <SPC> or <SPC> s [ 1 ] <SPC> + <SPC> 2 <SPC> >= <SPC> s [ 2 ] <SPC> else <SPC> 2 , <SPC> s [ 2 ] <SPC> - <SPC> s [ 0 ] <SPC> - <SPC> 2 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numMovesStones ( self , <SPC> a , <SPC> b , <SPC> c ) : <NL> <NL> <TAB> stones <SPC> = <SPC> [ a , <SPC> b , <SPC> c ] <NL> <TAB> stones . sort ( ) <NL> <TAB> left , <SPC> min_moves <SPC> = <SPC> 0 , <SPC> float ( "inf" ) <NL> <TAB> max_moves <SPC> = <SPC> ( stones [ - 1 ] <SPC> - <SPC> stones [ 0 ] ) <SPC> - <SPC> ( len ( stones ) <SPC> - <SPC> 1 ) <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( stones ) ) : <NL>          while <SPC> stones [ right ] <SPC> - <SPC> stones [ left ] <SPC> + <SPC> 1 <SPC> > <SPC> len ( <NL>              stones <NL>          ) : <NL>              left <SPC> += <SPC> 1 <NL>          min_moves <SPC> = <SPC> min ( <NL>              min_moves , <SPC> len ( stones ) <SPC> - <SPC> ( right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <NL>          ) <NL> <TAB> return <SPC> [ min_moves , <SPC> max_moves ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> multiply ( self , <SPC> num1 , <SPC> num2 ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( num1 ) <SPC> + <SPC> len ( num2 ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( num1 ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( num2 ) ) ) : <NL>              result [ i <SPC> + <SPC> j <SPC> + <SPC> 1 ] <SPC> += <SPC> int ( num1 [ i ] ) <SPC> * <SPC> int ( num2 [ j ] ) <NL>              result [ i <SPC> + <SPC> j ] <SPC> += <SPC> result [ i <SPC> + <SPC> j <SPC> + <SPC> 1 ] <SPC> // <SPC> 10 <NL>              result [ i <SPC> + <SPC> j <SPC> + <SPC> 1 ] <SPC> %= <SPC> 10 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( result ) ) : <NL>          if <SPC> result [ i ] : <NL>              break <NL> <TAB> return <SPC> "" . join ( map ( lambda <SPC> x : <SPC> str ( x ) , <SPC> result [ i : ] ) ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> multiply ( self , <SPC> num1 , <SPC> num2 ) : <NL> <NL> <TAB> num1 , <SPC> num2 <SPC> = <SPC> num1 [ : : - 1 ] , <SPC> num2 [ : : - 1 ] <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( num1 ) <SPC> + <SPC> len ( num2 ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( num1 ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( num2 ) ) : <NL>              result [ i <SPC> + <SPC> j ] <SPC> += <SPC> int ( num1 [ i ] ) <SPC> * <SPC> int ( num2 [ j ] ) <NL>              result [ i <SPC> + <SPC> j <SPC> + <SPC> 1 ] <SPC> += <SPC> result [ i <SPC> + <SPC> j ] <SPC> // <SPC> 10 <NL>              result [ i <SPC> + <SPC> j ] <SPC> %= <SPC> 10 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( result ) ) ) : <NL>          if <SPC> result [ i ] : <NL>              break <NL> <TAB> return <SPC> "" . join ( map ( str , <SPC> result [ i : : - 1 ] ) ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> multiply ( self , <SPC> num1 , <SPC> num2 ) : <NL> <NL> <TAB> return <SPC> str ( int ( num1 ) <SPC> * <SPC> int ( num2 ) ) <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> start , <SPC> end ) : <NL> <TAB> self . __start <SPC> = <SPC> start <NL> <TAB> self . __end <SPC> = <SPC> end <NL> <TAB> self . __left <SPC> = <SPC> None <NL> <TAB> self . __right <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> node ) : <NL> <TAB> if <SPC> node . __start <SPC> >= <SPC> self . __end : <NL>          if <SPC> not <SPC> self . __right : <NL>              self . __right <SPC> = <SPC> node <NL>              return <SPC> True <NL>          return <SPC> self . __right . insert ( node ) <NL> <TAB> elif <SPC> node . __end <SPC> <= <SPC> self . __start : <NL>          if <SPC> not <SPC> self . __left : <NL>              self . __left <SPC> = <SPC> node <NL>              return <SPC> True <NL>          return <SPC> self . __left . insert ( node ) <NL> <TAB> else : <NL>          return <SPC> False <NL> <NL> <NL> class <SPC> MyCalendar ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __root <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> book ( self , <SPC> start , <SPC> end ) : <NL> <NL> <TAB> if <SPC> self . __root <SPC> is <SPC> None : <NL>          self . __root <SPC> = <SPC> Node ( start , <SPC> end ) <NL>          return <SPC> True <NL> <TAB> return <SPC> self . root . insert ( Node ( start , <SPC> end ) ) <NL> <NL> <NL> class <SPC> MyCalendar2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __calendar <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> book ( self , <SPC> start , <SPC> end ) : <NL> <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> self . __calendar : <NL>          if <SPC> start <SPC> < <SPC> j <SPC> and <SPC> end <SPC> > <SPC> i : <NL>              return <SPC> False <NL> <TAB> self . __calendar . append ( ( start , <SPC> end ) ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> MyCalendarTwo ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __overlaps <SPC> = <SPC> [ ] <NL> <TAB> self . __calendar <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> book ( self , <SPC> start , <SPC> end ) : <NL> <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> self . __overlaps : <NL>          if <SPC> start <SPC> < <SPC> j <SPC> and <SPC> end <SPC> > <SPC> i : <NL>              return <SPC> False <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> self . __calendar : <NL>          if <SPC> start <SPC> < <SPC> j <SPC> and <SPC> end <SPC> > <SPC> i : <NL>              self . __overlaps . append ( ( max ( start , <SPC> i ) , <SPC> min ( end , <SPC> j ) ) ) <NL> <TAB> self . __calendar . append ( ( start , <SPC> end ) ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> MyCalendarThree ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __books <SPC> = <SPC> [ [ - 1 , <SPC> 0 ] ] <NL> <TAB> self . __count <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> book ( self , <SPC> start , <SPC> end ) : <NL> <NL> <TAB> i <SPC> = <SPC> bisect . bisect_right ( self . __books , <SPC> [ start , <SPC> float ( "inf" ) ] ) <NL> <TAB> if <SPC> self . __books [ i <SPC> - <SPC> 1 ] [ 0 ] <SPC> == <SPC> start : <NL>          i <SPC> -= <SPC> 1 <NL> <TAB> else : <NL>          self . __books . insert ( i , <SPC> [ start , <SPC> self . __books [ i <SPC> - <SPC> 1 ] [ 1 ] ] ) <NL> <TAB> j <SPC> = <SPC> bisect . bisect_right ( self . __books , <SPC> [ end , <SPC> float ( "inf" ) ] ) <NL> <TAB> if <SPC> self . __books [ j <SPC> - <SPC> 1 ] [ 0 ] <SPC> == <SPC> end : <NL>          j <SPC> -= <SPC> 1 <NL> <TAB> else : <NL>          self . __books . insert ( j , <SPC> [ end , <SPC> self . __books [ j <SPC> - <SPC> 1 ] [ 1 ] ] ) <NL> <TAB> for <SPC> k <SPC> in <SPC> xrange ( i , <SPC> j ) : <NL>          self . __books [ k ] [ 1 ] <SPC> += <SPC> 1 <NL>          self . __count <SPC> = <SPC> max ( self . __count , <SPC> self . __books [ k ] [ 1 ] ) <NL> <TAB> return <SPC> self . __count <NL> <NL> <NL> class <SPC> MyCalendarThree2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __books <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> book ( self , <SPC> start , <SPC> end ) : <NL> <NL> <TAB> i <SPC> = <SPC> bisect . bisect_left ( self . __books , <SPC> ( start , <SPC> 1 ) ) <NL> <TAB> if <SPC> i <SPC> < <SPC> len ( self . __books ) <SPC> and <SPC> self . __books [ i ] [ 0 ] <SPC> == <SPC> start : <NL>          self . __books [ i ] <SPC> = <SPC> ( self . __books [ i ] [ 0 ] , <SPC> self . __books [ i ] [ 1 ] <SPC> + <SPC> 1 ) <NL> <TAB> else : <NL>          self . __books . insert ( i , <SPC> ( start , <SPC> 1 ) ) <NL> <NL> <TAB> j <SPC> = <SPC> bisect . bisect_left ( self . __books , <SPC> ( end , <SPC> 1 ) ) <NL> <TAB> if <SPC> j <SPC> < <SPC> len ( self . __books ) <SPC> and <SPC> self . __books [ j ] [ 0 ] <SPC> == <SPC> end : <NL>          self . __books [ j ] <SPC> = <SPC> ( self . __books [ j ] [ 0 ] , <SPC> self . __books [ j ] [ 1 ] <SPC> - <SPC> 1 ) <NL> <TAB> else : <NL>          self . __books . insert ( j , <SPC> ( end , <SPC> - 1 ) ) <NL> <NL> <TAB> result , <SPC> cnt <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> book <SPC> in <SPC> self . __books : <NL>          cnt <SPC> += <SPC> book [ 1 ] <NL>          result <SPC> = <SPC> max ( result , <SPC> cnt ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> children ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . children <SPC> = <SPC> children <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> levelOrder ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> [ ] <NL> <TAB> result , <SPC> q <SPC> = <SPC> [ ] , <SPC> [ root ] <NL> <TAB> while <SPC> q : <NL>          result . append ( [ node . val <SPC> for <SPC> node <SPC> in <SPC> q ] ) <NL>          q <SPC> = <SPC> [ child <SPC> for <SPC> node <SPC> in <SPC> q <SPC> for <SPC> child <SPC> in <SPC> node . children <SPC> if <SPC> child ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> children ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . children <SPC> = <SPC> children <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> postorder ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> [ ] <NL> <TAB> result , <SPC> stack <SPC> = <SPC> [ ] , <SPC> [ root ] <NL> <TAB> while <SPC> stack : <NL>          node <SPC> = <SPC> stack . pop ( ) <NL>          result . append ( node . val ) <NL>          for <SPC> child <SPC> in <SPC> node . children : <NL>              if <SPC> child : <NL>                  stack . append ( child ) <NL> <TAB> return <SPC> result [ : : - 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> postorder ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( root , <SPC> result ) : <NL>          for <SPC> child <SPC> in <SPC> root . children : <NL>              if <SPC> child : <NL>                  dfs ( child , <SPC> result ) <NL>          result . append ( root . val ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> root : <NL>          dfs ( root , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> children ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . children <SPC> = <SPC> children <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> preorder ( self , <SPC> root ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> [ ] <NL> <TAB> result , <SPC> stack <SPC> = <SPC> [ ] , <SPC> [ root ] <NL> <TAB> while <SPC> stack : <NL>          node <SPC> = <SPC> stack . pop ( ) <NL>          result . append ( node . val ) <NL>          for <SPC> child <SPC> in <SPC> reversed ( node . children ) : <NL>              if <SPC> child : <NL>                  stack . append ( child ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> preorder ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( root , <SPC> result ) : <NL>          result . append ( root . val ) <NL>          for <SPC> child <SPC> in <SPC> root . children : <NL>              if <SPC> child : <NL>                  dfs ( child , <SPC> result ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> root : <NL>          dfs ( root , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> from <SPC> functools <SPC> import <SPC> reduce <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> totalNQueens ( self , <SPC> n ) : <NL> <TAB> self . cols <SPC> = <SPC> [ False ] <SPC> * <SPC> n <NL> <TAB> self . main_diag <SPC> = <SPC> [ False ] <SPC> * <SPC> ( 2 <SPC> * <SPC> n ) <NL> <TAB> self . anti_diag <SPC> = <SPC> [ False ] <SPC> * <SPC> ( 2 <SPC> * <SPC> n ) <NL> <TAB> return <SPC> self . totalNQueensRecu ( [ ] , <SPC> 0 , <SPC> n ) <NL> <NL> <TAB> def <SPC> totalNQueensRecu ( self , <SPC> solution , <SPC> row , <SPC> n ) : <NL> <TAB> if <SPC> row <SPC> == <SPC> n : <NL>          return <SPC> 1 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          if <SPC> ( <NL>              not <SPC> self . cols [ i ] <NL>              and <SPC> not <SPC> self . main_diag [ row <SPC> + <SPC> i ] <NL>              and <SPC> not <SPC> self . anti_diag [ row <SPC> - <SPC> i <SPC> + <SPC> n ] <NL>          ) : <NL>              self . cols [ i ] <SPC> = <SPC> self . main_diag [ row <SPC> + <SPC> i ] <SPC> = <SPC> self . anti_diag [ <NL>                  row <SPC> - <SPC> i <SPC> + <SPC> n <NL>              ] <SPC> = <SPC> True <NL>              result <SPC> += <SPC> self . totalNQueensRecu ( solution <SPC> + <SPC> [ i ] , <SPC> row <SPC> + <SPC> 1 , <SPC> n ) <NL>              self . cols [ i ] <SPC> = <SPC> self . main_diag [ row <SPC> + <SPC> i ] <SPC> = <SPC> self . anti_diag [ <NL>                  row <SPC> - <SPC> i <SPC> + <SPC> n <NL>              ] <SPC> = <SPC> False <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> totalNQueens ( self , <SPC> n ) : <NL> <TAB> return <SPC> self . totalNQueensRecu ( [ ] , <SPC> 0 , <SPC> n ) <NL> <NL> <TAB> def <SPC> totalNQueensRecu ( self , <SPC> solution , <SPC> row , <SPC> n ) : <NL> <TAB> if <SPC> row <SPC> == <SPC> n : <NL>          return <SPC> 1 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          if <SPC> i <SPC> not <SPC> in <SPC> solution <SPC> and <SPC> reduce ( <NL>              lambda <SPC> acc , <SPC> j : <SPC> abs ( row <SPC> - <SPC> j ) <SPC> != <SPC> abs ( i <SPC> - <SPC> solution [ j ] ) <SPC> and <SPC> acc , <NL>              xrange ( len ( solution ) ) , <NL>              True , <NL>          ) : <NL>              result <SPC> += <SPC> self . totalNQueensRecu ( solution <SPC> + <SPC> [ i ] , <SPC> row <SPC> + <SPC> 1 , <SPC> n ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> solveNQueens ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> dfs ( curr , <SPC> cols , <SPC> main_diag , <SPC> anti_diag , <SPC> result ) : <NL>          row , <SPC> n <SPC> = <SPC> len ( curr ) , <SPC> len ( cols ) <NL>          if <SPC> row <SPC> == <SPC> n : <NL>              result . append ( <NL>                  map ( lambda <SPC> x : <SPC> "." <SPC> * <SPC> x <SPC> + <SPC> "Q" <SPC> + <SPC> "." <SPC> * <SPC> ( n <SPC> - <SPC> x <SPC> - <SPC> 1 ) , <SPC> curr ) ) <NL>              return <NL>          for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> cols [ i ] <SPC> or <SPC> main_diag [ row <SPC> + <SPC> i ] <SPC> or <SPC> anti_diag [ row <SPC> - <SPC> i <SPC> + <SPC> n ] : <NL>                  continue <NL>              cols [ i ] <SPC> = <SPC> main_diag [ row <SPC> + <SPC> i ] <SPC> = <SPC> anti_diag [ row <SPC> - <SPC> i <SPC> + <SPC> n ] <SPC> = <SPC> True <NL>              curr . append ( i ) <NL>              dfs ( curr , <SPC> cols , <SPC> main_diag , <SPC> anti_diag , <SPC> result ) <NL>              curr . pop ( ) <NL>              cols [ i ] <SPC> = <SPC> main_diag [ row <SPC> + <SPC> i ] <SPC> = <SPC> anti_diag [ row <SPC> - <SPC> i <SPC> + <SPC> n ] <SPC> = <SPC> False <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> cols , <SPC> main_diag , <SPC> anti_diag <SPC> = <SPC> [ False ] <SPC> *          n , <SPC> [ False ] <SPC> * <SPC> ( 2 <SPC> * <SPC> n ) , <SPC> [ False ] <SPC> * <SPC> ( 2 <SPC> * <SPC> n ) <NL> <TAB> dfs ( [ ] , <SPC> cols , <SPC> main_diag , <SPC> anti_diag , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> solveNQueens ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> dfs ( col_per_row , <SPC> xy_diff , <SPC> xy_sum ) : <NL>          cur_row <SPC> = <SPC> len ( col_per_row ) <NL>          if <SPC> cur_row <SPC> == <SPC> n : <NL>              ress . append ( col_per_row ) <NL>          for <SPC> col <SPC> in <SPC> range ( n ) : <NL>              if <SPC> ( <NL>                  col <SPC> not <SPC> in <SPC> col_per_row <NL>                  and <SPC> cur_row <SPC> - <SPC> col <SPC> not <SPC> in <SPC> xy_diff <NL>                  and <SPC> cur_row <SPC> + <SPC> col <SPC> not <SPC> in <SPC> xy_sum <NL>              ) : <NL>                  dfs ( <NL>                      col_per_row <SPC> + <SPC> [ col ] , <NL>                      xy_diff <SPC> + <SPC> [ cur_row <SPC> - <SPC> col ] , <NL>                      xy_sum <SPC> + <SPC> [ cur_row <SPC> + <SPC> col ] , <NL>                  ) <NL> <NL> <TAB> ress <SPC> = <SPC> [ ] <NL> <TAB> dfs ( [ ] , <SPC> [ ] , <SPC> [ ] ) <NL> <TAB> return <SPC> [ [ "." <SPC> * <SPC> i <SPC> + <SPC> "Q" <SPC> + <SPC> "." <SPC> * <SPC> ( n <SPC> - <SPC> i <SPC> - <SPC> 1 ) <SPC> for <SPC> i <SPC> in <SPC> res ] <SPC> for <SPC> res <SPC> in <SPC> ress ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> repeatedNTimes ( self , <SPC> A ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> len ( A ) ) : <NL>          if <SPC> A [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> A [ i ] <SPC> or <SPC> A [ i <SPC> - <SPC> 2 ] <SPC> == <SPC> A [ i ] : <NL>              return <SPC> A [ i ] <NL> <TAB> return <SPC> A [ 0 ] <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> tribonacci ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> matrix_expo ( A , <SPC> K ) : <NL>          result <SPC> = <SPC> [ [ int ( i <SPC> == <SPC> j ) <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>                    for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>          while <SPC> K : <NL>              if <SPC> K <SPC> % <SPC> 2 : <NL>                  result <SPC> = <SPC> matrix_mult ( result , <SPC> A ) <NL>              A <SPC> = <SPC> matrix_mult ( A , <SPC> A ) <NL>              K <SPC> /= <SPC> 2 <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> matrix_mult ( A , <SPC> B ) : <NL>          ZB <SPC> = <SPC> zip ( * B ) <NL>          return <SPC> [ <NL>              [ sum ( a <SPC> * <SPC> b <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( row , <SPC> col ) ) <SPC> for <SPC> col <SPC> in <SPC> ZB ] <NL>              for <SPC> row <SPC> in <SPC> A <NL>          ] <NL> <NL> <TAB> T <SPC> = <SPC> [ [ 1 , <SPC> 1 , <SPC> 0 ] , <SPC> [ 1 , <SPC> 0 , <SPC> 1 ] , <SPC> [ 1 , <SPC> 0 , <SPC> 0 ] ] <NL> <TAB> return <SPC> matrix_mult ( [ [ 1 , <SPC> 0 , <SPC> 0 ] ] , <SPC> matrix_expo ( T , <SPC> n ) ) [ 0 ] [ <NL>          1 <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> tribonacci ( self , <SPC> n ) : <NL> <NL> <TAB> a , <SPC> b , <SPC> c <SPC> = <SPC> 0 , <SPC> 1 , <SPC> 1 <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( n ) : <NL>          a , <SPC> b , <SPC> c <SPC> = <SPC> b , <SPC> c , <SPC> a <SPC> + <SPC> b <SPC> + <SPC> c <NL> <TAB> return <SPC> a <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> depthSumInverse ( self , <SPC> nestedList ) : <NL> <NL> <TAB> def <SPC> depthSumInverseHelper ( list , <SPC> depth , <SPC> result ) : <NL>          if <SPC> len ( result ) <SPC> < <SPC> depth <SPC> + <SPC> 1 : <NL>              result . append ( 0 ) <NL>          if <SPC> list . isInteger ( ) : <NL>              result [ depth ] <SPC> += <SPC> list . getInteger ( ) <NL>          else : <NL>              for <SPC> l <SPC> in <SPC> list . getList ( ) : <NL>                  depthSumInverseHelper ( l , <SPC> depth <SPC> + <SPC> 1 , <SPC> result ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> list <SPC> in <SPC> nestedList : <NL>          depthSumInverseHelper ( list , <SPC> 0 , <SPC> result ) <NL> <NL> <TAB> sum <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( result ) ) ) : <NL>          sum <SPC> += <SPC> result [ i ] <SPC> * <SPC> ( len ( result ) <SPC> - <SPC> i ) <NL> <TAB> return <SPC> sum <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> depthSum ( self , <SPC> nestedList ) : <NL> <NL> <TAB> def <SPC> depthSumHelper ( nestedList , <SPC> depth ) : <NL>          res <SPC> = <SPC> 0 <NL>          for <SPC> l <SPC> in <SPC> nestedList : <NL>              if <SPC> l . isInteger ( ) : <NL>                  res <SPC> += <SPC> l . getInteger ( ) <SPC> * <SPC> depth <NL>              else : <NL>                  res <SPC> += <SPC> depthSumHelper ( l . getList ( ) , <SPC> depth <SPC> + <SPC> 1 ) <NL>          return <SPC> res <NL> <NL> <TAB> return <SPC> depthSumHelper ( nestedList , <SPC> 1 ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> networkDelayTime ( self , <SPC> times , <SPC> N , <SPC> K ) : <NL> <NL> <TAB> adj <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( N ) ] <NL> <TAB> for <SPC> u , <SPC> v , <SPC> w <SPC> in <SPC> times : <NL>          adj [ u <SPC> - <SPC> 1 ] . append ( ( v <SPC> - <SPC> 1 , <SPC> w ) ) <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> best <SPC> = <SPC> collections . defaultdict ( lambda : <SPC> float ( "inf" ) ) <NL> <TAB> min_heap <SPC> = <SPC> [ ( 0 , <SPC> K <SPC> - <SPC> 1 ) ] <NL> <TAB> while <SPC> min_heap <SPC> and <SPC> len ( lookup ) <SPC> != <SPC> N : <NL>          result , <SPC> u <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          lookup . add ( u ) <NL>          if <SPC> best [ u ] <SPC> < <SPC> result : <NL>              continue <NL>          for <SPC> v , <SPC> w <SPC> in <SPC> adj [ u ] : <NL>              if <SPC> v <SPC> in <SPC> lookup : <NL>                  continue <NL>              if <SPC> result <SPC> + <SPC> w <SPC> < <SPC> best [ v ] : <NL>                  best [ v ] <SPC> = <SPC> result <SPC> + <SPC> w <NL>                  heapq . heappush ( min_heap , <SPC> ( result <SPC> + <SPC> w , <SPC> v ) ) <NL> <TAB> return <SPC> result <SPC> if <SPC> len ( lookup ) <SPC> == <SPC> N <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nextClosestTime ( self , <SPC> time ) : <NL> <NL> <TAB> h , <SPC> m <SPC> = <SPC> time . split ( ":" ) <NL> <TAB> curr <SPC> = <SPC> int ( h ) <SPC> * <SPC> 60 <SPC> + <SPC> int ( m ) <NL> <TAB> result <SPC> = <SPC> None <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( curr <SPC> + <SPC> 1 , <SPC> curr <SPC> + <SPC> 1441 ) : <NL>          t <SPC> = <SPC> i <SPC> % <SPC> 1440 <NL>          h , <SPC> m <SPC> = <SPC> t <SPC> // <SPC> 60 , <SPC> t <SPC> % <SPC> 60 <NL>          result <SPC> = <SPC> "%02d:%02d" <SPC> % <SPC> ( h , <SPC> m ) <NL>          if <SPC> set ( result ) <SPC> <= <SPC> set ( time ) : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nextGreaterElement ( self , <SPC> findNums , <SPC> nums ) : <NL> <NL> <TAB> stk , <SPC> lookup <SPC> = <SPC> [ ] , <SPC> { } <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          while <SPC> stk <SPC> and <SPC> num <SPC> > <SPC> stk [ - 1 ] : <NL>              lookup [ stk . pop ( ) ] <SPC> = <SPC> num <NL>          stk . append ( num ) <NL> <TAB> while <SPC> stk : <NL>          lookup [ stk . pop ( ) ] <SPC> = <SPC> - 1 <NL> <TAB> return <SPC> map ( lambda <SPC> x : <SPC> lookup [ x ] , <SPC> findNums ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nextGreaterElements ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> stk <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( nums ) , <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 2 <SPC> * <SPC> len ( nums ) ) ) : <NL>          while <SPC> stk <SPC> and <SPC> stk [ - 1 ] <SPC> <= <SPC> nums [ i <SPC> % <SPC> len ( nums ) ] : <NL>              stk . pop ( ) <NL>          result [ i <SPC> % <SPC> len ( nums ) ] <SPC> = <SPC> stk [ - 1 ] <SPC> if <SPC> stk <SPC> else <SPC> - 1 <NL>          stk . append ( nums [ i <SPC> % <SPC> len ( nums ) ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nextGreaterElement ( self , <SPC> n ) : <NL> <NL> <TAB> digits <SPC> = <SPC> map ( int , <SPC> list ( str ( n ) ) ) <NL> <TAB> k , <SPC> l <SPC> = <SPC> - 1 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( digits ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> digits [ i ] <SPC> < <SPC> digits [ i <SPC> + <SPC> 1 ] : <NL>              k <SPC> = <SPC> i <NL> <NL> <TAB> if <SPC> k <SPC> == <SPC> - 1 : <NL>          digits . reverse ( ) <NL>          return <SPC> - 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k <SPC> + <SPC> 1 , <SPC> len ( digits ) ) : <NL>          if <SPC> digits [ i ] <SPC> > <SPC> digits [ k ] : <NL>              l <SPC> = <SPC> i <NL> <NL> <TAB> digits [ k ] , <SPC> digits [ l ] <SPC> = <SPC> digits [ l ] , <SPC> digits [ k ] <NL> <TAB> digits [ k <SPC> + <SPC> 1 : ] <SPC> = <SPC> digits [ : k : - 1 ] <NL> <TAB> result <SPC> = <SPC> int ( "" . join ( map ( str , <SPC> digits ) ) ) <NL> <TAB> return <SPC> - 1 <SPC> if <SPC> result <SPC> >= <SPC> 0x7FFFFFFF <SPC> else <SPC> result <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nextLargerNodes ( self , <SPC> head ) : <NL> <NL> <TAB> result , <SPC> stk <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> while <SPC> head : <NL>          while <SPC> stk <SPC> and <SPC> stk [ - 1 ] [ 1 ] <SPC> < <SPC> head . val : <NL>              result [ stk . pop ( ) [ 0 ] ] <SPC> = <SPC> head . val <NL>          stk . append ( [ len ( result ) , <SPC> head . val ] ) <NL>          result . append ( 0 ) <NL>          head <SPC> = <SPC> head . next <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nextPermutation ( self , <SPC> nums ) : <NL> <NL> <TAB> k , <SPC> l <SPC> = <SPC> - 1 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( nums ) <SPC> - <SPC> 1 ) ) : <NL>          if <SPC> nums [ i ] <SPC> < <SPC> nums [ i <SPC> + <SPC> 1 ] : <NL>              k <SPC> = <SPC> i <NL>              break <NL> <TAB> else : <NL>          nums . reverse ( ) <NL>          return <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( k <SPC> + <SPC> 1 , <SPC> len ( nums ) ) ) : <NL>          if <SPC> nums [ i ] <SPC> > <SPC> nums [ k ] : <NL>              l <SPC> = <SPC> i <NL>              break <NL> <TAB> nums [ k ] , <SPC> nums [ l ] <SPC> = <SPC> nums [ l ] , <SPC> nums [ k ] <NL> <TAB> nums [ k <SPC> + <SPC> 1 : ] <SPC> = <SPC> nums [ : k : - 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> nextPermutation ( self , <SPC> nums ) : <NL> <NL> <TAB> k , <SPC> l <SPC> = <SPC> - 1 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> nums [ i ] <SPC> < <SPC> nums [ i <SPC> + <SPC> 1 ] : <NL>              k <SPC> = <SPC> i <NL> <NL> <TAB> if <SPC> k <SPC> == <SPC> - 1 : <NL>          nums . reverse ( ) <NL>          return <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k <SPC> + <SPC> 1 , <SPC> len ( nums ) ) : <NL>          if <SPC> nums [ i ] <SPC> > <SPC> nums [ k ] : <NL>              l <SPC> = <SPC> i <NL> <TAB> nums [ k ] , <SPC> nums [ l ] <SPC> = <SPC> nums [ l ] , <SPC> nums [ k ] <NL> <TAB> nums [ k <SPC> + <SPC> 1 : ] <SPC> = <SPC> nums [ : k : - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canWinNim ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> n <SPC> % <SPC> 4 <SPC> != <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkPossibility ( self , <SPC> nums ) : <NL> <NL> <TAB> modified , <SPC> prev <SPC> = <SPC> False , <SPC> nums [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( nums ) ) : <NL>          if <SPC> prev <SPC> > <SPC> nums [ i ] : <NL>              if <SPC> modified : <NL>                  return <SPC> False <NL>              if <SPC> i <SPC> - <SPC> 2 <SPC> < <SPC> 0 <SPC> or <SPC> nums [ i <SPC> - <SPC> 2 ] <SPC> <= <SPC> nums [ i ] : <NL>                  prev <SPC> = <SPC> nums [ i ] <NL> <NL>              modified <SPC> = <SPC> True <NL>          else : <NL>              prev <SPC> = <SPC> nums [ i ] <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findIntegers ( self , <SPC> num ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 32 <NL> <TAB> dp [ 0 ] , <SPC> dp [ 1 ] <SPC> = <SPC> 1 , <SPC> 2 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> len ( dp ) ) : <NL>          dp [ i ] <SPC> = <SPC> dp [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> dp [ i <SPC> - <SPC> 2 ] <NL> <TAB> result , <SPC> prev_bit <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 31 ) ) : <NL>          if <SPC> ( num <SPC> & <SPC> ( 1 <SPC> << <SPC> i ) ) <SPC> != <SPC> 0 : <NL>              result <SPC> += <SPC> dp [ i ] <NL>              if <SPC> prev_bit <SPC> == <SPC> 1 : <NL>                  result <SPC> -= <SPC> 1 <NL>                  break <NL>              prev_bit <SPC> = <SPC> 1 <NL>          else : <NL>              prev_bit <SPC> = <SPC> 0 <NL> <TAB> return <SPC> result <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> eraseOverlapIntervals ( self , <SPC> intervals ) : <NL> <NL> <TAB> intervals . sort ( key = lambda <SPC> interval : <SPC> interval . start ) <NL> <TAB> result , <SPC> prev <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( intervals ) ) : <NL>          if <SPC> intervals [ i ] . start <SPC> < <SPC> intervals [ prev ] . end : <NL>              if <SPC> intervals [ i ] . end <SPC> < <SPC> intervals [ prev ] . end : <NL>                  prev <SPC> = <SPC> i <NL>              result <SPC> += <SPC> 1 <NL>          else : <NL>              prev <SPC> = <SPC> i <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findNthDigit ( self , <SPC> n ) : <NL> <NL> <TAB> digit_len <SPC> = <SPC> 1 <NL> <TAB> while <SPC> n <SPC> > <SPC> digit_len <SPC> * <SPC> 9 <SPC> * <SPC> ( 10 <SPC> ** <SPC> ( digit_len <SPC> - <SPC> 1 ) ) : <NL>          n <SPC> -= <SPC> digit_len <SPC> * <SPC> 9 <SPC> * <SPC> ( 10 <SPC> ** <SPC> ( digit_len <SPC> - <SPC> 1 ) ) <NL>          digit_len <SPC> += <SPC> 1 <NL> <NL> <TAB> num <SPC> = <SPC> 10 <SPC> ** <SPC> ( digit_len <SPC> - <SPC> 1 ) <SPC> + <SPC> ( n <SPC> - <SPC> 1 ) <SPC> / <SPC> digit_len <NL> <NL> <TAB> nth_digit <SPC> = <SPC> num <SPC> / <SPC> ( 10 <SPC> ** <SPC> ( ( digit_len <SPC> - <SPC> 1 ) <SPC> - <SPC> ( ( n <SPC> - <SPC> 1 ) <SPC> % <SPC> digit_len ) ) ) <NL> <TAB> nth_digit <SPC> %= <SPC> 10 <NL> <NL> <TAB> return <SPC> nth_digit <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nthMagicalNumber ( self , <SPC> N , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> def <SPC> gcd ( a , <SPC> b ) : <NL>          while <SPC> b : <NL>              a , <SPC> b <SPC> = <SPC> b , <SPC> a <SPC> % <SPC> b <NL>          return <SPC> a <NL> <NL> <TAB> def <SPC> check ( A , <SPC> B , <SPC> N , <SPC> lcm , <SPC> target ) : <NL>          return <SPC> target <SPC> // <SPC> A <SPC> + <SPC> target <SPC> // <SPC> B <SPC> - <SPC> target <SPC> // <SPC> lcm <SPC> >= <SPC> N <NL> <NL> <TAB> lcm <SPC> = <SPC> A <SPC> * <SPC> B <SPC> // <SPC> gcd ( A , <SPC> B ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> min ( A , <SPC> B ) , <SPC> max ( A , <SPC> B ) <SPC> * <SPC> N <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> check ( A , <SPC> B , <SPC> N , <SPC> lcm , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <SPC> % <SPC> ( 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findComplement ( self , <SPC> num ) : <NL> <NL> <TAB> return <SPC> 2 <SPC> ** <SPC> ( len ( bin ( num ) ) <SPC> - <SPC> 2 ) <SPC> - <SPC> 1 <SPC> - <SPC> num <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findComplement ( self , <SPC> num ) : <NL> <TAB> i <SPC> = <SPC> 1 <NL> <TAB> while <SPC> i <SPC> <= <SPC> num : <NL>          i <SPC> <<= <SPC> 1 <NL> <TAB> return <SPC> ( i <SPC> - <SPC> 1 ) <SPC> ^ <SPC> num <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> findComplement ( self , <SPC> num ) : <NL> <TAB> bits <SPC> = <SPC> "{0:b}" . format ( num ) <NL> <TAB> complement_bits <SPC> = <SPC> "" . join ( "1" <SPC> if <SPC> bit <SPC> == <SPC> "0" <SPC> else <SPC> "0" <SPC> for <SPC> bit <SPC> in <SPC> bits ) <NL> <TAB> return <SPC> int ( complement_bits , <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> hammingWeight ( self , <SPC> n ) : <NL> <TAB> n <SPC> = <SPC> ( n <SPC> & <SPC> 0x55555555 ) <SPC> + <SPC> ( ( n <SPC> >> <SPC> 1 ) <SPC> & <SPC> 0x55555555 ) <NL> <TAB> n <SPC> = <SPC> ( n <SPC> & <SPC> 0x33333333 ) <SPC> + <SPC> ( ( n <SPC> >> <SPC> 2 ) <SPC> & <SPC> 0x33333333 ) <NL> <TAB> n <SPC> = <SPC> ( n <SPC> & <SPC> 0x0F0F0F0F ) <SPC> + <SPC> ( ( n <SPC> >> <SPC> 4 ) <SPC> & <SPC> 0x0F0F0F0F ) <NL> <TAB> n <SPC> = <SPC> ( n <SPC> & <SPC> 0x00FF00FF ) <SPC> + <SPC> ( ( n <SPC> >> <SPC> 8 ) <SPC> & <SPC> 0x00FF00FF ) <NL> <TAB> n <SPC> = <SPC> ( n <SPC> & <SPC> 0x0000FFFF ) <SPC> + <SPC> ( ( n <SPC> >> <SPC> 16 ) <SPC> & <SPC> 0x0000FFFF ) <NL> <TAB> return <SPC> n <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __popcount_tab <SPC> = <SPC> [ <NL>          0 , <NL>          1 , <NL>          1 , <NL>          2 , <NL>          1 , <NL>          2 , <NL>          2 , <NL>          3 , <NL>          1 , <NL>          2 , <NL>          2 , <NL>          3 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          1 , <NL>          2 , <NL>          2 , <NL>          3 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          1 , <NL>          2 , <NL>          2 , <NL>          3 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          1 , <NL>          2 , <NL>          2 , <NL>          3 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          5 , <NL>          6 , <NL>          6 , <NL>          7 , <NL>          1 , <NL>          2 , <NL>          2 , <NL>          3 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          5 , <NL>          6 , <NL>          6 , <NL>          7 , <NL>          2 , <NL>          3 , <NL>          3 , <NL>          4 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          5 , <NL>          6 , <NL>          6 , <NL>          7 , <NL>          3 , <NL>          4 , <NL>          4 , <NL>          5 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          5 , <NL>          6 , <NL>          6 , <NL>          7 , <NL>          4 , <NL>          5 , <NL>          5 , <NL>          6 , <NL>          5 , <NL>          6 , <NL>          6 , <NL>          7 , <NL>          5 , <NL>          6 , <NL>          6 , <NL>          7 , <NL>          6 , <NL>          7 , <NL>          7 , <NL>          8 , <NL> <TAB> ] <NL> <NL> <TAB> def <SPC> hammingWeight ( self , <SPC> n ) : <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> n : <NL>          result <SPC> += <SPC> self . __popcount_tab [ n <SPC> & <SPC> 0xFF ] <NL>          n <SPC> >>= <SPC> 8 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <NL> <TAB> def <SPC> hammingWeight ( self , <SPC> n ) : <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> n : <NL>          n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL>          result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> re <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countOfAtoms ( self , <SPC> formula ) : <NL> <NL> <TAB> parse <SPC> = <SPC> re . findall ( r"([A-Z][a-z]*)(\d*)|(\()|(\))(\d*)" , <SPC> formula ) <NL> <TAB> stk <SPC> = <SPC> [ collections . Counter ( ) ] <NL> <TAB> for <SPC> name , <SPC> m1 , <SPC> left_open , <SPC> right_open , <SPC> m2 <SPC> in <SPC> parse : <NL>          if <SPC> name : <NL>              stk [ - 1 ] [ name ] <SPC> += <SPC> int ( m1 <SPC> or <SPC> 1 ) <NL>          if <SPC> left_open : <NL>              stk . append ( collections . Counter ( ) ) <NL>          if <SPC> right_open : <NL>              top <SPC> = <SPC> stk . pop ( ) <NL>              for <SPC> k , <SPC> v <SPC> in <SPC> top . iteritems ( ) : <NL>                  stk [ - 1 ] [ k ] <SPC> += <SPC> v <SPC> * <SPC> int ( m2 <SPC> or <SPC> 1 ) <NL> <NL> <TAB> return <SPC> "" . join ( <NL>          name <SPC> + <SPC> ( str ( stk [ - 1 ] [ name ] ) <SPC> if <SPC> stk [ - 1 ] [ name ] <SPC> > <SPC> 1 <SPC> else <SPC> "" ) <NL>          for <SPC> name <SPC> in <SPC> sorted ( stk [ - 1 ] ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfBoomerangs ( self , <SPC> points ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( points ) ) : <NL>          group <SPC> = <SPC> collections . defaultdict ( int ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( points ) ) : <NL>              if <SPC> j <SPC> == <SPC> i : <NL>                  continue <NL>              dx , <SPC> dy <SPC> = <SPC> points [ i ] [ 0 ] <SPC> - <SPC> points [ j ] [ 0 ] , <SPC> points [ i ] [ 1 ] <SPC> - <SPC> points [ j ] [ 1 ] <NL>              group [ dx <SPC> ** <SPC> 2 <SPC> + <SPC> dy <SPC> ** <SPC> 2 ] <SPC> += <SPC> 1 <NL> <NL>          for <SPC> _ , <SPC> v <SPC> in <SPC> group . iteritems ( ) : <NL>              if <SPC> v <SPC> > <SPC> 1 : <NL>                  result <SPC> += <SPC> v <SPC> * <SPC> ( v <SPC> - <SPC> 1 ) <NL> <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> numberOfBoomerangs2 ( self , <SPC> points ) : <NL> <NL> <TAB> cnt <SPC> = <SPC> 0 <NL> <TAB> for <SPC> a , <SPC> i <SPC> in <SPC> enumerate ( points ) : <NL>          dis_list <SPC> = <SPC> [ ] <NL>          for <SPC> b , <SPC> k <SPC> in <SPC> enumerate ( points [ : a ] <SPC> + <SPC> points [ a <SPC> + <SPC> 1 : ] ) : <NL>              dis_list . append ( ( k [ 0 ] <SPC> - <SPC> i [ 0 ] ) <SPC> ** <SPC> 2 <SPC> + <SPC> ( k [ 1 ] <SPC> - <SPC> i [ 1 ] ) <SPC> ** <SPC> 2 ) <NL>          for <SPC> z <SPC> in <SPC> collections . Counter ( dis_list ) . values ( ) : <NL>              if <SPC> z <SPC> > <SPC> 1 : <NL>                  cnt <SPC> += <SPC> z <SPC> * <SPC> ( z <SPC> - <SPC> 1 ) <NL> <TAB> return <SPC> cnt <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numOfBurgers ( self , <SPC> tomatoSlices , <SPC> cheeseSlices ) : <NL> <NL> <TAB> return <SPC> ( <NL>          [ tomatoSlices <SPC> // <SPC> 2 <SPC> - <SPC> cheeseSlices , <SPC> 2 <SPC> * <SPC> cheeseSlices <SPC> - <SPC> tomatoSlices <SPC> // <SPC> 2 ] <NL>          if <SPC> tomatoSlices <SPC> % <SPC> 2 <SPC> == <SPC> 0 <NL>          and <SPC> 2 <SPC> * <SPC> cheeseSlices <SPC> <= <SPC> tomatoSlices <SPC> <= <SPC> 4 <SPC> * <SPC> cheeseSlices <NL>          else <SPC> [ ] <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> closedIsland ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> fill ( grid , <SPC> i , <SPC> j ) : <NL>          if <SPC> not <SPC> ( 0 <SPC> <= <SPC> i <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> len ( grid [ 0 ] ) <SPC> and <SPC> grid [ i ] [ j ] <SPC> == <SPC> 0 ) : <NL>              return <SPC> False <NL>          grid [ i ] [ j ] <SPC> = <SPC> 1 <NL>          for <SPC> dx , <SPC> dy <SPC> in <SPC> directions : <NL>              fill ( grid , <SPC> i <SPC> + <SPC> dx , <SPC> j <SPC> + <SPC> dy ) <NL>          return <SPC> True <NL> <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>          fill ( grid , <SPC> 0 , <SPC> j ) <NL>          fill ( grid , <SPC> len ( grid ) <SPC> - <SPC> 1 , <SPC> j ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( grid ) ) : <NL>          fill ( grid , <SPC> i , <SPC> 0 ) <NL>          fill ( grid , <SPC> i , <SPC> len ( grid [ 0 ] ) <SPC> - <SPC> 1 ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( grid ) <SPC> - <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( grid [ 0 ] ) <SPC> - <SPC> 1 ) : <NL>              if <SPC> fill ( grid , <SPC> i , <SPC> j ) : <NL>                  result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . count <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> != <SPC> y_root : <NL>          self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL>          self . count <SPC> -= <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countComponents ( self , <SPC> n , <SPC> edges ) : <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( n ) <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> edges : <NL>          union_find . union_set ( i , <SPC> j ) <NL> <TAB> return <SPC> union_find . count <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countCornerRectangles ( self , <SPC> grid ) : <NL> <NL> <TAB> rows <SPC> = <SPC> [ [ c <SPC> for <SPC> c , <SPC> val <SPC> in <SPC> enumerate ( row ) <SPC> if <SPC> val ] <SPC> for <SPC> row <SPC> in <SPC> grid ] <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( rows ) ) : <NL>          lookup <SPC> = <SPC> set ( rows [ i ] ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( i ) : <NL>              count <SPC> = <SPC> sum ( 1 <SPC> for <SPC> c <SPC> in <SPC> rows [ j ] <SPC> if <SPC> c <SPC> in <SPC> lookup ) <NL>              result <SPC> += <SPC> count <SPC> * <SPC> ( count <SPC> - <SPC> 1 ) <SPC> / <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> def <SPC> dayOfMonth ( M ) : <NL>          return <SPC> 28 <SPC> if <SPC> ( M <SPC> == <SPC> 2 ) <SPC> else <SPC> 31 <SPC> - <SPC> ( M <SPC> - <SPC> 1 ) <SPC> % <SPC> 7 <SPC> % <SPC> 2 <NL> <NL> <TAB> self . __lookup <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 12 <NL> <TAB> for <SPC> M <SPC> in <SPC> xrange ( 1 , <SPC> len ( self . __lookup ) ) : <NL>          self . __lookup [ M ] <SPC> += <SPC> self . __lookup [ M <SPC> - <SPC> 1 ] <SPC> + <SPC> dayOfMonth ( M ) <NL> <NL> <TAB> def <SPC> daysBetweenDates ( self , <SPC> date1 , <SPC> date2 ) : <NL> <NL> <TAB> def <SPC> num_days ( date ) : <NL>          Y , <SPC> M , <SPC> D <SPC> = <SPC> map ( int , <SPC> date . split ( "-" ) ) <NL>          leap <SPC> = <SPC> ( <NL>              1 <NL>              if <SPC> M <SPC> > <SPC> 2 <SPC> and <SPC> ( ( ( Y <SPC> % <SPC> 4 <SPC> == <SPC> 0 ) <SPC> and <SPC> ( Y <SPC> % <SPC> 100 <SPC> != <SPC> 0 ) ) <SPC> or <SPC> ( Y <SPC> % <SPC> 400 <SPC> == <SPC> 0 ) ) <NL>              else <SPC> 0 <NL>          ) <NL>          return <SPC> ( <NL>              ( Y <SPC> - <SPC> 1 ) <SPC> * <SPC> 365 <NL>              + <SPC> ( ( Y <SPC> - <SPC> 1 ) <SPC> // <SPC> 4 <SPC> - <SPC> ( Y <SPC> - <SPC> 1 ) <SPC> // <SPC> 100 <SPC> + <SPC> ( Y <SPC> - <SPC> 1 ) <SPC> // <SPC> 400 ) <NL>              + <SPC> self . __lookup [ M <SPC> - <SPC> 1 ] <NL>              + <SPC> D <NL>              + <SPC> leap <NL>          ) <NL> <NL> <TAB> return <SPC> abs ( num_days ( date1 ) <SPC> - <SPC> num_days ( date2 ) ) <NL> <NL> <NL> import <SPC> datetime <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> daysBetweenDates ( self , <SPC> date1 , <SPC> date2 ) : <NL> <TAB> delta <SPC> = <SPC> datetime . datetime . strptime ( date1 , <SPC> "%Y-%m-%d" ) <NL> <TAB> delta <SPC> -= <SPC> datetime . datetime . strptime ( date2 , <SPC> "%Y-%m-%d" ) <NL> <TAB> return <SPC> abs ( delta . days ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfDays ( self , <SPC> Y , <SPC> M ) : <NL> <NL> <TAB> leap <SPC> = <SPC> 1 <SPC> if <SPC> ( ( Y <SPC> % <SPC> 4 <SPC> == <SPC> 0 ) <SPC> and <SPC> ( Y <SPC> % <SPC> 100 <SPC> != <SPC> 0 ) ) <SPC> or <SPC> ( Y <SPC> % <SPC> 400 <SPC> == <SPC> 0 ) <SPC> else <SPC> 0 <NL> <TAB> return <SPC> 28 <SPC> + <SPC> leap <SPC> if <SPC> ( M <SPC> == <SPC> 2 ) <SPC> else <SPC> 31 <SPC> - <SPC> ( M <SPC> - <SPC> 1 ) <SPC> % <SPC> 7 <SPC> % <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numRollsToTarget ( self , <SPC> d , <SPC> f , <SPC> target ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( target <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> d <SPC> + <SPC> 1 ) : <NL>          dp [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( target <SPC> + <SPC> 1 ) ] <NL>          for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> f <SPC> + <SPC> 1 ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( k , <SPC> target <SPC> + <SPC> 1 ) : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> ( dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> + <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> k ] ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> dp [ d <SPC> % <SPC> 2 ] [ target ] <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countDigitOne ( self , <SPC> n ) : <NL> <NL> <TAB> DIGIT <SPC> = <SPC> 1 <NL> <TAB> is_zero <SPC> = <SPC> int ( DIGIT <SPC> == <SPC> 0 ) <NL> <TAB> result <SPC> = <SPC> is_zero <NL> <TAB> base <SPC> = <SPC> 1 <NL> <TAB> while <SPC> n <SPC> >= <SPC> base : <NL>          result <SPC> += <SPC> ( n <SPC> // <SPC> ( 10 <SPC> * <SPC> base ) <SPC> - <SPC> is_zero ) <SPC> * <SPC> base <SPC> + <SPC> min ( <NL>              base , <SPC> max ( n <SPC> % <SPC> ( 10 <SPC> * <SPC> base ) <SPC> - <SPC> DIGIT <SPC> * <SPC> base <SPC> + <SPC> 1 , <SPC> 0 ) <NL>          ) <NL>          base <SPC> *= <SPC> 10 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numDistinctIslands2 ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> dfs ( i , <SPC> j , <SPC> grid , <SPC> island ) : <NL>          if <SPC> not <SPC> ( 0 <SPC> <= <SPC> i <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> len ( grid [ 0 ] ) <SPC> and <SPC> grid [ i ] [ j ] <SPC> > <SPC> 0 ) : <NL>              return <SPC> False <NL>          grid [ i ] [ j ] <SPC> *= <SPC> - 1 <NL>          island . append ( ( i , <SPC> j ) ) <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              dfs ( i <SPC> + <SPC> d [ 0 ] , <SPC> j <SPC> + <SPC> d [ 1 ] , <SPC> grid , <SPC> island ) <NL>          return <SPC> True <NL> <NL> <TAB> def <SPC> normalize ( island ) : <NL>          shapes <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 8 ) ] <NL>          for <SPC> x , <SPC> y <SPC> in <SPC> island : <NL>              rotations_and_reflections <SPC> = <SPC> [ <NL>                  [ x , <SPC> y ] , <NL>                  [ x , <SPC> - y ] , <NL>                  [ - x , <SPC> y ] , <NL>                  [ - x , <SPC> - y ] , <NL>                  [ y , <SPC> x ] , <NL>                  [ y , <SPC> - x ] , <NL>                  [ - y , <SPC> x ] , <NL>                  [ - y , <SPC> - x ] , <NL>              ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( rotations_and_reflections ) ) : <NL>                  shapes [ i ] . append ( rotations_and_reflections [ i ] ) <NL>          for <SPC> shape <SPC> in <SPC> shapes : <NL>              shape . sort ( ) <NL>              origin <SPC> = <SPC> list ( shape [ 0 ] ) <NL>              for <SPC> p <SPC> in <SPC> shape : <NL>                  p [ 0 ] <SPC> -= <SPC> origin [ 0 ] <NL>                  p [ 1 ] <SPC> -= <SPC> origin [ 1 ] <NL>          return <SPC> min ( shapes ) <NL> <NL> <TAB> islands <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              island <SPC> = <SPC> [ ] <NL>              if <SPC> dfs ( i , <SPC> j , <SPC> grid , <SPC> island ) : <NL>                  islands . add ( str ( normalize ( island ) ) ) <NL> <TAB> return <SPC> len ( islands ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numDistinctIslands ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> { "l" : <SPC> [ - 1 , <SPC> 0 ] , <SPC> "r" : <SPC> [ 1 , <SPC> 0 ] , <SPC> "u" : <SPC> [ 0 , <SPC> 1 ] , <SPC> "d" : <SPC> [ 0 , <SPC> - 1 ] } <NL> <NL> <TAB> def <SPC> dfs ( i , <SPC> j , <SPC> grid , <SPC> island ) : <NL>          if <SPC> not <SPC> ( 0 <SPC> <= <SPC> i <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> len ( grid [ 0 ] ) <SPC> and <SPC> grid [ i ] [ j ] <SPC> > <SPC> 0 ) : <NL>              return <SPC> False <NL>          grid [ i ] [ j ] <SPC> *= <SPC> - 1 <NL>          for <SPC> k , <SPC> v <SPC> in <SPC> directions . iteritems ( ) : <NL>              island . append ( k ) <NL>              dfs ( i <SPC> + <SPC> v [ 0 ] , <SPC> j <SPC> + <SPC> v [ 1 ] , <SPC> grid , <SPC> island ) <NL>          return <SPC> True <NL> <NL> <TAB> islands <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              island <SPC> = <SPC> [ ] <NL>              if <SPC> dfs ( i , <SPC> j , <SPC> grid , <SPC> island ) : <NL>                  islands . add ( "" . join ( island ) ) <NL> <TAB> return <SPC> len ( islands ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> distinctSubarraysWithAtMostKOddIntegers ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> def <SPC> countDistinct ( A , <SPC> left , <SPC> right , <SPC> trie ) : <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( left , <SPC> right <SPC> + <SPC> 1 ) ) : <NL>              if <SPC> A [ i ] <SPC> not <SPC> in <SPC> trie : <NL>                  result <SPC> += <SPC> 1 <NL>              trie <SPC> = <SPC> trie [ A [ i ] ] <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> trie <SPC> = <SPC> _trie ( ) <NL> <TAB> result , <SPC> left , <SPC> count <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          count <SPC> += <SPC> A [ right ] <SPC> % <SPC> 2 <NL>          while <SPC> count <SPC> > <SPC> K : <NL>              count <SPC> -= <SPC> A [ left ] <SPC> % <SPC> 2 <NL>              left <SPC> += <SPC> 1 <NL>          result <SPC> += <SPC> countDistinct ( A , <SPC> left , <SPC> right , <SPC> trie ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> distinctSubarraysWithAtMostKOddIntegers ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> def <SPC> countDistinct ( A , <SPC> left , <SPC> right , <SPC> trie ) : <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right <SPC> + <SPC> 1 ) : <NL>              if <SPC> A [ i ] <SPC> not <SPC> in <SPC> trie : <NL>                  result <SPC> += <SPC> 1 <NL>              trie <SPC> = <SPC> trie [ A [ i ] ] <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> trie <SPC> = <SPC> _trie ( ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> left <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          count <SPC> = <SPC> 0 <NL>          for <SPC> right <SPC> in <SPC> xrange ( left , <SPC> len ( A ) ) : <NL>              count <SPC> += <SPC> A [ right ] <SPC> % <SPC> 2 <NL>              if <SPC> count <SPC> > <SPC> K : <NL>                  right <SPC> -= <SPC> 1 <NL>                  break <NL>          result <SPC> += <SPC> countDistinct ( A , <SPC> left , <SPC> right , <SPC> trie ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countDistinct ( self , <SPC> s ) : <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> trie <SPC> = <SPC> { } <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          curr <SPC> = <SPC> trie <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> len ( s ) ) : <NL>              if <SPC> s [ j ] <SPC> not <SPC> in <SPC> curr : <NL>                  count <SPC> += <SPC> 1 <NL>                  curr [ s [ j ] ] <SPC> = <SPC> { } <NL>              curr <SPC> = <SPC> curr [ s [ j ] ] <NL> <TAB> return <SPC> count <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numEnclaves ( self , <SPC> A ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> dfs ( A , <SPC> i , <SPC> j ) : <NL>          if <SPC> not <SPC> ( 0 <SPC> <= <SPC> i <SPC> < <SPC> len ( A ) <SPC> and <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> len ( A [ 0 ] ) <SPC> and <SPC> A [ i ] [ j ] ) : <NL>              return <NL>          A [ i ] [ j ] <SPC> = <SPC> 0 <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              dfs ( A , <SPC> i <SPC> + <SPC> d [ 0 ] , <SPC> j <SPC> + <SPC> d [ 1 ] ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          dfs ( A , <SPC> i , <SPC> 0 ) <NL>          dfs ( A , <SPC> i , <SPC> len ( A [ 0 ] ) <SPC> - <SPC> 1 ) <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( A [ 0 ] ) <SPC> - <SPC> 1 ) : <NL>          dfs ( A , <SPC> 0 , <SPC> j ) <NL>          dfs ( A , <SPC> len ( A ) <SPC> - <SPC> 1 , <SPC> j ) <NL> <TAB> return <SPC> sum ( sum ( row ) <SPC> for <SPC> row <SPC> in <SPC> A ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numEquivDominoPairs ( self , <SPC> dominoes ) : <NL> <NL> <TAB> counter <SPC> = <SPC> collections . Counter ( ( min ( x ) , <SPC> max ( x ) ) <SPC> for <SPC> x <SPC> in <SPC> dominoes ) <NL> <TAB> return <SPC> sum ( v <SPC> * <SPC> ( v <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 <SPC> for <SPC> v <SPC> in <SPC> counter . itervalues ( ) ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countPairs ( self , <SPC> root , <SPC> distance ) : <NL> <NL> <TAB> def <SPC> iter_dfs ( distance , <SPC> root ) : <NL>          result <SPC> = <SPC> 0 <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> ( root , <SPC> [ collections . Counter ( ) ] ) ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  node , <SPC> ret <SPC> = <SPC> params <NL>                  if <SPC> not <SPC> node : <NL>                      continue <NL>                  if <SPC> not <SPC> node . left <SPC> and <SPC> not <SPC> node . right : <NL>                      ret [ 0 ] [ 0 ] <SPC> = <SPC> 1 <NL>                      continue <NL>                  left , <SPC> right <SPC> = <SPC> [ collections . Counter ( ) ] , <SPC> [ collections . Counter ( ) ] <NL>                  stk . append ( ( 2 , <SPC> ( left , <SPC> right , <SPC> ret ) ) ) <NL>                  stk . append ( ( 1 , <SPC> ( node . right , <SPC> right ) ) ) <NL>                  stk . append ( ( 1 , <SPC> ( node . left , <SPC> left ) ) ) <NL>              else : <NL>                  left , <SPC> right , <SPC> ret <SPC> = <SPC> params <NL>                  for <SPC> left_d , <SPC> left_c <SPC> in <SPC> left [ 0 ] . iteritems ( ) : <NL>                      for <SPC> right_d , <SPC> right_c <SPC> in <SPC> right [ 0 ] . iteritems ( ) : <NL>                          if <SPC> left_d <SPC> + <SPC> right_d <SPC> + <SPC> 2 <SPC> <= <SPC> distance : <NL>                              result <SPC> += <SPC> left_c <SPC> * <SPC> right_c <NL>                  ret [ 0 ] <SPC> = <SPC> collections . Counter ( <NL>                      { k <SPC> + <SPC> 1 : <SPC> v <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> ( left [ 0 ] <SPC> + <SPC> right [ 0 ] ) . iteritems ( ) } <NL>                  ) <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> iter_dfs ( distance , <SPC> root ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> countPairs ( self , <SPC> root , <SPC> distance ) : <NL> <NL> <TAB> def <SPC> dfs ( distance , <SPC> node ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> 0 , <SPC> collections . Counter ( ) <NL>          if <SPC> not <SPC> node . left <SPC> and <SPC> not <SPC> node . right : <NL>              return <SPC> 0 , <SPC> collections . Counter ( [ 0 ] ) <NL>          left , <SPC> right <SPC> = <SPC> dfs ( distance , <SPC> node . left ) , <SPC> dfs ( distance , <SPC> node . right ) <NL>          result <SPC> = <SPC> left [ 0 ] <SPC> + <SPC> right [ 0 ] <NL>          for <SPC> left_d , <SPC> left_c <SPC> in <SPC> left [ 1 ] . iteritems ( ) : <NL>              for <SPC> right_d , <SPC> right_c <SPC> in <SPC> right [ 1 ] . iteritems ( ) : <NL>                  if <SPC> left_d <SPC> + <SPC> right_d <SPC> + <SPC> 2 <SPC> <= <SPC> distance : <NL>                      result <SPC> += <SPC> left_c <SPC> * <SPC> right_c <NL>          return <SPC> result , <SPC> collections . Counter ( <NL>              { k <SPC> + <SPC> 1 : <SPC> v <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> ( left [ 1 ] <SPC> + <SPC> right [ 1 ] ) . iteritems ( ) } <NL>          ) <NL> <NL> <TAB> return <SPC> dfs ( distance , <SPC> root ) [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numIdenticalPairs ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> sum ( c <SPC> * <SPC> ( c <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 <SPC> for <SPC> c <SPC> in <SPC> collections . Counter ( nums ) . itervalues ( ) ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSplits ( self , <SPC> s ) : <NL> <NL> <TAB> left_count , <SPC> right_count <SPC> = <SPC> collections . Counter ( ) , <SPC> collections . Counter ( s ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          left_count [ c ] <SPC> += <SPC> 1 <NL>          right_count [ c ] <SPC> -= <SPC> 1 <NL>          if <SPC> not <SPC> right_count [ c ] : <NL>              del <SPC> right_count [ c ] <NL>          if <SPC> len ( left_count ) <SPC> == <SPC> len ( right_count ) : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numIslands2 ( self , <SPC> m , <SPC> n , <SPC> positions ) : <NL> <NL> <TAB> def <SPC> node_id ( node , <SPC> n ) : <NL>          return <SPC> node [ 0 ] <SPC> * <SPC> n <SPC> + <SPC> node [ 1 ] <NL> <NL> <TAB> def <SPC> find_set ( x ) : <NL>          if <SPC> set [ x ] <SPC> != <SPC> x : <NL>              set [ x ] <SPC> = <SPC> find_set ( set [ x ] ) <NL>          return <SPC> set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( x , <SPC> y ) : <NL>          x_root , <SPC> y_root <SPC> = <SPC> find_set ( x ) , <SPC> find_set ( y ) <NL>          set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <NL> <TAB> numbers <SPC> = <SPC> [ ] <NL> <TAB> number <SPC> = <SPC> 0 <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <TAB> set <SPC> = <SPC> { } <NL> <TAB> for <SPC> position <SPC> in <SPC> positions : <NL>          node <SPC> = <SPC> ( position [ 0 ] , <SPC> position [ 1 ] ) <NL>          set [ node_id ( node , <SPC> n ) ] <SPC> = <SPC> node_id ( node , <SPC> n ) <NL>          number <SPC> += <SPC> 1 <NL> <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              neighbor <SPC> = <SPC> ( position [ 0 ] <SPC> + <SPC> d [ 0 ] , <SPC> position [ 1 ] <SPC> + <SPC> d [ 1 ] ) <NL>              if <SPC> ( <NL>                  0 <SPC> <= <SPC> neighbor [ 0 ] <SPC> < <SPC> m <NL>                  and <SPC> 0 <SPC> <= <SPC> neighbor [ 1 ] <SPC> < <SPC> n <NL>                  and <SPC> node_id ( neighbor , <SPC> n ) <SPC> in <SPC> set <NL>              ) : <NL>                  if <SPC> find_set ( node_id ( node , <SPC> n ) ) <SPC> != <SPC> find_set ( node_id ( neighbor , <SPC> n ) ) : <NL> <NL>                      union_set ( node_id ( node , <SPC> n ) , <SPC> node_id ( neighbor , <SPC> n ) ) <NL>                      number <SPC> -= <SPC> 1 <NL>          numbers . append ( number ) <NL> <NL> <TAB> return <SPC> numbers <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . count <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> != <SPC> y_root : <NL>          self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL>          self . count <SPC> -= <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numIslands ( self , <SPC> grid ) : <NL> <NL> <TAB> def <SPC> index ( n , <SPC> i , <SPC> j ) : <NL>          return <SPC> i <SPC> * <SPC> n <SPC> + <SPC> j <NL> <NL> <TAB> if <SPC> not <SPC> grid : <NL>          return <SPC> 0 <NL> <NL> <TAB> zero_count <SPC> = <SPC> 0 <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( grid ) <SPC> * <SPC> len ( grid [ 0 ] ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> == <SPC> "1" : <NL>                  if <SPC> i <SPC> and <SPC> grid [ i <SPC> - <SPC> 1 ] [ j ] <SPC> == <SPC> "1" : <NL>                      union_find . union_set ( <NL>                          index ( len ( grid [ 0 ] ) , <SPC> i <SPC> - <SPC> 1 , <NL>                                j ) , <SPC> index ( len ( grid [ 0 ] ) , <SPC> i , <SPC> j ) <NL>                      ) <NL>                  if <SPC> j <SPC> and <SPC> grid [ i ] [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> "1" : <NL>                      union_find . union_set ( <NL>                          index ( len ( grid [ 0 ] ) , <SPC> i , <SPC> j <SPC> - <NL>                                1 ) , <SPC> index ( len ( grid [ 0 ] ) , <SPC> i , <SPC> j ) <NL>                      ) <NL>              else : <NL>                  zero_count <SPC> += <SPC> 1 <NL> <TAB> return <SPC> union_find . count <SPC> - <SPC> zero_count <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numIslands ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> dfs ( grid , <SPC> i , <SPC> j ) : <NL>          if <SPC> grid [ i ] [ j ] <SPC> == <SPC> "0" : <NL>              return <SPC> False <NL>          grid [ i ] [ j ] <SPC> = <SPC> "0" <NL>          stk <SPC> = <SPC> [ ( i , <SPC> j ) ] <NL>          while <SPC> stk : <NL>              r , <SPC> c <SPC> = <SPC> stk . pop ( ) <NL>              for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                  nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr , <SPC> c <SPC> + <SPC> dc <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( grid ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                      and <SPC> grid [ nr ] [ nc ] <SPC> == <SPC> "1" <NL>                  ) : <NL>                      continue <NL>                  grid [ nr ] [ nc ] <SPC> = <SPC> "0" <NL>                  stk . append ( ( nr , <SPC> nc ) ) <NL>          return <SPC> True <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> dfs ( grid , <SPC> i , <SPC> j ) : <NL>                  count <SPC> += <SPC> 1 <NL> <TAB> return <SPC> count <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> numIslands ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> bfs ( grid , <SPC> i , <SPC> j ) : <NL>          if <SPC> grid [ i ] [ j ] <SPC> == <SPC> "0" : <NL>              return <SPC> False <NL>          grid [ i ] [ j ] <SPC> = <SPC> "0" <NL>          q <SPC> = <SPC> collections . deque ( [ ( i , <SPC> j ) ] ) <NL>          while <SPC> q : <NL>              r , <SPC> c <SPC> = <SPC> q . popleft ( ) <NL>              for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                  nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr , <SPC> c <SPC> + <SPC> dc <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( grid ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                      and <SPC> grid [ nr ] [ nc ] <SPC> == <SPC> "1" <NL>                  ) : <NL>                      continue <NL>                  grid [ nr ] [ nc ] <SPC> = <SPC> "0" <NL>                  q . append ( ( nr , <SPC> nc ) ) <NL>          return <SPC> True <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> bfs ( grid , <SPC> i , <SPC> j ) : <NL>                  count <SPC> += <SPC> 1 <NL> <TAB> return <SPC> count <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfLines ( self , <SPC> widths , <SPC> S ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 1 , <SPC> 0 ] <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          w <SPC> = <SPC> widths [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <NL>          result [ 1 ] <SPC> += <SPC> w <NL>          if <SPC> result [ 1 ] <SPC> > <SPC> 100 : <NL>              result [ 0 ] <SPC> += <SPC> 1 <NL>              result [ 1 ] <SPC> = <SPC> w <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findNumberOfLIS ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> max_len <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> dp <SPC> = <SPC> [ [ 1 , <SPC> 1 ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( nums ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i ) : <NL>              if <SPC> nums [ i ] <SPC> > <SPC> nums [ j ] : <NL>                  if <SPC> dp [ i ] [ 0 ] <SPC> == <SPC> dp [ j ] [ 0 ] <SPC> + <SPC> 1 : <NL>                      dp [ i ] [ 1 ] <SPC> += <SPC> dp [ j ] [ 1 ] <NL>                  elif <SPC> dp [ i ] [ 0 ] <SPC> < <SPC> dp [ j ] [ 0 ] <SPC> + <SPC> 1 : <NL>                      dp [ i ] <SPC> = <SPC> [ dp [ j ] [ 0 ] <SPC> + <SPC> 1 , <SPC> dp [ j ] [ 1 ] ] <NL>          if <SPC> max_len <SPC> == <SPC> dp [ i ] [ 0 ] : <NL>              result <SPC> += <SPC> dp [ i ] [ 1 ] <NL>          elif <SPC> max_len <SPC> < <SPC> dp [ i ] [ 0 ] : <NL>              max_len <SPC> = <SPC> dp [ i ] [ 0 ] <NL>              result <SPC> = <SPC> dp [ i ] [ 1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numMatchingSubseq ( self , <SPC> S , <SPC> words ) : <NL> <NL> <TAB> waiting <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          it <SPC> = <SPC> iter ( word ) <NL>          waiting [ next ( it , <SPC> None ) ] . append ( it ) <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          for <SPC> it <SPC> in <SPC> waiting . pop ( c , <SPC> ( ) ) : <NL>              waiting [ next ( it , <SPC> None ) ] . append ( it ) <NL> <TAB> return <SPC> len ( waiting [ None ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numMusicPlaylists ( self , <SPC> N , <SPC> L , <SPC> K ) : <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 1 <SPC> + <SPC> L ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> dp [ 1 ] [ 1 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> n <SPC> in <SPC> xrange ( 1 , <SPC> N <SPC> + <SPC> 1 ) : <NL>          dp [ n <SPC> % <SPC> 2 ] [ n ] <SPC> = <SPC> ( dp [ ( n <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ n <SPC> - <SPC> 1 ] <SPC> * <SPC> n ) <SPC> % <SPC> M <NL>          for <SPC> l <SPC> in <SPC> xrange ( n <SPC> + <SPC> 1 , <SPC> L <SPC> + <SPC> 1 ) : <NL>              dp [ n <SPC> % <SPC> 2 ] [ l ] <SPC> = <SPC> ( <NL>                  ( dp [ n <SPC> % <SPC> 2 ] [ l <SPC> - <SPC> 1 ] <SPC> * <SPC> max ( n <SPC> - <SPC> K , <SPC> 0 ) ) <SPC> % <SPC> M <NL>                  + <SPC> ( dp [ ( n <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ l <SPC> - <SPC> 1 ] <SPC> * <SPC> n ) <SPC> % <SPC> M <NL>              ) <SPC> % <SPC> M <NL> <TAB> return <SPC> dp [ N <SPC> % <SPC> 2 ] [ L ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countSubTrees ( self , <SPC> n , <SPC> edges , <SPC> labels ) : <NL> <NL> <TAB> def <SPC> iter_dfs ( labels , <SPC> adj , <SPC> node , <SPC> parent , <SPC> result ) : <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> ( node , <SPC> parent , <SPC> [ 0 ] <SPC> * <SPC> 26 ) ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  node , <SPC> parent , <SPC> ret <SPC> = <SPC> params <NL>                  stk . append ( ( 4 , <SPC> ( node , <SPC> ret ) ) ) <NL>                  stk . append ( ( 2 , <SPC> ( node , <SPC> parent , <SPC> reversed ( adj [ node ] ) , <SPC> ret ) ) ) <NL>              elif <SPC> step <SPC> == <SPC> 2 : <NL>                  node , <SPC> parent , <SPC> it , <SPC> ret <SPC> = <SPC> params <NL>                  child <SPC> = <SPC> next ( it , <SPC> None ) <NL>                  if <SPC> not <SPC> child <SPC> or <SPC> child <SPC> == <SPC> parent : <NL>                      continue <NL>                  ret2 <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL>                  stk . append ( ( 2 , <SPC> ( node , <SPC> parent , <SPC> it , <SPC> ret ) ) ) <NL>                  stk . append ( ( 3 , <SPC> ( ret2 , <SPC> ret ) ) ) <NL>                  stk . append ( ( 1 , <SPC> ( child , <SPC> node , <SPC> ret2 ) ) ) <NL>              elif <SPC> step <SPC> == <SPC> 3 : <NL>                  ret2 , <SPC> ret <SPC> = <SPC> params <NL>                  for <SPC> k <SPC> in <SPC> xrange ( len ( ret2 ) ) : <NL>                      ret [ k ] <SPC> += <SPC> ret2 [ k ] <NL>              else : <NL>                  node , <SPC> ret <SPC> = <SPC> params <NL>                  ret [ ord ( labels [ node ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL>                  result [ node ] <SPC> += <SPC> ret [ ord ( labels [ node ] ) <SPC> - <SPC> ord ( "a" ) ] <NL> <NL> <TAB> adj <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          adj [ u ] . append ( v ) <NL>          adj [ v ] . append ( u ) <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> iter_dfs ( labels , <SPC> adj , <SPC> 0 , <SPC> - 1 , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> countSubTrees ( self , <SPC> n , <SPC> edges , <SPC> labels ) : <NL> <NL> <TAB> def <SPC> dfs ( labels , <SPC> adj , <SPC> node , <SPC> parent , <SPC> result ) : <NL>          count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL>          for <SPC> child <SPC> in <SPC> adj [ node ] : <NL>              if <SPC> child <SPC> == <SPC> parent : <NL>                  continue <NL>              new_count <SPC> = <SPC> dfs ( labels , <SPC> adj , <SPC> child , <SPC> node , <SPC> result ) <NL>              for <SPC> k <SPC> in <SPC> xrange ( len ( new_count ) ) : <NL>                  count [ k ] <SPC> += <SPC> new_count [ k ] <NL>          count [ ord ( labels [ node ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL>          result [ node ] <SPC> = <SPC> count [ ord ( labels [ node ] ) <SPC> - <SPC> ord ( "a" ) ] <NL>          return <SPC> count <NL> <NL> <TAB> adj <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          adj [ u ] . append ( v ) <NL>          adj [ v ] . append ( u ) <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> dfs ( labels , <SPC> adj , <SPC> 0 , <SPC> - 1 , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . count <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ max ( x_root , <SPC> y_root ) ] <SPC> = <SPC> min ( x_root , <SPC> y_root ) <NL> <TAB> self . count <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> makeConnected ( self , <SPC> n , <SPC> connections ) : <NL> <NL> <TAB> if <SPC> len ( connections ) <SPC> < <SPC> n <SPC> - <SPC> 1 : <NL>          return <SPC> - 1 <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( n ) <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> connections : <NL>          union_find . union_set ( i , <SPC> j ) <NL> <TAB> return <SPC> union_find . count <SPC> - <SPC> 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> makeConnected ( self , <SPC> n , <SPC> connections ) : <NL> <NL> <TAB> def <SPC> dfs ( i , <SPC> lookup ) : <NL>          if <SPC> i <SPC> in <SPC> lookup : <NL>              return <SPC> 0 <NL>          lookup . add ( i ) <NL>          if <SPC> i <SPC> in <SPC> G : <NL>              for <SPC> j <SPC> in <SPC> G [ i ] : <NL>                  dfs ( j , <SPC> lookup ) <NL>          return <SPC> 1 <NL> <NL> <TAB> if <SPC> len ( connections ) <SPC> < <SPC> n <SPC> - <SPC> 1 : <NL>          return <SPC> - 1 <NL> <TAB> G <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> connections : <NL>          G [ i ] . append ( j ) <NL>          G [ j ] . append ( i ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> return <SPC> sum ( dfs ( i , <SPC> lookup ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( n ) ) <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pathsWithMaxScore ( self , <SPC> board ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> directions <SPC> = <SPC> [ [ 1 , <SPC> 0 ] , <SPC> [ 0 , <SPC> 1 ] , <SPC> [ 1 , <SPC> 1 ] ] <NL> <TAB> dp <SPC> = <SPC> [ [ [ 0 , <SPC> 0 ] <SPC> for <SPC> r <SPC> in <SPC> xrange ( len ( board [ 0 ] ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> r <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> dp [ ( len ( board ) <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ len ( board [ 0 ] ) <SPC> - <SPC> 1 ] <SPC> = <SPC> [ 0 , <SPC> 1 ] <NL> <TAB> for <SPC> r <SPC> in <SPC> reversed ( xrange ( len ( board ) ) ) : <NL>          for <SPC> c <SPC> in <SPC> reversed ( xrange ( len ( board [ 0 ] ) ) ) : <NL>              if <SPC> board [ r ] [ c ] <SPC> in <SPC> "XS" : <NL>                  continue <NL>              dp [ r <SPC> % <SPC> 2 ] [ c ] <SPC> = <SPC> [ 0 , <SPC> 0 ] <NL>              for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                  if <SPC> dp [ r <SPC> % <SPC> 2 ] [ c ] [ 0 ] <SPC> < <SPC> dp [ ( r <SPC> + <SPC> dr ) <SPC> % <SPC> 2 ] [ c <SPC> + <SPC> dc ] [ 0 ] : <NL>                      dp [ r <SPC> % <SPC> 2 ] [ c ] <SPC> = <SPC> dp [ ( r <SPC> + <SPC> dr ) <SPC> % <SPC> 2 ] [ c <SPC> + <SPC> dc ] [ : ] <NL>                  elif <SPC> dp [ r <SPC> % <SPC> 2 ] [ c ] [ 0 ] <SPC> == <SPC> dp [ ( r <SPC> + <SPC> dr ) <SPC> % <SPC> 2 ] [ c <SPC> + <SPC> dc ] [ 0 ] : <NL>                      dp [ r <SPC> % <SPC> 2 ] [ c ] [ 1 ] <SPC> = <SPC> ( <NL>                          dp [ r <SPC> % <SPC> 2 ] [ c ] [ 1 ] <SPC> + <SPC> dp [ ( r <SPC> + <SPC> dr ) <SPC> % <SPC> 2 ] [ c <SPC> + <SPC> dc ] [ 1 ] <NL>                      ) <SPC> % <SPC> MOD <NL>              if <SPC> dp [ r <SPC> % <SPC> 2 ] [ c ] [ 1 ] <SPC> and <SPC> board [ r ] [ c ] <SPC> != <SPC> "E" : <NL>                  dp [ r <SPC> % <SPC> 2 ] [ c ] [ 0 ] <SPC> += <SPC> int ( board [ r ] [ c ] ) <NL> <TAB> return <SPC> dp [ 0 ] [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> RecentCounter ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __q <SPC> = <SPC> collections . deque ( ) <NL> <NL> <TAB> def <SPC> ping ( self , <SPC> t ) : <NL> <NL> <TAB> self . __q . append ( t ) <NL> <TAB> while <SPC> self . __q [ 0 ] <SPC> < <SPC> t <SPC> - <SPC> 3000 : <NL>          self . __q . popleft ( ) <NL> <TAB> return <SPC> len ( self . __q ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countGoodRectangles ( self , <SPC> rectangles ) : <NL> <NL> <TAB> result <SPC> = <SPC> mx <SPC> = <SPC> 0 <NL> <TAB> for <SPC> l , <SPC> w <SPC> in <SPC> rectangles : <NL>          side <SPC> = <SPC> min ( l , <SPC> w ) <NL>          if <SPC> side <SPC> > <SPC> mx : <NL>              result , <SPC> mx <SPC> = <SPC> 1 , <SPC> side <NL>          elif <SPC> side <SPC> == <SPC> mx : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countRestrictedPaths ( self , <SPC> n , <SPC> edges ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> adj <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> u , <SPC> v , <SPC> w <SPC> in <SPC> edges : <NL>          adj [ u <SPC> - <SPC> 1 ] . append ( ( v <SPC> - <SPC> 1 , <SPC> w ) ) <NL>          adj [ v <SPC> - <SPC> 1 ] . append ( ( u <SPC> - <SPC> 1 , <SPC> w ) ) <NL> <TAB> dist <SPC> = <SPC> [ float ( "inf" ) ] <SPC> * <SPC> n <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> dist [ n <SPC> - <SPC> 1 ] <SPC> = <SPC> 0 <NL> <TAB> dp [ n <SPC> - <SPC> 1 ] <SPC> = <SPC> 1 <NL> <TAB> min_heap <SPC> = <SPC> [ ( 0 , <SPC> n <SPC> - <SPC> 1 ) ] <NL> <TAB> while <SPC> min_heap : <NL>          w , <SPC> u <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> w <SPC> > <SPC> dist [ u ] : <NL>              continue <NL>          for <SPC> v , <SPC> d <SPC> in <SPC> adj [ u ] : <NL>              if <SPC> w <SPC> + <SPC> d <SPC> < <SPC> dist [ v ] : <NL>                  dist [ v ] <SPC> = <SPC> w <SPC> + <SPC> d <NL>                  heapq . heappush ( min_heap , <SPC> ( dist [ v ] , <SPC> v ) ) <NL>              elif <SPC> w <SPC> > <SPC> dist [ v ] : <NL>                  dp [ u ] <SPC> = <SPC> ( dp [ u ] <SPC> + <SPC> dp [ v ] ) <SPC> % <SPC> MOD <NL>          if <SPC> u <SPC> == <SPC> 0 : <NL>              break <NL> <TAB> return <SPC> dp [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countSegments ( self , <SPC> s ) : <NL> <NL> <TAB> result <SPC> = <SPC> int ( len ( s ) <SPC> and <SPC> s [ - 1 ] <SPC> != <SPC> " " ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) ) : <NL>          if <SPC> s [ i ] <SPC> == <SPC> " " <SPC> and <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> != <SPC> " " : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> countSegments2 ( self , <SPC> s ) : <NL> <NL> <TAB> return <SPC> len ( [ i <SPC> for <SPC> i <SPC> in <SPC> s . strip ( ) . split ( " " ) <SPC> if <SPC> i ] ) <NL> <NL> <NL> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> MAX_N <SPC> = <SPC> 1000 <NL> fact <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 2 <SPC> * <SPC> MAX_N <SPC> - <SPC> 1 <SPC> + <SPC> 1 ) <NL> inv <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 2 <SPC> * <SPC> MAX_N <SPC> - <SPC> 1 <SPC> + <SPC> 1 ) <NL> inv_fact <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 2 <SPC> * <SPC> MAX_N <SPC> - <SPC> 1 <SPC> + <SPC> 1 ) <NL> fact [ 0 ] <SPC> = <SPC> inv_fact [ 0 ] <SPC> = <SPC> fact [ 1 ] <SPC> = <SPC> inv_fact [ 1 ] <SPC> = <SPC> inv [ 1 ] <SPC> = <SPC> 1 <NL> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> len ( fact ) ) : <NL> <TAB> fact [ i ] <SPC> = <SPC> fact [ i <SPC> - <SPC> 1 ] <SPC> * <SPC> i <SPC> % <SPC> MOD <NL> <TAB> inv [ i ] <SPC> = <SPC> ( <NL>          inv [ MOD <SPC> % <SPC> i ] <SPC> * <SPC> ( MOD <SPC> - <SPC> MOD <SPC> // <SPC> i ) <SPC> % <SPC> MOD <NL> <TAB> ) <NL> <TAB> inv_fact [ i ] <SPC> = <SPC> inv_fact [ i <SPC> - <SPC> 1 ] <SPC> * <SPC> inv [ i ] <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfSets ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> def <SPC> nCr ( n , <SPC> k , <SPC> mod ) : <NL>          return <SPC> ( fact [ n ] <SPC> * <SPC> inv_fact [ n <SPC> - <SPC> k ] <SPC> % <SPC> mod ) <SPC> * <SPC> inv_fact [ k ] <SPC> % <SPC> mod <NL> <NL> <TAB> return <SPC> nCr ( n <SPC> + <SPC> k <SPC> - <SPC> 1 , <SPC> 2 <SPC> * <SPC> k , <SPC> MOD ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numberOfSets ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> def <SPC> nCr ( n , <SPC> r ) : <NL>          if <SPC> n <SPC> - <SPC> r <SPC> < <SPC> r : <NL>              return <SPC> nCr ( n , <SPC> n <SPC> - <SPC> r ) <NL>          c <SPC> = <SPC> 1 <NL>          for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> r <SPC> + <SPC> 1 ) : <NL>              c <SPC> *= <SPC> n <SPC> - <SPC> k <SPC> + <SPC> 1 <NL>              c <SPC> //= <SPC> k <NL>          return <SPC> c <NL> <NL> <TAB> return <SPC> nCr ( n <SPC> + <SPC> k <SPC> - <SPC> 1 , <SPC> 2 <SPC> * <SPC> k ) <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Sea ( object ) : <NL> <TAB> def <SPC> hasShips ( self , <SPC> topRight , <SPC> bottomLeft ) : <NL> <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Point ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x , <SPC> y ) : <NL> <TAB> self . x <SPC> = <SPC> x <NL> <TAB> self . y <SPC> = <SPC> y <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countShips ( self , <SPC> sea , <SPC> topRight , <SPC> bottomLeft ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> if <SPC> ( <NL>          topRight . x <SPC> >= <SPC> bottomLeft . x <NL>          and <SPC> topRight . y <SPC> >= <SPC> bottomLeft . y <NL>          and <SPC> sea . hasShips ( topRight , <SPC> bottomLeft ) <NL> <TAB> ) : <NL>          if <SPC> ( topRight . x , <SPC> topRight . y ) <SPC> == <SPC> ( bottomLeft . x , <SPC> bottomLeft . y ) : <NL>              return <SPC> 1 <NL>          mid_x , <SPC> mid_y <SPC> = <SPC> ( topRight . x <SPC> + <SPC> bottomLeft . x ) <SPC> // <SPC> 2 , <SPC> ( <NL>              topRight . y <SPC> + <SPC> bottomLeft . y <NL>          ) <SPC> // <SPC> 2 <NL>          result <SPC> += <SPC> self . countShips ( sea , <SPC> topRight , <SPC> Point ( mid_x <SPC> + <SPC> 1 , <SPC> mid_y <SPC> + <SPC> 1 ) ) <NL>          result <SPC> += <SPC> self . countShips ( <NL>              sea , <SPC> Point ( mid_x , <SPC> topRight . y ) , <SPC> Point ( bottomLeft . x , <SPC> mid_y <SPC> + <SPC> 1 ) <NL>          ) <NL>          result <SPC> += <SPC> self . countShips ( <NL>              sea , <SPC> Point ( topRight . x , <SPC> mid_y ) , <SPC> Point ( mid_x <SPC> + <SPC> 1 , <SPC> bottomLeft . y ) <NL>          ) <NL>          result <SPC> += <SPC> self . countShips ( sea , <SPC> Point ( mid_x , <SPC> mid_y ) , <SPC> bottomLeft ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSquarefulPerms ( self , <SPC> A ) : <NL> <NL> <TAB> def <SPC> dfs ( candidate , <SPC> x , <SPC> left , <SPC> count , <SPC> result ) : <NL>          count [ x ] <SPC> -= <SPC> 1 <NL>          if <SPC> left <SPC> == <SPC> 0 : <NL>              result [ 0 ] <SPC> += <SPC> 1 <NL>          for <SPC> y <SPC> in <SPC> candidate [ x ] : <NL>              if <SPC> count [ y ] : <NL>                  dfs ( candidate , <SPC> y , <SPC> left <SPC> - <SPC> 1 , <SPC> count , <SPC> result ) <NL>          count [ x ] <SPC> += <SPC> 1 <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( A ) <NL> <TAB> candidate <SPC> = <SPC> { <NL>          i : <SPC> { j <SPC> for <SPC> j <SPC> in <SPC> count <SPC> if <SPC> int ( ( i <SPC> + <SPC> j ) <SPC> ** <SPC> 0.5 ) <SPC> ** <SPC> 2 <SPC> == <SPC> i <SPC> + <SPC> j } <SPC> for <SPC> i <SPC> in <SPC> count <NL> <TAB> } <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> x <SPC> in <SPC> count : <NL>          dfs ( candidate , <SPC> x , <SPC> len ( A ) <SPC> - <SPC> 1 , <SPC> count , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSteps ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> carry <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( s ) ) ) : <NL>          if <SPC> int ( s [ i ] ) <SPC> + <SPC> carry <SPC> == <SPC> 1 : <NL>              carry <SPC> = <SPC> 1 <NL>              result <SPC> += <SPC> 2 <NL>          else : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <SPC> + <SPC> carry <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfSteps ( self , <SPC> num ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> num : <NL>          result <SPC> += <SPC> 2 <SPC> if <SPC> num <SPC> % <SPC> 2 <SPC> else <SPC> 1 <NL>          num <SPC> //= <SPC> 2 <NL> <TAB> return <SPC> max ( result <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> busyStudent ( self , <SPC> startTime , <SPC> endTime , <SPC> queryTime ) : <NL> <NL> <TAB> return <SPC> sum ( s <SPC> <= <SPC> queryTime <SPC> <= <SPC> e <SPC> for <SPC> s , <SPC> e <SPC> in <SPC> itertools . izip ( startTime , <SPC> endTime ) ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countStudents ( self , <SPC> students , <SPC> sandwiches ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( students ) <NL> <TAB> for <SPC> i , <SPC> s <SPC> in <SPC> enumerate ( sandwiches ) : <NL>          if <SPC> not <SPC> count [ s ] : <NL>              break <NL>          count [ s ] <SPC> -= <SPC> 1 <NL> <TAB> else : <NL>          i <SPC> = <SPC> len ( sandwiches ) <NL> <TAB> return <SPC> len ( sandwiches ) <SPC> - <SPC> i <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numOfSubarrays ( self , <SPC> arr , <SPC> k , <SPC> threshold ) : <NL> <NL> <TAB> result , <SPC> curr <SPC> = <SPC> 0 , <SPC> sum ( itertools . islice ( arr , <SPC> 0 , <SPC> k <SPC> - <SPC> 1 ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k <SPC> - <SPC> 1 , <SPC> len ( arr ) ) : <NL>          curr <SPC> += <SPC> arr [ i ] <SPC> - <SPC> ( arr [ i <SPC> - <SPC> k ] <SPC> if <SPC> i <SPC> - <SPC> k <SPC> >= <SPC> 0 <SPC> else <SPC> 0 ) <NL>          result <SPC> += <SPC> int ( curr <SPC> >= <SPC> threshold <SPC> * <SPC> k ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numOfSubarrays ( self , <SPC> arr , <SPC> k , <SPC> threshold ) : <NL> <NL> <TAB> accu <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> x <SPC> in <SPC> arr : <NL>          accu . append ( accu [ - 1 ] <SPC> + <SPC> x ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( accu ) <SPC> - <SPC> k ) : <NL>          if <SPC> accu [ i <SPC> + <SPC> k ] <SPC> - <SPC> accu [ i ] <SPC> >= <SPC> threshold <SPC> * <SPC> k : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numOfSubarrays ( self , <SPC> arr ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> result , <SPC> accu <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> dp <SPC> = <SPC> [ 1 , <SPC> 0 ] <NL> <TAB> for <SPC> x <SPC> in <SPC> arr : <NL>          accu <SPC> ^= <SPC> x <SPC> & <SPC> 1 <NL>          dp [ accu ] <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> ( result <SPC> + <SPC> dp [ accu <SPC> ^ <SPC> 1 ] ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSubarrayBoundedMax ( self , <SPC> A , <SPC> L , <SPC> R ) : <NL> <NL> <TAB> def <SPC> count ( A , <SPC> bound ) : <NL>          result , <SPC> curr <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> A : <NL>              curr <SPC> = <SPC> curr <SPC> + <SPC> 1 <SPC> if <SPC> i <SPC> <= <SPC> bound <SPC> else <SPC> 0 <NL>              result <SPC> += <SPC> curr <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> count ( A , <SPC> R ) <SPC> - <SPC> count ( A , <SPC> L <SPC> - <SPC> 1 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSubmatrixSumTarget ( self , <SPC> matrix , <SPC> target ) : <NL> <NL> <TAB> if <SPC> len ( matrix ) <SPC> > <SPC> len ( matrix [ 0 ] ) : <NL>          return <SPC> self . numSubmatrixSumTarget ( map ( list , <SPC> zip ( * matrix ) ) , <SPC> target ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ i ] ) <SPC> - <SPC> 1 ) : <NL>              matrix [ i ] [ j <SPC> + <SPC> 1 ] <SPC> += <SPC> matrix [ i ] [ j ] <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          prefix_sum <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( matrix [ i ] ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> len ( matrix ) ) : <NL>              lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL>              lookup [ 0 ] <SPC> = <SPC> 1 <NL>              for <SPC> k <SPC> in <SPC> xrange ( len ( matrix [ j ] ) ) : <NL>                  prefix_sum [ k ] <SPC> += <SPC> matrix [ j ] [ k ] <NL>                  if <SPC> prefix_sum [ k ] <SPC> - <SPC> target <SPC> in <SPC> lookup : <NL>                      result <SPC> += <SPC> lookup [ prefix_sum [ k ] <SPC> - <SPC> target ] <NL>                  lookup [ prefix_sum [ k ] ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSubseq ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> nums . sort ( ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          if <SPC> nums [ left ] <SPC> + <SPC> nums [ right ] <SPC> > <SPC> target : <NL>              right <SPC> -= <SPC> 1 <NL>          else : <NL>              result <SPC> = <SPC> ( result <SPC> + <SPC> pow ( 2 , <SPC> right <SPC> - <SPC> left , <SPC> MOD ) ) <SPC> % <SPC> MOD <NL>              left <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfSubstrings ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> left <SPC> = <SPC> 0 , <SPC> [ - 1 ] <SPC> * <SPC> 3 <NL> <TAB> for <SPC> right , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          left [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> right <NL>          result <SPC> += <SPC> min ( left ) <SPC> + <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numberOfSubstrings ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> left , <SPC> count <SPC> = <SPC> 0 , <SPC> 0 , <SPC> [ 0 ] <SPC> * <SPC> 3 <NL> <TAB> for <SPC> right , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          count [ ord ( s [ right ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL>          while <SPC> all ( count ) : <NL>              count [ ord ( s [ left ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> -= <SPC> 1 <NL>              left <SPC> += <SPC> 1 <NL>          result <SPC> += <SPC> left <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> numberOfSubstrings ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> right , <SPC> count <SPC> = <SPC> 0 , <SPC> 0 , <SPC> [ 0 ] <SPC> * <SPC> 3 <NL> <TAB> for <SPC> left , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          while <SPC> right <SPC> < <SPC> len ( s ) <SPC> and <SPC> not <SPC> all ( count ) : <NL>              count [ ord ( s [ right ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL>              right <SPC> += <SPC> 1 <NL>          if <SPC> all ( count ) : <NL>              result <SPC> += <SPC> ( len ( s ) <SPC> - <SPC> 1 ) <SPC> - <SPC> ( right <SPC> - <SPC> 1 ) <SPC> + <SPC> 1 <NL>          count [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSub ( self , <SPC> s ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> result , <SPC> count <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          count <SPC> = <SPC> count <SPC> + <SPC> 1 <SPC> if <SPC> c <SPC> == <SPC> "1" <SPC> else <SPC> 0 <NL>          result <SPC> = <SPC> ( result <SPC> + <SPC> count ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validSubarrays ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> s <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          while <SPC> s <SPC> and <SPC> s [ - 1 ] <SPC> > <SPC> num : <NL>              s . pop ( ) <NL>          s . append ( num ) <NL>          result <SPC> += <SPC> len ( s ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findNumOfValidWords ( self , <SPC> words , <SPC> puzzles ) : <NL> <NL> <TAB> L <SPC> = <SPC> 7 <NL> <NL> <TAB> def <SPC> search ( node , <SPC> puzzle , <SPC> start , <SPC> first , <SPC> met_first ) : <NL>          result <SPC> = <SPC> 0 <NL>          if <SPC> "_end" <SPC> in <SPC> node <SPC> and <SPC> met_first : <NL>              result <SPC> += <SPC> node [ "_end" ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> len ( puzzle ) ) : <NL>              if <SPC> puzzle [ i ] <SPC> not <SPC> in <SPC> node : <NL>                  continue <NL>              result <SPC> += <SPC> search ( <NL>                  node [ puzzle [ i ] ] , <NL>                  puzzle , <NL>                  i <SPC> + <SPC> 1 , <NL>                  first , <NL>                  met_first <SPC> or <SPC> ( puzzle [ i ] <SPC> == <SPC> first ) , <NL>              ) <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> trie <SPC> = <SPC> _trie ( ) <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          count <SPC> = <SPC> set ( word ) <NL>          if <SPC> len ( count ) <SPC> > <SPC> L : <NL>              continue <NL>          word <SPC> = <SPC> sorted ( count ) <NL>          end <SPC> = <SPC> reduce ( dict . __getitem__ , <SPC> word , <SPC> trie ) <NL>          end [ "_end" ] <SPC> = <SPC> end [ "_end" ] <SPC> + <SPC> 1 <SPC> if <SPC> "_end" <SPC> in <SPC> end <SPC> else <SPC> 1 <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> puzzle <SPC> in <SPC> puzzles : <NL>          first <SPC> = <SPC> puzzle [ 0 ] <NL>          result . append ( search ( trie , <SPC> sorted ( puzzle ) , <SPC> 0 , <SPC> first , <SPC> False ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findNumOfValidWords ( self , <SPC> words , <SPC> puzzles ) : <NL> <NL> <TAB> L <SPC> = <SPC> 7 <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( puzzles ) ) : <NL>          bits <SPC> = <SPC> [ ] <NL>          base <SPC> = <SPC> 1 <SPC> << <SPC> ( ord ( puzzles [ i ] [ 0 ] ) <SPC> - <SPC> ord ( "a" ) ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> L ) : <NL>              bits . append ( ord ( puzzles [ i ] [ j ] ) <SPC> - <SPC> ord ( "a" ) ) <NL>          for <SPC> k <SPC> in <SPC> xrange ( 2 <SPC> ** <SPC> len ( bits ) ) : <NL>              bitset <SPC> = <SPC> base <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( bits ) ) : <NL>                  if <SPC> k <SPC> & <SPC> ( 1 <SPC> << <SPC> j ) : <NL>                      bitset <SPC> |= <SPC> 1 <SPC> << <SPC> bits [ j ] <NL>              lookup [ bitset ] . append ( i ) <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( puzzles ) <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          bitset <SPC> = <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> word : <NL>              bitset <SPC> |= <SPC> 1 <SPC> << <SPC> ( ord ( c ) <SPC> - <SPC> ord ( "a" ) ) <NL>          if <SPC> bitset <SPC> not <SPC> in <SPC> lookup : <NL>              continue <NL>          for <SPC> i <SPC> in <SPC> lookup [ bitset ] : <NL>              result [ i ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> ways ( self , <SPC> pizza , <SPC> k ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> prefix <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( pizza [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( pizza ) ) ] <NL> <TAB> for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( pizza [ 0 ] ) ) ) : <NL>          accu <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( pizza ) ) ) : <NL>              accu <SPC> += <SPC> int ( pizza [ i ] [ j ] <SPC> == <SPC> "A" ) <NL>              prefix [ i ] [ j ] <SPC> = <SPC> ( <NL>                  prefix [ i ] [ j <SPC> + <SPC> 1 ] <SPC> if <SPC> ( j <SPC> + <SPC> 1 <SPC> < <SPC> len ( pizza [ 0 ] ) ) <SPC> else <SPC> 0 <NL>              ) <SPC> + <SPC> accu <NL> <TAB> dp <SPC> = <SPC> [ [ [ 0 ] <SPC> * <SPC> k <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( pizza [ 0 ] ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( pizza ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( pizza ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( pizza [ 0 ] ) ) ) : <NL>              dp [ i ] [ j ] [ 0 ] <SPC> = <SPC> 1 <NL>              for <SPC> m <SPC> in <SPC> xrange ( 1 , <SPC> k ) : <NL>                  for <SPC> n <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( pizza ) ) : <NL>                      if <SPC> prefix [ i ] [ j ] <SPC> == <SPC> prefix [ n ] [ j ] : <NL>                          continue <NL>                      if <SPC> prefix [ n ] [ j ] <SPC> == <SPC> 0 : <NL>                          break <NL>                      dp [ i ] [ j ] [ m ] <SPC> = <SPC> ( dp [ i ] [ j ] [ m ] <SPC> + <SPC> dp [ n ] [ j ] [ m <SPC> - <SPC> 1 ] ) <SPC> % <SPC> MOD <NL>                  for <SPC> n <SPC> in <SPC> xrange ( j <SPC> + <SPC> 1 , <SPC> len ( pizza [ 0 ] ) ) : <NL>                      if <SPC> prefix [ i ] [ j ] <SPC> == <SPC> prefix [ i ] [ n ] : <NL>                          continue <NL>                      if <SPC> prefix [ i ] [ n ] <SPC> == <SPC> 0 : <NL>                          break <NL>                      dp [ i ] [ j ] [ m ] <SPC> = <SPC> ( dp [ i ] [ j ] [ m ] <SPC> + <SPC> dp [ i ] [ n ] [ m <SPC> - <SPC> 1 ] ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> dp [ 0 ] [ 0 ] [ k <SPC> - <SPC> 1 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numWays ( self , <SPC> words , <SPC> target ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( target ) <SPC> + <SPC> 1 ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words [ 0 ] ) ) : <NL>          count <SPC> = <SPC> collections . Counter ( w [ i ] <SPC> for <SPC> w <SPC> in <SPC> words ) <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( target ) ) ) : <NL>              dp [ j <SPC> + <SPC> 1 ] <SPC> += <SPC> dp [ j ] <SPC> * <SPC> count [ target [ j ] ] <SPC> % <SPC> MOD <NL> <TAB> return <SPC> dp [ - 1 ] <SPC> % <SPC> MOD <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numWays ( self , <SPC> words , <SPC> target ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( len ( target ) <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( dp ) ) : <NL>          dp [ i ] [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words [ 0 ] ) ) : <NL>          count <SPC> = <SPC> collections . Counter ( w [ i ] <SPC> for <SPC> w <SPC> in <SPC> words ) <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( target ) ) ) : <NL>              dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> ( <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> + <SPC> dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> * <SPC> count [ target [ j ] ] <SPC> % <SPC> MOD <NL>              ) <NL> <TAB> return <SPC> dp [ ( len ( words [ 0 ] ) ) <SPC> % <SPC> 2 ] [ - 1 ] <SPC> % <SPC> MOD <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numOfWays ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> matrix_expo ( A , <SPC> K ) : <NL>          result <SPC> = <SPC> [ [ int ( i <SPC> == <SPC> j ) <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>                    for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) ] <NL>          while <SPC> K : <NL>              if <SPC> K <SPC> % <SPC> 2 : <NL>                  result <SPC> = <SPC> matrix_mult ( result , <SPC> A ) <NL>              A <SPC> = <SPC> matrix_mult ( A , <SPC> A ) <NL>              K <SPC> /= <SPC> 2 <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> matrix_mult ( A , <SPC> B ) : <NL>          ZB <SPC> = <SPC> zip ( * B ) <NL>          return <SPC> [ <NL>              [ <NL>                  sum ( a <SPC> * <SPC> b <SPC> % <SPC> MOD <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( row , <SPC> col ) ) <SPC> % <SPC> MOD <NL>                  for <SPC> col <SPC> in <SPC> ZB <NL>              ] <NL>              for <SPC> row <SPC> in <SPC> A <NL>          ] <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> T <SPC> = <SPC> [ [ 3 , <SPC> 2 ] , <SPC> [ 2 , <SPC> 2 ] ] <NL> <TAB> return <SPC> ( <NL>          sum ( matrix_mult ( [ [ 6 , <SPC> 6 ] ] , <SPC> matrix_expo ( T , <SPC> n <SPC> - <SPC> 1 ) ) [ 0 ] ) <SPC> % <SPC> MOD <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numOfWays ( self , <SPC> n ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> aba , <SPC> abc <SPC> = <SPC> 6 , <SPC> 6 <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( n <SPC> - <SPC> 1 ) : <NL>          aba , <SPC> abc <SPC> = <SPC> ( 3 <SPC> * <SPC> aba <SPC> % <SPC> MOD <SPC> + <SPC> 2 <SPC> * <SPC> abc <SPC> % <SPC> MOD ) <SPC> % <SPC> MOD , <SPC> ( <NL>              2 <SPC> * <SPC> abc <SPC> % <SPC> MOD <SPC> + <SPC> 2 <SPC> * <SPC> aba <SPC> % <SPC> MOD <NL>          ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> ( aba <SPC> + <SPC> abc ) <SPC> % <SPC> MOD <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkWays ( self , <SPC> pairs ) : <NL> <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> x , <SPC> y <SPC> in <SPC> pairs : <NL>          adj [ x ] . add ( y ) <NL>          adj [ y ] . add ( x ) <NL> <TAB> n , <SPC> mul <SPC> = <SPC> len ( adj ) , <SPC> False <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> node <SPC> in <SPC> sorted ( adj . iterkeys ( ) , <SPC> key = lambda <SPC> i : <SPC> len ( adj [ i ] ) , <SPC> reverse = True ) : <NL>          lookup . add ( node ) <NL>          parent <SPC> = <SPC> 0 <NL>          for <SPC> x <SPC> in <SPC> adj [ node ] : <NL>              if <SPC> x <SPC> not <SPC> in <SPC> lookup : <NL>                  continue <NL>              if <SPC> parent <SPC> == <SPC> 0 <SPC> or <SPC> len ( adj [ x ] ) <SPC> < <SPC> len ( adj [ parent ] ) : <NL>                  parent <SPC> = <SPC> x <NL>          if <SPC> parent : <NL>              if <SPC> any ( True <SPC> for <SPC> x <SPC> in <SPC> adj [ node ] <SPC> if <SPC> x <SPC> != <SPC> parent <SPC> and <SPC> x <SPC> not <SPC> in <SPC> adj [ parent ] ) : <NL>                  return <SPC> 0 <NL>              mul <SPC> |= <SPC> len ( adj [ parent ] ) <SPC> == <SPC> len ( adj [ node ] ) <NL>          elif <SPC> len ( adj [ node ] ) <SPC> != <SPC> n <SPC> - <SPC> 1 : <NL>              return <SPC> 0 <NL> <TAB> return <SPC> 1 <SPC> + <SPC> mul <NL> <NL> <NL> MAX_N <SPC> = <SPC> 1000 <NL> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> MAX_N <SPC> for <SPC> _ <SPC> in <SPC> xrange ( MAX_N ) ] <NL> for <SPC> i <SPC> in <SPC> xrange ( len ( dp ) ) : <NL> <TAB> dp [ i ] [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> i <SPC> + <SPC> 1 ) : <NL> <TAB> dp [ i ] [ j ] <SPC> = <SPC> ( dp [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> dp [ i <SPC> - <SPC> 1 ] [ j ] ) <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numOfWays ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> iter_dfs ( nums ) : <NL>          result <SPC> = <SPC> [ 0 ] <NL>          stk <SPC> = <SPC> [ [ 1 , <SPC> [ nums , <SPC> result ] ] ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  nums , <SPC> ret <SPC> = <SPC> params <NL>                  if <SPC> len ( nums ) <SPC> <= <SPC> 2 : <NL>                      ret [ 0 ] <SPC> = <SPC> 1 <NL>                      continue <NL>                  left <SPC> = <SPC> [ v <SPC> for <SPC> v <SPC> in <SPC> nums <SPC> if <SPC> v <SPC> < <SPC> nums [ 0 ] ] <NL>                  right <SPC> = <SPC> [ v <SPC> for <SPC> v <SPC> in <SPC> nums <SPC> if <SPC> v <SPC> > <SPC> nums [ 0 ] ] <NL>                  ret [ 0 ] <SPC> = <SPC> dp [ len ( left ) <SPC> + <SPC> len ( right ) ] [ len ( left ) ] <NL>                  ret1 , <SPC> ret2 <SPC> = <SPC> [ 0 ] , <SPC> [ 0 ] <NL>                  stk . append ( [ 2 , <SPC> [ ret1 , <SPC> ret2 , <SPC> ret ] ] ) <NL>                  stk . append ( [ 1 , <SPC> [ right , <SPC> ret2 ] ] ) <NL>                  stk . append ( [ 1 , <SPC> [ left , <SPC> ret1 ] ] ) <NL>              elif <SPC> step <SPC> == <SPC> 2 : <NL>                  ret1 , <SPC> ret2 , <SPC> ret <SPC> = <SPC> params <NL>                  ret [ 0 ] <SPC> = <SPC> ret [ 0 ] <SPC> * <SPC> ret1 [ 0 ] <SPC> % <SPC> MOD <NL>                  ret [ 0 ] <SPC> = <SPC> ret [ 0 ] <SPC> * <SPC> ret2 [ 0 ] <SPC> % <SPC> MOD <NL>          return <SPC> result [ 0 ] <NL> <NL> <TAB> return <SPC> ( iter_dfs ( nums ) <SPC> - <SPC> 1 ) <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numOfWays ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> dfs ( nums ) : <NL>          if <SPC> len ( nums ) <SPC> <= <SPC> 2 : <NL>              return <SPC> 1 <NL>          left <SPC> = <SPC> [ v <SPC> for <SPC> v <SPC> in <SPC> nums <SPC> if <SPC> v <SPC> < <SPC> nums [ 0 ] ] <NL>          right <SPC> = <SPC> [ v <SPC> for <SPC> v <SPC> in <SPC> nums <SPC> if <SPC> v <SPC> > <SPC> nums [ 0 ] ] <NL>          result <SPC> = <SPC> dp [ len ( left ) <SPC> + <SPC> len ( right ) ] [ len ( left ) ] <NL>          result <SPC> = <SPC> result <SPC> * <SPC> dfs ( left ) <SPC> % <SPC> MOD <NL>          result <SPC> = <SPC> result <SPC> * <SPC> dfs ( right ) <SPC> % <SPC> MOD <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> ( dfs ( nums ) <SPC> - <SPC> 1 ) <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numWays ( self , <SPC> s ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> ones <SPC> = <SPC> s . count ( "1" ) <NL> <TAB> if <SPC> ones <SPC> % <SPC> 3 : <NL>          return <SPC> 0 <NL> <TAB> ones <SPC> //= <SPC> 3 <NL> <TAB> if <SPC> ones <SPC> == <SPC> 0 : <NL>          return <SPC> ( len ( s ) <SPC> - <SPC> 1 ) <SPC> * <SPC> ( len ( s ) <SPC> - <SPC> 2 ) <SPC> // <SPC> 2 <SPC> % <SPC> MOD <NL> <TAB> count <SPC> = <SPC> left <SPC> = <SPC> right <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          if <SPC> c <SPC> == <SPC> "1" : <NL>              count <SPC> += <SPC> 1 <NL>          if <SPC> count <SPC> == <SPC> ones : <NL>              left <SPC> += <SPC> 1 <NL>          elif <SPC> count <SPC> == <SPC> 2 <SPC> * <SPC> ones : <NL>              right <SPC> += <SPC> 1 <NL> <TAB> return <SPC> left <SPC> * <SPC> right <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numWays ( self , <SPC> steps , <SPC> arrLen ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> int ( 1e9 <SPC> + <SPC> 7 ) <NL> <TAB> l <SPC> = <SPC> min ( 1 <SPC> + <SPC> steps <SPC> // <SPC> 2 , <SPC> arrLen ) <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( l <SPC> + <SPC> 2 ) <NL> <TAB> dp [ 1 ] <SPC> = <SPC> 1 <NL> <TAB> while <SPC> steps <SPC> > <SPC> 0 : <NL>          steps <SPC> -= <SPC> 1 <NL>          new_dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( l <SPC> + <SPC> 2 ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> l <SPC> + <SPC> 1 ) : <NL>              new_dp [ i ] <SPC> = <SPC> ( dp [ i ] <SPC> + <SPC> dp [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> dp [ i <SPC> + <SPC> 1 ] ) <SPC> % <SPC> MOD <NL>          dp <SPC> = <SPC> new_dp <NL> <TAB> return <SPC> dp [ 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberWays ( self , <SPC> hats ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> HAT_SIZE <SPC> = <SPC> 40 <NL> <TAB> hat_to_people <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( HAT_SIZE ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( hats ) ) : <NL>          for <SPC> h <SPC> in <SPC> hats [ i ] : <NL>              hat_to_people [ h <SPC> - <SPC> 1 ] . append ( i ) <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 1 <SPC> << <SPC> len ( hats ) ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> people <SPC> in <SPC> hat_to_people : <NL>          for <SPC> mask <SPC> in <SPC> reversed ( xrange ( len ( dp ) ) ) : <NL>              for <SPC> p <SPC> in <SPC> people : <NL>                  if <SPC> mask <SPC> & <SPC> ( 1 <SPC> << <SPC> p ) : <NL>                      continue <NL>                  dp [ mask <SPC> | <SPC> ( 1 <SPC> << <SPC> p ) ] <SPC> += <SPC> dp [ mask ] <NL>                  dp [ mask <SPC> | <SPC> ( 1 <SPC> << <SPC> p ) ] <SPC> %= <SPC> MOD <NL> <TAB> return <SPC> dp [ - 1 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numTriplets ( self , <SPC> nums1 , <SPC> nums2 ) : <NL> <NL> <TAB> def <SPC> two_product ( nums , <SPC> i ) : <NL>          count <SPC> = <SPC> 0 <NL>          lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL>          for <SPC> num <SPC> in <SPC> nums : <NL>              if <SPC> i <SPC> % <SPC> num : <NL>                  continue <NL>              count <SPC> += <SPC> lookup [ i <SPC> // <SPC> num ] <NL>              lookup [ num ] <SPC> += <SPC> 1 <NL>          return <SPC> count <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums1 : <NL>          result <SPC> += <SPC> two_product ( nums2 , <SPC> num <SPC> ** <SPC> 2 ) <NL> <TAB> for <SPC> num <SPC> in <SPC> nums2 : <NL>          result <SPC> += <SPC> two_product ( nums1 , <SPC> num <SPC> ** <SPC> 2 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> atMostNGivenDigitSet ( self , <SPC> D , <SPC> N ) : <NL> <NL> <TAB> str_N <SPC> = <SPC> str ( N ) <NL> <TAB> set_D <SPC> = <SPC> set ( D ) <NL> <TAB> result <SPC> = <SPC> sum ( len ( D ) <SPC> ** <SPC> i <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( str_N ) ) ) <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( str_N ) : <NL>          result <SPC> += <SPC> sum ( c <SPC> < <SPC> str_N [ i ] <NL>                        for <SPC> c <SPC> in <SPC> D ) <SPC> * <SPC> ( len ( D ) <SPC> ** <SPC> ( len ( str_N ) <SPC> - <SPC> i <SPC> - <SPC> 1 ) ) <NL>          if <SPC> str_N [ i ] <SPC> not <SPC> in <SPC> set_D : <NL>              break <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <SPC> + <SPC> int ( i <SPC> == <SPC> len ( str_N ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numDupDigitsAtMostN ( self , <SPC> N ) : <NL> <NL> <TAB> def <SPC> P ( m , <SPC> n ) : <NL>          result <SPC> = <SPC> 1 <NL>          while <SPC> n <SPC> > <SPC> 0 : <NL>              result <SPC> *= <SPC> m <SPC> - <SPC> n <SPC> + <SPC> 1 <NL>              n <SPC> -= <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> digits <SPC> = <SPC> map ( int , <SPC> str ( N <SPC> + <SPC> 1 ) ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( digits ) ) : <NL>          result <SPC> += <SPC> P ( 9 , <SPC> 1 ) <SPC> * <SPC> P ( 9 , <SPC> i <SPC> - <SPC> 1 ) <NL> <NL> <TAB> prefix_set <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( digits ) : <NL>          for <SPC> y <SPC> in <SPC> xrange ( 1 <SPC> if <SPC> i <SPC> == <SPC> 0 <SPC> else <SPC> 0 , <SPC> x ) : <NL>              if <SPC> y <SPC> in <SPC> prefix_set : <NL>                  continue <NL>              result <SPC> += <SPC> P ( 9 <SPC> - <SPC> i , <SPC> len ( digits ) <SPC> - <SPC> i <SPC> - <SPC> 1 ) <NL>          if <SPC> x <SPC> in <SPC> prefix_set : <NL>              break <NL>          prefix_set . add ( x ) <NL> <TAB> return <SPC> N <SPC> - <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numsSameConsecDiff ( self , <SPC> N , <SPC> K ) : <NL> <NL> <TAB> curr <SPC> = <SPC> range ( 10 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N <SPC> - <SPC> 1 ) : <NL>          curr <SPC> = <SPC> [ <NL>              x <SPC> * <SPC> 10 <SPC> + <SPC> y <NL>              for <SPC> x <SPC> in <SPC> curr <NL>              for <SPC> y <SPC> in <SPC> set ( [ x <SPC> % <SPC> 10 <SPC> + <SPC> K , <SPC> x <SPC> % <SPC> 10 <SPC> - <SPC> K ] ) <NL>              if <SPC> x <SPC> and <SPC> 0 <SPC> <= <SPC> y <SPC> < <SPC> 10 <NL>          ] <NL> <TAB> return <SPC> curr <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findOcurrences ( self , <SPC> text , <SPC> first , <SPC> second ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> first <SPC> += <SPC> " " <NL> <TAB> second <SPC> += <SPC> " " <NL> <TAB> third <SPC> = <SPC> [ ] <NL> <TAB> i , <SPC> j , <SPC> k <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> k <SPC> < <SPC> len ( text ) : <NL>          c <SPC> = <SPC> text [ k ] <NL>          k <SPC> += <SPC> 1 <NL>          if <SPC> i <SPC> != <SPC> len ( first ) : <NL>              if <SPC> c <SPC> == <SPC> first [ i ] : <NL>                  i <SPC> += <SPC> 1 <NL>              else : <NL>                  i <SPC> = <SPC> 0 <NL>              continue <NL>          if <SPC> j <SPC> != <SPC> len ( second ) : <NL>              if <SPC> c <SPC> == <SPC> second [ j ] : <NL>                  j <SPC> += <SPC> 1 <NL>              else : <NL>                  k <SPC> -= <SPC> j <SPC> + <SPC> 1 <NL>                  i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL>              continue <NL>          if <SPC> c <SPC> != <SPC> " " : <NL>              third . append ( c ) <NL>              continue <NL>          k <SPC> -= <SPC> len ( second ) <SPC> + <SPC> len ( third ) <SPC> + <SPC> 1 <NL>          i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL>          result . append ( "" . join ( third ) ) <NL>          third <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> third : <NL>          result . append ( "" . join ( third ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> oddEvenJumps ( self , <SPC> A ) : <NL> <NL> <TAB> def <SPC> findNext ( idx ) : <NL>          result <SPC> = <SPC> [ None ] <SPC> * <SPC> len ( idx ) <NL>          stack <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> idx : <NL>              while <SPC> stack <SPC> and <SPC> stack [ - 1 ] <SPC> < <SPC> i : <NL>                  result [ stack . pop ( ) ] <SPC> = <SPC> i <NL>              stack . append ( i ) <NL>          return <SPC> result <NL> <NL> <TAB> idx <SPC> = <SPC> sorted ( range ( len ( A ) ) , <SPC> key = lambda <SPC> i : <SPC> A [ i ] ) <NL> <TAB> next_higher <SPC> = <SPC> findNext ( idx ) <NL> <TAB> idx . sort ( key = lambda <SPC> i : <SPC> - A [ i ] ) <NL> <TAB> next_lower <SPC> = <SPC> findNext ( idx ) <NL> <NL> <TAB> odd , <SPC> even <SPC> = <SPC> [ False ] <SPC> * <SPC> len ( A ) , <SPC> [ False ] <SPC> * <SPC> len ( A ) <NL> <TAB> odd [ - 1 ] , <SPC> even [ - 1 ] <SPC> = <SPC> True , <SPC> True <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( A ) <SPC> - <SPC> 1 ) ) : <NL>          if <SPC> next_higher [ i ] : <NL>              odd [ i ] <SPC> = <SPC> even [ next_higher [ i ] ] <NL>          if <SPC> next_lower [ i ] : <NL>              even [ i ] <SPC> = <SPC> odd [ next_lower [ i ] ] <NL> <TAB> return <SPC> sum ( odd ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> oddEvenList ( self , <SPC> head ) : <NL> <NL> <TAB> if <SPC> head : <NL>          odd_tail , <SPC> cur <SPC> = <SPC> head , <SPC> head . next <NL>          while <SPC> cur <SPC> and <SPC> cur . next : <NL>              even_head <SPC> = <SPC> odd_tail . next <NL>              odd_tail . next <SPC> = <SPC> cur . next <NL>              odd_tail <SPC> = <SPC> odd_tail . next <NL>              cur . next <SPC> = <SPC> odd_tail . next <NL>              odd_tail . next <SPC> = <SPC> even_head <NL>              cur <SPC> = <SPC> cur . next <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isOneEditDistance ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( s ) , <SPC> len ( t ) <NL> <TAB> if <SPC> m <SPC> > <SPC> n : <NL>          return <SPC> self . isOneEditDistance ( t , <SPC> s ) <NL> <TAB> if <SPC> n <SPC> - <SPC> m <SPC> > <SPC> 1 : <NL>          return <SPC> False <NL> <NL> <TAB> i , <SPC> shift <SPC> = <SPC> 0 , <SPC> n <SPC> - <SPC> m <NL> <TAB> while <SPC> i <SPC> < <SPC> m <SPC> and <SPC> s [ i ] <SPC> == <SPC> t [ i ] : <NL>          i <SPC> += <SPC> 1 <NL> <TAB> if <SPC> shift <SPC> == <SPC> 0 : <NL>          i <SPC> += <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> m <SPC> and <SPC> s [ i ] <SPC> == <SPC> t [ i <SPC> + <SPC> shift ] : <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> i <SPC> == <SPC> m <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMaxForm ( self , <SPC> strs , <SPC> m , <SPC> n ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> s <SPC> in <SPC> strs : <NL>          zero_count , <SPC> one_count <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> s : <NL>              if <SPC> c <SPC> == <SPC> "0" : <NL>                  zero_count <SPC> += <SPC> 1 <NL>              elif <SPC> c <SPC> == <SPC> "1" : <NL>                  one_count <SPC> += <SPC> 1 <NL> <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( zero_count , <SPC> m <SPC> + <SPC> 1 ) ) : <NL>              for <SPC> j <SPC> in <SPC> reversed ( xrange ( one_count , <SPC> n <SPC> + <SPC> 1 ) ) : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> max ( dp [ i ] [ j ] , <SPC> dp [ i <SPC> - <SPC> zero_count ] [ j <SPC> - <SPC> one_count ] <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> dp [ m ] [ n ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> TopVotedCandidate ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> persons , <SPC> times ) : <NL> <NL> <TAB> lead <SPC> = <SPC> - 1 <NL> <TAB> self . __lookup , <SPC> count <SPC> = <SPC> [ ] , <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> t , <SPC> p <SPC> in <SPC> itertools . izip ( times , <SPC> persons ) : <NL>          count [ p ] <SPC> += <SPC> 1 <NL>          if <SPC> count [ p ] <SPC> >= <SPC> count [ lead ] : <NL>              lead <SPC> = <SPC> p <NL>              self . __lookup . append ( ( t , <SPC> lead ) ) <NL> <NL> <TAB> def <SPC> q ( self , <SPC> t ) : <NL> <NL> <TAB> return <SPC> self . __lookup [ bisect . bisect ( self . __lookup , <SPC> ( t , <SPC> float ( "inf" ) ) ) <SPC> - <SPC> 1 ] [ 1 ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> random <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> MajorityChecker ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> arr ) : <NL> <NL> <TAB> Q , <SPC> ERROR_RATE <SPC> = <SPC> 10000 , <SPC> 0.001 <NL> <TAB> self . __K <SPC> = <SPC> int ( Q <SPC> / <SPC> ERROR_RATE ) . bit_length ( ) <NL> <TAB> self . __arr <SPC> = <SPC> arr <NL> <TAB> self . __inv_idx <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( self . __arr ) : <NL>          self . __inv_idx [ x ] . append ( i ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> left , <SPC> right , <SPC> threshold ) : <NL> <NL> <TAB> def <SPC> count ( inv_idx , <SPC> m , <SPC> left , <SPC> right ) : <NL>          return <SPC> bisect . bisect_right ( inv_idx [ m ] , <SPC> right ) <SPC> - <SPC> bisect . bisect_left ( <NL>              inv_idx [ m ] , <SPC> left <NL>          ) <NL> <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( self . __K ) : <NL>          m <SPC> = <SPC> self . __arr [ random . randint ( left , <SPC> right ) ] <NL>          if <SPC> count ( self . __inv_idx , <SPC> m , <SPC> left , <SPC> right ) <SPC> >= <SPC> threshold : <NL>              return <SPC> m <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> MajorityChecker2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> arr ) : <NL> <NL> <TAB> self . __arr <SPC> = <SPC> arr <NL> <TAB> self . __inv_idx <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( self . __arr ) : <NL>          self . __inv_idx [ x ] . append ( i ) <NL> <TAB> self . __bound <SPC> = <SPC> int ( round ( ( len ( arr ) <SPC> ** <SPC> 0.5 ) ) ) <NL> <TAB> self . __majorities <SPC> = <SPC> [ <NL>          i <SPC> for <SPC> i , <SPC> group <SPC> in <SPC> self . __inv_idx . iteritems ( ) <SPC> if <SPC> len ( group ) <SPC> >= <SPC> self . __bound <NL> <TAB> ] <NL> <NL> <TAB> def <SPC> query ( self , <SPC> left , <SPC> right , <SPC> threshold ) : <NL> <NL> <TAB> def <SPC> count ( inv_idx , <SPC> m , <SPC> left , <SPC> right ) : <NL>          return <SPC> bisect . bisect_right ( inv_idx [ m ] , <SPC> right ) <SPC> - <SPC> bisect . bisect_left ( <NL>              inv_idx [ m ] , <SPC> left <NL>          ) <NL> <NL> <TAB> def <SPC> boyer_moore_majority_vote ( nums , <SPC> left , <SPC> right ) : <NL>          m , <SPC> cnt <SPC> = <SPC> nums [ left ] , <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( left <SPC> + <SPC> 1 , <SPC> right <SPC> + <SPC> 1 ) : <NL>              if <SPC> m <SPC> == <SPC> nums [ i ] : <NL>                  cnt <SPC> += <SPC> 1 <NL>              else : <NL>                  cnt <SPC> -= <SPC> 1 <NL>                  if <SPC> cnt <SPC> == <SPC> 0 : <NL>                      m <SPC> = <SPC> nums [ i ] <NL>                      cnt <SPC> = <SPC> 1 <NL>          return <SPC> m <NL> <NL> <TAB> if <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <SPC> < <SPC> self . __bound : <NL>          m <SPC> = <SPC> boyer_moore_majority_vote ( self . __arr , <SPC> left , <SPC> right ) <NL>          if <SPC> count ( self . __inv_idx , <SPC> m , <SPC> left , <SPC> right ) <SPC> >= <SPC> threshold : <NL>              return <SPC> m <NL> <TAB> else : <NL>          for <SPC> m <SPC> in <SPC> self . __majorities : <NL>              if <SPC> count ( self . __inv_idx , <SPC> m , <SPC> left , <SPC> right ) <SPC> >= <SPC> threshold : <NL>                  return <SPC> m <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> functools <NL> <NL> <NL> class <SPC> SegmentTreeRecu ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> nums , <SPC> count ) : <NL> <NL> <TAB> N <SPC> = <SPC> len ( nums ) <NL> <TAB> self . __original_length <SPC> = <SPC> N <NL> <TAB> self . __tree_length <SPC> = <SPC> 2 <SPC> ** <SPC> ( N . bit_length ( ) <SPC> + <SPC> ( N <SPC> & <SPC> ( N <SPC> - <SPC> 1 ) <SPC> != <SPC> 0 ) ) <SPC> - <SPC> 1 <NL> <TAB> self . __tree <SPC> = <SPC> [ - 1 <SPC> for <SPC> _ <SPC> in <SPC> range ( self . __tree_length ) ] <NL> <TAB> self . __count <SPC> = <SPC> count <NL> <TAB> self . __constructTree ( nums , <SPC> 0 , <SPC> self . __original_length <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> i , <SPC> j ) : <NL> <TAB> return <SPC> self . __queryRange ( i , <SPC> j , <SPC> 0 , <SPC> self . __original_length <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <TAB> def <SPC> __constructTree ( self , <SPC> nums , <SPC> left , <SPC> right , <SPC> idx ) : <NL> <TAB> if <SPC> left <SPC> > <SPC> right : <NL>          return <NL> <TAB> if <SPC> left <SPC> == <SPC> right : <NL>          self . __tree [ idx ] <SPC> = <SPC> nums [ left ] <NL>          return <NL> <TAB> mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL> <TAB> self . __constructTree ( nums , <SPC> left , <SPC> mid , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ) <NL> <TAB> self . __constructTree ( nums , <SPC> mid <SPC> + <SPC> 1 , <SPC> right , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ) <NL> <TAB> if <SPC> ( <NL>          self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] <SPC> != <SPC> - 1 <NL>          and <SPC> self . __count ( self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] , <SPC> left , <SPC> right ) <SPC> * <SPC> 2 <NL>          > <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <NL> <TAB> ) : <NL>          self . __tree [ idx ] <SPC> = <SPC> self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] <NL> <TAB> elif <SPC> ( <NL>          self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ] <SPC> != <SPC> - 1 <NL>          and <SPC> self . __count ( self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ] , <SPC> left , <SPC> right ) <SPC> * <SPC> 2 <NL>          > <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <NL> <TAB> ) : <NL>          self . __tree [ idx ] <SPC> = <SPC> self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ] <NL> <NL> <TAB> def <SPC> __queryRange ( self , <SPC> range_left , <SPC> range_right , <SPC> left , <SPC> right , <SPC> idx ) : <NL> <TAB> if <SPC> left <SPC> > <SPC> right : <NL>          return <SPC> ( - 1 , <SPC> - 1 ) <NL> <TAB> if <SPC> right <SPC> < <SPC> range_left <SPC> or <SPC> left <SPC> > <SPC> range_right : <NL>          return <SPC> ( - 1 , <SPC> - 1 ) <NL> <TAB> if <SPC> range_left <SPC> <= <SPC> left <SPC> and <SPC> right <SPC> <= <SPC> range_right : <NL>          if <SPC> self . __tree [ idx ] <SPC> != <SPC> - 1 : <NL>              c <SPC> = <SPC> self . __count ( self . __tree [ idx ] , <SPC> range_left , <SPC> range_right ) <NL>              if <SPC> c <SPC> * <SPC> 2 <SPC> > <SPC> range_right <SPC> - <SPC> range_left <SPC> + <SPC> 1 : <NL>                  return <SPC> ( self . __tree [ idx ] , <SPC> c ) <NL> <TAB> else : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          result <SPC> = <SPC> self . __queryRange ( <NL>              range_left , <SPC> range_right , <SPC> left , <SPC> mid , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ) <NL>          if <SPC> result [ 0 ] <SPC> != <SPC> - 1 : <NL>              return <SPC> result <NL>          result <SPC> = <SPC> self . __queryRange ( <NL>              range_left , <SPC> range_right , <SPC> mid <SPC> + <SPC> 1 , <SPC> right , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 <NL>          ) <NL>          if <SPC> result [ 0 ] <SPC> != <SPC> - 1 : <NL>              return <SPC> result <NL> <TAB> return <SPC> ( - 1 , <SPC> - 1 ) <NL> <NL> <NL> class <SPC> MajorityChecker3 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> arr ) : <NL> <NL> <TAB> def <SPC> count ( inv_idx , <SPC> m , <SPC> left , <SPC> right ) : <NL>          return <SPC> bisect . bisect_right ( inv_idx [ m ] , <SPC> right ) <SPC> - <SPC> bisect . bisect_left ( <NL>              inv_idx [ m ] , <SPC> left <NL>          ) <NL> <NL> <TAB> self . __arr <SPC> = <SPC> arr <NL> <TAB> self . __inv_idx <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( self . __arr ) : <NL>          self . __inv_idx [ x ] . append ( i ) <NL> <TAB> self . __segment_tree <SPC> = <SPC> SegmentTreeRecu ( <NL>          arr , <SPC> functools . partial ( count , <SPC> self . __inv_idx ) <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> left , <SPC> right , <SPC> threshold ) : <NL> <NL> <TAB> result <SPC> = <SPC> self . __segment_tree . query ( left , <SPC> right ) <NL> <TAB> if <SPC> result [ 1 ] <SPC> >= <SPC> threshold : <NL>          return <SPC> result [ 0 ] <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> MajorityChecker4 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> arr ) : <NL> <NL> <TAB> self . __arr <SPC> = <SPC> arr <NL> <TAB> self . __inv_idx <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( self . __arr ) : <NL>          self . __inv_idx [ x ] . append ( i ) <NL> <TAB> self . __bucket_size <SPC> = <SPC> int ( round ( ( len ( arr ) <SPC> ** <SPC> 0.5 ) ) ) <NL> <TAB> self . __bucket_majorities <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> left <SPC> in <SPC> xrange ( 0 , <SPC> len ( self . __arr ) , <SPC> self . __bucket_size ) : <NL>          right <SPC> = <SPC> min ( left <SPC> + <SPC> self . __bucket_size <SPC> - <SPC> 1 , <SPC> len ( self . __arr ) <SPC> - <SPC> 1 ) <NL>          self . __bucket_majorities . append ( <NL>              self . __boyer_moore_majority_vote ( self . __arr , <SPC> left , <SPC> right ) <NL>          ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> left , <SPC> right , <SPC> threshold ) : <NL> <NL> <TAB> def <SPC> count ( inv_idx , <SPC> m , <SPC> left , <SPC> right ) : <NL>          return <SPC> bisect . bisect_right ( inv_idx [ m ] , <SPC> right ) <SPC> - <SPC> bisect . bisect_left ( <NL>              inv_idx [ m ] , <SPC> left <NL>          ) <NL> <NL> <TAB> l , <SPC> r <SPC> = <SPC> left <SPC> // <SPC> self . __bucket_size , <SPC> right <SPC> // <SPC> self . __bucket_size <NL> <TAB> if <SPC> l <SPC> == <SPC> r : <NL>          m <SPC> = <SPC> self . __boyer_moore_majority_vote ( self . __arr , <SPC> left , <SPC> right ) <NL>          if <SPC> count ( self . __inv_idx , <SPC> m , <SPC> left , <SPC> right ) <SPC> >= <SPC> threshold : <NL>              return <SPC> m <NL>          return <SPC> - 1 <NL> <TAB> else : <NL>          m <SPC> = <SPC> self . __boyer_moore_majority_vote ( <NL>              self . __arr , <SPC> left , <SPC> ( l <SPC> + <SPC> 1 ) <SPC> * <SPC> self . __bucket_size <SPC> - <SPC> 1 <NL>          ) <NL>          if <SPC> count ( self . __inv_idx , <SPC> m , <SPC> left , <SPC> right ) <SPC> >= <SPC> threshold : <NL>              return <SPC> m <NL>          m <SPC> = <SPC> self . __boyer_moore_majority_vote ( <NL>              self . __arr , <SPC> r <SPC> * <SPC> self . __bucket_size , <SPC> right <NL>          ) <NL>          if <SPC> count ( self . __inv_idx , <SPC> m , <SPC> left , <SPC> right ) <SPC> >= <SPC> threshold : <NL>              return <SPC> m <NL>          for <SPC> i <SPC> in <SPC> xrange ( l <SPC> + <SPC> 1 , <SPC> r ) : <NL>              if <SPC> ( <NL>                  count ( self . __inv_idx , <SPC> self . __bucket_majorities [ i ] , <SPC> left , <SPC> right ) <NL>                  >= <SPC> threshold <NL>              ) : <NL>                  return <SPC> self . __bucket_majorities [ i ] <NL>          return <SPC> - 1 <NL> <NL> <TAB> def <SPC> __boyer_moore_majority_vote ( self , <SPC> nums , <SPC> left , <SPC> right ) : <NL> <TAB> m , <SPC> cnt <SPC> = <SPC> nums [ left ] , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( left <SPC> + <SPC> 1 , <SPC> right <SPC> + <SPC> 1 ) : <NL>          if <SPC> m <SPC> == <SPC> nums [ i ] : <NL>              cnt <SPC> += <SPC> 1 <NL>          else : <NL>              cnt <SPC> -= <SPC> 1 <NL>              if <SPC> cnt <SPC> == <SPC> 0 : <NL>                  m <SPC> = <SPC> nums [ i ] <NL>                  cnt <SPC> = <SPC> 1 <NL> <TAB> return <SPC> m <NL> <NL> <NL> class <SPC> StockSpanner ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __s <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> next ( self , <SPC> price ) : <NL> <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> while <SPC> self . __s <SPC> and <SPC> self . __s [ - 1 ] [ 0 ] <SPC> <= <SPC> price : <NL>          result <SPC> += <SPC> self . __s . pop ( ) [ 1 ] <NL> <TAB> self . __s . append ( [ price , <SPC> result ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> openLock ( self , <SPC> deadends , <SPC> target ) : <NL> <NL> <TAB> dead <SPC> = <SPC> set ( deadends ) <NL> <TAB> q <SPC> = <SPC> [ "0000" ] <NL> <TAB> lookup <SPC> = <SPC> { "0000" } <NL> <TAB> depth <SPC> = <SPC> 0 <NL> <TAB> while <SPC> q : <NL>          next_q <SPC> = <SPC> [ ] <NL>          for <SPC> node <SPC> in <SPC> q : <NL>              if <SPC> node <SPC> == <SPC> target : <NL>                  return <SPC> depth <NL>              if <SPC> node <SPC> in <SPC> dead : <NL>                  continue <NL>              for <SPC> i <SPC> in <SPC> xrange ( 4 ) : <NL>                  n <SPC> = <SPC> int ( node [ i ] ) <NL>                  for <SPC> d <SPC> in <SPC> ( - 1 , <SPC> 1 ) : <NL>                      nn <SPC> = <SPC> ( n <SPC> + <SPC> d ) <SPC> % <SPC> 10 <NL>                      neighbor <SPC> = <SPC> node [ : i ] <SPC> + <SPC> str ( nn ) <SPC> + <SPC> node [ i <SPC> + <SPC> 1 : ] <NL>                      if <SPC> neighbor <SPC> not <SPC> in <SPC> lookup : <NL>                          lookup . add ( neighbor ) <NL>                          next_q . append ( neighbor ) <NL>          q <SPC> = <SPC> next_q <NL>          depth <SPC> += <SPC> 1 <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minTransfers ( self , <SPC> transactions ) : <NL> <NL> <TAB> accounts <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> transaction <SPC> in <SPC> transactions : <NL>          accounts [ transaction [ 0 ] ] <SPC> += <SPC> transaction [ 2 ] <NL>          accounts [ transaction [ 1 ] ] <SPC> -= <SPC> transaction [ 2 ] <NL> <NL> <TAB> debts <SPC> = <SPC> [ account <SPC> for <SPC> account <SPC> in <SPC> accounts . values ( ) <SPC> if <SPC> account ] <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 2 <SPC> ** <SPC> len ( debts ) ) <NL> <TAB> sums <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 2 <SPC> ** <SPC> len ( debts ) ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( dp ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( debts ) ) : <NL>              if <SPC> ( i <SPC> & <SPC> ( 1 <SPC> << <SPC> j ) ) <SPC> == <SPC> 0 : <NL>                  nxt <SPC> = <SPC> i <SPC> | <SPC> ( 1 <SPC> << <SPC> j ) <NL>                  sums [ nxt ] <SPC> = <SPC> sums [ i ] <SPC> + <SPC> debts [ j ] <NL>                  if <SPC> sums [ nxt ] <SPC> == <SPC> 0 : <NL>                      dp [ nxt ] <SPC> = <SPC> max ( dp [ nxt ] , <SPC> dp [ i ] <SPC> + <SPC> 1 ) <NL>                  else : <NL>                      dp [ nxt ] <SPC> = <SPC> max ( dp [ nxt ] , <SPC> dp [ i ] ) <NL> <TAB> return <SPC> len ( debts ) <SPC> - <SPC> dp [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> optimalDivision ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> len ( nums ) <SPC> == <SPC> 1 : <NL>          return <SPC> str ( nums [ 0 ] ) <NL> <TAB> if <SPC> len ( nums ) <SPC> == <SPC> 2 : <NL>          return <SPC> str ( nums [ 0 ] ) <SPC> + <SPC> "/" <SPC> + <SPC> str ( nums [ 1 ] ) <NL> <TAB> result <SPC> = <SPC> [ str ( nums [ 0 ] ) <SPC> + <SPC> "/(" <SPC> + <SPC> str ( nums [ 1 ] ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> len ( nums ) ) : <NL>          result <SPC> += <SPC> "/" <SPC> + <SPC> str ( nums [ i ] ) <NL> <TAB> result <SPC> += <SPC> ")" <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . count <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ max ( x_root , <SPC> y_root ) ] <SPC> = <SPC> min ( x_root , <SPC> y_root ) <NL> <TAB> self . count <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minCostToSupplyWater ( self , <SPC> n , <SPC> wells , <SPC> pipes ) : <NL> <NL> <TAB> w <SPC> = <SPC> [ [ c , <SPC> 0 , <SPC> i ] <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( wells , <SPC> 1 ) ] <NL> <TAB> p <SPC> = <SPC> [ [ c , <SPC> i , <SPC> j ] <SPC> for <SPC> i , <SPC> j , <SPC> c <SPC> in <SPC> pipes ] <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( n <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> c , <SPC> x , <SPC> y <SPC> in <SPC> sorted ( w <SPC> + <SPC> p ) : <NL>          if <SPC> not <SPC> union_find . union_set ( x , <SPC> y ) : <NL>              continue <NL>          result <SPC> += <SPC> c <NL>          if <SPC> union_find . count <SPC> == <SPC> 1 : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> orderlyQueue ( self , <SPC> S , <SPC> K ) : <NL> <NL> <TAB> if <SPC> K <SPC> == <SPC> 1 : <NL>          return <SPC> min ( S [ i : ] <SPC> + <SPC> S [ : i ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( S ) ) ) <NL> <TAB> return <SPC> "" . join ( sorted ( S ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findPaths ( self , <SPC> m , <SPC> n , <SPC> N , <SPC> x , <SPC> y ) : <NL> <NL> <TAB> M <SPC> = <SPC> 1000000000 <SPC> + <SPC> 7 <NL> <TAB> dp <SPC> = <SPC> [ [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> moves <SPC> in <SPC> xrange ( N ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>                  dp [ ( moves <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ i ] [ j ] <SPC> = <SPC> ( <NL>                      ( <NL>                          ( 1 <SPC> if <SPC> ( i <SPC> == <SPC> 0 ) <SPC> else <SPC> dp [ moves <SPC> % <SPC> 2 ] [ i <SPC> - <SPC> 1 ] [ j ] ) <NL>                          + <SPC> ( 1 <SPC> if <SPC> ( i <SPC> == <SPC> m <SPC> - <SPC> 1 ) <SPC> else <SPC> dp [ moves <SPC> % <SPC> 2 ] [ i <SPC> + <SPC> 1 ] [ j ] ) <NL>                      ) <NL>                      % <SPC> M <NL>                      + <SPC> ( <NL>                          ( 1 <SPC> if <SPC> ( j <SPC> == <SPC> 0 ) <SPC> else <SPC> dp [ moves <SPC> % <SPC> 2 ] [ i ] [ j <SPC> - <SPC> 1 ] ) <NL>                          + <SPC> ( 1 <SPC> if <SPC> ( j <SPC> == <SPC> n <SPC> - <SPC> 1 ) <SPC> else <SPC> dp [ moves <SPC> % <SPC> 2 ] [ i ] [ j <SPC> + <SPC> 1 ] ) <NL>                      ) <NL>                      % <SPC> M <NL>                  ) <SPC> % <SPC> M <NL> <TAB> return <SPC> dp [ N <SPC> % <SPC> 2 ] [ x ] [ y ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findContestMatch ( self , <SPC> n ) : <NL> <NL> <TAB> matches <SPC> = <SPC> map ( str , <SPC> range ( 1 , <SPC> n <SPC> + <SPC> 1 ) ) <NL> <TAB> while <SPC> len ( matches ) <SPC> / <SPC> 2 : <NL>          matches <SPC> = <SPC> [ <NL>              "({},{})" . format ( matches [ i ] , <SPC> matches [ - i <SPC> - <SPC> 1 ] ) <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( matches ) <SPC> / <SPC> 2 ) <NL>          ] <NL> <TAB> return <SPC> matches [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pacificAtlantic ( self , <SPC> matrix ) : <NL> <NL> <TAB> PACIFIC , <SPC> ATLANTIC <SPC> = <SPC> 1 , <SPC> 2 <NL> <NL> <TAB> def <SPC> pacificAtlanticHelper ( matrix , <SPC> x , <SPC> y , <SPC> prev_height , <SPC> prev_val , <SPC> visited , <SPC> res ) : <NL>          if <SPC> ( <NL>              ( not <SPC> 0 <SPC> <= <SPC> x <SPC> < <SPC> len ( matrix ) ) <NL>              or <SPC> ( not <SPC> 0 <SPC> <= <SPC> y <SPC> < <SPC> len ( matrix [ 0 ] ) ) <NL>              or <SPC> matrix [ x ] [ y ] <SPC> < <SPC> prev_height <NL>              or <SPC> ( visited [ x ] [ y ] <SPC> | <SPC> prev_val ) <SPC> == <SPC> visited [ x ] [ y ] <NL>          ) : <NL>              return <NL> <NL>          visited [ x ] [ y ] <SPC> |= <SPC> prev_val <NL>          if <SPC> visited [ x ] [ y ] <SPC> == <SPC> ( PACIFIC <SPC> | <SPC> ATLANTIC ) : <NL>              res . append ( ( x , <SPC> y ) ) <NL> <NL>          for <SPC> d <SPC> in <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] : <NL>              pacificAtlanticHelper ( <NL>                  matrix , <NL>                  x <SPC> + <SPC> d [ 0 ] , <NL>                  y <SPC> + <SPC> d [ 1 ] , <NL>                  matrix [ x ] [ y ] , <NL>                  visited [ x ] [ y ] , <NL>                  visited , <NL>                  res , <NL>              ) <NL> <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <SPC> [ ] <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( matrix ) , <SPC> len ( matrix [ 0 ] ) <NL> <TAB> visited <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m ) ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          pacificAtlanticHelper ( matrix , <SPC> i , <SPC> 0 , <SPC> float ( <NL>              "-inf" ) , <SPC> PACIFIC , <SPC> visited , <SPC> res ) <NL>          pacificAtlanticHelper ( <NL>              matrix , <SPC> i , <SPC> n <SPC> - <SPC> 1 , <SPC> float ( "-inf" ) , <SPC> ATLANTIC , <SPC> visited , <SPC> res <NL>          ) <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>          pacificAtlanticHelper ( matrix , <SPC> 0 , <SPC> j , <SPC> float ( <NL>              "-inf" ) , <SPC> PACIFIC , <SPC> visited , <SPC> res ) <NL>          pacificAtlanticHelper ( <NL>              matrix , <SPC> m <SPC> - <SPC> 1 , <SPC> j , <SPC> float ( "-inf" ) , <SPC> ATLANTIC , <SPC> visited , <SPC> res <NL>          ) <NL> <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numWays ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> elif <SPC> n <SPC> == <SPC> 1 : <NL>          return <SPC> k <NL> <TAB> ways <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 3 <NL> <TAB> ways [ 0 ] <SPC> = <SPC> k <NL> <TAB> ways [ 1 ] <SPC> = <SPC> ( k <SPC> - <SPC> 1 ) <SPC> * <SPC> ways [ 0 ] <SPC> + <SPC> k <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> n ) : <NL>          ways [ i <SPC> % <SPC> 3 ] <SPC> = <SPC> ( k <SPC> - <SPC> 1 ) <SPC> * <SPC> ( ways [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 3 ] <SPC> + <SPC> ways [ ( i <SPC> - <SPC> 2 ) <SPC> % <SPC> 3 ] ) <NL> <TAB> return <SPC> ways [ ( n <SPC> - <SPC> 1 ) <SPC> % <SPC> 3 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numWays ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> elif <SPC> n <SPC> == <SPC> 1 : <NL>          return <SPC> k <NL> <TAB> ways <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> ways [ 0 ] <SPC> = <SPC> k <NL> <TAB> ways [ 1 ] <SPC> = <SPC> ( k <SPC> - <SPC> 1 ) <SPC> * <SPC> ways [ 0 ] <SPC> + <SPC> k <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> n ) : <NL>          ways [ i ] <SPC> = <SPC> ( k <SPC> - <SPC> 1 ) <SPC> * <SPC> ( ways [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> ways [ i <SPC> - <SPC> 2 ] ) <NL> <TAB> return <SPC> ways [ n <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minCostII ( self , <SPC> costs ) : <NL> <NL> <TAB> return <SPC> min ( reduce ( self . combine , <SPC> costs ) ) <SPC> if <SPC> costs <SPC> else <SPC> 0 <NL> <NL> <TAB> def <SPC> combine ( self , <SPC> tmp , <SPC> house ) : <NL> <TAB> smallest , <SPC> k , <SPC> i <SPC> = <SPC> min ( tmp ) , <SPC> len ( tmp ) , <SPC> tmp . index ( min ( tmp ) ) <NL> <TAB> tmp , <SPC> tmp [ i ] <SPC> = <SPC> [ smallest ] <SPC> * <SPC> k , <SPC> min ( tmp [ : i ] <SPC> + <SPC> tmp [ i <SPC> + <SPC> 1 : ] ) <NL> <TAB> return <SPC> map ( sum , <SPC> zip ( tmp , <SPC> house ) ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minCostII ( self , <SPC> costs ) : <NL> <NL> <TAB> if <SPC> not <SPC> costs : <NL>          return <SPC> 0 <NL> <NL> <TAB> n <SPC> = <SPC> len ( costs ) <NL> <TAB> k <SPC> = <SPC> len ( costs [ 0 ] ) <NL> <TAB> min_cost <SPC> = <SPC> [ costs [ 0 ] , <SPC> [ 0 ] <SPC> * <SPC> k ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>          smallest , <SPC> second_smallest <SPC> = <SPC> float ( "inf" ) , <SPC> float ( "inf" ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( k ) : <NL>              if <SPC> min_cost [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <SPC> < <SPC> smallest : <NL>                  smallest , <SPC> second_smallest <SPC> = <SPC> min_cost [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <SPC> smallest <NL>              elif <SPC> min_cost [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <SPC> < <SPC> second_smallest : <NL>                  second_smallest <SPC> = <SPC> min_cost [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( k ) : <NL>              min_j <SPC> = <SPC> ( <NL>                  smallest <NL>                  if <SPC> min_cost [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <SPC> != <SPC> smallest <NL>                  else <SPC> second_smallest <NL>              ) <NL>              min_cost [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> costs [ i ] [ j ] <SPC> + <SPC> min_j <NL> <NL> <TAB> return <SPC> min ( min_cost [ ( n <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minCost ( self , <SPC> houses , <SPC> cost , <SPC> m , <SPC> n , <SPC> target ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ <NL>          [ [ float ( "inf" ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( target ) ] <NL>          for <SPC> _ <SPC> in <SPC> xrange ( 2 ) <NL> <TAB> ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          dp [ i <SPC> % <SPC> 2 ] <SPC> = <SPC> [ [ float ( "inf" ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( target ) ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( min ( target , <SPC> i <SPC> + <SPC> 1 ) ) : <NL>              for <SPC> k <SPC> in <SPC> xrange ( n ) : <NL>                  if <SPC> houses [ i ] <SPC> and <SPC> houses [ i ] <SPC> - <SPC> 1 <SPC> != <SPC> k : <NL>                      continue <NL>                  same <SPC> = <SPC> dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] [ k ] <SPC> if <SPC> i <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <SPC> else <SPC> 0 <NL>                  diff <SPC> = <SPC> ( <NL>                      ( <NL>                          min ( <NL>                              [ <NL>                                  dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] [ nk ] <NL>                                  for <SPC> nk <SPC> in <SPC> xrange ( n ) <NL>                                  if <SPC> nk <SPC> != <SPC> k <NL>                              ] <NL>                              or <SPC> [ float ( "inf" ) ] <NL>                          ) <NL>                          if <SPC> j <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <NL>                          else <SPC> float ( "inf" ) <NL>                      ) <NL>                      if <SPC> i <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <NL>                      else <SPC> 0 <NL>                  ) <NL>                  paint <SPC> = <SPC> cost [ i ] [ k ] <SPC> if <SPC> not <SPC> houses [ i ] <SPC> else <SPC> 0 <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] [ k ] <SPC> = <SPC> min ( same , <SPC> diff ) <SPC> + <SPC> paint <NL> <TAB> result <SPC> = <SPC> min ( dp [ ( m <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ - 1 ] ) <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> != <SPC> float ( "inf" ) <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minCost ( self , <SPC> houses , <SPC> cost , <SPC> m , <SPC> n , <SPC> target ) : <NL> <NL> <TAB> dp <SPC> = <SPC> { ( 0 , <SPC> 0 ) : <SPC> 0 } <NL> <TAB> for <SPC> i , <SPC> p <SPC> in <SPC> enumerate ( houses ) : <NL>          new_dp <SPC> = <SPC> { } <NL>          for <SPC> nk <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) <SPC> if <SPC> not <SPC> p <SPC> else <SPC> [ p ] : <NL>              for <SPC> j , <SPC> k <SPC> in <SPC> dp : <NL>                  nj <SPC> = <SPC> j <SPC> + <SPC> ( k <SPC> != <SPC> nk ) <NL>                  if <SPC> nj <SPC> > <SPC> target : <NL>                      continue <NL>                  new_dp [ nj , <SPC> nk ] <SPC> = <SPC> min ( <NL>                      new_dp . get ( ( nj , <SPC> nk ) , <SPC> float ( "inf" ) ) , <NL>                      dp [ j , <SPC> k ] <SPC> + <SPC> ( cost [ i ] [ nk <SPC> - <SPC> 1 ] <SPC> if <SPC> nk <SPC> != <SPC> p <SPC> else <SPC> 0 ) , <NL>                  ) <NL>          dp <SPC> = <SPC> new_dp <NL> <TAB> return <SPC> min ( [ dp [ j , <SPC> k ] <SPC> for <SPC> j , <SPC> k <SPC> in <SPC> dp <SPC> if <SPC> j <SPC> == <SPC> target ] <SPC> or <SPC> [ - 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minCost ( self , <SPC> costs ) : <NL> <NL> <TAB> if <SPC> not <SPC> costs : <NL>          return <SPC> 0 <NL> <NL> <TAB> min_cost <SPC> = <SPC> [ costs [ 0 ] , <SPC> [ 0 , <SPC> 0 , <SPC> 0 ] ] <NL> <NL> <TAB> n <SPC> = <SPC> len ( costs ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>          min_cost [ i <SPC> % <SPC> 2 ] [ 0 ] <SPC> = <SPC> costs [ i ] [ 0 ] <SPC> + <SPC> min ( <NL>              min_cost [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ 1 ] , <SPC> min_cost [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ 2 ] <NL>          ) <NL>          min_cost [ i <SPC> % <SPC> 2 ] [ 1 ] <SPC> = <SPC> costs [ i ] [ 1 ] <SPC> + <SPC> min ( <NL>              min_cost [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ 0 ] , <SPC> min_cost [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ 2 ] <NL>          ) <NL>          min_cost [ i <SPC> % <SPC> 2 ] [ 2 ] <SPC> = <SPC> costs [ i ] [ 2 ] <SPC> + <SPC> min ( <NL>              min_cost [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ 0 ] , <SPC> min_cost [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ 1 ] <NL>          ) <NL> <NL> <TAB> return <SPC> min ( min_cost [ ( n <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minCost ( self , <SPC> costs ) : <NL> <NL> <TAB> if <SPC> not <SPC> costs : <NL>          return <SPC> 0 <NL> <NL> <TAB> n <SPC> = <SPC> len ( costs ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>          costs [ i ] [ 0 ] <SPC> += <SPC> min ( costs [ i <SPC> - <SPC> 1 ] [ 1 ] , <SPC> costs [ i <SPC> - <SPC> 1 ] [ 2 ] ) <NL>          costs [ i ] [ 1 ] <SPC> += <SPC> min ( costs [ i <SPC> - <SPC> 1 ] [ 0 ] , <SPC> costs [ i <SPC> - <SPC> 1 ] [ 2 ] ) <NL>          costs [ i ] [ 2 ] <SPC> += <SPC> min ( costs [ i <SPC> - <SPC> 1 ] [ 0 ] , <SPC> costs [ i <SPC> - <SPC> 1 ] [ 1 ] ) <NL> <NL> <TAB> return <SPC> min ( costs [ n <SPC> - <SPC> 1 ] ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numPairsDivisibleBy60 ( self , <SPC> time ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> count <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> for <SPC> t <SPC> in <SPC> time : <NL>          result <SPC> += <SPC> count [ - t <SPC> % <SPC> 60 ] <NL>          count [ t <SPC> % <SPC> 60 ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isPalindrome ( self , <SPC> head ) : <NL> <TAB> reverse , <SPC> fast <SPC> = <SPC> None , <SPC> head <NL> <NL> <TAB> while <SPC> fast <SPC> and <SPC> fast . next : <NL>          fast <SPC> = <SPC> fast . next . next <NL>          head . next , <SPC> reverse , <SPC> head <SPC> = <SPC> reverse , <SPC> head , <SPC> head . next <NL> <NL> <TAB> tail <SPC> = <SPC> head . next <SPC> if <SPC> fast <SPC> else <SPC> head <NL> <NL> <TAB> is_palindrome <SPC> = <SPC> True <NL> <TAB> while <SPC> reverse : <NL>          is_palindrome <SPC> = <SPC> is_palindrome <SPC> and <SPC> reverse . val <SPC> == <SPC> tail . val <NL>          reverse . next , <SPC> head , <SPC> reverse <SPC> = <SPC> head , <SPC> reverse , <SPC> reverse . next <NL>          tail <SPC> = <SPC> tail . next <NL> <NL> <TAB> return <SPC> is_palindrome <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isPalindrome ( self , <SPC> x ) : <NL> <TAB> if <SPC> x <SPC> < <SPC> 0 : <NL>          return <SPC> False <NL> <TAB> copy , <SPC> reverse <SPC> = <SPC> x , <SPC> 0 <NL> <NL> <TAB> while <SPC> copy : <NL>          reverse <SPC> *= <SPC> 10 <NL>          reverse <SPC> += <SPC> copy <SPC> % <SPC> 10 <NL>          copy <SPC> //= <SPC> 10 <NL> <NL> <TAB> return <SPC> x <SPC> == <SPC> reverse <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> palindromePairs ( self , <SPC> words ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          lookup [ word ] <SPC> = <SPC> i <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( words [ i ] ) <SPC> + <SPC> 1 ) : <NL>              prefix <SPC> = <SPC> words [ i ] [ j : ] <NL>              suffix <SPC> = <SPC> words [ i ] [ : j ] <NL>              if <SPC> ( <NL>                  prefix <SPC> == <SPC> prefix [ : : - 1 ] <NL>                  and <SPC> suffix [ : : - 1 ] <SPC> in <SPC> lookup <NL>                  and <SPC> lookup [ suffix [ : : - 1 ] ] <SPC> != <SPC> i <NL>              ) : <NL>                  res . append ( [ i , <SPC> lookup [ suffix [ : : - 1 ] ] ] ) <NL>              if <SPC> ( <NL>                  j <SPC> > <SPC> 0 <NL>                  and <SPC> suffix <SPC> == <SPC> suffix [ : : - 1 ] <NL>                  and <SPC> prefix [ : : - 1 ] <SPC> in <SPC> lookup <NL>                  and <SPC> lookup [ prefix [ : : - 1 ] ] <SPC> != <SPC> i <NL>              ) : <NL>                  res . append ( [ lookup [ prefix [ : : - 1 ] ] , <SPC> i ] ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution_TLE ( object ) : <NL> <TAB> def <SPC> palindromePairs ( self , <SPC> words ) : <NL> <NL> <TAB> def <SPC> manacher ( s , <SPC> P ) : <NL>          def <SPC> preProcess ( s ) : <NL>              if <SPC> not <SPC> s : <NL>                  return <SPC> [ "^" , <SPC> "$" ] <NL>              T <SPC> = <SPC> [ "^" ] <NL>              for <SPC> c <SPC> in <SPC> s : <NL>                  T <SPC> += <SPC> [ "#" , <SPC> c ] <NL>              T <SPC> += <SPC> [ "#" , <SPC> "$" ] <NL>              return <SPC> T <NL> <NL>          T <SPC> = <SPC> preProcess ( s ) <NL>          center , <SPC> right <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( T ) <SPC> - <SPC> 1 ) : <NL>              i_mirror <SPC> = <SPC> 2 <SPC> * <SPC> center <SPC> - <SPC> i <NL>              if <SPC> right <SPC> > <SPC> i : <NL>                  P [ i ] <SPC> = <SPC> min ( right <SPC> - <SPC> i , <SPC> P [ i_mirror ] ) <NL>              else : <NL>                  P [ i ] <SPC> = <SPC> 0 <NL>              while <SPC> T [ i <SPC> + <SPC> 1 <SPC> + <SPC> P [ i ] ] <SPC> == <SPC> T [ i <SPC> - <SPC> 1 <SPC> - <SPC> P [ i ] ] : <NL>                  P [ i ] <SPC> += <SPC> 1 <NL>              if <SPC> i <SPC> + <SPC> P [ i ] <SPC> > <SPC> right : <NL>                  center , <SPC> right <SPC> = <SPC> i , <SPC> i <SPC> + <SPC> P [ i ] <NL> <NL> <TAB> prefix , <SPC> suffix <SPC> = <SPC> collections . defaultdict ( <NL>          list ) , <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          P <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( 2 <SPC> * <SPC> len ( word ) <SPC> + <SPC> 3 ) <NL>          manacher ( word , <SPC> P ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( P ) ) : <NL>              if <SPC> j <SPC> - <SPC> P [ j ] <SPC> == <SPC> 1 : <NL>                  prefix [ word [ ( j <SPC> + <SPC> P [ j ] ) <SPC> / <SPC> 2 : ] ] . append ( i ) <NL>              if <SPC> j <SPC> + <SPC> P [ j ] <SPC> == <SPC> len ( P ) <SPC> - <SPC> 2 : <NL>                  suffix [ word [ : <SPC> ( j <SPC> - <SPC> P [ j ] ) <SPC> / <SPC> 2 ] ] . append ( i ) <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          for <SPC> j <SPC> in <SPC> prefix [ word [ : : - 1 ] ] : <NL>              if <SPC> j <SPC> != <SPC> i : <NL>                  res . append ( [ i , <SPC> j ] ) <NL>          for <SPC> j <SPC> in <SPC> suffix [ word [ : : - 1 ] ] : <NL>              if <SPC> len ( word ) <SPC> != <SPC> len ( words [ j ] ) : <NL>                  res . append ( [ j , <SPC> i ] ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> TrieNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . word_idx <SPC> = <SPC> - 1 <NL> <TAB> self . leaves <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> word , <SPC> i ) : <NL> <TAB> cur <SPC> = <SPC> self <NL> <TAB> for <SPC> c <SPC> in <SPC> word : <NL>          if <SPC> not <SPC> c <SPC> in <SPC> cur . leaves : <NL>              cur . leaves [ c ] <SPC> = <SPC> TrieNode ( ) <NL>          cur <SPC> = <SPC> cur . leaves [ c ] <NL> <TAB> cur . word_idx <SPC> = <SPC> i <NL> <NL> <TAB> def <SPC> find ( self , <SPC> s , <SPC> idx , <SPC> res ) : <NL> <TAB> cur <SPC> = <SPC> self <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>          if <SPC> s [ i ] <SPC> in <SPC> cur . leaves : <NL>              cur <SPC> = <SPC> cur . leaves [ s [ i ] ] <NL>              if <SPC> cur . word_idx <SPC> not <SPC> in <SPC> ( - 1 , <SPC> idx ) <SPC> and <SPC> self . is_palindrome ( s , <SPC> i <SPC> - <SPC> 1 ) : <NL>                  res . append ( [ cur . word_idx , <SPC> idx ] ) <NL>          else : <NL>              break <NL> <NL> <TAB> def <SPC> is_palindrome ( self , <SPC> s , <SPC> j ) : <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> <= <SPC> j : <NL>          if <SPC> s [ i ] <SPC> != <SPC> s [ j ] : <NL>              return <SPC> False <NL>          i <SPC> += <SPC> 1 <NL>          j <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution_MLE ( object ) : <NL> <TAB> def <SPC> palindromePairs ( self , <SPC> words ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> trie <SPC> = <SPC> TrieNode ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) ) : <NL>          trie . insert ( words [ i ] , <SPC> i ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) ) : <NL>          trie . find ( words [ i ] , <SPC> i , <SPC> res ) <NL> <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> minCut ( self , <SPC> s ) : <NL> <TAB> lookup <SPC> = <SPC> [ [ False <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( s ) ) ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) ] <NL> <TAB> mincut <SPC> = <SPC> [ len ( s ) <SPC> - <SPC> 1 <SPC> - <SPC> i <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> + <SPC> 1 ) ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> len ( s ) ) : <NL>              if <SPC> s [ i ] <SPC> == <SPC> s [ j ] <SPC> and <SPC> ( j <SPC> - <SPC> i <SPC> < <SPC> 2 <SPC> or <SPC> lookup [ i <SPC> + <SPC> 1 ] [ j <SPC> - <SPC> 1 ] ) : <NL>                  lookup [ i ] [ j ] <SPC> = <SPC> True <NL>                  mincut [ i ] <SPC> = <SPC> min ( mincut [ i ] , <SPC> mincut [ j <SPC> + <SPC> 1 ] <SPC> + <SPC> 1 ) <NL> <NL> <TAB> return <SPC> mincut [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> palindromePartition ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> dp1 <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> len ( s ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( s ) ) ] <NL> <TAB> for <SPC> l <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> - <SPC> l <SPC> + <SPC> 1 ) : <NL>              j <SPC> = <SPC> i <SPC> + <SPC> l <SPC> - <SPC> 1 <NL>              if <SPC> i <SPC> == <SPC> j <SPC> - <SPC> 1 : <NL>                  dp1 [ i ] [ j ] <SPC> = <SPC> 0 <SPC> if <SPC> s [ i ] <SPC> == <SPC> s [ j ] <SPC> else <SPC> 1 <NL>              elif <SPC> i <SPC> != <SPC> j : <NL>                  dp1 [ i ] [ j ] <SPC> = <SPC> ( <NL>                      dp1 [ i <SPC> + <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> if <SPC> s [ i ] <SPC> == <SPC> s [ j ] <SPC> else <SPC> dp1 [ i <SPC> + <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> 1 <NL>                  ) <NL> <NL> <TAB> dp2 <SPC> = <SPC> [ [ float ( "inf" ) ] <SPC> * <SPC> len ( s ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> dp2 [ 1 ] <SPC> = <SPC> dp1 [ 0 ] [ : ] <NL> <TAB> for <SPC> d <SPC> in <SPC> xrange ( 2 , <SPC> k <SPC> + <SPC> 1 ) : <NL>          dp2 [ d <SPC> % <SPC> 2 ] <SPC> = <SPC> [ float ( "inf" ) ] <SPC> * <SPC> len ( s ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( d <SPC> - <SPC> 1 , <SPC> len ( s ) ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( d <SPC> - <SPC> 2 , <SPC> i ) : <NL>                  dp2 [ d <SPC> % <SPC> 2 ] [ i ] <SPC> = <SPC> min ( <NL>                      dp2 [ d <SPC> % <SPC> 2 ] [ i ] , <SPC> dp2 [ ( d <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <SPC> + <SPC> dp1 [ j <SPC> + <SPC> 1 ] [ i ] <NL>                  ) <NL> <TAB> return <SPC> dp2 [ k <SPC> % <SPC> 2 ] [ len ( s ) <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkPartitioning ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> manacher ( s ) : <NL>          s <SPC> = <SPC> "^#" <SPC> + <SPC> "#" . join ( s ) <SPC> + <SPC> "#$" <NL>          P <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( s ) <NL>          C , <SPC> R <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> - <SPC> 1 ) : <NL>              i_mirror <SPC> = <SPC> 2 <SPC> * <SPC> C <SPC> - <SPC> i <NL>              if <SPC> R <SPC> > <SPC> i : <NL>                  P [ i ] <SPC> = <SPC> min ( R <SPC> - <SPC> i , <SPC> P [ i_mirror ] ) <NL>              while <SPC> s [ i <SPC> + <SPC> 1 <SPC> + <SPC> P [ i ] ] <SPC> == <SPC> s [ i <SPC> - <SPC> 1 <SPC> - <SPC> P [ i ] ] : <NL>                  P [ i ] <SPC> += <SPC> 1 <NL>              if <SPC> i <SPC> + <SPC> P [ i ] <SPC> > <SPC> R : <NL>                  C , <SPC> R <SPC> = <SPC> i , <SPC> i <SPC> + <SPC> P [ i ] <NL>          return <SPC> P <NL> <NL> <TAB> P <SPC> = <SPC> manacher ( s ) <NL> <TAB> prefix , <SPC> suffix <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> len ( P ) <SPC> - <SPC> 2 ) : <NL>          if <SPC> i <SPC> - <SPC> 1 <SPC> - <SPC> P [ i ] <SPC> == <SPC> 0 : <NL>              prefix . append ( i ) <NL>          if <SPC> i <SPC> + <SPC> 1 <SPC> + <SPC> P [ i ] <SPC> == <SPC> len ( P ) <SPC> - <SPC> 1 : <NL>              suffix . append ( i ) <NL> <TAB> for <SPC> i <SPC> in <SPC> prefix : <NL>          for <SPC> j <SPC> in <SPC> suffix : <NL>              left , <SPC> right <SPC> = <SPC> i <SPC> + <SPC> 1 <SPC> + <SPC> P [ i ] , <SPC> j <SPC> - <SPC> 1 <SPC> - <SPC> P [ j ] <NL>              if <SPC> left <SPC> > <SPC> right : <NL>                  continue <NL>              mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>              if <SPC> P [ mid ] <SPC> >= <SPC> mid <SPC> - <SPC> left : <NL>                  return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> checkPartitioning ( self , <SPC> s ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ False ] <SPC> * <SPC> len ( s ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( s ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> len ( s ) ) : <NL>              if <SPC> s [ i ] <SPC> == <SPC> s [ j ] <SPC> and <SPC> ( j <SPC> - <SPC> i <SPC> < <SPC> 2 <SPC> or <SPC> dp [ i <SPC> + <SPC> 1 ] [ j <SPC> - <SPC> 1 ] ) : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> True <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> not <SPC> dp [ 0 ] [ i <SPC> - <SPC> 1 ] : <NL>              continue <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( s ) ) : <NL>              if <SPC> not <SPC> dp [ j ] [ - 1 ] : <NL>                  continue <NL>              if <SPC> dp [ i ] [ j <SPC> - <SPC> 1 ] : <NL>                  return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> partition ( self , <SPC> s ) : <NL> <TAB> n <SPC> = <SPC> len ( s ) <NL> <NL> <TAB> is_palindrome <SPC> = <SPC> [ [ 0 <SPC> for <SPC> j <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 0 , <SPC> n ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> n ) : <NL>              is_palindrome [ i ] [ j ] <SPC> = <SPC> s [ i ] <SPC> == <SPC> s [ j ] <SPC> and <SPC> ( <NL>                  ( j <SPC> - <SPC> i <SPC> < <SPC> 2 ) <SPC> or <SPC> is_palindrome [ i <SPC> + <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <NL>              ) <NL> <NL> <TAB> sub_partition <SPC> = <SPC> [ [ ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( n ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> n ) : <NL>              if <SPC> is_palindrome [ i ] [ j ] : <NL>                  if <SPC> j <SPC> + <SPC> 1 <SPC> < <SPC> n : <NL>                      for <SPC> p <SPC> in <SPC> sub_partition [ j <SPC> + <SPC> 1 ] : <NL>                          sub_partition [ i ] . append ( [ s [ i : <SPC> j <SPC> + <SPC> 1 ] ] <SPC> + <SPC> p ) <NL>                  else : <NL>                      sub_partition [ i ] . append ( [ s [ i : <SPC> j <SPC> + <SPC> 1 ] ] ) <NL> <NL> <TAB> return <SPC> sub_partition [ 0 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> partition ( self , <SPC> s ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> self . partitionRecu ( result , <SPC> [ ] , <SPC> s , <SPC> 0 ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> partitionRecu ( self , <SPC> result , <SPC> cur , <SPC> s , <SPC> i ) : <NL> <TAB> if <SPC> i <SPC> == <SPC> len ( s ) : <NL>          result . append ( list ( cur ) ) <NL> <TAB> else : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> len ( s ) ) : <NL>              if <SPC> self . isPalindrome ( s [ i : <SPC> j <SPC> + <SPC> 1 ] ) : <NL>                  cur . append ( s [ i : <SPC> j <SPC> + <SPC> 1 ] ) <NL>                  self . partitionRecu ( result , <SPC> cur , <SPC> s , <SPC> j <SPC> + <SPC> 1 ) <NL>                  cur . pop ( ) <NL> <NL> <TAB> def <SPC> isPalindrome ( self , <SPC> s ) : <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> / <SPC> 2 ) : <NL>          if <SPC> s [ i ] <SPC> != <SPC> s [ - ( i <SPC> + <SPC> 1 ) ] : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> generatePalindromes ( self , <SPC> s ) : <NL> <NL> <TAB> cnt <SPC> = <SPC> collections . Counter ( s ) <NL> <TAB> mid <SPC> = <SPC> "" . join ( k <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> cnt . iteritems ( ) <SPC> if <SPC> v <SPC> % <SPC> 2 ) <NL> <TAB> chars <SPC> = <SPC> "" . join ( k <SPC> * <SPC> ( v <SPC> / <SPC> 2 ) <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> cnt . iteritems ( ) ) <NL> <TAB> return <SPC> self . permuteUnique ( mid , <SPC> chars ) <SPC> if <SPC> len ( mid ) <SPC> < <SPC> 2 <SPC> else <SPC> [ ] <NL> <NL> <TAB> def <SPC> permuteUnique ( self , <SPC> mid , <SPC> nums ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> used <SPC> = <SPC> [ False ] <SPC> * <SPC> len ( nums ) <NL> <TAB> self . permuteUniqueRecu ( mid , <SPC> result , <SPC> used , <SPC> [ ] , <SPC> nums ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> permuteUniqueRecu ( self , <SPC> mid , <SPC> result , <SPC> used , <SPC> cur , <SPC> nums ) : <NL> <TAB> if <SPC> len ( cur ) <SPC> == <SPC> len ( nums ) : <NL>          half_palindrome <SPC> = <SPC> "" . join ( cur ) <NL>          result . append ( half_palindrome <SPC> + <SPC> mid <SPC> + <SPC> half_palindrome [ : : - 1 ] ) <NL>          return <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> not <SPC> used [ i ] <SPC> and <SPC> not <SPC> ( i <SPC> > <SPC> 0 <SPC> and <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> nums [ i ] <SPC> and <SPC> used [ i <SPC> - <SPC> 1 ] ) : <NL>              used [ i ] <SPC> = <SPC> True <NL>              cur . append ( nums [ i ] ) <NL>              self . permuteUniqueRecu ( mid , <SPC> result , <SPC> used , <SPC> cur , <SPC> nums ) <NL>              cur . pop ( ) <NL>              used [ i ] <SPC> = <SPC> False <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> generatePalindromes ( self , <SPC> s ) : <NL> <NL> <TAB> cnt <SPC> = <SPC> collections . Counter ( s ) <NL> <TAB> mid <SPC> = <SPC> tuple ( k <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> cnt . iteritems ( ) <SPC> if <SPC> v <SPC> % <SPC> 2 ) <NL> <TAB> chars <SPC> = <SPC> "" . join ( k <SPC> * <SPC> ( v <SPC> / <SPC> 2 ) <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> cnt . iteritems ( ) ) <NL> <TAB> return <SPC> ( <NL>          [ <NL>              "" . join ( half_palindrome <SPC> + <SPC> mid <SPC> + <SPC> half_palindrome [ : : - 1 ] ) <NL>              for <SPC> half_palindrome <SPC> in <SPC> set ( itertools . permutations ( chars ) ) <NL>          ] <NL>          if <SPC> len ( mid ) <SPC> < <SPC> 2 <NL>          else <SPC> [ ] <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canPermutePalindrome ( self , <SPC> s ) : <NL> <NL> <TAB> return <SPC> sum ( v <SPC> % <SPC> 2 <SPC> for <SPC> v <SPC> in <SPC> collections . Counter ( s ) . values ( ) ) <SPC> < <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumMoves ( self , <SPC> arr ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( arr ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( arr ) <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> l <SPC> in <SPC> xrange ( 1 , <SPC> len ( arr ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( arr ) <SPC> - <SPC> l <SPC> + <SPC> 1 ) : <NL>              j <SPC> = <SPC> i <SPC> + <SPC> l <SPC> - <SPC> 1 <NL>              if <SPC> l <SPC> == <SPC> 1 : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> 1 <NL>              else : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> 1 <SPC> + <SPC> dp [ i <SPC> + <SPC> 1 ] [ j ] <NL>                  if <SPC> arr [ i ] <SPC> == <SPC> arr [ i <SPC> + <SPC> 1 ] : <NL>                      dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> 1 <SPC> + <SPC> dp [ i <SPC> + <SPC> 2 ] [ j ] ) <NL>                  for <SPC> k <SPC> in <SPC> xrange ( i <SPC> + <SPC> 2 , <SPC> j <SPC> + <SPC> 1 ) : <NL>                      if <SPC> arr [ i ] <SPC> == <SPC> arr [ k ] : <NL>                          dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> dp [ i <SPC> + <SPC> 1 ] <NL>                                         [ k <SPC> - <SPC> 1 ] <SPC> + <SPC> dp [ k <SPC> + <SPC> 1 ] [ j ] ) <NL> <TAB> return <SPC> dp [ 0 ] [ len ( arr ) <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countSubstrings ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> manacher ( s ) : <NL>          s <SPC> = <SPC> "^#" <SPC> + <SPC> "#" . join ( s ) <SPC> + <SPC> "#$" <NL>          P <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( s ) <NL>          C , <SPC> R <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> - <SPC> 1 ) : <NL>              i_mirror <SPC> = <SPC> 2 <SPC> * <SPC> C <SPC> - <SPC> i <NL>              if <SPC> R <SPC> > <SPC> i : <NL>                  P [ i ] <SPC> = <SPC> min ( R <SPC> - <SPC> i , <SPC> P [ i_mirror ] ) <NL>              while <SPC> s [ i <SPC> + <SPC> 1 <SPC> + <SPC> P [ i ] ] <SPC> == <SPC> s [ i <SPC> - <SPC> 1 <SPC> - <SPC> P [ i ] ] : <NL>                  P [ i ] <SPC> += <SPC> 1 <NL>              if <SPC> i <SPC> + <SPC> P [ i ] <SPC> > <SPC> R : <NL>                  C , <SPC> R <SPC> = <SPC> i , <SPC> i <SPC> + <SPC> P [ i ] <NL>          return <SPC> P <NL> <NL> <TAB> return <SPC> sum ( ( max_len <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 <SPC> for <SPC> max_len <SPC> in <SPC> manacher ( s ) ) <NL> <NL> <NL> class <SPC> BIT ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . __bit <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <NL> <TAB> def <SPC> add ( self , <SPC> i , <SPC> val ) : <NL> <TAB> i <SPC> += <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( self . __bit ) : <NL>          self . __bit [ i ] <SPC> += <SPC> val <NL>          i <SPC> += <SPC> i <SPC> & <SPC> - i <NL> <NL> <TAB> def <SPC> query ( self , <SPC> i ) : <NL> <TAB> i <SPC> += <SPC> 1 <NL> <TAB> ret <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> > <SPC> 0 : <NL>          ret <SPC> += <SPC> self . __bit [ i ] <NL>          i <SPC> -= <SPC> i <SPC> & <SPC> - i <NL> <TAB> return <SPC> ret <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pancakeSort ( self , <SPC> arr ) : <NL> <NL> <TAB> bit <SPC> = <SPC> BIT ( len ( arr ) ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( arr ) ) : <NL>          n <SPC> = <SPC> bit . query ( ( arr [ i ] <SPC> - <SPC> 1 ) <SPC> - <SPC> 1 ) <NL>          bit . add ( arr [ i ] <SPC> - <SPC> 1 , <SPC> 1 ) <NL>          if <SPC> n <SPC> == <SPC> i : <NL>              continue <NL>          if <SPC> n <SPC> == <SPC> 0 : <NL>              if <SPC> i <SPC> > <SPC> 1 : <NL>                  result . append ( i ) <NL>              result . append ( i <SPC> + <SPC> 1 ) <NL>          else : <NL>              if <SPC> n <SPC> > <SPC> 1 : <NL>                  result . append ( n ) <NL>              result . append ( i ) <NL>              result . append ( i <SPC> + <SPC> 1 ) <NL>              result . append ( n <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> pancakeSort ( self , <SPC> arr ) : <NL> <NL> <TAB> def <SPC> smallerMergeSort ( idxs , <SPC> start , <SPC> end , <SPC> counts ) : <NL>          if <SPC> ( <NL>              end <SPC> - <SPC> start <SPC> <= <SPC> 0 <NL>          ) : <NL>              return <SPC> 0 <NL> <NL>          mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> // <SPC> 2 <NL>          smallerMergeSort ( idxs , <SPC> start , <SPC> mid , <SPC> counts ) <NL>          smallerMergeSort ( idxs , <SPC> mid <SPC> + <SPC> 1 , <SPC> end , <SPC> counts ) <NL>          r <SPC> = <SPC> start <NL>          tmp <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( mid <SPC> + <SPC> 1 , <SPC> end <SPC> + <SPC> 1 ) : <NL> <NL>              while <SPC> r <SPC> <= <SPC> mid <SPC> and <SPC> idxs [ r ] [ 0 ] <SPC> < <SPC> idxs [ i ] [ 0 ] : <NL>                  tmp . append ( idxs [ r ] ) <NL>                  r <SPC> += <SPC> 1 <NL>              if <SPC> r <SPC> <= <SPC> mid : <NL>                  tmp . append ( idxs [ i ] ) <NL>              counts [ idxs [ i ] [ 1 ] ] <SPC> += <SPC> r <SPC> - <SPC> start <NL>          while <SPC> r <SPC> <= <SPC> mid : <NL>              tmp . append ( idxs [ r ] ) <NL>              r <SPC> += <SPC> 1 <NL> <NL>          idxs [ start : <SPC> start <SPC> + <SPC> len ( tmp ) ] <SPC> = <SPC> tmp <NL> <NL> <TAB> idxs <SPC> = <SPC> [ ] <NL> <TAB> smaller_counts <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( arr ) <NL> <TAB> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( arr ) : <NL>          idxs . append ( ( x , <SPC> i ) ) <NL> <TAB> smallerMergeSort ( idxs , <SPC> 0 , <SPC> len ( idxs ) <SPC> - <SPC> 1 , <SPC> smaller_counts ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> n <SPC> in <SPC> enumerate ( smaller_counts ) : <NL>          if <SPC> n <SPC> == <SPC> i : <NL>              continue <NL>          if <SPC> n <SPC> == <SPC> 0 : <NL>              if <SPC> i <SPC> > <SPC> 1 : <NL>                  result . append ( i ) <NL>              result . append ( i <SPC> + <SPC> 1 ) <NL>          else : <NL>              if <SPC> n <SPC> > <SPC> 1 : <NL>                  result . append ( n ) <NL>              result . append ( i ) <NL>              result . append ( i <SPC> + <SPC> 1 ) <NL>              result . append ( n <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> pancakeSort ( self , <SPC> A ) : <NL> <NL> <TAB> def <SPC> reverse ( l , <SPC> begin , <SPC> end ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( ( end <SPC> - <SPC> begin ) <SPC> // <SPC> 2 ) : <NL>              l [ begin <SPC> + <SPC> i ] , <SPC> l [ end <SPC> - <SPC> 1 <SPC> - <SPC> i ] <SPC> = <SPC> l [ end <SPC> - <SPC> 1 <SPC> - <SPC> i ] , <SPC> l [ begin <SPC> + <SPC> i ] <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> n <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( A ) <SPC> + <SPC> 1 ) ) : <NL>          i <SPC> = <SPC> A . index ( n ) <NL>          reverse ( A , <SPC> 0 , <SPC> i <SPC> + <SPC> 1 ) <NL>          result . append ( i <SPC> + <SPC> 1 ) <NL>          reverse ( A , <SPC> 0 , <SPC> n ) <NL>          result . append ( n ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minNumberOfSemesters ( self , <SPC> n , <SPC> dependencies , <SPC> k ) : <NL> <NL> <TAB> reqs <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> dependencies : <NL>          reqs [ v <SPC> - <SPC> 1 ] <SPC> |= <SPC> 1 <SPC> << <SPC> ( u <SPC> - <SPC> 1 ) <NL> <TAB> dp <SPC> = <SPC> [ n ] <SPC> * <SPC> ( 1 <SPC> << <SPC> n ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> mask <SPC> in <SPC> xrange ( 1 <SPC> << <SPC> n ) : <NL>          candidates <SPC> = <SPC> [ ] <NL>          for <SPC> v <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> ( mask <SPC> & <SPC> ( 1 <SPC> << <SPC> v ) ) <SPC> == <SPC> 0 <SPC> and <SPC> ( mask <SPC> & <SPC> reqs [ v ] ) <SPC> == <SPC> reqs [ v ] : <NL>                  candidates . append ( v ) <NL>          for <SPC> choice <SPC> in <SPC> itertools . combinations ( candidates , <SPC> min ( len ( candidates ) , <SPC> k ) ) : <NL>              new_mask <SPC> = <SPC> mask <NL>              for <SPC> v <SPC> in <SPC> choice : <NL>                  new_mask <SPC> |= <SPC> 1 <SPC> << <SPC> v <NL>              dp [ new_mask ] <SPC> = <SPC> min ( dp [ new_mask ] , <SPC> dp [ mask ] <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> dp [ - 1 ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution_WA ( object ) : <NL> <TAB> def <SPC> minNumberOfSemesters ( self , <SPC> n , <SPC> dependencies , <SPC> k ) : <NL> <NL> <TAB> def <SPC> dfs ( graph , <SPC> i , <SPC> depths ) : <NL>          if <SPC> depths [ i ] <SPC> == <SPC> - 1 : <NL>              depths [ i ] <SPC> = <SPC> ( <NL>                  max ( dfs ( graph , <SPC> child , <SPC> depths ) <SPC> for <SPC> child <SPC> in <SPC> graph [ i ] ) <SPC> + <SPC> 1 <NL>                  if <SPC> i <SPC> in <SPC> graph <NL>                  else <SPC> 1 <NL>              ) <NL>          return <SPC> depths [ i ] <NL> <NL> <TAB> degrees <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> dependencies : <NL>          graph [ u <SPC> - <SPC> 1 ] . append ( v <SPC> - <SPC> 1 ) <NL>          degrees [ v <SPC> - <SPC> 1 ] <SPC> += <SPC> 1 <NL> <TAB> depths <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> n <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          dfs ( graph , <SPC> i , <SPC> depths ) <NL> <TAB> max_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          if <SPC> not <SPC> degrees [ i ] : <NL>              heapq . heappush ( max_heap , <SPC> ( - depths [ i ] , <SPC> i ) ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> max_heap : <NL>          new_q <SPC> = <SPC> [ ] <NL>          for <SPC> _ <SPC> in <SPC> xrange ( min ( len ( max_heap ) , <SPC> k ) ) : <NL>              _ , <SPC> node <SPC> = <SPC> heapq . heappop ( max_heap ) <NL>              if <SPC> node <SPC> not <SPC> in <SPC> graph : <NL>                  continue <NL>              for <SPC> child <SPC> in <SPC> graph [ node ] : <NL>                  degrees [ child ] <SPC> -= <SPC> 1 <NL>                  if <SPC> not <SPC> degrees [ child ] : <NL>                      new_q . append ( child ) <NL>          result <SPC> += <SPC> 1 <NL>          for <SPC> node <SPC> in <SPC> new_q : <NL>              heapq . heappush ( max_heap , <SPC> ( - depths [ node ] , <SPC> node ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumSemesters ( self , <SPC> N , <SPC> relations ) : <NL> <NL> <TAB> g <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> in_degree <SPC> = <SPC> [ 0 ] <SPC> * <SPC> N <NL> <TAB> for <SPC> x , <SPC> y <SPC> in <SPC> relations : <NL>          g [ x <SPC> - <SPC> 1 ] . append ( y <SPC> - <SPC> 1 ) <NL>          in_degree [ y <SPC> - <SPC> 1 ] <SPC> += <SPC> 1 <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ ( 1 , <SPC> i ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( N ) <SPC> if <SPC> not <SPC> in_degree [ i ] ] ) <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> count <SPC> = <SPC> N <NL> <TAB> while <SPC> q : <NL>          level , <SPC> u <SPC> = <SPC> q . popleft ( ) <NL>          count <SPC> -= <SPC> 1 <NL>          result <SPC> = <SPC> level <NL>          for <SPC> v <SPC> in <SPC> g [ u ] : <NL>              in_degree [ v ] <SPC> -= <SPC> 1 <NL>              if <SPC> not <SPC> in_degree [ v ] : <NL>                  q . append ( ( level <SPC> + <SPC> 1 , <SPC> v ) ) <NL> <TAB> return <SPC> result <SPC> if <SPC> count <SPC> == <SPC> 0 <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> evaluate ( self , <SPC> expression ) : <NL> <NL> <TAB> def <SPC> getval ( lookup , <SPC> x ) : <NL>          return <SPC> lookup . get ( x , <SPC> x ) <NL> <NL> <TAB> def <SPC> evaluate ( tokens , <SPC> lookup ) : <NL>          if <SPC> tokens [ 0 ] <SPC> in <SPC> ( "add" , <SPC> "mult" ) : <NL>              a , <SPC> b <SPC> = <SPC> map ( int , <SPC> map ( lambda <SPC> x : <SPC> getval ( lookup , <SPC> x ) , <SPC> tokens [ 1 : ] ) ) <NL>              return <SPC> str ( a <SPC> + <SPC> b <SPC> if <SPC> tokens [ 0 ] <SPC> == <SPC> "add" <SPC> else <SPC> a <SPC> * <SPC> b ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( tokens ) <SPC> - <SPC> 1 , <SPC> 2 ) : <NL>              if <SPC> tokens [ i <SPC> + <SPC> 1 ] : <NL>                  lookup [ tokens [ i ] ] <SPC> = <SPC> getval ( lookup , <SPC> tokens [ i <SPC> + <SPC> 1 ] ) <NL>          return <SPC> getval ( lookup , <SPC> tokens [ - 1 ] ) <NL> <NL> <TAB> tokens , <SPC> lookup , <SPC> stk <SPC> = <SPC> [ "" ] , <SPC> { } , <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> expression : <NL>          if <SPC> c <SPC> == <SPC> "(" : <NL>              if <SPC> tokens [ 0 ] <SPC> == <SPC> "let" : <NL>                  evaluate ( tokens , <SPC> lookup ) <NL>              stk . append ( ( tokens , <SPC> dict ( lookup ) ) ) <NL>              tokens <SPC> = <SPC> [ "" ] <NL>          elif <SPC> c <SPC> == <SPC> " " : <NL>              tokens . append ( "" ) <NL>          elif <SPC> c <SPC> == <SPC> ")" : <NL>              val <SPC> = <SPC> evaluate ( tokens , <SPC> lookup ) <NL>              tokens , <SPC> lookup <SPC> = <SPC> stk . pop ( ) <NL>              tokens [ - 1 ] <SPC> += <SPC> val <NL>          else : <NL>              tokens [ - 1 ] <SPC> += <SPC> c <NL> <TAB> return <SPC> int ( tokens [ 0 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> parseBoolExpr ( self , <SPC> expression ) : <NL> <NL> <TAB> def <SPC> parse ( expression , <SPC> i ) : <NL>          if <SPC> expression [ i [ 0 ] ] <SPC> not <SPC> in <SPC> "&|!" : <NL>              result <SPC> = <SPC> expression [ i [ 0 ] ] <SPC> == <SPC> "t" <NL>              i [ 0 ] <SPC> += <SPC> 1 <NL>              return <SPC> result <NL>          op <SPC> = <SPC> expression [ i [ 0 ] ] <NL>          i [ 0 ] <SPC> += <SPC> 2 <NL>          stk <SPC> = <SPC> [ ] <NL>          while <SPC> expression [ i [ 0 ] ] <SPC> != <SPC> ")" : <NL>              if <SPC> expression [ i [ 0 ] ] <SPC> == <SPC> "," : <NL>                  i [ 0 ] <SPC> += <SPC> 1 <NL>                  continue <NL>              stk . append ( parse ( expression , <SPC> i ) ) <NL>          i [ 0 ] <SPC> += <SPC> 1 <NL>          if <SPC> op <SPC> == <SPC> "&" : <NL>              return <SPC> all ( stk ) <NL>          if <SPC> op <SPC> == <SPC> "|" : <NL>              return <SPC> any ( stk ) <NL>          return <SPC> not <SPC> stk [ 0 ] <NL> <NL> <TAB> return <SPC> parse ( expression , <SPC> [ 0 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSumAfterPartitioning ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> W <SPC> = <SPC> K <SPC> + <SPC> 1 <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> W <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          curr_max <SPC> = <SPC> 0 <NL> <NL>          for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> min ( K , <SPC> i <SPC> + <SPC> 1 ) <SPC> + <SPC> 1 ) : <NL>              curr_max <SPC> = <SPC> max ( curr_max , <SPC> A [ i <SPC> - <SPC> k <SPC> + <SPC> 1 ] ) <NL>              dp [ i <SPC> % <SPC> W ] <SPC> = <SPC> max ( <NL>                  dp [ i <SPC> % <SPC> W ] , <SPC> ( dp [ ( i <SPC> - <SPC> k ) <SPC> % <SPC> W ] <SPC> if <SPC> i <SPC> >= <SPC> k <SPC> else <SPC> 0 ) <SPC> + <SPC> curr_max <SPC> * <SPC> k <NL>              ) <NL> <TAB> return <SPC> dp [ ( len ( A ) <SPC> - <SPC> 1 ) <SPC> % <SPC> W ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> partitionDisjoint ( self , <SPC> A ) : <NL> <NL> <TAB> B <SPC> = <SPC> A [ : ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( A ) <SPC> - <SPC> 1 ) ) : <NL>          B [ i ] <SPC> = <SPC> min ( B [ i ] , <SPC> B [ i <SPC> + <SPC> 1 ] ) <NL> <TAB> p_max <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) ) : <NL>          p_max <SPC> = <SPC> max ( p_max , <SPC> A [ i <SPC> - <SPC> 1 ] ) <NL>          if <SPC> p_max <SPC> <= <SPC> B [ i ] : <NL>              return <SPC> i <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canThreePartsEqualSum ( self , <SPC> A ) : <NL> <NL> <TAB> total <SPC> = <SPC> sum ( A ) <NL> <TAB> if <SPC> total <SPC> % <SPC> 3 <SPC> != <SPC> 0 : <NL>          return <SPC> False <NL> <TAB> parts , <SPC> curr <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> A : <NL>          curr <SPC> += <SPC> x <NL>          if <SPC> curr <SPC> == <SPC> total <SPC> // <SPC> 3 : <NL>              parts <SPC> += <SPC> 1 <NL>              curr <SPC> = <SPC> 0 <NL> <TAB> return <SPC> parts <SPC> >= <SPC> 3 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canPartition ( self , <SPC> nums ) : <NL> <NL> <TAB> s <SPC> = <SPC> sum ( nums ) <NL> <TAB> if <SPC> s <SPC> % <SPC> 2 : <NL>          return <SPC> False <NL> <NL> <TAB> dp <SPC> = <SPC> [ False ] <SPC> * <SPC> ( s <SPC> / <SPC> 2 <SPC> + <SPC> 1 ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> True <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( dp ) ) ) : <NL>              if <SPC> num <SPC> <= <SPC> i : <NL>                  dp [ i ] <SPC> = <SPC> dp [ i ] <SPC> or <SPC> dp [ i <SPC> - <SPC> num ] <NL> <TAB> return <SPC> dp [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> partitionLabels ( self , <SPC> S ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { c : <SPC> i <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( S ) } <NL> <TAB> first , <SPC> last <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( S ) : <NL>          last <SPC> = <SPC> max ( last , <SPC> lookup [ c ] ) <NL>          if <SPC> i <SPC> == <SPC> last : <NL>              result . append ( i <SPC> - <SPC> first <SPC> + <SPC> 1 ) <NL>              first <SPC> = <SPC> i <SPC> + <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> repr ( self . next ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> partition ( self , <SPC> head , <SPC> x ) : <NL> <TAB> dummySmaller , <SPC> dummyGreater <SPC> = <SPC> ListNode ( - 1 ) , <SPC> ListNode ( - 1 ) <NL> <TAB> smaller , <SPC> greater <SPC> = <SPC> dummySmaller , <SPC> dummyGreater <NL> <NL> <TAB> while <SPC> head : <NL>          if <SPC> head . val <SPC> < <SPC> x : <NL>              smaller . next <SPC> = <SPC> head <NL>              smaller <SPC> = <SPC> smaller . next <NL>          else : <NL>              greater . next <SPC> = <SPC> head <NL>              greater <SPC> = <SPC> greater . next <NL>          head <SPC> = <SPC> head . next <NL> <NL> <TAB> smaller . next <SPC> = <SPC> dummyGreater . next <NL> <TAB> greater . next <SPC> = <SPC> None <NL> <NL> <TAB> return <SPC> dummySmaller . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canPartitionKSubsets ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> dfs ( nums , <SPC> target , <SPC> used , <SPC> todo , <SPC> lookup ) : <NL>          if <SPC> lookup [ used ] <SPC> is <SPC> None : <NL>              targ <SPC> = <SPC> ( todo <SPC> - <SPC> 1 ) <SPC> % <SPC> target <SPC> + <SPC> 1 <NL>              lookup [ used ] <SPC> = <SPC> any ( <NL>                  dfs ( nums , <SPC> target , <SPC> used <SPC> | <SPC> ( 1 <SPC> << <SPC> i ) , <SPC> todo <SPC> - <SPC> num , <SPC> lookup ) <NL>                  for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) <NL>                  if <SPC> ( ( used <SPC> >> <SPC> i ) <SPC> & <SPC> 1 ) <SPC> == <SPC> 0 <SPC> and <SPC> num <SPC> <= <SPC> targ <NL>              ) <NL>          return <SPC> lookup [ used ] <NL> <NL> <TAB> total <SPC> = <SPC> sum ( nums ) <NL> <TAB> if <SPC> total <SPC> % <SPC> k <SPC> or <SPC> max ( nums ) <SPC> > <SPC> total <SPC> // <SPC> k : <NL>          return <SPC> False <NL> <TAB> lookup <SPC> = <SPC> [ None ] <SPC> * <SPC> ( 1 <SPC> << <SPC> len ( nums ) ) <NL> <TAB> lookup [ - 1 ] <SPC> = <SPC> True <NL> <TAB> return <SPC> dfs ( nums , <SPC> total <SPC> // <SPC> k , <SPC> 0 , <SPC> total , <SPC> lookup ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> canPartitionKSubsets ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> dfs ( nums , <SPC> target , <SPC> i , <SPC> subset_sums ) : <NL>          if <SPC> i <SPC> == <SPC> len ( nums ) : <NL>              return <SPC> True <NL>          for <SPC> k <SPC> in <SPC> xrange ( len ( subset_sums ) ) : <NL>              if <SPC> subset_sums [ k ] <SPC> + <SPC> nums [ i ] <SPC> > <SPC> target : <NL>                  continue <NL>              subset_sums [ k ] <SPC> += <SPC> nums [ i ] <NL>              if <SPC> dfs ( nums , <SPC> target , <SPC> i <SPC> + <SPC> 1 , <SPC> subset_sums ) : <NL>                  return <SPC> True <NL>              subset_sums [ k ] <SPC> -= <SPC> nums [ i ] <NL>              if <SPC> not <SPC> subset_sums [ k ] : <NL>                  break <NL>          return <SPC> False <NL> <NL> <TAB> total <SPC> = <SPC> sum ( nums ) <NL> <TAB> if <SPC> total <SPC> % <SPC> k <SPC> != <SPC> 0 <SPC> or <SPC> max ( nums ) <SPC> > <SPC> total <SPC> // <SPC> k : <NL>          return <SPC> False <NL> <TAB> nums . sort ( reverse = True ) <NL> <TAB> subset_sums <SPC> = <SPC> [ 0 ] <SPC> * <SPC> k <NL> <TAB> return <SPC> dfs ( nums , <SPC> total <SPC> // <SPC> k , <SPC> 0 , <SPC> subset_sums ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minPartitions ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> int ( max ( n ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> getRow ( self , <SPC> rowIndex ) : <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( rowIndex <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( rowIndex <SPC> + <SPC> 1 ) : <NL>          old <SPC> = <SPC> result [ 0 ] <SPC> = <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> i <SPC> + <SPC> 1 ) : <NL>              old , <SPC> result [ j ] <SPC> = <SPC> result [ j ] , <SPC> old <SPC> + <SPC> result [ j ] <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> getRow2 ( self , <SPC> rowIndex ) : <NL> <NL> <TAB> row <SPC> = <SPC> [ 1 ] <NL> <TAB> for <SPC> _ <SPC> in <SPC> range ( rowIndex ) : <NL>          row <SPC> = <SPC> [ x <SPC> + <SPC> y <SPC> for <SPC> x , <SPC> y <SPC> in <SPC> zip ( [ 0 ] <SPC> + <SPC> row , <SPC> row <SPC> + <SPC> [ 0 ] ) ] <NL> <TAB> return <SPC> row <NL> <NL> <TAB> def <SPC> getRow3 ( self , <SPC> rowIndex ) : <NL> <NL> <TAB> if <SPC> rowIndex <SPC> == <SPC> 0 : <NL>          return <SPC> [ 1 ] <NL> <TAB> res <SPC> = <SPC> [ 1 , <SPC> 1 ] <NL> <NL> <TAB> def <SPC> add ( nums ) : <NL>          res <SPC> = <SPC> nums [ : 1 ] <NL>          for <SPC> i , <SPC> j <SPC> in <SPC> enumerate ( nums ) : <NL>              if <SPC> i <SPC> < <SPC> len ( nums ) <SPC> - <SPC> 1 : <NL>                  res <SPC> += <SPC> [ nums [ i ] <SPC> + <SPC> nums [ i <SPC> + <SPC> 1 ] ] <NL>          res <SPC> += <SPC> nums [ : 1 ] <NL>          return <SPC> res <NL> <NL> <TAB> while <SPC> res [ 1 ] <SPC> < <SPC> rowIndex : <NL>          res <SPC> = <SPC> add ( res ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> getRow ( self , <SPC> rowIndex ) : <NL> <TAB> result <SPC> = <SPC> [ 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> rowIndex <SPC> + <SPC> 1 ) : <NL>          result <SPC> = <SPC> [ 1 ] <SPC> + <SPC> [ result [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> result [ j ] <SPC> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> i ) ] <SPC> + <SPC> [ 1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> generate ( self , <SPC> numRows ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( numRows ) : <NL>          result . append ( [ ] ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 ) : <NL>              if <SPC> j <SPC> in <SPC> ( 0 , <SPC> i ) : <NL>                  result [ i ] . append ( 1 ) <NL>              else : <NL>                  result [ i ] . append ( result [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> result [ i <SPC> - <SPC> 1 ] [ j ] ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> generate2 ( self , <SPC> numRows ) : <NL> <TAB> if <SPC> not <SPC> numRows : <NL>          return <SPC> [ ] <NL> <TAB> res <SPC> = <SPC> [ [ 1 ] ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 1 , <SPC> numRows ) : <NL>          res <SPC> += <SPC> [ map ( lambda <SPC> x , <SPC> y : <SPC> x <SPC> + <SPC> y , <SPC> res [ - 1 ] <SPC> + <SPC> [ 0 ] , <SPC> [ 0 ] <SPC> + <SPC> res [ - 1 ] ) ] <NL> <TAB> return <SPC> res [ : numRows ] <NL> <NL> <TAB> def <SPC> generate3 ( self , <SPC> numRows ) : <NL> <NL> <TAB> if <SPC> numRows <SPC> == <SPC> 0 : <NL>          return <SPC> [ ] <NL> <TAB> if <SPC> numRows <SPC> == <SPC> 1 : <NL>          return <SPC> [ [ 1 ] ] <NL> <TAB> res <SPC> = <SPC> [ [ 1 ] , <SPC> [ 1 , <SPC> 1 ] ] <NL> <NL> <TAB> def <SPC> add ( nums ) : <NL>          res <SPC> = <SPC> nums [ : 1 ] <NL>          for <SPC> i , <SPC> j <SPC> in <SPC> enumerate ( nums ) : <NL>              if <SPC> i <SPC> < <SPC> len ( nums ) <SPC> - <SPC> 1 : <NL>                  res <SPC> += <SPC> [ nums [ i ] <SPC> + <SPC> nums [ i <SPC> + <SPC> 1 ] ] <NL>          res <SPC> += <SPC> nums [ : 1 ] <NL>          return <SPC> res <NL> <NL> <TAB> while <SPC> len ( res ) <SPC> < <SPC> numRows : <NL>          res . extend ( [ add ( res [ - 1 ] ) ] ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minPatches ( self , <SPC> nums , <SPC> n ) : <NL> <NL> <TAB> patch , <SPC> miss , <SPC> i <SPC> = <SPC> 0 , <SPC> 1 , <SPC> 0 <NL> <TAB> while <SPC> miss <SPC> <= <SPC> n : <NL>          if <SPC> i <SPC> < <SPC> len ( nums ) <SPC> and <SPC> nums [ i ] <SPC> <= <SPC> miss : <NL>              miss <SPC> += <SPC> nums [ i ] <NL>              i <SPC> += <SPC> 1 <NL>          else : <NL>              miss <SPC> += <SPC> miss <NL>              patch <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> patch <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPathCrossing ( self , <SPC> path ) : <NL> <NL> <TAB> x <SPC> = <SPC> y <SPC> = <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> { ( 0 , <SPC> 0 ) } <NL> <TAB> for <SPC> c <SPC> in <SPC> path : <NL>          if <SPC> c <SPC> == <SPC> "E" : <NL>              x <SPC> += <SPC> 1 <NL>          elif <SPC> c <SPC> == <SPC> "W" : <NL>              x <SPC> -= <SPC> 1 <NL>          elif <SPC> c <SPC> == <SPC> "N" : <NL>              y <SPC> += <SPC> 1 <NL>          elif <SPC> c <SPC> == <SPC> "S" : <NL>              y <SPC> -= <SPC> 1 <NL>          if <SPC> ( x , <SPC> y ) <SPC> in <SPC> lookup : <NL>              return <SPC> True <NL>          lookup . add ( ( x , <SPC> y ) ) <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pathInZigZagTree ( self , <SPC> label ) : <NL> <NL> <TAB> count <SPC> = <SPC> 2 <SPC> ** <SPC> label . bit_length ( ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> label <SPC> >= <SPC> 1 : <NL>          result . append ( label ) <NL>          label <SPC> = <SPC> ( ( count <SPC> // <SPC> 2 ) <SPC> + <SPC> ( ( count <SPC> - <SPC> 1 ) <SPC> - <SPC> label ) ) <SPC> // <SPC> 2 <NL>          count <SPC> //= <SPC> 2 <NL> <TAB> result . reverse ( ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> pathSum ( self , <SPC> root , <SPC> sum ) : <NL> <TAB> return <SPC> self . pathSumRecu ( [ ] , <SPC> [ ] , <SPC> root , <SPC> sum ) <NL> <NL> <TAB> def <SPC> pathSumRecu ( self , <SPC> result , <SPC> cur , <SPC> root , <SPC> sum ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> result <NL> <NL> <TAB> if <SPC> root . left <SPC> is <SPC> None <SPC> and <SPC> root . right <SPC> is <SPC> None <SPC> and <SPC> root . val <SPC> == <SPC> sum : <NL>          result . append ( cur <SPC> + <SPC> [ root . val ] ) <NL>          return <SPC> result <NL> <NL> <TAB> cur . append ( root . val ) <NL> <TAB> self . pathSumRecu ( result , <SPC> cur , <SPC> root . left , <SPC> sum <SPC> - <SPC> root . val ) <NL> <TAB> self . pathSumRecu ( result , <SPC> cur , <SPC> root . right , <SPC> sum <SPC> - <SPC> root . val ) <NL> <TAB> cur . pop ( ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pathSum ( self , <SPC> root , <SPC> sum ) : <NL> <NL> <TAB> def <SPC> pathSumHelper ( root , <SPC> curr , <SPC> sum , <SPC> lookup ) : <NL>          if <SPC> root <SPC> is <SPC> None : <NL>              return <SPC> 0 <NL>          curr <SPC> += <SPC> root . val <NL>          result <SPC> = <SPC> lookup [ curr <SPC> - <SPC> sum ] <SPC> if <SPC> curr <SPC> - <SPC> sum <SPC> in <SPC> lookup <SPC> else <SPC> 0 <NL>          lookup [ curr ] <SPC> += <SPC> 1 <NL>          result <SPC> += <SPC> pathSumHelper ( root . left , <SPC> curr , <SPC> sum , <SPC> lookup ) <SPC> + <SPC> pathSumHelper ( <NL>              root . right , <SPC> curr , <SPC> sum , <SPC> lookup <NL>          ) <NL>          lookup [ curr ] <SPC> -= <SPC> 1 <NL>          if <SPC> lookup [ curr ] <SPC> == <SPC> 0 : <NL>              del <SPC> lookup [ curr ] <NL>          return <SPC> result <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> lookup [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> return <SPC> pathSumHelper ( root , <SPC> 0 , <SPC> sum , <SPC> lookup ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> pathSum ( self , <SPC> root , <SPC> sum ) : <NL> <NL> <TAB> def <SPC> pathSumHelper ( root , <SPC> prev , <SPC> sum ) : <NL>          if <SPC> root <SPC> is <SPC> None : <NL>              return <SPC> 0 <NL> <NL>          curr <SPC> = <SPC> prev <SPC> + <SPC> root . val <NL>          return <SPC> ( <NL>              int ( curr <SPC> == <SPC> sum ) <NL>              + <SPC> pathSumHelper ( root . left , <SPC> curr , <SPC> sum ) <NL>              + <SPC> pathSumHelper ( root . right , <SPC> curr , <SPC> sum ) <NL>          ) <NL> <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <NL> <TAB> return <SPC> ( <NL>          pathSumHelper ( root , <SPC> 0 , <SPC> sum ) <NL>          + <SPC> self . pathSum ( root . left , <SPC> sum ) <NL>          + <SPC> self . pathSum ( root . right , <SPC> sum ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pathSum ( self , <SPC> nums ) : <NL> <NL> <TAB> class <SPC> Node ( object ) : <NL>          def <SPC> __init__ ( self , <SPC> num ) : <NL>              self . level <SPC> = <SPC> num <SPC> / <SPC> 100 <SPC> - <SPC> 1 <NL>              self . i <SPC> = <SPC> ( num <SPC> % <SPC> 100 ) <SPC> / <SPC> 10 <SPC> - <SPC> 1 <NL>              self . val <SPC> = <SPC> num <SPC> % <SPC> 10 <NL>              self . leaf <SPC> = <SPC> True <NL> <NL>          def <SPC> isParent ( self , <SPC> other ) : <NL>              return <SPC> self . level <SPC> == <SPC> other . level <SPC> - <SPC> 1 <SPC> and <SPC> self . i <SPC> == <SPC> other . i <SPC> / <SPC> 2 <NL> <NL> <TAB> if <SPC> not <SPC> nums : <NL>          return <SPC> 0 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> dummy <SPC> = <SPC> Node ( 10 ) <NL> <TAB> parent <SPC> = <SPC> dummy <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          child <SPC> = <SPC> Node ( num ) <NL>          while <SPC> not <SPC> parent . isParent ( child ) : <NL>              result <SPC> += <SPC> parent . val <SPC> if <SPC> parent . leaf <SPC> else <SPC> 0 <NL>              parent <SPC> = <SPC> q . popleft ( ) <NL>          parent . leaf <SPC> = <SPC> False <NL>          child . val <SPC> += <SPC> parent . val <NL>          q . append ( child ) <NL> <TAB> while <SPC> q : <NL>          result <SPC> += <SPC> q . pop ( ) . val <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> hasPathSum ( self , <SPC> root , <SPC> sum ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> False <NL> <NL> <TAB> if <SPC> root . left <SPC> is <SPC> None <SPC> and <SPC> root . right <SPC> is <SPC> None <SPC> and <SPC> root . val <SPC> == <SPC> sum : <NL>          return <SPC> True <NL> <NL> <TAB> return <SPC> self . hasPathSum ( root . left , <SPC> sum <SPC> - <SPC> root . val ) <SPC> or <SPC> self . hasPathSum ( <NL>          root . right , <SPC> sum <SPC> - <SPC> root . val <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getMaximumGold ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> backtracking ( grid , <SPC> i , <SPC> j ) : <NL>          result <SPC> = <SPC> 0 <NL>          grid [ i ] [ j ] <SPC> *= <SPC> - 1 <NL>          for <SPC> dx , <SPC> dy <SPC> in <SPC> directions : <NL>              ni , <SPC> nj <SPC> = <SPC> i <SPC> + <SPC> dx , <SPC> j <SPC> + <SPC> dy <NL>              if <SPC> not <SPC> ( <NL>                  0 <SPC> <= <SPC> ni <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> nj <SPC> < <SPC> len ( <NL>                      grid [ 0 ] ) <SPC> and <SPC> grid [ ni ] [ nj ] <SPC> > <SPC> 0 <NL>              ) : <NL>                  continue <NL>              result <SPC> = <SPC> max ( result , <SPC> backtracking ( grid , <SPC> ni , <SPC> nj ) ) <NL>          grid [ i ] [ j ] <SPC> *= <SPC> - 1 <NL>          return <SPC> grid [ i ] [ j ] <SPC> + <SPC> result <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> grid [ i ] [ j ] : <NL>                  result <SPC> = <SPC> max ( result , <SPC> backtracking ( grid , <SPC> i , <SPC> j ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumMinimumPath ( self , <SPC> A ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> check ( A , <SPC> val , <SPC> r , <SPC> c , <SPC> lookup ) : <NL>          if <SPC> r <SPC> == <SPC> len ( A ) <SPC> - <SPC> 1 <SPC> and <SPC> c <SPC> == <SPC> len ( A [ 0 ] ) <SPC> - <SPC> 1 : <NL>              return <SPC> True <NL>          lookup . add ( ( r , <SPC> c ) ) <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> d [ 0 ] , <SPC> c <SPC> + <SPC> d [ 1 ] <NL>              if <SPC> ( <NL>                  0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( A ) <NL>                  and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( A [ 0 ] ) <NL>                  and <SPC> ( nr , <SPC> nc ) <SPC> not <SPC> in <SPC> lookup <NL>                  and <SPC> A [ nr ] [ nc ] <SPC> >= <SPC> val <NL>                  and <SPC> check ( A , <SPC> val , <SPC> nr , <SPC> nc , <SPC> lookup ) <NL>              ) : <NL>                  return <SPC> True <NL>          return <SPC> False <NL> <NL> <TAB> vals , <SPC> ceil <SPC> = <SPC> [ ] , <SPC> min ( A [ 0 ] [ 0 ] , <SPC> A [ - 1 ] [ - 1 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( A [ 0 ] ) ) : <NL>              if <SPC> A [ i ] [ j ] <SPC> <= <SPC> ceil : <NL>                  vals . append ( A [ i ] [ j ] ) <NL> <TAB> vals <SPC> = <SPC> list ( set ( vals ) ) <NL> <TAB> vals . sort ( ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( vals ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( A , <SPC> vals [ mid ] , <SPC> 0 , <SPC> 0 , <SPC> set ( ) ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> vals [ right ] <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maximumMinimumPath ( self , <SPC> A ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> max_heap <SPC> = <SPC> [ ( - A [ 0 ] [ 0 ] , <SPC> 0 , <SPC> 0 ) ] <NL> <TAB> lookup <SPC> = <SPC> set ( [ ( 0 , <SPC> 0 ) ] ) <NL> <TAB> while <SPC> max_heap : <NL>          i , <SPC> r , <SPC> c <SPC> = <SPC> heapq . heappop ( max_heap ) <NL>          if <SPC> r <SPC> == <SPC> len ( A ) <SPC> - <SPC> 1 <SPC> and <SPC> c <SPC> == <SPC> len ( A [ 0 ] ) <SPC> - <SPC> 1 : <NL>              return <SPC> - i <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> d [ 0 ] , <SPC> c <SPC> + <SPC> d [ 1 ] <NL>              if <SPC> 0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( A ) <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( A [ 0 ] ) <SPC> and <SPC> ( nr , <SPC> nc ) <SPC> not <SPC> in <SPC> lookup : <NL>                  heapq . heappush ( max_heap , <SPC> ( - min ( - i , <SPC> A [ nr ] [ nc ] ) , <SPC> nr , <SPC> nc ) ) <NL>                  lookup . add ( ( nr , <SPC> nc ) ) <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProbability ( self , <SPC> n , <SPC> edges , <SPC> succProb , <SPC> start , <SPC> end ) : <NL> <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> ( u , <SPC> v ) , <SPC> p <SPC> in <SPC> itertools . izip ( edges , <SPC> succProb ) : <NL>          adj [ u ] . append ( ( v , <SPC> p ) ) <NL>          adj [ v ] . append ( ( u , <SPC> p ) ) <NL> <TAB> max_heap <SPC> = <SPC> [ ( - 1.0 , <SPC> start ) ] <NL> <TAB> result , <SPC> lookup <SPC> = <SPC> collections . defaultdict ( float ) , <SPC> set ( ) <NL> <TAB> result [ start ] <SPC> = <SPC> 1.0 <NL> <TAB> while <SPC> max_heap <SPC> and <SPC> len ( lookup ) <SPC> != <SPC> len ( adj ) : <NL>          curr , <SPC> u <SPC> = <SPC> heapq . heappop ( max_heap ) <NL>          if <SPC> u <SPC> in <SPC> lookup : <NL>              continue <NL>          lookup . add ( u ) <NL>          for <SPC> v , <SPC> w <SPC> in <SPC> adj [ u ] : <NL>              if <SPC> v <SPC> in <SPC> lookup : <NL>                  continue <NL>              if <SPC> v <SPC> in <SPC> result <SPC> and <SPC> result [ v ] <SPC> >= <SPC> - curr <SPC> * <SPC> w : <NL>                  continue <NL>              result [ v ] <SPC> = <SPC> - curr <SPC> * <SPC> w <NL>              heapq . heappush ( max_heap , <SPC> ( - result [ v ] , <SPC> v ) ) <NL> <TAB> return <SPC> result [ end ] <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumEffortPath ( self , <SPC> heights ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> dst <SPC> = <SPC> ( len ( heights ) <SPC> - <SPC> 1 , <SPC> len ( heights [ 0 ] ) <SPC> - <SPC> 1 ) <NL> <TAB> dist <SPC> = <SPC> [ [ float ( "inf" ) ] <SPC> * <SPC> len ( heights [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( heights ) ) ] <NL> <TAB> min_heap <SPC> = <SPC> [ ( 0 , <SPC> 0 , <SPC> 0 ) ] <NL> <TAB> lookup <SPC> = <SPC> [ [ False ] <SPC> * <SPC> len ( heights [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( heights ) ) ] <NL> <TAB> while <SPC> min_heap : <NL>          d , <SPC> r , <SPC> c <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> lookup [ r ] [ c ] : <NL>              continue <NL>          lookup [ r ] [ c ] <SPC> = <SPC> True <NL>          if <SPC> ( r , <SPC> c ) <SPC> == <SPC> dst : <NL>              return <SPC> d <NL>          for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>              nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr , <SPC> c <SPC> + <SPC> dc <NL>              if <SPC> not <SPC> ( <NL>                  0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( heights ) <NL>                  and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( heights [ 0 ] ) <NL>                  and <SPC> not <SPC> lookup [ nr ] [ nc ] <NL>              ) : <NL>                  continue <NL>              nd <SPC> = <SPC> max ( d , <SPC> abs ( heights [ nr ] [ nc ] <SPC> - <SPC> heights [ r ] [ c ] ) ) <NL>              if <SPC> nd <SPC> < <SPC> dist [ nr ] [ nc ] : <NL>                  dist [ nr ] [ nc ] <SPC> = <SPC> nd <NL>                  heapq . heappush ( min_heap , <SPC> ( nd , <SPC> nr , <SPC> nc ) ) <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . rank <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          stk . append ( x ) <NL>          x <SPC> = <SPC> self . set [ x ] <NL> <TAB> while <SPC> stk : <NL>          self . set [ stk . pop ( ) ] <SPC> = <SPC> x <NL> <TAB> return <SPC> x <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> if <SPC> self . rank [ x_root ] <SPC> < <SPC> self . rank [ y_root ] : <NL>          self . set [ x_root ] <SPC> = <SPC> y_root <NL> <TAB> elif <SPC> self . rank [ x_root ] <SPC> > <SPC> self . rank [ y_root ] : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL> <TAB> else : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL>          self . rank [ x_root ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minimumEffortPath ( self , <SPC> heights ) : <NL> <NL> <TAB> def <SPC> index ( n , <SPC> i , <SPC> j ) : <NL>          return <SPC> i <SPC> * <SPC> n <SPC> + <SPC> j <NL> <NL> <TAB> diffs <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( heights ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( heights [ 0 ] ) ) : <NL>              if <SPC> i <SPC> > <SPC> 0 : <NL>                  diffs . append ( <NL>                      ( <NL>                          abs ( heights [ i ] [ j ] <SPC> - <SPC> heights [ i <SPC> - <SPC> 1 ] [ j ] ) , <NL>                          index ( len ( heights [ 0 ] ) , <SPC> i <SPC> - <SPC> 1 , <SPC> j ) , <NL>                          index ( len ( heights [ 0 ] ) , <SPC> i , <SPC> j ) , <NL>                      ) <NL>                  ) <NL>              if <SPC> j <SPC> > <SPC> 0 : <NL>                  diffs . append ( <NL>                      ( <NL>                          abs ( heights [ i ] [ j ] <SPC> - <SPC> heights [ i ] [ j <SPC> - <SPC> 1 ] ) , <NL>                          index ( len ( heights [ 0 ] ) , <SPC> i , <SPC> j <SPC> - <SPC> 1 ) , <NL>                          index ( len ( heights [ 0 ] ) , <SPC> i , <SPC> j ) , <NL>                      ) <NL>                  ) <NL> <TAB> diffs . sort ( ) <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( heights ) <SPC> * <SPC> len ( heights [ 0 ] ) ) <NL> <TAB> for <SPC> d , <SPC> i , <SPC> j <SPC> in <SPC> diffs : <NL>          if <SPC> union_find . union_set ( i , <SPC> j ) : <NL>              if <SPC> union_find . find_set ( <NL>                  index ( len ( heights [ 0 ] ) , <SPC> 0 , <SPC> 0 ) <NL>              ) <SPC> == <SPC> union_find . find_set ( <NL>                  index ( len ( heights [ 0 ] ) , <SPC> len ( heights ) <SPC> - <SPC> 1 , <SPC> len ( heights [ 0 ] ) <SPC> - <SPC> 1 ) <NL>              ) : <NL>                  return <SPC> d <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> minimumEffortPath ( self , <SPC> heights ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> check ( heights , <SPC> x ) : <NL>          lookup <SPC> = <SPC> [ [ False ] <SPC> * <SPC> len ( heights [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( heights ) ) ] <NL>          left , <SPC> right <SPC> = <SPC> { ( 0 , <SPC> 0 ) } , <SPC> { ( len ( heights ) <SPC> - <SPC> 1 , <SPC> len ( heights [ 0 ] ) <SPC> - <SPC> 1 ) } <NL>          while <SPC> left : <NL>              for <SPC> r , <SPC> c <SPC> in <SPC> left : <NL>                  lookup [ r ] [ c ] <SPC> = <SPC> True <NL>              new_left <SPC> = <SPC> set ( ) <NL>              for <SPC> r , <SPC> c <SPC> in <SPC> left : <NL>                  if <SPC> ( r , <SPC> c ) <SPC> in <SPC> right : <NL>                      return <SPC> True <NL>                  for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                      nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr , <SPC> c <SPC> + <SPC> dc <NL>                      if <SPC> not <SPC> ( <NL>                          0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( heights ) <NL>                          and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( heights [ 0 ] ) <NL>                          and <SPC> abs ( heights [ nr ] [ nc ] <SPC> - <SPC> heights [ r ] [ c ] ) <SPC> <= <SPC> x <NL>                          and <SPC> not <SPC> lookup [ nr ] [ nc ] <NL>                      ) : <NL>                          continue <NL>                      new_left . add ( ( nr , <SPC> nc ) ) <NL>              left <SPC> = <SPC> new_left <NL>              if <SPC> len ( left ) <SPC> > <SPC> len ( right ) : <NL>                  left , <SPC> right <SPC> = <SPC> right , <SPC> left <NL>          return <SPC> False <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> 10 <SPC> ** <SPC> 6 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> check ( heights , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> minimumEffortPath ( self , <SPC> heights ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> check ( heights , <SPC> x ) : <NL>          lookup <SPC> = <SPC> [ [ False ] <SPC> * <SPC> len ( heights [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( heights ) ) ] <NL>          q <SPC> = <SPC> collections . deque ( [ ( 0 , <SPC> 0 ) ] ) <NL>          while <SPC> q : <NL>              r , <SPC> c <SPC> = <SPC> q . popleft ( ) <NL>              if <SPC> ( r , <SPC> c ) <SPC> == <SPC> ( len ( heights ) <SPC> - <SPC> 1 , <SPC> len ( heights [ 0 ] ) <SPC> - <SPC> 1 ) : <NL>                  return <SPC> True <NL>              for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                  nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr , <SPC> c <SPC> + <SPC> dc <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( heights ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( heights [ 0 ] ) <NL>                      and <SPC> abs ( heights [ nr ] [ nc ] <SPC> - <SPC> heights [ r ] [ c ] ) <SPC> <= <SPC> x <NL>                      and <SPC> not <SPC> lookup [ nr ] [ nc ] <NL>                  ) : <NL>                      continue <NL>                  lookup [ nr ] [ nc ] <SPC> = <SPC> True <NL>                  q . append ( ( nr , <SPC> nc ) ) <NL>          return <SPC> False <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> 10 <SPC> ** <SPC> 6 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> check ( heights , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution5 ( object ) : <NL> <TAB> def <SPC> minimumEffortPath ( self , <SPC> heights ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> check ( heights , <SPC> x ) : <NL>          lookup <SPC> = <SPC> [ [ False ] <SPC> * <SPC> len ( heights [ 0 ] ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( heights ) ) ] <NL>          stk <SPC> = <SPC> [ ( 0 , <SPC> 0 ) ] <NL>          while <SPC> stk : <NL>              r , <SPC> c <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> ( r , <SPC> c ) <SPC> == <SPC> ( len ( heights ) <SPC> - <SPC> 1 , <SPC> len ( heights [ 0 ] ) <SPC> - <SPC> 1 ) : <NL>                  return <SPC> True <NL>              for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                  nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr , <SPC> c <SPC> + <SPC> dc <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( heights ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( heights [ 0 ] ) <NL>                      and <SPC> abs ( heights [ nr ] [ nc ] <SPC> - <SPC> heights [ r ] [ c ] ) <SPC> <= <SPC> x <NL>                      and <SPC> not <SPC> lookup [ nr ] [ nc ] <NL>                  ) : <NL>                      continue <NL>                  lookup [ nr ] [ nc ] <SPC> = <SPC> True <NL>                  stk . append ( ( nr , <SPC> nc ) ) <NL>          return <SPC> False <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> 10 <SPC> ** <SPC> 6 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> check ( heights , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> peakIndexInMountainArray ( self , <SPC> arr ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( arr ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> arr [ mid ] <SPC> > <SPC> arr [ mid <SPC> + <SPC> 1 ] : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> PeekingIterator ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> iterator ) : <NL> <NL> <TAB> self . iterator <SPC> = <SPC> iterator <NL> <TAB> self . val_ <SPC> = <SPC> None <NL> <TAB> self . has_next_ <SPC> = <SPC> iterator . hasNext ( ) <NL> <TAB> self . has_peeked_ <SPC> = <SPC> False <NL> <NL> <TAB> def <SPC> peek ( self ) : <NL> <NL> <TAB> if <SPC> not <SPC> self . has_peeked_ : <NL>          self . has_peeked_ <SPC> = <SPC> True <NL>          self . val_ <SPC> = <SPC> self . iterator . next ( ) <NL> <TAB> return <SPC> self . val_ <NL> <NL> <TAB> def <SPC> next ( self ) : <NL> <NL> <TAB> self . val_ <SPC> = <SPC> self . peek ( ) <NL> <TAB> self . has_peeked_ <SPC> = <SPC> False <NL> <TAB> self . has_next_ <SPC> = <SPC> self . iterator . hasNext ( ) <NL> <TAB> return <SPC> self . val_ <NL> <NL> <TAB> def <SPC> hasNext ( self ) : <NL> <NL> <TAB> return <SPC> self . has_next_ <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> peopleIndexes ( self , <SPC> favoriteCompanies ) : <NL> <NL> <TAB> lookup , <SPC> comps <SPC> = <SPC> { } , <SPC> [ ] <NL> <TAB> for <SPC> cs <SPC> in <SPC> favoriteCompanies : <NL>          comps . append ( set ( ) ) <NL>          for <SPC> c <SPC> in <SPC> cs : <NL>              if <SPC> c <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup [ c ] <SPC> = <SPC> len ( lookup ) <NL>              comps [ - 1 ] . add ( lookup [ c ] ) <NL> <TAB> return <SPC> [ <NL>          i <NL>          for <SPC> i , <SPC> c1 <SPC> in <SPC> enumerate ( comps ) <NL>          if <SPC> not <SPC> any ( <NL>              i <SPC> != <SPC> j <SPC> and <SPC> len ( c1 ) <SPC> < <SPC> len ( c2 ) <SPC> and <SPC> c1 <SPC> < <SPC> c2 <SPC> for <SPC> j , <SPC> c2 <SPC> in <SPC> enumerate ( comps ) <NL>          ) <NL> <TAB> ] <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> data ) : <NL> <TAB> self . data <SPC> = <SPC> [ set ( d ) <SPC> for <SPC> d <SPC> in <SPC> data ] <NL> <TAB> self . set <SPC> = <SPC> range ( len ( data ) ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <NL> <TAB> if <SPC> ( <NL>          len ( self . data [ x_root ] ) <SPC> > <SPC> len ( self . data [ y_root ] ) <NL>          and <SPC> self . data [ x_root ] <SPC> > <SPC> self . data [ y_root ] <NL> <TAB> ) : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL> <TAB> elif <SPC> ( <NL>          len ( self . data [ x_root ] ) <SPC> < <SPC> len ( self . data [ y_root ] ) <NL>          and <SPC> self . data [ x_root ] <SPC> < <SPC> self . data [ y_root ] <NL> <TAB> ) : <NL>          self . set [ x_root ] <SPC> = <SPC> y_root <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> peopleIndexes ( self , <SPC> favoriteCompanies ) : <NL> <NL> <TAB> lookup , <SPC> comps <SPC> = <SPC> { } , <SPC> [ ] <NL> <TAB> for <SPC> cs <SPC> in <SPC> favoriteCompanies : <NL>          comps . append ( set ( ) ) <NL>          for <SPC> c <SPC> in <SPC> cs : <NL>              if <SPC> c <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup [ c ] <SPC> = <SPC> len ( lookup ) <NL>              comps [ - 1 ] . add ( lookup [ c ] ) <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( comps ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( comps ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( comps ) ) : <NL>              if <SPC> j <SPC> == <SPC> i : <NL>                  continue <NL>              union_find . union_set ( i , <SPC> j ) <NL> <TAB> return <SPC> [ x <SPC> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( union_find . set ) <SPC> if <SPC> x <SPC> == <SPC> i ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkPerfectNumber ( self , <SPC> num ) : <NL> <NL> <TAB> if <SPC> num <SPC> <= <SPC> 0 : <NL>          return <SPC> False <NL> <NL> <TAB> sqrt_num <SPC> = <SPC> int ( num <SPC> ** <SPC> 0.5 ) <NL> <TAB> total <SPC> = <SPC> sum ( i <SPC> + <SPC> num <SPC> // <SPC> i <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> sqrt_num <SPC> + <SPC> 1 ) <SPC> if <SPC> num <SPC> % <SPC> i <SPC> == <SPC> 0 ) <NL> <TAB> if <SPC> sqrt_num <SPC> ** <SPC> 2 <SPC> == <SPC> num : <NL>          total <SPC> -= <SPC> sqrt_num <NL> <TAB> return <SPC> total <SPC> - <SPC> num <SPC> == <SPC> num <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> defaultdict <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isRectangleCover ( self , <SPC> rectangles ) : <NL> <NL> <TAB> left <SPC> = <SPC> min ( rec [ 0 ] <SPC> for <SPC> rec <SPC> in <SPC> rectangles ) <NL> <TAB> bottom <SPC> = <SPC> min ( rec [ 1 ] <SPC> for <SPC> rec <SPC> in <SPC> rectangles ) <NL> <TAB> right <SPC> = <SPC> max ( rec [ 2 ] <SPC> for <SPC> rec <SPC> in <SPC> rectangles ) <NL> <TAB> top <SPC> = <SPC> max ( rec [ 3 ] <SPC> for <SPC> rec <SPC> in <SPC> rectangles ) <NL> <NL> <TAB> points <SPC> = <SPC> defaultdict ( int ) <NL> <TAB> for <SPC> l , <SPC> b , <SPC> r , <SPC> t <SPC> in <SPC> rectangles : <NL>          for <SPC> p , <SPC> q <SPC> in <SPC> zip ( ( ( l , <SPC> b ) , <SPC> ( r , <SPC> b ) , <SPC> ( l , <SPC> t ) , <SPC> ( r , <SPC> t ) ) , <SPC> ( 1 , <SPC> 2 , <SPC> 4 , <SPC> 8 ) ) : <NL>              if <SPC> points [ p ] <SPC> & <SPC> q : <NL>                  return <SPC> False <NL>              points [ p ] <SPC> |= <SPC> q <NL> <NL> <TAB> for <SPC> px , <SPC> py <SPC> in <SPC> points : <NL>          if <SPC> left <SPC> < <SPC> px <SPC> < <SPC> right <SPC> or <SPC> bottom <SPC> < <SPC> py <SPC> < <SPC> top : <NL>              if <SPC> points [ ( px , <SPC> py ) ] <SPC> not <SPC> in <SPC> ( 3 , <SPC> 5 , <SPC> 10 , <SPC> 12 , <SPC> 15 ) : <NL>                  return <SPC> False <NL> <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> _num <SPC> = <SPC> [ 0 ] <NL> <NL> <TAB> def <SPC> numSquares ( self , <SPC> n ) : <NL> <NL> <TAB> num <SPC> = <SPC> self . _num <NL> <TAB> while <SPC> len ( num ) <SPC> <= <SPC> n : <NL>          num <SPC> += <SPC> ( min ( num [ - i <SPC> * <SPC> i ] <NL>                  for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> int ( len ( num ) <SPC> ** <SPC> 0.5 <SPC> + <SPC> 1 ) ) ) <SPC> + <SPC> 1 , ) <NL> <TAB> return <SPC> num [ n ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> stringShift ( self , <SPC> s , <SPC> shift ) : <NL> <NL> <TAB> left_shifts <SPC> = <SPC> 0 <NL> <TAB> for <SPC> direction , <SPC> amount <SPC> in <SPC> shift : <NL>          if <SPC> not <SPC> direction : <NL>              left_shifts <SPC> += <SPC> amount <NL>          else : <NL>              left_shifts <SPC> -= <SPC> amount <NL> <TAB> left_shifts <SPC> %= <SPC> len ( s ) <NL> <TAB> return <SPC> s [ left_shifts : ] <SPC> + <SPC> s [ : left_shifts ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkInclusion ( self , <SPC> s1 , <SPC> s2 ) : <NL> <NL> <TAB> counts <SPC> = <SPC> collections . Counter ( s1 ) <NL> <TAB> l <SPC> = <SPC> len ( s1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s2 ) ) : <NL>          if <SPC> counts [ s2 [ i ] ] <SPC> > <SPC> 0 : <NL>              l <SPC> -= <SPC> 1 <NL>          counts [ s2 [ i ] ] <SPC> -= <SPC> 1 <NL>          if <SPC> l <SPC> == <SPC> 0 : <NL>              return <SPC> True <NL>          start <SPC> = <SPC> i <SPC> + <SPC> 1 <SPC> - <SPC> len ( s1 ) <NL>          if <SPC> start <SPC> >= <SPC> 0 : <NL>              counts [ s2 [ start ] ] <SPC> += <SPC> 1 <NL>              if <SPC> counts [ s2 [ start ] ] <SPC> > <SPC> 0 : <NL>                  l <SPC> += <SPC> 1 <NL> <TAB> return <SPC> False <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getPermutation ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> seq , <SPC> k , <SPC> fact <SPC> = <SPC> "" , <SPC> k <SPC> - <SPC> 1 , <SPC> math . factorial ( n <SPC> - <SPC> 1 ) <NL> <TAB> perm <SPC> = <SPC> [ i <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( n ) ) : <NL>          curr <SPC> = <SPC> perm [ k <SPC> / <SPC> fact ] <NL>          seq <SPC> += <SPC> str ( curr ) <NL>          perm . remove ( curr ) <NL>          if <SPC> i <SPC> > <SPC> 0 : <NL>              k <SPC> %= <SPC> fact <NL>              fact <SPC> /= <SPC> i <NL> <TAB> return <SPC> seq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> permuteUnique ( self , <SPC> nums ) : <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> used <SPC> = <SPC> [ False ] <SPC> * <SPC> len ( nums ) <NL> <TAB> self . permuteUniqueRecu ( result , <SPC> used , <SPC> [ ] , <SPC> nums ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> permuteUniqueRecu ( self , <SPC> result , <SPC> used , <SPC> cur , <SPC> nums ) : <NL> <TAB> if <SPC> len ( cur ) <SPC> == <SPC> len ( nums ) : <NL>          result . append ( cur <SPC> + <SPC> [ ] ) <NL>          return <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> used [ i ] <SPC> or <SPC> ( i <SPC> > <SPC> 0 <SPC> and <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> nums [ i ] <SPC> and <SPC> not <SPC> used [ i <SPC> - <SPC> 1 ] ) : <NL>              continue <NL>          used [ i ] <SPC> = <SPC> True <NL>          cur . append ( nums [ i ] ) <NL>          self . permuteUniqueRecu ( result , <SPC> used , <SPC> cur , <SPC> nums ) <NL>          cur . pop ( ) <NL>          used [ i ] <SPC> = <SPC> False <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> permuteUnique ( self , <SPC> nums ) : <NL> <TAB> solutions <SPC> = <SPC> [ [ ] ] <NL> <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          next <SPC> = <SPC> [ ] <NL>          for <SPC> solution <SPC> in <SPC> solutions : <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( solution ) <SPC> + <SPC> 1 ) : <NL>                  candidate <SPC> = <SPC> solution [ : i ] <SPC> + <SPC> [ num ] <SPC> + <SPC> solution [ i : ] <NL>                  if <SPC> candidate <SPC> not <SPC> in <SPC> next : <NL>                      next . append ( candidate ) <NL> <NL>          solutions <SPC> = <SPC> next <NL> <NL> <TAB> return <SPC> solutions <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> permute ( self , <SPC> num ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> used <SPC> = <SPC> [ False ] <SPC> * <SPC> len ( num ) <NL> <TAB> self . permuteRecu ( result , <SPC> used , <SPC> [ ] , <SPC> num ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> permuteRecu ( self , <SPC> result , <SPC> used , <SPC> cur , <SPC> num ) : <NL> <TAB> if <SPC> len ( cur ) <SPC> == <SPC> len ( num ) : <NL>          result . append ( cur [ : ] ) <NL>          return <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( num ) ) : <NL>          if <SPC> not <SPC> used [ i ] : <NL>              used [ i ] <SPC> = <SPC> True <NL>              cur . append ( num [ i ] ) <NL>              self . permuteRecu ( result , <SPC> used , <SPC> cur , <SPC> num ) <NL>              cur . pop ( ) <NL>              used [ i ] <SPC> = <SPC> False <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> permute ( self , <SPC> nums ) : <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> self . dfs ( nums , <SPC> [ ] , <SPC> res ) <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> dfs ( self , <SPC> nums , <SPC> path , <SPC> res ) : <NL> <TAB> if <SPC> not <SPC> nums : <NL>          res . append ( path ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL> <NL>          self . dfs ( nums [ : i ] <SPC> + <SPC> nums [ i <SPC> + <SPC> 1 : ] , <SPC> path <SPC> + <SPC> [ nums [ i ] ] , <SPC> res ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSizeSlices ( self , <SPC> slices ) : <NL> <NL> <TAB> def <SPC> maxSizeSlicesLinear ( slices , <SPC> start , <SPC> end ) : <NL>          dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( len ( slices ) <SPC> // <SPC> 3 <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> end ) : <NL>              for <SPC> j <SPC> in <SPC> reversed ( <NL>                  xrange ( 1 , <SPC> min ( ( ( i <SPC> - <SPC> start <SPC> + <SPC> 1 ) <SPC> - <SPC> 1 ) <SPC> // <NL>                         2 <SPC> + <SPC> 1 , <SPC> len ( slices ) <SPC> // <SPC> 3 ) <SPC> + <SPC> 1 ) <NL>              ) : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> max ( <NL>                      dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <SPC> dp [ ( i <SPC> - <SPC> 2 ) <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> slices [ i ] <NL>                  ) <NL>          return <SPC> dp [ ( end <SPC> - <SPC> 1 ) <SPC> % <SPC> 2 ] [ len ( slices ) <SPC> // <SPC> 3 ] <NL> <NL> <TAB> return <SPC> max ( <NL>          maxSizeSlicesLinear ( slices , <SPC> 0 , <SPC> len ( slices ) <SPC> - <SPC> 1 ) , <NL>          maxSizeSlicesLinear ( slices , <SPC> 1 , <SPC> len ( slices ) ) , <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxSizeSlices ( self , <SPC> slices ) : <NL> <NL> <TAB> def <SPC> maxSizeSlicesLinear ( slices , <SPC> start , <SPC> end ) : <NL>          dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> ( len ( slices ) <SPC> // <SPC> 3 <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 3 ) ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> end ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( <NL>                  1 , <SPC> min ( ( ( i <SPC> - <SPC> start <SPC> + <SPC> 1 ) <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 <SPC> + <SPC> 1 , <SPC> len ( slices ) <SPC> // <SPC> 3 ) <SPC> + <SPC> 1 <NL>              ) : <NL>                  dp [ i <SPC> % <SPC> 3 ] [ j ] <SPC> = <SPC> max ( <NL>                      dp [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 3 ] [ j ] , <SPC> dp [ ( i <SPC> - <SPC> 2 ) <SPC> % <SPC> 3 ] [ j <SPC> - <SPC> 1 ] <SPC> + <SPC> slices [ i ] <NL>                  ) <NL>          return <SPC> dp [ ( end <SPC> - <SPC> 1 ) <SPC> % <SPC> 3 ] [ len ( slices ) <SPC> // <SPC> 3 ] <NL> <NL> <TAB> return <SPC> max ( <NL>          maxSizeSlicesLinear ( slices , <SPC> 0 , <SPC> len ( slices ) <SPC> - <SPC> 1 ) , <NL>          maxSizeSlicesLinear ( slices , <SPC> 1 , <SPC> len ( slices ) ) , <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minCostToMoveChips ( self , <SPC> chips ) : <NL> <NL> <TAB> count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 <NL> <TAB> for <SPC> p <SPC> in <SPC> chips : <NL>          count [ p <SPC> % <SPC> 2 ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> min ( count ) <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> plusOne ( self , <SPC> head ) : <NL> <NL> <TAB> if <SPC> not <SPC> head : <NL>          return <SPC> None <NL> <NL> <TAB> dummy <SPC> = <SPC> ListNode ( 0 ) <NL> <TAB> dummy . next <SPC> = <SPC> head <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> dummy , <SPC> head <NL> <TAB> while <SPC> right . next : <NL>          if <SPC> right . val <SPC> != <SPC> 9 : <NL>              left <SPC> = <SPC> right <NL>          right <SPC> = <SPC> right . next <NL> <NL> <TAB> if <SPC> right . val <SPC> != <SPC> 9 : <NL>          right . val <SPC> += <SPC> 1 <NL> <TAB> else : <NL>          left . val <SPC> += <SPC> 1 <NL>          right <SPC> = <SPC> left . next <NL>          while <SPC> right : <NL>              right . val <SPC> = <SPC> 0 <NL>              right <SPC> = <SPC> right . next <NL> <NL> <TAB> return <SPC> dummy <SPC> if <SPC> dummy . val <SPC> else <SPC> dummy . next <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> plusOne ( self , <SPC> head ) : <NL> <NL> <TAB> def <SPC> reverseList ( head ) : <NL>          dummy <SPC> = <SPC> ListNode ( 0 ) <NL>          curr <SPC> = <SPC> head <NL>          while <SPC> curr : <NL>              dummy . next , <SPC> curr . next , <SPC> curr <SPC> = <SPC> curr , <SPC> dummy . next , <SPC> curr . next <NL>          return <SPC> dummy . next <NL> <NL> <TAB> rev_head <SPC> = <SPC> reverseList ( head ) <NL> <TAB> curr , <SPC> carry <SPC> = <SPC> rev_head , <SPC> 1 <NL> <TAB> while <SPC> curr <SPC> and <SPC> carry : <NL>          curr . val <SPC> += <SPC> carry <NL>          carry <SPC> = <SPC> curr . val <SPC> / <SPC> 10 <NL>          curr . val <SPC> %= <SPC> 10 <NL>          if <SPC> carry <SPC> and <SPC> curr . next <SPC> is <SPC> None : <NL>              curr . next <SPC> = <SPC> ListNode ( 0 ) <NL>          curr <SPC> = <SPC> curr . next <NL> <NL> <TAB> return <SPC> reverseList ( rev_head ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> plusOne ( self , <SPC> digits ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( digits ) ) ) : <NL>          if <SPC> digits [ i ] <SPC> == <SPC> 9 : <NL>              digits [ i ] <SPC> = <SPC> 0 <NL>          else : <NL>              digits [ i ] <SPC> += <SPC> 1 <NL>              return <SPC> digits <NL> <TAB> digits [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> digits . append ( 0 ) <NL> <TAB> return <SPC> digits <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> plusOne ( self , <SPC> digits ) : <NL> <NL> <TAB> result <SPC> = <SPC> digits [ : : - 1 ] <NL> <TAB> carry <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( result ) ) : <NL>          result [ i ] <SPC> += <SPC> carry <NL>          carry , <SPC> result [ i ] <SPC> = <SPC> divmod ( result [ i ] , <SPC> 10 ) <NL> <TAB> if <SPC> carry : <NL>          result . append ( carry ) <NL> <TAB> return <SPC> result [ : : - 1 ] <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> poorPigs ( self , <SPC> buckets , <SPC> minutesToDie , <SPC> minutesToTest ) : <NL> <NL> <TAB> return <SPC> int ( <NL>          math . ceil ( math . log ( buckets ) <SPC> / <NL>                    math . log ( minutesToTest <SPC> / <SPC> minutesToDie <SPC> + <SPC> 1 ) ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None , <SPC> next = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <TAB> self . next <SPC> = <SPC> next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> connect ( self , <SPC> root ) : <NL> <TAB> head <SPC> = <SPC> root <NL> <TAB> pre <SPC> = <SPC> Node ( 0 ) <NL> <TAB> cur <SPC> = <SPC> pre <NL> <TAB> while <SPC> root : <NL>          while <SPC> root : <NL>              if <SPC> root . left : <NL>                  cur . next <SPC> = <SPC> root . left <NL>                  cur <SPC> = <SPC> cur . next <NL>              if <SPC> root . right : <NL>                  cur . next <SPC> = <SPC> root . right <NL>                  cur <SPC> = <SPC> cur . next <NL>              root <SPC> = <SPC> root . next <NL>          root , <SPC> cur <SPC> = <SPC> pre . next , <SPC> pre <NL>          cur . next <SPC> = <SPC> None <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self <SPC> is <SPC> None : <NL>          return <SPC> "Nil" <NL> <TAB> else : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> repr ( self . next ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> connect ( self , <SPC> root ) : <NL> <TAB> head <SPC> = <SPC> root <NL> <TAB> while <SPC> head : <NL>          cur <SPC> = <SPC> head <NL>          while <SPC> cur <SPC> and <SPC> cur . left : <NL>              cur . left . next <SPC> = <SPC> cur . right <NL>              if <SPC> cur . next : <NL>                  cur . right . next <SPC> = <SPC> cur . next . left <NL>              cur <SPC> = <SPC> cur . next <NL>          head <SPC> = <SPC> head . left <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> connect ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <NL> <TAB> if <SPC> root . left : <NL>          root . left . next <SPC> = <SPC> root . right <NL> <TAB> if <SPC> root . right <SPC> and <SPC> root . next : <NL>          root . right . next <SPC> = <SPC> root . next . left <NL> <TAB> self . connect ( root . left ) <NL> <TAB> self . connect ( root . right ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> largeGroupPositions ( self , <SPC> S ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( S ) ) : <NL>          if <SPC> j <SPC> == <SPC> len ( S ) <SPC> - <SPC> 1 <SPC> or <SPC> S [ j ] <SPC> != <SPC> S [ j <SPC> + <SPC> 1 ] : <NL>              if <SPC> j <SPC> - <SPC> i <SPC> + <SPC> 1 <SPC> >= <SPC> 3 : <NL>                  result . append ( [ i , <SPC> j ] ) <NL>              i <SPC> = <SPC> j <SPC> + <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> possibleBipartition ( self , <SPC> N , <SPC> dislikes ) : <NL> <NL> <TAB> adj <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( N ) ] <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> dislikes : <NL>          adj [ u <SPC> - <SPC> 1 ] . append ( v <SPC> - <SPC> 1 ) <NL>          adj [ v <SPC> - <SPC> 1 ] . append ( u <SPC> - <SPC> 1 ) <NL> <NL> <TAB> color <SPC> = <SPC> [ 0 ] <SPC> * <SPC> N <NL> <TAB> color [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ 0 ] ) <NL> <TAB> while <SPC> q : <NL>          cur <SPC> = <SPC> q . popleft ( ) <NL>          for <SPC> nei <SPC> in <SPC> adj [ cur ] : <NL>              if <SPC> color [ nei ] <SPC> == <SPC> color [ cur ] : <NL>                  return <SPC> False <NL>              elif <SPC> color [ nei ] <SPC> == <SPC> - color [ cur ] : <NL>                  continue <NL>              color [ nei ] <SPC> = <SPC> - color [ cur ] <NL>              q . append ( nei ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pourWater ( self , <SPC> heights , <SPC> V , <SPC> K ) : <NL> <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( V ) : <NL>          best <SPC> = <SPC> K <NL>          for <SPC> d <SPC> in <SPC> ( - 1 , <SPC> 1 ) : <NL>              i <SPC> = <SPC> K <NL>              while <SPC> 0 <SPC> <= <SPC> i <SPC> + <SPC> d <SPC> < <SPC> len ( heights ) <SPC> and <SPC> heights [ i <SPC> + <SPC> d ] <SPC> <= <SPC> heights [ i ] : <NL>                  if <SPC> heights [ i <SPC> + <SPC> d ] <SPC> < <SPC> heights [ i ] : <NL>                      best <SPC> = <SPC> i <SPC> + <SPC> d <NL>                  i <SPC> += <SPC> d <NL>              if <SPC> best <SPC> != <SPC> K : <NL>                  break <NL>          heights [ best ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> heights <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPowerOfFour ( self , <SPC> num ) : <NL> <NL> <TAB> return <SPC> ( <NL>          num <SPC> > <SPC> 0 <NL>          and <SPC> ( num <SPC> & <SPC> ( num <SPC> - <SPC> 1 ) ) <SPC> == <SPC> 0 <NL>          and <SPC> ( ( num <SPC> & <SPC> 0b01010101010101010101010101010101 ) <SPC> == <SPC> num ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isPowerOfFour ( self , <SPC> num ) : <NL> <NL> <TAB> while <SPC> num <SPC> and <SPC> not <SPC> ( num <SPC> & <SPC> 0b11 ) : <NL>          num <SPC> >>= <SPC> 2 <NL> <TAB> return <SPC> num <SPC> == <SPC> 1 <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> isPowerOfFour ( self , <SPC> num ) : <NL> <NL> <TAB> num <SPC> = <SPC> bin ( num ) <NL> <TAB> return <SPC> ( <NL>          True <NL>          if <SPC> num [ 2 : ] . startswith ( "1" ) <NL>          and <SPC> len ( num [ 2 : ] ) <SPC> == <SPC> num . count ( "0" ) <NL>          and <SPC> num . count ( "0" ) <SPC> % <SPC> 2 <NL>          and <SPC> "-" <SPC> not <SPC> in <SPC> num <NL>          else <SPC> False <NL> <TAB> ) <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __max_log3 <SPC> = <SPC> int ( math . log ( 0x7FFFFFFF ) <SPC> / <SPC> math . log ( 3 ) ) <NL> <TAB> self . __max_pow3 <SPC> = <SPC> 3 <SPC> ** <SPC> self . __max_log3 <NL> <NL> <TAB> def <SPC> isPowerOfThree ( self , <SPC> n ) : <NL> <NL> <TAB> return <SPC> n <SPC> > <SPC> 0 <SPC> and <SPC> self . __max_pow3 <SPC> % <SPC> n <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isPowerOfThree ( self , <SPC> n ) : <NL> <TAB> return <SPC> n <SPC> > <SPC> 0 <SPC> and <SPC> ( math . log10 ( n ) <SPC> / <SPC> math . log10 ( 3 ) ) . is_integer ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isPowerOfTwo ( self , <SPC> n ) : <NL> <TAB> return <SPC> n <SPC> > <SPC> 0 <SPC> and <SPC> ( n <SPC> & <SPC> ( n <SPC> - <SPC> 1 ) ) <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> isPowerOfTwo ( self , <SPC> n ) : <NL> <TAB> return <SPC> n <SPC> > <SPC> 0 <SPC> and <SPC> ( n <SPC> & <SPC> ~ - n ) <SPC> == <SPC> 0 <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> powerfulIntegers ( self , <SPC> x , <SPC> y , <SPC> bound ) : <NL> <NL> <TAB> result <SPC> = <SPC> set ( ) <NL> <TAB> log_x <SPC> = <SPC> int ( math . floor ( math . log ( bound ) <SPC> / <SPC> math . log ( x ) ) ) <SPC> + <SPC> 1 <SPC> if <SPC> x <SPC> != <SPC> 1 <SPC> else <SPC> 1 <NL> <TAB> log_y <SPC> = <SPC> int ( math . floor ( math . log ( bound ) <SPC> / <SPC> math . log ( y ) ) ) <SPC> + <SPC> 1 <SPC> if <SPC> y <SPC> != <SPC> 1 <SPC> else <SPC> 1 <NL> <TAB> pow_x <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( log_x ) : <NL>          pow_y <SPC> = <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> xrange ( log_y ) : <NL>              val <SPC> = <SPC> pow_x <SPC> + <SPC> pow_y <NL>              if <SPC> val <SPC> <= <SPC> bound : <NL>                  result . add ( val ) <NL>              pow_y <SPC> *= <SPC> y <NL>          pow_x <SPC> *= <SPC> x <NL> <TAB> return <SPC> list ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> myPow ( self , <SPC> x , <SPC> n ) : <NL> <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> abs_n <SPC> = <SPC> abs ( n ) <NL> <TAB> while <SPC> abs_n : <NL>          if <SPC> abs_n <SPC> & <SPC> 1 : <NL>              result <SPC> *= <SPC> x <NL>          abs_n <SPC> >>= <SPC> 1 <NL>          x <SPC> *= <SPC> x <NL> <NL> <TAB> return <SPC> 1 <SPC> / <SPC> result <SPC> if <SPC> n <SPC> < <SPC> 0 <SPC> else <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> myPow ( self , <SPC> x , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> < <SPC> 0 <SPC> and <SPC> n <SPC> != <SPC> - n : <NL>          return <SPC> 1.0 <SPC> / <SPC> self . myPow ( x , <SPC> - n ) <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 : <NL>          return <SPC> 1 <NL> <TAB> v <SPC> = <SPC> self . myPow ( x , <SPC> n <SPC> / <SPC> 2 ) <NL> <TAB> if <SPC> n <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>          return <SPC> v <SPC> * <SPC> v <NL> <TAB> else : <NL>          return <SPC> v <SPC> * <SPC> v <SPC> * <SPC> x <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> PredictTheWinner ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> len ( nums ) <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> or <SPC> len ( nums ) <SPC> == <SPC> 1 : <NL>          return <SPC> True <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( nums ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( nums ) ) ) : <NL>          dp [ i ] <SPC> = <SPC> nums [ i ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( nums ) ) : <NL>              dp [ j ] <SPC> = <SPC> max ( nums [ i ] <SPC> - <SPC> dp [ j ] , <SPC> nums [ j ] <SPC> - <SPC> dp [ j <SPC> - <SPC> 1 ] ) <NL> <NL> <TAB> return <SPC> dp [ - 1 ] <SPC> >= <SPC> 0 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> WordFilter ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> words ) : <NL> <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> self . __trie <SPC> = <SPC> _trie ( ) <NL> <NL> <TAB> for <SPC> weight , <SPC> word <SPC> in <SPC> enumerate ( words ) : <NL>          word <SPC> += <SPC> "#" <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( word ) ) : <NL>              cur <SPC> = <SPC> self . __trie <NL>              cur [ "_weight" ] <SPC> = <SPC> weight <NL>              for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> 2 <SPC> * <SPC> len ( word ) <SPC> - <SPC> 1 ) : <NL>                  cur <SPC> = <SPC> cur [ word [ j <SPC> % <SPC> len ( word ) ] ] <NL>                  cur [ "_weight" ] <SPC> = <SPC> weight <NL> <NL> <TAB> def <SPC> f ( self , <SPC> prefix , <SPC> suffix ) : <NL> <NL> <TAB> cur <SPC> = <SPC> self . __trie <NL> <TAB> for <SPC> letter <SPC> in <SPC> suffix <SPC> + <SPC> "#" <SPC> + <SPC> prefix : <NL>          if <SPC> letter <SPC> not <SPC> in <SPC> cur : <NL>              return <SPC> - 1 <NL>          cur <SPC> = <SPC> cur [ letter ] <NL> <TAB> return <SPC> cur [ "_weight" ] <NL> <NL> <NL> class <SPC> Trie ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> self . __trie <SPC> = <SPC> _trie ( ) <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> word , <SPC> i ) : <NL> <NL> <TAB> def <SPC> add_word ( cur , <SPC> i ) : <NL>          if <SPC> "_words" <SPC> not <SPC> in <SPC> cur : <NL>              cur [ "_words" ] <SPC> = <SPC> [ ] <NL>          cur [ "_words" ] . append ( i ) <NL> <NL> <TAB> cur <SPC> = <SPC> self . __trie <NL> <TAB> add_word ( cur , <SPC> i ) <NL> <TAB> for <SPC> c <SPC> in <SPC> word : <NL>          cur <SPC> = <SPC> cur [ c ] <NL>          add_word ( cur , <SPC> i ) <NL> <NL> <TAB> def <SPC> find ( self , <SPC> word ) : <NL> <TAB> cur <SPC> = <SPC> self . __trie <NL> <TAB> for <SPC> c <SPC> in <SPC> word : <NL>          if <SPC> c <SPC> not <SPC> in <SPC> cur : <NL>              return <SPC> [ ] <NL>          cur <SPC> = <SPC> cur [ c ] <NL> <TAB> return <SPC> cur [ "_words" ] <NL> <NL> <NL> class <SPC> WordFilter2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> words ) : <NL> <NL> <TAB> self . __prefix_trie <SPC> = <SPC> Trie ( ) <NL> <TAB> self . __suffix_trie <SPC> = <SPC> Trie ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( words ) ) ) : <NL>          self . __prefix_trie . insert ( words [ i ] , <SPC> i ) <NL>          self . __suffix_trie . insert ( words [ i ] [ : : - 1 ] , <SPC> i ) <NL> <NL> <TAB> def <SPC> f ( self , <SPC> prefix , <SPC> suffix ) : <NL> <NL> <TAB> prefix_match <SPC> = <SPC> self . __prefix_trie . find ( prefix ) <NL> <TAB> suffix_match <SPC> = <SPC> self . __suffix_trie . find ( suffix [ : : - 1 ] ) <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> != <SPC> len ( prefix_match ) <SPC> and <SPC> j <SPC> != <SPC> len ( suffix_match ) : <NL>          if <SPC> prefix_match [ i ] <SPC> == <SPC> suffix_match [ j ] : <NL>              return <SPC> prefix_match [ i ] <NL>          elif <SPC> prefix_match [ i ] <SPC> > <SPC> suffix_match [ j ] : <NL>              i <SPC> += <SPC> 1 <NL>          else : <NL>              j <SPC> += <SPC> 1 <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> preimageSizeFZF ( self , <SPC> K ) : <NL> <NL> <TAB> def <SPC> count_of_factorial_primes ( n , <SPC> p ) : <NL>          cnt <SPC> = <SPC> 0 <NL>          while <SPC> n <SPC> > <SPC> 0 : <NL>              cnt <SPC> += <SPC> n <SPC> // <SPC> p <NL>              n <SPC> //= <SPC> p <NL>          return <SPC> cnt <NL> <NL> <TAB> p <SPC> = <SPC> 5 <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> p <SPC> * <SPC> K <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> count_of_factorial_primes ( mid , <SPC> p ) <SPC> >= <SPC> K : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> p <SPC> if <SPC> count_of_factorial_primes ( left , <SPC> p ) <SPC> == <SPC> K <SPC> else <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> prevPermOpt1 ( self , <SPC> A ) : <NL> <NL> <TAB> for <SPC> left <SPC> in <SPC> reversed ( xrange ( len ( A ) <SPC> - <SPC> 1 ) ) : <NL>          if <SPC> A [ left ] <SPC> > <SPC> A [ left <SPC> + <SPC> 1 ] : <NL>              break <NL> <TAB> else : <NL>          return <SPC> A <NL> <TAB> right <SPC> = <SPC> len ( A ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> A [ left ] <SPC> <= <SPC> A [ right ] : <NL>          right <SPC> -= <SPC> 1 <NL> <TAB> while <SPC> A [ right <SPC> - <SPC> 1 ] <SPC> == <SPC> A [ right ] : <NL>          right <SPC> -= <SPC> 1 <NL> <TAB> A [ left ] , <SPC> A [ right ] <SPC> = <SPC> A [ right ] , <SPC> A [ left ] <NL> <TAB> return <SPC> A <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numPrimeArrangements ( self , <SPC> n ) : <NL> <NL> <TAB> def <SPC> count_primes ( n ) : <NL>          if <SPC> n <SPC> <= <SPC> 1 : <NL>              return <SPC> 0 <NL>          is_prime <SPC> = <SPC> [ True ] <SPC> * <SPC> ( ( n <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 ) <NL>          cnt <SPC> = <SPC> len ( is_prime ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( 3 , <SPC> n <SPC> + <SPC> 1 , <SPC> 2 ) : <NL>              if <SPC> i <SPC> * <SPC> i <SPC> > <SPC> n : <NL>                  break <NL>              if <SPC> not <SPC> is_prime [ i <SPC> // <SPC> 2 ] : <NL>                  continue <NL>              for <SPC> j <SPC> in <SPC> xrange ( i <SPC> * <SPC> i , <SPC> n <SPC> + <SPC> 1 , <SPC> 2 <SPC> * <SPC> i ) : <NL>                  if <SPC> not <SPC> is_prime [ j <SPC> // <SPC> 2 ] : <NL>                      continue <NL>                  cnt <SPC> -= <SPC> 1 <NL>                  is_prime [ j <SPC> // <SPC> 2 ] <SPC> = <SPC> False <NL>          return <SPC> cnt <NL> <NL> <TAB> def <SPC> factorial ( n ) : <NL>          result <SPC> = <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> n <SPC> + <SPC> 1 ) : <NL>              result <SPC> = <SPC> ( result <SPC> * <SPC> i ) <SPC> % <SPC> MOD <NL>          return <SPC> result <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> cnt <SPC> = <SPC> count_primes ( n ) <NL> <TAB> return <SPC> factorial ( cnt ) <SPC> * <SPC> factorial ( n <SPC> - <SPC> cnt ) <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countPrimeSetBits ( self , <SPC> L , <SPC> R ) : <NL> <NL> <TAB> def <SPC> bitCount ( n ) : <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> n : <NL>              n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL>              result <SPC> += <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> primes <SPC> = <SPC> { 2 , <SPC> 3 , <SPC> 5 , <SPC> 7 , <SPC> 11 , <SPC> 13 , <SPC> 17 , <SPC> 19 } <NL> <TAB> return <SPC> sum ( bitCount ( i ) <SPC> in <SPC> primes <SPC> for <SPC> i <SPC> in <SPC> xrange ( L , <SPC> R <SPC> + <SPC> 1 ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> primePalindrome ( self , <SPC> N ) : <NL> <NL> <TAB> def <SPC> is_prime ( n ) : <NL>          if <SPC> n <SPC> < <SPC> 2 <SPC> or <SPC> n <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              return <SPC> n <SPC> == <SPC> 2 <NL>          return <SPC> all ( n <SPC> % <SPC> d <SPC> for <SPC> d <SPC> in <SPC> xrange ( 3 , <SPC> int ( n <SPC> ** <SPC> 0.5 ) <SPC> + <SPC> 1 , <SPC> 2 ) ) <NL> <NL> <TAB> if <SPC> 8 <SPC> <= <SPC> N <SPC> <= <SPC> 11 : <NL>          return <SPC> 11 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 10 <SPC> ** <SPC> ( len ( str ( N ) ) <SPC> // <SPC> 2 ) , <SPC> 10 <SPC> ** <SPC> 5 ) : <NL>          j <SPC> = <SPC> int ( str ( i ) <SPC> + <SPC> str ( i ) [ - 2 : : - 1 ] ) <NL>          if <SPC> j <SPC> >= <SPC> N <SPC> and <SPC> is_prime ( j ) : <NL>              return <SPC> j <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> printTree ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> getWidth ( root ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 <NL>          return <SPC> 2 <SPC> * <SPC> max ( getWidth ( root . left ) , <SPC> getWidth ( root . right ) ) <SPC> + <SPC> 1 <NL> <NL> <TAB> def <SPC> getHeight ( root ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 <NL>          return <SPC> max ( getHeight ( root . left ) , <SPC> getHeight ( root . right ) ) <SPC> + <SPC> 1 <NL> <NL> <TAB> def <SPC> preorderTraversal ( root , <SPC> level , <SPC> left , <SPC> right , <SPC> result ) : <NL>          if <SPC> not <SPC> root : <NL>              return <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          result [ level ] [ mid ] <SPC> = <SPC> str ( root . val ) <NL>          preorderTraversal ( root . left , <SPC> level <SPC> + <SPC> 1 , <SPC> left , <SPC> mid <SPC> - <SPC> 1 , <SPC> result ) <NL>          preorderTraversal ( root . right , <SPC> level <SPC> + <SPC> 1 , <SPC> mid <SPC> + <SPC> 1 , <SPC> right , <SPC> result ) <NL> <NL> <TAB> h , <SPC> w <SPC> = <SPC> getHeight ( root ) , <SPC> getWidth ( root ) <NL> <TAB> result <SPC> = <SPC> [ [ "" ] <SPC> * <SPC> w <SPC> for <SPC> _ <SPC> in <SPC> xrange ( h ) ] <NL> <TAB> preorderTraversal ( root , <SPC> 0 , <SPC> 0 , <SPC> w <SPC> - <SPC> 1 , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> threading <NL> <NL> <NL> class <SPC> FooBar ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . __n <SPC> = <SPC> n <NL> <TAB> self . __curr <SPC> = <SPC> False <NL> <TAB> self . __cv <SPC> = <SPC> threading . Condition ( ) <NL> <NL> <TAB> def <SPC> foo ( self , <SPC> printFoo ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . __n ) : <NL>          with <SPC> self . __cv : <NL>              while <SPC> self . __curr <SPC> != <SPC> False : <NL>                  self . __cv . wait ( ) <NL>              self . __curr <SPC> = <SPC> not <SPC> self . __curr <NL> <NL>              printFoo ( ) <NL>              self . __cv . notify ( ) <NL> <NL> <TAB> def <SPC> bar ( self , <SPC> printBar ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . __n ) : <NL>          with <SPC> self . __cv : <NL>              while <SPC> self . __curr <SPC> != <SPC> True : <NL>                  self . __cv . wait ( ) <NL>              self . __curr <SPC> = <SPC> not <SPC> self . __curr <NL> <NL>              printBar ( ) <NL>              self . __cv . notify ( ) <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> printLinkedListInReverse ( self , <SPC> head ) : <NL> <NL> <TAB> def <SPC> print_nodes ( head , <SPC> count ) : <NL>          nodes <SPC> = <SPC> [ ] <NL>          while <SPC> head <SPC> and <SPC> len ( nodes ) <SPC> != <SPC> count : <NL>              nodes . append ( head ) <NL>              head <SPC> = <SPC> head . getNext ( ) <NL>          for <SPC> node <SPC> in <SPC> reversed ( nodes ) : <NL>              node . printValue ( ) <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> curr <SPC> = <SPC> head <NL> <TAB> while <SPC> curr : <NL>          curr <SPC> = <SPC> curr . getNext ( ) <NL>          count <SPC> += <SPC> 1 <NL> <TAB> bucket_count <SPC> = <SPC> int ( math . ceil ( count <SPC> ** <SPC> 0.5 ) ) <NL> <NL> <TAB> buckets <SPC> = <SPC> [ ] <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> curr <SPC> = <SPC> head <NL> <TAB> while <SPC> curr : <NL>          if <SPC> count <SPC> % <SPC> bucket_count <SPC> == <SPC> 0 : <NL>              buckets . append ( curr ) <NL>          curr <SPC> = <SPC> curr . getNext ( ) <NL>          count <SPC> += <SPC> 1 <NL> <TAB> for <SPC> node <SPC> in <SPC> reversed ( buckets ) : <NL>          print_nodes ( node , <SPC> bucket_count ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> printLinkedListInReverse ( self , <SPC> head ) : <NL> <NL> <TAB> nodes <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> head : <NL>          nodes . append ( head ) <NL>          head <SPC> = <SPC> head . getNext ( ) <NL> <TAB> for <SPC> node <SPC> in <SPC> reversed ( nodes ) : <NL>          node . printValue ( ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> printLinkedListInReverse ( self , <SPC> head ) : <NL> <NL> <TAB> tail <SPC> = <SPC> None <NL> <TAB> while <SPC> head <SPC> != <SPC> tail : <NL>          curr <SPC> = <SPC> head <NL>          while <SPC> curr . getNext ( ) <SPC> != <SPC> tail : <NL>              curr <SPC> = <SPC> curr . getNext ( ) <NL>          curr . printValue ( ) <NL>          tail <SPC> = <SPC> curr <NL> <NL> <NL> import <SPC> threading <NL> <NL> <NL> class <SPC> Foo ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __cv <SPC> = <SPC> threading . Condition ( ) <NL> <TAB> self . __has_first <SPC> = <SPC> False <NL> <TAB> self . __has_second <SPC> = <SPC> False <NL> <NL> <TAB> def <SPC> first ( self , <SPC> printFirst ) : <NL> <NL> <TAB> with <SPC> self . __cv : <NL> <NL>          printFirst ( ) <NL>          self . __has_first <SPC> = <SPC> True <NL>          self . __cv . notifyAll ( ) <NL> <NL> <TAB> def <SPC> second ( self , <SPC> printSecond ) : <NL> <NL> <TAB> with <SPC> self . __cv : <NL>          while <SPC> not <SPC> self . __has_first : <NL>              self . __cv . wait ( ) <NL> <NL>          printSecond ( ) <NL>          self . __has_second <SPC> = <SPC> True <NL>          self . __cv . notifyAll ( ) <NL> <NL> <TAB> def <SPC> third ( self , <SPC> printThird ) : <NL> <NL> <TAB> with <SPC> self . __cv : <NL>          while <SPC> not <SPC> self . __has_second : <NL>              self . __cv . wait ( ) <NL> <NL>          printThird ( ) <NL>          self . __cv . notifyAll ( ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> printVertically ( self , <SPC> s ) : <NL> <NL> <TAB> return <SPC> [ <NL>          "" . join ( c ) . rstrip ( ) <NL>          for <SPC> c <SPC> in <SPC> itertools . izip_longest ( * s . split ( ) , <SPC> fillvalue = " " ) <NL> <TAB> ] <NL> <NL> <NL> import <SPC> threading <NL> <NL> <NL> class <SPC> ZeroEvenOdd ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . __n <SPC> = <SPC> n <NL> <TAB> self . __curr <SPC> = <SPC> 0 <NL> <TAB> self . __cv <SPC> = <SPC> threading . Condition ( ) <NL> <NL> <TAB> def <SPC> zero ( self , <SPC> printNumber ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . __n ) : <NL>          with <SPC> self . __cv : <NL>              while <SPC> self . __curr <SPC> % <SPC> 2 <SPC> != <SPC> 0 : <NL>                  self . __cv . wait ( ) <NL>              self . __curr <SPC> += <SPC> 1 <NL>              printNumber ( 0 ) <NL>              self . __cv . notifyAll ( ) <NL> <NL> <TAB> def <SPC> even ( self , <SPC> printNumber ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> self . __n <SPC> + <SPC> 1 , <SPC> 2 ) : <NL>          with <SPC> self . __cv : <NL>              while <SPC> self . __curr <SPC> % <SPC> 4 <SPC> != <SPC> 3 : <NL>                  self . __cv . wait ( ) <NL>              self . __curr <SPC> += <SPC> 1 <NL>              printNumber ( i ) <NL>              self . __cv . notifyAll ( ) <NL> <NL> <TAB> def <SPC> odd ( self , <SPC> printNumber ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> self . __n <SPC> + <SPC> 1 , <SPC> 2 ) : <NL>          with <SPC> self . __cv : <NL>              while <SPC> self . __curr <SPC> % <SPC> 4 <SPC> != <SPC> 1 : <NL>                  self . __cv . wait ( ) <NL>              self . __curr <SPC> += <SPC> 1 <NL>              printNumber ( i ) <NL>              self . __cv . notifyAll ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> prisonAfterNDays ( self , <SPC> cells , <SPC> N ) : <NL> <NL> <TAB> N <SPC> -= <SPC> max ( N <SPC> - <SPC> 1 , <SPC> 0 ) <SPC> // <SPC> 14 <SPC> * <SPC> 14 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N ) : <NL>          cells <SPC> = <SPC> [ 0 ] <SPC> + <SPC> [ cells [ i <SPC> - <SPC> 1 ] <SPC> ^ <SPC> cells [ i <SPC> + <SPC> 1 ] <NL>                         ^ <SPC> 1 <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> 7 ) ] <SPC> + <SPC> [ 0 ] <NL> <TAB> return <SPC> cells <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> prisonAfterNDays ( self , <SPC> cells , <SPC> N ) : <NL> <NL> <TAB> cells <SPC> = <SPC> tuple ( cells ) <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> while <SPC> N : <NL>          lookup [ cells ] <SPC> = <SPC> N <NL>          N <SPC> -= <SPC> 1 <NL>          cells <SPC> = <SPC> tuple ( <NL>              [ 0 ] <SPC> + <SPC> [ cells [ i <SPC> - <SPC> 1 ] <SPC> ^ <SPC> cells [ i <SPC> + <SPC> 1 ] <SPC> ^ <SPC> 1 <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> 7 ) ] <SPC> + <SPC> [ 0 ] <NL>          ) <NL>          if <SPC> cells <SPC> in <SPC> lookup : <NL>              assert <SPC> lookup [ cells ] <SPC> - <SPC> N <SPC> in <SPC> ( 1 , <SPC> 7 , <SPC> 14 ) <NL>              N <SPC> %= <SPC> lookup [ cells ] <SPC> - <SPC> N <NL>              break <NL> <NL> <TAB> while <SPC> N : <NL>          N <SPC> -= <SPC> 1 <NL>          cells <SPC> = <SPC> tuple ( <NL>              [ 0 ] <SPC> + <SPC> [ cells [ i <SPC> - <SPC> 1 ] <SPC> ^ <SPC> cells [ i <SPC> + <SPC> 1 ] <SPC> ^ <SPC> 1 <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> 7 ) ] <SPC> + <SPC> [ 0 ] <NL>          ) <NL> <TAB> return <SPC> list ( cells ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getProbability ( self , <SPC> balls ) : <NL> <NL> <TAB> def <SPC> nCrs ( n ) : <NL>          c <SPC> = <SPC> 1 <NL>          for <SPC> k <SPC> in <SPC> xrange ( n <SPC> + <SPC> 1 ) : <NL>              yield <SPC> c <NL>              c <SPC> *= <SPC> n <SPC> - <SPC> ( k <SPC> + <SPC> 1 ) <SPC> + <SPC> 1 <NL>              c <SPC> //= <SPC> k <SPC> + <SPC> 1 <NL> <NL> <TAB> def <SPC> nCr ( n , <SPC> r ) : <NL>          if <SPC> n <SPC> - <SPC> r <SPC> < <SPC> r : <NL>              return <SPC> nCr ( n , <SPC> n <SPC> - <SPC> r ) <NL>          c <SPC> = <SPC> 1 <NL>          for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> r <SPC> + <SPC> 1 ) : <NL>              c <SPC> *= <SPC> n <SPC> - <SPC> k <SPC> + <SPC> 1 <NL>              c <SPC> //= <SPC> k <NL>          return <SPC> c <NL> <NL> <TAB> dp <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> dp [ <NL>          0 , <SPC> 0 <NL> <TAB> ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> n <SPC> in <SPC> balls : <NL>          new_dp <SPC> = <SPC> collections . defaultdict ( int ) <NL>          for <SPC> ( ndiff , <SPC> cdiff ) , <SPC> count <SPC> in <SPC> dp . iteritems ( ) : <NL>              for <SPC> k , <SPC> new_count <SPC> in <SPC> enumerate ( nCrs ( n ) ) : <NL>                  new_ndiff <SPC> = <SPC> ndiff <SPC> + <SPC> ( k <SPC> - <SPC> ( n <SPC> - <SPC> k ) ) <NL>                  new_cdiff <SPC> = <SPC> ( <NL>                      cdiff <SPC> - <SPC> 1 <SPC> if <SPC> k <SPC> == <SPC> 0 <SPC> else <SPC> ( cdiff <SPC> + <SPC> 1 <SPC> if <SPC> k <SPC> == <SPC> n <SPC> else <SPC> cdiff ) <NL>                  ) <NL>                  new_dp [ new_ndiff , <SPC> new_cdiff ] <SPC> += <SPC> count <SPC> * <SPC> new_count <NL>          dp <SPC> = <SPC> new_dp <NL> <TAB> total <SPC> = <SPC> sum ( balls ) <NL> <TAB> return <SPC> float ( dp [ 0 , <SPC> 0 ] ) <SPC> / <SPC> nCr ( total , <SPC> total <SPC> // <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> productExceptSelf ( self , <SPC> nums ) : <NL> <TAB> if <SPC> not <SPC> nums : <NL>          return <SPC> [ ] <NL> <NL> <TAB> left_product <SPC> = <SPC> [ 1 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( nums ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( nums ) ) : <NL>          left_product [ i ] <SPC> = <SPC> left_product [ i <SPC> - <SPC> 1 ] <SPC> * <SPC> nums [ i <SPC> - <SPC> 1 ] <NL> <NL> <TAB> right_product <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) <SPC> - <SPC> 2 , <SPC> - 1 , <SPC> - 1 ) : <NL>          right_product <SPC> *= <SPC> nums [ i <SPC> + <SPC> 1 ] <NL>          left_product [ i ] <SPC> = <SPC> left_product [ i ] <SPC> * <SPC> right_product <NL> <NL> <TAB> return <SPC> left_product <NL> <NL> <NL> class <SPC> ProductOfNumbers ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __accu <SPC> = <SPC> [ 1 ] <NL> <NL> <TAB> def <SPC> add ( self , <SPC> num ) : <NL> <NL> <TAB> if <SPC> not <SPC> num : <NL>          self . __accu <SPC> = <SPC> [ 1 ] <NL>          return <NL> <TAB> self . __accu . append ( self . __accu [ - 1 ] <SPC> * <SPC> num ) <NL> <NL> <TAB> def <SPC> getProduct ( self , <SPC> k ) : <NL> <NL> <TAB> if <SPC> len ( self . __accu ) <SPC> <= <SPC> k : <NL>          return <SPC> 0 <NL> <TAB> return <SPC> self . __accu [ - 1 ] <SPC> // <SPC> self . __accu [ - 1 <SPC> - <SPC> k ] <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> profitableSchemes ( self , <SPC> G , <SPC> P , <SPC> group , <SPC> profit ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( G <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( P <SPC> + <SPC> 1 ) ] <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> p , <SPC> g <SPC> in <SPC> itertools . izip ( profit , <SPC> group ) : <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( P <SPC> + <SPC> 1 ) ) : <NL>              for <SPC> j <SPC> in <SPC> reversed ( xrange ( G <SPC> - <SPC> g <SPC> + <SPC> 1 ) ) : <NL>                  dp [ min ( i <SPC> + <SPC> p , <SPC> P ) ] [ j <SPC> + <SPC> g ] <SPC> += <SPC> dp [ i ] [ j ] <NL> <TAB> return <SPC> sum ( dp [ P ] ) <SPC> % <SPC> ( 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> projectionArea ( self , <SPC> grid ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          max_row , <SPC> max_col <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>              if <SPC> grid [ i ] [ j ] : <NL>                  result <SPC> += <SPC> 1 <NL>              max_row <SPC> = <SPC> max ( max_row , <SPC> grid [ i ] [ j ] ) <NL>              max_col <SPC> = <SPC> max ( max_col , <SPC> grid [ j ] [ i ] ) <NL>          result <SPC> += <SPC> max_row <SPC> + <SPC> max_col <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> left = None , <SPC> right = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . left <SPC> = <SPC> left <NL> <TAB> self . right <SPC> = <SPC> right <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pseudoPalindromicPaths ( self , <SPC> root ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> stk <SPC> = <SPC> [ ( root , <SPC> 0 ) ] <NL> <TAB> while <SPC> stk : <NL>          node , <SPC> count <SPC> = <SPC> stk . pop ( ) <NL>          if <SPC> not <SPC> node : <NL>              continue <NL>          count <SPC> ^= <SPC> 1 <SPC> << <SPC> ( node . val <SPC> - <SPC> 1 ) <NL>          result <SPC> += <SPC> int ( node . left <SPC> == <SPC> node . right <SPC> and <SPC> count <SPC> & <SPC> ( count <SPC> - <SPC> 1 ) <SPC> == <SPC> 0 ) <NL>          stk . append ( ( node . right , <SPC> count ) ) <NL>          stk . append ( ( node . left , <SPC> count ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> pseudoPalindromicPaths ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> count ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 <NL>          count <SPC> ^= <SPC> 1 <SPC> << <SPC> ( node . val <SPC> - <SPC> 1 ) <NL>          return <SPC> ( <NL>              int ( node . left <SPC> == <SPC> node . right <SPC> and <SPC> count <SPC> & <SPC> ( count <SPC> - <SPC> 1 ) <SPC> == <SPC> 0 ) <NL>              + <SPC> dfs ( node . left , <SPC> count ) <NL>              + <SPC> dfs ( node . right , <SPC> count ) <NL>          ) <NL> <NL> <TAB> return <SPC> dfs ( root , <SPC> 0 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pushDominoes ( self , <SPC> dominoes ) : <NL> <NL> <TAB> force <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( dominoes ) <NL> <NL> <TAB> f <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( dominoes ) ) : <NL>          if <SPC> dominoes [ i ] <SPC> == <SPC> "R" : <NL>              f <SPC> = <SPC> len ( dominoes ) <NL>          elif <SPC> dominoes [ i ] <SPC> == <SPC> "L" : <NL>              f <SPC> = <SPC> 0 <NL>          else : <NL>              f <SPC> = <SPC> max ( f <SPC> - <SPC> 1 , <SPC> 0 ) <NL>          force [ i ] <SPC> += <SPC> f <NL> <NL> <TAB> f <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( dominoes ) ) ) : <NL>          if <SPC> dominoes [ i ] <SPC> == <SPC> "L" : <NL>              f <SPC> = <SPC> len ( dominoes ) <NL>          elif <SPC> dominoes [ i ] <SPC> == <SPC> "R" : <NL>              f <SPC> = <SPC> 0 <NL>          else : <NL>              f <SPC> = <SPC> max ( f <SPC> - <SPC> 1 , <SPC> 0 ) <NL>          force [ i ] <SPC> -= <SPC> f <NL> <NL> <TAB> return <SPC> "" . join ( "." <SPC> if <SPC> f <SPC> == <SPC> 0 <SPC> else <SPC> "R" <SPC> if <SPC> f <SPC> > <SPC> 0 <SPC> else <SPC> "L" <SPC> for <SPC> f <SPC> in <SPC> force ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxBoxesInWarehouse ( self , <SPC> boxes , <SPC> warehouse ) : <NL> <NL> <TAB> boxes . sort ( reverse = True ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> h <SPC> in <SPC> boxes : <NL>          if <SPC> h <SPC> > <SPC> warehouse [ result ] : <NL>              continue <NL>          result <SPC> += <SPC> 1 <NL>          if <SPC> result <SPC> == <SPC> len ( warehouse ) : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxBoxesInWarehouse ( self , <SPC> boxes , <SPC> warehouse ) : <NL> <NL> <TAB> boxes . sort ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( warehouse ) ) : <NL>          warehouse [ i ] <SPC> = <SPC> min ( warehouse [ i ] , <SPC> warehouse [ i <SPC> - <SPC> 1 ] ) <NL> <TAB> result , <SPC> curr <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> h <SPC> in <SPC> reversed ( warehouse ) : <NL>          if <SPC> boxes [ curr ] <SPC> > <SPC> h : <NL>              continue <NL>          result <SPC> += <SPC> 1 <NL>          curr <SPC> += <SPC> 1 <NL>          if <SPC> curr <SPC> == <SPC> len ( boxes ) : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxBoxesInWarehouse ( self , <SPC> boxes , <SPC> warehouse ) : <NL> <NL> <TAB> boxes . sort ( reverse = True ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( warehouse ) <SPC> - <SPC> 1 <NL> <TAB> for <SPC> h <SPC> in <SPC> boxes : <NL>          if <SPC> h <SPC> <= <SPC> warehouse [ left ] : <NL>              left <SPC> += <SPC> 1 <NL>          elif <SPC> h <SPC> <= <SPC> warehouse [ right ] : <NL>              right <SPC> -= <SPC> 1 <NL>          if <SPC> left <SPC> > <SPC> right : <NL>              break <NL> <TAB> return <SPC> left <SPC> + <SPC> ( len ( warehouse ) <SPC> - <SPC> 1 <SPC> - <SPC> right ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> pyramidTransition ( self , <SPC> bottom , <SPC> allowed ) : <NL> <NL> <TAB> def <SPC> pyramidTransitionHelper ( bottom , <SPC> edges , <SPC> lookup ) : <NL>          def <SPC> dfs ( bottom , <SPC> edges , <SPC> new_bottom , <SPC> idx , <SPC> lookup ) : <NL>              if <SPC> idx <SPC> == <SPC> len ( bottom ) <SPC> - <SPC> 1 : <NL>                  return <SPC> pyramidTransitionHelper ( "" . join ( new_bottom ) , <SPC> edges , <SPC> lookup ) <NL>              for <SPC> i <SPC> in <SPC> edges [ ord ( bottom [ idx ] ) <SPC> - <SPC> ord ( "A" ) ] [ <NL>                  ord ( bottom [ idx <SPC> + <SPC> 1 ] ) <SPC> - <SPC> ord ( "A" ) <NL>              ] : <NL>                  new_bottom [ idx ] <SPC> = <SPC> chr ( i <SPC> + <SPC> ord ( "A" ) ) <NL>                  if <SPC> dfs ( bottom , <SPC> edges , <SPC> new_bottom , <SPC> idx <SPC> + <SPC> 1 , <SPC> lookup ) : <NL>                      return <SPC> True <NL>              return <SPC> False <NL> <NL>          if <SPC> len ( bottom ) <SPC> == <SPC> 1 : <NL>              return <SPC> True <NL>          if <SPC> bottom <SPC> in <SPC> lookup : <NL>              return <SPC> False <NL>          lookup . add ( bottom ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( bottom ) <SPC> - <SPC> 1 ) : <NL>              if <SPC> not <SPC> edges [ ord ( bottom [ i ] ) <SPC> - <SPC> ord ( "A" ) ] [ ord ( bottom [ i <SPC> + <SPC> 1 ] ) <SPC> - <SPC> ord ( "A" ) ] : <NL>                  return <SPC> False <NL>          new_bottom <SPC> = <SPC> [ "A" ] <SPC> * <SPC> ( len ( bottom ) <SPC> - <SPC> 1 ) <NL>          return <SPC> dfs ( bottom , <SPC> edges , <SPC> new_bottom , <SPC> 0 , <SPC> lookup ) <NL> <NL> <TAB> edges <SPC> = <SPC> [ [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 7 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 7 ) ] <NL> <TAB> for <SPC> s <SPC> in <SPC> allowed : <NL>          edges [ ord ( s [ 0 ] ) <SPC> - <SPC> ord ( "A" ) ] [ ord ( s [ 1 ] ) <SPC> - <SPC> ord ( "A" ) ] . append ( <NL>              ord ( s [ 2 ] ) <SPC> - <SPC> ord ( "A" ) <NL>          ) <NL> <TAB> return <SPC> pyramidTransitionHelper ( bottom , <SPC> edges , <SPC> set ( ) ) <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> isLeaf , <SPC> topLeft , <SPC> topRight , <SPC> bottomLeft , <SPC> bottomRight ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . isLeaf <SPC> = <SPC> isLeaf <NL> <TAB> self . topLeft <SPC> = <SPC> topLeft <NL> <TAB> self . topRight <SPC> = <SPC> topRight <NL> <TAB> self . bottomLeft <SPC> = <SPC> bottomLeft <NL> <TAB> self . bottomRight <SPC> = <SPC> bottomRight <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> intersect ( self , <SPC> quadTree1 , <SPC> quadTree2 ) : <NL> <NL> <TAB> if <SPC> quadTree1 . isLeaf : <NL>          return <SPC> quadTree1 <SPC> if <SPC> quadTree1 . val <SPC> else <SPC> quadTree2 <NL> <TAB> elif <SPC> quadTree2 . isLeaf : <NL>          return <SPC> quadTree2 <SPC> if <SPC> quadTree2 . val <SPC> else <SPC> quadTree1 <NL> <TAB> topLeftNode <SPC> = <SPC> self . intersect ( quadTree1 . topLeft , <SPC> quadTree2 . topLeft ) <NL> <TAB> topRightNode <SPC> = <SPC> self . intersect ( quadTree1 . topRight , <SPC> quadTree2 . topRight ) <NL> <TAB> bottomLeftNode <SPC> = <SPC> self . intersect ( quadTree1 . bottomLeft , <SPC> quadTree2 . bottomLeft ) <NL> <TAB> bottomRightNode <SPC> = <SPC> self . intersect ( <NL>          quadTree1 . bottomRight , <SPC> quadTree2 . bottomRight ) <NL> <TAB> if <SPC> ( <NL>          topLeftNode . isLeaf <NL>          and <SPC> topRightNode . isLeaf <NL>          and <SPC> bottomLeftNode . isLeaf <NL>          and <SPC> bottomRightNode . isLeaf <NL>          and <SPC> topLeftNode . val <NL>          == <SPC> topRightNode . val <NL>          == <SPC> bottomLeftNode . val <NL>          == <SPC> bottomRightNode . val <NL> <TAB> ) : <NL>          return <SPC> Node ( topLeftNode . val , <SPC> True , <SPC> None , <SPC> None , <SPC> None , <SPC> None ) <NL> <TAB> return <SPC> Node ( <NL>          True , <SPC> False , <SPC> topLeftNode , <SPC> topRightNode , <SPC> bottomLeftNode , <SPC> bottomRightNode <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> queensAttacktheKing ( self , <SPC> queens , <SPC> king ) : <NL> <NL> <TAB> dirctions <SPC> = <SPC> [ <NL>          ( - 1 , <SPC> 0 ) , <NL>          ( 0 , <SPC> 1 ) , <NL>          ( 1 , <SPC> 0 ) , <NL>          ( 0 , <SPC> - 1 ) , <NL>          ( - 1 , <SPC> 1 ) , <NL>          ( 1 , <SPC> 1 ) , <NL>          ( 1 , <SPC> - 1 ) , <NL>          ( - 1 , <SPC> - 1 ) , <NL> <TAB> ] <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> lookup <SPC> = <SPC> { ( i , <SPC> j ) <SPC> for <SPC> i , <SPC> j <SPC> in <SPC> queens } <NL> <TAB> for <SPC> dx , <SPC> dy <SPC> in <SPC> dirctions : <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> 8 ) : <NL>              x , <SPC> y <SPC> = <SPC> king [ 0 ] <SPC> + <SPC> dx <SPC> * <SPC> i , <SPC> king [ 1 ] <SPC> + <SPC> dy <SPC> * <SPC> i <NL>              if <SPC> ( x , <SPC> y ) <SPC> in <SPC> lookup : <NL>                  result . append ( [ x , <SPC> y ] ) <NL>                  break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> BIT ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . __bit <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <NL> <TAB> def <SPC> add ( self , <SPC> i , <SPC> val ) : <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( self . __bit ) : <NL>          self . __bit [ i ] <SPC> += <SPC> val <NL>          i <SPC> += <SPC> i <SPC> & <SPC> - i <NL> <NL> <TAB> def <SPC> sum ( self , <SPC> i ) : <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> > <SPC> 0 : <NL>          result <SPC> += <SPC> self . __bit [ i ] <NL>          i <SPC> -= <SPC> i <SPC> & <SPC> - i <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> processQueries ( self , <SPC> queries , <SPC> m ) : <NL> <NL> <TAB> bit <SPC> = <SPC> BIT ( 2 <SPC> * <SPC> m <SPC> + <SPC> 1 ) <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> m <SPC> + <SPC> 1 ) : <NL>          bit . add ( m <SPC> + <SPC> i , <SPC> 1 ) <NL>          lookup [ i ] <SPC> = <SPC> m <SPC> + <SPC> i <NL> <TAB> result , <SPC> curr <SPC> = <SPC> [ ] , <SPC> m <NL> <TAB> for <SPC> q <SPC> in <SPC> queries : <NL>          i <SPC> = <SPC> lookup . pop ( q ) <NL>          result . append ( bit . sum ( i <SPC> - <SPC> 1 ) ) <NL>          bit . add ( i , <SPC> - 1 ) <NL>          lookup [ q ] <SPC> = <SPC> curr <NL>          bit . add ( curr , <SPC> 1 ) <NL>          curr <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reconstructQueue ( self , <SPC> people ) : <NL> <NL> <TAB> people . sort ( key = lambda <SPC> h_k : <SPC> ( - h_k [ 0 ] , <SPC> h_k [ 1 ] ) ) <NL> <NL> <TAB> blocks <SPC> = <SPC> [ [ ] ] <NL> <TAB> for <SPC> p <SPC> in <SPC> people : <NL>          index <SPC> = <SPC> p [ 1 ] <NL> <NL>          for <SPC> i , <SPC> block <SPC> in <SPC> enumerate ( blocks ) : <NL>              if <SPC> index <SPC> <= <SPC> len ( block ) : <NL>                  break <NL>              index <SPC> -= <SPC> len ( block ) <NL>          block . insert ( index , <SPC> p ) <NL> <NL>          if <SPC> len ( block ) <SPC> * <SPC> len ( block ) <SPC> > <SPC> len ( people ) : <NL>              blocks . insert ( i <SPC> + <SPC> 1 , <SPC> block [ len ( block ) <SPC> / <SPC> 2 : ] ) <NL>              del <SPC> block [ len ( block ) <SPC> / <SPC> 2 : ] <NL> <NL> <TAB> return <SPC> [ p <SPC> for <SPC> block <SPC> in <SPC> blocks <SPC> for <SPC> p <SPC> in <SPC> block ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> reconstructQueue ( self , <SPC> people ) : <NL> <NL> <TAB> people . sort ( key = lambda <SPC> h_k1 : <SPC> ( - h_k1 [ 0 ] , <SPC> h_k1 [ 1 ] ) ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> p <SPC> in <SPC> people : <NL>          result . insert ( p [ 1 ] , <SPC> p ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numRabbits ( self , <SPC> answers ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( answers ) <NL> <TAB> return <SPC> sum ( <NL>          ( ( ( k <SPC> + <SPC> 1 ) <SPC> + <SPC> v <SPC> - <SPC> 1 ) <SPC> // <SPC> ( k <SPC> + <SPC> 1 ) ) <SPC> * <SPC> ( k <SPC> + <SPC> 1 ) <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> count . iteritems ( ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> racecar ( self , <SPC> target ) : <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( target <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> target <SPC> + <SPC> 1 ) : <NL> <NL>          k <SPC> = <SPC> i . bit_length ( ) <NL> <NL>          if <SPC> i <SPC> == <SPC> 2 <SPC> ** <SPC> k <SPC> - <SPC> 1 : <NL>              dp [ i ] <SPC> = <SPC> k <NL>              continue <NL> <NL>          dp [ i ] <SPC> = <SPC> k <SPC> + <SPC> 1 <SPC> + <SPC> dp [ 2 <SPC> ** <SPC> k <SPC> - <SPC> 1 <SPC> - <SPC> i ] <NL> <NL>          for <SPC> j <SPC> in <SPC> xrange ( k <SPC> - <SPC> 1 ) : <NL>              dp [ i ] <SPC> = <SPC> min ( dp [ i ] , <SPC> k <SPC> + <SPC> j <SPC> + <SPC> 1 <SPC> + <SPC> dp [ i <SPC> - <SPC> 2 <SPC> ** <SPC> ( k <SPC> - <SPC> 1 ) <SPC> + <SPC> 2 <SPC> ** <SPC> j ] ) <NL> <NL> <TAB> return <SPC> dp [ - 1 ] <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n_rows , <SPC> n_cols ) : <NL> <NL> <TAB> self . __n_rows <SPC> = <SPC> n_rows <NL> <TAB> self . __n_cols <SPC> = <SPC> n_cols <NL> <TAB> self . __n <SPC> = <SPC> n_rows <SPC> * <SPC> n_cols <NL> <TAB> self . __lookup <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> flip ( self ) : <NL> <NL> <TAB> self . __n <SPC> -= <SPC> 1 <NL> <TAB> target <SPC> = <SPC> random . randint ( 0 , <SPC> self . __n ) <NL> <TAB> x <SPC> = <SPC> self . __lookup . get ( target , <SPC> target ) <NL> <TAB> self . __lookup [ target ] <SPC> = <SPC> self . __lookup . get ( self . __n , <SPC> self . __n ) <NL> <TAB> return <SPC> divmod ( x , <SPC> self . __n_cols ) <NL> <NL> <TAB> def <SPC> reset ( self ) : <NL> <NL> <TAB> self . __n <SPC> = <SPC> self . __n_rows <SPC> * <SPC> self . __n_cols <NL> <TAB> self . __lookup <SPC> = <SPC> { } <NL> <NL> <NL> from <SPC> random <SPC> import <SPC> randint <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> nums ) : <NL> <NL> <TAB> self . __nums <SPC> = <SPC> nums <NL> <NL> <TAB> def <SPC> pick ( self , <SPC> target ) : <NL> <NL> <TAB> reservoir <SPC> = <SPC> - 1 <NL> <TAB> n <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( self . __nums ) ) : <NL>          if <SPC> self . __nums [ i ] <SPC> != <SPC> target : <NL>              continue <NL>          reservoir <SPC> = <SPC> i <SPC> if <SPC> randint ( 1 , <SPC> n <SPC> + <SPC> 1 ) <SPC> == <SPC> 1 <SPC> else <SPC> reservoir <NL>          n <SPC> += <SPC> 1 <NL> <TAB> return <SPC> reservoir <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> N , <SPC> blacklist ) : <NL> <NL> <TAB> self . __n <SPC> = <SPC> N <SPC> - <SPC> len ( blacklist ) <NL> <TAB> self . __lookup <SPC> = <SPC> { } <NL> <TAB> white <SPC> = <SPC> iter ( set ( range ( self . __n , <SPC> N ) ) <SPC> - <SPC> set ( blacklist ) ) <NL> <TAB> for <SPC> black <SPC> in <SPC> blacklist : <NL>          if <SPC> black <SPC> < <SPC> self . __n : <NL>              self . __lookup [ black ] <SPC> = <SPC> next ( white ) <NL> <NL> <TAB> def <SPC> pick ( self ) : <NL> <NL> <TAB> index <SPC> = <SPC> random . randint ( 0 , <SPC> self . __n <SPC> - <SPC> 1 ) <NL> <TAB> return <SPC> self . __lookup [ index ] <SPC> if <SPC> index <SPC> in <SPC> self . __lookup <SPC> else <SPC> index <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> N , <SPC> blacklist ) : <NL> <NL> <TAB> self . __n <SPC> = <SPC> N <SPC> - <SPC> len ( blacklist ) <NL> <TAB> blacklist . sort ( ) <NL> <TAB> self . __blacklist <SPC> = <SPC> blacklist <NL> <NL> <TAB> def <SPC> pick ( self ) : <NL> <NL> <TAB> index <SPC> = <SPC> random . randint ( 0 , <SPC> self . __n <SPC> - <SPC> 1 ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( self . __blacklist ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> index <SPC> + <SPC> mid <SPC> < <SPC> self . __blacklist [ mid ] : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> index <SPC> + <SPC> left <NL> <NL> <NL> import <SPC> random <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> w ) : <NL> <NL> <TAB> self . __prefix_sum <SPC> = <SPC> list ( w ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( w ) ) : <NL>          self . __prefix_sum [ i ] <SPC> += <SPC> self . __prefix_sum [ i <SPC> - <SPC> 1 ] <NL> <NL> <TAB> def <SPC> pickIndex ( self ) : <NL> <NL> <TAB> target <SPC> = <SPC> random . randint ( 0 , <SPC> self . __prefix_sum [ - 1 ] <SPC> - <SPC> 1 ) <NL> <TAB> return <SPC> bisect . bisect_right ( self . __prefix_sum , <SPC> target ) <NL> <NL> <NL> import <SPC> random <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> rects ) : <NL> <NL> <TAB> self . __rects <SPC> = <SPC> list ( rects ) <NL> <TAB> self . __prefix_sum <SPC> = <SPC> map ( lambda <SPC> x : <SPC> ( <NL>          x [ 2 ] <SPC> - <SPC> x [ 0 ] <SPC> + <SPC> 1 ) <SPC> * <SPC> ( x [ 3 ] <SPC> - <SPC> x [ 1 ] <SPC> + <SPC> 1 ) , <SPC> rects ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( self . __prefix_sum ) ) : <NL>          self . __prefix_sum [ i ] <SPC> += <SPC> self . __prefix_sum [ i <SPC> - <SPC> 1 ] <NL> <NL> <TAB> def <SPC> pick ( self ) : <NL> <NL> <TAB> target <SPC> = <SPC> random . randint ( 0 , <SPC> self . __prefix_sum [ - 1 ] <SPC> - <SPC> 1 ) <NL> <TAB> left <SPC> = <SPC> bisect . bisect_right ( self . __prefix_sum , <SPC> target ) <NL> <TAB> rect <SPC> = <SPC> self . __rects [ left ] <NL> <TAB> width , <SPC> height <SPC> = <SPC> rect [ 2 ] <SPC> - <SPC> rect [ 0 ] <SPC> + <SPC> 1 , <SPC> rect [ 3 ] <SPC> - <SPC> rect [ 1 ] <SPC> + <SPC> 1 <NL> <TAB> base <SPC> = <SPC> self . __prefix_sum [ left ] <SPC> - <SPC> width <SPC> * <SPC> height <NL> <TAB> return <SPC> [ rect [ 0 ] <SPC> + <SPC> ( target <SPC> - <SPC> base ) <SPC> % <SPC> width , <SPC> rect [ 1 ] <SPC> + <SPC> ( target <SPC> - <SPC> base ) <SPC> // <SPC> width ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxCount ( self , <SPC> m , <SPC> n , <SPC> ops ) : <NL> <NL> <TAB> for <SPC> op <SPC> in <SPC> ops : <NL>          m <SPC> = <SPC> min ( m , <SPC> op [ 0 ] ) <NL>          n <SPC> = <SPC> min ( n , <SPC> op [ 1 ] ) <NL> <TAB> return <SPC> m <SPC> * <SPC> n <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getModifiedArray ( self , <SPC> length , <SPC> updates ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> length <NL> <TAB> for <SPC> update <SPC> in <SPC> updates : <NL>          result [ update [ 0 ] ] <SPC> += <SPC> update [ 2 ] <NL>          if <SPC> update [ 1 ] <SPC> + <SPC> 1 <SPC> < <SPC> length : <NL>              result [ update [ 1 ] <SPC> + <SPC> 1 ] <SPC> -= <SPC> update [ 2 ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> length ) : <NL>          result [ i ] <SPC> += <SPC> result [ i <SPC> - <SPC> 1 ] <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> RangeModule ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __intervals <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> addRange ( self , <SPC> left , <SPC> right ) : <NL> <NL> <TAB> tmp <SPC> = <SPC> [ ] <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> for <SPC> interval <SPC> in <SPC> self . __intervals : <NL>          if <SPC> right <SPC> < <SPC> interval [ 0 ] : <NL>              tmp . append ( ( left , <SPC> right ) ) <NL>              break <NL>          elif <SPC> interval [ 1 ] <SPC> < <SPC> left : <NL>              tmp . append ( interval ) <NL>          else : <NL>              left <SPC> = <SPC> min ( left , <SPC> interval [ 0 ] ) <NL>              right <SPC> = <SPC> max ( right , <SPC> interval [ 1 ] ) <NL>          i <SPC> += <SPC> 1 <NL> <TAB> if <SPC> i <SPC> == <SPC> len ( self . __intervals ) : <NL>          tmp . append ( ( left , <SPC> right ) ) <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( self . __intervals ) : <NL>          tmp . append ( self . __intervals [ i ] ) <NL>          i <SPC> += <SPC> 1 <NL> <TAB> self . __intervals <SPC> = <SPC> tmp <NL> <NL> <TAB> def <SPC> queryRange ( self , <SPC> left , <SPC> right ) : <NL> <NL> <TAB> i <SPC> = <SPC> bisect . bisect_left ( self . __intervals , <SPC> ( left , <SPC> float ( "inf" ) ) ) <NL> <TAB> if <SPC> i : <NL>          i <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> ( <NL>          bool ( self . __intervals ) <NL>          and <SPC> self . __intervals [ i ] [ 0 ] <SPC> <= <SPC> left <NL>          and <SPC> right <SPC> <= <SPC> self . __intervals [ i ] [ 1 ] <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> removeRange ( self , <SPC> left , <SPC> right ) : <NL> <NL> <TAB> tmp <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> interval <SPC> in <SPC> self . __intervals : <NL>          if <SPC> interval [ 1 ] <SPC> <= <SPC> left <SPC> or <SPC> interval [ 0 ] <SPC> >= <SPC> right : <NL>              tmp . append ( interval ) <NL>          else : <NL>              if <SPC> interval [ 0 ] <SPC> < <SPC> left : <NL>                  tmp . append ( ( interval [ 0 ] , <SPC> left ) ) <NL>              if <SPC> right <SPC> < <SPC> interval [ 1 ] : <NL>                  tmp . append ( ( right , <SPC> interval [ 1 ] ) ) <NL> <TAB> self . __intervals <SPC> = <SPC> tmp <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rangeSumBST ( self , <SPC> root , <SPC> L , <SPC> R ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> s <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> s : <NL>          node <SPC> = <SPC> s . pop ( ) <NL>          if <SPC> node : <NL>              if <SPC> L <SPC> <= <SPC> node . val <SPC> <= <SPC> R : <NL>                  result <SPC> += <SPC> node . val <NL>              if <SPC> L <SPC> < <SPC> node . val : <NL>                  s . append ( node . left ) <NL>              if <SPC> node . val <SPC> < <SPC> R : <NL>                  s . append ( node . right ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rangeSum ( self , <SPC> nums , <SPC> n , <SPC> left , <SPC> right ) : <NL> <NL> <TAB> def <SPC> countUntil ( nums , <SPC> target ) : <NL>          result , <SPC> curr , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL>          for <SPC> right <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>              curr <SPC> += <SPC> nums [ right ] <NL>              while <SPC> curr <SPC> > <SPC> target : <NL>                  curr <SPC> -= <SPC> nums [ left ] <NL>                  left <SPC> += <SPC> 1 <NL>              result <SPC> += <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> sumUntil ( nums , <SPC> prefix , <SPC> target ) : <NL>          result , <SPC> curr , <SPC> total , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 <NL>          for <SPC> right <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>              curr <SPC> += <SPC> nums [ right ] <NL>              total <SPC> += <SPC> nums [ right ] <SPC> * <SPC> ( right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <NL>              while <SPC> curr <SPC> > <SPC> target : <NL>                  curr <SPC> -= <SPC> nums [ left ] <NL>                  total <SPC> -= <SPC> prefix [ right <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ ( left <SPC> - <SPC> 1 ) <SPC> + <SPC> 1 ] <NL>                  left <SPC> += <SPC> 1 <NL>              result <SPC> += <SPC> total <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> sumLessOrEqualTo ( prefix , <SPC> nums , <SPC> left , <SPC> right , <SPC> count ) : <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>              if <SPC> countUntil ( nums , <SPC> mid ) <SPC> - <SPC> count <SPC> >= <SPC> 0 : <NL>                  right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          return <SPC> sumUntil ( nums , <SPC> prefix , <SPC> left ) <SPC> - <SPC> left <SPC> * <SPC> ( <NL>              countUntil ( nums , <SPC> left ) <SPC> - <SPC> count <NL>          ) <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( nums ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          prefix [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> prefix [ i ] <SPC> + <SPC> nums [ i ] <NL> <TAB> m , <SPC> M <SPC> = <SPC> min ( nums ) , <SPC> sum ( nums ) <NL> <TAB> return <SPC> ( <NL>          sumLessOrEqualTo ( prefix , <SPC> nums , <SPC> m , <SPC> M , <SPC> right ) <NL>          - <SPC> sumLessOrEqualTo ( prefix , <SPC> nums , <SPC> m , <SPC> M , <SPC> left <SPC> - <SPC> 1 ) <NL> <TAB> ) <SPC> % <SPC> MOD <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> rangeSum ( self , <SPC> nums , <SPC> n , <SPC> left , <SPC> right ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums , <SPC> 1 ) : <NL>          heapq . heappush ( min_heap , <SPC> ( num , <SPC> i ) ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> right <SPC> + <SPC> 1 ) : <NL>          total , <SPC> j <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> i <SPC> >= <SPC> left : <NL>              result <SPC> = <SPC> ( result <SPC> + <SPC> total ) <SPC> % <SPC> MOD <NL>          if <SPC> j <SPC> + <SPC> 1 <SPC> <= <SPC> n : <NL>              heapq . heappush ( min_heap , <SPC> ( total <SPC> + <SPC> nums [ j ] , <SPC> j <SPC> + <SPC> 1 ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> NumMatrix ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> matrix ) : <NL> <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( matrix ) , <SPC> len ( matrix [ 0 ] ) <NL> <TAB> self . __sums <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> m <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>              self . __sums [ i ] [ j ] <SPC> = <SPC> ( <NL>                  self . __sums [ i ] [ j <SPC> - <SPC> 1 ] <NL>                  + <SPC> self . __sums [ i <SPC> - <SPC> 1 ] [ j ] <NL>                  - <SPC> self . __sums [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <NL>                  + <SPC> matrix [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <NL>              ) <NL> <NL> <TAB> def <SPC> sumRegion ( self , <SPC> row1 , <SPC> col1 , <SPC> row2 , <SPC> col2 ) : <NL> <NL> <TAB> return <SPC> ( <NL>          self . __sums [ row2 <SPC> + <SPC> 1 ] [ col2 <SPC> + <SPC> 1 ] <NL>          - <SPC> self . __sums [ row2 <SPC> + <SPC> 1 ] [ col1 ] <NL>          - <SPC> self . __sums [ row1 ] [ col2 <SPC> + <SPC> 1 ] <NL>          + <SPC> self . __sums [ row1 ] [ col1 ] <NL> <TAB> ) <NL> <NL> <NL> class <SPC> NumMatrix ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> matrix ) : <NL> <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <NL> <TAB> self . __matrix <SPC> = <SPC> matrix <NL> <TAB> self . __bit <SPC> = <SPC> [ <NL>          [ 0 ] <SPC> * <SPC> ( len ( self . __matrix [ 0 ] ) <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( self . __matrix ) <SPC> + <SPC> 1 ) <NL> <TAB> ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( self . __bit ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( self . __bit [ 0 ] ) ) : <NL>              self . __bit [ i ] [ j ] <SPC> = <SPC> ( <NL>                  matrix [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <NL>                  + <SPC> self . __bit [ i <SPC> - <SPC> 1 ] [ j ] <NL>                  + <SPC> self . __bit [ i ] [ j <SPC> - <SPC> 1 ] <NL>                  - <SPC> self . __bit [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <NL>              ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( self . __bit ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( self . __bit [ 0 ] ) ) ) : <NL>              last_i , <SPC> last_j <SPC> = <SPC> i <SPC> - <SPC> ( i <SPC> & <SPC> - i ) , <SPC> j <SPC> - <SPC> ( j <SPC> & <SPC> - j ) <NL>              self . __bit [ i ] [ j ] <SPC> = <SPC> ( <NL>                  self . __bit [ i ] [ j ] <NL>                  - <SPC> self . __bit [ i ] [ last_j ] <NL>                  - <SPC> self . __bit [ last_i ] [ j ] <NL>                  + <SPC> self . __bit [ last_i ] [ last_j ] <NL>              ) <NL> <NL> <TAB> def <SPC> update ( self , <SPC> row , <SPC> col , <SPC> val ) : <NL> <NL> <TAB> if <SPC> val <SPC> - <SPC> self . __matrix [ row ] [ col ] : <NL>          self . __add ( row , <SPC> col , <SPC> val <SPC> - <SPC> self . __matrix [ row ] [ col ] ) <NL>          self . __matrix [ row ] [ col ] <SPC> = <SPC> val <NL> <NL> <TAB> def <SPC> sumRegion ( self , <SPC> row1 , <SPC> col1 , <SPC> row2 , <SPC> col2 ) : <NL> <NL> <TAB> return <SPC> ( <NL>          self . __sum ( row2 , <SPC> col2 ) <NL>          - <SPC> self . __sum ( row2 , <SPC> col1 <SPC> - <SPC> 1 ) <NL>          - <SPC> self . __sum ( row1 <SPC> - <SPC> 1 , <SPC> col2 ) <NL>          + <SPC> self . __sum ( row1 <SPC> - <SPC> 1 , <SPC> col1 <SPC> - <SPC> 1 ) <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> __sum ( self , <SPC> row , <SPC> col ) : <NL> <TAB> row <SPC> += <SPC> 1 <NL> <TAB> col <SPC> += <SPC> 1 <NL> <TAB> ret <SPC> = <SPC> 0 <NL> <TAB> i <SPC> = <SPC> row <NL> <TAB> while <SPC> i <SPC> > <SPC> 0 : <NL>          j <SPC> = <SPC> col <NL>          while <SPC> j <SPC> > <SPC> 0 : <NL>              ret <SPC> += <SPC> self . __bit [ i ] [ j ] <NL>              j <SPC> -= <SPC> j <SPC> & <SPC> - j <NL>          i <SPC> -= <SPC> i <SPC> & <SPC> - i <NL> <TAB> return <SPC> ret <NL> <NL> <TAB> def <SPC> __add ( self , <SPC> row , <SPC> col , <SPC> val ) : <NL> <TAB> row <SPC> += <SPC> 1 <NL> <TAB> col <SPC> += <SPC> 1 <NL> <TAB> i <SPC> = <SPC> row <NL> <TAB> while <SPC> i <SPC> <= <SPC> len ( self . __matrix ) : <NL>          j <SPC> = <SPC> col <NL>          while <SPC> j <SPC> <= <SPC> len ( self . __matrix [ 0 ] ) : <NL>              self . __bit [ i ] [ j ] <SPC> += <SPC> val <NL>              j <SPC> += <SPC> j <SPC> & <SPC> - j <NL>          i <SPC> += <SPC> i <SPC> & <SPC> - i <NL> <NL> <NL> class <SPC> NumArray ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> nums ) : <NL> <NL> <TAB> self . accu <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          self . accu . append ( self . accu [ - 1 ] <SPC> + <SPC> num ) , <NL> <NL> <TAB> def <SPC> sumRange ( self , <SPC> i , <SPC> j ) : <NL> <NL> <TAB> return <SPC> self . accu [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> self . accu [ i ] <NL> <NL> <NL> class <SPC> NumArray ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> not <SPC> nums : <NL>          return <NL> <TAB> self . __nums <SPC> = <SPC> nums <NL> <TAB> self . __bit <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( self . __nums ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( self . __bit ) ) : <NL>          self . __bit [ i ] <SPC> = <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> self . __bit [ i <SPC> - <SPC> 1 ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( self . __bit ) ) ) : <NL>          last_i <SPC> = <SPC> i <SPC> - <SPC> ( i <SPC> & <SPC> - i ) <NL>          self . __bit [ i ] <SPC> -= <SPC> self . __bit [ last_i ] <NL> <NL> <TAB> def <SPC> update ( self , <SPC> i , <SPC> val ) : <NL> <NL> <TAB> if <SPC> val <SPC> - <SPC> self . __nums [ i ] : <NL>          self . __add ( i , <SPC> val <SPC> - <SPC> self . __nums [ i ] ) <NL>          self . __nums [ i ] <SPC> = <SPC> val <NL> <NL> <TAB> def <SPC> sumRange ( self , <SPC> i , <SPC> j ) : <NL> <NL> <TAB> return <SPC> self . __sum ( j ) <SPC> - <SPC> self . __sum ( i <SPC> - <SPC> 1 ) <NL> <NL> <TAB> def <SPC> __sum ( self , <SPC> i ) : <NL> <TAB> i <SPC> += <SPC> 1 <NL> <TAB> ret <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> > <SPC> 0 : <NL>          ret <SPC> += <SPC> self . __bit [ i ] <NL>          i <SPC> -= <SPC> i <SPC> & <SPC> - i <NL> <TAB> return <SPC> ret <NL> <NL> <TAB> def <SPC> __add ( self , <SPC> i , <SPC> val ) : <NL> <TAB> i <SPC> += <SPC> 1 <NL> <TAB> while <SPC> i <SPC> <= <SPC> len ( self . __nums ) : <NL>          self . __bit [ i ] <SPC> += <SPC> val <NL>          i <SPC> += <SPC> i <SPC> & <SPC> - i <NL> <NL> <NL> class <SPC> NumArray2 ( object ) : <NL> <TAB> def <SPC> __init__ ( <NL>          self , <SPC> nums , <SPC> query_fn = lambda <SPC> x , <SPC> y : <SPC> x <SPC> + <SPC> y , <SPC> update_fn = lambda <SPC> x , <SPC> y : <SPC> y , <SPC> default_val = 0 <NL> <TAB> ) : <NL> <NL> <TAB> N <SPC> = <SPC> len ( nums ) <NL> <TAB> self . __original_length <SPC> = <SPC> N <NL> <TAB> self . __tree_length <SPC> = <SPC> 2 <SPC> ** <SPC> ( N . bit_length ( ) <SPC> + <SPC> ( N <SPC> & <SPC> ( N <SPC> - <SPC> 1 ) <SPC> != <SPC> 0 ) ) <SPC> - <SPC> 1 <NL> <TAB> self . __query_fn <SPC> = <SPC> query_fn <NL> <TAB> self . __update_fn <SPC> = <SPC> update_fn <NL> <TAB> self . __default_val <SPC> = <SPC> default_val <NL> <TAB> self . __tree <SPC> = <SPC> [ default_val <SPC> for <SPC> _ <SPC> in <SPC> range ( self . __tree_length ) ] <NL> <TAB> self . __lazy <SPC> = <SPC> [ None <SPC> for <SPC> _ <SPC> in <SPC> range ( self . __tree_length ) ] <NL> <TAB> self . __constructTree ( nums , <SPC> 0 , <SPC> self . __original_length <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <TAB> def <SPC> update ( self , <SPC> i , <SPC> val ) : <NL> <TAB> self . __updateTree ( val , <SPC> i , <SPC> i , <SPC> 0 , <SPC> self . __original_length <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <TAB> def <SPC> sumRange ( self , <SPC> i , <SPC> j ) : <NL> <TAB> return <SPC> self . __queryRange ( i , <SPC> j , <SPC> 0 , <SPC> self . __original_length <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <TAB> def <SPC> __constructTree ( self , <SPC> nums , <SPC> left , <SPC> right , <SPC> idx ) : <NL> <TAB> if <SPC> left <SPC> > <SPC> right : <NL>          return <NL> <TAB> if <SPC> left <SPC> == <SPC> right : <NL>          self . __tree [ idx ] <SPC> = <SPC> self . __update_fn ( self . __tree [ idx ] , <SPC> nums [ left ] ) <NL>          return <NL> <TAB> mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL> <TAB> self . __constructTree ( nums , <SPC> left , <SPC> mid , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ) <NL> <TAB> self . __constructTree ( nums , <SPC> mid <SPC> + <SPC> 1 , <SPC> right , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ) <NL> <TAB> self . __tree [ idx ] <SPC> = <SPC> self . __query_fn ( <NL>          self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] , <SPC> self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ] <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> __apply ( self , <SPC> left , <SPC> right , <SPC> idx , <SPC> val ) : <NL> <TAB> self . __tree [ idx ] <SPC> = <SPC> self . __update_fn ( self . __tree [ idx ] , <SPC> val ) <NL> <TAB> if <SPC> left <SPC> != <SPC> right : <NL>          self . __lazy [ idx <SPC> * <SPC> 2 <SPC> + <NL>                      1 ] <SPC> = <SPC> self . __update_fn ( self . __lazy [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] , <SPC> val ) <NL>          self . __lazy [ idx <SPC> * <SPC> 2 <SPC> + <NL>                      2 ] <SPC> = <SPC> self . __update_fn ( self . __lazy [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ] , <SPC> val ) <NL> <NL> <TAB> def <SPC> __updateTree ( self , <SPC> val , <SPC> range_left , <SPC> range_right , <SPC> left , <SPC> right , <SPC> idx ) : <NL> <TAB> if <SPC> left <SPC> > <SPC> right : <NL>          return <NL> <TAB> if <SPC> self . __lazy [ idx ] <SPC> is <SPC> not <SPC> None : <NL>          self . __apply ( left , <SPC> right , <SPC> idx , <SPC> self . __lazy [ idx ] ) <NL>          self . __lazy [ idx ] <SPC> = <SPC> None <NL> <TAB> if <SPC> range_left <SPC> > <SPC> right <SPC> or <SPC> range_right <SPC> < <SPC> left : <NL>          return <NL> <TAB> if <SPC> range_left <SPC> <= <SPC> left <SPC> and <SPC> right <SPC> <= <SPC> range_right : <NL>          self . __apply ( left , <SPC> right , <SPC> idx , <SPC> val ) <NL>          return <NL> <TAB> mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL> <TAB> self . __updateTree ( val , <SPC> range_left , <SPC> range_right , <SPC> left , <SPC> mid , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ) <NL> <TAB> self . __updateTree ( val , <SPC> range_left , <SPC> range_right , <NL>                        mid <SPC> + <SPC> 1 , <SPC> right , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ) <NL> <TAB> self . __tree [ idx ] <SPC> = <SPC> self . __query_fn ( <NL>          self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ] , <SPC> self . __tree [ idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ] <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> __queryRange ( self , <SPC> range_left , <SPC> range_right , <SPC> left , <SPC> right , <SPC> idx ) : <NL> <TAB> if <SPC> left <SPC> > <SPC> right : <NL>          return <SPC> self . __default_val <NL> <TAB> if <SPC> self . __lazy [ idx ] <SPC> is <SPC> not <SPC> None : <NL>          self . __apply ( left , <SPC> right , <SPC> idx , <SPC> self . __lazy [ idx ] ) <NL>          self . __lazy [ idx ] <SPC> = <SPC> None <NL> <TAB> if <SPC> right <SPC> < <SPC> range_left <SPC> or <SPC> left <SPC> > <SPC> range_right : <NL>          return <SPC> self . __default_val <NL> <TAB> if <SPC> range_left <SPC> <= <SPC> left <SPC> and <SPC> right <SPC> <= <SPC> range_right : <NL>          return <SPC> self . __tree [ idx ] <NL> <TAB> mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL> <TAB> return <SPC> self . __query_fn ( <NL>          self . __queryRange ( range_left , <SPC> range_right , <SPC> left , <SPC> mid , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 1 ) , <NL>          self . __queryRange ( range_left , <SPC> range_right , <NL>                            mid <SPC> + <SPC> 1 , <SPC> right , <SPC> idx <SPC> * <SPC> 2 <SPC> + <SPC> 2 ) , <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rankTeams ( self , <SPC> votes ) : <NL> <NL> <TAB> count <SPC> = <SPC> { v : <SPC> [ 0 ] <SPC> * <SPC> len ( votes [ 0 ] ) <SPC> + <SPC> [ v ] <SPC> for <SPC> v <SPC> in <SPC> votes [ 0 ] } <NL> <TAB> for <SPC> vote <SPC> in <SPC> votes : <NL>          for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( vote ) : <NL>              count [ v ] [ i ] <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> "" . join ( sorted ( votes [ 0 ] , <SPC> key = count . __getitem__ ) ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n , <SPC> cb ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . rank <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> self . cb <SPC> = <SPC> cb <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> stk <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          stk . append ( x ) <NL>          x <SPC> = <SPC> self . set [ x ] <NL> <TAB> while <SPC> stk : <NL>          self . set [ stk . pop ( ) ] <SPC> = <SPC> x <NL> <TAB> return <SPC> x <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> if <SPC> self . rank [ x_root ] <SPC> < <SPC> self . rank [ y_root ] : <NL>          self . set [ x_root ] <SPC> = <SPC> y_root <NL>          self . cb ( y_root , <SPC> x_root , <SPC> y_root ) <NL> <TAB> elif <SPC> self . rank [ x_root ] <SPC> > <SPC> self . rank [ y_root ] : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL>          self . cb ( x_root , <SPC> x_root , <SPC> y_root ) <NL> <TAB> else : <NL>          self . set [ y_root ] <SPC> = <SPC> x_root <NL>          self . rank [ x_root ] <SPC> += <SPC> 1 <NL>          self . cb ( x_root , <SPC> x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> matrixRankTransform ( self , <SPC> matrix ) : <NL> <NL> <TAB> def <SPC> cb ( x , <SPC> y , <SPC> z ) : <NL>          new_rank [ x ] <SPC> = <SPC> max ( new_rank [ y ] , <SPC> new_rank [ z ] ) <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) : <NL>              lookup [ matrix [ i ] [ j ] ] . append ( [ i , <SPC> j ] ) <NL> <TAB> rank <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( matrix ) <SPC> + <SPC> len ( matrix [ 0 ] ) ) <NL> <TAB> for <SPC> x <SPC> in <SPC> sorted ( lookup ) : <NL>          new_rank <SPC> = <SPC> rank [ : ] <NL>          union_find <SPC> = <SPC> UnionFind ( len ( matrix ) <SPC> + <SPC> len ( matrix [ 0 ] ) , <SPC> cb ) <NL>          for <SPC> i , <SPC> j <SPC> in <SPC> lookup [ x ] : <NL>              union_find . union_set ( i , <SPC> j <SPC> + <SPC> len ( matrix ) ) <NL>          for <SPC> i , <SPC> j <SPC> in <SPC> lookup [ x ] : <NL>              matrix [ i ] [ j ] <SPC> = <SPC> rank [ i ] <SPC> = <SPC> rank [ j <SPC> + <SPC> len ( matrix ) ] <SPC> = <SPC> ( <NL>                  new_rank [ union_find . find_set ( i ) ] <SPC> + <SPC> 1 <NL>              ) <NL> <TAB> return <SPC> matrix <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> arrayRankTransform ( self , <SPC> arr ) : <NL> <NL> <TAB> return <SPC> map ( { x : <SPC> i <SPC> + <SPC> 1 <SPC> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( sorted ( set ( arr ) ) ) } . get , <SPC> arr ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canConstruct ( self , <SPC> ransomNote , <SPC> magazine ) : <NL> <NL> <TAB> counts <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL> <TAB> letters <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> c <SPC> in <SPC> ransomNote : <NL>          if <SPC> counts [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> == <SPC> 0 : <NL>              letters <SPC> += <SPC> 1 <NL>          counts [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL> <NL> <TAB> for <SPC> c <SPC> in <SPC> magazine : <NL>          counts [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> -= <SPC> 1 <NL>          if <SPC> counts [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> == <SPC> 0 : <NL>              letters <SPC> -= <SPC> 1 <NL>              if <SPC> letters <SPC> == <SPC> 0 : <NL>                  break <NL> <NL> <TAB> return <SPC> letters <SPC> == <SPC> 0 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> canConstruct ( self , <SPC> ransomNote , <SPC> magazine ) : <NL> <NL> <TAB> return <SPC> not <SPC> collections . Counter ( ransomNote ) <SPC> - <SPC> collections . Counter ( magazine ) <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reachNumber ( self , <SPC> target ) : <NL> <NL> <TAB> target <SPC> = <SPC> abs ( target ) <NL> <TAB> k <SPC> = <SPC> int ( math . ceil ( ( - 1 <SPC> + <SPC> math . sqrt ( 1 <SPC> + <SPC> 8 <SPC> * <SPC> target ) ) <SPC> / <SPC> 2 ) ) <NL> <TAB> target <SPC> -= <SPC> k <SPC> * <SPC> ( k <SPC> + <SPC> 1 ) <SPC> / <SPC> 2 <NL> <TAB> return <SPC> k <SPC> if <SPC> target <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> else <SPC> k <SPC> + <SPC> 1 <SPC> + <SPC> k <SPC> % <SPC> 2 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> reachNumber ( self , <SPC> target ) : <NL> <NL> <TAB> target <SPC> = <SPC> abs ( target ) <NL> <TAB> k <SPC> = <SPC> 0 <NL> <TAB> while <SPC> target <SPC> > <SPC> 0 : <NL>          k <SPC> += <SPC> 1 <NL>          target <SPC> -= <SPC> k <NL> <TAB> return <SPC> k <SPC> if <SPC> target <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> else <SPC> k <SPC> + <SPC> 1 <SPC> + <SPC> k <SPC> % <SPC> 2 <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reachableNodes ( self , <SPC> edges , <SPC> M , <SPC> N ) : <NL> <NL> <TAB> adj <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( N ) ] <NL> <TAB> for <SPC> u , <SPC> v , <SPC> w <SPC> in <SPC> edges : <NL>          adj [ u ] . append ( ( v , <SPC> w ) ) <NL>          adj [ v ] . append ( ( u , <SPC> w ) ) <NL> <NL> <TAB> min_heap <SPC> = <SPC> [ ( 0 , <SPC> 0 ) ] <NL> <TAB> best <SPC> = <SPC> collections . defaultdict ( lambda : <SPC> float ( "inf" ) ) <NL> <TAB> best [ 0 ] <SPC> = <SPC> 0 <NL> <TAB> count <SPC> = <SPC> collections . defaultdict ( lambda : <SPC> collections . defaultdict ( int ) ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> min_heap : <NL>          curr_total , <SPC> u <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> best [ u ] <SPC> < <SPC> curr_total : <NL>              continue <NL>          result <SPC> += <SPC> 1 <NL>          for <SPC> v , <SPC> w <SPC> in <SPC> adj [ u ] : <NL>              count [ u ] [ v ] <SPC> = <SPC> min ( w , <SPC> M <SPC> - <SPC> curr_total ) <NL>              next_total <SPC> = <SPC> curr_total <SPC> + <SPC> w <SPC> + <SPC> 1 <NL>              if <SPC> next_total <SPC> <= <SPC> M <SPC> and <SPC> next_total <SPC> < <SPC> best [ v ] : <NL>                  best [ v ] <SPC> = <SPC> next_total <NL>                  heapq . heappush ( <NL>                      min_heap , <SPC> ( next_total , <SPC> v ) <NL>                  ) <NL> <NL> <TAB> for <SPC> u , <SPC> v , <SPC> w <SPC> in <SPC> edges : <NL>          result <SPC> += <SPC> min ( w , <SPC> count [ u ] [ v ] <SPC> + <SPC> count [ v ] [ u ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reachingPoints ( self , <SPC> sx , <SPC> sy , <SPC> tx , <SPC> ty ) : <NL> <NL> <TAB> while <SPC> tx <SPC> >= <SPC> sx <SPC> and <SPC> ty <SPC> >= <SPC> sy : <NL>          if <SPC> tx <SPC> < <SPC> ty : <NL>              sx , <SPC> sy <SPC> = <SPC> sy , <SPC> sx <NL>              tx , <SPC> ty <SPC> = <SPC> ty , <SPC> tx <NL>          if <SPC> ty <SPC> > <SPC> sy : <NL>              tx <SPC> %= <SPC> ty <NL>          else : <NL>              return <SPC> ( tx <SPC> - <SPC> sx ) <SPC> % <SPC> ty <SPC> == <SPC> 0 <NL> <NL> <TAB> return <SPC> False <NL> <NL> <NL> def <SPC> read4 ( buf ) : <NL> <TAB> global <SPC> file_content <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( file_content ) <SPC> and <SPC> i <SPC> < <SPC> 4 : <NL> <TAB> buf [ i ] <SPC> = <SPC> file_content [ i ] <NL> <TAB> i <SPC> += <SPC> 1 <NL> <NL> <TAB> if <SPC> len ( file_content ) <SPC> > <SPC> 4 : <NL> <TAB> file_content <SPC> = <SPC> file_content [ 4 : ] <NL> <TAB> else : <NL> <TAB> file_content <SPC> = <SPC> "" <NL> <TAB> return <SPC> i <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __buf4 <SPC> = <SPC> [ "" ] <SPC> * <SPC> 4 <NL> <TAB> self . __i4 <SPC> = <SPC> 0 <NL> <TAB> self . __n4 <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> read ( self , <SPC> buf , <SPC> n ) : <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> n : <NL>          if <SPC> self . __i4 <SPC> < <SPC> self . __n4 : <NL>              buf [ i ] <SPC> = <SPC> self . __buf4 [ self . __i4 ] <NL>              i <SPC> += <SPC> 1 <NL>              self . __i4 <SPC> += <SPC> 1 <NL>          else : <NL>              self . __n4 <SPC> = <SPC> read4 ( self . __buf4 ) <NL>              if <SPC> self . __n4 : <NL>                  self . __i4 <SPC> = <SPC> 0 <NL>              else : <NL>                  break <NL> <NL> <TAB> return <SPC> i <NL> <NL> <NL> def <SPC> read4 ( buf ) : <NL> <TAB> global <SPC> file_content <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( file_content ) <SPC> and <SPC> i <SPC> < <SPC> 4 : <NL> <TAB> buf [ i ] <SPC> = <SPC> file_content [ i ] <NL> <TAB> i <SPC> += <SPC> 1 <NL> <NL> <TAB> if <SPC> len ( file_content ) <SPC> > <SPC> 4 : <NL> <TAB> file_content <SPC> = <SPC> file_content [ 4 : ] <NL> <TAB> else : <NL> <TAB> file_content <SPC> = <SPC> "" <NL> <TAB> return <SPC> i <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> read ( self , <SPC> buf , <SPC> n ) : <NL> <NL> <TAB> read_bytes <SPC> = <SPC> 0 <NL> <TAB> buffer <SPC> = <SPC> [ "" ] <SPC> * <SPC> 4 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( ( n <SPC> + <SPC> 4 <SPC> - <SPC> 1 ) <SPC> // <SPC> 4 ) : <NL>          size <SPC> = <SPC> min ( read4 ( buffer ) , <SPC> n <SPC> - <SPC> read_bytes ) <NL>          buf [ read_bytes : <SPC> read_bytes <SPC> + <SPC> size ] <SPC> = <SPC> buffer [ : size ] <NL>          read_bytes <SPC> += <SPC> size <NL> <TAB> return <SPC> read_bytes <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reorderSpaces ( self , <SPC> text ) : <NL> <NL> <TAB> text <SPC> = <SPC> list ( text ) <NL> <NL> <TAB> space_count , <SPC> word_count <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( text ) : <NL>          if <SPC> c <SPC> == <SPC> " " : <NL>              space_count <SPC> += <SPC> 1 <NL>          elif <SPC> i <SPC> == <SPC> 0 <SPC> or <SPC> text [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> " " : <NL>              word_count <SPC> += <SPC> 1 <NL> <NL> <TAB> left , <SPC> i <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( text ) : <NL>          has_word <SPC> = <SPC> False <NL>          while <SPC> i <SPC> < <SPC> len ( text ) <SPC> and <SPC> text [ i ] <SPC> != <SPC> " " : <NL>              text [ left ] , <SPC> text [ i ] <SPC> = <SPC> text [ i ] , <SPC> text [ left ] <NL>              left <SPC> += <SPC> 1 <NL>              i <SPC> += <SPC> 1 <NL>              has_word <SPC> = <SPC> True <NL>          if <SPC> has_word : <NL>              left <SPC> += <SPC> 1 <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> equal_count <SPC> = <SPC> space_count <SPC> // <SPC> ( word_count <SPC> - <SPC> 1 ) <SPC> if <SPC> word_count <SPC> - <SPC> 1 <SPC> > <SPC> 0 <SPC> else <SPC> 0 <NL> <TAB> extra_count <SPC> = <SPC> ( <NL>          space_count <SPC> % <SPC> ( word_count <SPC> - <SPC> 1 ) <SPC> if <SPC> word_count <SPC> - <SPC> 1 <SPC> > <SPC> 0 <SPC> else <SPC> space_count <NL> <TAB> ) <NL> <TAB> right , <SPC> i <SPC> = <SPC> len ( text ) <SPC> - <SPC> 1 <SPC> - <SPC> extra_count , <SPC> len ( text ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> i <SPC> >= <SPC> 0 : <NL>          has_word <SPC> = <SPC> False <NL>          while <SPC> i <SPC> >= <SPC> 0 <SPC> and <SPC> text [ i ] <SPC> != <SPC> " " : <NL>              text [ right ] , <SPC> text [ i ] <SPC> = <SPC> text [ i ] , <SPC> text [ right ] <NL>              right <SPC> -= <SPC> 1 <NL>              i <SPC> -= <SPC> 1 <NL>              has_word <SPC> = <SPC> True <NL>          if <SPC> has_word : <NL>              right <SPC> -= <SPC> equal_count <NL>          i <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> "" . join ( text ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rearrangeString ( self , <SPC> str , <SPC> k ) : <NL> <NL> <TAB> cnts <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> c <SPC> in <SPC> str : <NL>          cnts [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL> <NL> <TAB> sorted_cnts <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 26 ) : <NL>          sorted_cnts . append ( ( cnts [ i ] , <SPC> chr ( i <SPC> + <SPC> ord ( "a" ) ) ) ) <NL> <TAB> sorted_cnts . sort ( reverse = True ) <NL> <NL> <TAB> max_cnt <SPC> = <SPC> sorted_cnts [ 0 ] [ 0 ] <NL> <TAB> blocks <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( max_cnt ) ] <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> for <SPC> cnt <SPC> in <SPC> sorted_cnts : <NL>          for <SPC> _ <SPC> in <SPC> xrange ( cnt [ 0 ] ) : <NL>              blocks [ i ] . append ( cnt [ 1 ] ) <NL>              i <SPC> = <SPC> ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> max ( cnt [ 0 ] , <SPC> max_cnt <SPC> - <SPC> 1 ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( max_cnt <SPC> - <SPC> 1 ) : <NL>          if <SPC> len ( blocks [ i ] ) <SPC> < <SPC> k : <NL>              return <SPC> "" <NL> <NL> <TAB> return <SPC> "" . join ( map ( lambda <SPC> x : <SPC> "" . join ( x ) , <SPC> blocks ) ) <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> Counter <NL> from <SPC> heapq <SPC> import <SPC> heappush , <SPC> heappop <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> rearrangeString ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> if <SPC> k <SPC> <= <SPC> 1 : <NL>          return <SPC> s <NL> <NL> <TAB> cnts <SPC> = <SPC> Counter ( s ) <NL> <TAB> heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> c , <SPC> cnt <SPC> in <SPC> cnts . iteritems ( ) : <NL>          heappush ( heap , <SPC> [ - cnt , <SPC> c ] ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> heap : <NL>          used_cnt_chars <SPC> = <SPC> [ ] <NL>          for <SPC> _ <SPC> in <SPC> xrange ( min ( k , <SPC> len ( s ) <SPC> - <SPC> len ( result ) ) ) : <NL>              if <SPC> not <SPC> heap : <NL>                  return <SPC> "" <NL>              cnt_char <SPC> = <SPC> heappop ( heap ) <NL>              result . append ( cnt_char [ 1 ] ) <NL>              cnt_char [ 0 ] <SPC> += <SPC> 1 <NL>              if <SPC> cnt_char [ 0 ] <SPC> < <SPC> 0 : <NL>                  used_cnt_chars . append ( cnt_char ) <NL>          for <SPC> cnt_char <SPC> in <SPC> used_cnt_chars : <NL>              heappush ( heap , <SPC> cnt_char ) <NL> <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> arrangeWords ( self , <SPC> text ) : <NL> <NL> <TAB> result <SPC> = <SPC> text . split ( ) <NL> <TAB> result [ 0 ] <SPC> = <SPC> result [ 0 ] . lower ( ) <NL> <TAB> result . sort ( key = len ) <NL> <TAB> result [ 0 ] <SPC> = <SPC> result [ 0 ] . title ( ) <NL> <TAB> return <SPC> " " . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reconstructMatrix ( self , <SPC> upper , <SPC> lower , <SPC> colsum ) : <NL> <NL> <TAB> upper_matrix , <SPC> lower_matrix <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( colsum ) , <SPC> [ 0 ] <SPC> * <SPC> len ( colsum ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( colsum ) ) : <NL>          upper_matrix [ i ] <SPC> = <SPC> int ( upper <SPC> > <SPC> 0 <SPC> and <SPC> colsum [ i ] <SPC> != <SPC> 0 ) <NL>          lower_matrix [ i ] <SPC> = <SPC> colsum [ i ] <SPC> - <SPC> upper_matrix [ i ] <NL>          upper <SPC> -= <SPC> upper_matrix [ i ] <NL>          lower <SPC> -= <SPC> lower_matrix [ i ] <NL> <TAB> return <SPC> [ upper_matrix , <SPC> lower_matrix ] <SPC> if <SPC> upper <SPC> == <SPC> lower <SPC> == <SPC> 0 <SPC> else <SPC> [ ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findItinerary ( self , <SPC> tickets ) : <NL> <NL> <TAB> def <SPC> route_helper ( origin , <SPC> ticket_cnt , <SPC> graph , <SPC> ans ) : <NL>          if <SPC> ticket_cnt <SPC> == <SPC> 0 : <NL>              return <SPC> True <NL> <NL>          for <SPC> i , <SPC> ( dest , <SPC> valid ) <SPC> in <SPC> enumerate ( graph [ origin ] ) : <NL>              if <SPC> valid : <NL>                  graph [ origin ] [ i ] [ 1 ] <SPC> = <SPC> False <NL>                  ans . append ( dest ) <NL>                  if <SPC> route_helper ( dest , <SPC> ticket_cnt <SPC> - <SPC> 1 , <SPC> graph , <SPC> ans ) : <NL>                      return <SPC> ans <NL>                  ans . pop ( ) <NL>                  graph [ origin ] [ i ] [ 1 ] <SPC> = <SPC> True <NL>          return <SPC> False <NL> <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> ticket <SPC> in <SPC> tickets : <NL>          graph [ ticket [ 0 ] ] . append ( [ ticket [ 1 ] , <SPC> True ] ) <NL> <TAB> for <SPC> k <SPC> in <SPC> graph . keys ( ) : <NL>          graph [ k ] . sort ( ) <NL> <NL> <TAB> origin <SPC> = <SPC> "JFK" <NL> <TAB> ans <SPC> = <SPC> [ origin ] <NL> <TAB> route_helper ( origin , <SPC> len ( tickets ) , <SPC> graph , <SPC> ans ) <NL> <TAB> return <SPC> ans <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> Counter <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> originalDigits ( self , <SPC> s ) : <NL> <NL> <TAB> cnts <SPC> = <SPC> [ <NL>          Counter ( _ ) <NL>          for <SPC> _ <SPC> in <SPC> [ <NL>              "zero" , <NL>              "one" , <NL>              "two" , <NL>              "three" , <NL>              "four" , <NL>              "five" , <NL>              "six" , <NL>              "seven" , <NL>              "eight" , <NL>              "nine" , <NL>          ] <NL> <TAB> ] <NL> <NL> <TAB> order <SPC> = <SPC> [ 0 , <SPC> 2 , <SPC> 4 , <SPC> 6 , <SPC> 8 , <SPC> 1 , <SPC> 3 , <SPC> 5 , <SPC> 7 , <SPC> 9 ] <NL> <NL> <TAB> unique_chars <SPC> = <SPC> [ "z" , <SPC> "o" , <SPC> "w" , <SPC> "t" , <SPC> "u" , <SPC> "f" , <SPC> "x" , <SPC> "s" , <SPC> "g" , <SPC> "n" ] <NL> <NL> <TAB> cnt <SPC> = <SPC> Counter ( list ( s ) ) <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> order : <NL>          while <SPC> cnt [ unique_chars [ i ] ] <SPC> > <SPC> 0 : <NL>              cnt <SPC> -= <SPC> cnts [ i ] <NL>              res . append ( i ) <NL> <TAB> res . sort ( ) <NL> <NL> <TAB> return <SPC> "" . join ( map ( str , <SPC> res ) ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> recoverFromPreorder ( self , <SPC> S ) : <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( S ) : <NL>          level <SPC> = <SPC> 0 <NL>          while <SPC> i <SPC> < <SPC> len ( S ) <SPC> and <SPC> S [ i ] <SPC> == <SPC> "-" : <NL>              level <SPC> += <SPC> 1 <NL>              i <SPC> += <SPC> 1 <NL>          while <SPC> len ( stack ) <SPC> > <SPC> level : <NL>              stack . pop ( ) <NL>          val <SPC> = <SPC> [ ] <NL>          while <SPC> i <SPC> < <SPC> len ( S ) <SPC> and <SPC> S [ i ] <SPC> != <SPC> "-" : <NL>              val . append ( S [ i ] ) <NL>              i <SPC> += <SPC> 1 <NL>          node <SPC> = <SPC> TreeNode ( int ( "" . join ( val ) ) ) <NL>          if <SPC> stack : <NL>              if <SPC> stack [ - 1 ] . left <SPC> is <SPC> None : <NL>                  stack [ - 1 ] . left <SPC> = <SPC> node <NL>              else : <NL>                  stack [ - 1 ] . right <SPC> = <SPC> node <NL>          stack . append ( node ) <NL> <TAB> return <SPC> stack [ 0 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> recoverFromPreorder ( self , <SPC> S ) : <NL> <NL> <TAB> def <SPC> recoverFromPreorderHelper ( S , <SPC> level , <SPC> i ) : <NL>          j <SPC> = <SPC> i [ 0 ] <NL>          while <SPC> j <SPC> < <SPC> len ( S ) <SPC> and <SPC> S [ j ] <SPC> == <SPC> "-" : <NL>              j <SPC> += <SPC> 1 <NL>          if <SPC> level <SPC> != <SPC> j <SPC> - <SPC> i [ 0 ] : <NL>              return <SPC> None <NL>          i [ 0 ] <SPC> = <SPC> j <NL>          while <SPC> j <SPC> < <SPC> len ( S ) <SPC> and <SPC> S [ j ] <SPC> != <SPC> "-" : <NL>              j <SPC> += <SPC> 1 <NL>          node <SPC> = <SPC> TreeNode ( int ( S [ i [ 0 ] : <SPC> j ] ) ) <NL>          i [ 0 ] <SPC> = <SPC> j <NL>          node . left <SPC> = <SPC> recoverFromPreorderHelper ( S , <SPC> level <SPC> + <SPC> 1 , <SPC> i ) <NL>          node . right <SPC> = <SPC> recoverFromPreorderHelper ( S , <SPC> level <SPC> + <SPC> 1 , <SPC> i ) <NL>          return <SPC> node <NL> <NL> <TAB> return <SPC> recoverFromPreorderHelper ( S , <SPC> 0 , <SPC> [ 0 ] ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          serial <SPC> = <SPC> [ ] <NL>          queue <SPC> = <SPC> [ self ] <NL> <NL>          while <SPC> queue : <NL>              cur <SPC> = <SPC> queue [ 0 ] <NL> <NL>              if <SPC> cur : <NL>                  serial . append ( cur . val ) <NL>                  queue . append ( cur . left ) <NL>                  queue . append ( cur . right ) <NL>              else : <NL>                  serial . append ( "#" ) <NL> <NL>              queue <SPC> = <SPC> queue [ 1 : ] <NL> <NL>          while <SPC> serial [ - 1 ] <SPC> == <SPC> "#" : <NL>              serial . pop ( ) <NL> <NL>          return <SPC> repr ( serial ) <NL> <NL> <TAB> else : <NL>          return <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> recoverTree ( self , <SPC> root ) : <NL> <TAB> return <SPC> self . MorrisTraversal ( root ) <NL> <NL> <TAB> def <SPC> MorrisTraversal ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <NL> <TAB> broken <SPC> = <SPC> [ None , <SPC> None ] <NL> <TAB> pre , <SPC> cur <SPC> = <SPC> None , <SPC> root <NL> <NL> <TAB> while <SPC> cur : <NL>          if <SPC> cur . left <SPC> is <SPC> None : <NL>              self . detectBroken ( broken , <SPC> pre , <SPC> cur ) <NL>              pre <SPC> = <SPC> cur <NL>              cur <SPC> = <SPC> cur . right <NL>          else : <NL>              node <SPC> = <SPC> cur . left <NL>              while <SPC> node . right <SPC> and <SPC> node . right <SPC> != <SPC> cur : <NL>                  node <SPC> = <SPC> node . right <NL> <NL>              if <SPC> node . right <SPC> is <SPC> None : <NL>                  node . right <SPC> = <SPC> cur <NL>                  cur <SPC> = <SPC> cur . left <NL>              else : <NL>                  self . detectBroken ( broken , <SPC> pre , <SPC> cur ) <NL>                  node . right <SPC> = <SPC> None <NL>                  pre <SPC> = <SPC> cur <NL>                  cur <SPC> = <SPC> cur . right <NL> <NL> <TAB> broken [ 0 ] . val , <SPC> broken [ 1 ] . val <SPC> = <SPC> broken [ 1 ] . val , <SPC> broken [ 0 ] . val <NL> <NL> <TAB> return <SPC> root <NL> <NL> <TAB> def <SPC> detectBroken ( self , <SPC> broken , <SPC> pre , <SPC> cur ) : <NL> <TAB> if <SPC> pre <SPC> and <SPC> pre . val <SPC> > <SPC> cur . val : <NL>          if <SPC> broken [ 0 ] <SPC> is <SPC> None : <NL>              broken [ 0 ] <SPC> = <SPC> pre <NL>          broken [ 1 ] <SPC> = <SPC> cur <NL> <NL> <NL> class <SPC> SegmentTreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> start , <SPC> end ) : <NL> <TAB> self . start , <SPC> self . end <SPC> = <SPC> start , <SPC> end <NL> <TAB> self . total <SPC> = <SPC> self . count <SPC> = <SPC> 0 <NL> <TAB> self . _left <SPC> = <SPC> self . _right <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> mid ( self ) : <NL> <TAB> return <SPC> ( self . start <SPC> + <SPC> self . end ) <SPC> // <SPC> 2 <NL> <NL> <TAB> def <SPC> left ( self ) : <NL> <TAB> self . _left <SPC> = <SPC> self . _left <SPC> or <SPC> SegmentTreeNode ( self . start , <SPC> self . mid ( ) ) <NL> <TAB> return <SPC> self . _left <NL> <NL> <TAB> def <SPC> right ( self ) : <NL> <TAB> self . _right <SPC> = <SPC> self . _right <SPC> or <SPC> SegmentTreeNode ( self . mid ( ) , <SPC> self . end ) <NL> <TAB> return <SPC> self . _right <NL> <NL> <TAB> def <SPC> update ( self , <SPC> X , <SPC> i , <SPC> j , <SPC> val ) : <NL> <TAB> if <SPC> i <SPC> >= <SPC> j : <NL>          return <SPC> 0 <NL> <TAB> if <SPC> self . start <SPC> == <SPC> i <SPC> and <SPC> self . end <SPC> == <SPC> j : <NL>          self . count <SPC> += <SPC> val <NL> <TAB> else : <NL>          self . left ( ) . update ( X , <SPC> i , <SPC> min ( self . mid ( ) , <SPC> j ) , <SPC> val ) <NL>          self . right ( ) . update ( X , <SPC> max ( self . mid ( ) , <SPC> i ) , <SPC> j , <SPC> val ) <NL> <TAB> if <SPC> self . count <SPC> > <SPC> 0 : <NL>          self . total <SPC> = <SPC> X [ self . end ] <SPC> - <SPC> X [ self . start ] <NL> <TAB> else : <NL>          self . total <SPC> = <SPC> self . left ( ) . total <SPC> + <SPC> self . right ( ) . total <NL> <TAB> return <SPC> self . total <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rectangleArea ( self , <SPC> rectangles ) : <NL> <NL> <TAB> OPEN , <SPC> CLOSE <SPC> = <SPC> 1 , <SPC> - 1 <NL> <TAB> events <SPC> = <SPC> [ ] <NL> <TAB> X <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> x1 , <SPC> y1 , <SPC> x2 , <SPC> y2 <SPC> in <SPC> rectangles : <NL>          events . append ( ( y1 , <SPC> OPEN , <SPC> x1 , <SPC> x2 ) ) <NL>          events . append ( ( y2 , <SPC> CLOSE , <SPC> x1 , <SPC> x2 ) ) <NL>          X . add ( x1 ) <NL>          X . add ( x2 ) <NL> <TAB> events . sort ( ) <NL> <TAB> X <SPC> = <SPC> sorted ( X ) <NL> <TAB> Xi <SPC> = <SPC> { x : <SPC> i <SPC> for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( X ) } <NL> <NL> <TAB> st <SPC> = <SPC> SegmentTreeNode ( 0 , <SPC> len ( X ) <SPC> - <SPC> 1 ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> cur_x_sum <SPC> = <SPC> 0 <NL> <TAB> cur_y <SPC> = <SPC> events [ 0 ] [ 0 ] <NL> <TAB> for <SPC> y , <SPC> typ , <SPC> x1 , <SPC> x2 <SPC> in <SPC> events : <NL>          result <SPC> += <SPC> cur_x_sum <SPC> * <SPC> ( y <SPC> - <SPC> cur_y ) <NL>          cur_x_sum <SPC> = <SPC> st . update ( X , <SPC> Xi [ x1 ] , <SPC> Xi [ x2 ] , <SPC> typ ) <NL>          cur_y <SPC> = <SPC> y <NL> <TAB> return <SPC> result <SPC> % <SPC> ( 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> computeArea ( self , <SPC> A , <SPC> B , <SPC> C , <SPC> D , <SPC> E , <SPC> F , <SPC> G , <SPC> H ) : <NL> <TAB> return <SPC> ( <NL>          ( D <SPC> - <SPC> B ) <SPC> * <SPC> ( C <SPC> - <SPC> A ) <NL>          + <SPC> ( G <SPC> - <SPC> E ) <SPC> * <SPC> ( H <SPC> - <SPC> F ) <NL>          - <SPC> max ( 0 , <SPC> ( min ( C , <SPC> G ) <SPC> - <SPC> max ( A , <SPC> E ) ) ) <SPC> * <SPC> max ( 0 , <SPC> ( min ( D , <SPC> H ) <SPC> - <SPC> max ( B , <SPC> F ) ) ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isRectangleOverlap ( self , <SPC> rec1 , <SPC> rec2 ) : <NL> <NL> <TAB> def <SPC> intersect ( p_left , <SPC> p_right , <SPC> q_left , <SPC> q_right ) : <NL>          return <SPC> max ( p_left , <SPC> q_left ) <SPC> < <SPC> min ( p_right , <SPC> q_right ) <NL> <NL> <TAB> return <SPC> intersect ( rec1 [ 0 ] , <SPC> rec1 [ 2 ] , <SPC> rec2 [ 0 ] , <SPC> rec2 [ 2 ] ) <SPC> and <SPC> intersect ( <NL>          rec1 [ 1 ] , <SPC> rec1 [ 3 ] , <SPC> rec2 [ 1 ] , <SPC> rec2 [ 3 ] <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minSetSize ( self , <SPC> arr ) : <NL> <NL> <TAB> counting_sort <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( arr ) <NL> <TAB> count <SPC> = <SPC> collections . Counter ( arr ) <NL> <TAB> for <SPC> c <SPC> in <SPC> count . itervalues ( ) : <NL>          counting_sort [ c <SPC> - <SPC> 1 ] <SPC> += <SPC> 1 <NL> <TAB> result , <SPC> total <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> reversed ( xrange ( len ( arr ) ) ) : <NL>          if <SPC> not <SPC> counting_sort [ c ] : <NL>              continue <NL>          count <SPC> = <SPC> min ( <NL>              counting_sort [ c ] , <SPC> ( ( len ( arr ) <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 <SPC> - <SPC> total <SPC> - <SPC> 1 ) <SPC> // <SPC> ( c <SPC> + <SPC> 1 ) <SPC> + <SPC> 1 <NL>          ) <NL>          result <SPC> += <SPC> count <NL>          total <SPC> += <SPC> count <SPC> * <SPC> ( c <SPC> + <SPC> 1 ) <NL>          if <SPC> total <SPC> >= <SPC> ( len ( arr ) <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSatisfaction ( self , <SPC> satisfaction ) : <NL> <NL> <TAB> satisfaction . sort ( reverse = True ) <NL> <TAB> result , <SPC> curr <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> satisfaction : <NL>          curr <SPC> += <SPC> x <NL>          if <SPC> curr <SPC> <= <SPC> 0 : <NL>              break <NL>          result <SPC> += <SPC> curr <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findRedundantDirectedConnection ( self , <SPC> edges ) : <NL> <NL> <TAB> cand1 , <SPC> cand2 <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> parent <SPC> = <SPC> { } <NL> <TAB> for <SPC> edge <SPC> in <SPC> edges : <NL>          if <SPC> edge [ 1 ] <SPC> not <SPC> in <SPC> parent : <NL>              parent [ edge [ 1 ] ] <SPC> = <SPC> edge [ 0 ] <NL>          else : <NL>              cand1 <SPC> = <SPC> [ parent [ edge [ 1 ] ] , <SPC> edge [ 1 ] ] <NL>              cand2 <SPC> = <SPC> edge <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( edges ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> edge <SPC> in <SPC> edges : <NL>          if <SPC> edge <SPC> == <SPC> cand2 : <NL>              continue <NL>          if <SPC> not <SPC> union_find . union_set ( * edge ) : <NL>              return <SPC> cand1 <SPC> if <SPC> cand2 <SPC> else <SPC> edge <NL> <TAB> return <SPC> cand2 <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findRedundantConnection ( self , <SPC> edges ) : <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( edges ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> edge <SPC> in <SPC> edges : <NL>          if <SPC> not <SPC> union_find . union_set ( * edge ) : <NL>              return <SPC> edge <NL> <TAB> return <SPC> [ ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reformatDate ( self , <SPC> date ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { <NL>          "Jan" : <SPC> 1 , <NL>          "Feb" : <SPC> 2 , <NL>          "Mar" : <SPC> 3 , <NL>          "Apr" : <SPC> 4 , <NL>          "May" : <SPC> 5 , <NL>          "Jun" : <SPC> 6 , <NL>          "Jul" : <SPC> 7 , <NL>          "Aug" : <SPC> 8 , <NL>          "Sep" : <SPC> 9 , <NL>          "Oct" : <SPC> 10 , <NL>          "Nov" : <SPC> 11 , <NL>          "Dec" : <SPC> 12 , <NL> <TAB> } <NL> <TAB> return <SPC> "{:04d}-{:02d}-{:02d}" . format ( <NL>          int ( date [ - 4 : ] ) , <SPC> lookup [ date [ - 8 : - 5 ] ] , <SPC> int ( date [ : <SPC> date . index ( " " ) <SPC> - <SPC> 2 ] ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reformatNumber ( self , <SPC> number ) : <NL> <NL> <TAB> number <SPC> = <SPC> list ( number ) <NL> <TAB> src_len <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> number : <NL>          if <SPC> c . isdigit ( ) : <NL>              number [ src_len ] <SPC> = <SPC> c <NL>              src_len <SPC> += <SPC> 1 <NL> <TAB> dst_len <SPC> = <SPC> src_len <SPC> + <SPC> ( src_len <SPC> - <SPC> 1 ) <SPC> // <SPC> 3 <NL> <TAB> if <SPC> dst_len <SPC> > <SPC> len ( number ) : <NL>          number . extend ( [ 0 ] <SPC> * <SPC> ( dst_len <SPC> - <SPC> len ( number ) ) ) <NL> <TAB> while <SPC> dst_len <SPC> < <SPC> len ( number ) : <NL>          number . pop ( ) <NL> <TAB> curr <SPC> = <SPC> dst_len <SPC> - <SPC> 1 <NL> <TAB> for <SPC> l , <SPC> i <SPC> in <SPC> enumerate ( reversed ( xrange ( src_len ) ) , <SPC> ( 3 <SPC> - <SPC> src_len <SPC> % <SPC> 3 ) <SPC> % <SPC> 3 ) : <NL>          if <SPC> l <SPC> and <SPC> l <SPC> % <SPC> 3 <SPC> == <SPC> 0 : <NL>              number [ curr ] <SPC> = <SPC> "-" <NL>              curr <SPC> -= <SPC> 1 <NL>          number [ curr ] <SPC> = <SPC> number [ i ] <NL>          curr <SPC> -= <SPC> 1 <NL> <TAB> if <SPC> dst_len <SPC> >= <SPC> 3 <SPC> and <SPC> number [ dst_len <SPC> - <SPC> 2 ] <SPC> == <SPC> "-" : <NL>          number [ dst_len <SPC> - <SPC> 3 ] , <SPC> number [ dst_len <SPC> - <SPC> 2 ] <SPC> = <SPC> ( <NL>              number [ dst_len <SPC> - <SPC> 2 ] , <NL>              number [ dst_len <SPC> - <SPC> 3 ] , <NL>          ) <NL> <TAB> return <SPC> "" . join ( number ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reformat ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> char_gen ( start , <SPC> end , <SPC> count ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( ord ( start ) , <SPC> ord ( end ) <SPC> + <SPC> 1 ) : <NL>              c <SPC> = <SPC> chr ( c ) <NL>              for <SPC> i <SPC> in <SPC> xrange ( count [ c ] ) : <NL>                  yield <SPC> c <NL>          yield <SPC> "" <NL> <NL> <TAB> count <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> alpha_cnt <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          count [ c ] <SPC> += <SPC> 1 <NL>          if <SPC> c . isalpha ( ) : <NL>              alpha_cnt <SPC> += <SPC> 1 <NL> <TAB> if <SPC> abs ( len ( s ) <SPC> - <SPC> 2 <SPC> * <SPC> alpha_cnt ) <SPC> > <SPC> 1 : <NL>          return <SPC> "" <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> it1 , <SPC> it2 <SPC> = <SPC> char_gen ( "a" , <SPC> "z" , <SPC> count ) , <SPC> char_gen ( "0" , <SPC> "9" , <SPC> count ) <NL> <TAB> if <SPC> alpha_cnt <SPC> < <SPC> len ( s ) <SPC> - <SPC> alpha_cnt : <NL>          it1 , <SPC> it2 <SPC> = <SPC> it2 , <SPC> it1 <NL> <TAB> while <SPC> len ( result ) <SPC> < <SPC> len ( s ) : <NL>          result . append ( next ( it1 ) ) <NL>          result . append ( next ( it2 ) ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . count <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> != <SPC> y_root : <NL>          self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL>          self . count <SPC> -= <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> regionsBySlashes ( self , <SPC> grid ) : <NL> <NL> <TAB> def <SPC> index ( n , <SPC> i , <SPC> j , <SPC> k ) : <NL>          return <SPC> ( i <SPC> * <SPC> n <SPC> + <SPC> j ) <SPC> * <SPC> 4 <SPC> + <SPC> k <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( grid ) <SPC> ** <SPC> 2 <SPC> * <SPC> 4 ) <NL> <TAB> N , <SPC> E , <SPC> S , <SPC> W <SPC> = <SPC> range ( 4 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>              if <SPC> i : <NL>                  union_find . union_set ( <NL>                      index ( len ( grid ) , <SPC> i <SPC> - <SPC> 1 , <SPC> j , <SPC> S ) , <SPC> index ( len ( grid ) , <SPC> i , <SPC> j , <SPC> N ) <NL>                  ) <NL>              if <SPC> j : <NL>                  union_find . union_set ( <NL>                      index ( len ( grid ) , <SPC> i , <SPC> j <SPC> - <SPC> 1 , <SPC> E ) , <SPC> index ( len ( grid ) , <SPC> i , <SPC> j , <SPC> W ) <NL>                  ) <NL>              if <SPC> grid [ i ] [ j ] <SPC> != <SPC> "/" : <NL>                  union_find . union_set ( <NL>                      index ( len ( grid ) , <SPC> i , <SPC> j , <SPC> N ) , <SPC> index ( len ( grid ) , <SPC> i , <SPC> j , <SPC> E ) <NL>                  ) <NL>                  union_find . union_set ( <NL>                      index ( len ( grid ) , <SPC> i , <SPC> j , <SPC> S ) , <SPC> index ( len ( grid ) , <SPC> i , <SPC> j , <SPC> W ) <NL>                  ) <NL>              if <SPC> grid [ i ] [ j ] <SPC> != <SPC> "\\" : <NL>                  union_find . union_set ( <NL>                      index ( len ( grid ) , <SPC> i , <SPC> j , <SPC> W ) , <SPC> index ( len ( grid ) , <SPC> i , <SPC> j , <SPC> N ) <NL>                  ) <NL>                  union_find . union_set ( <NL>                      index ( len ( grid ) , <SPC> i , <SPC> j , <SPC> E ) , <SPC> index ( len ( grid ) , <SPC> i , <SPC> j , <SPC> S ) <NL>                  ) <NL> <TAB> return <SPC> union_find . count <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isMatch ( self , <SPC> s , <SPC> p ) : <NL> <TAB> k <SPC> = <SPC> 3 <NL> <TAB> result <SPC> = <SPC> [ [ False <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( p ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( k ) ] <NL> <NL> <TAB> result [ 0 ] [ 0 ] <SPC> = <SPC> True <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> len ( p ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> p [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "*" : <NL>              result [ 0 ] [ i ] <SPC> = <SPC> result [ 0 ] [ i <SPC> - <SPC> 2 ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> i <SPC> > <SPC> 1 : <NL>              result [ 0 ] [ 0 ] <SPC> = <SPC> False <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( p ) <SPC> + <SPC> 1 ) : <NL>              if <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> != <SPC> "*" : <NL>                  result [ i <SPC> % <SPC> k ] [ j ] <SPC> = <SPC> result [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> k ] [ j <SPC> - <SPC> 1 ] <SPC> and <SPC> ( <NL>                      s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> or <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> "." <NL>                  ) <NL>              else : <NL>                  result [ i <SPC> % <SPC> k ] [ j ] <SPC> = <SPC> result [ i <SPC> % <SPC> k ] [ j <SPC> - <SPC> 2 ] <SPC> or <SPC> ( <NL>                      result [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> k ] [ j ] <NL>                      and <SPC> ( s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> p [ j <SPC> - <SPC> 2 ] <SPC> or <SPC> p [ j <SPC> - <SPC> 2 ] <SPC> == <SPC> "." ) <NL>                  ) <NL> <NL> <TAB> return <SPC> result [ len ( s ) <SPC> % <SPC> k ] [ len ( p ) ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> isMatch ( self , <SPC> s , <SPC> p ) : <NL> <TAB> result <SPC> = <SPC> [ [ False <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( p ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> + <SPC> 1 ) ] <NL> <NL> <TAB> result [ 0 ] [ 0 ] <SPC> = <SPC> True <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> len ( p ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> p [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "*" : <NL>              result [ 0 ] [ i ] <SPC> = <SPC> result [ 0 ] [ i <SPC> - <SPC> 2 ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( p ) <SPC> + <SPC> 1 ) : <NL>              if <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> != <SPC> "*" : <NL>                  result [ i ] [ j ] <SPC> = <SPC> result [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> and <SPC> ( <NL>                      s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> or <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> "." <NL>                  ) <NL>              else : <NL>                  result [ i ] [ j ] <SPC> = <SPC> result [ i ] [ j <SPC> - <SPC> 2 ] <SPC> or <SPC> ( <NL>                      result [ i <SPC> - <SPC> 1 ] [ j ] <SPC> and <SPC> ( s [ i <SPC> - <SPC> 1 ] <SPC> == <NL>                                            p [ j <SPC> - <SPC> 2 ] <SPC> or <SPC> p [ j <SPC> - <SPC> 2 ] <SPC> == <SPC> "." ) <NL>                  ) <NL> <NL> <TAB> return <SPC> result [ len ( s ) ] [ len ( p ) ] <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <NL> <TAB> def <SPC> isMatch ( self , <SPC> s , <SPC> p ) : <NL> <TAB> p_ptr , <SPC> s_ptr , <SPC> last_s_ptr , <SPC> last_p_ptr <SPC> = <SPC> 0 , <SPC> 0 , <SPC> - 1 , <SPC> - 1 <NL> <TAB> last_ptr <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> s_ptr <SPC> < <SPC> len ( s ) : <NL>          if <SPC> ( <NL>              p_ptr <SPC> < <SPC> len ( p ) <NL>              and <SPC> ( p_ptr <SPC> == <SPC> len ( p ) <SPC> - <SPC> 1 <SPC> or <SPC> p [ p_ptr <SPC> + <SPC> 1 ] <SPC> != <SPC> "*" ) <NL>              and <SPC> ( s_ptr <SPC> < <SPC> len ( s ) <SPC> and <SPC> ( p [ p_ptr ] <SPC> == <SPC> s [ s_ptr ] <SPC> or <SPC> p [ p_ptr ] <SPC> == <SPC> "." ) ) <NL>          ) : <NL>              s_ptr <SPC> += <SPC> 1 <NL>              p_ptr <SPC> += <SPC> 1 <NL>          elif <SPC> p_ptr <SPC> < <SPC> len ( p ) <SPC> - <SPC> 1 <SPC> and <SPC> ( p_ptr <SPC> != <SPC> len ( p ) <SPC> - <SPC> 1 <SPC> and <SPC> p [ p_ptr <SPC> + <SPC> 1 ] <SPC> == <SPC> "*" ) : <NL>              p_ptr <SPC> += <SPC> 2 <NL>              last_ptr . append ( [ s_ptr , <SPC> p_ptr ] ) <NL>          elif <SPC> last_ptr : <NL>              [ last_s_ptr , <SPC> last_p_ptr ] <SPC> = <SPC> last_ptr . pop ( ) <NL>              while <SPC> ( <NL>                  last_ptr <NL>                  and <SPC> p [ last_p_ptr <SPC> - <SPC> 2 ] <SPC> != <SPC> s [ last_s_ptr ] <NL>                  and <SPC> p [ last_p_ptr <SPC> - <SPC> 2 ] <SPC> != <SPC> "." <NL>              ) : <NL>                  [ last_s_ptr , <SPC> last_p_ptr ] <SPC> = <SPC> last_ptr . pop ( ) <NL> <NL>              if <SPC> p [ last_p_ptr <SPC> - <SPC> 2 ] <SPC> == <SPC> s [ last_s_ptr ] <SPC> or <SPC> p [ last_p_ptr <SPC> - <SPC> 2 ] <SPC> == <SPC> "." : <NL>                  last_s_ptr <SPC> += <SPC> 1 <NL>                  s_ptr <SPC> = <SPC> last_s_ptr <NL>                  p_ptr <SPC> = <SPC> last_p_ptr <NL>                  last_ptr . append ( [ s_ptr , <SPC> p_ptr ] ) <NL>              else : <NL>                  return <SPC> False <NL>          else : <NL>              return <SPC> False <NL> <NL> <TAB> while <SPC> p_ptr <SPC> < <SPC> len ( p ) <SPC> - <SPC> 1 <SPC> and <SPC> p [ p_ptr ] <SPC> == <SPC> "." <SPC> and <SPC> p [ p_ptr <SPC> + <SPC> 1 ] <SPC> == <SPC> "*" : <NL>          p_ptr <SPC> += <SPC> 2 <NL> <NL> <TAB> return <SPC> p_ptr <SPC> == <SPC> len ( p ) <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <NL> <TAB> def <SPC> isMatch ( self , <SPC> s , <SPC> p ) : <NL> <TAB> if <SPC> not <SPC> p : <NL>          return <SPC> not <SPC> s <NL> <NL> <TAB> if <SPC> len ( p ) <SPC> == <SPC> 1 <SPC> or <SPC> p [ 1 ] <SPC> != <SPC> "*" : <NL>          if <SPC> len ( s ) <SPC> > <SPC> 0 <SPC> and <SPC> ( p [ 0 ] <SPC> == <SPC> s [ 0 ] <SPC> or <SPC> p [ 0 ] <SPC> == <SPC> "." ) : <NL>              return <SPC> self . isMatch ( s [ 1 : ] , <SPC> p [ 1 : ] ) <NL>          else : <NL>              return <SPC> False <NL> <TAB> else : <NL>          while <SPC> len ( s ) <SPC> > <SPC> 0 <SPC> and <SPC> ( p [ 0 ] <SPC> == <SPC> s [ 0 ] <SPC> or <SPC> p [ 0 ] <SPC> == <SPC> "." ) : <NL>              if <SPC> self . isMatch ( s , <SPC> p [ 2 : ] ) : <NL>                  return <SPC> True <NL>              s <SPC> = <SPC> s [ 1 : ] <NL>          return <SPC> self . isMatch ( s , <SPC> p [ 2 : ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findRelativeRanks ( self , <SPC> nums ) : <NL> <NL> <TAB> sorted_nums <SPC> = <SPC> sorted ( nums ) [ : : - 1 ] <NL> <TAB> ranks <SPC> = <SPC> [ "Gold Medal" , <SPC> "Silver Medal" , <SPC> "Bronze Medal" ] <SPC> + <SPC> map ( <NL>          str , <SPC> range ( 4 , <SPC> len ( nums ) <SPC> + <SPC> 1 ) <NL> <TAB> ) <NL> <TAB> return <SPC> map ( dict ( zip ( sorted_nums , <SPC> ranks ) ) . get , <SPC> nums ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> relativeSortArray ( self , <SPC> arr1 , <SPC> arr2 ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { v : <SPC> i <SPC> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( arr2 ) } <NL> <TAB> return <SPC> sorted ( arr1 , <SPC> key = lambda <SPC> i : <SPC> lookup . get ( i , <SPC> len ( arr2 ) <SPC> + <SPC> i ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> newInteger ( self , <SPC> n ) : <NL> <NL> <TAB> result , <SPC> base <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> while <SPC> n <SPC> > <SPC> 0 : <NL>          result <SPC> += <SPC> ( n <SPC> % <SPC> 9 ) <SPC> * <SPC> base <NL>          n <SPC> /= <SPC> 9 <NL>          base <SPC> *= <SPC> 10 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeDuplicates ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> stk <SPC> = <SPC> [ [ "^" , <SPC> 0 ] ] <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          if <SPC> stk [ - 1 ] [ 0 ] <SPC> == <SPC> c : <NL>              stk [ - 1 ] [ 1 ] <SPC> += <SPC> 1 <NL>              if <SPC> stk [ - 1 ] [ 1 ] <SPC> == <SPC> k : <NL>                  stk . pop ( ) <NL>          else : <NL>              stk . append ( [ c , <SPC> 1 ] ) <NL> <TAB> return <SPC> "" . join ( c <SPC> * <SPC> k <SPC> for <SPC> c , <SPC> k <SPC> in <SPC> stk ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeDuplicates ( self , <SPC> S ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          if <SPC> result <SPC> and <SPC> result [ - 1 ] <SPC> == <SPC> c : <NL>              result . pop ( ) <NL>          else : <NL>              result . append ( c ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeBoxes ( self , <SPC> boxes ) : <NL> <NL> <TAB> def <SPC> dfs ( boxes , <SPC> l , <SPC> r , <SPC> k , <SPC> lookup ) : <NL>          if <SPC> l <SPC> > <SPC> r : <NL>              return <SPC> 0 <NL>          if <SPC> lookup [ l ] [ r ] [ k ] : <NL>              return <SPC> lookup [ l ] [ r ] [ k ] <NL> <NL>          ll , <SPC> kk <SPC> = <SPC> l , <SPC> k <NL>          while <SPC> l <SPC> < <SPC> r <SPC> and <SPC> boxes [ l <SPC> + <SPC> 1 ] <SPC> == <SPC> boxes [ l ] : <NL>              l <SPC> += <SPC> 1 <NL>              k <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> dfs ( boxes , <SPC> l <SPC> + <SPC> 1 , <SPC> r , <SPC> 0 , <SPC> lookup ) <SPC> + <SPC> ( k <SPC> + <SPC> 1 ) <SPC> ** <SPC> 2 <NL>          for <SPC> i <SPC> in <SPC> xrange ( l <SPC> + <SPC> 1 , <SPC> r <SPC> + <SPC> 1 ) : <NL>              if <SPC> boxes [ i ] <SPC> == <SPC> boxes [ l ] : <NL>                  result <SPC> = <SPC> max ( <NL>                      result , <NL>                      dfs ( boxes , <SPC> l <SPC> + <SPC> 1 , <SPC> i <SPC> - <SPC> 1 , <SPC> 0 , <SPC> lookup ) <NL>                      + <SPC> dfs ( boxes , <SPC> i , <SPC> r , <SPC> k <SPC> + <SPC> 1 , <SPC> lookup ) , <NL>                  ) <NL>          lookup [ ll ] [ r ] [ kk ] <SPC> = <SPC> result <NL>          return <SPC> result <NL> <NL> <TAB> lookup <SPC> = <SPC> [ <NL>          [ [ 0 ] <SPC> * <SPC> len ( boxes ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( boxes ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( boxes ) ) <NL> <TAB> ] <NL> <TAB> return <SPC> dfs ( boxes , <SPC> 0 , <SPC> len ( boxes ) <SPC> - <SPC> 1 , <SPC> 0 , <SPC> lookup ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeComments ( self , <SPC> source ) : <NL> <NL> <TAB> in_block <SPC> = <SPC> False <NL> <TAB> result , <SPC> newline <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> for <SPC> line <SPC> in <SPC> source : <NL>          i <SPC> = <SPC> 0 <NL>          while <SPC> i <SPC> < <SPC> len ( line ) : <NL>              if <SPC> not <SPC> in_block <SPC> and <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( line ) <SPC> and <SPC> line [ i : <SPC> i <SPC> + <SPC> 2 ] <SPC> == <SPC> "/*" : <NL>                  in_block <SPC> = <SPC> True <NL>                  i <SPC> += <SPC> 1 <NL>              elif <SPC> in_block <SPC> and <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( line ) <SPC> and <SPC> line [ i : <SPC> i <SPC> + <SPC> 2 ] <SPC> == <SPC> "*/" : <NL>                  in_block <SPC> = <SPC> False <NL>                  i <SPC> += <SPC> 1 <NL>              elif <SPC> not <SPC> in_block <SPC> and <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( line ) <SPC> and <SPC> line [ i : <SPC> i <SPC> + <SPC> 2 ] <SPC> == <SPC> "//" : <NL>                  break <NL>              elif <SPC> not <SPC> in_block : <NL>                  newline . append ( line [ i ] ) <NL>              i <SPC> += <SPC> 1 <NL>          if <SPC> newline <SPC> and <SPC> not <SPC> in_block : <NL>              result . append ( "" . join ( newline ) ) <NL>              newline <SPC> = <SPC> [ ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeCoveredIntervals ( self , <SPC> intervals ) : <NL> <NL> <TAB> intervals . sort ( key = lambda <SPC> x : <SPC> [ x [ 0 ] , <SPC> - x [ 1 ] ] ) <NL> <TAB> result , <SPC> max_right <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> left , <SPC> right <SPC> in <SPC> intervals : <NL>          result <SPC> += <SPC> int ( right <SPC> > <SPC> max_right ) <NL>          max_right <SPC> = <SPC> max ( max_right , <SPC> right ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> Counter <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeDuplicateLetters ( self , <SPC> s ) : <NL> <NL> <TAB> remaining <SPC> = <SPC> Counter ( s ) <NL> <NL> <TAB> in_stack , <SPC> stk <SPC> = <SPC> set ( ) , <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          if <SPC> c <SPC> not <SPC> in <SPC> in_stack : <NL>              while <SPC> stk <SPC> and <SPC> stk [ - 1 ] <SPC> > <SPC> c <SPC> and <SPC> remaining [ stk [ - 1 ] ] : <NL>                  in_stack . remove ( stk . pop ( ) ) <NL>              stk <SPC> += <SPC> c <NL>              in_stack . add ( c ) <NL>          remaining [ c ] <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> "" . join ( stk ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> removeDuplicates ( self , <SPC> A ) : <NL> <TAB> if <SPC> not <SPC> A : <NL>          return <SPC> 0 <NL> <NL> <TAB> last , <SPC> i , <SPC> same <SPC> = <SPC> 0 , <SPC> 1 , <SPC> False <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( A ) : <NL>          if <SPC> A [ last ] <SPC> != <SPC> A [ i ] <SPC> or <SPC> not <SPC> same : <NL>              same <SPC> = <SPC> A [ last ] <SPC> == <SPC> A [ i ] <NL>              last <SPC> += <SPC> 1 <NL>              A [ last ] <SPC> = <SPC> A [ i ] <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> last <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> removeDuplicates ( self , <SPC> A ) : <NL> <TAB> if <SPC> not <SPC> A : <NL>          return <SPC> 0 <NL> <NL> <TAB> last <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          if <SPC> A [ last ] <SPC> != <SPC> A [ i ] : <NL>              last <SPC> += <SPC> 1 <NL>              A [ last ] <SPC> = <SPC> A [ i ] <NL> <TAB> return <SPC> last <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self <SPC> is <SPC> None : <NL>          return <SPC> "Nil" <NL> <TAB> else : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> repr ( self . next ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> deleteDuplicates ( self , <SPC> head ) : <NL> <NL> <TAB> dummy <SPC> = <SPC> ListNode ( 0 ) <NL> <TAB> pre , <SPC> cur <SPC> = <SPC> dummy , <SPC> head <NL> <TAB> while <SPC> cur : <NL>          if <SPC> cur . next <SPC> and <SPC> cur . next . val <SPC> == <SPC> cur . val : <NL>              val <SPC> = <SPC> cur . val <NL>              while <SPC> cur <SPC> and <SPC> cur . val <SPC> == <SPC> val : <NL>                  cur <SPC> = <SPC> cur . next <NL>              pre . next <SPC> = <SPC> cur <NL>          else : <NL>              pre . next <SPC> = <SPC> cur <NL>              pre <SPC> = <SPC> cur <NL>              cur <SPC> = <SPC> cur . next <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> deleteDuplicates ( self , <SPC> head ) : <NL> <NL> <TAB> cur <SPC> = <SPC> head <NL> <TAB> while <SPC> cur : <NL>          runner <SPC> = <SPC> cur . next <NL>          while <SPC> runner <SPC> and <SPC> runner . val <SPC> == <SPC> cur . val : <NL>              runner <SPC> = <SPC> runner . next <NL>          cur . next <SPC> = <SPC> runner <NL>          cur <SPC> = <SPC> runner <NL> <TAB> return <SPC> head <NL> <NL> <TAB> def <SPC> deleteDuplicates2 ( self , <SPC> head ) : <NL> <NL> <TAB> if <SPC> not <SPC> head : <NL>          return <SPC> head <NL> <TAB> if <SPC> head . next : <NL>          if <SPC> head . val <SPC> == <SPC> head . next . val : <NL>              head <SPC> = <SPC> self . deleteDuplicates2 ( head . next ) <NL>          else : <NL>              head . next <SPC> = <SPC> self . deleteDuplicates2 ( head . next ) <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> removeElement ( self , <SPC> A , <SPC> elem ) : <NL> <TAB> i , <SPC> last <SPC> = <SPC> 0 , <SPC> len ( A ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> i <SPC> <= <SPC> last : <NL>          if <SPC> A [ i ] <SPC> == <SPC> elem : <NL>              A [ i ] , <SPC> A [ last ] <SPC> = <SPC> A [ last ] , <SPC> A [ i ] <NL>              last <SPC> -= <SPC> 1 <NL>          else : <NL>              i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> last <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeInterval ( self , <SPC> intervals , <SPC> toBeRemoved ) : <NL> <NL> <TAB> A , <SPC> B <SPC> = <SPC> toBeRemoved <NL> <TAB> return <SPC> [ <NL>          [ x , <SPC> y ] <NL>          for <SPC> a , <SPC> b <SPC> in <SPC> intervals <NL>          for <SPC> x , <SPC> y <SPC> in <SPC> ( ( a , <SPC> min ( A , <SPC> b ) ) , <SPC> ( max ( a , <SPC> B ) , <SPC> b ) ) <NL>          if <SPC> x <SPC> < <SPC> y <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeInvalidParentheses ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> findMinRemove ( s ) : <NL>          left_removed , <SPC> right_removed <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> s : <NL>              if <SPC> c <SPC> == <SPC> "(" : <NL>                  left_removed <SPC> += <SPC> 1 <NL>              elif <SPC> c <SPC> == <SPC> ")" : <NL>                  if <SPC> not <SPC> left_removed : <NL>                      right_removed <SPC> += <SPC> 1 <NL>                  else : <NL>                      left_removed <SPC> -= <SPC> 1 <NL>          return <SPC> ( left_removed , <SPC> right_removed ) <NL> <NL> <TAB> def <SPC> isValid ( s ) : <NL>          sum <SPC> = <SPC> 0 <NL>          for <SPC> c <SPC> in <SPC> s : <NL>              if <SPC> c <SPC> == <SPC> "(" : <NL>                  sum <SPC> += <SPC> 1 <NL>              elif <SPC> c <SPC> == <SPC> ")" : <NL>                  sum <SPC> -= <SPC> 1 <NL>              if <SPC> sum <SPC> < <SPC> 0 : <NL>                  return <SPC> False <NL>          return <SPC> sum <SPC> == <SPC> 0 <NL> <NL> <TAB> def <SPC> removeInvalidParenthesesHelper ( start , <SPC> left_removed , <SPC> right_removed ) : <NL>          if <SPC> left_removed <SPC> == <SPC> 0 <SPC> and <SPC> right_removed <SPC> == <SPC> 0 : <NL>              tmp <SPC> = <SPC> "" <NL>              for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>                  if <SPC> i <SPC> not <SPC> in <SPC> removed : <NL>                      tmp <SPC> += <SPC> c <NL>              if <SPC> isValid ( tmp ) : <NL>                  res . append ( tmp ) <NL>              return <NL> <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> len ( s ) ) : <NL>              if <SPC> right_removed <SPC> == <SPC> 0 <SPC> and <SPC> left_removed <SPC> > <SPC> 0 <SPC> and <SPC> s [ i ] <SPC> == <SPC> "(" : <NL>                  if <SPC> i <SPC> == <SPC> start <SPC> or <SPC> s [ i ] <SPC> != <SPC> s [ i <SPC> - <SPC> 1 ] : <NL>                      removed [ i ] <SPC> = <SPC> True <NL>                      removeInvalidParenthesesHelper ( <NL>                          i <SPC> + <SPC> 1 , <SPC> left_removed <SPC> - <SPC> 1 , <SPC> right_removed <NL>                      ) <NL>                      del <SPC> removed [ i ] <NL>              elif <SPC> right_removed <SPC> > <SPC> 0 <SPC> and <SPC> s [ i ] <SPC> == <SPC> ")" : <NL>                  if <SPC> i <SPC> == <SPC> start <SPC> or <SPC> s [ i ] <SPC> != <SPC> s [ i <SPC> - <SPC> 1 ] : <NL>                      removed [ i ] <SPC> = <SPC> True <NL>                      removeInvalidParenthesesHelper ( <NL>                          i <SPC> + <SPC> 1 , <SPC> left_removed , <SPC> right_removed <SPC> - <SPC> 1 <NL>                      ) <NL>                      del <SPC> removed [ i ] <NL> <NL> <TAB> res , <SPC> removed <SPC> = <SPC> [ ] , <SPC> { } <NL> <TAB> ( left_removed , <SPC> right_removed ) <SPC> = <SPC> findMinRemove ( s ) <NL> <TAB> removeInvalidParenthesesHelper ( 0 , <SPC> left_removed , <SPC> right_removed ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeKdigits ( self , <SPC> num , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> d <SPC> in <SPC> num : <NL>          while <SPC> k <SPC> and <SPC> result <SPC> and <SPC> result [ - 1 ] <SPC> > <SPC> d : <NL>              result . pop ( ) <NL>              k <SPC> -= <SPC> 1 <NL>          result . append ( d ) <NL> <TAB> return <SPC> "" . join ( result ) . lstrip ( "0" ) [ : <SPC> - k <SPC> or <SPC> None ] <SPC> or <SPC> "0" <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> removeElements ( self , <SPC> head , <SPC> val ) : <NL> <TAB> dummy <SPC> = <SPC> ListNode ( float ( "-inf" ) ) <NL> <TAB> dummy . next <SPC> = <SPC> head <NL> <TAB> prev , <SPC> curr <SPC> = <SPC> dummy , <SPC> dummy . next <NL> <NL> <TAB> while <SPC> curr : <NL>          if <SPC> curr . val <SPC> == <SPC> val : <NL>              prev . next <SPC> = <SPC> curr . next <NL>          else : <NL>              prev <SPC> = <SPC> curr <NL> <NL>          curr <SPC> = <SPC> curr . next <NL> <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . count <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ max ( x_root , <SPC> y_root ) ] <SPC> = <SPC> min ( x_root , <SPC> y_root ) <NL> <TAB> self . count <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxNumEdgesToRemove ( self , <SPC> n , <SPC> edges ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> union_find_a , <SPC> union_find_b <SPC> = <SPC> UnionFind ( n ) , <SPC> UnionFind ( n ) <NL> <TAB> for <SPC> t , <SPC> i , <SPC> j <SPC> in <SPC> edges : <NL>          if <SPC> t <SPC> != <SPC> 3 : <NL>              continue <NL>          a <SPC> = <SPC> union_find_a . union_set ( i <SPC> - <SPC> 1 , <SPC> j <SPC> - <SPC> 1 ) <NL>          b <SPC> = <SPC> union_find_b . union_set ( i <SPC> - <SPC> 1 , <SPC> j <SPC> - <SPC> 1 ) <NL>          if <SPC> not <SPC> a <SPC> and <SPC> not <SPC> b : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> for <SPC> t , <SPC> i , <SPC> j <SPC> in <SPC> edges : <NL>          if <SPC> t <SPC> == <SPC> 1 : <NL>              if <SPC> not <SPC> union_find_a . union_set ( i <SPC> - <SPC> 1 , <SPC> j <SPC> - <SPC> 1 ) : <NL>                  result <SPC> += <SPC> 1 <NL>          elif <SPC> t <SPC> == <SPC> 2 : <NL>              if <SPC> not <SPC> union_find_b . union_set ( i <SPC> - <SPC> 1 , <SPC> j <SPC> - <SPC> 1 ) : <NL>                  result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <SPC> if <SPC> union_find_a . count <SPC> == <SPC> union_find_b . count <SPC> == <SPC> 1 <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self <SPC> is <SPC> None : <NL>          return <SPC> "Nil" <NL> <TAB> else : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> repr ( self . next ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> removeNthFromEnd ( self , <SPC> head , <SPC> n ) : <NL> <TAB> dummy <SPC> = <SPC> ListNode ( - 1 ) <NL> <TAB> dummy . next <SPC> = <SPC> head <NL> <TAB> slow , <SPC> fast <SPC> = <SPC> dummy , <SPC> dummy <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          fast <SPC> = <SPC> fast . next <NL> <NL> <TAB> while <SPC> fast . next : <NL>          slow , <SPC> fast <SPC> = <SPC> slow . next , <SPC> fast . next <NL> <NL> <TAB> slow . next <SPC> = <SPC> slow . next . next <NL> <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeOuterParentheses ( self , <SPC> S ) : <NL> <NL> <TAB> deep <SPC> = <SPC> 1 <NL> <TAB> result , <SPC> cnt <SPC> = <SPC> [ ] , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          if <SPC> c <SPC> == <SPC> "(" <SPC> and <SPC> cnt <SPC> >= <SPC> deep : <NL>              result . append ( c ) <NL>          if <SPC> c <SPC> == <SPC> ")" <SPC> and <SPC> cnt <SPC> > <SPC> deep : <NL>              result . append ( c ) <NL>          cnt <SPC> += <SPC> 1 <SPC> if <SPC> c <SPC> == <SPC> "(" <SPC> else <SPC> - 1 <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removePalindromeSub ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> is_palindrome ( s ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> // <SPC> 2 ) : <NL>              if <SPC> s [ i ] <SPC> != <SPC> s [ - 1 <SPC> - <SPC> i ] : <NL>                  return <SPC> False <NL>          return <SPC> True <NL> <NL> <TAB> return <SPC> 2 <SPC> - <SPC> is_palindrome ( s ) <SPC> - <SPC> ( s <SPC> == <SPC> "" ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeSubfolders ( self , <SPC> folder ) : <NL> <NL> <TAB> def <SPC> dfs ( curr , <SPC> path , <SPC> result ) : <NL>          if <SPC> "_end" <SPC> in <SPC> curr : <NL>              result . append ( "/" <SPC> + <SPC> "/" . join ( path ) ) <NL>              return <NL>          for <SPC> c <SPC> in <SPC> curr : <NL>              if <SPC> c <SPC> == <SPC> "_end" : <NL>                  continue <NL>              path . append ( c ) <NL>              dfs ( curr [ c ] , <SPC> path , <SPC> result ) <NL>              path . pop ( ) <NL> <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> trie <SPC> = <SPC> _trie ( ) <NL> <TAB> for <SPC> f <SPC> in <SPC> folder : <NL>          f_list <SPC> = <SPC> f . split ( "/" ) <NL>          reduce ( <NL>              dict . __getitem__ , <SPC> itertools . islice ( f_list , <SPC> 1 , <SPC> len ( f_list ) ) , <SPC> trie <NL>          ) . setdefault ( "_end" ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> dfs ( trie , <SPC> [ ] , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeVowels ( self , <SPC> S ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( "aeiou" ) <NL> <TAB> return <SPC> "" . join ( c <SPC> for <SPC> c <SPC> in <SPC> S <SPC> if <SPC> c <SPC> not <SPC> in <SPC> lookup ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> removeZeroSumSublists ( self , <SPC> head ) : <NL> <NL> <TAB> curr <SPC> = <SPC> dummy <SPC> = <SPC> ListNode ( 0 ) <NL> <TAB> dummy . next <SPC> = <SPC> head <NL> <TAB> prefix <SPC> = <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> collections . OrderedDict ( ) <NL> <TAB> while <SPC> curr : <NL>          prefix <SPC> += <SPC> curr . val <NL>          node <SPC> = <SPC> lookup . get ( prefix , <SPC> curr ) <NL>          while <SPC> prefix <SPC> in <SPC> lookup : <NL>              lookup . popitem ( ) <NL>          lookup [ prefix ] <SPC> = <SPC> node <NL>          node . next <SPC> = <SPC> curr . next <NL>          curr <SPC> = <SPC> curr . next <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> repr ( self . next ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> reorderList ( self , <SPC> head ) : <NL> <TAB> if <SPC> head <SPC> == <SPC> None <SPC> or <SPC> head . next <SPC> == <SPC> None : <NL>          return <SPC> head <NL> <NL> <TAB> fast , <SPC> slow , <SPC> prev <SPC> = <SPC> head , <SPC> head , <SPC> None <NL> <TAB> while <SPC> fast <SPC> != <SPC> None <SPC> and <SPC> fast . next <SPC> != <SPC> None : <NL>          fast , <SPC> slow , <SPC> prev <SPC> = <SPC> fast . next . next , <SPC> slow . next , <SPC> slow <NL> <TAB> current , <SPC> prev . next , <SPC> prev <SPC> = <SPC> slow , <SPC> None , <SPC> None <NL> <NL> <TAB> while <SPC> current <SPC> != <SPC> None : <NL>          current . next , <SPC> prev , <SPC> current <SPC> = <SPC> prev , <SPC> current , <SPC> current . next <NL> <NL> <TAB> l1 , <SPC> l2 <SPC> = <SPC> head , <SPC> prev <NL> <TAB> dummy <SPC> = <SPC> ListNode ( 0 ) <NL> <TAB> current <SPC> = <SPC> dummy <NL> <NL> <TAB> while <SPC> l1 <SPC> != <SPC> None <SPC> and <SPC> l2 <SPC> != <SPC> None : <NL>          current . next , <SPC> current , <SPC> l1 <SPC> = <SPC> l1 , <SPC> l1 , <SPC> l1 . next <NL>          current . next , <SPC> current , <SPC> l2 <SPC> = <SPC> l2 , <SPC> l2 , <SPC> l2 . next <NL> <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reorderLogFiles ( self , <SPC> logs ) : <NL> <NL> <TAB> def <SPC> f ( log ) : <NL>          i , <SPC> content <SPC> = <SPC> log . split ( " " , <SPC> 1 ) <NL>          return <SPC> ( 0 , <SPC> content , <SPC> i ) <SPC> if <SPC> content [ 0 ] . isalpha ( ) <SPC> else <SPC> ( 1 , ) <NL> <NL> <TAB> logs . sort ( key = f ) <NL> <TAB> return <SPC> logs <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minReorder ( self , <SPC> n , <SPC> connections ) : <NL> <NL> <TAB> lookup , <SPC> graph <SPC> = <SPC> set ( ) , <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> connections : <NL>          lookup . add ( u <SPC> * <SPC> n <SPC> + <SPC> v ) <NL>          graph [ v ] . append ( u ) <NL>          graph [ u ] . append ( v ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> stk <SPC> = <SPC> [ ( - 1 , <SPC> 0 ) ] <NL> <TAB> while <SPC> stk : <NL>          parent , <SPC> u <SPC> = <SPC> stk . pop ( ) <NL>          result <SPC> += <SPC> parent <SPC> * <SPC> n <SPC> + <SPC> u <SPC> in <SPC> lookup <NL>          for <SPC> v <SPC> in <SPC> reversed ( graph [ u ] ) : <NL>              if <SPC> v <SPC> == <SPC> parent : <NL>                  continue <NL>              stk . append ( ( u , <SPC> v ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> minReorder ( self , <SPC> n , <SPC> connections ) : <NL> <NL> <TAB> def <SPC> dfs ( n , <SPC> lookup , <SPC> graph , <SPC> parent , <SPC> u ) : <NL>          result <SPC> = <SPC> parent <SPC> * <SPC> n <SPC> + <SPC> u <SPC> in <SPC> lookup <NL>          for <SPC> v <SPC> in <SPC> graph [ u ] : <NL>              if <SPC> v <SPC> == <SPC> parent : <NL>                  continue <NL>              result <SPC> += <SPC> dfs ( n , <SPC> lookup , <SPC> graph , <SPC> u , <SPC> v ) <NL>          return <SPC> result <NL> <NL> <TAB> lookup , <SPC> graph <SPC> = <SPC> set ( ) , <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> connections : <NL>          lookup . add ( u <SPC> * <SPC> n <SPC> + <SPC> v ) <NL>          graph [ v ] . append ( u ) <NL>          graph [ u ] . append ( v ) <NL> <TAB> return <SPC> dfs ( n , <SPC> lookup , <SPC> graph , <SPC> - 1 , <SPC> 0 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reorderedPowerOf2 ( self , <SPC> N ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( str ( N ) ) <NL> <TAB> return <SPC> any ( count <SPC> == <SPC> collections . Counter ( str ( 1 <SPC> << <SPC> i ) ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( 31 ) ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reorganizeString ( self , <SPC> S ) : <NL> <NL> <TAB> counts <SPC> = <SPC> collections . Counter ( S ) <NL> <TAB> if <SPC> any ( v <SPC> > <SPC> ( len ( S ) <SPC> + <SPC> 1 ) <SPC> / <SPC> 2 <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> counts . iteritems ( ) ) : <NL>          return <SPC> "" <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> max_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> k , <SPC> v <SPC> in <SPC> counts . iteritems ( ) : <NL>          heapq . heappush ( max_heap , <SPC> ( - v , <SPC> k ) ) <NL> <TAB> while <SPC> len ( max_heap ) <SPC> > <SPC> 1 : <NL>          count1 , <SPC> c1 <SPC> = <SPC> heapq . heappop ( max_heap ) <NL>          count2 , <SPC> c2 <SPC> = <SPC> heapq . heappop ( max_heap ) <NL>          if <SPC> not <SPC> result <SPC> or <SPC> c1 <SPC> != <SPC> result [ - 1 ] : <NL>              result . extend ( [ c1 , <SPC> c2 ] ) <NL>              if <SPC> count1 <SPC> + <SPC> 1 : <NL>                  heapq . heappush ( max_heap , <SPC> ( count1 <SPC> + <SPC> 1 , <SPC> c1 ) ) <NL>              if <SPC> count2 <SPC> + <SPC> 1 : <NL>                  heapq . heappush ( max_heap , <SPC> ( count2 <SPC> + <SPC> 1 , <SPC> c2 ) ) <NL> <TAB> return <SPC> "" . join ( result ) <SPC> + <SPC> ( max_heap [ 0 ] [ 1 ] <SPC> if <SPC> max_heap <SPC> else <SPC> "" ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findRepeatedDnaSequences ( self , <SPC> s ) : <NL> <NL> <TAB> dict , <SPC> rolling_hash , <SPC> res <SPC> = <SPC> { } , <SPC> 0 , <SPC> [ ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          rolling_hash <SPC> = <SPC> ( ( rolling_hash <SPC> << <SPC> 3 ) <SPC> & <SPC> 0x3FFFFFFF ) <SPC> | <SPC> ( ord ( s [ i ] ) <SPC> & <SPC> 7 ) <NL>          if <SPC> rolling_hash <SPC> not <SPC> in <SPC> dict : <NL>              dict [ rolling_hash ] <SPC> = <SPC> True <NL>          elif <SPC> dict [ rolling_hash ] : <NL>              res . append ( s [ i <SPC> - <SPC> 9 : <SPC> i <SPC> + <SPC> 1 ] ) <NL>              dict [ rolling_hash ] <SPC> = <SPC> False <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> findRepeatedDnaSequences2 ( self , <SPC> s ) : <NL> <NL> <TAB> l , <SPC> r <SPC> = <SPC> [ ] , <SPC> [ ] <NL> <TAB> if <SPC> len ( s ) <SPC> < <SPC> 10 : <NL>          return <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( len ( s ) <SPC> - <SPC> 9 ) : <NL>          l . extend ( [ s [ i : <SPC> i <SPC> + <SPC> 10 ] ] ) <NL> <TAB> return <SPC> [ k <SPC> for <SPC> k , <SPC> v <SPC> in <SPC> collections . Counter ( l ) . items ( ) <SPC> if <SPC> v <SPC> > <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> repeatedStringMatch ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> def <SPC> check ( index ) : <NL>          return <SPC> all ( A [ ( i <SPC> + <SPC> index ) <SPC> % <SPC> len ( A ) ] <SPC> == <SPC> c <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( B ) ) <NL> <NL> <TAB> M , <SPC> p <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 , <SPC> 113 <NL> <TAB> p_inv <SPC> = <SPC> pow ( p , <SPC> M <SPC> - <SPC> 2 , <SPC> M ) <NL> <TAB> q <SPC> = <SPC> ( len ( B ) <SPC> + <SPC> len ( A ) <SPC> - <SPC> 1 ) <SPC> // <SPC> len ( A ) <NL> <NL> <TAB> b_hash , <SPC> power <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> c <SPC> in <SPC> B : <NL>          b_hash <SPC> += <SPC> power <SPC> * <SPC> ord ( c ) <NL>          b_hash <SPC> %= <SPC> M <NL>          power <SPC> = <SPC> ( power <SPC> * <SPC> p ) <SPC> % <SPC> M <NL> <NL> <TAB> a_hash , <SPC> power <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( B ) ) : <NL>          a_hash <SPC> += <SPC> power <SPC> * <SPC> ord ( A [ i <SPC> % <SPC> len ( A ) ] ) <NL>          a_hash <SPC> %= <SPC> M <NL>          power <SPC> = <SPC> ( power <SPC> * <SPC> p ) <SPC> % <SPC> M <NL> <NL> <TAB> if <SPC> a_hash <SPC> == <SPC> b_hash <SPC> and <SPC> check ( 0 ) : <NL>          return <SPC> q <NL> <NL> <TAB> power <SPC> = <SPC> ( power <SPC> * <SPC> p_inv ) <SPC> % <SPC> M <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( B ) , <SPC> ( q <SPC> + <SPC> 1 ) <SPC> * <SPC> len ( A ) ) : <NL>          a_hash <SPC> = <SPC> ( a_hash <SPC> - <SPC> ord ( A [ ( i <SPC> - <SPC> len ( B ) ) <SPC> % <SPC> len ( A ) ] ) ) <SPC> * <SPC> p_inv <NL>          a_hash <SPC> += <SPC> power <SPC> * <SPC> ord ( A [ i <SPC> % <SPC> len ( A ) ] ) <NL>          a_hash <SPC> %= <SPC> M <NL>          if <SPC> a_hash <SPC> == <SPC> b_hash <SPC> and <SPC> check ( i <SPC> - <SPC> len ( B ) <SPC> + <SPC> 1 ) : <NL>              return <SPC> q <SPC> if <SPC> i <SPC> < <SPC> q <SPC> * <SPC> len ( A ) <SPC> else <SPC> q <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> repeatedSubstringPattern ( self , <SPC> str ) : <NL> <NL> <TAB> def <SPC> getPrefix ( pattern ) : <NL>          prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>              while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              prefix [ i ] <SPC> = <SPC> j <NL>          return <SPC> prefix <NL> <NL> <TAB> prefix <SPC> = <SPC> getPrefix ( str ) <NL> <TAB> return <SPC> prefix [ - 1 ] <SPC> != <SPC> - 1 <SPC> and <SPC> ( prefix [ - 1 ] <SPC> + <SPC> 1 ) <SPC> % <SPC> ( len ( str ) <SPC> - <SPC> prefix [ - 1 ] <SPC> - <SPC> 1 ) <SPC> == <SPC> 0 <NL> <NL> <TAB> def <SPC> repeatedSubstringPattern2 ( self , <SPC> str ) : <NL> <NL> <TAB> if <SPC> not <SPC> str : <NL>          return <SPC> False <NL> <NL> <TAB> ss <SPC> = <SPC> ( str <SPC> + <SPC> str ) [ 1 : - 1 ] <NL> <TAB> return <SPC> ss . find ( str ) <SPC> != <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> modifyString ( self , <SPC> s ) : <NL> <NL> <TAB> s <SPC> = <SPC> list ( s ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> s [ i ] <SPC> != <SPC> "?" : <NL>              continue <NL>          for <SPC> c <SPC> in <SPC> ( "a" , <SPC> "b" , <SPC> "c" ) : <NL>              if <SPC> ( i <SPC> == <SPC> 0 <SPC> or <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> != <SPC> c ) <SPC> and <SPC> ( i <SPC> == <SPC> len ( s ) <SPC> - <SPC> 1 <SPC> or <SPC> c <SPC> != <SPC> s [ i <SPC> + <SPC> 1 ] ) : <NL>                  break <NL>          s [ i ] <SPC> = <SPC> c <NL> <TAB> return <SPC> "" . join ( s ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> replaceElements ( self , <SPC> arr ) : <NL> <NL> <TAB> curr_max <SPC> = <SPC> - 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( arr ) ) ) : <NL>          arr [ i ] , <SPC> curr_max <SPC> = <SPC> curr_max , <SPC> max ( curr_max , <SPC> arr [ i ] ) <NL> <TAB> return <SPC> arr <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> balancedString ( self , <SPC> s ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( s ) <NL> <TAB> result <SPC> = <SPC> len ( s ) <NL> <TAB> left <SPC> = <SPC> 0 <NL> <TAB> for <SPC> right <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          count [ s [ right ] ] <SPC> -= <SPC> 1 <NL>          while <SPC> left <SPC> < <SPC> len ( s ) <SPC> and <SPC> all ( v <SPC> <= <SPC> len ( s ) <SPC> // <SPC> 4 <SPC> for <SPC> v <SPC> in <SPC> count . itervalues ( ) ) : <NL>              result <SPC> = <SPC> min ( result , <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 ) <NL>              count [ s [ left ] ] <SPC> += <SPC> 1 <NL>              left <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> replaceWords ( self , <SPC> dictionary , <SPC> sentence ) : <NL> <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> trie <SPC> = <SPC> _trie ( ) <NL> <TAB> for <SPC> word <SPC> in <SPC> dictionary : <NL>          reduce ( dict . __getitem__ , <SPC> word , <SPC> trie ) . setdefault ( "_end" ) <NL> <NL> <TAB> def <SPC> replace ( word ) : <NL>          curr <SPC> = <SPC> trie <NL>          for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( word ) : <NL>              if <SPC> c <SPC> not <SPC> in <SPC> curr : <NL>                  break <NL>              curr <SPC> = <SPC> curr [ c ] <NL>              if <SPC> "_end" <SPC> in <SPC> curr : <NL>                  return <SPC> word [ : <SPC> i <SPC> + <SPC> 1 ] <NL>          return <SPC> word <NL> <NL> <TAB> return <SPC> " " . join ( map ( replace , <SPC> sentence . split ( ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> matrixReshape ( self , <SPC> nums , <SPC> r , <SPC> c ) : <NL> <NL> <TAB> if <SPC> not <SPC> nums <SPC> or <SPC> r <SPC> * <SPC> c <SPC> != <SPC> len ( nums ) <SPC> * <SPC> len ( nums [ 0 ] ) : <NL>          return <SPC> nums <NL> <NL> <TAB> result <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( c ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( r ) ] <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( nums [ 0 ] ) ) : <NL>              result [ count <SPC> / <SPC> c ] [ count <SPC> % <SPC> c ] <SPC> = <SPC> nums [ i ] [ j ] <NL>              count <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> restoreIpAddresses ( self , <SPC> s ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> self . restoreIpAddressesRecur ( result , <SPC> s , <SPC> 0 , <SPC> "" , <SPC> 0 ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> restoreIpAddressesRecur ( self , <SPC> result , <SPC> s , <SPC> start , <SPC> current , <SPC> dots ) : <NL> <NL> <TAB> if <SPC> ( 4 <SPC> - <SPC> dots ) <SPC> * <SPC> 3 <SPC> < <SPC> len ( s ) <SPC> - <SPC> start <SPC> or <SPC> ( 4 <SPC> - <SPC> dots ) <SPC> > <SPC> len ( s ) <SPC> - <SPC> start : <NL>          return <NL> <NL> <TAB> if <SPC> start <SPC> == <SPC> len ( s ) <SPC> and <SPC> dots <SPC> == <SPC> 4 : <NL>          result . append ( current [ : - 1 ] ) <NL> <TAB> else : <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> start <SPC> + <SPC> 3 ) : <NL>              if <SPC> len ( s ) <SPC> > <SPC> i <SPC> and <SPC> self . isValid ( s [ start : <SPC> i <SPC> + <SPC> 1 ] ) : <NL>                  current <SPC> += <SPC> s [ start : <SPC> i <SPC> + <SPC> 1 ] <SPC> + <SPC> "." <NL>                  self . restoreIpAddressesRecur ( <NL>                      result , <SPC> s , <SPC> i <SPC> + <SPC> 1 , <SPC> current , <SPC> dots <SPC> + <SPC> 1 ) <NL>                  current <SPC> = <SPC> current [ : <SPC> - ( i <SPC> - <SPC> start <SPC> + <SPC> 2 ) ] <NL> <NL> <TAB> def <SPC> isValid ( self , <SPC> s ) : <NL> <TAB> if <SPC> len ( s ) <SPC> == <SPC> 0 <SPC> or <SPC> ( s [ 0 ] <SPC> == <SPC> "0" <SPC> and <SPC> s <SPC> != <SPC> "0" ) : <NL>          return <SPC> False <NL> <TAB> return <SPC> int ( s ) <SPC> < <SPC> 256 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> restoreArray ( self , <SPC> adjacentPairs ) : <NL> <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> adjacentPairs : <NL>          adj [ u ] . append ( v ) <NL>          adj [ v ] . append ( u ) <NL> <TAB> result <SPC> = <SPC> next ( [ x , <SPC> adj [ x ] [ 0 ] ] <SPC> for <SPC> x <SPC> in <SPC> adj <SPC> if <SPC> len ( adj [ x ] ) <SPC> == <SPC> 1 ) <NL> <TAB> while <SPC> len ( result ) <SPC> != <SPC> len ( adjacentPairs ) <SPC> + <SPC> 1 : <NL>          result . append ( adj [ result [ - 1 ] ] [ adj [ result [ - 1 ] ] [ 0 ] <SPC> == <SPC> result [ - 2 ] ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numberOfArrays ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <TAB> klen <SPC> = <SPC> len ( str ( k ) ) <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( klen <SPC> + <SPC> 1 ) <NL> <TAB> dp [ len ( s ) <SPC> % <SPC> len ( dp ) ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>          dp [ i <SPC> % <SPC> len ( dp ) ] <SPC> = <SPC> 0 <NL>          if <SPC> s [ i ] <SPC> == <SPC> "0" : <NL>              continue <NL>          curr <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> min ( i <SPC> + <SPC> klen , <SPC> len ( s ) ) ) : <NL>              curr <SPC> = <SPC> 10 <SPC> * <SPC> curr <SPC> + <SPC> int ( s [ j ] ) <NL>              if <SPC> curr <SPC> > <SPC> k : <NL>                  break <NL>              dp [ i <SPC> % <SPC> len ( dp ) ] <SPC> = <SPC> ( dp [ i <SPC> % <SPC> len ( dp ) ] <SPC> + <SPC> dp [ ( j <SPC> + <SPC> 1 ) <SPC> % <SPC> len ( dp ) ] ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> dp [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> deckRevealedIncreasing ( self , <SPC> deck ) : <NL> <NL> <TAB> d <SPC> = <SPC> collections . deque ( ) <NL> <TAB> deck . sort ( reverse = True ) <NL> <TAB> for <SPC> i <SPC> in <SPC> deck : <NL>          if <SPC> d : <NL>              d . appendleft ( d . pop ( ) ) <NL>          d . appendleft ( i ) <NL> <TAB> return <SPC> list ( d ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> reverseBits ( self , <SPC> n ) : <NL> <TAB> n <SPC> = <SPC> ( n <SPC> >> <SPC> 16 ) <SPC> | <SPC> ( n <SPC> << <SPC> 16 ) <NL> <TAB> n <SPC> = <SPC> ( ( n <SPC> & <SPC> 0xFF00FF00 ) <SPC> >> <SPC> 8 ) <SPC> | <SPC> ( ( n <SPC> & <SPC> 0x00FF00FF ) <SPC> << <SPC> 8 ) <NL> <TAB> n <SPC> = <SPC> ( ( n <SPC> & <SPC> 0xF0F0F0F0 ) <SPC> >> <SPC> 4 ) <SPC> | <SPC> ( ( n <SPC> & <SPC> 0x0F0F0F0F ) <SPC> << <SPC> 4 ) <NL> <TAB> n <SPC> = <SPC> ( ( n <SPC> & <SPC> 0xCCCCCCCC ) <SPC> >> <SPC> 2 ) <SPC> | <SPC> ( ( n <SPC> & <SPC> 0x33333333 ) <SPC> << <SPC> 2 ) <NL> <TAB> n <SPC> = <SPC> ( ( n <SPC> & <SPC> 0xAAAAAAAA ) <SPC> >> <SPC> 1 ) <SPC> | <SPC> ( ( n <SPC> & <SPC> 0x55555555 ) <SPC> << <SPC> 1 ) <NL> <TAB> return <SPC> n <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> reverseBits ( self , <SPC> n ) : <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 32 ) : <NL>          result <SPC> <<= <SPC> 1 <NL>          result <SPC> |= <SPC> n <SPC> & <SPC> 1 <NL>          n <SPC> >>= <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverse ( self , <SPC> x ) : <NL> <NL> <TAB> if <SPC> x <SPC> < <SPC> 0 : <NL>          return <SPC> - self . reverse ( - x ) <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> x : <NL>          result <SPC> = <SPC> result <SPC> * <SPC> 10 <SPC> + <SPC> x <SPC> % <SPC> 10 <NL>          x <SPC> //= <SPC> 10 <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> <= <SPC> 0x7FFFFFFF <SPC> else <SPC> 0 <NL> <NL> <TAB> def <SPC> reverse2 ( self , <SPC> x ) : <NL> <NL> <TAB> if <SPC> x <SPC> < <SPC> 0 : <NL>          x <SPC> = <SPC> int ( str ( x ) [ : : - 1 ] [ - 1 ] <SPC> + <SPC> str ( x ) [ : : - 1 ] [ : - 1 ] ) <NL> <TAB> else : <NL>          x <SPC> = <SPC> int ( str ( x ) [ : : - 1 ] ) <NL> <TAB> x <SPC> = <SPC> 0 <SPC> if <SPC> abs ( x ) <SPC> > <SPC> 0x7FFFFFFF <SPC> else <SPC> x <NL> <TAB> return <SPC> x <NL> <NL> <TAB> def <SPC> reverse3 ( self , <SPC> x ) : <NL> <NL> <TAB> s <SPC> = <SPC> cmp ( x , <SPC> 0 ) <NL> <TAB> r <SPC> = <SPC> int ( repr ( s <SPC> * <SPC> x ) [ : : - 1 ] ) <NL> <TAB> return <SPC> s <SPC> * <SPC> r <SPC> * <SPC> ( r <SPC> < <SPC> 2 <SPC> ** <SPC> 31 ) <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> repr ( self . next ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> reverseBetween ( self , <SPC> head , <SPC> m , <SPC> n ) : <NL> <TAB> diff , <SPC> dummy , <SPC> cur <SPC> = <SPC> n <SPC> - <SPC> m <SPC> + <SPC> 1 , <SPC> ListNode ( - 1 ) , <SPC> head <NL> <TAB> dummy . next <SPC> = <SPC> head <NL> <NL> <TAB> last_unswapped <SPC> = <SPC> dummy <NL> <TAB> while <SPC> cur <SPC> and <SPC> m <SPC> > <SPC> 1 : <NL>          cur , <SPC> last_unswapped , <SPC> m <SPC> = <SPC> cur . next , <SPC> cur , <SPC> m <SPC> - <SPC> 1 <NL> <NL> <TAB> prev , <SPC> first_swapped <SPC> = <SPC> last_unswapped , <SPC> cur <NL> <TAB> while <SPC> cur <SPC> and <SPC> diff <SPC> > <SPC> 0 : <NL>          cur . next , <SPC> prev , <SPC> cur , <SPC> diff <SPC> = <SPC> prev , <SPC> cur , <SPC> cur . next , <SPC> diff <SPC> - <SPC> 1 <NL> <NL> <TAB> last_unswapped . next , <SPC> first_swapped . next <SPC> = <SPC> prev , <SPC> cur <NL> <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> repr ( self . next ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> reverseList ( self , <SPC> head ) : <NL> <TAB> dummy <SPC> = <SPC> ListNode ( float ( "-inf" ) ) <NL> <TAB> while <SPC> head : <NL>          dummy . next , <SPC> head . next , <SPC> head <SPC> = <SPC> head , <SPC> dummy . next , <SPC> head . next <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> reverseList ( self , <SPC> head ) : <NL> <TAB> [ begin , <SPC> end ] <SPC> = <SPC> self . reverseListRecu ( head ) <NL> <TAB> return <SPC> begin <NL> <NL> <TAB> def <SPC> reverseListRecu ( self , <SPC> head ) : <NL> <TAB> if <SPC> not <SPC> head : <NL>          return <SPC> [ None , <SPC> None ] <NL> <NL> <TAB> [ begin , <SPC> end ] <SPC> = <SPC> self . reverseListRecu ( head . next ) <NL> <NL> <TAB> if <SPC> end : <NL>          end . next <SPC> = <SPC> head <NL>          head . next <SPC> = <SPC> None <NL>          return <SPC> [ begin , <SPC> head ] <NL> <TAB> else : <NL>          return <SPC> [ head , <SPC> head ] <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> repr ( self . next ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> reverseKGroup ( self , <SPC> head , <SPC> k ) : <NL> <TAB> dummy <SPC> = <SPC> ListNode ( - 1 ) <NL> <TAB> dummy . next <SPC> = <SPC> head <NL> <NL> <TAB> cur , <SPC> cur_dummy <SPC> = <SPC> head , <SPC> dummy <NL> <TAB> length <SPC> = <SPC> 0 <NL> <NL> <TAB> while <SPC> cur : <NL>          next_cur <SPC> = <SPC> cur . next <NL>          length <SPC> = <SPC> ( length <SPC> + <SPC> 1 ) <SPC> % <SPC> k <NL> <NL>          if <SPC> length <SPC> == <SPC> 0 : <NL>              next_dummy <SPC> = <SPC> cur_dummy . next <NL>              self . reverse ( cur_dummy , <SPC> cur . next ) <NL>              cur_dummy <SPC> = <SPC> next_dummy <NL> <NL>          cur <SPC> = <SPC> next_cur <NL> <NL> <TAB> return <SPC> dummy . next <NL> <NL> <TAB> def <SPC> reverse ( self , <SPC> begin , <SPC> end ) : <NL> <TAB> first <SPC> = <SPC> begin . next <NL> <TAB> cur <SPC> = <SPC> first . next <NL> <NL> <TAB> while <SPC> cur <SPC> != <SPC> end : <NL>          first . next <SPC> = <SPC> cur . next <NL>          cur . next <SPC> = <SPC> begin . next <NL>          begin . next <SPC> = <SPC> cur <NL>          cur <SPC> = <SPC> first . next <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseOnlyLetters ( self , <SPC> S ) : <NL> <NL> <TAB> def <SPC> getNext ( S ) : <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( S ) ) ) : <NL>              if <SPC> S [ i ] . isalpha ( ) : <NL>                  yield <SPC> S [ i ] <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> letter <SPC> = <SPC> getNext ( S ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( S ) ) : <NL>          if <SPC> S [ i ] . isalpha ( ) : <NL>              result . append ( letter . next ( ) ) <NL>          else : <NL>              result . append ( S [ i ] ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reversePairs ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> merge ( nums , <SPC> start , <SPC> mid , <SPC> end ) : <NL>          r <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          tmp <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> mid <SPC> + <SPC> 1 ) : <NL>              while <SPC> r <SPC> <= <SPC> end <SPC> and <SPC> nums [ i ] <SPC> > <SPC> nums [ r ] : <NL>                  tmp . append ( nums [ r ] ) <NL>                  r <SPC> += <SPC> 1 <NL>              tmp . append ( nums [ i ] ) <NL>          nums [ start : <SPC> start <SPC> + <SPC> len ( tmp ) ] <SPC> = <SPC> tmp <NL> <NL> <TAB> def <SPC> countAndMergeSort ( nums , <SPC> start , <SPC> end ) : <NL>          if <SPC> end <SPC> - <SPC> start <SPC> <= <SPC> 0 : <NL>              return <SPC> 0 <NL> <NL>          mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> / <SPC> 2 <NL>          count <SPC> = <SPC> countAndMergeSort ( nums , <SPC> start , <SPC> mid ) <SPC> + <SPC> countAndMergeSort ( <NL>              nums , <SPC> mid <SPC> + <SPC> 1 , <SPC> end <NL>          ) <NL>          r <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> mid <SPC> + <SPC> 1 ) : <NL>              while <SPC> r <SPC> <= <SPC> end <SPC> and <SPC> nums [ i ] <SPC> > <SPC> nums [ r ] <SPC> * <SPC> 2 : <NL>                  r <SPC> += <SPC> 1 <NL>              count <SPC> += <SPC> r <SPC> - <SPC> ( mid <SPC> + <SPC> 1 ) <NL>          merge ( nums , <SPC> start , <SPC> mid , <SPC> end ) <NL>          return <SPC> count <NL> <NL> <TAB> return <SPC> countAndMergeSort ( nums , <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseStr ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> s <SPC> = <SPC> list ( s ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 0 , <SPC> len ( s ) , <SPC> 2 <SPC> * <SPC> k ) : <NL>          s [ i : <SPC> i <SPC> + <SPC> k ] <SPC> = <SPC> reversed ( s [ i : <SPC> i <SPC> + <SPC> k ] ) <NL> <TAB> return <SPC> "" . join ( s ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseString ( self , <SPC> s ) : <NL> <NL> <TAB> string <SPC> = <SPC> list ( s ) <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> len ( string ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> j : <NL>          string [ i ] , <SPC> string [ j ] <SPC> = <SPC> string [ j ] , <SPC> string [ i ] <NL>          i <SPC> += <SPC> 1 <NL>          j <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> "" . join ( string ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> reverseString ( self , <SPC> s ) : <NL> <NL> <TAB> return <SPC> s [ : : - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxValueAfterReverse ( self , <SPC> nums ) : <NL> <NL> <TAB> result , <SPC> add , <SPC> max_pair , <SPC> min_pair <SPC> = <SPC> 0 , <SPC> 0 , <SPC> float ( "-inf" ) , <SPC> float ( "inf" ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( nums ) ) : <NL>          result <SPC> += <SPC> abs ( nums [ i <SPC> - <SPC> 1 ] <SPC> - <SPC> nums [ i ] ) <NL>          add <SPC> = <SPC> max ( <NL>              add , <NL>              abs ( nums [ 0 ] <SPC> - <SPC> nums [ i ] ) <SPC> - <SPC> abs ( nums [ i <SPC> - <SPC> 1 ] <SPC> - <SPC> nums [ i ] ) , <NL>              abs ( nums [ - 1 ] <SPC> - <SPC> nums [ i <SPC> - <SPC> 1 ] ) <SPC> - <SPC> abs ( nums [ i <SPC> - <SPC> 1 ] <SPC> - <SPC> nums [ i ] ) , <NL>          ) <NL>          min_pair <SPC> = <SPC> min ( min_pair , <SPC> max ( nums [ i <SPC> - <SPC> 1 ] , <SPC> nums [ i ] ) ) <NL>          max_pair <SPC> = <SPC> max ( max_pair , <SPC> min ( nums [ i <SPC> - <SPC> 1 ] , <SPC> nums [ i ] ) ) <NL> <TAB> return <SPC> result <SPC> + <SPC> max ( add , <SPC> ( max_pair <SPC> - <SPC> min_pair ) <SPC> * <SPC> 2 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseParentheses ( self , <SPC> s ) : <NL> <NL> <TAB> stk , <SPC> lookup <SPC> = <SPC> [ ] , <SPC> { } <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( s ) : <NL>          if <SPC> c <SPC> == <SPC> "(" : <NL>              stk . append ( i ) <NL>          elif <SPC> c <SPC> == <SPC> ")" : <NL>              j <SPC> = <SPC> stk . pop ( ) <NL>              lookup [ i ] , <SPC> lookup [ j ] <SPC> = <SPC> j , <SPC> i <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i , <SPC> d <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( s ) : <NL>          if <SPC> i <SPC> in <SPC> lookup : <NL>              i <SPC> = <SPC> lookup [ i ] <NL>              d <SPC> *= <SPC> - 1 <NL>          else : <NL>              result . append ( s [ i ] ) <NL>          i <SPC> += <SPC> d <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> reverseParentheses ( self , <SPC> s ) : <NL> <NL> <TAB> stk <SPC> = <SPC> [ [ ] ] <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          if <SPC> c <SPC> == <SPC> "(" : <NL>              stk . append ( [ ] ) <NL>          elif <SPC> c <SPC> == <SPC> ")" : <NL>              end <SPC> = <SPC> stk . pop ( ) <NL>              end . reverse ( ) <NL>              stk [ - 1 ] . extend ( end ) <NL>          else : <NL>              stk [ - 1 ] . append ( c ) <NL> <TAB> return <SPC> "" . join ( stk . pop ( ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseVowels ( self , <SPC> s ) : <NL> <NL> <TAB> vowels <SPC> = <SPC> "aeiou" <NL> <TAB> string <SPC> = <SPC> list ( s ) <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> len ( s ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> j : <NL>          if <SPC> string [ i ] . lower ( ) <SPC> not <SPC> in <SPC> vowels : <NL>              i <SPC> += <SPC> 1 <NL>          elif <SPC> string [ j ] . lower ( ) <SPC> not <SPC> in <SPC> vowels : <NL>              j <SPC> -= <SPC> 1 <NL>          else : <NL>              string [ i ] , <SPC> string [ j ] <SPC> = <SPC> string [ j ] , <SPC> string [ i ] <NL>              i <SPC> += <SPC> 1 <NL>              j <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> "" . join ( string ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseWords ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> reverse ( s , <SPC> begin , <SPC> end ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( ( end <SPC> - <SPC> begin ) <SPC> / <SPC> 2 ) : <NL>              s [ begin <SPC> + <SPC> i ] , <SPC> s [ end <SPC> - <SPC> 1 <SPC> - <SPC> i ] <SPC> = <SPC> s [ end <SPC> - <SPC> 1 <SPC> - <SPC> i ] , <SPC> s [ begin <SPC> + <SPC> i ] <NL> <NL> <TAB> reverse ( s , <SPC> 0 , <SPC> len ( s ) ) <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( s ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> j <SPC> == <SPC> len ( s ) <SPC> or <SPC> s [ j ] <SPC> == <SPC> " " : <NL>              reverse ( s , <SPC> i , <SPC> j ) <NL>              i <SPC> = <SPC> j <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> reverseWords ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> reverse ( s , <SPC> begin , <SPC> end ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( ( end <SPC> - <SPC> begin ) <SPC> // <SPC> 2 ) : <NL>              s [ begin <SPC> + <SPC> i ] , <SPC> s [ end <SPC> - <SPC> 1 <SPC> - <SPC> i ] <SPC> = <SPC> s [ end <SPC> - <SPC> 1 <SPC> - <SPC> i ] , <SPC> s [ begin <SPC> + <SPC> i ] <NL> <NL> <TAB> s , <SPC> i <SPC> = <SPC> list ( s ) , <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( s ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> j <SPC> == <SPC> len ( s ) <SPC> or <SPC> s [ j ] <SPC> == <SPC> " " : <NL>              reverse ( s , <SPC> i , <SPC> j ) <NL>              i <SPC> = <SPC> j <SPC> + <SPC> 1 <NL> <TAB> return <SPC> "" . join ( s ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> reverseWords ( self , <SPC> s ) : <NL> <TAB> reversed_words <SPC> = <SPC> [ word [ : : - 1 ] <SPC> for <SPC> word <SPC> in <SPC> s . split ( " " ) ] <NL> <TAB> return <SPC> " " . join ( reversed_words ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> reverseWords ( self , <SPC> s ) : <NL> <TAB> return <SPC> " " . join ( reversed ( s . split ( ) ) ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maximumWealth ( self , <SPC> accounts ) : <NL> <NL> <TAB> return <SPC> max ( itertools . imap ( sum , <SPC> accounts ) ) <NL> <NL> <NL> class <SPC> RLEIterator ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> A ) : <NL> <NL> <TAB> self . __A <SPC> = <SPC> A <NL> <TAB> self . __i <SPC> = <SPC> 0 <NL> <TAB> self . __cnt <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> next ( self , <SPC> n ) : <NL> <NL> <TAB> while <SPC> self . __i <SPC> < <SPC> len ( self . __A ) : <NL>          if <SPC> n <SPC> > <SPC> self . __A [ self . __i ] <SPC> - <SPC> self . __cnt : <NL>              n <SPC> -= <SPC> self . __A [ self . __i ] <SPC> - <SPC> self . __cnt <NL>              self . __cnt <SPC> = <SPC> 0 <NL>              self . __i <SPC> += <SPC> 2 <NL>          else : <NL>              self . __cnt <SPC> += <SPC> n <NL>              return <SPC> self . __A [ self . __i <SPC> + <SPC> 1 ] <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isRobotBounded ( self , <SPC> instructions ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ [ 1 , <SPC> 0 ] , <SPC> [ 0 , <SPC> - 1 ] , <SPC> [ - 1 , <SPC> 0 ] , <SPC> [ 0 , <SPC> 1 ] ] <NL> <TAB> x , <SPC> y , <SPC> i <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> instruction <SPC> in <SPC> instructions : <NL>          if <SPC> instruction <SPC> == <SPC> "R" : <NL>              i <SPC> = <SPC> ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 4 <NL>          elif <SPC> instruction <SPC> == <SPC> "L" : <NL>              i <SPC> = <SPC> ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 4 <NL>          else : <NL>              x <SPC> += <SPC> directions [ i ] [ 0 ] <NL>              y <SPC> += <SPC> directions [ i ] [ 1 ] <NL> <TAB> return <SPC> ( x <SPC> == <SPC> 0 <SPC> and <SPC> y <SPC> == <SPC> 0 ) <SPC> or <SPC> i <SPC> > <SPC> 0 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> judgeCircle ( self , <SPC> moves ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( moves ) <NL> <TAB> return <SPC> count [ "L" ] <SPC> == <SPC> count [ "R" ] <SPC> and <SPC> count [ "U" ] <SPC> == <SPC> count [ "D" ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> judgeCircle ( self , <SPC> moves ) : <NL> <NL> <TAB> v , <SPC> h <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> move <SPC> in <SPC> moves : <NL>          if <SPC> move <SPC> == <SPC> "U" : <NL>              v <SPC> += <SPC> 1 <NL>          elif <SPC> move <SPC> == <SPC> "D" : <NL>              v <SPC> -= <SPC> 1 <NL>          elif <SPC> move <SPC> == <SPC> "R" : <NL>              h <SPC> += <SPC> 1 <NL>          elif <SPC> move <SPC> == <SPC> "L" : <NL>              h <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> v <SPC> == <SPC> 0 <SPC> and <SPC> h <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> cleanRoom ( self , <SPC> robot ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> goBack ( robot ) : <NL>          robot . turnLeft ( ) <NL>          robot . turnLeft ( ) <NL>          robot . move ( ) <NL>          robot . turnRight ( ) <NL>          robot . turnRight ( ) <NL> <NL> <TAB> def <SPC> dfs ( pos , <SPC> robot , <SPC> d , <SPC> lookup ) : <NL>          robot . clean ( ) <NL>          for <SPC> _ <SPC> in <SPC> directions : <NL>              new_pos <SPC> = <SPC> ( pos [ 0 ] <SPC> + <SPC> directions [ d ] [ 0 ] , <SPC> pos [ 1 ] <SPC> + <SPC> directions [ d ] [ 1 ] ) <NL>              if <SPC> new_pos <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup . add ( new_pos ) <NL>                  if <SPC> robot . move ( ) : <NL>                      dfs ( new_pos , <SPC> robot , <SPC> d , <SPC> lookup ) <NL>                      goBack ( robot ) <NL>              robot . turnRight ( ) <NL>              d <SPC> = <SPC> ( d <SPC> + <SPC> 1 ) <SPC> % <SPC> len ( directions ) <NL> <NL> <TAB> dfs ( ( 0 , <SPC> 0 ) , <SPC> robot , <SPC> 0 , <SPC> set ( ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> romanToInt ( self , <SPC> s ) : <NL> <TAB> numeral_map <SPC> = <SPC> { "I" : <SPC> 1 , <SPC> "V" : <SPC> 5 , <SPC> "X" : <SPC> 10 , <NL>                     "L" : <SPC> 50 , <SPC> "C" : <SPC> 100 , <SPC> "D" : <SPC> 500 , <SPC> "M" : <SPC> 1000 } <NL> <TAB> decimal <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> i <SPC> > <SPC> 0 <SPC> and <SPC> numeral_map [ s [ i ] ] <SPC> > <SPC> numeral_map [ s [ i <SPC> - <SPC> 1 ] ] : <NL>              decimal <SPC> += <SPC> numeral_map [ s [ i ] ] <SPC> - <SPC> 2 <SPC> * <SPC> numeral_map [ s [ i <SPC> - <SPC> 1 ] ] <NL>          else : <NL>              decimal <SPC> += <SPC> numeral_map [ s [ i ] ] <NL> <TAB> return <SPC> decimal <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> rotate ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> reverse ( nums , <SPC> start , <SPC> end ) : <NL>          while <SPC> start <SPC> < <SPC> end : <NL>              nums [ start ] , <SPC> nums [ end <SPC> - <SPC> 1 ] <SPC> = <SPC> nums [ end <SPC> - <SPC> 1 ] , <SPC> nums [ start ] <NL>              start <SPC> += <SPC> 1 <NL>              end <SPC> -= <SPC> 1 <NL> <NL> <TAB> k <SPC> %= <SPC> len ( nums ) <NL> <TAB> reverse ( nums , <SPC> 0 , <SPC> len ( nums ) ) <NL> <TAB> reverse ( nums , <SPC> 0 , <SPC> k ) <NL> <TAB> reverse ( nums , <SPC> k , <SPC> len ( nums ) ) <NL> <NL> <NL> from <SPC> fractions <SPC> import <SPC> gcd <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> rotate ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> apply_cycle_permutation ( k , <SPC> offset , <SPC> cycle_len , <SPC> nums ) : <NL>          tmp <SPC> = <SPC> nums [ offset ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> cycle_len ) : <NL>              nums [ ( offset <SPC> + <SPC> i <SPC> * <SPC> k ) <SPC> % <SPC> len ( nums ) ] , <SPC> tmp <SPC> = <SPC> ( <NL>                  tmp , <NL>                  nums [ ( offset <SPC> + <SPC> i <SPC> * <SPC> k ) <SPC> % <SPC> len ( nums ) ] , <NL>              ) <NL>          nums [ offset ] <SPC> = <SPC> tmp <NL> <NL> <TAB> k <SPC> %= <SPC> len ( nums ) <NL> <TAB> num_cycles <SPC> = <SPC> gcd ( len ( nums ) , <SPC> k ) <NL> <TAB> cycle_len <SPC> = <SPC> len ( nums ) <SPC> / <SPC> num_cycles <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( num_cycles ) : <NL>          apply_cycle_permutation ( k , <SPC> i , <SPC> cycle_len , <SPC> nums ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <NL> <TAB> def <SPC> rotate ( self , <SPC> nums , <SPC> k ) : <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> start <SPC> = <SPC> 0 <NL> <TAB> while <SPC> count <SPC> < <SPC> len ( nums ) : <NL>          curr <SPC> = <SPC> start <NL>          prev <SPC> = <SPC> nums [ curr ] <NL>          while <SPC> True : <NL>              idx <SPC> = <SPC> ( curr <SPC> + <SPC> k ) <SPC> % <SPC> len ( nums ) <NL>              nums [ idx ] , <SPC> prev <SPC> = <SPC> prev , <SPC> nums [ idx ] <NL>              curr <SPC> = <SPC> idx <NL>              count <SPC> += <SPC> 1 <NL>              if <SPC> start <SPC> == <SPC> curr : <NL>                  break <NL>          start <SPC> += <SPC> 1 <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <NL> <TAB> def <SPC> rotate ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> nums [ : ] <SPC> = <SPC> nums [ len ( nums ) <SPC> - <SPC> k : ] <SPC> + <SPC> nums [ : <SPC> len ( nums ) <SPC> - <SPC> k ] <NL> <NL> <NL> class <SPC> Solution5 ( object ) : <NL> <NL> <TAB> def <SPC> rotate ( self , <SPC> nums , <SPC> k ) : <NL> <TAB> while <SPC> k <SPC> > <SPC> 0 : <NL>          nums . insert ( 0 , <SPC> nums . pop ( ) ) <NL>          k <SPC> -= <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxRotateFunction ( self , <SPC> A ) : <NL> <NL> <TAB> s <SPC> = <SPC> sum ( A ) <NL> <TAB> fi <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          fi <SPC> += <SPC> i <SPC> * <SPC> A [ i ] <NL> <NL> <TAB> result <SPC> = <SPC> fi <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) <SPC> + <SPC> 1 ) : <NL>          fi <SPC> += <SPC> s <SPC> - <SPC> len ( A ) <SPC> * <SPC> A [ - i ] <NL>          result <SPC> = <SPC> max ( result , <SPC> fi ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> rotate ( self , <SPC> matrix ) : <NL> <TAB> n <SPC> = <SPC> len ( matrix ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n <SPC> - <SPC> i ) : <NL>              matrix [ i ] [ j ] , <SPC> matrix [ n <SPC> - <SPC> 1 <SPC> - <SPC> j ] [ n <SPC> - <SPC> 1 <SPC> - <SPC> i ] <SPC> = <SPC> ( <NL>                  matrix [ n <SPC> - <SPC> 1 <SPC> - <SPC> j ] [ n <SPC> - <SPC> 1 <SPC> - <SPC> i ] , <NL>                  matrix [ i ] [ j ] , <NL>              ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n <SPC> / <SPC> 2 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              matrix [ i ] [ j ] , <SPC> matrix [ n <SPC> - <SPC> 1 <SPC> - <NL>                                   i ] [ j ] <SPC> = <SPC> matrix [ n <SPC> - <SPC> 1 <SPC> - <SPC> i ] [ j ] , <SPC> matrix [ i ] [ j ] <NL> <NL> <TAB> return <SPC> matrix <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> rotate ( self , <SPC> matrix ) : <NL> <TAB> return <SPC> [ list ( reversed ( x ) ) <SPC> for <SPC> x <SPC> in <SPC> zip ( * matrix ) ] <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> repr ( self . next ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rotateRight ( self , <SPC> head , <SPC> k ) : <NL> <NL> <TAB> if <SPC> not <SPC> head <SPC> or <SPC> not <SPC> head . next : <NL>          return <SPC> head <NL> <NL> <TAB> n , <SPC> cur <SPC> = <SPC> 1 , <SPC> head <NL> <TAB> while <SPC> cur . next : <NL>          cur <SPC> = <SPC> cur . next <NL>          n <SPC> += <SPC> 1 <NL> <TAB> cur . next <SPC> = <SPC> head <NL> <NL> <TAB> cur , <SPC> tail <SPC> = <SPC> head , <SPC> cur <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( n <SPC> - <SPC> k <SPC> % <SPC> n ) : <NL>          tail <SPC> = <SPC> cur <NL>          cur <SPC> = <SPC> cur . next <NL> <TAB> tail . next <SPC> = <SPC> None <NL> <NL> <TAB> return <SPC> cur <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rotateString ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> def <SPC> check ( index ) : <NL>          return <SPC> all ( A [ ( i <SPC> + <SPC> index ) <SPC> % <SPC> len ( A ) ] <SPC> == <SPC> c <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( B ) ) <NL> <NL> <TAB> if <SPC> len ( A ) <SPC> != <SPC> len ( B ) : <NL>          return <SPC> False <NL> <NL> <TAB> M , <SPC> p <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 , <SPC> 113 <NL> <TAB> p_inv <SPC> = <SPC> pow ( p , <SPC> M <SPC> - <SPC> 2 , <SPC> M ) <NL> <NL> <TAB> b_hash , <SPC> power <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> c <SPC> in <SPC> B : <NL>          b_hash <SPC> += <SPC> power <SPC> * <SPC> ord ( c ) <NL>          b_hash <SPC> %= <SPC> M <NL>          power <SPC> = <SPC> ( power <SPC> * <SPC> p ) <SPC> % <SPC> M <NL> <NL> <TAB> a_hash , <SPC> power <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( B ) ) : <NL>          a_hash <SPC> += <SPC> power <SPC> * <SPC> ord ( A [ i <SPC> % <SPC> len ( A ) ] ) <NL>          a_hash <SPC> %= <SPC> M <NL>          power <SPC> = <SPC> ( power <SPC> * <SPC> p ) <SPC> % <SPC> M <NL> <NL> <TAB> if <SPC> a_hash <SPC> == <SPC> b_hash <SPC> and <SPC> check ( 0 ) : <NL>          return <SPC> True <NL> <NL> <TAB> power <SPC> = <SPC> ( power <SPC> * <SPC> p_inv ) <SPC> % <SPC> M <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( B ) , <SPC> 2 <SPC> * <SPC> len ( A ) ) : <NL>          a_hash <SPC> = <SPC> ( a_hash <SPC> - <SPC> ord ( A [ ( i <SPC> - <SPC> len ( B ) ) <SPC> % <SPC> len ( A ) ] ) ) <SPC> * <SPC> p_inv <NL>          a_hash <SPC> += <SPC> power <SPC> * <SPC> ord ( A [ i <SPC> % <SPC> len ( A ) ] ) <NL>          a_hash <SPC> %= <SPC> M <NL>          if <SPC> a_hash <SPC> == <SPC> b_hash <SPC> and <SPC> check ( i <SPC> - <SPC> len ( B ) <SPC> + <SPC> 1 ) : <NL>              return <SPC> True <NL> <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> rotateString ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> def <SPC> strStr ( haystack , <SPC> needle ) : <NL>          def <SPC> KMP ( text , <SPC> pattern ) : <NL>              prefix <SPC> = <SPC> getPrefix ( pattern ) <NL>              j <SPC> = <SPC> - 1 <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( text ) ) : <NL>                  while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> text [ i ] : <NL>                      j <SPC> = <SPC> prefix [ j ] <NL>                  if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> text [ i ] : <NL>                      j <SPC> += <SPC> 1 <NL>                  if <SPC> j <SPC> == <SPC> len ( pattern ) <SPC> - <SPC> 1 : <NL>                      return <SPC> i <SPC> - <SPC> j <NL>              return <SPC> - 1 <NL> <NL>          def <SPC> getPrefix ( pattern ) : <NL>              prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL>              j <SPC> = <SPC> - 1 <NL>              for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>                  while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>                      j <SPC> = <SPC> prefix [ j ] <NL>                  if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>                      j <SPC> += <SPC> 1 <NL>                  prefix [ i ] <SPC> = <SPC> j <NL>              return <SPC> prefix <NL> <NL>          if <SPC> not <SPC> needle : <NL>              return <SPC> 0 <NL>          return <SPC> KMP ( haystack , <SPC> needle ) <NL> <NL> <TAB> if <SPC> len ( A ) <SPC> != <SPC> len ( B ) : <NL>          return <SPC> False <NL> <TAB> return <SPC> strStr ( A <SPC> * <SPC> 2 , <SPC> B ) <SPC> != <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> rotateString ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> return <SPC> len ( A ) <SPC> == <SPC> len ( B ) <SPC> and <SPC> B <SPC> in <SPC> A <SPC> * <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> rotatedDigits ( self , <SPC> N ) : <NL> <NL> <TAB> A <SPC> = <SPC> map ( int , <SPC> str ( N ) ) <NL> <TAB> invalid , <SPC> diff <SPC> = <SPC> set ( [ 3 , <SPC> 4 , <SPC> 7 ] ) , <SPC> set ( [ 2 , <SPC> 5 , <SPC> 6 , <SPC> 9 ] ) <NL> <NL> <TAB> def <SPC> dp ( A , <SPC> i , <SPC> is_prefix_equal , <SPC> is_good , <SPC> lookup ) : <NL>          if <SPC> i <SPC> == <SPC> len ( A ) : <NL>              return <SPC> int ( is_good ) <NL>          if <SPC> ( i , <SPC> is_prefix_equal , <SPC> is_good ) <SPC> not <SPC> in <SPC> lookup : <NL>              result <SPC> = <SPC> 0 <NL>              for <SPC> d <SPC> in <SPC> xrange ( A [ i ] <SPC> + <SPC> 1 <SPC> if <SPC> is_prefix_equal <SPC> else <SPC> 10 ) : <NL>                  if <SPC> d <SPC> in <SPC> invalid : <NL>                      continue <NL>                  result <SPC> += <SPC> dp ( <NL>                      A , <NL>                      i <SPC> + <SPC> 1 , <NL>                      is_prefix_equal <SPC> and <SPC> d <SPC> == <SPC> A [ i ] , <NL>                      is_good <SPC> or <SPC> d <SPC> in <SPC> diff , <NL>                      lookup , <NL>                  ) <NL>              lookup [ i , <SPC> is_prefix_equal , <SPC> is_good ] <SPC> = <SPC> result <NL>          return <SPC> lookup [ i , <SPC> is_prefix_equal , <SPC> is_good ] <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> return <SPC> dp ( A , <SPC> 0 , <SPC> True , <SPC> False , <SPC> lookup ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> rotatedDigits ( self , <SPC> N ) : <NL> <NL> <TAB> INVALID , <SPC> SAME , <SPC> DIFF <SPC> = <SPC> 0 , <SPC> 1 , <SPC> 2 <NL> <TAB> same , <SPC> diff <SPC> = <SPC> [ 0 , <SPC> 1 , <SPC> 8 ] , <SPC> [ 2 , <SPC> 5 , <SPC> 6 , <SPC> 9 ] <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( N <SPC> + <SPC> 1 ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> SAME <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N <SPC> // <SPC> 10 <SPC> + <SPC> 1 ) : <NL>          if <SPC> dp [ i ] <SPC> != <SPC> INVALID : <NL>              for <SPC> j <SPC> in <SPC> same : <NL>                  if <SPC> i <SPC> * <SPC> 10 <SPC> + <SPC> j <SPC> <= <SPC> N : <NL>                      dp [ i <SPC> * <SPC> 10 <SPC> + <SPC> j ] <SPC> = <SPC> max ( SAME , <SPC> dp [ i ] ) <NL>              for <SPC> j <SPC> in <SPC> diff : <NL>                  if <SPC> i <SPC> * <SPC> 10 <SPC> + <SPC> j <SPC> <= <SPC> N : <NL>                      dp [ i <SPC> * <SPC> 10 <SPC> + <SPC> j ] <SPC> = <SPC> DIFF <NL> <TAB> return <SPC> dp . count ( DIFF ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> rotatedDigits ( self , <SPC> N ) : <NL> <NL> <TAB> invalid , <SPC> diff <SPC> = <SPC> set ( [ "3" , <SPC> "4" , <SPC> "7" ] ) , <SPC> set ( [ "2" , <SPC> "5" , <SPC> "6" , <SPC> "9" ] ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N <SPC> + <SPC> 1 ) : <NL>          lookup <SPC> = <SPC> set ( list ( str ( i ) ) ) <NL>          if <SPC> invalid <SPC> & <SPC> lookup : <NL>              continue <NL>          if <SPC> diff <SPC> & <SPC> lookup : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> orangesRotting ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( grid ) : <NL>          for <SPC> c , <SPC> val <SPC> in <SPC> enumerate ( row ) : <NL>              if <SPC> val <SPC> == <SPC> 2 : <NL>                  q . append ( ( r , <SPC> c , <SPC> 0 ) ) <NL>              elif <SPC> val <SPC> == <SPC> 1 : <NL>                  count <SPC> += <SPC> 1 <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> q : <NL>          r , <SPC> c , <SPC> result <SPC> = <SPC> q . popleft ( ) <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> d [ 0 ] , <SPC> c <SPC> + <SPC> d [ 1 ] <NL>              if <SPC> not <SPC> ( 0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ r ] ) ) : <NL>                  continue <NL>              if <SPC> grid [ nr ] [ nc ] <SPC> == <SPC> 1 : <NL>                  count <SPC> -= <SPC> 1 <NL>                  grid [ nr ] [ nc ] <SPC> = <SPC> 2 <NL>                  q . append ( ( nr , <SPC> nc , <SPC> result <SPC> + <SPC> 1 ) ) <NL> <TAB> return <SPC> result <SPC> if <SPC> count <SPC> == <SPC> 0 <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> runningSum ( self , <SPC> nums ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) <SPC> - <SPC> 1 ) : <NL>          nums [ i <SPC> + <SPC> 1 ] <SPC> += <SPC> nums [ i ] <NL> <TAB> return <SPC> nums <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxEnvelopes ( self , <SPC> envelopes ) : <NL> <NL> <TAB> def <SPC> insert ( target ) : <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( result ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>              if <SPC> result [ mid ] <SPC> >= <SPC> target : <NL>                  right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          if <SPC> left <SPC> == <SPC> len ( result ) : <NL>              result . append ( target ) <NL>          else : <NL>              result [ left ] <SPC> = <SPC> target <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <NL> <TAB> envelopes . sort ( lambda <SPC> x , <SPC> y : <SPC> y [ 1 ] <SPC> - <SPC> x [ 1 ] <SPC> if <SPC> x [ 0 ] <SPC> == <SPC> y [ 0 ] <SPC> else <SPC> x [ 0 ] <SPC> - <SPC> y [ 0 ] ) <NL> <TAB> for <SPC> envelope <SPC> in <SPC> envelopes : <NL>          insert ( envelope [ 1 ] ) <NL> <NL> <TAB> return <SPC> len ( result ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isSameTree ( self , <SPC> p , <SPC> q ) : <NL> <TAB> if <SPC> p <SPC> is <SPC> None <SPC> and <SPC> q <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <NL> <TAB> if <SPC> p <SPC> is <SPC> not <SPC> None <SPC> and <SPC> q <SPC> is <SPC> not <SPC> None : <NL>          return <SPC> ( <NL>              p . val <SPC> == <SPC> q . val <NL>              and <SPC> self . isSameTree ( p . left , <SPC> q . left ) <NL>              and <SPC> self . isSameTree ( p . right , <SPC> q . right ) <NL>          ) <NL> <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> equationsPossible ( self , <SPC> equations ) : <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( 26 ) <NL> <TAB> for <SPC> eqn <SPC> in <SPC> equations : <NL>          x <SPC> = <SPC> ord ( eqn [ 0 ] ) <SPC> - <SPC> ord ( "a" ) <NL>          y <SPC> = <SPC> ord ( eqn [ 3 ] ) <SPC> - <SPC> ord ( "a" ) <NL>          if <SPC> eqn [ 1 ] <SPC> == <SPC> "=" : <NL>              union_find . union_set ( x , <SPC> y ) <NL> <TAB> for <SPC> eqn <SPC> in <SPC> equations : <NL>          x <SPC> = <SPC> ord ( eqn [ 0 ] ) <SPC> - <SPC> ord ( "a" ) <NL>          y <SPC> = <SPC> ord ( eqn [ 3 ] ) <SPC> - <SPC> ord ( "a" ) <NL>          if <SPC> eqn [ 1 ] <SPC> == <SPC> "!" : <NL>              if <SPC> union_find . find_set ( x ) <SPC> == <SPC> union_find . find_set ( y ) : <NL>                  return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> equationsPossible ( self , <SPC> equations ) : <NL> <NL> <TAB> graph <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 26 ) ] <NL> <NL> <TAB> for <SPC> eqn <SPC> in <SPC> equations : <NL>          x <SPC> = <SPC> ord ( eqn [ 0 ] ) <SPC> - <SPC> ord ( "a" ) <NL>          y <SPC> = <SPC> ord ( eqn [ 3 ] ) <SPC> - <SPC> ord ( "a" ) <NL>          if <SPC> eqn [ 1 ] <SPC> == <SPC> "!" : <NL>              if <SPC> x <SPC> == <SPC> y : <NL>                  return <SPC> False <NL>          else : <NL>              graph [ x ] . append ( y ) <NL>              graph [ y ] . append ( x ) <NL> <NL> <TAB> color <SPC> = <SPC> [ None ] <SPC> * <SPC> 26 <NL> <TAB> c <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 26 ) : <NL>          if <SPC> color [ i ] <SPC> is <SPC> not <SPC> None : <NL>              continue <NL>          c <SPC> += <SPC> 1 <NL>          stack <SPC> = <SPC> [ i ] <NL>          while <SPC> stack : <NL>              node <SPC> = <SPC> stack . pop ( ) <NL>              for <SPC> nei <SPC> in <SPC> graph [ node ] : <NL>                  if <SPC> color [ nei ] <SPC> is <SPC> not <SPC> None : <NL>                      continue <NL>                  color [ nei ] <SPC> = <SPC> c <NL>                  stack . append ( nei ) <NL> <NL> <TAB> for <SPC> eqn <SPC> in <SPC> equations : <NL>          if <SPC> eqn [ 1 ] <SPC> != <SPC> "!" : <NL>              continue <NL>          x <SPC> = <SPC> ord ( eqn [ 0 ] ) <SPC> - <SPC> ord ( "a" ) <NL>          y <SPC> = <SPC> ord ( eqn [ 3 ] ) <SPC> - <SPC> ord ( "a" ) <NL>          if <SPC> color [ x ] <SPC> is <SPC> not <SPC> None <SPC> and <SPC> color [ x ] <SPC> == <SPC> color [ y ] : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> matrixScore ( self , <SPC> A ) : <NL> <NL> <TAB> R , <SPC> C <SPC> = <SPC> len ( A ) , <SPC> len ( A [ 0 ] ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> xrange ( C ) : <NL>          col <SPC> = <SPC> 0 <NL>          for <SPC> r <SPC> in <SPC> xrange ( R ) : <NL>              col <SPC> += <SPC> A [ r ] [ c ] <SPC> ^ <SPC> A [ r ] [ 0 ] <NL>          result <SPC> += <SPC> max ( col , <SPC> R <SPC> - <SPC> col ) <SPC> * <SPC> 2 <SPC> ** <SPC> ( C <SPC> - <SPC> 1 <SPC> - <SPC> c ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> scoreOfParentheses ( self , <SPC> S ) : <NL> <NL> <TAB> result , <SPC> depth <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( S ) ) : <NL>          if <SPC> S [ i ] <SPC> == <SPC> "(" : <NL>              depth <SPC> += <SPC> 1 <NL>          else : <NL>              depth <SPC> -= <SPC> 1 <NL>              if <SPC> S [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "(" : <NL>                  result <SPC> += <SPC> 2 <SPC> ** <SPC> depth <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> scoreOfParentheses ( self , <SPC> S ) : <NL> <NL> <TAB> stack <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          if <SPC> c <SPC> == <SPC> "(" : <NL>              stack . append ( 0 ) <NL>          else : <NL>              last <SPC> = <SPC> stack . pop ( ) <NL>              stack [ - 1 ] <SPC> += <SPC> max ( 1 , <SPC> 2 <SPC> * <SPC> last ) <NL> <TAB> return <SPC> stack [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isScramble ( self , <SPC> s1 , <SPC> s2 ) : <NL> <TAB> if <SPC> not <SPC> s1 <SPC> or <SPC> not <SPC> s2 <SPC> or <SPC> len ( s1 ) <SPC> != <SPC> len ( s2 ) : <NL>          return <SPC> False <NL> <TAB> if <SPC> s1 <SPC> == <SPC> s2 : <NL>          return <SPC> True <NL> <TAB> result <SPC> = <SPC> [ <NL>          [ [ False <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( s2 ) ) ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( s1 ) ) ] <NL>          for <SPC> n <SPC> in <SPC> xrange ( len ( s1 ) <SPC> + <SPC> 1 ) <NL> <TAB> ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s1 ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( s2 ) ) : <NL>              if <SPC> s1 [ i ] <SPC> == <SPC> s2 [ j ] : <NL>                  result [ 1 ] [ i ] [ j ] <SPC> = <SPC> True <NL> <NL> <TAB> for <SPC> n <SPC> in <SPC> xrange ( 2 , <SPC> len ( s1 ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s1 ) <SPC> - <SPC> n <SPC> + <SPC> 1 ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( s2 ) <SPC> - <SPC> n <SPC> + <SPC> 1 ) : <NL>                  for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>                      if <SPC> ( <NL>                          result [ k ] [ i ] [ j ] <NL>                          and <SPC> result [ n <SPC> - <SPC> k ] [ i <SPC> + <SPC> k ] [ j <SPC> + <SPC> k ] <NL>                          or <SPC> result [ k ] [ i ] [ j <SPC> + <SPC> n <SPC> - <SPC> k ] <NL>                          and <SPC> result [ n <SPC> - <SPC> k ] [ i <SPC> + <SPC> k ] [ j ] <NL>                      ) : <NL>                          result [ n ] [ i ] [ j ] <SPC> = <SPC> True <NL>                          break <NL> <NL> <TAB> return <SPC> result [ n ] [ 0 ] [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> searchMatrix ( self , <SPC> matrix , <SPC> target ) : <NL> <TAB> m <SPC> = <SPC> len ( matrix ) <NL> <TAB> if <SPC> m <SPC> == <SPC> 0 : <NL>          return <SPC> False <NL> <NL> <TAB> n <SPC> = <SPC> len ( matrix [ 0 ] ) <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 : <NL>          return <SPC> False <NL> <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> n <SPC> - <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> m <SPC> and <SPC> j <SPC> >= <SPC> 0 : <NL>          if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> target : <NL>              return <SPC> True <NL>          elif <SPC> matrix [ i ] [ j ] <SPC> > <SPC> target : <NL>              j <SPC> -= <SPC> 1 <NL>          else : <NL>              i <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> searchMatrix ( self , <SPC> matrix , <SPC> target ) : <NL> <NL> <TAB> if <SPC> not <SPC> matrix : <NL>          return <SPC> False <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( matrix ) , <SPC> len ( matrix [ 0 ] ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> m <SPC> * <SPC> n <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> matrix [ mid <SPC> / <SPC> n ] [ mid <SPC> % <SPC> n ] <SPC> >= <SPC> target : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> left <SPC> < <SPC> m <SPC> * <SPC> n <SPC> and <SPC> matrix [ left <SPC> / <SPC> n ] [ left <SPC> % <SPC> n ] <SPC> == <SPC> target <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> searchRange ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> left <SPC> = <SPC> self . binarySearch ( lambda <SPC> x , <SPC> y : <SPC> x <SPC> >= <SPC> y , <SPC> nums , <SPC> target ) <NL> <TAB> if <SPC> left <SPC> >= <SPC> len ( nums ) <SPC> or <SPC> nums [ left ] <SPC> != <SPC> target : <NL>          return <SPC> [ - 1 , <SPC> - 1 ] <NL> <NL> <TAB> right <SPC> = <SPC> self . binarySearch ( lambda <SPC> x , <SPC> y : <SPC> x <SPC> > <SPC> y , <SPC> nums , <SPC> target ) <NL> <TAB> return <SPC> [ left , <SPC> right <SPC> - <SPC> 1 ] <NL> <NL> <TAB> def <SPC> binarySearch ( self , <SPC> compare , <SPC> nums , <SPC> target ) : <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> compare ( nums [ mid ] , <SPC> target ) : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <TAB> def <SPC> binarySearch2 ( self , <SPC> compare , <SPC> nums , <SPC> target ) : <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> compare ( nums [ mid ] , <SPC> target ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <TAB> def <SPC> binarySearch3 ( self , <SPC> compare , <SPC> nums , <SPC> target ) : <NL> <TAB> left , <SPC> right <SPC> = <SPC> - 1 , <SPC> len ( nums ) <NL> <TAB> while <SPC> left <SPC> + <SPC> 1 <SPC> < <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> compare ( nums [ mid ] , <SPC> target ) : <NL>              right <SPC> = <SPC> mid <NL>          else : <NL>              left <SPC> = <SPC> mid <NL> <TAB> return <SPC> left <SPC> if <SPC> left <SPC> != <SPC> - 1 <SPC> and <SPC> compare ( nums [ left ] , <SPC> target ) <SPC> else <SPC> right <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> searchBST ( self , <SPC> root , <SPC> val ) : <NL> <NL> <TAB> while <SPC> root <SPC> and <SPC> val <SPC> != <SPC> root . val : <NL>          if <SPC> val <SPC> < <SPC> root . val : <NL>              root <SPC> = <SPC> root . left <NL>          else : <NL>              root <SPC> = <SPC> root . right <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> search ( self , <SPC> reader , <SPC> target ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> 19999 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          response <SPC> = <SPC> reader . get ( mid ) <NL>          if <SPC> response <SPC> > <SPC> target : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          elif <SPC> response <SPC> < <SPC> target : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          else : <NL>              return <SPC> mid <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> search ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL> <NL>          if <SPC> nums [ mid ] <SPC> == <SPC> target : <NL>              return <SPC> True <NL>          elif <SPC> nums [ mid ] <SPC> == <SPC> nums [ left ] : <NL>              left <SPC> += <SPC> 1 <NL>          elif <SPC> ( nums [ mid ] <SPC> > <SPC> nums [ left ] <SPC> and <SPC> nums [ left ] <SPC> <= <SPC> target <SPC> < <SPC> nums [ mid ] ) <SPC> or <SPC> ( <NL>              nums [ mid ] <SPC> < <SPC> nums [ left ] <SPC> and <SPC> not <SPC> ( nums [ mid ] <SPC> < <SPC> target <SPC> <= <SPC> nums [ right ] ) <NL>          ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> search ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL> <NL>          if <SPC> nums [ mid ] <SPC> == <SPC> target : <NL>              return <SPC> mid <NL>          elif <SPC> ( nums [ mid ] <SPC> >= <SPC> nums [ left ] <SPC> and <SPC> nums [ left ] <SPC> <= <SPC> target <SPC> < <SPC> nums [ mid ] ) <SPC> or <SPC> ( <NL>              nums [ mid ] <SPC> < <SPC> nums [ left ] <SPC> and <SPC> not <SPC> ( nums [ mid ] <SPC> < <SPC> target <SPC> <= <SPC> nums [ right ] ) <NL>          ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> searchInsert ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> nums [ mid ] <SPC> >= <SPC> target : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> left <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> TrieNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __TOP_COUNT <SPC> = <SPC> 3 <NL> <TAB> self . leaves <SPC> = <SPC> collections . defaultdict ( TrieNode ) <NL> <TAB> self . infos <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> words , <SPC> i ) : <NL> <TAB> curr <SPC> = <SPC> self <NL> <TAB> for <SPC> c <SPC> in <SPC> words [ i ] : <NL>          curr <SPC> = <SPC> curr . leaves [ c ] <NL>          curr . add_info ( words , <SPC> i ) <NL> <NL> <TAB> def <SPC> add_info ( self , <SPC> words , <SPC> i ) : <NL> <TAB> self . infos . append ( i ) <NL> <TAB> self . infos . sort ( key = lambda <SPC> x : <SPC> words [ x ] ) <NL> <TAB> if <SPC> len ( self . infos ) <SPC> > <SPC> self . __TOP_COUNT : <NL>          self . infos . pop ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> suggestedProducts ( self , <SPC> products , <SPC> searchWord ) : <NL> <NL> <TAB> trie <SPC> = <SPC> TrieNode ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( products ) ) : <NL>          trie . insert ( products , <SPC> i ) <NL> <TAB> result <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( searchWord ) ) ] <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( searchWord ) : <NL>          if <SPC> c <SPC> not <SPC> in <SPC> trie . leaves : <NL>              break <NL>          trie <SPC> = <SPC> trie . leaves [ c ] <NL>          result [ i ] <SPC> = <SPC> map ( lambda <SPC> x : <SPC> products [ x ] , <SPC> trie . infos ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TrieNode2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __TOP_COUNT <SPC> = <SPC> 3 <NL> <TAB> self . leaves <SPC> = <SPC> collections . defaultdict ( TrieNode2 ) <NL> <TAB> self . infos <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> words , <SPC> i ) : <NL> <TAB> curr <SPC> = <SPC> self <NL> <TAB> for <SPC> c <SPC> in <SPC> words [ i ] : <NL>          curr <SPC> = <SPC> curr . leaves [ c ] <NL>          curr . add_info ( i ) <NL> <NL> <TAB> def <SPC> add_info ( self , <SPC> i ) : <NL> <TAB> if <SPC> len ( self . infos ) <SPC> == <SPC> self . __TOP_COUNT : <NL>          return <NL> <TAB> self . infos . append ( i ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> suggestedProducts ( self , <SPC> products , <SPC> searchWord ) : <NL> <NL> <TAB> products . sort ( ) <NL> <TAB> trie <SPC> = <SPC> TrieNode2 ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( products ) ) : <NL>          trie . insert ( products , <SPC> i ) <NL> <TAB> result <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( searchWord ) ) ] <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( searchWord ) : <NL>          if <SPC> c <SPC> not <SPC> in <SPC> trie . leaves : <NL>              break <NL>          trie <SPC> = <SPC> trie . leaves [ c ] <NL>          result [ i ] <SPC> = <SPC> map ( lambda <SPC> x : <SPC> products [ x ] , <SPC> trie . infos ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> suggestedProducts ( self , <SPC> products , <SPC> searchWord ) : <NL> <NL> <TAB> products . sort ( ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> prefix <SPC> = <SPC> "" <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( searchWord ) : <NL>          prefix <SPC> += <SPC> c <NL>          start <SPC> = <SPC> bisect . bisect_left ( products , <SPC> prefix ) <NL>          new_products <SPC> = <SPC> [ ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( start , <SPC> len ( products ) ) : <NL>              if <SPC> not <SPC> ( i <SPC> < <SPC> len ( products [ j ] ) <SPC> and <SPC> products [ j ] [ i ] <SPC> == <SPC> c ) : <NL>                  break <NL>              new_products . append ( products [ j ] ) <NL>          products <SPC> = <SPC> new_products <NL>          result . append ( products [ : 3 ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findSecondMinimumValue ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> findSecondMinimumValueHelper ( root , <SPC> max_heap , <SPC> lookup ) : <NL>          if <SPC> not <SPC> root : <NL>              return <NL>          if <SPC> root . val <SPC> not <SPC> in <SPC> lookup : <NL>              heapq . heappush ( max_heap , <SPC> - root . val ) <NL>              lookup . add ( root . val ) <NL>              if <SPC> len ( max_heap ) <SPC> > <SPC> 2 : <NL>                  lookup . remove ( - heapq . heappop ( max_heap ) ) <NL>          findSecondMinimumValueHelper ( root . left , <SPC> max_heap , <SPC> lookup ) <NL>          findSecondMinimumValueHelper ( root . right , <SPC> max_heap , <SPC> lookup ) <NL> <NL> <TAB> max_heap , <SPC> lookup <SPC> = <SPC> [ ] , <SPC> set ( ) <NL> <TAB> findSecondMinimumValueHelper ( root , <SPC> max_heap , <SPC> lookup ) <NL> <TAB> if <SPC> len ( max_heap ) <SPC> < <SPC> 2 : <NL>          return <SPC> - 1 <NL> <TAB> return <SPC> - max_heap [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isSelfCrossing ( self , <SPC> x ) : <NL> <NL> <TAB> if <SPC> len ( x ) <SPC> >= <SPC> 5 <SPC> and <SPC> x [ 3 ] <SPC> == <SPC> x [ 1 ] <SPC> and <SPC> x [ 4 ] <SPC> + <SPC> x [ 0 ] <SPC> >= <SPC> x [ 2 ] : <NL> <NL>          return <SPC> True <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 3 , <SPC> len ( x ) ) : <NL>          if <SPC> x [ i ] <SPC> >= <SPC> x [ i <SPC> - <SPC> 2 ] <SPC> and <SPC> x [ i <SPC> - <SPC> 3 ] <SPC> >= <SPC> x [ i <SPC> - <SPC> 1 ] : <NL> <NL>              return <SPC> True <NL>          elif <SPC> ( <NL>              i <SPC> >= <SPC> 5 <NL>              and <SPC> x [ i <SPC> - <SPC> 4 ] <SPC> <= <SPC> x [ i <SPC> - <SPC> 2 ] <NL>              and <SPC> x [ i ] <SPC> + <SPC> x [ i <SPC> - <SPC> 4 ] <SPC> >= <SPC> x [ i <SPC> - <SPC> 2 ] <NL>              and <SPC> x [ i <SPC> - <SPC> 1 ] <SPC> <= <SPC> x [ i <SPC> - <SPC> 3 ] <NL>              and <SPC> x [ i <SPC> - <SPC> 5 ] <SPC> + <SPC> x [ i <SPC> - <SPC> 1 ] <SPC> >= <SPC> x [ i <SPC> - <SPC> 3 ] <NL>          ) : <NL> <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> selfDividingNumbers ( self , <SPC> left , <SPC> right ) : <NL> <NL> <TAB> def <SPC> isDividingNumber ( num ) : <NL>          n <SPC> = <SPC> num <NL>          while <SPC> n <SPC> > <SPC> 0 : <NL>              n , <SPC> r <SPC> = <SPC> divmod ( n , <SPC> 10 ) <NL>              if <SPC> r <SPC> == <SPC> 0 <SPC> or <SPC> ( num <SPC> % <SPC> r ) <SPC> != <SPC> 0 : <NL>                  return <SPC> False <NL>          return <SPC> True <NL> <NL> <TAB> return <SPC> [ num <SPC> for <SPC> num <SPC> in <SPC> xrange ( left , <SPC> right <SPC> + <SPC> 1 ) <SPC> if <SPC> isDividingNumber ( num ) ] <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> selfDividingNumbers ( self , <SPC> left , <SPC> right ) : <NL> <NL> <TAB> return <SPC> [ <NL>          num <NL>          for <SPC> num <SPC> in <SPC> xrange ( left , <SPC> right <SPC> + <SPC> 1 ) <NL>          if <SPC> not <SPC> any ( <NL>              itertools . imap ( lambda <SPC> x : <SPC> int ( x ) <SPC> == <SPC> 0 <SPC> or <SPC> num <SPC> % <NL>                             int ( x ) <SPC> != <SPC> 0 , <SPC> str ( num ) ) <NL>          ) <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxProfit ( self , <SPC> inventory , <SPC> orders ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> def <SPC> check ( inventory , <SPC> orders , <SPC> x ) : <NL>          return <SPC> count ( inventory , <SPC> x ) <SPC> > <SPC> orders <NL> <NL> <TAB> def <SPC> count ( inventory , <SPC> x ) : <NL>          return <SPC> sum ( count <SPC> - <SPC> x <SPC> + <SPC> 1 <SPC> for <SPC> count <SPC> in <SPC> inventory <SPC> if <SPC> count <SPC> >= <SPC> x ) <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> max ( inventory ) <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> not <SPC> check ( inventory , <SPC> orders , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> ( <NL>          sum ( <NL>              ( left <SPC> + <SPC> cnt ) <SPC> * <SPC> ( cnt <SPC> - <SPC> left <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 <SPC> for <SPC> cnt <SPC> in <SPC> inventory <SPC> if <SPC> cnt <SPC> >= <SPC> left <NL>          ) <NL>          + <SPC> ( left <SPC> - <SPC> 1 ) <SPC> * <SPC> ( orders <SPC> - <SPC> count ( inventory , <SPC> left ) ) <NL> <TAB> ) <SPC> % <SPC> MOD <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wordsTyping ( self , <SPC> sentence , <SPC> rows , <SPC> cols ) : <NL> <NL> <TAB> def <SPC> words_fit ( sentence , <SPC> start , <SPC> cols ) : <NL>          if <SPC> len ( sentence [ start ] ) <SPC> > <SPC> cols : <NL>              return <SPC> 0 <NL> <NL>          s , <SPC> count <SPC> = <SPC> len ( sentence [ start ] ) , <SPC> 1 <NL>          i <SPC> = <SPC> ( start <SPC> + <SPC> 1 ) <SPC> % <SPC> len ( sentence ) <NL>          while <SPC> s <SPC> + <SPC> 1 <SPC> + <SPC> len ( sentence [ i ] ) <SPC> <= <SPC> cols : <NL>              s <SPC> += <SPC> 1 <SPC> + <SPC> len ( sentence [ i ] ) <NL>              count <SPC> += <SPC> 1 <NL>              i <SPC> = <SPC> ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> len ( sentence ) <NL>          return <SPC> count <NL> <NL> <TAB> wc <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( sentence ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( sentence ) ) : <NL>          wc [ i ] <SPC> = <SPC> words_fit ( sentence , <SPC> i , <SPC> cols ) <NL> <NL> <TAB> words , <SPC> start <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( rows ) : <NL>          words <SPC> += <SPC> wc [ start ] <NL>          start <SPC> = <SPC> ( start <SPC> + <SPC> wc [ start ] ) <SPC> % <SPC> len ( sentence ) <NL> <TAB> return <SPC> words <SPC> / <SPC> len ( sentence ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> areSentencesSimilarTwo ( self , <SPC> words1 , <SPC> words2 , <SPC> pairs ) : <NL> <NL> <TAB> if <SPC> len ( words1 ) <SPC> != <SPC> len ( words2 ) : <NL>          return <SPC> False <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( 2 <SPC> * <SPC> len ( pairs ) ) <NL> <TAB> for <SPC> pair <SPC> in <SPC> pairs : <NL>          for <SPC> p <SPC> in <SPC> pair : <NL>              if <SPC> p <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup [ p ] <SPC> = <SPC> len ( lookup ) <NL>          union_find . union_set ( lookup [ pair [ 0 ] ] , <SPC> lookup [ pair [ 1 ] ] ) <NL> <NL> <TAB> return <SPC> all ( <NL>          w1 <SPC> == <SPC> w2 <NL>          or <SPC> w1 <SPC> in <SPC> lookup <NL>          and <SPC> w2 <SPC> in <SPC> lookup <NL>          and <SPC> union_find . find_set ( lookup [ w1 ] ) <SPC> == <SPC> union_find . find_set ( lookup [ w2 ] ) <NL>          for <SPC> w1 , <SPC> w2 <SPC> in <SPC> itertools . izip ( words1 , <SPC> words2 ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> areSentencesSimilar ( self , <SPC> words1 , <SPC> words2 , <SPC> pairs ) : <NL> <NL> <TAB> if <SPC> len ( words1 ) <SPC> != <SPC> len ( words2 ) : <NL>          return <SPC> False <NL> <TAB> lookup <SPC> = <SPC> set ( map ( tuple , <SPC> pairs ) ) <NL> <TAB> return <SPC> all ( <NL>          w1 <SPC> == <SPC> w2 <SPC> or <SPC> ( w1 , <SPC> w2 ) <SPC> in <SPC> lookup <SPC> or <SPC> ( w2 , <SPC> w1 ) <SPC> in <SPC> lookup <NL>          for <SPC> w1 , <SPC> w2 <SPC> in <SPC> itertools . izip ( words1 , <SPC> words2 ) <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sequenceReconstruction ( self , <SPC> org , <SPC> seqs ) : <NL> <NL> <TAB> if <SPC> not <SPC> seqs : <NL>          return <SPC> False <NL> <TAB> pos <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( org ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( org ) ) : <NL>          pos [ org [ i ] ] <SPC> = <SPC> i <NL> <NL> <TAB> is_matched <SPC> = <SPC> [ False ] <SPC> * <SPC> ( len ( org ) <SPC> + <SPC> 1 ) <NL> <TAB> cnt_to_match <SPC> = <SPC> len ( org ) <SPC> - <SPC> 1 <NL> <TAB> for <SPC> seq <SPC> in <SPC> seqs : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( seq ) ) : <NL>              if <SPC> not <SPC> 0 <SPC> < <SPC> seq [ i ] <SPC> <= <SPC> len ( org ) : <NL>                  return <SPC> False <NL>              if <SPC> i <SPC> == <SPC> 0 : <NL>                  continue <NL>              if <SPC> pos [ seq [ i <SPC> - <SPC> 1 ] ] <SPC> >= <SPC> pos [ seq [ i ] ] : <NL>                  return <SPC> False <NL>              if <SPC> ( <NL>                  is_matched [ seq [ i <SPC> - <SPC> 1 ] ] <SPC> == <SPC> False <NL>                  and <SPC> pos [ seq [ i <SPC> - <SPC> 1 ] ] <SPC> + <SPC> 1 <SPC> == <SPC> pos [ seq [ i ] ] <NL>              ) : <NL>                  is_matched [ seq [ i <SPC> - <SPC> 1 ] ] <SPC> = <SPC> True <NL>                  cnt_to_match <SPC> -= <SPC> 1 <NL> <NL> <TAB> return <SPC> cnt_to_match <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> sequenceReconstruction ( self , <SPC> org , <SPC> seqs ) : <NL> <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> indegree <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> integer_set <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> seq <SPC> in <SPC> seqs : <NL>          for <SPC> i <SPC> in <SPC> seq : <NL>              integer_set . add ( i ) <NL>          if <SPC> len ( seq ) <SPC> == <SPC> 1 : <NL>              if <SPC> seq [ 0 ] <SPC> not <SPC> in <SPC> indegree : <NL>                  indegree [ seq [ 0 ] ] <SPC> = <SPC> 0 <NL>              continue <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( seq ) <SPC> - <SPC> 1 ) : <NL>              if <SPC> seq [ i ] <SPC> not <SPC> in <SPC> indegree : <NL>                  indegree [ seq [ i ] ] <SPC> = <SPC> 0 <NL>              if <SPC> seq [ i <SPC> + <SPC> 1 ] <SPC> not <SPC> in <SPC> graph [ seq [ i ] ] : <NL>                  graph [ seq [ i ] ] . add ( seq [ i <SPC> + <SPC> 1 ] ) <NL>                  indegree [ seq [ i <SPC> + <SPC> 1 ] ] <SPC> += <SPC> 1 <NL> <NL> <TAB> cnt_of_zero_indegree <SPC> = <SPC> 0 <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> q <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> indegree : <NL>          if <SPC> indegree [ i ] <SPC> == <SPC> 0 : <NL>              cnt_of_zero_indegree <SPC> += <SPC> 1 <NL>              if <SPC> cnt_of_zero_indegree <SPC> > <SPC> 1 : <NL>                  return <SPC> False <NL>              q . append ( i ) <NL> <NL> <TAB> while <SPC> q : <NL>          i <SPC> = <SPC> q . pop ( ) <NL>          res . append ( i ) <NL>          cnt_of_zero_indegree <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> graph [ i ] : <NL>              indegree [ j ] <SPC> -= <SPC> 1 <NL>              if <SPC> indegree [ j ] <SPC> == <SPC> 0 : <NL>                  cnt_of_zero_indegree <SPC> += <SPC> 1 <NL>                  if <SPC> cnt_of_zero_indegree <SPC> > <SPC> 1 : <NL>                      return <SPC> False <NL>                  q . append ( j ) <NL> <TAB> return <SPC> res <SPC> == <SPC> org <SPC> and <SPC> len ( org ) <SPC> == <SPC> len ( integer_set ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sequentialDigits ( self , <SPC> low , <SPC> high ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> q <SPC> = <SPC> collections . deque ( range ( 1 , <SPC> 9 ) ) <NL> <TAB> while <SPC> q : <NL>          num <SPC> = <SPC> q . popleft ( ) <NL>          if <SPC> num <SPC> > <SPC> high : <NL>              continue <NL>          if <SPC> low <SPC> <= <SPC> num : <NL>              result . append ( num ) <NL>          if <SPC> num <SPC> % <SPC> 10 <SPC> + <SPC> 1 <SPC> < <SPC> 10 : <NL>              q . append ( num <SPC> * <SPC> 10 <SPC> + <SPC> num <SPC> % <SPC> 10 <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Codec ( object ) : <NL> <TAB> def <SPC> serialize ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> serializeHelper ( node ) : <NL>          if <SPC> not <SPC> node : <NL>              vals . append ( "#" ) <NL>              return <NL>          vals . append ( str ( node . val ) ) <NL>          serializeHelper ( node . left ) <NL>          serializeHelper ( node . right ) <NL> <NL> <TAB> vals <SPC> = <SPC> [ ] <NL> <TAB> serializeHelper ( root ) <NL> <TAB> return <SPC> " " . join ( vals ) <NL> <NL> <TAB> def <SPC> deserialize ( self , <SPC> data ) : <NL> <NL> <TAB> def <SPC> deserializeHelper ( ) : <NL>          val <SPC> = <SPC> next ( vals ) <NL>          if <SPC> val <SPC> == <SPC> "#" : <NL>              return <SPC> None <NL>          node <SPC> = <SPC> TreeNode ( int ( val ) ) <NL>          node . left <SPC> = <SPC> deserializeHelper ( ) <NL>          node . right <SPC> = <SPC> deserializeHelper ( ) <NL>          return <SPC> node <NL> <NL> <TAB> def <SPC> isplit ( source , <SPC> sep ) : <NL>          sepsize <SPC> = <SPC> len ( sep ) <NL>          start <SPC> = <SPC> 0 <NL>          while <SPC> True : <NL>              idx <SPC> = <SPC> source . find ( sep , <SPC> start ) <NL>              if <SPC> idx <SPC> == <SPC> - 1 : <NL>                  yield <SPC> source [ start : ] <NL>                  return <NL>              yield <SPC> source [ start : idx ] <NL>              start <SPC> = <SPC> idx <SPC> + <SPC> sepsize <NL> <NL> <TAB> vals <SPC> = <SPC> iter ( isplit ( data , <SPC> " " ) ) <NL> <TAB> return <SPC> deserializeHelper ( ) <NL> <NL> <NL> class <SPC> Codec2 ( object ) : <NL> <TAB> def <SPC> serialize ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> gen_preorder ( node ) : <NL>          if <SPC> not <SPC> node : <NL>              yield <SPC> "#" <NL>          else : <NL>              yield <SPC> str ( node . val ) <NL>              for <SPC> n <SPC> in <SPC> gen_preorder ( node . left ) : <NL>                  yield <SPC> n <NL>              for <SPC> n <SPC> in <SPC> gen_preorder ( node . right ) : <NL>                  yield <SPC> n <NL> <NL> <TAB> return <SPC> " " . join ( gen_preorder ( root ) ) <NL> <NL> <TAB> def <SPC> deserialize ( self , <SPC> data ) : <NL> <NL> <TAB> def <SPC> builder ( chunk_iter ) : <NL>          val <SPC> = <SPC> next ( chunk_iter ) <NL>          if <SPC> val <SPC> == <SPC> "#" : <NL>              return <SPC> None <NL>          node <SPC> = <SPC> TreeNode ( int ( val ) ) <NL>          node . left <SPC> = <SPC> builder ( chunk_iter ) <NL>          node . right <SPC> = <SPC> builder ( chunk_iter ) <NL>          return <SPC> node <NL> <NL> <TAB> chunk_iter <SPC> = <SPC> iter ( data . split ( ) ) <NL> <TAB> return <SPC> builder ( chunk_iter ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Codec ( object ) : <NL> <TAB> def <SPC> serialize ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> serializeHelper ( node , <SPC> vals ) : <NL>          if <SPC> node : <NL>              vals . append ( node . val ) <NL>              serializeHelper ( node . left , <SPC> vals ) <NL>              serializeHelper ( node . right , <SPC> vals ) <NL> <NL> <TAB> vals <SPC> = <SPC> [ ] <NL> <TAB> serializeHelper ( root , <SPC> vals ) <NL> <NL> <TAB> return <SPC> " " . join ( map ( str , <SPC> vals ) ) <NL> <NL> <TAB> def <SPC> deserialize ( self , <SPC> data ) : <NL> <NL> <TAB> def <SPC> deserializeHelper ( minVal , <SPC> maxVal , <SPC> vals ) : <NL>          if <SPC> not <SPC> vals : <NL>              return <SPC> None <NL> <NL>          if <SPC> minVal <SPC> < <SPC> vals [ 0 ] <SPC> < <SPC> maxVal : <NL>              val <SPC> = <SPC> vals . popleft ( ) <NL>              node <SPC> = <SPC> TreeNode ( val ) <NL>              node . left <SPC> = <SPC> deserializeHelper ( minVal , <SPC> val , <SPC> vals ) <NL>              node . right <SPC> = <SPC> deserializeHelper ( val , <SPC> maxVal , <SPC> vals ) <NL>              return <SPC> node <NL>          else : <NL>              return <SPC> None <NL> <NL> <TAB> vals <SPC> = <SPC> collections . deque ( [ int ( val ) <SPC> for <SPC> val <SPC> in <SPC> data . split ( ) ] ) <NL> <NL> <TAB> return <SPC> deserializeHelper ( float ( "-inf" ) , <SPC> float ( "inf" ) , <SPC> vals ) <NL> <NL> <NL> class <SPC> Node ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val , <SPC> children ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . children <SPC> = <SPC> children <NL> <NL> <NL> class <SPC> Codec ( object ) : <NL> <TAB> def <SPC> serialize ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> vals ) : <NL>          if <SPC> not <SPC> node : <NL>              return <NL>          vals . append ( str ( node . val ) ) <NL>          for <SPC> child <SPC> in <SPC> node . children : <NL>              dfs ( child , <SPC> vals ) <NL>          vals . append ( "#" ) <NL> <NL> <TAB> vals <SPC> = <SPC> [ ] <NL> <TAB> dfs ( root , <SPC> vals ) <NL> <TAB> return <SPC> " " . join ( vals ) <NL> <NL> <TAB> def <SPC> deserialize ( self , <SPC> data ) : <NL> <NL> <TAB> def <SPC> isplit ( source , <SPC> sep ) : <NL>          sepsize <SPC> = <SPC> len ( sep ) <NL>          start <SPC> = <SPC> 0 <NL>          while <SPC> True : <NL>              idx <SPC> = <SPC> source . find ( sep , <SPC> start ) <NL>              if <SPC> idx <SPC> == <SPC> - 1 : <NL>                  yield <SPC> source [ start : ] <NL>                  return <NL>              yield <SPC> source [ start : idx ] <NL>              start <SPC> = <SPC> idx <SPC> + <SPC> sepsize <NL> <NL> <TAB> def <SPC> dfs ( vals ) : <NL>          val <SPC> = <SPC> next ( vals ) <NL>          if <SPC> val <SPC> == <SPC> "#" : <NL>              return <SPC> None <NL>          root <SPC> = <SPC> Node ( int ( val ) , <SPC> [ ] ) <NL>          child <SPC> = <SPC> dfs ( vals ) <NL>          while <SPC> child : <NL>              root . children . append ( child ) <NL>              child <SPC> = <SPC> dfs ( vals ) <NL>          return <SPC> root <NL> <NL> <TAB> if <SPC> not <SPC> data : <NL>          return <SPC> None <NL> <NL> <TAB> return <SPC> dfs ( iter ( isplit ( data , <SPC> " " ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> intersectionSizeTwo ( self , <SPC> intervals ) : <NL> <NL> <TAB> intervals . sort ( key = lambda <SPC> s_e : <SPC> ( s_e [ 0 ] , <SPC> - s_e [ 1 ] ) ) <NL> <TAB> cnts <SPC> = <SPC> [ 2 ] <SPC> * <SPC> len ( intervals ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> intervals : <NL>          ( start , <SPC> _ ) , <SPC> cnt <SPC> = <SPC> intervals . pop ( ) , <SPC> cnts . pop ( ) <NL>          for <SPC> s <SPC> in <SPC> xrange ( start , <SPC> start <SPC> + <SPC> cnt ) : <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( intervals ) ) : <NL>                  if <SPC> cnts [ i ] <SPC> and <SPC> s <SPC> <= <SPC> intervals [ i ] [ 1 ] : <NL>                      cnts [ i ] <SPC> -= <SPC> 1 <NL>          result <SPC> += <SPC> cnt <NL> <TAB> return <SPC> result <NL> <NL> <NL> from <SPC> functools <SPC> import <SPC> reduce <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> setZeroes ( self , <SPC> matrix ) : <NL> <TAB> first_col <SPC> = <SPC> reduce ( <NL>          lambda <SPC> acc , <SPC> i : <SPC> acc <SPC> or <SPC> matrix [ i ] [ 0 ] <SPC> == <SPC> 0 , <SPC> xrange ( len ( matrix ) ) , <SPC> False <NL> <TAB> ) <NL> <TAB> first_row <SPC> = <SPC> reduce ( <NL>          lambda <SPC> acc , <SPC> j : <SPC> acc <SPC> or <SPC> matrix [ 0 ] [ j ] <SPC> == <SPC> 0 , <SPC> xrange ( len ( matrix [ 0 ] ) ) , <SPC> False <NL> <TAB> ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( matrix [ 0 ] ) ) : <NL>              if <SPC> matrix [ i ] [ j ] <SPC> == <SPC> 0 : <NL>                  matrix [ i ] [ 0 ] , <SPC> matrix [ 0 ] [ j ] <SPC> = <SPC> 0 , <SPC> 0 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( matrix ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( matrix [ 0 ] ) ) : <NL>              if <SPC> matrix [ i ] [ 0 ] <SPC> == <SPC> 0 <SPC> or <SPC> matrix [ 0 ] [ j ] <SPC> == <SPC> 0 : <NL>                  matrix [ i ] [ j ] <SPC> = <SPC> 0 <NL> <NL> <TAB> if <SPC> first_col : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( matrix ) ) : <NL>              matrix [ i ] [ 0 ] <SPC> = <SPC> 0 <NL> <NL> <TAB> if <SPC> first_row : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( matrix [ 0 ] ) ) : <NL>              matrix [ 0 ] [ j ] <SPC> = <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findErrorNums ( self , <SPC> nums ) : <NL> <NL> <TAB> x_xor_y <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          x_xor_y <SPC> ^= <SPC> nums [ i ] <SPC> ^ <SPC> ( i <SPC> + <SPC> 1 ) <NL> <TAB> bit <SPC> = <SPC> x_xor_y <SPC> & <SPC> ~ ( x_xor_y <SPC> - <SPC> 1 ) <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          result [ bool ( num <SPC> & <SPC> bit ) ] <SPC> ^= <SPC> num <NL>          result [ bool ( ( i <SPC> + <SPC> 1 ) <SPC> & <SPC> bit ) ] <SPC> ^= <SPC> i <SPC> + <SPC> 1 <NL> <TAB> if <SPC> result [ 0 ] <SPC> not <SPC> in <SPC> nums : <NL>          result [ 0 ] , <SPC> result [ 1 ] <SPC> = <SPC> result [ 1 ] , <SPC> result [ 0 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findErrorNums ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 <NL> <TAB> for <SPC> i <SPC> in <SPC> nums : <NL>          if <SPC> nums [ abs ( i ) <SPC> - <SPC> 1 ] <SPC> < <SPC> 0 : <NL>              result [ 0 ] <SPC> = <SPC> abs ( i ) <NL>          else : <NL>              nums [ abs ( i ) <SPC> - <SPC> 1 ] <SPC> *= <SPC> - 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> nums [ i ] <SPC> > <SPC> 0 : <NL>              result [ 1 ] <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>          else : <NL>              nums [ i ] <SPC> *= <SPC> - 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> findErrorNums ( self , <SPC> nums ) : <NL> <NL> <TAB> N <SPC> = <SPC> len ( nums ) <NL> <TAB> x_minus_y <SPC> = <SPC> sum ( nums ) <SPC> - <SPC> N <SPC> * <SPC> ( N <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 <NL> <TAB> x_plus_y <SPC> = <SPC> ( <NL>          sum ( x <SPC> * <SPC> x <SPC> for <SPC> x <SPC> in <SPC> nums ) <SPC> - <SPC> N <SPC> * <SPC> ( N <SPC> + <SPC> 1 ) <SPC> * <SPC> ( 2 <SPC> * <SPC> N <SPC> + <SPC> 1 ) <SPC> / <SPC> 6 <NL> <TAB> ) <SPC> // <SPC> x_minus_y <NL> <TAB> return <SPC> ( x_plus_y <SPC> + <SPC> x_minus_y ) <SPC> // <SPC> 2 , <SPC> ( x_plus_y <SPC> - <SPC> x_minus_y ) <SPC> // <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shiftGrid ( self , <SPC> grid , <SPC> k ) : <NL> <NL> <TAB> def <SPC> rotate ( grids , <SPC> k ) : <NL>          def <SPC> reverse ( grid , <SPC> start , <SPC> end ) : <NL>              while <SPC> start <SPC> < <SPC> end : <NL>                  start_r , <SPC> start_c <SPC> = <SPC> divmod ( start , <SPC> len ( grid [ 0 ] ) ) <NL>                  end_r , <SPC> end_c <SPC> = <SPC> divmod ( end <SPC> - <SPC> 1 , <SPC> len ( grid [ 0 ] ) ) <NL>                  grid [ start_r ] [ start_c ] , <SPC> grid [ end_r ] [ end_c ] <SPC> = <SPC> ( <NL>                      grid [ end_r ] [ end_c ] , <NL>                      grid [ start_r ] [ start_c ] , <NL>                  ) <NL>                  start <SPC> += <SPC> 1 <NL>                  end <SPC> -= <SPC> 1 <NL> <NL>          k <SPC> %= <SPC> len ( grid ) <SPC> * <SPC> len ( grid [ 0 ] ) <NL>          reverse ( grid , <SPC> 0 , <SPC> len ( grid ) <SPC> * <SPC> len ( grid [ 0 ] ) ) <NL>          reverse ( grid , <SPC> 0 , <SPC> k ) <NL>          reverse ( grid , <SPC> k , <SPC> len ( grid ) <SPC> * <SPC> len ( grid [ 0 ] ) ) <NL> <NL> <TAB> rotate ( grid , <SPC> k ) <NL> <TAB> return <SPC> grid <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shiftingLetters ( self , <SPC> S , <SPC> shifts ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> times <SPC> = <SPC> sum ( shifts ) <SPC> % <SPC> 26 <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( S ) : <NL>          index <SPC> = <SPC> ord ( c ) <SPC> - <SPC> ord ( "a" ) <NL>          result . append ( chr ( ord ( "a" ) <SPC> + <SPC> ( index <SPC> + <SPC> times ) <SPC> % <SPC> 26 ) ) <NL>          times <SPC> = <SPC> ( times <SPC> - <SPC> shifts [ i ] ) <SPC> % <SPC> 26 <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shoppingOffers ( self , <SPC> price , <SPC> special , <SPC> needs ) : <NL> <NL> <TAB> def <SPC> shoppingOffersHelper ( price , <SPC> special , <SPC> needs , <SPC> i ) : <NL>          if <SPC> i <SPC> == <SPC> len ( special ) : <NL>              return <SPC> sum ( map ( lambda <SPC> x , <SPC> y : <SPC> x <SPC> * <SPC> y , <SPC> price , <SPC> needs ) ) <NL>          result <SPC> = <SPC> shoppingOffersHelper ( price , <SPC> special , <SPC> needs , <SPC> i <SPC> + <SPC> 1 ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( needs ) ) : <NL>              needs [ j ] <SPC> -= <SPC> special [ i ] [ j ] <NL>          if <SPC> all ( need <SPC> >= <SPC> 0 <SPC> for <SPC> need <SPC> in <SPC> needs ) : <NL>              result <SPC> = <SPC> min ( <NL>                  result , <NL>                  special [ i ] [ - 1 ] <SPC> + <NL>                  shoppingOffersHelper ( price , <SPC> special , <SPC> needs , <SPC> i ) , <NL>              ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( needs ) ) : <NL>              needs [ j ] <SPC> += <SPC> special [ i ] [ j ] <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> shoppingOffersHelper ( price , <SPC> special , <SPC> needs , <SPC> 0 ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> functools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minimumLengthEncoding ( self , <SPC> words ) : <NL> <NL> <TAB> words <SPC> = <SPC> list ( set ( words ) ) <NL> <TAB> def <SPC> _trie ( ) : <SPC> return <SPC> collections . defaultdict ( _trie ) <NL> <TAB> trie <SPC> = <SPC> _trie ( ) <NL> <NL> <TAB> nodes <SPC> = <SPC> [ functools . reduce ( dict . __getitem__ , <SPC> word [ : : - 1 ] , <SPC> trie ) <NL>               for <SPC> word <SPC> in <SPC> words ] <NL> <NL> <TAB> return <SPC> sum ( len ( word ) <SPC> + <SPC> 1 <SPC> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( words ) <SPC> if <SPC> len ( nodes [ i ] ) <SPC> == <SPC> 0 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestBridge ( self , <SPC> A ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> get_islands ( A ) : <NL>          islands <SPC> = <SPC> [ ] <NL>          done <SPC> = <SPC> set ( ) <NL>          for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( A ) : <NL>              for <SPC> c , <SPC> val <SPC> in <SPC> enumerate ( row ) : <NL>                  if <SPC> val <SPC> == <SPC> 0 <SPC> or <SPC> ( r , <SPC> c ) <SPC> in <SPC> done : <NL>                      continue <NL>                  s <SPC> = <SPC> [ ( r , <SPC> c ) ] <NL>                  lookup <SPC> = <SPC> set ( s ) <NL>                  while <SPC> s : <NL>                      node <SPC> = <SPC> s . pop ( ) <NL>                      for <SPC> d <SPC> in <SPC> directions : <NL>                          nei <SPC> = <SPC> node [ 0 ] <SPC> + <SPC> d [ 0 ] , <SPC> node [ 1 ] <SPC> + <SPC> d [ 1 ] <NL>                          if <SPC> ( <NL>                              not <SPC> ( 0 <SPC> <= <SPC> nei [ 0 ] <SPC> < <SPC> len ( A ) <NL>                                   and <SPC> 0 <SPC> <= <SPC> nei [ 1 ] <SPC> < <SPC> len ( A [ 0 ] ) ) <NL>                              or <SPC> nei <SPC> in <SPC> lookup <NL>                              or <SPC> A [ nei [ 0 ] ] [ nei [ 1 ] ] <SPC> == <SPC> 0 <NL>                          ) : <NL>                              continue <NL>                          s . append ( nei ) <NL>                          lookup . add ( nei ) <NL>                  done <SPC> |= <SPC> lookup <NL>                  islands . append ( lookup ) <NL>                  if <SPC> len ( islands ) <SPC> == <SPC> 2 : <NL>                      break <NL>          return <SPC> islands <NL> <NL> <TAB> lookup , <SPC> target <SPC> = <SPC> get_islands ( A ) <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ ( node , <SPC> 0 ) <SPC> for <SPC> node <SPC> in <SPC> lookup ] ) <NL> <TAB> while <SPC> q : <NL>          node , <SPC> dis <SPC> = <SPC> q . popleft ( ) <NL>          if <SPC> node <SPC> in <SPC> target : <NL>              return <SPC> dis <SPC> - <SPC> 1 <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              nei <SPC> = <SPC> node [ 0 ] <SPC> + <SPC> d [ 0 ] , <SPC> node [ 1 ] <SPC> + <SPC> d [ 1 ] <NL>              if <SPC> ( <NL>                  not <SPC> ( 0 <SPC> <= <SPC> nei [ 0 ] <SPC> < <SPC> len ( A ) <SPC> and <SPC> 0 <SPC> <= <SPC> nei [ 1 ] <SPC> < <SPC> len ( A [ 0 ] ) ) <NL>                  or <SPC> nei <SPC> in <SPC> lookup <NL>              ) : <NL>                  continue <NL>              q . append ( ( nei , <SPC> dis <SPC> + <SPC> 1 ) ) <NL>              lookup . add ( nei ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestCommonSupersequence ( self , <SPC> str1 , <SPC> str2 ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( str2 ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> bt <SPC> = <SPC> [ [ None <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( str2 ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( str1 ) <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( str1 ) : <NL>          bt [ i <SPC> + <SPC> 1 ] [ 0 ] <SPC> = <SPC> ( i , <SPC> 0 , <SPC> c ) <NL> <TAB> for <SPC> j , <SPC> c <SPC> in <SPC> enumerate ( str2 ) : <NL>          bt [ 0 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> ( 0 , <SPC> j , <SPC> c ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( str1 ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( str2 ) ) : <NL>              if <SPC> dp [ i <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> > <SPC> dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> dp [ i <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <NL>                  bt [ i <SPC> + <SPC> 1 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> ( i , <SPC> j <SPC> + <SPC> 1 , <SPC> str1 [ i ] ) <NL>              else : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] <NL>                  bt [ i <SPC> + <SPC> 1 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> ( i <SPC> + <SPC> 1 , <SPC> j , <SPC> str2 [ j ] ) <NL>              if <SPC> str1 [ i ] <SPC> != <SPC> str2 [ j ] : <NL>                  continue <NL>              if <SPC> dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> + <SPC> 1 <SPC> > <SPC> dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] : <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> + <SPC> 1 <NL>                  bt [ i <SPC> + <SPC> 1 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> ( i , <SPC> j , <SPC> str1 [ i ] ) <NL> <NL> <TAB> i , <SPC> j <SPC> = <SPC> len ( str1 ) , <SPC> len ( str2 ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> i <SPC> != <SPC> 0 <SPC> or <SPC> j <SPC> != <SPC> 0 : <NL>          i , <SPC> j , <SPC> c <SPC> = <SPC> bt [ i ] [ j ] <NL>          result . append ( c ) <NL> <TAB> result . reverse ( ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestCompletingWord ( self , <SPC> licensePlate , <SPC> words ) : <NL> <NL> <TAB> def <SPC> contains ( counter1 , <SPC> w2 ) : <NL>          c2 <SPC> = <SPC> collections . Counter ( w2 . lower ( ) ) <NL>          c2 . subtract ( counter1 ) <NL>          return <SPC> all ( map ( lambda <SPC> x : <SPC> x <SPC> >= <SPC> 0 , <SPC> c2 . values ( ) ) ) <NL> <NL> <TAB> result <SPC> = <SPC> None <NL> <TAB> counter <SPC> = <SPC> collections . Counter ( c . lower ( ) <NL>                                    for <SPC> c <SPC> in <SPC> licensePlate <SPC> if <SPC> c . isalpha ( ) ) <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          if <SPC> ( result <SPC> is <SPC> None <SPC> or <SPC> ( len ( word ) <SPC> < <SPC> len ( result ) ) ) <SPC> and <SPC> contains ( <NL>              counter , <SPC> word <NL>          ) : <NL>              result <SPC> = <SPC> word <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestDistance ( self , <SPC> grid ) : <NL> <NL> <TAB> def <SPC> bfs ( grid , <SPC> dists , <SPC> cnts , <SPC> x , <SPC> y ) : <NL>          dist , <SPC> m , <SPC> n <SPC> = <SPC> 0 , <SPC> len ( grid ) , <SPC> len ( grid [ 0 ] ) <NL>          visited <SPC> = <SPC> [ [ False <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m ) ] <NL> <NL>          pre_level <SPC> = <SPC> [ ( x , <SPC> y ) ] <NL>          visited [ x ] [ y ] <SPC> = <SPC> True <NL>          while <SPC> pre_level : <NL>              dist <SPC> += <SPC> 1 <NL>              cur_level <SPC> = <SPC> [ ] <NL>              for <SPC> i , <SPC> j <SPC> in <SPC> pre_level : <NL>                  for <SPC> dir <SPC> in <SPC> [ ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) ] : <NL>                      I , <SPC> J <SPC> = <SPC> i <SPC> + <SPC> dir [ 0 ] , <SPC> j <SPC> + <SPC> dir [ 1 ] <NL>                      if <SPC> ( <NL>                          0 <SPC> <= <SPC> I <SPC> < <SPC> m <NL>                          and <SPC> 0 <SPC> <= <SPC> J <SPC> < <SPC> n <NL>                          and <SPC> grid [ I ] [ J ] <SPC> == <SPC> 0 <NL>                          and <SPC> not <SPC> visited [ I ] [ J ] <NL>                      ) : <NL>                          cnts [ I ] [ J ] <SPC> += <SPC> 1 <NL>                          dists [ I ] [ J ] <SPC> += <SPC> dist <NL>                          cur_level . append ( ( I , <SPC> J ) ) <NL>                          visited [ I ] [ J ] <SPC> = <SPC> True <NL> <NL>              pre_level <SPC> = <SPC> cur_level <NL> <NL> <TAB> m , <SPC> n , <SPC> cnt <SPC> = <SPC> len ( grid ) , <SPC> len ( grid [ 0 ] ) , <SPC> 0 <NL> <TAB> dists <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m ) ] <NL> <TAB> cnts <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> grid [ i ] [ j ] <SPC> == <SPC> 1 : <NL>                  cnt <SPC> += <SPC> 1 <NL>                  bfs ( grid , <SPC> dists , <SPC> cnts , <SPC> i , <SPC> j ) <NL> <NL> <TAB> shortest <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> dists [ i ] [ j ] <SPC> < <SPC> shortest <SPC> and <SPC> cnts [ i ] [ j ] <SPC> == <SPC> cnt : <NL>                  shortest <SPC> = <SPC> dists [ i ] [ j ] <NL> <NL> <TAB> return <SPC> shortest <SPC> if <SPC> shortest <SPC> != <SPC> float ( "inf" ) <SPC> else <SPC> - 1 <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestToChar ( self , <SPC> S , <SPC> C ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ len ( S ) ] <SPC> * <SPC> len ( S ) <NL> <TAB> prev <SPC> = <SPC> - len ( S ) <NL> <TAB> for <SPC> i <SPC> in <SPC> itertools . chain ( xrange ( len ( S ) ) , <SPC> reversed ( xrange ( len ( S ) ) ) ) : <NL>          if <SPC> S [ i ] <SPC> == <SPC> C : <NL>              prev <SPC> = <SPC> i <NL>          result [ i ] <SPC> = <SPC> min ( result [ i ] , <SPC> abs ( i <SPC> - <SPC> prev ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestDistanceColor ( self , <SPC> colors , <SPC> queries ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ - 1 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( colors ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 3 ) ] <NL> <TAB> dp [ colors [ 0 ] <SPC> - <SPC> 1 ] [ 0 ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( colors ) ) : <NL>          for <SPC> color <SPC> in <SPC> xrange ( 3 ) : <NL>              dp [ color ] [ i ] <SPC> = <SPC> dp [ color ] [ i <SPC> - <SPC> 1 ] <NL>          dp [ colors [ i ] <SPC> - <SPC> 1 ] [ i ] <SPC> = <SPC> i <NL> <NL> <TAB> dp [ colors [ len ( colors ) <SPC> - <SPC> 1 ] <SPC> - <SPC> 1 ] [ len ( colors ) <SPC> - <SPC> 1 ] <SPC> = <SPC> len ( colors ) <SPC> - <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( colors ) <SPC> - <SPC> 1 ) ) : <NL>          for <SPC> color <SPC> in <SPC> xrange ( 3 ) : <NL>              if <SPC> dp [ color ] [ i <SPC> + <SPC> 1 ] <SPC> == <SPC> - 1 : <NL>                  continue <NL>              if <SPC> dp [ color ] [ i ] <SPC> == <SPC> - 1 <SPC> or <SPC> abs ( dp [ color ] [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> i ) <SPC> < <SPC> abs ( <NL>                  dp [ color ] [ i ] <SPC> - <SPC> i <NL>              ) : <NL>                  dp [ color ] [ i ] <SPC> = <SPC> dp [ color ] [ i <SPC> + <SPC> 1 ] <NL>          dp [ colors [ i ] <SPC> - <SPC> 1 ] [ i ] <SPC> = <SPC> i <NL> <NL> <TAB> return <SPC> [ <NL>          abs ( dp [ color <SPC> - <SPC> 1 ] [ i ] <SPC> - <SPC> i ) <SPC> if <SPC> dp [ color <SPC> - <SPC> 1 ] [ i ] <SPC> != <SPC> - 1 <SPC> else <SPC> - 1 <NL>          for <SPC> i , <SPC> color <SPC> in <SPC> queries <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestPalindrome ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> getPrefix ( pattern ) : <NL>          prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>              while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              prefix [ i ] <SPC> = <SPC> j <NL>          return <SPC> prefix <NL> <NL> <TAB> if <SPC> not <SPC> s : <NL>          return <SPC> s <NL> <NL> <TAB> A <SPC> = <SPC> s <SPC> + <SPC> "#" <SPC> + <SPC> s [ : : - 1 ] <NL> <TAB> return <SPC> s [ getPrefix ( A ) [ - 1 ] <SPC> + <SPC> 1 : ] [ : : - 1 ] <SPC> + <SPC> s <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> shortestPalindrome ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> getPrefix ( pattern ) : <NL>          prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>              while <SPC> j <SPC> > <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              prefix [ i ] <SPC> = <SPC> j <NL>          return <SPC> prefix <NL> <NL> <TAB> if <SPC> not <SPC> s : <NL>          return <SPC> s <NL> <NL> <TAB> A <SPC> = <SPC> s <SPC> + <SPC> s [ : : - 1 ] <NL> <TAB> prefix <SPC> = <SPC> getPrefix ( A ) <NL> <TAB> i <SPC> = <SPC> prefix [ - 1 ] <NL> <TAB> while <SPC> i <SPC> >= <SPC> len ( s ) : <NL>          i <SPC> = <SPC> prefix [ i ] <NL> <TAB> return <SPC> s [ i <SPC> + <SPC> 1 : ] [ : : - 1 ] <SPC> + <SPC> s <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> shortestPalindrome ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> preProcess ( s ) : <NL>          if <SPC> not <SPC> s : <NL>              return <SPC> [ "^" , <SPC> "$" ] <NL>          string <SPC> = <SPC> [ "^" ] <NL>          for <SPC> c <SPC> in <SPC> s : <NL>              string <SPC> += <SPC> [ "#" , <SPC> c ] <NL>          string <SPC> += <SPC> [ "#" , <SPC> "$" ] <NL>          return <SPC> string <NL> <NL> <TAB> string <SPC> = <SPC> preProcess ( s ) <NL> <TAB> palindrome <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( string ) <NL> <TAB> center , <SPC> right <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( string ) <SPC> - <SPC> 1 ) : <NL>          i_mirror <SPC> = <SPC> 2 <SPC> * <SPC> center <SPC> - <SPC> i <NL>          if <SPC> right <SPC> > <SPC> i : <NL>              palindrome [ i ] <SPC> = <SPC> min ( right <SPC> - <SPC> i , <SPC> palindrome [ i_mirror ] ) <NL>          else : <NL>              palindrome [ i ] <SPC> = <SPC> 0 <NL> <NL>          while <SPC> string [ i <SPC> + <SPC> 1 <SPC> + <SPC> palindrome [ i ] ] <SPC> == <SPC> string [ i <SPC> - <SPC> 1 <SPC> - <SPC> palindrome [ i ] ] : <NL>              palindrome [ i ] <SPC> += <SPC> 1 <NL> <NL>          if <SPC> i <SPC> + <SPC> palindrome [ i ] <SPC> > <SPC> right : <NL>              center , <SPC> right <SPC> = <SPC> i , <SPC> i <SPC> + <SPC> palindrome [ i ] <NL> <NL> <TAB> max_len <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( string ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> i <SPC> - <SPC> palindrome [ i ] <SPC> == <SPC> 1 : <NL>              max_len <SPC> = <SPC> palindrome [ i ] <NL> <TAB> return <SPC> s [ len ( s ) <SPC> - <SPC> 1 : <SPC> max_len <SPC> - <SPC> 1 : <SPC> - 1 ] <SPC> + <SPC> s <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestPath ( self , <SPC> grid , <SPC> k ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> dot ( a , <SPC> b ) : <NL>          return <SPC> a [ 0 ] <SPC> * <SPC> b [ 0 ] <SPC> + <SPC> a [ 1 ] <SPC> * <SPC> b [ 1 ] <NL> <NL> <TAB> def <SPC> g ( a , <SPC> b ) : <NL>          return <SPC> abs ( a [ 0 ] <SPC> - <SPC> b [ 0 ] ) <SPC> + <SPC> abs ( a [ 1 ] <SPC> - <SPC> b [ 1 ] ) <NL> <NL> <TAB> def <SPC> a_star ( grid , <SPC> b , <SPC> t , <SPC> k ) : <NL>          f , <SPC> dh <SPC> = <SPC> g ( b , <SPC> t ) , <SPC> 2 <NL>          closer , <SPC> detour <SPC> = <SPC> [ ( b , <SPC> k ) ] , <SPC> [ ] <NL>          lookup <SPC> = <SPC> { } <NL>          while <SPC> closer <SPC> or <SPC> detour : <NL>              if <SPC> not <SPC> closer : <NL>                  f <SPC> += <SPC> dh <NL>                  closer , <SPC> detour <SPC> = <SPC> detour , <SPC> closer <NL>              b , <SPC> k <SPC> = <SPC> closer . pop ( ) <NL>              if <SPC> b <SPC> == <SPC> t : <NL>                  return <SPC> f <NL>              if <SPC> b <SPC> in <SPC> lookup <SPC> and <SPC> lookup [ b ] <SPC> >= <SPC> k : <NL>                  continue <NL>              lookup [ b ] <SPC> = <SPC> k <NL>              for <SPC> dx , <SPC> dy <SPC> in <SPC> directions : <NL>                  nb <SPC> = <SPC> ( b [ 0 ] <SPC> + <SPC> dx , <SPC> b [ 1 ] <SPC> + <SPC> dy ) <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> nb [ 0 ] <SPC> < <SPC> len ( grid ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nb [ 1 ] <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                      and <SPC> ( grid [ nb [ 0 ] ] [ nb [ 1 ] ] <SPC> == <SPC> 0 <SPC> or <SPC> k <SPC> > <SPC> 0 ) <NL>                      and <SPC> ( nb <SPC> not <SPC> in <SPC> lookup <SPC> or <SPC> lookup [ nb ] <SPC> < <SPC> k ) <NL>                  ) : <NL>                      continue <NL>                  ( <NL>                      closer <NL>                      if <SPC> dot ( ( dx , <SPC> dy ) , <SPC> ( t [ 0 ] <SPC> - <SPC> b [ 0 ] , <SPC> t [ 1 ] <SPC> - <SPC> b [ 1 ] ) ) <SPC> > <SPC> 0 <NL>                      else <SPC> detour <NL>                  ) . append ( ( nb , <SPC> k <SPC> - <SPC> int ( grid [ nb [ 0 ] ] [ nb [ 1 ] ] <SPC> == <SPC> 1 ) ) ) <NL>          return <SPC> - 1 <NL> <NL> <TAB> return <SPC> a_star ( grid , <SPC> ( 0 , <SPC> 0 ) , <SPC> ( len ( grid ) <SPC> - <SPC> 1 , <SPC> len ( grid [ 0 ] ) <SPC> - <SPC> 1 ) , <SPC> k ) <NL> <NL> <NL> class <SPC> GridMaster ( object ) : <NL> <TAB> def <SPC> canMove ( self , <SPC> direction ) : <NL> <TAB> pass <NL> <NL> <TAB> def <SPC> move ( self , <SPC> direction ) : <NL> <TAB> pass <NL> <NL> <TAB> def <SPC> isTarget ( self ) : <NL> <TAB> pass <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findShortestPath ( self , <SPC> master ) : <NL> <NL> <TAB> directions <SPC> = <SPC> { "L" : <SPC> ( 0 , <SPC> - 1 ) , <SPC> "R" : <SPC> ( 0 , <SPC> 1 ) , <SPC> "U" : <SPC> ( - 1 , <SPC> 0 ) , <SPC> "D" : <SPC> ( 1 , <SPC> 0 ) } <NL> <TAB> rollback <SPC> = <SPC> { "L" : <SPC> "R" , <SPC> "R" : <SPC> "L" , <SPC> "U" : <SPC> "D" , <SPC> "D" : <SPC> "U" } <NL> <NL> <TAB> def <SPC> dfs ( pos , <SPC> target , <SPC> master , <SPC> lookup , <SPC> adj ) : <NL>          if <SPC> target [ 0 ] <SPC> is <SPC> None <SPC> and <SPC> master . isTarget ( ) : <NL>              target [ 0 ] <SPC> = <SPC> pos <NL>          lookup . add ( pos ) <NL>          for <SPC> d , <SPC> ( di , <SPC> dj ) <SPC> in <SPC> directions . iteritems ( ) : <NL>              if <SPC> not <SPC> master . canMove ( d ) : <NL>                  continue <NL>              nei <SPC> = <SPC> ( pos [ 0 ] <SPC> + <SPC> di , <SPC> pos [ 1 ] <SPC> + <SPC> dj ) <NL>              adj [ pos ] . add ( nei ) <NL>              adj [ nei ] . add ( pos ) <NL>              if <SPC> nei <SPC> in <SPC> lookup : <NL>                  continue <NL>              master . move ( d ) <NL>              dfs ( nei , <SPC> target , <SPC> master , <SPC> lookup , <SPC> adj ) <NL>              master . move ( rollback [ d ] ) <NL> <NL> <TAB> def <SPC> bi_bfs ( start , <SPC> target , <SPC> adj ) : <NL>          lookup <SPC> = <SPC> set ( ) <NL>          left , <SPC> right <SPC> = <SPC> set ( [ start ] ) , <SPC> set ( [ target ] ) <NL>          steps <SPC> = <SPC> 0 <NL>          while <SPC> left : <NL>              for <SPC> pos <SPC> in <SPC> left : <NL>                  lookup . add ( pos ) <NL>              new_left <SPC> = <SPC> set ( ) <NL>              for <SPC> pos <SPC> in <SPC> left : <NL>                  if <SPC> pos <SPC> in <SPC> right : <NL>                      return <SPC> steps <NL>                  for <SPC> nei <SPC> in <SPC> adj [ pos ] : <NL>                      if <SPC> nei <SPC> in <SPC> lookup : <NL>                          continue <NL>                      new_left . add ( nei ) <NL>              left <SPC> = <SPC> new_left <NL>              steps <SPC> += <SPC> 1 <NL>              if <SPC> len ( left ) <SPC> > <SPC> len ( right ) : <NL>                  left , <SPC> right <SPC> = <SPC> right , <SPC> left <NL>          return <SPC> - 1 <NL> <NL> <TAB> start <SPC> = <SPC> ( 0 , <SPC> 0 ) <NL> <TAB> target <SPC> = <SPC> [ None ] <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> dfs ( start , <SPC> target , <SPC> master , <SPC> set ( ) , <SPC> adj ) <NL> <TAB> if <SPC> not <SPC> target [ 0 ] : <NL>          return <SPC> - 1 <NL> <TAB> return <SPC> bi_bfs ( start , <SPC> target [ 0 ] , <SPC> adj ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findShortestPath ( self , <SPC> master ) : <NL> <NL> <TAB> directions <SPC> = <SPC> { "L" : <SPC> ( 0 , <SPC> - 1 ) , <SPC> "R" : <SPC> ( 0 , <SPC> 1 ) , <SPC> "U" : <SPC> ( - 1 , <SPC> 0 ) , <SPC> "D" : <SPC> ( 1 , <SPC> 0 ) } <NL> <TAB> rollback <SPC> = <SPC> { "L" : <SPC> "R" , <SPC> "R" : <SPC> "L" , <SPC> "U" : <SPC> "D" , <SPC> "D" : <SPC> "U" } <NL> <NL> <TAB> def <SPC> dfs ( pos , <SPC> target , <SPC> master , <SPC> lookup , <SPC> adj ) : <NL>          if <SPC> target [ 0 ] <SPC> is <SPC> None <SPC> and <SPC> master . isTarget ( ) : <NL>              target [ 0 ] <SPC> = <SPC> pos <NL>          lookup . add ( pos ) <NL>          for <SPC> d , <SPC> ( di , <SPC> dj ) <SPC> in <SPC> directions . iteritems ( ) : <NL>              if <SPC> not <SPC> master . canMove ( d ) : <NL>                  continue <NL>              nei <SPC> = <SPC> ( pos [ 0 ] <SPC> + <SPC> di , <SPC> pos [ 1 ] <SPC> + <SPC> dj ) <NL>              adj [ pos ] . add ( nei ) <NL>              adj [ nei ] . add ( pos ) <NL>              if <SPC> nei <SPC> in <SPC> lookup : <NL>                  continue <NL>              master . move ( d ) <NL>              dfs ( nei , <SPC> target , <SPC> master , <SPC> lookup , <SPC> adj ) <NL>              master . move ( rollback [ d ] ) <NL> <NL> <TAB> def <SPC> bfs ( start , <SPC> target , <SPC> adj ) : <NL>          q <SPC> = <SPC> [ start ] <NL>          lookup <SPC> = <SPC> set ( q ) <NL>          steps <SPC> = <SPC> 0 <NL>          while <SPC> q : <NL>              new_q <SPC> = <SPC> [ ] <NL>              for <SPC> pos <SPC> in <SPC> q : <NL>                  if <SPC> pos <SPC> == <SPC> target : <NL>                      return <SPC> steps <NL>                  for <SPC> nei <SPC> in <SPC> adj [ pos ] : <NL>                      if <SPC> nei <SPC> in <SPC> lookup : <NL>                          continue <NL>                      lookup . add ( nei ) <NL>                      new_q . append ( nei ) <NL>              q <SPC> = <SPC> new_q <NL>              steps <SPC> += <SPC> 1 <NL>          return <SPC> - 1 <NL> <NL> <TAB> start <SPC> = <SPC> ( 0 , <SPC> 0 ) <NL> <TAB> target <SPC> = <SPC> [ None ] <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> dfs ( start , <SPC> target , <SPC> master , <SPC> set ( ) , <SPC> adj ) <NL> <TAB> if <SPC> not <SPC> target [ 0 ] : <NL>          return <SPC> - 1 <NL> <TAB> return <SPC> bfs ( start , <SPC> target [ 0 ] , <SPC> adj ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestPathBinaryMatrix ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ <NL>          ( - 1 , <SPC> - 1 ) , <NL>          ( - 1 , <SPC> 0 ) , <NL>          ( - 1 , <SPC> 1 ) , <NL>          ( 0 , <SPC> - 1 ) , <NL>          ( 0 , <SPC> 1 ) , <NL>          ( 1 , <SPC> - 1 ) , <NL>          ( 1 , <SPC> 0 ) , <NL>          ( 1 , <SPC> 1 ) , <NL> <TAB> ] <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ ( 0 , <SPC> 0 ) ] ) <NL> <TAB> while <SPC> q : <NL>          result <SPC> += <SPC> 1 <NL>          next_depth <SPC> = <SPC> collections . deque ( ) <NL>          while <SPC> q : <NL>              i , <SPC> j <SPC> = <SPC> q . popleft ( ) <NL>              if <SPC> 0 <SPC> <= <SPC> i <SPC> < <SPC> len ( grid ) <SPC> and <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> len ( grid [ 0 ] ) <SPC> and <SPC> not <SPC> grid [ i ] [ j ] : <NL>                  grid [ i ] [ j ] <SPC> = <SPC> 1 <NL>                  if <SPC> i <SPC> == <SPC> len ( grid ) <SPC> - <SPC> 1 <SPC> and <SPC> j <SPC> == <SPC> len ( grid ) <SPC> - <SPC> 1 : <NL>                      return <SPC> result <NL>                  for <SPC> d <SPC> in <SPC> directions : <NL>                      next_depth . append ( ( i <SPC> + <SPC> d [ 0 ] , <SPC> j <SPC> + <SPC> d [ 1 ] ) ) <NL>          q <SPC> = <SPC> next_depth <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestPathAllKeys ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> bfs ( grid , <SPC> source , <SPC> locations ) : <NL>          r , <SPC> c <SPC> = <SPC> locations [ source ] <NL>          lookup <SPC> = <SPC> [ [ False ] <SPC> * <SPC> ( len ( grid [ 0 ] ) ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( grid ) ) ] <NL>          lookup [ r ] [ c ] <SPC> = <SPC> True <NL>          q <SPC> = <SPC> collections . deque ( [ ( r , <SPC> c , <SPC> 0 ) ] ) <NL>          dist <SPC> = <SPC> { } <NL>          while <SPC> q : <NL>              r , <SPC> c , <SPC> d <SPC> = <SPC> q . popleft ( ) <NL>              if <SPC> source <SPC> != <SPC> grid [ r ] [ c ] <SPC> != <SPC> "." : <NL>                  dist [ grid [ r ] [ c ] ] <SPC> = <SPC> d <NL>                  continue <NL>              for <SPC> direction <SPC> in <SPC> directions : <NL>                  cr , <SPC> cc <SPC> = <SPC> r <SPC> + <SPC> direction [ 0 ] , <SPC> c <SPC> + <SPC> direction [ 1 ] <NL>                  if <SPC> not <SPC> ( ( 0 <SPC> <= <SPC> cr <SPC> < <SPC> len ( grid ) ) <SPC> and <SPC> ( 0 <SPC> <= <SPC> cc <SPC> < <SPC> len ( grid [ cr ] ) ) ) : <NL>                      continue <NL>                  if <SPC> grid [ cr ] [ cc ] <SPC> != <SPC> "#" <SPC> and <SPC> not <SPC> lookup [ cr ] [ cc ] : <NL>                      lookup [ cr ] [ cc ] <SPC> = <SPC> True <NL>                      q . append ( ( cr , <SPC> cc , <SPC> d <SPC> + <SPC> 1 ) ) <NL>          return <SPC> dist <NL> <NL> <TAB> locations <SPC> = <SPC> { <NL>          place : <SPC> ( r , <SPC> c ) <NL>          for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( grid ) <NL>          for <SPC> c , <SPC> place <SPC> in <SPC> enumerate ( row ) <NL>          if <SPC> place <SPC> not <SPC> in <SPC> ".#" <NL> <TAB> } <NL> <TAB> dists <SPC> = <SPC> { place : <SPC> bfs ( grid , <SPC> place , <SPC> locations ) <SPC> for <SPC> place <SPC> in <SPC> locations } <NL> <NL> <TAB> min_heap <SPC> = <SPC> [ ( 0 , <SPC> "@" , <SPC> 0 ) ] <NL> <TAB> best <SPC> = <SPC> collections . defaultdict ( <NL>          lambda : <SPC> collections . defaultdict ( lambda : <SPC> float ( "inf" ) ) <NL> <TAB> ) <NL> <TAB> best [ "@" ] [ 0 ] <SPC> = <SPC> 0 <NL> <TAB> target_state <SPC> = <SPC> 2 <SPC> ** <SPC> sum ( place . islower ( ) <SPC> for <SPC> place <SPC> in <SPC> locations ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> min_heap : <NL>          cur_d , <SPC> place , <SPC> state <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> best [ place ] [ state ] <SPC> < <SPC> cur_d : <NL>              continue <NL>          if <SPC> state <SPC> == <SPC> target_state : <NL>              return <SPC> cur_d <NL>          for <SPC> dest , <SPC> d <SPC> in <SPC> dists [ place ] . iteritems ( ) : <NL>              next_state <SPC> = <SPC> state <NL>              if <SPC> dest . islower ( ) : <NL>                  next_state <SPC> |= <SPC> 1 <SPC> << <SPC> ( ord ( dest ) <SPC> - <SPC> ord ( "a" ) ) <NL>              elif <SPC> dest . isupper ( ) : <NL>                  if <SPC> not <SPC> ( state <SPC> & <SPC> ( 1 <SPC> << <SPC> ( ord ( dest ) <SPC> - <SPC> ord ( "A" ) ) ) ) : <NL>                      continue <NL>              if <SPC> cur_d <SPC> + <SPC> d <SPC> < <SPC> best [ dest ] [ next_state ] : <NL>                  best [ dest ] [ next_state ] <SPC> = <SPC> cur_d <SPC> + <SPC> d <NL>                  heapq . heappush ( min_heap , <SPC> ( cur_d <SPC> + <SPC> d , <SPC> dest , <SPC> next_state ) ) <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getFood ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> q <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> r <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>              if <SPC> grid [ r ] [ c ] <SPC> == <SPC> "*" : <NL>                  q . append ( ( r , <SPC> c ) ) <NL>                  break <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> while <SPC> q : <NL>          result <SPC> += <SPC> 1 <NL>          new_q <SPC> = <SPC> [ ] <NL>          for <SPC> r , <SPC> c <SPC> in <SPC> q : <NL>              for <SPC> dr , <SPC> dc <SPC> in <SPC> directions : <NL>                  nr , <SPC> nc <SPC> = <SPC> r <SPC> + <SPC> dr , <SPC> c <SPC> + <SPC> dc <NL>                  if <SPC> not <SPC> ( <NL>                      0 <SPC> <= <SPC> nr <SPC> < <SPC> len ( grid ) <NL>                      and <SPC> 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                      and <SPC> grid [ nr ] [ nc ] <SPC> != <SPC> "X" <NL>                  ) : <NL>                      continue <NL>                  if <SPC> grid [ nr ] [ nc ] <SPC> == <SPC> "#" : <NL>                      return <SPC> result <NL>                  grid [ nr ] [ nc ] <SPC> = <SPC> "X" <NL>                  new_q . append ( ( nr , <SPC> nc ) ) <NL>          q <SPC> = <SPC> new_q <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestPathLength ( self , <SPC> graph ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ float ( "inf" ) ] <SPC> * <SPC> ( len ( graph ) ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 1 <SPC> << <SPC> len ( graph ) ) ] <NL> <TAB> q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( graph ) ) : <NL>          dp [ 1 <SPC> << <SPC> i ] [ i ] <SPC> = <SPC> 0 <NL>          q . append ( ( 1 <SPC> << <SPC> i , <SPC> i ) ) <NL> <TAB> while <SPC> q : <NL>          state , <SPC> node <SPC> = <SPC> q . popleft ( ) <NL>          steps <SPC> = <SPC> dp [ state ] [ node ] <NL>          for <SPC> nei <SPC> in <SPC> graph [ node ] : <NL>              new_state <SPC> = <SPC> state <SPC> | <SPC> ( 1 <SPC> << <SPC> nei ) <NL>              if <SPC> dp [ new_state ] [ nei ] <SPC> == <SPC> float ( "inf" ) : <NL>                  dp [ new_state ] [ nei ] <SPC> = <SPC> steps <SPC> + <SPC> 1 <NL>                  q . append ( ( new_state , <SPC> nei ) ) <NL> <TAB> return <SPC> min ( dp [ - 1 ] ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestAlternatingPaths ( self , <SPC> n , <SPC> red_edges , <SPC> blue_edges ) : <NL> <NL> <TAB> neighbors <SPC> = <SPC> [ [ set ( ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> red_edges : <NL>          neighbors [ i ] [ 0 ] . add ( j ) <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> blue_edges : <NL>          neighbors [ i ] [ 1 ] . add ( j ) <NL> <TAB> INF <SPC> = <SPC> max ( 2 <SPC> * <SPC> n <SPC> - <SPC> 3 , <SPC> 0 ) <SPC> + <SPC> 1 <NL> <TAB> dist <SPC> = <SPC> [ [ INF , <SPC> INF ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> dist [ 0 ] <SPC> = <SPC> [ 0 , <SPC> 0 ] <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ ( 0 , <SPC> 0 ) , <SPC> ( 0 , <SPC> 1 ) ] ) <NL> <TAB> while <SPC> q : <NL>          i , <SPC> c <SPC> = <SPC> q . popleft ( ) <NL>          for <SPC> j <SPC> in <SPC> neighbors [ i ] [ c ] : <NL>              if <SPC> dist [ j ] [ c ] <SPC> != <SPC> INF : <NL>                  continue <NL>              dist [ j ] [ c ] <SPC> = <SPC> dist [ i ] [ 1 <SPC> ^ <SPC> c ] <SPC> + <SPC> 1 <NL>              q . append ( ( j , <SPC> 1 <SPC> ^ <SPC> c ) ) <NL> <TAB> return <SPC> [ x <SPC> if <SPC> x <SPC> != <SPC> INF <SPC> else <SPC> - 1 <SPC> for <SPC> x <SPC> in <SPC> map ( min , <SPC> dist ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLengthOfShortestSubarray ( self , <SPC> arr ) : <NL> <NL> <TAB> j <SPC> = <SPC> - 1 <NL> <TAB> for <SPC> j <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> len ( arr ) ) ) : <NL>          if <SPC> arr [ j <SPC> - <SPC> 1 ] <SPC> > <SPC> arr [ j ] : <NL>              break <NL> <TAB> else : <NL>          return <SPC> 0 <NL> <TAB> result <SPC> = <SPC> j <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( j ) : <NL>          if <SPC> i <SPC> and <SPC> arr [ i ] <SPC> < <SPC> arr [ i <SPC> - <SPC> 1 ] : <NL>              break <NL>          while <SPC> j <SPC> < <SPC> len ( arr ) <SPC> and <SPC> arr [ i ] <SPC> > <SPC> arr [ j ] : <NL>              j <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> min ( result , <SPC> ( j <SPC> - <SPC> i <SPC> + <SPC> 1 ) <SPC> - <SPC> 2 ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findLengthOfShortestSubarray ( self , <SPC> arr ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( arr ) ) : <NL>          if <SPC> arr [ i <SPC> - <SPC> 1 ] <SPC> <= <SPC> arr [ i ] : <NL>              continue <NL>          j <SPC> = <SPC> len ( arr ) <SPC> - <SPC> 1 <NL>          while <SPC> ( <NL>              j <SPC> > <SPC> i <NL>              and <SPC> ( j <SPC> == <SPC> len ( arr ) <SPC> - <SPC> 1 <SPC> or <SPC> arr [ j ] <SPC> <= <SPC> arr [ j <SPC> + <SPC> 1 ] ) <NL>              and <SPC> arr [ i <SPC> - <SPC> 1 ] <SPC> <= <SPC> arr [ j ] <NL>          ) : <NL>              j <SPC> -= <SPC> 1 <NL>          result <SPC> = <SPC> j <SPC> - <SPC> i <SPC> + <SPC> 1 <NL>          break <NL> <TAB> for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( arr ) <SPC> - <SPC> 1 ) ) : <NL>          if <SPC> arr [ j ] <SPC> <= <SPC> arr [ j <SPC> + <SPC> 1 ] : <NL>              continue <NL>          i <SPC> = <SPC> 0 <NL>          while <SPC> i <SPC> < <SPC> j <SPC> and <SPC> ( i <SPC> == <SPC> 0 <SPC> or <SPC> arr [ i <SPC> - <SPC> 1 ] <SPC> <= <SPC> arr [ i ] ) <SPC> and <SPC> arr [ i ] <SPC> <= <SPC> arr [ j <SPC> + <SPC> 1 ] : <NL>              i <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> min ( result , <SPC> j <SPC> - <SPC> i <SPC> + <SPC> 1 ) <NL>          break <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestSubarray ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> accumulated_sum <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( len ( A ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          accumulated_sum [ i <SPC> + <SPC> 1 ] <SPC> = <SPC> accumulated_sum [ i ] <SPC> + <SPC> A [ i ] <NL> <NL> <TAB> result <SPC> = <SPC> float ( "inf" ) <NL> <TAB> mono_increasing_q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> i , <SPC> curr <SPC> in <SPC> enumerate ( accumulated_sum ) : <NL>          while <SPC> mono_increasing_q <SPC> and <SPC> curr <SPC> <= <SPC> accumulated_sum [ mono_increasing_q [ - 1 ] ] : <NL>              mono_increasing_q . pop ( ) <NL>          while <SPC> ( <NL>              mono_increasing_q <SPC> and <SPC> curr <SPC> - <NL>                  accumulated_sum [ mono_increasing_q [ 0 ] ] <SPC> >= <SPC> K <NL>          ) : <NL>              result <SPC> = <SPC> min ( result , <SPC> i <SPC> - <SPC> mono_increasing_q . popleft ( ) ) <NL>          mono_increasing_q . append ( i ) <NL> <TAB> return <SPC> result <SPC> if <SPC> result <SPC> != <SPC> float ( "inf" ) <SPC> else <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findUnsortedSubarray ( self , <SPC> nums ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( nums ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> - 1 , <SPC> - 2 <NL> <TAB> min_from_right , <SPC> max_from_left <SPC> = <SPC> nums [ - 1 ] , <SPC> nums [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>          max_from_left <SPC> = <SPC> max ( max_from_left , <SPC> nums [ i ] ) <NL>          min_from_right <SPC> = <SPC> min ( min_from_right , <SPC> nums [ n <SPC> - <SPC> 1 <SPC> - <SPC> i ] ) <NL>          if <SPC> nums [ i ] <SPC> < <SPC> max_from_left : <NL>              right <SPC> = <SPC> i <NL>          if <SPC> nums [ n <SPC> - <SPC> 1 <SPC> - <SPC> i ] <SPC> > <SPC> min_from_right : <NL>              left <SPC> = <SPC> n <SPC> - <SPC> 1 <SPC> - <SPC> i <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findUnsortedSubarray ( self , <SPC> nums ) : <NL> <NL> <TAB> a <SPC> = <SPC> sorted ( nums ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> nums [ left ] <SPC> == <SPC> a [ left ] <SPC> or <SPC> nums [ right ] <SPC> == <SPC> a [ right ] : <NL>          if <SPC> right <SPC> - <SPC> left <SPC> <= <SPC> 1 : <NL>              return <SPC> 0 <NL>          if <SPC> nums [ left ] <SPC> == <SPC> a [ left ] : <NL>              left <SPC> += <SPC> 1 <NL>          if <SPC> nums [ right ] <SPC> == <SPC> a [ right ] : <NL>              right <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestWay ( self , <SPC> source , <SPC> target ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> [ [ None <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 26 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( source ) <SPC> + <SPC> 1 ) ] <NL> <TAB> find_char_next_pos <SPC> = <SPC> [ None ] <SPC> * <SPC> 26 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( source ) ) ) : <NL>          find_char_next_pos [ ord ( source [ i ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>          lookup [ i ] <SPC> = <SPC> list ( find_char_next_pos ) <NL> <NL> <TAB> result , <SPC> start <SPC> = <SPC> 1 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> target : <NL>          start <SPC> = <SPC> lookup [ start ] [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <NL>          if <SPC> start <SPC> != <SPC> None : <NL>              continue <NL>          result <SPC> += <SPC> 1 <NL>          start <SPC> = <SPC> lookup [ 0 ] [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <NL>          if <SPC> start <SPC> == <SPC> None : <NL>              return <SPC> - 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> WordDistance ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> words ) : <NL> <TAB> self . wordIndex <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) ) : <NL>          self . wordIndex [ words [ i ] ] . append ( i ) <NL> <NL> <TAB> def <SPC> shortest ( self , <SPC> word1 , <SPC> word2 ) : <NL> <TAB> indexes1 <SPC> = <SPC> self . wordIndex [ word1 ] <NL> <TAB> indexes2 <SPC> = <SPC> self . wordIndex [ word2 ] <NL> <NL> <TAB> i , <SPC> j , <SPC> dist <SPC> = <SPC> 0 , <SPC> 0 , <SPC> float ( "inf" ) <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( indexes1 ) <SPC> and <SPC> j <SPC> < <SPC> len ( indexes2 ) : <NL>          dist <SPC> = <SPC> min ( dist , <SPC> abs ( indexes1 [ i ] <SPC> - <SPC> indexes2 [ j ] ) ) <NL>          if <SPC> indexes1 [ i ] <SPC> < <SPC> indexes2 [ j ] : <NL>              i <SPC> += <SPC> 1 <NL>          else : <NL>              j <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> dist <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> shortestWordDistance ( self , <SPC> words , <SPC> word1 , <SPC> word2 ) : <NL> <TAB> dist <SPC> = <SPC> float ( "inf" ) <NL> <TAB> is_same <SPC> = <SPC> word1 <SPC> == <SPC> word2 <NL> <TAB> i , <SPC> index1 , <SPC> index2 <SPC> = <SPC> 0 , <SPC> None , <SPC> None <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( words ) : <NL>          if <SPC> words [ i ] <SPC> == <SPC> word1 : <NL>              if <SPC> is_same <SPC> and <SPC> index1 <SPC> is <SPC> not <SPC> None : <NL>                  dist <SPC> = <SPC> min ( dist , <SPC> abs ( index1 <SPC> - <SPC> i ) ) <NL>              index1 <SPC> = <SPC> i <NL>          elif <SPC> words [ i ] <SPC> == <SPC> word2 : <NL>              index2 <SPC> = <SPC> i <NL> <NL>          if <SPC> index1 <SPC> is <SPC> not <SPC> None <SPC> and <SPC> index2 <SPC> is <SPC> not <SPC> None : <NL>              dist <SPC> = <SPC> min ( dist , <SPC> abs ( index1 <SPC> - <SPC> index2 ) ) <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> dist <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> shortestDistance ( self , <SPC> words , <SPC> word1 , <SPC> word2 ) : <NL> <TAB> dist <SPC> = <SPC> float ( "inf" ) <NL> <TAB> i , <SPC> index1 , <SPC> index2 <SPC> = <SPC> 0 , <SPC> None , <SPC> None <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( words ) : <NL>          if <SPC> words [ i ] <SPC> == <SPC> word1 : <NL>              index1 <SPC> = <SPC> i <NL>          elif <SPC> words [ i ] <SPC> == <SPC> word2 : <NL>              index2 <SPC> = <SPC> i <NL> <NL>          if <SPC> index1 <SPC> is <SPC> not <SPC> None <SPC> and <SPC> index2 <SPC> is <SPC> not <SPC> None : <NL>              dist <SPC> = <SPC> min ( dist , <SPC> abs ( index1 <SPC> - <SPC> index2 ) ) <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> dist <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> nums ) : <NL> <NL> <TAB> self . __nums <SPC> = <SPC> nums <NL> <NL> <TAB> def <SPC> reset ( self ) : <NL> <NL> <TAB> return <SPC> self . __nums <NL> <NL> <TAB> def <SPC> shuffle ( self ) : <NL> <NL> <TAB> nums <SPC> = <SPC> list ( self . __nums ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          j <SPC> = <SPC> random . randint ( i , <SPC> len ( nums ) <SPC> - <SPC> 1 ) <NL>          nums [ i ] , <SPC> nums [ j ] <SPC> = <SPC> nums [ j ] , <SPC> nums [ i ] <NL> <TAB> return <SPC> nums <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> restoreString ( self , <SPC> s , <SPC> indices ) : <NL> <NL> <TAB> result <SPC> = <SPC> list ( s ) <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( result ) : <NL>          if <SPC> indices [ i ] <SPC> == <SPC> i : <NL>              continue <NL>          move , <SPC> j <SPC> = <SPC> c , <SPC> indices [ i ] <NL>          while <SPC> j <SPC> != <SPC> i : <NL>              result [ j ] , <SPC> move <SPC> = <SPC> move , <SPC> result [ j ] <NL>              indices [ j ] , <SPC> j <SPC> = <SPC> j , <SPC> indices [ j ] <NL>          result [ i ] <SPC> = <SPC> move <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> restoreString ( self , <SPC> s , <SPC> indices ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ "" ] <SPC> * <SPC> len ( s ) <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> itertools . izip ( indices , <SPC> s ) : <NL>          result [ i ] <SPC> = <SPC> c <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shuffle ( self , <SPC> nums , <SPC> n ) : <NL> <NL> <TAB> def <SPC> dest ( i , <SPC> n ) : <NL>          return <SPC> 2 <SPC> * <SPC> i <SPC> if <SPC> i <SPC> < <SPC> n <SPC> else <SPC> 2 <SPC> * <SPC> ( i <SPC> - <SPC> n ) <SPC> + <SPC> 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> nums [ i ] <SPC> < <SPC> 0 : <NL>              continue <NL>          j <SPC> = <SPC> i <NL>          while <SPC> True : <NL>              j <SPC> = <SPC> dest ( j , <SPC> n ) <NL>              nums [ i ] , <SPC> nums [ j ] <SPC> = <SPC> nums [ j ] , <SPC> nums [ i ] <NL>              nums [ j ] <SPC> = <SPC> - nums [ j ] <NL>              if <SPC> i <SPC> == <SPC> j : <NL>                  break <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          nums [ i ] <SPC> = <SPC> - nums [ i ] <NL> <TAB> return <SPC> nums <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> similarRGB ( self , <SPC> color ) : <NL> <NL> <TAB> def <SPC> rounding ( color ) : <NL>          q , <SPC> r <SPC> = <SPC> divmod ( int ( color , <SPC> 16 ) , <SPC> 17 ) <NL>          if <SPC> r <SPC> > <SPC> 8 : <NL>              q <SPC> += <SPC> 1 <NL>          return <SPC> "{:02x}" . format ( 17 <SPC> * <SPC> q ) <NL> <NL> <TAB> return <SPC> "#" <SPC> + <SPC> rounding ( color [ 1 : 3 ] ) <SPC> + <SPC> rounding ( color [ 3 : 5 ] ) <SPC> + <SPC> rounding ( color [ 5 : 7 ] ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . __size <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> self . __size <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> size ( self ) : <NL> <TAB> return <SPC> self . __size <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSimilarGroups ( self , <SPC> A ) : <NL> <NL> <TAB> def <SPC> isSimilar ( a , <SPC> b ) : <NL>          diff <SPC> = <SPC> 0 <NL>          for <SPC> x , <SPC> y <SPC> in <SPC> itertools . izip ( a , <SPC> b ) : <NL>              if <SPC> x <SPC> != <SPC> y : <NL>                  diff <SPC> += <SPC> 1 <NL>                  if <SPC> diff <SPC> > <SPC> 2 : <NL>                      return <SPC> False <NL>          return <SPC> diff <SPC> == <SPC> 2 <NL> <NL> <TAB> N , <SPC> L <SPC> = <SPC> len ( A ) , <SPC> len ( A [ 0 ] ) <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( N ) <NL> <TAB> if <SPC> N <SPC> < <SPC> L <SPC> * <SPC> L : <NL>          for <SPC> ( i1 , <SPC> word1 ) , <SPC> ( i2 , <SPC> word2 ) <SPC> in <SPC> itertools . combinations ( enumerate ( A ) , <SPC> 2 ) : <NL>              if <SPC> isSimilar ( word1 , <SPC> word2 ) : <NL>                  union_find . union_set ( i1 , <SPC> i2 ) <NL> <TAB> else : <NL>          buckets <SPC> = <SPC> collections . defaultdict ( list ) <NL>          lookup <SPC> = <SPC> set ( ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>              word <SPC> = <SPC> list ( A [ i ] ) <NL>              if <SPC> A [ i ] <SPC> not <SPC> in <SPC> lookup : <NL>                  buckets [ A [ i ] ] . append ( i ) <NL>                  lookup . add ( A [ i ] ) <NL>              for <SPC> j1 , <SPC> j2 <SPC> in <SPC> itertools . combinations ( xrange ( L ) , <SPC> 2 ) : <NL>                  word [ j1 ] , <SPC> word [ j2 ] <SPC> = <SPC> word [ j2 ] , <SPC> word [ j1 ] <NL>                  buckets [ "" . join ( word ) ] . append ( i ) <NL>                  word [ j1 ] , <SPC> word [ j2 ] <SPC> = <SPC> word [ j2 ] , <SPC> word [ j1 ] <NL>          for <SPC> word <SPC> in <SPC> A : <NL>              for <SPC> i1 , <SPC> i2 <SPC> in <SPC> itertools . combinations ( buckets [ word ] , <SPC> 2 ) : <NL>                  union_find . union_set ( i1 , <SPC> i2 ) <NL> <TAB> return <SPC> union_find . size ( ) <NL> <NL> <NL> import <SPC> fractions <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> simplifiedFractions ( self , <SPC> n ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> b <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          for <SPC> a <SPC> in <SPC> xrange ( 1 , <SPC> b ) : <NL>              g <SPC> = <SPC> fractions . gcd ( a , <SPC> b ) <NL>              lookup . add ( ( a <SPC> // <SPC> g , <SPC> b <SPC> // <SPC> g ) ) <NL> <TAB> return <SPC> map ( lambda <SPC> x : <SPC> "{}/{}" . format ( * x ) , <SPC> lookup ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> simplifyPath ( self , <SPC> path ) : <NL> <TAB> stack , <SPC> tokens <SPC> = <SPC> [ ] , <SPC> path . split ( "/" ) <NL> <TAB> for <SPC> token <SPC> in <SPC> tokens : <NL>          if <SPC> token <SPC> == <SPC> ".." <SPC> and <SPC> stack : <NL>              stack . pop ( ) <NL>          elif <SPC> token <SPC> != <SPC> ".." <SPC> and <SPC> token <SPC> != <SPC> "." <SPC> and <SPC> token : <NL>              stack . append ( token ) <NL> <TAB> return <SPC> "/" <SPC> + <SPC> "/" . join ( stack ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> singleNonDuplicate ( self , <SPC> nums ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> not <SPC> ( <NL>              mid <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> and <SPC> mid <SPC> + <SPC> 1 <SPC> < <SPC> len ( nums ) <SPC> and <SPC> nums [ mid ] <SPC> == <SPC> nums [ mid <SPC> + <SPC> 1 ] <NL>          ) <SPC> and <SPC> not <SPC> ( mid <SPC> % <SPC> 2 <SPC> == <SPC> 1 <SPC> and <SPC> nums [ mid ] <SPC> == <SPC> nums [ mid <SPC> - <SPC> 1 ] ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> nums [ left ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> singleNumber ( self , <SPC> A ) : <NL> <TAB> one , <SPC> two <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> A : <NL>          one , <SPC> two <SPC> = <SPC> ( ~ x <SPC> & <SPC> one ) <SPC> | <SPC> ( x <SPC> & <SPC> ~ one <SPC> & <SPC> ~ two ) , <SPC> ( ~ x <SPC> & <SPC> two ) <SPC> | <SPC> ( x <SPC> & <SPC> one ) <NL> <TAB> return <SPC> one <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> singleNumber ( self , <SPC> A ) : <NL> <TAB> one , <SPC> two , <SPC> carry <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> A : <NL>          two <SPC> |= <SPC> one <SPC> & <SPC> x <NL>          one <SPC> ^= <SPC> x <NL>          carry <SPC> = <SPC> one <SPC> & <SPC> two <NL>          one <SPC> &= <SPC> ~ carry <NL>          two <SPC> &= <SPC> ~ carry <NL> <TAB> return <SPC> one <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> singleNumber ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> ( <NL>          collections . Counter ( list ( set ( nums ) ) <SPC> * <SPC> 3 ) <SPC> - <SPC> collections . Counter ( nums ) <NL> <TAB> ) . keys ( ) [ 0 ] <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> singleNumber ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> ( sum ( set ( nums ) ) <SPC> * <SPC> 3 <SPC> - <SPC> sum ( nums ) ) <SPC> / <SPC> 2 <NL> <NL> <NL> class <SPC> SolutionEX ( object ) : <NL> <NL> <TAB> def <SPC> singleNumber ( self , <SPC> A ) : <NL> <TAB> one , <SPC> two , <SPC> three <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> A : <NL>          one , <SPC> two , <SPC> three <SPC> = <SPC> ( <NL>              ( ~ x <SPC> & <SPC> one ) <SPC> | <SPC> ( x <SPC> & <SPC> ~ one <SPC> & <SPC> ~ two <SPC> & <SPC> ~ three ) , <NL>              ( ~ x <SPC> & <SPC> two ) <SPC> | <SPC> ( x <SPC> & <SPC> one ) , <NL>              ( ~ x <SPC> & <SPC> three ) <SPC> | <SPC> ( x <SPC> & <SPC> two ) , <NL>          ) <NL> <TAB> return <SPC> two <NL> <NL> <NL> import <SPC> operator <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> singleNumber ( self , <SPC> nums ) : <NL> <TAB> x_xor_y <SPC> = <SPC> reduce ( operator . xor , <SPC> nums ) <NL> <TAB> bit <SPC> = <SPC> x_xor_y <SPC> & <SPC> - x_xor_y <NL> <TAB> result <SPC> = <SPC> [ 0 , <SPC> 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> nums : <NL>          result [ bool ( i <SPC> & <SPC> bit ) ] <SPC> ^= <SPC> i <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> singleNumber ( self , <SPC> nums ) : <NL> <TAB> x_xor_y <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> nums : <NL>          x_xor_y <SPC> ^= <SPC> i <NL> <NL> <TAB> bit <SPC> = <SPC> x_xor_y <SPC> & <SPC> ~ ( x_xor_y <SPC> - <SPC> 1 ) <NL> <NL> <TAB> x <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> nums : <NL>          if <SPC> i <SPC> & <SPC> bit : <NL>              x <SPC> ^= <SPC> i <NL> <NL> <TAB> return <SPC> [ x , <SPC> x <SPC> ^ <SPC> x_xor_y ] <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> singleNumber ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> [ <NL>          x [ 0 ] <NL>          for <SPC> x <SPC> in <SPC> sorted ( <NL>              collections . Counter ( nums ) . items ( ) , <SPC> key = lambda <SPC> i : <SPC> i [ 1 ] , <SPC> reverse = False <NL>          ) [ : 2 ] <NL> <TAB> ] <NL> <NL> <NL> import <SPC> operator <NL> from <SPC> functools <SPC> import <SPC> reduce <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> singleNumber ( self , <SPC> A ) : <NL> <TAB> return <SPC> reduce ( operator . xor , <SPC> A ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> calculateTime ( self , <SPC> keyboard , <SPC> word ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { c : <SPC> i <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( keyboard ) } <NL> <TAB> result , <SPC> prev <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> word : <NL>          result <SPC> += <SPC> abs ( lookup [ c ] <SPC> - <SPC> prev ) <NL>          prev <SPC> = <SPC> lookup [ c ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> heapq <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> slidingPuzzle ( self , <SPC> board ) : <NL> <NL> <TAB> def <SPC> dot ( p1 , <SPC> p2 ) : <NL>          return <SPC> p1 [ 0 ] <SPC> * <SPC> p2 [ 0 ] <SPC> + <SPC> p1 [ 1 ] <SPC> * <SPC> p2 [ 1 ] <NL> <NL> <TAB> def <SPC> heuristic_estimate ( board , <SPC> R , <SPC> C , <SPC> expected ) : <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( R ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( C ) : <NL>                  val <SPC> = <SPC> board [ C <SPC> * <SPC> i <SPC> + <SPC> j ] <NL>                  if <SPC> val <SPC> == <SPC> 0 : <NL>                      continue <NL>                  r , <SPC> c <SPC> = <SPC> expected [ val ] <NL>                  result <SPC> += <SPC> abs ( r <SPC> - <SPC> i ) <SPC> + <SPC> abs ( c <SPC> - <SPC> j ) <NL>          return <SPC> result <NL> <NL> <TAB> R , <SPC> C <SPC> = <SPC> len ( board ) , <SPC> len ( board [ 0 ] ) <NL> <TAB> begin <SPC> = <SPC> tuple ( itertools . chain ( * board ) ) <NL> <TAB> end <SPC> = <SPC> tuple ( range ( 1 , <SPC> R <SPC> * <SPC> C ) <SPC> + <SPC> [ 0 ] ) <NL> <TAB> expected <SPC> = <SPC> { <NL>          ( C <SPC> * <SPC> i <SPC> + <SPC> j <SPC> + <SPC> 1 ) <SPC> % <SPC> ( R <SPC> * <SPC> C ) : <SPC> ( i , <SPC> j ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( R ) <SPC> for <SPC> j <SPC> in <SPC> xrange ( C ) <NL> <TAB> } <NL> <NL> <TAB> min_steps <SPC> = <SPC> heuristic_estimate ( begin , <SPC> R , <SPC> C , <SPC> expected ) <NL> <TAB> closer , <SPC> detour <SPC> = <SPC> [ ( begin . index ( 0 ) , <SPC> begin ) ] , <SPC> [ ] <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> while <SPC> True : <NL>          if <SPC> not <SPC> closer : <NL>              if <SPC> not <SPC> detour : <NL>                  return <SPC> - 1 <NL>              min_steps <SPC> += <SPC> 2 <NL>              closer , <SPC> detour <SPC> = <SPC> detour , <SPC> closer <NL>          zero , <SPC> board <SPC> = <SPC> closer . pop ( ) <NL>          if <SPC> board <SPC> == <SPC> end : <NL>              return <SPC> min_steps <NL>          if <SPC> board <SPC> not <SPC> in <SPC> lookup : <NL>              lookup . add ( board ) <NL>              r , <SPC> c <SPC> = <SPC> divmod ( zero , <SPC> C ) <NL>              for <SPC> direction <SPC> in <SPC> ( ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) ) : <NL>                  i , <SPC> j <SPC> = <SPC> r <SPC> + <SPC> direction [ 0 ] , <SPC> c <SPC> + <SPC> direction [ 1 ] <NL>                  if <SPC> 0 <SPC> <= <SPC> i <SPC> < <SPC> R <SPC> and <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> C : <NL>                      new_zero <SPC> = <SPC> i <SPC> * <SPC> C <SPC> + <SPC> j <NL>                      tmp <SPC> = <SPC> list ( board ) <NL>                      tmp [ zero ] , <SPC> tmp [ new_zero ] <SPC> = <SPC> tmp [ new_zero ] , <SPC> tmp [ zero ] <NL>                      new_board <SPC> = <SPC> tuple ( tmp ) <NL>                      r2 , <SPC> c2 <SPC> = <SPC> expected [ board [ new_zero ] ] <NL>                      r1 , <SPC> c1 <SPC> = <SPC> divmod ( zero , <SPC> C ) <NL>                      r0 , <SPC> c0 <SPC> = <SPC> divmod ( new_zero , <SPC> C ) <NL>                      is_closer <SPC> = <SPC> dot ( ( r1 <SPC> - <SPC> r0 , <SPC> c1 <SPC> - <SPC> c0 ) , <SPC> ( r2 <SPC> - <SPC> r0 , <SPC> c2 <SPC> - <SPC> c0 ) ) <SPC> > <SPC> 0 <NL>                      ( closer <SPC> if <SPC> is_closer <SPC> else <SPC> detour ) . append ( <NL>                          ( new_zero , <SPC> new_board ) ) <NL> <TAB> return <SPC> min_steps <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> slidingPuzzle ( self , <SPC> board ) : <NL> <NL> <TAB> def <SPC> heuristic_estimate ( board , <SPC> R , <SPC> C , <SPC> expected ) : <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( R ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( C ) : <NL>                  val <SPC> = <SPC> board [ C <SPC> * <SPC> i <SPC> + <SPC> j ] <NL>                  if <SPC> val <SPC> == <SPC> 0 : <NL>                      continue <NL>                  r , <SPC> c <SPC> = <SPC> expected [ val ] <NL>                  result <SPC> += <SPC> abs ( r <SPC> - <SPC> i ) <SPC> + <SPC> abs ( c <SPC> - <SPC> j ) <NL>          return <SPC> result <NL> <NL> <TAB> R , <SPC> C <SPC> = <SPC> len ( board ) , <SPC> len ( board [ 0 ] ) <NL> <TAB> begin <SPC> = <SPC> tuple ( itertools . chain ( * board ) ) <NL> <TAB> end <SPC> = <SPC> tuple ( range ( 1 , <SPC> R <SPC> * <SPC> C ) <SPC> + <SPC> [ 0 ] ) <NL> <TAB> end_wrong <SPC> = <SPC> tuple ( range ( 1 , <SPC> R <SPC> * <SPC> C <SPC> - <SPC> 2 ) <SPC> + <SPC> [ R <SPC> * <SPC> C <SPC> - <SPC> 1 , <SPC> R <SPC> * <SPC> C <SPC> - <SPC> 2 , <SPC> 0 ] ) <NL> <TAB> expected <SPC> = <SPC> { <NL>          ( C <SPC> * <SPC> i <SPC> + <SPC> j <SPC> + <SPC> 1 ) <SPC> % <SPC> ( R <SPC> * <SPC> C ) : <SPC> ( i , <SPC> j ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( R ) <SPC> for <SPC> j <SPC> in <SPC> xrange ( C ) <NL> <TAB> } <NL> <NL> <TAB> min_heap <SPC> = <SPC> [ ( 0 , <SPC> 0 , <SPC> begin . index ( 0 ) , <SPC> begin ) ] <NL> <TAB> lookup <SPC> = <SPC> { begin : <SPC> 0 } <NL> <TAB> while <SPC> min_heap : <NL>          f , <SPC> g , <SPC> zero , <SPC> board <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          if <SPC> board <SPC> == <SPC> end : <NL>              return <SPC> g <NL>          if <SPC> board <SPC> == <SPC> end_wrong : <NL>              return <SPC> - 1 <NL>          if <SPC> f <SPC> > <SPC> lookup [ board ] : <NL>              continue <NL> <NL>          r , <SPC> c <SPC> = <SPC> divmod ( zero , <SPC> C ) <NL>          for <SPC> direction <SPC> in <SPC> ( ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) ) : <NL>              i , <SPC> j <SPC> = <SPC> r <SPC> + <SPC> direction [ 0 ] , <SPC> c <SPC> + <SPC> direction [ 1 ] <NL>              if <SPC> 0 <SPC> <= <SPC> i <SPC> < <SPC> R <SPC> and <SPC> 0 <SPC> <= <SPC> j <SPC> < <SPC> C : <NL>                  new_zero <SPC> = <SPC> C <SPC> * <SPC> i <SPC> + <SPC> j <NL>                  tmp <SPC> = <SPC> list ( board ) <NL>                  tmp [ zero ] , <SPC> tmp [ new_zero ] <SPC> = <SPC> tmp [ new_zero ] , <SPC> tmp [ zero ] <NL>                  new_board <SPC> = <SPC> tuple ( tmp ) <NL>                  f <SPC> = <SPC> g <SPC> + <SPC> 1 <SPC> + <SPC> heuristic_estimate ( new_board , <SPC> R , <SPC> C , <SPC> expected ) <NL>                  if <SPC> f <SPC> < <SPC> lookup . get ( new_board , <SPC> float ( "inf" ) ) : <NL>                      lookup [ new_board ] <SPC> = <SPC> f <NL>                      heapq . heappush ( min_heap , <SPC> ( f , <SPC> g <SPC> + <SPC> 1 , <SPC> new_zero , <SPC> new_board ) ) <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> deque <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxSlidingWindow ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> result , <SPC> dq <SPC> = <SPC> [ ] , <SPC> deque ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> dq <SPC> and <SPC> i <SPC> - <SPC> dq [ 0 ] <SPC> == <SPC> k : <NL>              dq . popleft ( ) <NL>          while <SPC> dq <SPC> and <SPC> nums [ dq [ - 1 ] ] <SPC> <= <SPC> nums [ i ] : <NL>              dq . pop ( ) <NL>          dq . append ( i ) <NL>          if <SPC> i <SPC> >= <SPC> k <SPC> - <SPC> 1 : <NL>              result . append ( nums [ dq [ 0 ] ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> slowestKey ( self , <SPC> releaseTimes , <SPC> keysPressed ) : <NL> <NL> <TAB> result , <SPC> lookup <SPC> = <SPC> "a" , <SPC> collections . Counter ( ) <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( keysPressed ) : <NL>          lookup [ c ] <SPC> = <SPC> max ( <NL>              lookup [ c ] , <SPC> releaseTimes [ i ] <SPC> - <SPC> ( releaseTimes [ i <SPC> - <SPC> 1 ] <SPC> if <SPC> i <SPC> > <SPC> 0 <SPC> else <SPC> 0 ) <NL>          ) <NL>          if <SPC> lookup [ c ] <SPC> > <SPC> lookup [ result ] <SPC> or <SPC> lookup [ c ] <SPC> == <SPC> lookup [ result ] <SPC> and <SPC> c <SPC> > <SPC> result : <NL>              result <SPC> = <SPC> c <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findSmallestRegion ( self , <SPC> regions , <SPC> region1 , <SPC> region2 ) : <NL> <NL> <TAB> parents <SPC> = <SPC> { <NL>          region [ i ] : <SPC> region [ 0 ] <SPC> for <SPC> region <SPC> in <SPC> regions <SPC> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( region ) ) <NL> <TAB> } <NL> <TAB> lookup <SPC> = <SPC> { region1 } <NL> <TAB> while <SPC> region1 <SPC> in <SPC> parents : <NL>          region1 <SPC> = <SPC> parents [ region1 ] <NL>          lookup . add ( region1 ) <NL> <TAB> while <SPC> region2 <SPC> not <SPC> in <SPC> lookup : <NL>          region2 <SPC> = <SPC> parents [ region2 ] <NL> <TAB> return <SPC> region2 <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestGoodBase ( self , <SPC> n ) : <NL> <NL> <TAB> num <SPC> = <SPC> int ( n ) <NL> <TAB> max_len <SPC> = <SPC> int ( math . log ( num , <SPC> 2 ) ) <NL> <TAB> for <SPC> l <SPC> in <SPC> xrange ( max_len , <SPC> 1 , <SPC> - 1 ) : <NL>          b <SPC> = <SPC> int ( num <SPC> ** <SPC> ( l <SPC> ** <SPC> - 1 ) ) <NL>          if <SPC> ( b <SPC> ** <SPC> ( l <SPC> + <SPC> 1 ) <SPC> - <SPC> 1 ) <SPC> // <SPC> ( b <SPC> - <SPC> 1 ) <SPC> == <SPC> num : <NL>              return <SPC> str ( b ) <NL> <TAB> return <SPC> str ( num <SPC> - <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestRepunitDivByK ( self , <SPC> K ) : <NL> <NL> <TAB> if <SPC> K <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> or <SPC> K <SPC> % <SPC> 5 <SPC> == <SPC> 0 : <NL>          return <SPC> - 1 <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> N <SPC> in <SPC> xrange ( 1 , <SPC> K <SPC> + <SPC> 1 ) : <NL>          result <SPC> = <SPC> ( result <SPC> * <SPC> 10 <SPC> + <SPC> 1 ) <SPC> % <SPC> K <NL>          if <SPC> not <SPC> result : <NL>              return <SPC> N <NL> <TAB> assert <SPC> False <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestRangeI ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> return <SPC> max ( 0 , <SPC> max ( A ) <SPC> - <SPC> min ( A ) <SPC> - <SPC> 2 <SPC> * <SPC> K ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestRangeII ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> A . sort ( ) <NL> <TAB> result <SPC> = <SPC> A [ - 1 ] <SPC> - <SPC> A [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) <SPC> - <SPC> 1 ) : <NL>          result <SPC> = <SPC> min ( result , <SPC> max ( A [ - 1 ] <SPC> - <SPC> K , <SPC> A [ i ] <SPC> + <NL>                       K ) <SPC> - <SPC> min ( A [ 0 ] <SPC> + <SPC> K , <SPC> A [ i <SPC> + <SPC> 1 ] <SPC> - <SPC> K ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestRange ( self , <SPC> nums ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> float ( "inf" ) , <SPC> float ( "-inf" ) <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> row <SPC> in <SPC> nums : <NL>          left <SPC> = <SPC> min ( left , <SPC> row [ 0 ] ) <NL>          right <SPC> = <SPC> max ( right , <SPC> row [ 0 ] ) <NL>          it <SPC> = <SPC> iter ( row ) <NL>          heapq . heappush ( min_heap , <SPC> ( next ( it , <SPC> None ) , <SPC> it ) ) <NL> <NL> <TAB> result <SPC> = <SPC> ( left , <SPC> right ) <NL> <TAB> while <SPC> min_heap : <NL>          ( val , <SPC> it ) <SPC> = <SPC> heapq . heappop ( min_heap ) <NL>          val <SPC> = <SPC> next ( it , <SPC> None ) <NL>          if <SPC> val <SPC> is <SPC> None : <NL>              break <NL>          heapq . heappush ( min_heap , <SPC> ( val , <SPC> it ) ) <NL>          left , <SPC> right <SPC> = <SPC> min_heap [ 0 ] [ 0 ] , <SPC> max ( right , <SPC> val ) <NL>          if <SPC> right <SPC> - <SPC> left <SPC> < <SPC> result [ 1 ] <SPC> - <SPC> result [ 0 ] : <NL>              result <SPC> = <SPC> ( left , <SPC> right ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> bisect <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minArea ( self , <SPC> image , <SPC> x , <SPC> y ) : <NL> <NL> <TAB> def <SPC> binarySearch ( left , <SPC> right , <SPC> find , <SPC> image , <SPC> has_one ) : <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>              if <SPC> find ( image , <SPC> has_one , <SPC> mid ) : <NL>                  right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL>          return <SPC> left <NL> <NL> <TAB> searchColumns <SPC> = <SPC> ( <NL>          lambda <SPC> image , <SPC> has_one , <SPC> mid : <SPC> any ( <NL>              [ int ( row [ mid ] ) <SPC> for <SPC> row <SPC> in <SPC> image ] ) <SPC> == <SPC> has_one <NL> <TAB> ) <NL> <TAB> left <SPC> = <SPC> binarySearch ( 0 , <SPC> y <SPC> - <SPC> 1 , <SPC> searchColumns , <SPC> image , <SPC> True ) <NL> <TAB> right <SPC> = <SPC> binarySearch ( y <SPC> + <SPC> 1 , <SPC> len ( image [ 0 ] ) <SPC> - <SPC> 1 , <SPC> searchColumns , <SPC> image , <SPC> False ) <NL> <NL> <TAB> searchRows <SPC> = <SPC> ( <NL>          lambda <SPC> image , <SPC> has_one , <SPC> mid : <SPC> any ( <NL>              itertools . imap ( int , <SPC> image [ mid ] ) ) <SPC> == <SPC> has_one <NL> <TAB> ) <NL> <TAB> top <SPC> = <SPC> binarySearch ( 0 , <SPC> x <SPC> - <SPC> 1 , <SPC> searchRows , <SPC> image , <SPC> True ) <NL> <TAB> bottom <SPC> = <SPC> binarySearch ( x <SPC> + <SPC> 1 , <SPC> len ( image ) <SPC> - <SPC> 1 , <SPC> searchRows , <SPC> image , <SPC> False ) <NL> <NL> <TAB> return <SPC> ( right <SPC> - <SPC> left ) <SPC> * <SPC> ( bottom <SPC> - <SPC> top ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> bestRotation ( self , <SPC> A ) : <NL> <NL> <TAB> N <SPC> = <SPC> len ( A ) <NL> <TAB> change <SPC> = <SPC> [ 1 ] <SPC> * <SPC> N <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N ) : <NL>          change [ ( i <SPC> - <SPC> A [ i ] <SPC> + <SPC> 1 ) <SPC> % <SPC> N ] <SPC> -= <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> N ) : <NL>          change [ i ] <SPC> += <SPC> change [ i <SPC> - <SPC> 1 ] <NL> <TAB> return <SPC> change . index ( max ( change ) ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestFromLeaf ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> candidate , <SPC> result ) : <NL>          if <SPC> not <SPC> node : <NL>              return <NL> <NL>          candidate . append ( chr ( ord ( "a" ) <SPC> + <SPC> node . val ) ) <NL>          if <SPC> not <SPC> node . left <SPC> and <SPC> not <SPC> node . right : <NL>              result [ 0 ] <SPC> = <SPC> min ( result [ 0 ] , <SPC> "" . join ( reversed ( candidate ) ) ) <NL>          dfs ( node . left , <SPC> candidate , <SPC> result ) <NL>          dfs ( node . right , <SPC> candidate , <SPC> result ) <NL>          candidate . pop ( ) <NL> <NL> <TAB> result <SPC> = <SPC> [ "~" ] <NL> <TAB> dfs ( root , <SPC> [ ] , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getSmallestString ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> MAX_DIFF <SPC> = <SPC> ord ( "z" ) <SPC> - <SPC> ord ( "a" ) <NL> <NL> <TAB> k <SPC> -= <SPC> n <NL> <TAB> result <SPC> = <SPC> [ "a" ] <SPC> * <SPC> n <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( n ) ) : <NL>          tmp <SPC> = <SPC> min ( k , <SPC> MAX_DIFF ) <NL>          result [ i ] <SPC> = <SPC> chr ( ord ( "a" ) <SPC> + <SPC> tmp ) <NL>          k <SPC> -= <SPC> tmp <NL>          if <SPC> k <SPC> == <SPC> 0 : <NL>              break <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ max ( x_root , <SPC> y_root ) ] <SPC> = <SPC> min ( x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestStringWithSwaps ( self , <SPC> s , <SPC> pairs ) : <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( s ) ) <NL> <TAB> for <SPC> x , <SPC> y <SPC> in <SPC> pairs : <NL>          union_find . union_set ( x , <SPC> y ) <NL> <TAB> components <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          components [ union_find . find_set ( i ) ] . append ( s [ i ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> components . iterkeys ( ) : <NL>          components [ i ] . sort ( reverse = True ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          result . append ( components [ union_find . find_set ( i ) ] . pop ( ) ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> smallestStringWithSwaps ( self , <SPC> s , <SPC> pairs ) : <NL> <NL> <TAB> def <SPC> dfs ( i , <SPC> adj , <SPC> lookup , <SPC> component ) : <NL>          lookup . add ( i ) <NL>          component . append ( i ) <NL>          for <SPC> j <SPC> in <SPC> adj [ i ] : <NL>              if <SPC> j <SPC> in <SPC> lookup : <NL>                  continue <NL>              dfs ( j , <SPC> adj , <SPC> lookup , <SPC> component ) <NL> <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> pairs : <NL>          adj [ i ] . append ( j ) <NL>          adj [ j ] . append ( i ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> result <SPC> = <SPC> list ( s ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> i <SPC> in <SPC> lookup : <NL>              continue <NL>          component <SPC> = <SPC> [ ] <NL>          dfs ( i , <SPC> adj , <SPC> lookup , <SPC> component ) <NL>          component . sort ( ) <NL>          chars <SPC> = <SPC> sorted ( result [ k ] <SPC> for <SPC> k <SPC> in <SPC> component ) <NL>          for <SPC> comp , <SPC> char <SPC> in <SPC> itertools . izip ( component , <SPC> chars ) : <NL>              result [ comp ] <SPC> = <SPC> char <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestSubsequence ( self , <SPC> text ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( text ) <NL> <NL> <TAB> lookup , <SPC> stk <SPC> = <SPC> set ( ) , <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> text : <NL>          if <SPC> c <SPC> not <SPC> in <SPC> lookup : <NL>              while <SPC> stk <SPC> and <SPC> stk [ - 1 ] <SPC> > <SPC> c <SPC> and <SPC> count [ stk [ - 1 ] ] : <NL>                  lookup . remove ( stk . pop ( ) ) <NL>              stk <SPC> += <SPC> c <NL>              lookup . add ( c ) <NL>          count [ c ] <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> "" . join ( stk ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> subtreeWithAllDeepest ( self , <SPC> root ) : <NL> <NL> <TAB> Result <SPC> = <SPC> collections . namedtuple ( "Result" , <SPC> ( "node" , <SPC> "depth" ) ) <NL> <NL> <TAB> def <SPC> dfs ( node ) : <NL>          if <SPC> not <SPC> node : <NL>              return <SPC> Result ( None , <SPC> 0 ) <NL>          left , <SPC> right <SPC> = <SPC> dfs ( node . left ) , <SPC> dfs ( node . right ) <NL>          if <SPC> left . depth <SPC> > <SPC> right . depth : <NL>              return <SPC> Result ( left . node , <SPC> left . depth <SPC> + <SPC> 1 ) <NL>          if <SPC> left . depth <SPC> < <SPC> right . depth : <NL>              return <SPC> Result ( right . node , <SPC> right . depth <SPC> + <SPC> 1 ) <NL>          return <SPC> Result ( node , <SPC> left . depth <SPC> + <SPC> 1 ) <NL> <NL> <TAB> return <SPC> dfs ( root ) . node <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> smallestSufficientTeam ( self , <SPC> req_skills , <SPC> people ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { v : <SPC> i <SPC> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( req_skills ) } <NL> <TAB> dp <SPC> = <SPC> { 0 : <SPC> [ ] } <NL> <TAB> for <SPC> i , <SPC> p <SPC> in <SPC> enumerate ( people ) : <NL>          his_skill_set <SPC> = <SPC> 0 <NL>          for <SPC> skill <SPC> in <SPC> p : <NL>              if <SPC> skill <SPC> in <SPC> lookup : <NL>                  his_skill_set <SPC> |= <SPC> 1 <SPC> << <SPC> lookup [ skill ] <NL>          for <SPC> skill_set , <SPC> people <SPC> in <SPC> dp . items ( ) : <NL>              with_him <SPC> = <SPC> skill_set <SPC> | <SPC> his_skill_set <NL>              if <SPC> with_him <SPC> == <SPC> skill_set : <NL>                  continue <NL>              if <SPC> with_him <SPC> not <SPC> in <SPC> dp <SPC> or <SPC> len ( dp [ with_him ] ) <SPC> > <SPC> len ( people ) <SPC> + <SPC> 1 : <NL>                  dp [ with_him ] <SPC> = <SPC> people <SPC> + <SPC> [ i ] <NL> <TAB> return <SPC> dp [ ( 1 <SPC> << <SPC> len ( req_skills ) ) <SPC> - <SPC> 1 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> snakesAndLadders ( self , <SPC> board ) : <NL> <NL> <TAB> def <SPC> coordinate ( n , <SPC> s ) : <NL>          a , <SPC> b <SPC> = <SPC> divmod ( s <SPC> - <SPC> 1 , <SPC> n ) <NL>          r <SPC> = <SPC> n <SPC> - <SPC> 1 <SPC> - <SPC> a <NL>          c <SPC> = <SPC> b <SPC> if <SPC> r <SPC> % <SPC> 2 <SPC> != <SPC> n <SPC> % <SPC> 2 <SPC> else <SPC> n <SPC> - <SPC> 1 <SPC> - <SPC> b <NL>          return <SPC> r , <SPC> c <NL> <NL> <TAB> n <SPC> = <SPC> len ( board ) <NL> <TAB> lookup <SPC> = <SPC> { 1 : <SPC> 0 } <NL> <TAB> q <SPC> = <SPC> collections . deque ( [ 1 ] ) <NL> <TAB> while <SPC> q : <NL>          s <SPC> = <SPC> q . popleft ( ) <NL>          if <SPC> s <SPC> == <SPC> n <SPC> * <SPC> n : <NL>              return <SPC> lookup [ s ] <NL>          for <SPC> s2 <SPC> in <SPC> xrange ( s <SPC> + <SPC> 1 , <SPC> min ( s <SPC> + <SPC> 6 , <SPC> n <SPC> * <SPC> n ) <SPC> + <SPC> 1 ) : <NL>              r , <SPC> c <SPC> = <SPC> coordinate ( n , <SPC> s2 ) <NL>              if <SPC> board [ r ] [ c ] <SPC> != <SPC> - 1 : <NL>                  s2 <SPC> = <SPC> board [ r ] [ c ] <NL>              if <SPC> s2 <SPC> not <SPC> in <SPC> lookup : <NL>                  lookup [ s2 ] <SPC> = <SPC> lookup [ s ] <SPC> + <SPC> 1 <NL>                  q . append ( s2 ) <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> SnapshotArray ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> length ) : <NL> <NL> <TAB> self . __A <SPC> = <SPC> collections . defaultdict ( lambda : <SPC> [ [ 0 , <SPC> 0 ] ] ) <NL> <TAB> self . __snap_id <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> set ( self , <SPC> index , <SPC> val ) : <NL> <NL> <TAB> if <SPC> self . __A [ index ] [ - 1 ] [ 0 ] <SPC> == <SPC> self . __snap_id : <NL>          self . __A [ index ] [ - 1 ] [ 1 ] <SPC> = <SPC> val <NL> <TAB> else : <NL>          self . __A [ index ] . append ( [ self . __snap_id , <SPC> val ] ) <NL> <NL> <TAB> def <SPC> snap ( self ) : <NL> <NL> <TAB> self . __snap_id <SPC> += <SPC> 1 <NL> <TAB> return <SPC> self . __snap_id <SPC> - <SPC> 1 <NL> <NL> <TAB> def <SPC> get ( self , <SPC> index , <SPC> snap_id ) : <NL> <NL> <TAB> i <SPC> = <SPC> bisect . bisect_left ( self . __A [ index ] , <SPC> [ snap_id <SPC> + <SPC> 1 , <SPC> float ( "-inf" ) ] ) <SPC> - <SPC> 1 <NL> <TAB> return <SPC> self . __A [ index ] [ i ] [ 1 ] <NL> <NL> <NL> import <SPC> re <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> solveEquation ( self , <SPC> equation ) : <NL> <NL> <TAB> a , <SPC> b , <SPC> side <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> eq , <SPC> sign , <SPC> num , <SPC> isx <SPC> in <SPC> re . findall ( "(=)|([-+]?)(\d*)(x?)" , <SPC> equation ) : <NL>          if <SPC> eq : <NL>              side <SPC> = <SPC> - 1 <NL>          elif <SPC> isx : <NL>              a <SPC> += <SPC> side <SPC> * <SPC> int ( sign <SPC> + <SPC> "1" ) <SPC> * <SPC> int ( num <SPC> or <SPC> 1 ) <NL>          elif <SPC> num : <NL>              b <SPC> -= <SPC> side <SPC> * <SPC> int ( sign <SPC> + <SPC> num ) <NL> <TAB> return <SPC> "x=%d" <SPC> % <SPC> ( b <SPC> / <SPC> a ) <SPC> if <SPC> a <SPC> else <SPC> "No solution" <SPC> if <SPC> b <SPC> else <SPC> "Infinite solutions" <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sortArray ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> mergeSort ( start , <SPC> end , <SPC> nums ) : <NL>          if <SPC> end <SPC> - <SPC> start <SPC> <= <SPC> 1 : <NL>              return <NL>          mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> // <SPC> 2 <NL>          mergeSort ( start , <SPC> mid , <SPC> nums ) <NL>          mergeSort ( mid , <SPC> end , <SPC> nums ) <NL>          right <SPC> = <SPC> mid <NL>          tmp <SPC> = <SPC> [ ] <NL>          for <SPC> left <SPC> in <SPC> xrange ( start , <SPC> mid ) : <NL>              while <SPC> right <SPC> < <SPC> end <SPC> and <SPC> nums [ right ] <SPC> < <SPC> nums [ left ] : <NL>                  tmp . append ( nums [ right ] ) <NL>                  right <SPC> += <SPC> 1 <NL>              tmp . append ( nums [ left ] ) <NL>          nums [ start : <SPC> start <SPC> + <SPC> len ( tmp ) ] <SPC> = <SPC> tmp <NL> <NL> <TAB> mergeSort ( 0 , <SPC> len ( nums ) , <SPC> nums ) <NL> <TAB> return <SPC> nums <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> sortArray ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> kthElement ( nums , <SPC> left , <SPC> k , <SPC> right , <SPC> compare ) : <NL>          def <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare ) : <NL>              new_pivot_idx <SPC> = <SPC> left <NL>              nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>                  if <SPC> compare ( nums [ i ] , <SPC> nums [ right ] ) : <NL>                      nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                      new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>              nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>              return <SPC> new_pivot_idx <NL> <NL>          right <SPC> -= <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> PartitionAroundPivot ( <NL>                  left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare <NL>              ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> k : <NL>                  return <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> k : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> def <SPC> quickSort ( start , <SPC> end , <SPC> nums ) : <NL>          if <SPC> end <SPC> - <SPC> start <SPC> <= <SPC> 1 : <NL>              return <NL>          mid <SPC> = <SPC> start <SPC> + <SPC> ( end <SPC> - <SPC> start ) <SPC> / <SPC> 2 <NL>          kthElement ( nums , <SPC> start , <SPC> mid , <SPC> end , <SPC> lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) <NL>          quickSort ( start , <SPC> mid , <SPC> nums ) <NL>          quickSort ( mid , <SPC> end , <SPC> nums ) <NL> <NL> <TAB> quickSort ( 0 , <SPC> len ( nums ) , <SPC> nums ) <NL> <TAB> return <SPC> nums <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> frequencySort ( self , <SPC> nums ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( nums ) <NL> <TAB> return <SPC> sorted ( nums , <SPC> key = lambda <SPC> x : <SPC> ( count [ x ] , <SPC> - x ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sortArrayByParityII ( self , <SPC> A ) : <NL> <NL> <TAB> j <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 0 , <SPC> len ( A ) , <SPC> 2 ) : <NL>          if <SPC> A [ i ] <SPC> % <SPC> 2 : <NL>              while <SPC> A [ j ] <SPC> % <SPC> 2 : <NL>                  j <SPC> += <SPC> 2 <NL>              A [ i ] , <SPC> A [ j ] <SPC> = <SPC> A [ j ] , <SPC> A [ i ] <NL> <TAB> return <SPC> A <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sortArrayByParity ( self , <SPC> A ) : <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          if <SPC> A [ j ] <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              A [ i ] , <SPC> A [ j ] <SPC> = <SPC> A [ j ] , <SPC> A [ i ] <NL>              i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> A <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> frequencySort ( self , <SPC> s ) : <NL> <NL> <TAB> freq <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          freq [ c ] <SPC> += <SPC> 1 <NL> <NL> <TAB> counts <SPC> = <SPC> [ "" ] <SPC> * <SPC> ( len ( s ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> c <SPC> in <SPC> freq : <NL>          counts [ freq [ c ] ] <SPC> += <SPC> c <NL> <NL> <TAB> result <SPC> = <SPC> "" <NL> <TAB> for <SPC> count <SPC> in <SPC> reversed ( xrange ( len ( counts ) <SPC> - <SPC> 1 ) ) : <NL>          for <SPC> c <SPC> in <SPC> counts [ count ] : <NL>              result <SPC> += <SPC> c <SPC> * <SPC> count <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sortColors ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> triPartition ( nums , <SPC> target ) : <NL>          i , <SPC> left , <SPC> right <SPC> = <SPC> 0 , <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> i <SPC> <= <SPC> right : <NL>              if <SPC> nums [ i ] <SPC> > <SPC> target : <NL>                  nums [ i ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ i ] <NL>                  right <SPC> -= <SPC> 1 <NL>              else : <NL>                  if <SPC> nums [ i ] <SPC> < <SPC> target : <NL>                      nums [ left ] , <SPC> nums [ i ] <SPC> = <SPC> nums [ i ] , <SPC> nums [ left ] <NL>                      left <SPC> += <SPC> 1 <NL>                  i <SPC> += <SPC> 1 <NL> <NL> <TAB> triPartition ( nums , <SPC> 1 ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sortFeatures ( self , <SPC> features , <SPC> responses ) : <NL> <NL> <TAB> features_set <SPC> = <SPC> set ( features ) <NL> <TAB> order <SPC> = <SPC> { word : <SPC> i <SPC> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( features ) } <NL> <TAB> freq <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> r <SPC> in <SPC> responses : <NL>          for <SPC> word <SPC> in <SPC> set ( r . split ( " " ) ) : <NL>              if <SPC> word <SPC> in <SPC> features_set : <NL>                  freq [ word ] <SPC> += <SPC> 1 <NL> <TAB> features . sort ( key = lambda <SPC> x : <SPC> ( - freq [ x ] , <SPC> order [ x ] ) ) <NL> <TAB> return <SPC> features <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sortByBits ( self , <SPC> arr ) : <NL> <NL> <TAB> def <SPC> popcount ( n ) : <NL>          result <SPC> = <SPC> 0 <NL>          while <SPC> n : <NL>              n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL>              result <SPC> += <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> arr . sort ( key = lambda <SPC> x : <SPC> ( popcount ( x ) , <SPC> x ) ) <NL> <TAB> return <SPC> arr <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> dp <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> getKth ( self , <SPC> lo , <SPC> hi , <SPC> k ) : <NL> <NL> <TAB> def <SPC> nth_element ( nums , <SPC> n , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) : <NL>          def <SPC> partition_around_pivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare ) : <NL>              new_pivot_idx <SPC> = <SPC> left <NL>              nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>                  if <SPC> compare ( nums [ i ] , <SPC> nums [ right ] ) : <NL>                      nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                      new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>              nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>              return <SPC> new_pivot_idx <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> partition_around_pivot ( <NL>                  left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare <NL>              ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> n : <NL>                  return <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> n : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> def <SPC> power_value ( x ) : <NL>          y , <SPC> result <SPC> = <SPC> x , <SPC> 0 <NL>          while <SPC> x <SPC> > <SPC> 1 <SPC> and <SPC> x <SPC> not <SPC> in <SPC> Solution . dp : <NL>              result <SPC> += <SPC> 1 <NL>              if <SPC> x <SPC> % <SPC> 2 : <NL>                  x <SPC> = <SPC> 3 <SPC> * <SPC> x <SPC> + <SPC> 1 <NL>              else : <NL>                  x <SPC> //= <SPC> 2 <NL>          Solution . dp [ y ] <SPC> = <SPC> result <SPC> + <SPC> ( Solution . dp [ x ] <SPC> if <SPC> x <SPC> > <SPC> 1 <SPC> else <SPC> 0 ) <NL>          return <SPC> Solution . dp [ y ] , <SPC> y <NL> <NL> <TAB> arr <SPC> = <SPC> map ( power_value , <SPC> range ( lo , <SPC> hi <SPC> + <SPC> 1 ) ) <NL> <TAB> nth_element ( arr , <SPC> k <SPC> - <SPC> 1 ) <NL> <TAB> return <SPC> arr [ k <SPC> - <SPC> 1 ] [ 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> dp <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> getKth ( self , <SPC> lo , <SPC> hi , <SPC> k ) : <NL> <NL> <TAB> def <SPC> power_value ( x ) : <NL>          y , <SPC> result <SPC> = <SPC> x , <SPC> 0 <NL>          while <SPC> x <SPC> > <SPC> 1 <SPC> and <SPC> x <SPC> not <SPC> in <SPC> Solution2 . dp : <NL>              result <SPC> += <SPC> 1 <NL>              if <SPC> x <SPC> % <SPC> 2 : <NL>                  x <SPC> = <SPC> 3 <SPC> * <SPC> x <SPC> + <SPC> 1 <NL>              else : <NL>                  x <SPC> //= <SPC> 2 <NL>          Solution2 . dp [ y ] <SPC> = <SPC> result <SPC> + <SPC> ( Solution2 . dp [ x ] <SPC> if <SPC> x <SPC> > <SPC> 1 <SPC> else <SPC> 0 ) <NL>          return <SPC> Solution2 . dp [ y ] , <SPC> y <NL> <NL> <TAB> return <SPC> sorted ( range ( lo , <SPC> hi <SPC> + <SPC> 1 ) , <SPC> key = power_value ) [ k <SPC> - <SPC> 1 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Topo ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __nodes <SPC> = <SPC> set ( ) <NL> <TAB> self . __in_degree <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> self . __out_degree <SPC> = <SPC> collections . defaultdict ( set ) <NL> <NL> <TAB> def <SPC> add_node ( self , <SPC> node ) : <NL> <TAB> self . __nodes . add ( node ) <NL> <NL> <TAB> def <SPC> add_edge ( self , <SPC> src , <SPC> dst ) : <NL> <TAB> self . add_node ( src ) , <SPC> self . add_node ( dst ) <NL> <TAB> self . __in_degree [ dst ] . add ( src ) <NL> <TAB> self . __out_degree [ src ] . add ( dst ) <NL> <NL> <TAB> def <SPC> sort ( self ) : <NL> <TAB> q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> node <SPC> in <SPC> self . __nodes : <NL>          if <SPC> node <SPC> not <SPC> in <SPC> self . __in_degree : <NL>              q . append ( node ) <NL> <TAB> while <SPC> q : <NL>          node <SPC> = <SPC> q . popleft ( ) <NL>          result . append ( node ) <NL>          for <SPC> nei <SPC> in <SPC> self . __out_degree [ node ] : <NL>              self . __in_degree [ nei ] . remove ( node ) <NL>              if <SPC> not <SPC> self . __in_degree [ nei ] : <NL>                  self . __in_degree . pop ( nei ) <NL>                  q . append ( nei ) <NL> <TAB> if <SPC> len ( result ) <SPC> < <SPC> len ( self . __nodes ) : <NL>          return <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sortItems ( self , <SPC> n , <SPC> m , <SPC> group , <SPC> beforeItems ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          if <SPC> group [ i ] <SPC> == <SPC> - 1 : <NL>              group [ i ] <SPC> = <SPC> m <NL>              m <SPC> += <SPC> 1 <NL> <TAB> global_group <SPC> = <SPC> Topo ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          global_group . add_node ( i ) <NL> <TAB> local_groups <SPC> = <SPC> collections . defaultdict ( Topo ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          local_groups [ group [ i ] ] . add_node ( i ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          for <SPC> j <SPC> in <SPC> beforeItems [ i ] : <NL>              if <SPC> group [ i ] <SPC> == <SPC> group [ j ] : <NL>                  local_groups [ group [ i ] ] . add_edge ( j , <SPC> i ) <NL>              else : <NL>                  global_group . add_edge ( group [ j ] , <SPC> group [ i ] ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> global_order <SPC> = <SPC> global_group . sort ( ) <NL> <TAB> if <SPC> global_order <SPC> is <SPC> None : <NL>          return <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> global_order : <NL>          local_order <SPC> = <SPC> local_groups [ i ] . sort ( ) <NL>          if <SPC> local_order <SPC> is <SPC> None : <NL>              return <SPC> [ ] <NL>          for <SPC> x <SPC> in <SPC> local_order : <NL>              result . append ( x ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> repr ( self . next ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> sortList ( self , <SPC> head ) : <NL> <TAB> if <SPC> head <SPC> == <SPC> None <SPC> or <SPC> head . next <SPC> == <SPC> None : <NL>          return <SPC> head <NL> <NL> <TAB> fast , <SPC> slow , <SPC> prev <SPC> = <SPC> head , <SPC> head , <SPC> None <NL> <TAB> while <SPC> fast <SPC> != <SPC> None <SPC> and <SPC> fast . next <SPC> != <SPC> None : <NL>          prev , <SPC> fast , <SPC> slow <SPC> = <SPC> slow , <SPC> fast . next . next , <SPC> slow . next <NL> <TAB> prev . next <SPC> = <SPC> None <NL> <NL> <TAB> sorted_l1 <SPC> = <SPC> self . sortList ( head ) <NL> <TAB> sorted_l2 <SPC> = <SPC> self . sortList ( slow ) <NL> <NL> <TAB> return <SPC> self . mergeTwoLists ( sorted_l1 , <SPC> sorted_l2 ) <NL> <NL> <TAB> def <SPC> mergeTwoLists ( self , <SPC> l1 , <SPC> l2 ) : <NL> <TAB> dummy <SPC> = <SPC> ListNode ( 0 ) <NL> <NL> <TAB> cur <SPC> = <SPC> dummy <NL> <TAB> while <SPC> l1 <SPC> != <SPC> None <SPC> and <SPC> l2 <SPC> != <SPC> None : <NL>          if <SPC> l1 . val <SPC> <= <SPC> l2 . val : <NL>              cur . next , <SPC> cur , <SPC> l1 <SPC> = <SPC> l1 , <SPC> l1 , <SPC> l1 . next <NL>          else : <NL>              cur . next , <SPC> cur , <SPC> l2 <SPC> = <SPC> l2 , <SPC> l2 , <SPC> l2 . next <NL> <NL> <TAB> if <SPC> l1 <SPC> != <SPC> None : <NL>          cur . next <SPC> = <SPC> l1 <NL> <TAB> if <SPC> l2 <SPC> != <SPC> None : <NL>          cur . next <SPC> = <SPC> l2 <NL> <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> diagonalSort ( self , <SPC> mat ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( mat ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( mat [ 0 ] ) ) : <NL>              lookup [ i <SPC> - <SPC> j ] . append ( mat [ i ] [ j ] ) <NL> <TAB> for <SPC> v <SPC> in <SPC> lookup . itervalues ( ) : <NL>          v . sort ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( mat ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( len ( mat [ 0 ] ) ) ) : <NL>              mat [ i ] [ j ] <SPC> = <SPC> lookup [ i <SPC> - <SPC> j ] . pop ( ) <NL> <TAB> return <SPC> mat <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sortTransformedArray ( self , <SPC> nums , <SPC> a , <SPC> b , <SPC> c ) : <NL> <NL> <TAB> def <SPC> f ( x , <SPC> a , <SPC> b , <SPC> c ) : <SPC> return <SPC> a <SPC> * <SPC> x <SPC> * <SPC> x <SPC> + <SPC> b <SPC> * <SPC> x <SPC> + <SPC> c <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> not <SPC> nums : <NL>          return <SPC> result <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> d <SPC> = <SPC> - 1 <SPC> if <SPC> a <SPC> > <SPC> 0 <SPC> else <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          if <SPC> d <SPC> * <SPC> f ( nums [ left ] , <SPC> a , <SPC> b , <SPC> c ) <SPC> < <SPC> d <SPC> * <SPC> f ( nums [ right ] , <SPC> a , <SPC> b , <SPC> c ) : <NL>              result . append ( f ( nums [ left ] , <SPC> a , <SPC> b , <SPC> c ) ) <NL>              left <SPC> += <SPC> 1 <NL>          else : <NL>              result . append ( f ( nums [ right ] , <SPC> a , <SPC> b , <SPC> c ) ) <NL>              right <SPC> -= <SPC> 1 <NL> <NL> <TAB> return <SPC> result [ : : d ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> soupServings ( self , <SPC> N ) : <NL> <NL> <TAB> def <SPC> dp ( a , <SPC> b , <SPC> lookup ) : <NL>          if <SPC> ( a , <SPC> b ) <SPC> in <SPC> lookup : <NL>              return <SPC> lookup [ a , <SPC> b ] <NL>          if <SPC> a <SPC> <= <SPC> 0 <SPC> and <SPC> b <SPC> <= <SPC> 0 : <NL>              return <SPC> 0.5 <NL>          if <SPC> a <SPC> <= <SPC> 0 : <NL>              return <SPC> 1.0 <NL>          if <SPC> b <SPC> <= <SPC> 0 : <NL>              return <SPC> 0.0 <NL>          lookup [ a , <SPC> b ] <SPC> = <SPC> 0.25 <SPC> * <SPC> ( <NL>              dp ( a <SPC> - <SPC> 4 , <SPC> b , <SPC> lookup ) <NL>              + <SPC> dp ( a <SPC> - <SPC> 3 , <SPC> b <SPC> - <SPC> 1 , <SPC> lookup ) <NL>              + <SPC> dp ( a <SPC> - <SPC> 2 , <SPC> b <SPC> - <SPC> 2 , <SPC> lookup ) <NL>              + <SPC> dp ( a <SPC> - <SPC> 1 , <SPC> b <SPC> - <SPC> 3 , <SPC> lookup ) <NL>          ) <NL>          return <SPC> lookup [ a , <SPC> b ] <NL> <NL> <TAB> if <SPC> N <SPC> >= <SPC> 4800 : <NL>          return <SPC> 1.0 <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> N <SPC> = <SPC> ( N <SPC> + <SPC> 24 ) <SPC> // <SPC> 25 <NL> <TAB> return <SPC> dp ( N , <SPC> N , <SPC> lookup ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> multiply ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> m , <SPC> n , <SPC> l <SPC> = <SPC> len ( A ) , <SPC> len ( A [ 0 ] ) , <SPC> len ( B [ 0 ] ) <NL> <TAB> res <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( l ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( m ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          for <SPC> k <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> A [ i ] [ k ] : <NL>                  for <SPC> j <SPC> in <SPC> xrange ( l ) : <NL>                      res [ i ] [ j ] <SPC> += <SPC> A [ i ] [ k ] <SPC> * <SPC> B [ k ] [ j ] <NL> <TAB> return <SPC> res <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> specialArray ( self , <SPC> nums ) : <NL> <NL> <TAB> MAX_NUM <SPC> = <SPC> 1000 <NL> <TAB> count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( MAX_NUM <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          count [ num ] <SPC> += <SPC> 1 <NL> <TAB> n <SPC> = <SPC> len ( nums ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( count ) ) : <NL>          if <SPC> i <SPC> == <SPC> n : <NL>              return <SPC> i <NL>          n <SPC> -= <SPC> count [ i ] <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> specialArray ( self , <SPC> nums ) : <NL> <NL> <TAB> MAX_NUM <SPC> = <SPC> 1000 <NL> <NL> <TAB> def <SPC> inplace_counting_sort ( nums , <SPC> reverse = False ) : <NL>          count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( MAX_NUM <SPC> + <SPC> 1 ) <NL>          for <SPC> num <SPC> in <SPC> nums : <NL>              count [ num ] <SPC> += <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( count ) ) : <NL>              count [ i ] <SPC> += <SPC> count [ i <SPC> - <SPC> 1 ] <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( nums ) ) ) : <NL>              if <SPC> nums [ i ] <SPC> < <SPC> 0 : <NL>                  continue <NL>              while <SPC> i <SPC> != <SPC> count [ nums [ i ] ] <SPC> - <SPC> 1 : <NL>                  count [ nums [ i ] ] <SPC> -= <SPC> 1 <NL>                  nums [ count [ nums [ i ] ] ] , <SPC> nums [ i ] <SPC> = <SPC> ~ nums [ i ] , <SPC> nums [ count [ nums [ i ] ] ] <NL>              count [ nums [ i ] ] <SPC> -= <SPC> 1 <NL>              nums [ i ] <SPC> = <SPC> ~ nums [ i ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>              nums [ i ] <SPC> = <SPC> ~ nums [ i ] <NL>          if <SPC> reverse : <NL>              nums . reverse ( ) <NL> <NL> <TAB> inplace_counting_sort ( nums , <SPC> reverse = True ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> nums [ mid ] <SPC> <= <SPC> mid : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> - 1 <SPC> if <SPC> left <SPC> < <SPC> len ( nums ) <SPC> and <SPC> nums [ left ] <SPC> == <SPC> left <SPC> else <SPC> left <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> specialArray ( self , <SPC> nums ) : <NL> <NL> <TAB> MAX_NUM <SPC> = <SPC> 1000 <NL> <NL> <TAB> def <SPC> counting_sort ( nums , <SPC> reverse = False ) : <NL>          count <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( MAX_NUM <SPC> + <SPC> 1 ) <NL>          for <SPC> num <SPC> in <SPC> nums : <NL>              count [ num ] <SPC> += <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( count ) ) : <NL>              count [ i ] <SPC> += <SPC> count [ i <SPC> - <SPC> 1 ] <NL>          result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( nums ) <NL>          if <SPC> not <SPC> reverse : <NL>              for <SPC> num <SPC> in <SPC> reversed ( nums ) : <NL>                  count [ num ] <SPC> -= <SPC> 1 <NL>                  result [ count [ num ] ] <SPC> = <SPC> num <NL>          else : <NL>              for <SPC> num <SPC> in <SPC> nums : <NL>                  count [ num ] <SPC> -= <SPC> 1 <NL>                  result [ count [ num ] ] <SPC> = <SPC> num <NL>              result . reverse ( ) <NL>          return <SPC> result <NL> <NL> <TAB> nums <SPC> = <SPC> counting_sort ( nums , <SPC> reverse = True ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> nums [ mid ] <SPC> <= <SPC> mid : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> - 1 <SPC> if <SPC> left <SPC> < <SPC> len ( nums ) <SPC> and <SPC> nums [ left ] <SPC> == <SPC> left <SPC> else <SPC> left <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> specialArray ( self , <SPC> nums ) : <NL> <NL> <TAB> nums . sort ( reverse = True ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          if <SPC> nums [ i ] <SPC> <= <SPC> i : <NL>              break <NL> <TAB> else : <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> - 1 <SPC> if <SPC> i <SPC> < <SPC> len ( nums ) <SPC> and <SPC> nums [ i ] <SPC> == <SPC> i <SPC> else <SPC> i <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> makeLargestSpecial ( self , <SPC> S ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> anchor <SPC> = <SPC> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( S ) : <NL>          count <SPC> += <SPC> 1 <SPC> if <SPC> v <SPC> == <SPC> "1" <SPC> else <SPC> - 1 <NL>          if <SPC> count <SPC> == <SPC> 0 : <NL>              result . append ( "1{}0" . format ( <NL>                  self . makeLargestSpecial ( S [ anchor <SPC> + <SPC> 1 : <SPC> i ] ) ) ) <NL>              anchor <SPC> = <SPC> i <SPC> + <SPC> 1 <NL> <TAB> result . sort ( reverse = True ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSpecial ( self , <SPC> mat ) : <NL> <NL> <TAB> rows , <SPC> cols <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( mat ) , <SPC> [ 0 ] <SPC> * <SPC> len ( mat [ 0 ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( rows ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( cols ) ) : <NL>              if <SPC> mat [ i ] [ j ] : <NL>                  rows [ i ] <SPC> += <SPC> 1 <NL>                  cols [ j ] <SPC> += <SPC> 1 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( rows ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( cols ) ) : <NL>              if <SPC> mat [ i ] [ j ] <SPC> == <SPC> rows [ i ] <SPC> == <SPC> cols [ j ] <SPC> == <SPC> 1 : <NL>                  result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> generateMatrix ( self , <SPC> n ) : <NL> <TAB> matrix <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <NL> <TAB> left , <SPC> right , <SPC> top , <SPC> bottom , <SPC> num <SPC> = <SPC> 0 , <SPC> n <SPC> - <SPC> 1 , <SPC> 0 , <SPC> n <SPC> - <SPC> 1 , <SPC> 1 <NL> <NL> <TAB> while <SPC> left <SPC> <= <SPC> right <SPC> and <SPC> top <SPC> <= <SPC> bottom : <NL>          for <SPC> j <SPC> in <SPC> xrange ( left , <SPC> right <SPC> + <SPC> 1 ) : <NL>              matrix [ top ] [ j ] <SPC> = <SPC> num <NL>              num <SPC> += <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( top <SPC> + <SPC> 1 , <SPC> bottom ) : <NL>              matrix [ i ] [ right ] <SPC> = <SPC> num <NL>              num <SPC> += <SPC> 1 <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( left , <SPC> right <SPC> + <SPC> 1 ) ) : <NL>              if <SPC> top <SPC> < <SPC> bottom : <NL>                  matrix [ bottom ] [ j ] <SPC> = <SPC> num <NL>                  num <SPC> += <SPC> 1 <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( top <SPC> + <SPC> 1 , <SPC> bottom ) ) : <NL>              if <SPC> left <SPC> < <SPC> right : <NL>                  matrix [ i ] [ left ] <SPC> = <SPC> num <NL>                  num <SPC> += <SPC> 1 <NL>          left , <SPC> right , <SPC> top , <SPC> bottom <SPC> = <SPC> left <SPC> + <SPC> 1 , <SPC> right <SPC> - <SPC> 1 , <SPC> top <SPC> + <SPC> 1 , <SPC> bottom <SPC> - <SPC> 1 <NL> <NL> <TAB> return <SPC> matrix <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> spiralMatrixIII ( self , <SPC> R , <SPC> C , <SPC> r0 , <SPC> c0 ) : <NL> <NL> <TAB> r , <SPC> c <SPC> = <SPC> r0 , <SPC> c0 <NL> <TAB> result <SPC> = <SPC> [ [ r , <SPC> c ] ] <NL> <TAB> x , <SPC> y , <SPC> n , <SPC> i <SPC> = <SPC> 0 , <SPC> 1 , <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> len ( result ) <SPC> < <SPC> R <SPC> * <SPC> C : <NL>          r , <SPC> c , <SPC> i <SPC> = <SPC> r <SPC> + <SPC> x , <SPC> c <SPC> + <SPC> y , <SPC> i <SPC> + <SPC> 1 <NL>          if <SPC> 0 <SPC> <= <SPC> r <SPC> < <SPC> R <SPC> and <SPC> 0 <SPC> <= <SPC> c <SPC> < <SPC> C : <NL>              result . append ( [ r , <SPC> c ] ) <NL>          if <SPC> i <SPC> == <SPC> n <SPC> // <SPC> 2 <SPC> + <SPC> 1 : <NL>              x , <SPC> y , <SPC> n , <SPC> i <SPC> = <SPC> y , <SPC> - x , <SPC> n <SPC> + <SPC> 1 , <SPC> 0 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> spiralOrder ( self , <SPC> matrix ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> matrix <SPC> == <SPC> [ ] : <NL>          return <SPC> result <NL> <NL> <TAB> left , <SPC> right , <SPC> top , <SPC> bottom <SPC> = <SPC> 0 , <SPC> len ( matrix [ 0 ] ) <SPC> - <SPC> 1 , <SPC> 0 , <SPC> len ( matrix ) <SPC> - <SPC> 1 <NL> <NL> <TAB> while <SPC> left <SPC> <= <SPC> right <SPC> and <SPC> top <SPC> <= <SPC> bottom : <NL>          for <SPC> j <SPC> in <SPC> xrange ( left , <SPC> right <SPC> + <SPC> 1 ) : <NL>              result . append ( matrix [ top ] [ j ] ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( top <SPC> + <SPC> 1 , <SPC> bottom ) : <NL>              result . append ( matrix [ i ] [ right ] ) <NL>          for <SPC> j <SPC> in <SPC> reversed ( xrange ( left , <SPC> right <SPC> + <SPC> 1 ) ) : <NL>              if <SPC> top <SPC> < <SPC> bottom : <NL>                  result . append ( matrix [ bottom ] [ j ] ) <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( top <SPC> + <SPC> 1 , <SPC> bottom ) ) : <NL>              if <SPC> left <SPC> < <SPC> right : <NL>                  result . append ( matrix [ i ] [ left ] ) <NL>          left , <SPC> right , <SPC> top , <SPC> bottom <SPC> = <SPC> left <SPC> + <SPC> 1 , <SPC> right <SPC> - <SPC> 1 , <SPC> top <SPC> + <SPC> 1 , <SPC> bottom <SPC> - <SPC> 1 <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> balancedStringSplit ( self , <SPC> s ) : <NL> <NL> <TAB> result , <SPC> count <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          count <SPC> += <SPC> 1 <SPC> if <SPC> c <SPC> == <SPC> "L" <SPC> else <SPC> - 1 <NL>          if <SPC> count <SPC> == <SPC> 0 : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxUniqueSplit ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> popcount ( n ) : <NL>          count <SPC> = <SPC> 0 <NL>          while <SPC> n : <NL>              n <SPC> &= <SPC> n <SPC> - <SPC> 1 <NL>              count <SPC> += <SPC> 1 <NL>          return <SPC> count <NL> <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> total <SPC> = <SPC> 2 <SPC> ** <SPC> ( len ( s ) <SPC> - <SPC> 1 ) <NL> <TAB> mask <SPC> = <SPC> 0 <NL> <TAB> while <SPC> mask <SPC> < <SPC> total : <NL>          if <SPC> popcount ( mask ) <SPC> < <SPC> result : <NL>              mask <SPC> += <SPC> 1 <NL>              continue <NL>          lookup , <SPC> curr , <SPC> base <SPC> = <SPC> set ( ) , <SPC> [ ] , <SPC> total <SPC> // <SPC> 2 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>              curr . append ( s [ i ] ) <NL>              if <SPC> ( mask <SPC> & <SPC> base ) <SPC> or <SPC> base <SPC> == <SPC> 0 : <NL>                  if <SPC> "" . join ( curr ) <SPC> in <SPC> lookup : <NL>                      mask <SPC> = <SPC> ( <NL>                          ( mask <SPC> | <SPC> ( base <SPC> - <SPC> 1 ) ) <SPC> + <SPC> 1 <SPC> if <SPC> base <SPC> else <SPC> mask <SPC> + <SPC> 1 <NL>                      ) <NL>                      break <NL>                  lookup . add ( "" . join ( curr ) ) <NL>                  curr <SPC> = <SPC> [ ] <NL>              base <SPC> >>= <SPC> 1 <NL>          else : <NL>              result <SPC> = <SPC> max ( result , <SPC> len ( lookup ) ) <NL>              mask <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPossible ( self , <SPC> nums ) : <NL> <NL> <TAB> pre , <SPC> cur <SPC> = <SPC> float ( "-inf" ) , <SPC> 0 <NL> <TAB> cnt1 , <SPC> cnt2 , <SPC> cnt3 <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( nums ) : <NL>          cnt <SPC> = <SPC> 0 <NL>          cur <SPC> = <SPC> nums [ i ] <NL>          while <SPC> i <SPC> < <SPC> len ( nums ) <SPC> and <SPC> cur <SPC> == <SPC> nums [ i ] : <NL>              cnt <SPC> += <SPC> 1 <NL>              i <SPC> += <SPC> 1 <NL> <NL>          if <SPC> cur <SPC> != <SPC> pre <SPC> + <SPC> 1 : <NL>              if <SPC> cnt1 <SPC> != <SPC> 0 <SPC> or <SPC> cnt2 <SPC> != <SPC> 0 : <NL>                  return <SPC> False <NL>              cnt1 , <SPC> cnt2 , <SPC> cnt3 <SPC> = <SPC> cnt , <SPC> 0 , <SPC> 0 <NL>          else : <NL>              if <SPC> cnt <SPC> < <SPC> cnt1 <SPC> + <SPC> cnt2 : <NL>                  return <SPC> False <NL>              cnt1 , <SPC> cnt2 , <SPC> cnt3 <SPC> = <SPC> ( <NL>                  max ( 0 , <SPC> cnt <SPC> - <SPC> ( cnt1 <SPC> + <SPC> cnt2 <SPC> + <SPC> cnt3 ) ) , <NL>                  cnt1 , <NL>                  cnt2 <SPC> + <SPC> min ( cnt3 , <SPC> cnt <SPC> - <SPC> ( cnt1 <SPC> + <SPC> cnt2 ) ) , <NL>              ) <NL>          pre <SPC> = <SPC> cur <NL> <TAB> return <SPC> cnt1 <SPC> == <SPC> 0 <SPC> and <SPC> cnt2 <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> splitIntoFibonacci ( self , <SPC> S ) : <NL> <NL> <TAB> def <SPC> startswith ( S , <SPC> k , <SPC> x ) : <NL>          y <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( k , <SPC> len ( S ) ) : <NL>              y <SPC> = <SPC> 10 <SPC> * <SPC> y <SPC> + <SPC> int ( S [ i ] ) <NL>              if <SPC> y <SPC> == <SPC> x : <NL>                  return <SPC> i <SPC> - <SPC> k <SPC> + <SPC> 1 <NL>              elif <SPC> y <SPC> > <SPC> x : <NL>                  break <NL>          return <SPC> 0 <NL> <NL> <TAB> MAX_INT <SPC> = <SPC> 2 <SPC> ** <SPC> 31 <SPC> - <SPC> 1 <NL> <TAB> a <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( S ) <SPC> - <SPC> 2 ) : <NL>          a <SPC> = <SPC> 10 <SPC> * <SPC> a <SPC> + <SPC> int ( S [ i ] ) <NL>          b <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( S ) <SPC> - <SPC> 1 ) : <NL>              b <SPC> = <SPC> 10 <SPC> * <SPC> b <SPC> + <SPC> int ( S [ j ] ) <NL>              fib <SPC> = <SPC> [ a , <SPC> b ] <NL>              k <SPC> = <SPC> j <SPC> + <SPC> 1 <NL>              while <SPC> k <SPC> < <SPC> len ( S ) : <NL>                  if <SPC> fib [ - 2 ] <SPC> > <SPC> MAX_INT <SPC> - <SPC> fib [ - 1 ] : <NL>                      break <NL>                  c <SPC> = <SPC> fib [ - 2 ] <SPC> + <SPC> fib [ - 1 ] <NL>                  length <SPC> = <SPC> startswith ( S , <SPC> k , <SPC> c ) <NL>                  if <SPC> length <SPC> == <SPC> 0 : <NL>                      break <NL>                  fib . append ( c ) <NL>                  k <SPC> += <SPC> length <NL>              else : <NL>                  return <SPC> fib <NL>              if <SPC> b <SPC> == <SPC> 0 : <NL>                  break <NL>          if <SPC> a <SPC> == <SPC> 0 : <NL>              break <NL> <TAB> return <SPC> [ ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> splitArray ( self , <SPC> nums , <SPC> m ) : <NL> <NL> <TAB> def <SPC> check ( nums , <SPC> m , <SPC> s ) : <NL>          cnt , <SPC> curr_sum <SPC> = <SPC> 1 , <SPC> 0 <NL>          for <SPC> num <SPC> in <SPC> nums : <NL>              curr_sum <SPC> += <SPC> num <NL>              if <SPC> curr_sum <SPC> > <SPC> s : <NL>                  curr_sum <SPC> = <SPC> num <NL>                  cnt <SPC> += <SPC> 1 <NL>          return <SPC> cnt <SPC> <= <SPC> m <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> max ( nums ) , <SPC> sum ( nums ) <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> check ( nums , <SPC> m , <SPC> mid ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> splitArray ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> len ( nums ) <SPC> < <SPC> 7 : <NL>          return <SPC> False <NL> <NL> <TAB> accumulated_sum <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( nums ) <NL> <TAB> accumulated_sum [ 0 ] <SPC> = <SPC> nums [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( nums ) ) : <NL>          accumulated_sum [ i ] <SPC> = <SPC> accumulated_sum [ i <SPC> - <SPC> 1 ] <SPC> + <SPC> nums [ i ] <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 3 , <SPC> len ( nums ) <SPC> - <SPC> 3 ) : <NL>          lookup <SPC> = <SPC> set ( ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> j <SPC> - <SPC> 1 ) : <NL>              if <SPC> ( <NL>                  accumulated_sum [ i <SPC> - <SPC> 1 ] <NL>                  == <SPC> accumulated_sum [ j <SPC> - <SPC> 1 ] <SPC> - <SPC> accumulated_sum [ i ] <NL>              ) : <NL>                  lookup . add ( accumulated_sum [ i <SPC> - <SPC> 1 ] ) <NL>          for <SPC> k <SPC> in <SPC> xrange ( j <SPC> + <SPC> 2 , <SPC> len ( nums ) <SPC> - <SPC> 1 ) : <NL>              if <SPC> ( <NL>                  accumulated_sum [ - 1 ] <SPC> - <SPC> accumulated_sum [ k ] <NL>                  == <SPC> accumulated_sum [ k <SPC> - <SPC> 1 ] <SPC> - <SPC> accumulated_sum [ j ] <NL>                  and <SPC> accumulated_sum [ k <SPC> - <SPC> 1 ] <SPC> - <SPC> accumulated_sum [ j ] <SPC> in <SPC> lookup <NL>              ) : <NL>                  return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> splitArraySameAverage ( self , <SPC> A ) : <NL> <NL> <TAB> def <SPC> possible ( total , <SPC> n ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> // <SPC> 2 <SPC> + <SPC> 1 ) : <NL>              if <SPC> total <SPC> * <SPC> i <SPC> % <SPC> n <SPC> == <SPC> 0 : <NL>                  return <SPC> True <NL>          return <SPC> False <NL> <NL> <TAB> n , <SPC> s <SPC> = <SPC> len ( A ) , <SPC> sum ( A ) <NL> <TAB> if <SPC> not <SPC> possible ( n , <SPC> s ) : <NL>          return <SPC> False <NL> <NL> <TAB> sums <SPC> = <SPC> [ set ( ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n <SPC> // <SPC> 2 <SPC> + <SPC> 1 ) ] <NL> <TAB> sums [ 0 ] . add ( 0 ) <NL> <TAB> for <SPC> num <SPC> in <SPC> A : <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> n <SPC> // <SPC> 2 <SPC> + <SPC> 1 ) ) : <NL>              for <SPC> prev <SPC> in <SPC> sums [ i <SPC> - <SPC> 1 ] : <NL>                  sums [ i ] . add ( prev <SPC> + <SPC> num ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> // <SPC> 2 <SPC> + <SPC> 1 ) : <NL>          if <SPC> s <SPC> * <SPC> i <SPC> % <SPC> n <SPC> == <SPC> 0 <SPC> and <SPC> s <SPC> * <SPC> i <SPC> // <SPC> n <SPC> in <SPC> sums [ i ] : <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> splitBST ( self , <SPC> root , <SPC> V ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> None , <SPC> None <NL> <TAB> elif <SPC> root . val <SPC> <= <SPC> V : <NL>          result <SPC> = <SPC> self . splitBST ( root . right , <SPC> V ) <NL>          root . right <SPC> = <SPC> result [ 0 ] <NL>          return <SPC> root , <SPC> result [ 1 ] <NL> <TAB> else : <NL>          result <SPC> = <SPC> self . splitBST ( root . left , <SPC> V ) <NL>          root . left <SPC> = <SPC> result [ 1 ] <NL>          return <SPC> result [ 0 ] , <SPC> root <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> splitLoopedString ( self , <SPC> strs ) : <NL> <NL> <TAB> tmp <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> s <SPC> in <SPC> strs : <NL>          tmp <SPC> += <SPC> max ( s , <SPC> s [ : : - 1 ] ) <NL> <TAB> s <SPC> = <SPC> "" . join ( tmp ) <NL> <NL> <TAB> result , <SPC> st <SPC> = <SPC> "a" , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( strs ) ) : <NL>          body <SPC> = <SPC> "" . join ( [ s [ st <SPC> + <SPC> len ( strs [ i ] ) : ] , <SPC> s [ 0 : st ] ] ) <NL>          for <SPC> p <SPC> in <SPC> strs [ i ] , <SPC> strs [ i ] [ : : - 1 ] : <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( strs [ i ] ) ) : <NL>                  if <SPC> p [ j ] <SPC> >= <SPC> result [ 0 ] : <NL>                      result <SPC> = <SPC> max ( result , <SPC> "" . join ( [ p [ j : ] , <SPC> body , <SPC> p [ : j ] ] ) ) <NL>          st <SPC> += <SPC> len ( strs [ i ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> splitListToParts ( self , <SPC> root , <SPC> k ) : <NL> <NL> <TAB> n <SPC> = <SPC> 0 <NL> <TAB> curr <SPC> = <SPC> root <NL> <TAB> while <SPC> curr : <NL>          curr <SPC> = <SPC> curr . next <NL>          n <SPC> += <SPC> 1 <NL> <TAB> width , <SPC> remainder <SPC> = <SPC> divmod ( n , <SPC> k ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> curr <SPC> = <SPC> root <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k ) : <NL>          head <SPC> = <SPC> curr <NL>          for <SPC> j <SPC> in <SPC> xrange ( width <SPC> - <SPC> 1 <SPC> + <SPC> int ( i <SPC> < <SPC> remainder ) ) : <NL>              if <SPC> curr : <NL>                  curr <SPC> = <SPC> curr . next <NL>          if <SPC> curr : <NL>              curr . next , <SPC> curr <SPC> = <SPC> None , <SPC> curr . next <NL>          result . append ( head ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkPalindromeFormation ( self , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> def <SPC> is_palindrome ( s , <SPC> i , <SPC> j ) : <NL>          while <SPC> i <SPC> < <SPC> j : <NL>              if <SPC> s [ i ] <SPC> != <SPC> s [ j ] : <NL>                  return <SPC> False <NL>              i <SPC> += <SPC> 1 <NL>              j <SPC> -= <SPC> 1 <NL>          return <SPC> True <NL> <NL> <TAB> def <SPC> check ( a , <SPC> b ) : <NL>          i , <SPC> j <SPC> = <SPC> 0 , <SPC> len ( b ) <SPC> - <SPC> 1 <NL>          while <SPC> i <SPC> < <SPC> j : <NL>              if <SPC> a [ i ] <SPC> != <SPC> b [ j ] : <NL>                  return <SPC> is_palindrome ( a , <SPC> i , <SPC> j ) <SPC> or <SPC> is_palindrome ( b , <SPC> i , <SPC> j ) <NL>              i <SPC> += <SPC> 1 <NL>              j <SPC> -= <SPC> 1 <NL>          return <SPC> True <NL> <NL> <TAB> return <SPC> check ( a , <SPC> b ) <SPC> or <SPC> check ( b , <SPC> a ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mySqrt ( self , <SPC> x ) : <NL> <NL> <TAB> if <SPC> x <SPC> < <SPC> 2 : <NL>          return <SPC> x <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> x <SPC> // <SPC> 2 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> mid <SPC> > <SPC> x <SPC> / <SPC> mid : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <NL> <TAB> return <SPC> left <SPC> - <SPC> 1 <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sortedSquares ( self , <SPC> A ) : <NL> <NL> <TAB> right <SPC> = <SPC> bisect . bisect_left ( A , <SPC> 0 ) <NL> <TAB> left <SPC> = <SPC> right <SPC> - <SPC> 1 <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> 0 <SPC> <= <SPC> left <SPC> or <SPC> right <SPC> < <SPC> len ( A ) : <NL>          if <SPC> right <SPC> == <SPC> len ( A ) <SPC> or <SPC> ( 0 <SPC> <= <SPC> left <SPC> and <SPC> A [ left ] <SPC> ** <SPC> 2 <SPC> < <SPC> A [ right ] <SPC> ** <SPC> 2 ) : <NL>              result . append ( A [ left ] <SPC> ** <SPC> 2 ) <NL>              left <SPC> -= <SPC> 1 <NL>          else : <NL>              result . append ( A [ right ] <SPC> ** <SPC> 2 ) <NL>              right <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minDistance ( self , <SPC> height , <SPC> width , <SPC> tree , <SPC> squirrel , <SPC> nuts ) : <NL> <NL> <TAB> def <SPC> distance ( a , <SPC> b ) : <NL>          return <SPC> abs ( a [ 0 ] <SPC> - <SPC> b [ 0 ] ) <SPC> + <SPC> abs ( a [ 1 ] <SPC> - <SPC> b [ 1 ] ) <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> d <SPC> = <SPC> float ( "inf" ) <NL> <TAB> for <SPC> nut <SPC> in <SPC> nuts : <NL>          result <SPC> += <SPC> distance ( nut , <SPC> tree ) <SPC> * <SPC> 2 <NL>          d <SPC> = <SPC> min ( d , <SPC> distance ( nut , <SPC> squirrel ) <SPC> - <SPC> distance ( nut , <SPC> tree ) ) <NL> <TAB> return <SPC> result <SPC> + <SPC> d <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> movesToStamp ( self , <SPC> stamp , <SPC> target ) : <NL> <TAB> M , <SPC> N <SPC> = <SPC> len ( stamp ) , <SPC> len ( target ) <NL> <NL> <TAB> q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> lookup <SPC> = <SPC> [ False ] <SPC> * <SPC> N <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> A <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( N <SPC> - <SPC> M <SPC> + <SPC> 1 ) : <NL>          made , <SPC> todo <SPC> = <SPC> set ( ) , <SPC> set ( ) <NL>          for <SPC> j , <SPC> c <SPC> in <SPC> enumerate ( stamp ) : <NL>              if <SPC> c <SPC> == <SPC> target [ i <SPC> + <SPC> j ] : <NL>                  made . add ( i <SPC> + <SPC> j ) <NL>              else : <NL>                  todo . add ( i <SPC> + <SPC> j ) <NL>          A . append ( ( made , <SPC> todo ) ) <NL>          if <SPC> todo : <NL>              continue <NL>          result . append ( i ) <NL>          for <SPC> m <SPC> in <SPC> made : <NL>              if <SPC> lookup [ m ] : <NL>                  continue <NL>              q . append ( m ) <NL>              lookup [ m ] <SPC> = <SPC> True <NL> <NL> <TAB> while <SPC> q : <NL>          i <SPC> = <SPC> q . popleft ( ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( max ( 0 , <SPC> i <SPC> - <SPC> M <SPC> + <SPC> 1 ) , <SPC> min ( N <SPC> - <SPC> M , <SPC> i ) <SPC> + <SPC> 1 ) : <NL>              made , <SPC> todo <SPC> = <SPC> A [ j ] <NL>              if <SPC> i <SPC> not <SPC> in <SPC> todo : <NL>                  continue <NL>              todo . discard ( i ) <NL>              if <SPC> todo : <NL>                  continue <NL>              result . append ( j ) <NL>              for <SPC> m <SPC> in <SPC> made : <NL>                  if <SPC> lookup [ m ] : <NL>                      continue <NL>                  q . append ( m ) <NL>                  lookup [ m ] <SPC> = <SPC> True <NL> <TAB> return <SPC> result [ : : - 1 ] <SPC> if <SPC> all ( lookup ) <SPC> else <SPC> [ ] <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sampleStats ( self , <SPC> count ) : <NL> <NL> <TAB> n <SPC> = <SPC> sum ( count ) <NL> <TAB> mi <SPC> = <SPC> next ( i <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( count ) ) <SPC> if <SPC> count [ i ] ) <SPC> * <SPC> 1.0 <NL> <TAB> ma <SPC> = <SPC> next ( i <SPC> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( count ) ) ) <SPC> if <SPC> count [ i ] ) <SPC> * <SPC> 1.0 <NL> <TAB> mean <SPC> = <SPC> sum ( i <SPC> * <SPC> v <SPC> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( count ) ) <SPC> * <SPC> 1.0 <SPC> / <SPC> n <NL> <TAB> mode <SPC> = <SPC> count . index ( max ( count ) ) <SPC> * <SPC> 1.0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( count ) ) : <NL>          count [ i ] <SPC> += <SPC> count [ i <SPC> - <SPC> 1 ] <NL> <TAB> median1 <SPC> = <SPC> bisect . bisect_left ( count , <SPC> ( n <SPC> + <SPC> 1 ) <SPC> // <SPC> 2 ) <NL> <TAB> median2 <SPC> = <SPC> bisect . bisect_left ( count , <SPC> ( n <SPC> + <SPC> 2 ) <SPC> // <SPC> 2 ) <NL> <TAB> median <SPC> = <SPC> ( median1 <SPC> + <SPC> median2 ) <SPC> / <SPC> 2.0 <NL> <TAB> return <SPC> [ mi , <SPC> ma , <SPC> mean , <SPC> median , <SPC> mode ] <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> MAX_HIGH <SPC> = <SPC> int ( 2e9 ) <NL> result <SPC> = <SPC> [ 0 , <SPC> 1 , <SPC> 2 , <SPC> 3 , <SPC> 4 , <SPC> 5 , <SPC> 6 , <SPC> 7 , <SPC> 8 , <SPC> 9 ] <NL> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> MAX_HIGH ) : <NL> <TAB> if <SPC> result [ - 1 ] <SPC> >= <SPC> MAX_HIGH : <NL> <TAB> break <NL> <TAB> d1 <SPC> = <SPC> result [ i ] <SPC> % <SPC> 10 <SPC> - <SPC> 1 <NL> <TAB> if <SPC> d1 <SPC> >= <SPC> 0 : <NL> <TAB> result . append ( result [ i ] <SPC> * <SPC> 10 <SPC> + <SPC> d1 ) <NL> <TAB> d2 <SPC> = <SPC> result [ i ] <SPC> % <SPC> 10 <SPC> + <SPC> 1 <NL> <TAB> if <SPC> d2 <SPC> <= <SPC> 9 : <NL> <TAB> result . append ( result [ i ] <SPC> * <SPC> 10 <SPC> + <SPC> d2 ) <NL> result . append ( float ( "inf" ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countSteppingNumbers ( self , <SPC> low , <SPC> high ) : <NL> <NL> <TAB> lit <SPC> = <SPC> bisect . bisect_left ( result , <SPC> low ) <NL> <TAB> rit <SPC> = <SPC> bisect . bisect_right ( result , <SPC> high ) <NL> <TAB> return <SPC> result [ lit : rit ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> countSteppingNumbers ( self , <SPC> low , <SPC> high ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ 0 , <SPC> 1 , <SPC> 2 , <SPC> 3 , <SPC> 4 , <SPC> 5 , <SPC> 6 , <SPC> 7 , <SPC> 8 , <SPC> 9 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> high ) : <NL>          if <SPC> result [ - 1 ] <SPC> >= <SPC> high : <NL>              break <NL>          d1 <SPC> = <SPC> result [ i ] <SPC> % <SPC> 10 <SPC> - <SPC> 1 <NL>          if <SPC> d1 <SPC> >= <SPC> 0 : <NL>              result . append ( result [ i ] <SPC> * <SPC> 10 <SPC> + <SPC> d1 ) <NL>          d2 <SPC> = <SPC> result [ i ] <SPC> % <SPC> 10 <SPC> + <SPC> 1 <NL>          if <SPC> d2 <SPC> <= <SPC> 9 : <NL>              result . append ( result [ i ] <SPC> * <SPC> 10 <SPC> + <SPC> d2 ) <NL> <TAB> result . append ( float ( "inf" ) ) <NL> <TAB> lit <SPC> = <SPC> bisect . bisect_left ( result , <SPC> low ) <NL> <TAB> rit <SPC> = <SPC> bisect . bisect_right ( result , <SPC> high ) <NL> <TAB> return <SPC> result [ lit : rit ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> minStickers ( self , <SPC> stickers , <SPC> target ) : <NL> <NL> <TAB> def <SPC> minStickersHelper ( sticker_counts , <SPC> target , <SPC> dp ) : <NL>          if <SPC> "" . join ( target ) <SPC> in <SPC> dp : <NL>              return <SPC> dp [ "" . join ( target ) ] <NL>          target_count <SPC> = <SPC> collections . Counter ( target ) <NL>          result <SPC> = <SPC> float ( "inf" ) <NL>          for <SPC> sticker_count <SPC> in <SPC> sticker_counts : <NL>              if <SPC> sticker_count [ target [ 0 ] ] <SPC> == <SPC> 0 : <NL>                  continue <NL>              new_target <SPC> = <SPC> [ ] <NL>              for <SPC> k <SPC> in <SPC> target_count . keys ( ) : <NL>                  if <SPC> target_count [ k ] <SPC> > <SPC> sticker_count [ k ] : <NL>                      new_target <SPC> += <SPC> [ k ] <SPC> * <SPC> ( target_count [ k ] <SPC> - <SPC> sticker_count [ k ] ) <NL>              if <SPC> len ( new_target ) <SPC> != <SPC> len ( target ) : <NL>                  num <SPC> = <SPC> minStickersHelper ( sticker_counts , <SPC> new_target , <SPC> dp ) <NL>                  if <SPC> num <SPC> != <SPC> - 1 : <NL>                      result <SPC> = <SPC> min ( result , <SPC> 1 <SPC> + <SPC> num ) <NL>          dp [ "" . join ( target ) ] <SPC> = <SPC> - 1 <SPC> if <SPC> result <SPC> == <SPC> float ( "inf" ) <SPC> else <SPC> result <NL>          return <SPC> dp [ "" . join ( target ) ] <NL> <NL> <TAB> sticker_counts <SPC> = <SPC> map ( collections . Counter , <SPC> stickers ) <NL> <TAB> dp <SPC> = <SPC> { "" : <SPC> 0 } <NL> <TAB> return <SPC> minStickersHelper ( sticker_counts , <SPC> target , <SPC> dp ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> stoneGameII ( self , <SPC> piles ) : <NL> <NL> <TAB> def <SPC> dp ( piles , <SPC> lookup , <SPC> i , <SPC> m ) : <NL>          if <SPC> i <SPC> + <SPC> 2 <SPC> * <SPC> m <SPC> >= <SPC> len ( piles ) : <NL>              return <SPC> piles [ i ] <NL>          if <SPC> ( i , <SPC> m ) <SPC> not <SPC> in <SPC> lookup : <NL>              lookup [ i , <SPC> m ] <SPC> = <SPC> piles [ i ] <SPC> - <SPC> min ( <NL>                  dp ( piles , <SPC> lookup , <SPC> i <SPC> + <SPC> x , <SPC> max ( m , <SPC> x ) ) <SPC> for <SPC> x <SPC> in <SPC> xrange ( 1 , <SPC> 2 <SPC> * <SPC> m <SPC> + <SPC> 1 ) <NL>              ) <NL>          return <SPC> lookup [ i , <SPC> m ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( piles ) <SPC> - <SPC> 1 ) ) : <NL>          piles [ i ] <SPC> += <SPC> piles [ i <SPC> + <SPC> 1 ] <NL> <TAB> return <SPC> dp ( piles , <SPC> { } , <SPC> 0 , <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> stoneGameIII ( self , <SPC> stoneValue ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ float ( "-inf" ) ] <SPC> * <SPC> 3 <NL> <TAB> dp [ len ( stoneValue ) <SPC> % <SPC> 3 ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( stoneValue ) ) ) : <NL>          max_dp , <SPC> curr <SPC> = <SPC> float ( "-inf" ) , <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( min ( 3 , <SPC> len ( stoneValue ) <SPC> - <SPC> i ) ) : <NL>              curr <SPC> += <SPC> stoneValue [ i <SPC> + <SPC> j ] <NL>              max_dp <SPC> = <SPC> max ( max_dp , <SPC> curr <SPC> - <SPC> dp [ ( i <SPC> + <SPC> j <SPC> + <SPC> 1 ) <SPC> % <SPC> 3 ] ) <NL>          dp [ i <SPC> % <SPC> 3 ] <SPC> = <SPC> max_dp <NL> <TAB> return <SPC> [ "Tie" , <SPC> "Alice" , <SPC> "Bob" ] [ cmp ( dp [ 0 ] , <SPC> 0 ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> winnerSquareGame ( self , <SPC> n ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ False ] <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          j <SPC> = <SPC> 1 <NL>          while <SPC> j <SPC> * <SPC> j <SPC> <= <SPC> i : <NL>              if <SPC> not <SPC> dp [ i <SPC> - <SPC> j <SPC> * <SPC> j ] : <NL>                  dp [ i ] <SPC> = <SPC> True <NL>                  break <NL>              j <SPC> += <SPC> 1 <NL> <TAB> return <SPC> dp [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> stoneGameV ( self , <SPC> stoneValue ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( stoneValue ) <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> v <SPC> in <SPC> stoneValue : <NL>          prefix . append ( prefix [ - 1 ] <SPC> + <SPC> v ) <NL> <NL> <TAB> mid <SPC> = <SPC> range ( n ) <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          dp [ i ] [ i ] <SPC> = <SPC> stoneValue [ i ] <NL> <NL> <TAB> max_score <SPC> = <SPC> 0 <NL> <TAB> for <SPC> l <SPC> in <SPC> xrange ( 2 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( n <SPC> - <SPC> l <SPC> + <SPC> 1 ) : <NL>              j <SPC> = <SPC> i <SPC> + <SPC> l <SPC> - <SPC> 1 <NL>              while <SPC> prefix [ mid [ i ] ] <SPC> - <SPC> prefix [ i ] <SPC> < <SPC> prefix [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ mid [ i ] ] : <NL>                  mid [ i ] <SPC> += <SPC> 1 <NL>              p <SPC> = <SPC> mid [ i ] <NL>              max_score <SPC> = <SPC> 0 <NL>              if <SPC> prefix [ p ] <SPC> - <SPC> prefix [ i ] <SPC> == <SPC> prefix [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ p ] : <NL>                  max_score <SPC> = <SPC> max ( dp [ i ] [ p <SPC> - <SPC> 1 ] , <SPC> dp [ j ] [ p ] ) <NL>              else : <NL>                  if <SPC> i <SPC> <= <SPC> p <SPC> - <SPC> 2 : <NL>                      max_score <SPC> = <SPC> max ( max_score , <SPC> dp [ i ] [ p <SPC> - <SPC> 2 ] ) <NL>                  if <SPC> p <SPC> <= <SPC> j : <NL>                      max_score <SPC> = <SPC> max ( max_score , <SPC> dp [ j ] [ p ] ) <NL>              dp [ i ] [ j ] <SPC> = <SPC> max ( <NL>                  dp [ i ] [ j <SPC> - <SPC> 1 ] , <SPC> ( prefix [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ i ] ) <SPC> + <SPC> max_score ) <NL>              dp [ j ] [ i ] <SPC> = <SPC> max ( <NL>                  dp [ j ] [ i <SPC> + <SPC> 1 ] , <SPC> ( prefix [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ i ] ) <SPC> + <SPC> max_score ) <NL> <TAB> return <SPC> max_score <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> stoneGameV ( self , <SPC> stoneValue ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( stoneValue ) <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> v <SPC> in <SPC> stoneValue : <NL>          prefix . append ( prefix [ - 1 ] <SPC> + <SPC> v ) <NL> <NL> <TAB> mid <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> l <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( n <SPC> - <SPC> l <SPC> + <SPC> 1 ) : <NL>              j <SPC> = <SPC> i <SPC> + <SPC> l <SPC> - <SPC> 1 <NL>              p <SPC> = <SPC> i <SPC> if <SPC> l <SPC> == <SPC> 1 <SPC> else <SPC> mid [ i ] [ j <SPC> - <SPC> 1 ] <NL>              while <SPC> prefix [ p ] <SPC> - <SPC> prefix [ i ] <SPC> < <SPC> prefix [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ p ] : <NL>                  p <SPC> += <SPC> 1 <NL>              mid [ i ] [ j ] <SPC> = <SPC> p <NL> <NL> <TAB> rmq <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          rmq [ i ] [ i ] <SPC> = <SPC> stoneValue [ i ] <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> l <SPC> in <SPC> xrange ( 2 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( n <SPC> - <SPC> l <SPC> + <SPC> 1 ) : <NL>              j <SPC> = <SPC> i <SPC> + <SPC> l <SPC> - <SPC> 1 <NL>              p <SPC> = <SPC> mid [ i ] [ j ] <NL>              max_score <SPC> = <SPC> 0 <NL>              if <SPC> prefix [ p ] <SPC> - <SPC> prefix [ i ] <SPC> == <SPC> prefix [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ p ] : <NL>                  max_score <SPC> = <SPC> max ( rmq [ i ] [ p <SPC> - <SPC> 1 ] , <SPC> rmq [ j ] [ p ] ) <NL>              else : <NL>                  if <SPC> i <SPC> <= <SPC> p <SPC> - <SPC> 2 : <NL>                      max_score <SPC> = <SPC> max ( max_score , <SPC> rmq [ i ] [ p <SPC> - <SPC> 2 ] ) <NL>                  if <SPC> p <SPC> <= <SPC> j : <NL>                      max_score <SPC> = <SPC> max ( max_score , <SPC> rmq [ j ] [ p ] ) <NL>              dp [ i ] [ j ] <SPC> = <SPC> max_score <NL>              rmq [ i ] [ j ] <SPC> = <SPC> max ( <NL>                  rmq [ i ] [ j <SPC> - <SPC> 1 ] , <SPC> ( prefix [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ i ] ) <SPC> + <SPC> max_score ) <NL>              rmq [ j ] [ i ] <SPC> = <SPC> max ( <NL>                  rmq [ j ] [ i <SPC> + <SPC> 1 ] , <SPC> ( prefix [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ i ] ) <SPC> + <SPC> max_score ) <NL> <TAB> return <SPC> dp [ 0 ] [ n <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> stoneGameVI ( self , <SPC> aliceValues , <SPC> bobValues ) : <NL> <NL> <TAB> sorted_vals <SPC> = <SPC> sorted ( <NL>          ( ( a , <SPC> b ) <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> zip ( aliceValues , <SPC> bobValues ) ) , <SPC> key = sum , <SPC> reverse = True <NL> <TAB> ) <NL> <TAB> return <SPC> cmp ( <NL>          sum ( a <SPC> for <SPC> a , <SPC> _ <SPC> in <SPC> sorted_vals [ : : 2 ] ) , <SPC> sum ( <NL>              b <SPC> for <SPC> _ , <SPC> b <SPC> in <SPC> sorted_vals [ 1 : : 2 ] ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> stoneGameVII ( self , <SPC> stones ) : <NL> <NL> <TAB> def <SPC> score ( i , <SPC> j ) : <NL>          return <SPC> prefix [ j <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ i ] <NL> <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> stone <SPC> in <SPC> stones : <NL>          prefix . append ( prefix [ - 1 ] <SPC> + <SPC> stone ) <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( stones ) ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( stones ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( stones ) ) : <NL>              dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> max ( <NL>                  score ( i <SPC> + <SPC> 1 , <SPC> j ) <SPC> - <SPC> dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <NL>                  score ( i , <SPC> j <SPC> - <SPC> 1 ) <SPC> - <SPC> dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] , <NL>              ) <NL> <TAB> return <SPC> dp [ 0 ] [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> stoneGame ( self , <SPC> piles ) : <NL> <NL> <TAB> if <SPC> len ( piles ) <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> or <SPC> len ( piles ) <SPC> == <SPC> 1 : <NL>          return <SPC> True <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( piles ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( piles ) ) ) : <NL>          dp [ i ] <SPC> = <SPC> piles [ i ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( piles ) ) : <NL>              dp [ j ] <SPC> = <SPC> max ( piles [ i ] <SPC> - <SPC> dp [ j ] , <SPC> piles [ j ] <SPC> - <SPC> dp [ j <SPC> - <SPC> 1 ] ) <NL> <TAB> return <SPC> dp [ - 1 ] <SPC> >= <SPC> 0 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPrintable ( self , <SPC> targetGrid ) : <NL> <NL> <TAB> VISITING , <SPC> VISITED <SPC> = <SPC> range ( 2 ) <NL> <NL> <TAB> def <SPC> has_cycle ( adj , <SPC> color , <SPC> lookup ) : <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> color ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> color <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  lookup [ color ] <SPC> = <SPC> VISITING <NL>                  stk . append ( ( 2 , <SPC> color ) ) <NL>                  for <SPC> new_color <SPC> in <SPC> adj [ color ] : <NL>                      if <SPC> new_color <SPC> in <SPC> lookup : <NL>                          if <SPC> lookup [ new_color ] <SPC> == <SPC> VISITED : <NL>                              continue <NL>                          return <SPC> True <NL>                      stk . append ( ( 1 , <SPC> new_color ) ) <NL>              elif <SPC> step <SPC> == <SPC> 2 : <NL>                  lookup [ color ] <SPC> = <SPC> VISITED <NL>          return <SPC> False <NL> <NL> <TAB> boxes <SPC> = <SPC> collections . defaultdict ( <NL>          lambda : <SPC> [ len ( targetGrid ) , <SPC> len ( targetGrid [ 0 ] ) , <SPC> - 1 , <SPC> - 1 ] <NL> <TAB> ) <NL> <TAB> for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( targetGrid ) : <NL>          for <SPC> c , <SPC> color <SPC> in <SPC> enumerate ( row ) : <NL>              boxes [ color ] [ 0 ] <SPC> = <SPC> min ( boxes [ color ] [ 0 ] , <SPC> r ) <NL>              boxes [ color ] [ 1 ] <SPC> = <SPC> min ( boxes [ color ] [ 1 ] , <SPC> c ) <NL>              boxes [ color ] [ 2 ] <SPC> = <SPC> max ( boxes [ color ] [ 2 ] , <SPC> r ) <NL>              boxes [ color ] [ 3 ] <SPC> = <SPC> max ( boxes [ color ] [ 3 ] , <SPC> c ) <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> color , <SPC> ( min_r , <SPC> min_c , <SPC> max_r , <SPC> max_c ) <SPC> in <SPC> boxes . iteritems ( ) : <NL>          for <SPC> r <SPC> in <SPC> xrange ( min_r , <SPC> max_r <SPC> + <SPC> 1 ) : <NL>              for <SPC> c <SPC> in <SPC> xrange ( min_c , <SPC> max_c <SPC> + <SPC> 1 ) : <NL>                  if <SPC> targetGrid [ r ] [ c ] <SPC> != <SPC> color : <NL>                      adj [ color ] . add ( targetGrid [ r ] [ c ] ) <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> return <SPC> all ( <NL>          color <SPC> in <SPC> lookup <SPC> or <SPC> not <SPC> has_cycle ( adj , <SPC> color , <SPC> lookup ) <NL>          for <SPC> color <SPC> in <SPC> boxes . iterkeys ( ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isPrintable ( self , <SPC> targetGrid ) : <NL> <NL> <TAB> VISITING , <SPC> VISITED <SPC> = <SPC> range ( 2 ) <NL> <NL> <TAB> def <SPC> has_cycle ( adj , <SPC> color , <SPC> lookup ) : <NL>          lookup [ color ] <SPC> = <SPC> VISITING <NL>          for <SPC> new_color <SPC> in <SPC> adj [ color ] : <NL>              if <SPC> ( <NL>                  new_color <SPC> not <SPC> in <SPC> lookup <SPC> and <SPC> has_cycle ( adj , <SPC> new_color , <SPC> lookup ) <NL>              ) <SPC> or <SPC> lookup [ new_color ] <SPC> == <SPC> VISITING : <NL>                  return <SPC> True <NL>          lookup [ color ] <SPC> = <SPC> VISITED <NL>          return <SPC> False <NL> <NL> <TAB> MAX_COLOR <SPC> = <SPC> 60 <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> color <SPC> in <SPC> xrange ( 1 , <SPC> MAX_COLOR <SPC> + <SPC> 1 ) : <NL>          min_r <SPC> = <SPC> len ( targetGrid ) <NL>          min_c <SPC> = <SPC> len ( targetGrid [ 0 ] ) <NL>          max_r <SPC> = <SPC> - 1 <NL>          max_c <SPC> = <SPC> - 1 <NL>          for <SPC> r <SPC> in <SPC> xrange ( len ( targetGrid ) ) : <NL>              for <SPC> c <SPC> in <SPC> xrange ( len ( targetGrid [ r ] ) ) : <NL>                  if <SPC> targetGrid [ r ] [ c ] <SPC> == <SPC> color : <NL>                      min_r <SPC> = <SPC> min ( min_r , <SPC> r ) <NL>                      min_c <SPC> = <SPC> min ( min_c , <SPC> c ) <NL>                      max_r <SPC> = <SPC> max ( max_r , <SPC> r ) <NL>                      max_c <SPC> = <SPC> max ( max_c , <SPC> c ) <NL>          for <SPC> r <SPC> in <SPC> xrange ( min_r , <SPC> max_r <SPC> + <SPC> 1 ) : <NL>              for <SPC> c <SPC> in <SPC> xrange ( min_c , <SPC> max_c <SPC> + <SPC> 1 ) : <NL>                  if <SPC> targetGrid [ r ] [ c ] <SPC> != <SPC> color : <NL>                      adj [ color ] . add ( targetGrid [ r ] [ c ] ) <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> return <SPC> all ( <NL>          color <SPC> in <SPC> lookup <SPC> or <SPC> not <SPC> has_cycle ( adj , <SPC> color , <SPC> lookup ) <NL>          for <SPC> color <SPC> in <SPC> xrange ( 1 , <SPC> MAX_COLOR <SPC> + <SPC> 1 ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> strangePrinter ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> dp ( s , <SPC> i , <SPC> j , <SPC> lookup ) : <NL>          if <SPC> i <SPC> > <SPC> j : <NL>              return <SPC> 0 <NL>          if <SPC> ( i , <SPC> j ) <SPC> not <SPC> in <SPC> lookup : <NL>              lookup [ ( i , <SPC> j ) ] <SPC> = <SPC> dp ( s , <SPC> i , <SPC> j <SPC> - <SPC> 1 , <SPC> lookup ) <SPC> + <SPC> 1 <NL>              for <SPC> k <SPC> in <SPC> xrange ( i , <SPC> j ) : <NL>                  if <SPC> s [ k ] <SPC> == <SPC> s [ j ] : <NL>                      lookup [ ( i , <SPC> j ) ] <SPC> = <SPC> min ( <NL>                          lookup [ ( i , <SPC> j ) ] , <NL>                          dp ( s , <SPC> i , <SPC> k , <SPC> lookup ) <SPC> + <SPC> dp ( s , <SPC> k <SPC> + <SPC> 1 , <SPC> j <SPC> - <SPC> 1 , <SPC> lookup ) , <NL>                      ) <NL>          return <SPC> lookup [ ( i , <SPC> j ) ] <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> return <SPC> dp ( s , <SPC> 0 , <SPC> len ( s ) <SPC> - <SPC> 1 , <SPC> lookup ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> AhoNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . children <SPC> = <SPC> collections . defaultdict ( AhoNode ) <NL> <TAB> self . indices <SPC> = <SPC> [ ] <NL> <TAB> self . suffix <SPC> = <SPC> None <NL> <TAB> self . output <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> AhoTrie ( object ) : <NL> <TAB> def <SPC> step ( self , <SPC> letter ) : <NL> <TAB> while <SPC> self . __node <SPC> and <SPC> letter <SPC> not <SPC> in <SPC> self . __node . children : <NL>          self . __node <SPC> = <SPC> self . __node . suffix <NL> <TAB> self . __node <SPC> = <SPC> self . __node . children [ letter ] <SPC> if <SPC> self . __node <SPC> else <SPC> self . __root <NL> <TAB> return <SPC> self . __get_ac_node_outputs ( self . __node ) <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> patterns ) : <NL> <TAB> self . __root <SPC> = <SPC> self . __create_ac_trie ( patterns ) <NL> <TAB> self . __node <SPC> = <SPC> self . __create_ac_suffix_and_output_links ( self . __root ) <NL> <NL> <TAB> def <SPC> __create_ac_trie ( self , <SPC> patterns ) : <NL> <TAB> root <SPC> = <SPC> AhoNode ( ) <NL> <TAB> for <SPC> i , <SPC> pattern <SPC> in <SPC> enumerate ( patterns ) : <NL>          node <SPC> = <SPC> root <NL>          for <SPC> c <SPC> in <SPC> pattern : <NL>              node <SPC> = <SPC> node . children [ c ] <NL>          node . indices . append ( i ) <NL> <TAB> return <SPC> root <NL> <NL> <TAB> def <SPC> __create_ac_suffix_and_output_links ( self , <SPC> root ) : <NL> <TAB> queue <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> node <SPC> in <SPC> root . children . itervalues ( ) : <NL>          queue . append ( node ) <NL>          node . suffix <SPC> = <SPC> root <NL> <NL> <TAB> while <SPC> queue : <NL>          node <SPC> = <SPC> queue . popleft ( ) <NL>          for <SPC> c , <SPC> child <SPC> in <SPC> node . children . iteritems ( ) : <NL>              queue . append ( child ) <NL>              suffix <SPC> = <SPC> node . suffix <NL>              while <SPC> suffix <SPC> and <SPC> c <SPC> not <SPC> in <SPC> suffix . children : <NL>                  suffix <SPC> = <SPC> suffix . suffix <NL>              child . suffix <SPC> = <SPC> suffix . children [ c ] <SPC> if <SPC> suffix <SPC> else <SPC> root <NL>              child . output <SPC> = <SPC> ( <NL>                  child . suffix <SPC> if <SPC> child . suffix . indices <SPC> else <SPC> child . suffix . output <NL>              ) <NL> <NL> <TAB> return <SPC> root <NL> <NL> <TAB> def <SPC> __get_ac_node_outputs ( <NL>          self , <SPC> node <NL> <TAB> ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> node . indices : <NL>          result . append ( i ) <NL> <NL> <TAB> output <SPC> = <SPC> node . output <NL> <TAB> while <SPC> output : <NL>          for <SPC> i <SPC> in <SPC> output . indices : <NL>              result . append ( i ) <NL> <NL>          output <SPC> = <SPC> output . output <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> StreamChecker ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> words ) : <NL> <NL> <TAB> self . __trie <SPC> = <SPC> AhoTrie ( words ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> letter ) : <NL> <NL> <TAB> return <SPC> len ( self . __trie . step ( letter ) ) <SPC> > <SPC> 0 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> AhoNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . children <SPC> = <SPC> collections . defaultdict ( AhoNode ) <NL> <TAB> self . suffix <SPC> = <SPC> None <NL> <TAB> self . outputs <SPC> = <SPC> [ ] <NL> <NL> <NL> class <SPC> AhoTrie ( object ) : <NL> <TAB> def <SPC> step ( self , <SPC> letter ) : <NL> <TAB> while <SPC> self . __node <SPC> and <SPC> letter <SPC> not <SPC> in <SPC> self . __node . children : <NL>          self . __node <SPC> = <SPC> self . __node . suffix <NL> <TAB> self . __node <SPC> = <SPC> self . __node . children [ letter ] <SPC> if <SPC> self . __node <SPC> else <SPC> self . __root <NL> <TAB> return <SPC> ( <NL>          self . __node . outputs <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> patterns ) : <NL> <TAB> self . __root <SPC> = <SPC> self . __create_ac_trie ( patterns ) <NL> <TAB> self . __node <SPC> = <SPC> self . __create_ac_suffix_and_output_links ( self . __root ) <NL> <NL> <TAB> def <SPC> __create_ac_trie ( self , <SPC> patterns ) : <NL> <TAB> root <SPC> = <SPC> AhoNode ( ) <NL> <TAB> for <SPC> i , <SPC> pattern <SPC> in <SPC> enumerate ( patterns ) : <NL>          node <SPC> = <SPC> root <NL>          for <SPC> c <SPC> in <SPC> pattern : <NL>              node <SPC> = <SPC> node . children [ c ] <NL>          node . outputs . append ( i ) <NL> <TAB> return <SPC> root <NL> <NL> <TAB> def <SPC> __create_ac_suffix_and_output_links ( <NL>          self , <SPC> root <NL> <TAB> ) : <NL> <TAB> queue <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> node <SPC> in <SPC> root . children . itervalues ( ) : <NL>          queue . append ( node ) <NL>          node . suffix <SPC> = <SPC> root <NL> <NL> <TAB> while <SPC> queue : <NL>          node <SPC> = <SPC> queue . popleft ( ) <NL>          for <SPC> c , <SPC> child <SPC> in <SPC> node . children . iteritems ( ) : <NL>              queue . append ( child ) <NL>              suffix <SPC> = <SPC> node . suffix <NL>              while <SPC> suffix <SPC> and <SPC> c <SPC> not <SPC> in <SPC> suffix . children : <NL>                  suffix <SPC> = <SPC> suffix . suffix <NL>              child . suffix <SPC> = <SPC> suffix . children [ c ] <SPC> if <SPC> suffix <SPC> else <SPC> root <NL>              child . outputs <SPC> += <SPC> child . suffix . outputs <NL> <NL> <TAB> return <SPC> root <NL> <NL> <NL> class <SPC> StreamChecker ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> words ) : <NL> <NL> <TAB> self . __trie <SPC> = <SPC> AhoTrie ( words ) <NL> <NL> <TAB> def <SPC> query ( self , <SPC> letter ) : <NL> <NL> <TAB> return <SPC> len ( self . __trie . step ( letter ) ) <SPC> > <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getLengthOfOptimalCompression ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> def <SPC> length ( cnt ) : <NL>          l <SPC> = <SPC> 2 <SPC> if <SPC> cnt <SPC> >= <SPC> 2 <SPC> else <SPC> 1 <NL>          while <SPC> cnt <SPC> >= <SPC> 10 : <NL>              l <SPC> += <SPC> 1 <NL>              cnt <SPC> //= <SPC> 10 <NL>          return <SPC> l <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ len ( s ) ] <SPC> * <SPC> ( k <SPC> + <SPC> 1 ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( s ) <SPC> + <SPC> 1 ) ] <NL> <TAB> dp [ 0 ] [ 0 ] <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( k <SPC> + <SPC> 1 ) : <NL>              if <SPC> i <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <SPC> and <SPC> j <SPC> - <SPC> 1 <SPC> >= <SPC> 0 : <NL>                  dp [ i ] [ j ] <SPC> = <SPC> min ( dp [ i ] [ j ] , <SPC> dp [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] ) <NL>              keep <SPC> = <SPC> delete <SPC> = <SPC> 0 <NL>              for <SPC> m <SPC> in <SPC> xrange ( i , <SPC> len ( s ) <SPC> + <SPC> 1 ) : <NL>                  if <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> s [ m <SPC> - <SPC> 1 ] : <NL>                      keep <SPC> += <SPC> 1 <NL>                  else : <NL>                      delete <SPC> += <SPC> 1 <NL>                  if <SPC> j <SPC> + <SPC> delete <SPC> <= <SPC> k : <NL>                      dp [ m ] [ j <SPC> + <SPC> delete ] <SPC> = <SPC> min ( <NL>                          dp [ m ] [ j <SPC> + <SPC> delete ] , <SPC> dp [ i <SPC> - <SPC> 1 ] [ j ] <SPC> + <SPC> length ( keep ) <NL>                      ) <NL> <TAB> return <SPC> dp [ len ( s ) ] [ k ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> compress ( self , <SPC> chars ) : <NL> <NL> <TAB> anchor , <SPC> write <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> read , <SPC> c <SPC> in <SPC> enumerate ( chars ) : <NL>          if <SPC> read <SPC> + <SPC> 1 <SPC> == <SPC> len ( chars ) <SPC> or <SPC> chars [ read <SPC> + <SPC> 1 ] <SPC> != <SPC> c : <NL>              chars [ write ] <SPC> = <SPC> chars [ anchor ] <NL>              write <SPC> += <SPC> 1 <NL>              if <SPC> read <SPC> > <SPC> anchor : <NL>                  n , <SPC> left <SPC> = <SPC> read <SPC> - <SPC> anchor <SPC> + <SPC> 1 , <SPC> write <NL>                  while <SPC> n <SPC> > <SPC> 0 : <NL>                      chars [ write ] <SPC> = <SPC> chr ( n <SPC> % <SPC> 10 <SPC> + <SPC> ord ( "0" ) ) <NL>                      write <SPC> += <SPC> 1 <NL>                      n <SPC> /= <SPC> 10 <NL>                  right <SPC> = <SPC> write <SPC> - <SPC> 1 <NL>                  while <SPC> left <SPC> < <SPC> right : <NL>                      chars [ left ] , <SPC> chars [ right ] <SPC> = <SPC> chars [ right ] , <SPC> chars [ left ] <NL>                      left <SPC> += <SPC> 1 <NL>                      right <SPC> -= <SPC> 1 <NL>              anchor <SPC> = <SPC> read <SPC> + <SPC> 1 <NL> <TAB> return <SPC> write <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> AhoNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . children <SPC> = <SPC> collections . defaultdict ( AhoNode ) <NL> <TAB> self . indices <SPC> = <SPC> [ ] <NL> <TAB> self . suffix <SPC> = <SPC> None <NL> <TAB> self . output <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> AhoTrie ( object ) : <NL> <TAB> def <SPC> step ( self , <SPC> letter ) : <NL> <TAB> while <SPC> self . __node <SPC> and <SPC> letter <SPC> not <SPC> in <SPC> self . __node . children : <NL>          self . __node <SPC> = <SPC> self . __node . suffix <NL> <TAB> self . __node <SPC> = <SPC> self . __node . children [ letter ] <SPC> if <SPC> self . __node <SPC> else <SPC> self . __root <NL> <TAB> return <SPC> self . __get_ac_node_outputs ( self . __node ) <NL> <NL> <TAB> def <SPC> reset ( self ) : <NL> <TAB> self . __node <SPC> = <SPC> self . __root <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> patterns ) : <NL> <TAB> self . __root <SPC> = <SPC> self . __create_ac_trie ( patterns ) <NL> <TAB> self . __node <SPC> = <SPC> self . __create_ac_suffix_and_output_links ( self . __root ) <NL> <NL> <TAB> def <SPC> __create_ac_trie ( self , <SPC> patterns ) : <NL> <TAB> root <SPC> = <SPC> AhoNode ( ) <NL> <TAB> for <SPC> i , <SPC> pattern <SPC> in <SPC> enumerate ( patterns ) : <NL>          node <SPC> = <SPC> root <NL>          for <SPC> c <SPC> in <SPC> pattern : <NL>              node <SPC> = <SPC> node . children [ c ] <NL>          node . indices . append ( i ) <NL> <TAB> return <SPC> root <NL> <NL> <TAB> def <SPC> __create_ac_suffix_and_output_links ( self , <SPC> root ) : <NL> <TAB> queue <SPC> = <SPC> collections . deque ( ) <NL> <TAB> for <SPC> node <SPC> in <SPC> root . children . itervalues ( ) : <NL>          queue . append ( node ) <NL>          node . suffix <SPC> = <SPC> root <NL> <NL> <TAB> while <SPC> queue : <NL>          node <SPC> = <SPC> queue . popleft ( ) <NL>          for <SPC> c , <SPC> child <SPC> in <SPC> node . children . iteritems ( ) : <NL>              queue . append ( child ) <NL>              suffix <SPC> = <SPC> node . suffix <NL>              while <SPC> suffix <SPC> and <SPC> c <SPC> not <SPC> in <SPC> suffix . children : <NL>                  suffix <SPC> = <SPC> suffix . suffix <NL>              child . suffix <SPC> = <SPC> suffix . children [ c ] <SPC> if <SPC> suffix <SPC> else <SPC> root <NL>              child . output <SPC> = <SPC> ( <NL>                  child . suffix <SPC> if <SPC> child . suffix . indices <SPC> else <SPC> child . suffix . output <NL>              ) <NL> <NL> <TAB> return <SPC> root <NL> <NL> <TAB> def <SPC> __get_ac_node_outputs ( self , <SPC> node ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> node . indices : <NL>          result . append ( i ) <NL> <TAB> output <SPC> = <SPC> node . output <NL> <TAB> while <SPC> output : <NL>          for <SPC> i <SPC> in <SPC> output . indices : <NL>              result . append ( i ) <NL>          output <SPC> = <SPC> output . output <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> stringMatching ( self , <SPC> words ) : <NL> <NL> <TAB> trie <SPC> = <SPC> AhoTrie ( words ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) ) : <NL>          trie . reset ( ) <NL>          for <SPC> c <SPC> in <SPC> words [ i ] : <NL>              for <SPC> j <SPC> in <SPC> trie . step ( c ) : <NL>                  if <SPC> j <SPC> != <SPC> i : <NL>                      lookup . add ( j ) <NL> <TAB> return <SPC> [ words [ i ] <SPC> for <SPC> i <SPC> in <SPC> lookup ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> stringMatching ( self , <SPC> words ) : <NL> <NL> <TAB> def <SPC> getPrefix ( pattern ) : <NL>          prefix <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( pattern ) <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( pattern ) ) : <NL>              while <SPC> j <SPC> != <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> pattern [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> pattern [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              prefix [ i ] <SPC> = <SPC> j <NL>          return <SPC> prefix <NL> <NL> <TAB> def <SPC> kmp ( text , <SPC> pattern , <SPC> prefix ) : <NL>          if <SPC> not <SPC> pattern : <NL>              return <SPC> 0 <NL>          if <SPC> len ( text ) <SPC> < <SPC> len ( pattern ) : <NL>              return <SPC> - 1 <NL>          j <SPC> = <SPC> - 1 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( text ) ) : <NL>              while <SPC> j <SPC> != <SPC> - 1 <SPC> and <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> != <SPC> text [ i ] : <NL>                  j <SPC> = <SPC> prefix [ j ] <NL>              if <SPC> pattern [ j <SPC> + <SPC> 1 ] <SPC> == <SPC> text [ i ] : <NL>                  j <SPC> += <SPC> 1 <NL>              if <SPC> j <SPC> + <SPC> 1 <SPC> == <SPC> len ( pattern ) : <NL>                  return <SPC> i <SPC> - <SPC> j <NL>          return <SPC> - 1 <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> pattern <SPC> in <SPC> enumerate ( words ) : <NL>          prefix <SPC> = <SPC> getPrefix ( pattern ) <NL>          for <SPC> j , <SPC> text <SPC> in <SPC> enumerate ( words ) : <NL>              if <SPC> i <SPC> != <SPC> j <SPC> and <SPC> kmp ( text , <SPC> pattern , <SPC> prefix ) <SPC> != <SPC> - 1 : <NL>                  result . append ( pattern ) <NL>                  break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> stringMatching ( self , <SPC> words ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> pattern <SPC> in <SPC> enumerate ( words ) : <NL>          for <SPC> j , <SPC> text <SPC> in <SPC> enumerate ( words ) : <NL>              if <SPC> i <SPC> != <SPC> j <SPC> and <SPC> pattern <SPC> in <SPC> text : <NL>                  result . append ( pattern ) <NL>                  break <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> myAtoi ( self , <SPC> str ) : <NL> <NL> <TAB> INT_MAX <SPC> = <SPC> 2147483647 <NL> <TAB> INT_MIN <SPC> = <SPC> - 2147483648 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <NL> <TAB> if <SPC> not <SPC> str : <NL>          return <SPC> result <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( str ) <SPC> and <SPC> str [ i ] . isspace ( ) : <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> if <SPC> len ( str ) <SPC> == <SPC> i : <NL>          return <SPC> result <NL> <NL> <TAB> sign <SPC> = <SPC> 1 <NL> <TAB> if <SPC> str [ i ] <SPC> == <SPC> "+" : <NL>          i <SPC> += <SPC> 1 <NL> <TAB> elif <SPC> str [ i ] <SPC> == <SPC> "-" : <NL>          sign <SPC> = <SPC> - 1 <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( str ) <SPC> and <SPC> "0" <SPC> <= <SPC> str [ i ] <SPC> <= <SPC> "9" : <NL>          if <SPC> result <SPC> > <SPC> ( INT_MAX <SPC> - <SPC> int ( str [ i ] ) ) <SPC> / <SPC> 10 : <NL>              return <SPC> INT_MAX <SPC> if <SPC> sign <SPC> > <SPC> 0 <SPC> else <SPC> INT_MIN <NL>          result <SPC> = <SPC> result <SPC> * <SPC> 10 <SPC> + <SPC> int ( str [ i ] ) <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> sign <SPC> * <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canConvert ( self , <SPC> str1 , <SPC> str2 ) : <NL> <NL> <TAB> if <SPC> str1 <SPC> == <SPC> str2 : <NL>          return <SPC> True <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> j <SPC> in <SPC> itertools . izip ( str1 , <SPC> str2 ) : <NL>          if <SPC> lookup . setdefault ( i , <SPC> j ) <SPC> != <SPC> j : <NL>              return <SPC> False <NL> <TAB> return <SPC> len ( set ( str2 ) ) <SPC> < <SPC> 26 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> strWithout3a3b ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> put_A <SPC> = <SPC> None <NL> <TAB> while <SPC> A <SPC> or <SPC> B : <NL>          if <SPC> len ( result ) <SPC> >= <SPC> 2 <SPC> and <SPC> result [ - 1 ] <SPC> == <SPC> result [ - 2 ] : <NL>              put_A <SPC> = <SPC> result [ - 1 ] <SPC> == <SPC> "b" <NL>          else : <NL>              put_A <SPC> = <SPC> A <SPC> >= <SPC> B <NL> <NL>          if <SPC> put_A : <NL>              A <SPC> -= <SPC> 1 <NL>              result . append ( "a" ) <NL>          else : <NL>              B <SPC> -= <SPC> 1 <NL>              result . append ( "b" ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> differByOne ( self , <SPC> dict ) : <NL> <NL> <TAB> MOD , <SPC> P <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 , <SPC> 113 <NL> <NL> <TAB> hashes <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( dict ) <NL> <TAB> for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( dict ) : <NL>          for <SPC> c <SPC> in <SPC> word : <NL>              hashes [ i ] <SPC> = <SPC> ( P <SPC> * <SPC> hashes [ i ] <SPC> + <SPC> ( ord ( c ) <SPC> - <SPC> ord ( "a" ) ) ) <SPC> % <SPC> MOD <NL> <NL> <TAB> base <SPC> = <SPC> 1 <NL> <TAB> for <SPC> p <SPC> in <SPC> reversed ( xrange ( len ( dict [ 0 ] ) ) ) : <NL>          lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL>          for <SPC> i , <SPC> word <SPC> in <SPC> enumerate ( dict ) : <NL>              new_hash <SPC> = <SPC> ( hashes [ i ] <SPC> - <SPC> base <SPC> * <SPC> ( ord ( word [ p ] ) <SPC> - <SPC> ord ( "a" ) ) ) <SPC> % <SPC> MOD <NL>              if <SPC> new_hash <SPC> in <SPC> lookup : <NL>                  for <SPC> j <SPC> in <SPC> lookup [ new_hash ] : <NL>                      if <SPC> dict [ j ] [ : p ] <SPC> + <SPC> dict [ j ] [ p <SPC> + <SPC> 1 : ] <SPC> == <SPC> word [ : p ] <SPC> + <SPC> word [ p <SPC> + <SPC> 1 : ] : <NL>                          return <SPC> True <NL>              lookup [ new_hash ] . append ( i ) <NL>          base <SPC> = <SPC> P <SPC> * <SPC> base <SPC> % <SPC> MOD <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findStrobogrammatic ( self , <SPC> n ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { "0" : <SPC> "0" , <SPC> "1" : <SPC> "1" , <SPC> "6" : <SPC> "9" , <SPC> "8" : <SPC> "8" , <SPC> "9" : <SPC> "6" } <NL> <TAB> result <SPC> = <SPC> [ "0" , <SPC> "1" , <SPC> "8" ] <SPC> if <SPC> n <SPC> % <SPC> 2 <SPC> else <SPC> [ "" ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n <SPC> % <SPC> 2 , <SPC> n , <SPC> 2 ) : <NL>          result <SPC> = <SPC> [ <NL>              a <SPC> + <SPC> num <SPC> + <SPC> b <NL>              for <SPC> a , <SPC> b <SPC> in <SPC> lookup . iteritems ( ) <NL>              if <SPC> i <SPC> != <SPC> n <SPC> - <SPC> 2 <SPC> or <SPC> a <SPC> != <SPC> "0" <NL>              for <SPC> num <SPC> in <SPC> result <NL>          ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findStrobogrammatic ( self , <SPC> n ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { "0" : <SPC> "0" , <SPC> "1" : <SPC> "1" , <SPC> "6" : <SPC> "9" , <SPC> "8" : <SPC> "8" , <SPC> "9" : <SPC> "6" } <NL> <NL> <TAB> def <SPC> findStrobogrammaticRecu ( n , <SPC> k ) : <NL>          if <SPC> k <SPC> == <SPC> 0 : <NL>              return <SPC> [ "" ] <NL>          elif <SPC> k <SPC> == <SPC> 1 : <NL>              return <SPC> [ "0" , <SPC> "1" , <SPC> "8" ] <NL>          result <SPC> = <SPC> [ ] <NL>          for <SPC> num <SPC> in <SPC> findStrobogrammaticRecu ( n , <SPC> k <SPC> - <SPC> 2 ) : <NL>              for <SPC> key , <SPC> val <SPC> in <SPC> lookup . iteritems ( ) : <NL>                  if <SPC> n <SPC> != <SPC> k <SPC> or <SPC> key <SPC> != <SPC> "0" : <NL>                      result . append ( key <SPC> + <SPC> num <SPC> + <SPC> val ) <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> findStrobogrammaticRecu ( n , <SPC> n ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> lookup <SPC> = <SPC> { "0" : <SPC> "0" , <SPC> "1" : <SPC> "1" , <SPC> "6" : <SPC> "9" , <SPC> "8" : <SPC> "8" , <SPC> "9" : <SPC> "6" } <NL> <TAB> cache <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> strobogrammaticInRange ( self , <SPC> low , <SPC> high ) : <NL> <TAB> count <SPC> = <SPC> ( <NL>          self . countStrobogrammaticUntil ( high , <SPC> False ) <NL>          - <SPC> self . countStrobogrammaticUntil ( low , <SPC> False ) <NL>          + <SPC> self . isStrobogrammatic ( low ) <NL> <TAB> ) <NL> <TAB> return <SPC> count <SPC> if <SPC> count <SPC> >= <SPC> 0 <SPC> else <SPC> 0 <NL> <NL> <TAB> def <SPC> countStrobogrammaticUntil ( self , <SPC> num , <SPC> can_start_with_0 ) : <NL> <TAB> if <SPC> can_start_with_0 <SPC> and <SPC> num <SPC> in <SPC> self . cache : <NL>          return <SPC> self . cache [ num ] <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> if <SPC> len ( num ) <SPC> == <SPC> 1 : <NL>          for <SPC> c <SPC> in <SPC> [ "0" , <SPC> "1" , <SPC> "8" ] : <NL>              if <SPC> num [ 0 ] <SPC> >= <SPC> c : <NL>                  count <SPC> += <SPC> 1 <NL>          self . cache [ num ] <SPC> = <SPC> count <NL>          return <SPC> count <NL> <NL> <TAB> for <SPC> key , <SPC> val <SPC> in <SPC> self . lookup . iteritems ( ) : <NL>          if <SPC> can_start_with_0 <SPC> or <SPC> key <SPC> != <SPC> "0" : <NL>              if <SPC> num [ 0 ] <SPC> > <SPC> key : <NL>                  if <SPC> len ( num ) <SPC> == <SPC> 2 : <NL>                      count <SPC> += <SPC> 1 <NL>                  else : <NL>                      count <SPC> += <SPC> self . countStrobogrammaticUntil ( <NL>                          "9" <SPC> * <SPC> ( len ( num ) <SPC> - <SPC> 2 ) , <SPC> True <NL>                      ) <NL>              elif <SPC> num [ 0 ] <SPC> == <SPC> key : <NL>                  if <SPC> len ( num ) <SPC> == <SPC> 2 : <NL>                      if <SPC> num [ - 1 ] <SPC> >= <SPC> val : <NL>                          count <SPC> += <SPC> 1 <NL>                  else : <NL>                      if <SPC> num [ - 1 ] <SPC> >= <SPC> val : <NL>                          count <SPC> += <SPC> self . countStrobogrammaticUntil ( <NL>                              self . getMid ( num ) , <SPC> True <NL>                          ) <NL>                      elif <SPC> self . getMid ( num ) <SPC> != <SPC> "0" <SPC> * <SPC> ( <NL>                          len ( num ) <SPC> - <SPC> 2 <NL>                      ) : <NL>                          count <SPC> += <SPC> self . countStrobogrammaticUntil ( <NL>                              self . getMid ( num ) , <SPC> True <NL>                          ) <SPC> - <SPC> self . isStrobogrammatic ( self . getMid ( num ) ) <NL> <NL> <TAB> if <SPC> not <SPC> can_start_with_0 : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( num ) <SPC> - <SPC> 1 , <SPC> 0 , <SPC> - 1 ) : <NL>              count <SPC> += <SPC> self . countStrobogrammaticByLength ( i ) <NL> <TAB> else : <NL>          self . cache [ num ] <SPC> = <SPC> count <NL> <NL> <TAB> return <SPC> count <NL> <NL> <TAB> def <SPC> getMid ( self , <SPC> num ) : <NL> <TAB> return <SPC> num [ 1 : <SPC> len ( num ) <SPC> - <SPC> 1 ] <NL> <NL> <TAB> def <SPC> countStrobogrammaticByLength ( self , <SPC> n ) : <NL> <TAB> if <SPC> n <SPC> == <SPC> 1 : <NL>          return <SPC> 3 <NL> <TAB> elif <SPC> n <SPC> == <SPC> 2 : <NL>          return <SPC> 4 <NL> <TAB> elif <SPC> n <SPC> == <SPC> 3 : <NL>          return <SPC> 4 <SPC> * <SPC> 3 <NL> <TAB> else : <NL>          return <SPC> 5 <SPC> * <SPC> self . countStrobogrammaticByLength ( n <SPC> - <SPC> 2 ) <NL> <NL> <TAB> def <SPC> isStrobogrammatic ( self , <SPC> num ) : <NL> <TAB> n <SPC> = <SPC> len ( num ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( ( n <SPC> + <SPC> 1 ) <SPC> / <SPC> 2 ) : <NL>          if <SPC> ( <NL>              num [ n <SPC> - <SPC> 1 <SPC> - <SPC> i ] <SPC> not <SPC> in <SPC> self . lookup <NL>              or <SPC> num [ i ] <SPC> != <SPC> self . lookup [ num [ n <SPC> - <SPC> 1 <SPC> - <SPC> i ] ] <NL>          ) : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> lookup <SPC> = <SPC> { "0" : <SPC> "0" , <SPC> "1" : <SPC> "1" , <SPC> "6" : <SPC> "9" , <SPC> "8" : <SPC> "8" , <SPC> "9" : <SPC> "6" } <NL> <NL> <TAB> def <SPC> isStrobogrammatic ( self , <SPC> num ) : <NL> <TAB> n <SPC> = <SPC> len ( num ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( ( n <SPC> + <SPC> 1 ) <SPC> / <SPC> 2 ) : <NL>          if <SPC> ( <NL>              num [ n <SPC> - <SPC> 1 <SPC> - <SPC> i ] <SPC> not <SPC> in <SPC> self . lookup <NL>              or <SPC> num [ i ] <SPC> != <SPC> self . lookup [ num [ n <SPC> - <SPC> 1 <SPC> - <SPC> i ] ] <NL>          ) : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> strongPasswordChecker ( self , <SPC> s ) : <NL> <NL> <TAB> missing_type_cnt <SPC> = <SPC> 3 <NL> <TAB> if <SPC> any ( "a" <SPC> <= <SPC> c <SPC> <= <SPC> "z" <SPC> for <SPC> c <SPC> in <SPC> s ) : <NL>          missing_type_cnt <SPC> -= <SPC> 1 <NL> <TAB> if <SPC> any ( "A" <SPC> <= <SPC> c <SPC> <= <SPC> "Z" <SPC> for <SPC> c <SPC> in <SPC> s ) : <NL>          missing_type_cnt <SPC> -= <SPC> 1 <NL> <TAB> if <SPC> any ( c . isdigit ( ) <SPC> for <SPC> c <SPC> in <SPC> s ) : <NL>          missing_type_cnt <SPC> -= <SPC> 1 <NL> <NL> <TAB> total_change_cnt <SPC> = <SPC> 0 <NL> <TAB> one_change_cnt , <SPC> two_change_cnt , <SPC> three_change_cnt <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> i <SPC> = <SPC> 2 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( s ) : <NL>          if <SPC> s [ i ] <SPC> == <SPC> s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> s [ i <SPC> - <SPC> 2 ] : <NL>              length <SPC> = <SPC> 2 <NL>              while <SPC> i <SPC> < <SPC> len ( s ) <SPC> and <SPC> s [ i ] <SPC> == <SPC> s [ i <SPC> - <SPC> 1 ] : <NL>                  length <SPC> += <SPC> 1 <NL>                  i <SPC> += <SPC> 1 <NL> <NL>              total_change_cnt <SPC> += <SPC> length <SPC> / <SPC> 3 <NL>              if <SPC> length <SPC> % <SPC> 3 <SPC> == <SPC> 0 : <NL>                  one_change_cnt <SPC> += <SPC> 1 <NL>              elif <SPC> length <SPC> % <SPC> 3 <SPC> == <SPC> 1 : <NL>                  two_change_cnt <SPC> += <SPC> 1 <NL>              else : <NL>                  three_change_cnt <SPC> += <SPC> 1 <NL>          else : <NL>              i <SPC> += <SPC> 1 <NL> <NL> <TAB> if <SPC> len ( s ) <SPC> < <SPC> 6 : <NL>          return <SPC> max ( missing_type_cnt , <SPC> 6 <SPC> - <SPC> len ( s ) ) <NL> <TAB> elif <SPC> len ( s ) <SPC> <= <SPC> 20 : <NL>          return <SPC> max ( missing_type_cnt , <SPC> total_change_cnt ) <NL> <TAB> else : <NL>          delete_cnt <SPC> = <SPC> len ( s ) <SPC> - <SPC> 20 <NL> <NL>          total_change_cnt <SPC> -= <SPC> min ( delete_cnt , <SPC> one_change_cnt <SPC> * <SPC> 1 ) <SPC> / <SPC> 1 <NL>          total_change_cnt <SPC> -= <SPC> ( <NL>              min ( max ( delete_cnt <SPC> - <SPC> one_change_cnt , <SPC> 0 ) , <SPC> two_change_cnt <SPC> * <SPC> 2 ) <SPC> / <SPC> 2 <NL>          ) <NL>          total_change_cnt <SPC> -= <SPC> ( <NL>              min ( <NL>                  max ( delete_cnt <SPC> - <SPC> one_change_cnt <SPC> - <SPC> 2 <SPC> * <SPC> two_change_cnt , <SPC> 0 ) , <NL>                  three_change_cnt <SPC> * <SPC> 3 , <NL>              ) <NL>              / <SPC> 3 <NL>          ) <NL> <NL>          return <SPC> delete_cnt <SPC> + <SPC> max ( missing_type_cnt , <SPC> total_change_cnt ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkRecord ( self , <SPC> s ) : <NL> <NL> <TAB> count_A <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          if <SPC> s [ i ] <SPC> == <SPC> "A" : <NL>              count_A <SPC> += <SPC> 1 <NL>              if <SPC> count_A <SPC> == <SPC> 2 : <NL>                  return <SPC> False <NL>          if <SPC> i <SPC> < <SPC> len ( s ) <SPC> - <SPC> 2 <SPC> and <SPC> s [ i ] <SPC> == <SPC> s [ i <SPC> + <SPC> 1 ] <SPC> == <SPC> s [ i <SPC> + <SPC> 2 ] <SPC> == <SPC> "L" : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkRecord ( self , <SPC> n ) : <NL> <NL> <TAB> M <SPC> = <SPC> 1000000007 <NL> <TAB> a0l0 , <SPC> a0l1 , <SPC> a0l2 , <SPC> a1l0 , <SPC> a1l1 , <SPC> a1l2 <SPC> = <SPC> 1 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n <SPC> + <SPC> 1 ) : <NL>          a0l2 , <SPC> a0l1 , <SPC> a0l0 <SPC> = <SPC> a0l1 , <SPC> a0l0 , <SPC> ( a0l0 <SPC> + <SPC> a0l1 <SPC> + <SPC> a0l2 ) <SPC> % <SPC> M <NL>          a1l2 , <SPC> a1l1 , <SPC> a1l0 <SPC> = <SPC> a1l1 , <SPC> a1l0 , <SPC> ( a0l0 <SPC> + <SPC> a1l0 <SPC> + <SPC> a1l1 <SPC> + <SPC> a1l2 ) <SPC> % <SPC> M <NL> <TAB> return <SPC> a1l0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numSubarrayProductLessThanK ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> if <SPC> k <SPC> <= <SPC> 1 : <NL>          return <SPC> 0 <NL> <TAB> result , <SPC> start , <SPC> prod <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 1 <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          prod <SPC> *= <SPC> num <NL>          while <SPC> prod <SPC> >= <SPC> k : <NL>              prod <SPC> /= <SPC> nums [ start ] <NL>              start <SPC> += <SPC> 1 <NL>          result <SPC> += <SPC> i <SPC> - <SPC> start <SPC> + <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> subarraySum ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> accumulated_sum <SPC> = <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> lookup [ 0 ] <SPC> += <SPC> 1 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          accumulated_sum <SPC> += <SPC> num <NL>          result <SPC> += <SPC> lookup [ accumulated_sum <SPC> - <SPC> k ] <NL>          lookup [ accumulated_sum ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> subarraysDivByK ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> count [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> result , <SPC> prefix <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> a <SPC> in <SPC> A : <NL>          prefix <SPC> = <SPC> ( prefix <SPC> + <SPC> a ) <SPC> % <SPC> K <NL>          result <SPC> += <SPC> count [ prefix ] <NL>          count [ prefix ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> subarraysWithKDistinct ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> def <SPC> atMostK ( A , <SPC> K ) : <NL>          count <SPC> = <SPC> collections . defaultdict ( int ) <NL>          result , <SPC> left <SPC> = <SPC> 0 , <SPC> 0 <NL>          for <SPC> right <SPC> in <SPC> xrange ( len ( A ) ) : <NL>              count [ A [ right ] ] <SPC> += <SPC> 1 <NL>              while <SPC> len ( count ) <SPC> > <SPC> K : <NL>                  count [ A [ left ] ] <SPC> -= <SPC> 1 <NL>                  if <SPC> count [ A [ left ] ] <SPC> == <SPC> 0 : <NL>                      count . pop ( A [ left ] ) <NL>                  left <SPC> += <SPC> 1 <NL>              result <SPC> += <SPC> right <SPC> - <SPC> left <SPC> + <SPC> 1 <NL>          return <SPC> result <NL> <NL> <TAB> return <SPC> atMostK ( A , <SPC> K ) <SPC> - <SPC> atMostK ( A , <SPC> K <SPC> - <SPC> 1 ) <NL> <NL> <NL> class <SPC> Window ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __count <SPC> = <SPC> collections . defaultdict ( int ) <NL> <NL> <TAB> def <SPC> add ( self , <SPC> x ) : <NL> <TAB> self . __count [ x ] <SPC> += <SPC> 1 <NL> <NL> <TAB> def <SPC> remove ( self , <SPC> x ) : <NL> <TAB> self . __count [ x ] <SPC> -= <SPC> 1 <NL> <TAB> if <SPC> self . __count [ x ] <SPC> == <SPC> 0 : <NL>          self . __count . pop ( x ) <NL> <NL> <TAB> def <SPC> size ( self ) : <NL> <TAB> return <SPC> len ( self . __count ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> subarraysWithKDistinct ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> window1 , <SPC> window2 <SPC> = <SPC> Window ( ) , <SPC> Window ( ) <NL> <TAB> result , <SPC> left1 , <SPC> left2 <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> A : <NL>          window1 . add ( i ) <NL>          while <SPC> window1 . size ( ) <SPC> > <SPC> K : <NL>              window1 . remove ( A [ left1 ] ) <NL>              left1 <SPC> += <SPC> 1 <NL>          window2 . add ( i ) <NL>          while <SPC> window2 . size ( ) <SPC> >= <SPC> K : <NL>              window2 . remove ( A [ left2 ] ) <NL>              left2 <SPC> += <SPC> 1 <NL>          result <SPC> += <SPC> left2 <SPC> - <SPC> left1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> subdomainVisits ( self , <SPC> cpdomains ) : <NL> <NL> <TAB> result <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> domain <SPC> in <SPC> cpdomains : <NL>          count , <SPC> domain <SPC> = <SPC> domain . split ( ) <NL>          count <SPC> = <SPC> int ( count ) <NL>          frags <SPC> = <SPC> domain . split ( "." ) <NL>          curr <SPC> = <SPC> [ ] <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( frags ) ) ) : <NL>              curr . append ( frags [ i ] ) <NL>              result [ "." . join ( reversed ( curr ) ) ] <SPC> += <SPC> count <NL> <NL> <TAB> return <SPC> [ "{} {}" . format ( count , <SPC> domain ) <SPC> for <SPC> domain , <SPC> count <SPC> in <SPC> result . iteritems ( ) ] <NL> <NL> <NL> class <SPC> SubrectangleQueries ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> rectangle ) : <NL> <NL> <TAB> self . __rectangle <SPC> = <SPC> rectangle <NL> <TAB> self . __updates <SPC> = <SPC> [ ] <NL> <NL> <TAB> def <SPC> updateSubrectangle ( self , <SPC> row1 , <SPC> col1 , <SPC> row2 , <SPC> col2 , <SPC> newValue ) : <NL> <NL> <TAB> self . __updates . append ( ( row1 , <SPC> col1 , <SPC> row2 , <SPC> col2 , <SPC> newValue ) ) <NL> <NL> <TAB> def <SPC> getValue ( self , <SPC> row , <SPC> col ) : <NL> <NL> <TAB> for <SPC> ( row1 , <SPC> col1 , <SPC> row2 , <SPC> col2 , <SPC> newValue ) <SPC> in <SPC> reversed ( self . __updates ) : <NL>          if <SPC> row1 <SPC> <= <SPC> row <SPC> <= <SPC> row2 <SPC> and <SPC> col1 <SPC> <= <SPC> col <SPC> <= <SPC> col2 : <NL>              return <SPC> newValue <NL> <TAB> return <SPC> self . __rectangle [ row ] [ col ] <NL> <NL> <NL> class <SPC> SubrectangleQueries2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> rectangle ) : <NL> <NL> <TAB> self . __rectangle <SPC> = <SPC> rectangle <NL> <NL> <TAB> def <SPC> updateSubrectangle ( self , <SPC> row1 , <SPC> col1 , <SPC> row2 , <SPC> col2 , <SPC> newValue ) : <NL> <NL> <TAB> for <SPC> r <SPC> in <SPC> xrange ( row1 , <SPC> row2 <SPC> + <SPC> 1 ) : <NL>          for <SPC> c <SPC> in <SPC> xrange ( col1 , <SPC> col2 <SPC> + <SPC> 1 ) : <NL>              self . __rectangle [ r ] [ c ] <SPC> = <SPC> newValue <NL> <NL> <TAB> def <SPC> getValue ( self , <SPC> row , <SPC> col ) : <NL> <NL> <TAB> return <SPC> self . __rectangle [ row ] [ col ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> subsetsWithDup ( self , <SPC> nums ) : <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> result <SPC> = <SPC> [ [ ] ] <NL> <TAB> previous_size <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          size <SPC> = <SPC> len ( result ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( size ) : <NL> <NL>              if <SPC> i <SPC> == <SPC> 0 <SPC> or <SPC> nums [ i ] <SPC> != <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> or <SPC> j <SPC> >= <SPC> previous_size : <NL>                  result . append ( list ( result [ j ] ) ) <NL>                  result [ - 1 ] . append ( nums [ i ] ) <NL>          previous_size <SPC> = <SPC> size <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> subsetsWithDup ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i , <SPC> count <SPC> = <SPC> 0 , <SPC> 1 <SPC> << <SPC> len ( nums ) <NL> <TAB> nums . sort ( ) <NL> <NL> <TAB> while <SPC> i <SPC> < <SPC> count : <NL>          cur <SPC> = <SPC> [ ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>              if <SPC> i <SPC> & <SPC> 1 <SPC> << <SPC> j : <NL>                  cur . append ( nums [ j ] ) <NL>          if <SPC> cur <SPC> not <SPC> in <SPC> result : <NL>              result . append ( cur ) <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> subsetsWithDup ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> self . subsetsWithDupRecu ( result , <SPC> [ ] , <SPC> sorted ( nums ) ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> subsetsWithDupRecu ( self , <SPC> result , <SPC> cur , <SPC> nums ) : <NL> <TAB> if <SPC> not <SPC> nums : <NL>          if <SPC> cur <SPC> not <SPC> in <SPC> result : <NL>              result . append ( cur ) <NL> <TAB> else : <NL>          self . subsetsWithDupRecu ( result , <SPC> cur , <SPC> nums [ 1 : ] ) <NL>          self . subsetsWithDupRecu ( result , <SPC> cur <SPC> + <SPC> [ nums [ 0 ] ] , <SPC> nums [ 1 : ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> subsets ( self , <SPC> nums ) : <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> result <SPC> = <SPC> [ [ ] ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          size <SPC> = <SPC> len ( result ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( size ) : <NL>              result . append ( list ( result [ j ] ) ) <NL>              result [ - 1 ] . append ( nums [ i ] ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> subsets ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i , <SPC> count <SPC> = <SPC> 0 , <SPC> 1 <SPC> << <SPC> len ( nums ) <NL> <TAB> nums . sort ( ) <NL> <NL> <TAB> while <SPC> i <SPC> < <SPC> count : <NL>          cur <SPC> = <SPC> [ ] <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>              if <SPC> i <SPC> & <SPC> 1 <SPC> << <SPC> j : <NL>                  cur . append ( nums [ j ] ) <NL>          result . append ( cur ) <NL>          i <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> subsets ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> self . subsetsRecu ( [ ] , <SPC> sorted ( nums ) ) <NL> <NL> <TAB> def <SPC> subsetsRecu ( self , <SPC> cur , <SPC> nums ) : <NL> <TAB> if <SPC> not <SPC> nums : <NL>          return <SPC> [ cur ] <NL> <NL> <TAB> return <SPC> self . subsetsRecu ( cur , <SPC> nums [ 1 : ] ) <SPC> + <SPC> self . subsetsRecu ( <NL>          cur <SPC> + <SPC> [ nums [ 0 ] ] , <SPC> nums [ 1 : ] <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findSubstring ( self , <SPC> s , <SPC> words ) : <NL> <NL> <TAB> if <SPC> not <SPC> words : <NL>          return <SPC> [ ] <NL> <NL> <TAB> result , <SPC> m , <SPC> n , <SPC> k <SPC> = <SPC> [ ] , <SPC> len ( s ) , <SPC> len ( words ) , <SPC> len ( words [ 0 ] ) <NL> <TAB> if <SPC> m <SPC> < <SPC> n <SPC> * <SPC> k : <NL>          return <SPC> result <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> i <SPC> in <SPC> words : <NL>          lookup [ i ] <SPC> += <SPC> 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k ) : <NL>          left , <SPC> count <SPC> = <SPC> i , <SPC> 0 <NL>          tmp <SPC> = <SPC> collections . defaultdict ( int ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> m <SPC> - <SPC> k <SPC> + <SPC> 1 , <SPC> k ) : <NL>              s1 <SPC> = <SPC> s [ j : <SPC> j <SPC> + <SPC> k ] <NL>              if <SPC> s1 <SPC> in <SPC> lookup : <NL>                  tmp [ s1 ] <SPC> += <SPC> 1 <NL>                  count <SPC> += <SPC> 1 <NL>                  while <SPC> tmp [ s1 ] <SPC> > <SPC> lookup [ s1 ] : <NL>                      tmp [ s [ left : <SPC> left <SPC> + <SPC> k ] ] <SPC> -= <SPC> 1 <NL>                      count <SPC> -= <SPC> 1 <NL>                      left <SPC> += <SPC> k <NL>                  if <SPC> count <SPC> == <SPC> n : <NL>                      result . append ( left ) <NL>              else : <NL>                  tmp <SPC> = <SPC> collections . defaultdict ( int ) <NL>                  count <SPC> = <SPC> 0 <NL>                  left <SPC> = <SPC> j <SPC> + <SPC> k <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findSubstring ( self , <SPC> s , <SPC> words ) : <NL> <NL> <TAB> result , <SPC> m , <SPC> n , <SPC> k <SPC> = <SPC> [ ] , <SPC> len ( s ) , <SPC> len ( words ) , <SPC> len ( words [ 0 ] ) <NL> <TAB> if <SPC> m <SPC> < <SPC> n <SPC> * <SPC> k : <NL>          return <SPC> result <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> i <SPC> in <SPC> words : <NL>          lookup [ i ] <SPC> += <SPC> 1 <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m <SPC> + <SPC> 1 <SPC> - <SPC> k <SPC> * <SPC> n ) : <NL>          cur , <SPC> j <SPC> = <SPC> collections . defaultdict ( int ) , <SPC> 0 <NL>          while <SPC> j <SPC> < <SPC> n : <NL>              word <SPC> = <SPC> s [ i <SPC> + <SPC> j <SPC> * <SPC> k : <SPC> i <SPC> + <SPC> j <SPC> * <SPC> k <SPC> + <SPC> k ] <NL>              if <SPC> word <SPC> not <SPC> in <SPC> lookup : <NL>                  break <NL>              cur [ word ] <SPC> += <SPC> 1 <NL>              if <SPC> cur [ word ] <SPC> > <SPC> lookup [ word ] : <NL>                  break <NL>              j <SPC> += <SPC> 1 <NL>          if <SPC> j <SPC> == <SPC> n : <NL>              result . append ( i ) <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> subtractProductAndSum ( self , <SPC> n ) : <NL> <NL> <TAB> product , <SPC> total <SPC> = <SPC> 1 , <SPC> 0 <NL> <TAB> while <SPC> n : <NL>          n , <SPC> r <SPC> = <SPC> divmod ( n , <SPC> 10 ) <NL>          product <SPC> *= <SPC> r <NL>          total <SPC> += <SPC> r <NL> <TAB> return <SPC> product <SPC> - <SPC> total <NL> <NL> <NL> import <SPC> operator <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> subtractProductAndSum ( self , <SPC> n ) : <NL> <NL> <TAB> A <SPC> = <SPC> map ( int , <SPC> str ( n ) ) <NL> <TAB> return <SPC> reduce ( operator . mul , <SPC> A ) <SPC> - <SPC> sum ( A ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isSubtree ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> def <SPC> isSame ( x , <SPC> y ) : <NL>          if <SPC> not <SPC> x <SPC> and <SPC> not <SPC> y : <NL>              return <SPC> True <NL>          if <SPC> not <SPC> x <SPC> or <SPC> not <SPC> y : <NL>              return <SPC> False <NL>          return <SPC> ( <NL>              x . val <SPC> == <SPC> y . val <SPC> and <SPC> isSame ( <NL>                  x . left , <SPC> y . left ) <SPC> and <SPC> isSame ( x . right , <SPC> y . right ) <NL>          ) <NL> <NL> <TAB> def <SPC> preOrderTraverse ( s , <SPC> t ) : <NL>          return <SPC> s <SPC> != <SPC> None <SPC> and <SPC> ( <NL>              isSame ( s , <SPC> t ) <NL>              or <SPC> preOrderTraverse ( s . left , <SPC> t ) <NL>              or <SPC> preOrderTraverse ( s . right , <SPC> t ) <NL>          ) <NL> <NL> <TAB> return <SPC> preOrderTraverse ( s , <SPC> t ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> solveSudoku ( self , <SPC> board ) : <NL> <NL> <TAB> def <SPC> isValid ( board , <SPC> x , <SPC> y ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( 9 ) : <NL>              if <SPC> i <SPC> != <SPC> x <SPC> and <SPC> board [ i ] [ y ] <SPC> == <SPC> board [ x ] [ y ] : <NL>                  return <SPC> False <NL>          for <SPC> j <SPC> in <SPC> xrange ( 9 ) : <NL>              if <SPC> j <SPC> != <SPC> y <SPC> and <SPC> board [ x ] [ j ] <SPC> == <SPC> board [ x ] [ y ] : <NL>                  return <SPC> False <NL>          i <SPC> = <SPC> 3 <SPC> * <SPC> ( x <SPC> / <SPC> 3 ) <NL>          while <SPC> i <SPC> < <SPC> 3 <SPC> * <SPC> ( x <SPC> / <SPC> 3 <SPC> + <SPC> 1 ) : <NL>              j <SPC> = <SPC> 3 <SPC> * <SPC> ( y <SPC> / <SPC> 3 ) <NL>              while <SPC> j <SPC> < <SPC> 3 <SPC> * <SPC> ( y <SPC> / <SPC> 3 <SPC> + <SPC> 1 ) : <NL>                  if <SPC> ( i <SPC> != <SPC> x <SPC> or <SPC> j <SPC> != <SPC> y ) <SPC> and <SPC> board [ i ] [ j ] <SPC> == <SPC> board [ x ] [ y ] : <NL>                      return <SPC> False <NL>                  j <SPC> += <SPC> 1 <NL>              i <SPC> += <SPC> 1 <NL>          return <SPC> True <NL> <NL> <TAB> def <SPC> solver ( board ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( board ) ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( board [ 0 ] ) ) : <NL>                  if <SPC> board [ i ] [ j ] <SPC> == <SPC> "." : <NL>                      for <SPC> k <SPC> in <SPC> xrange ( 9 ) : <NL>                          board [ i ] [ j ] <SPC> = <SPC> chr ( ord ( "1" ) <SPC> + <SPC> k ) <NL>                          if <SPC> isValid ( board , <SPC> i , <SPC> j ) <SPC> and <SPC> solver ( board ) : <NL>                              return <SPC> True <NL>                          board [ i ] [ j ] <SPC> = <SPC> "." <NL>                      return <SPC> False <NL>          return <SPC> True <NL> <NL> <TAB> solver ( board ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getSumAbsoluteDifferences ( self , <SPC> nums ) : <NL> <NL> <TAB> prefix , <SPC> suffix <SPC> = <SPC> 0 , <SPC> sum ( nums ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          suffix <SPC> -= <SPC> num <NL>          result . append ( ( i <SPC> * <SPC> num <SPC> - <SPC> prefix ) <SPC> + <NL>                        ( suffix <SPC> - <SPC> ( ( len ( nums ) <SPC> - <SPC> 1 ) <SPC> - <SPC> i ) <SPC> * <SPC> num ) ) <NL>          prefix <SPC> += <SPC> num <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumOddLengthSubarrays ( self , <SPC> arr ) : <NL> <NL> <TAB> def <SPC> ceil_divide ( a , <SPC> b ) : <NL>          return <SPC> ( a <SPC> + <SPC> ( b <SPC> - <SPC> 1 ) ) <SPC> // <SPC> b <NL> <NL> <TAB> return <SPC> sum ( <NL>          x <SPC> * <SPC> ceil_divide ( ( i <SPC> - <SPC> 0 <SPC> + <SPC> 1 ) <SPC> * <SPC> ( ( len ( arr ) <SPC> - <SPC> 1 ) <SPC> - <SPC> i <SPC> + <SPC> 1 ) , <SPC> 2 ) <NL>          for <SPC> i , <SPC> x <SPC> in <SPC> enumerate ( arr ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> beautySum ( self , <SPC> s ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>          lookup <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> len ( s ) ) : <NL>              lookup [ ord ( s [ j ] ) <SPC> - <SPC> ord ( "a" ) ] <SPC> += <SPC> 1 <NL>              result <SPC> += <SPC> max ( lookup ) <SPC> - <SPC> min ( x <SPC> for <SPC> x <SPC> in <SPC> lookup <SPC> if <SPC> x ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumOfDigits ( self , <SPC> A ) : <NL> <NL> <TAB> total <SPC> = <SPC> sum ( [ int ( c ) <SPC> for <SPC> c <SPC> in <SPC> str ( min ( A ) ) ] ) <NL> <TAB> return <SPC> 1 <SPC> if <SPC> total <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> else <SPC> 0 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumOfDistancesInTree ( self , <SPC> N , <SPC> edges ) : <NL> <NL> <TAB> def <SPC> dfs ( graph , <SPC> node , <SPC> parent , <SPC> count , <SPC> result ) : <NL>          for <SPC> nei <SPC> in <SPC> graph [ node ] : <NL>              if <SPC> nei <SPC> != <SPC> parent : <NL>                  dfs ( graph , <SPC> nei , <SPC> node , <SPC> count , <SPC> result ) <NL>                  count [ node ] <SPC> += <SPC> count [ nei ] <NL>                  result [ node ] <SPC> += <SPC> result [ nei ] <SPC> + <SPC> count [ nei ] <NL> <NL> <TAB> def <SPC> dfs2 ( graph , <SPC> node , <SPC> parent , <SPC> count , <SPC> result ) : <NL>          for <SPC> nei <SPC> in <SPC> graph [ node ] : <NL>              if <SPC> nei <SPC> != <SPC> parent : <NL>                  result [ nei ] <SPC> = <SPC> result [ node ] <SPC> -                      count [ nei ] <SPC> + <SPC> len ( count ) <SPC> - <SPC> count [ nei ] <NL>                  dfs2 ( graph , <SPC> nei , <SPC> node , <SPC> count , <SPC> result ) <NL> <NL> <TAB> graph <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          graph [ u ] . append ( v ) <NL>          graph [ v ] . append ( u ) <NL> <NL> <TAB> count <SPC> = <SPC> [ 1 ] <SPC> * <SPC> N <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> N <NL> <NL> <TAB> dfs ( graph , <SPC> 0 , <SPC> None , <SPC> count , <SPC> result ) <NL> <TAB> dfs2 ( graph , <SPC> 0 , <SPC> None , <SPC> count , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumEvenAfterQueries ( self , <SPC> A , <SPC> queries ) : <NL> <NL> <TAB> total <SPC> = <SPC> sum ( v <SPC> for <SPC> v <SPC> in <SPC> A <SPC> if <SPC> v <SPC> % <SPC> 2 <SPC> == <SPC> 0 ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> v , <SPC> i <SPC> in <SPC> queries : <NL>          if <SPC> A [ i ] <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              total <SPC> -= <SPC> A [ i ] <NL>          A [ i ] <SPC> += <SPC> v <NL>          if <SPC> A [ i ] <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              total <SPC> += <SPC> A [ i ] <NL>          result . append ( total ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumOfLeftLeaves ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> sumOfLeftLeavesHelper ( root , <SPC> is_left ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 <NL>          if <SPC> not <SPC> root . left <SPC> and <SPC> not <SPC> root . right : <NL>              return <SPC> root . val <SPC> if <SPC> is_left <SPC> else <SPC> 0 <NL>          return <SPC> sumOfLeftLeavesHelper ( root . left , <SPC> True ) <SPC> + <SPC> sumOfLeftLeavesHelper ( <NL>              root . right , <SPC> False <NL>          ) <NL> <NL> <TAB> return <SPC> sumOfLeftLeavesHelper ( root , <SPC> False ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findBestValue ( self , <SPC> arr , <SPC> target ) : <NL> <NL> <TAB> arr . sort ( reverse = True ) <NL> <TAB> max_arr <SPC> = <SPC> arr [ 0 ] <NL> <TAB> while <SPC> arr <SPC> and <SPC> arr [ - 1 ] <SPC> * <SPC> len ( arr ) <SPC> <= <SPC> target : <NL>          target <SPC> -= <SPC> arr . pop ( ) <NL> <NL> <TAB> return <SPC> max_arr <SPC> if <SPC> not <SPC> arr <SPC> else <SPC> ( 2 <SPC> * <SPC> target <SPC> + <SPC> len ( arr ) <SPC> - <SPC> 1 ) <SPC> // <SPC> ( 2 <SPC> * <SPC> len ( arr ) ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findBestValue ( self , <SPC> arr , <SPC> target ) : <NL> <NL> <TAB> arr . sort ( reverse = True ) <NL> <TAB> max_arr <SPC> = <SPC> arr [ 0 ] <NL> <TAB> while <SPC> arr <SPC> and <SPC> arr [ - 1 ] <SPC> * <SPC> len ( arr ) <SPC> <= <SPC> target : <NL>          target <SPC> -= <SPC> arr . pop ( ) <NL> <TAB> if <SPC> not <SPC> arr : <NL>          return <SPC> max_arr <NL> <TAB> x <SPC> = <SPC> ( target <SPC> - <SPC> 1 ) <SPC> // <SPC> len ( arr ) <NL> <TAB> return <SPC> x <SPC> if <SPC> target <SPC> - <SPC> x <SPC> * <SPC> len ( arr ) <SPC> <= <SPC> ( x <SPC> + <SPC> 1 ) <SPC> * <SPC> len ( arr ) <SPC> - <SPC> target <SPC> else <SPC> x <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> findBestValue ( self , <SPC> arr , <SPC> target ) : <NL> <NL> <TAB> def <SPC> total ( arr , <SPC> v ) : <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> x <SPC> in <SPC> arr : <NL>              result <SPC> += <SPC> min ( v , <SPC> x ) <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> check ( arr , <SPC> v , <SPC> target ) : <NL>          return <SPC> total ( arr , <SPC> v ) <SPC> >= <SPC> target <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> max ( arr ) <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> check ( arr , <SPC> mid , <SPC> target ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> ( <NL>          left <SPC> - <SPC> 1 <NL>          if <SPC> target <SPC> - <SPC> total ( arr , <SPC> left <SPC> - <SPC> 1 ) <SPC> <= <SPC> total ( arr , <SPC> left ) <SPC> - <SPC> target <NL>          else <SPC> left <NL> <TAB> ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumEvenGrandparent ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> sumEvenGrandparentHelper ( root , <SPC> p , <SPC> gp ) : <NL>          return <SPC> ( <NL>              sumEvenGrandparentHelper ( root . left , <SPC> root . val , <SPC> p ) <NL>              + <SPC> sumEvenGrandparentHelper ( root . right , <SPC> root . val , <SPC> p ) <NL>              + <SPC> ( root . val <SPC> if <SPC> gp <SPC> is <SPC> not <SPC> None <SPC> and <SPC> gp <SPC> % <SPC> 2 <SPC> == <SPC> 0 <SPC> else <SPC> 0 ) <NL>              if <SPC> root <NL>              else <SPC> 0 <NL>          ) <NL> <NL> <TAB> return <SPC> sumEvenGrandparentHelper ( root , <SPC> None , <SPC> None ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumRootToLeaf ( self , <SPC> root ) : <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> def <SPC> sumRootToLeafHelper ( root , <SPC> val ) : <NL>          if <SPC> not <SPC> root : <NL>              return <SPC> 0 <NL>          val <SPC> = <SPC> ( val <SPC> * <SPC> 2 <SPC> + <SPC> root . val ) <SPC> % <SPC> M <NL>          if <SPC> not <SPC> root . left <SPC> and <SPC> not <SPC> root . right : <NL>              return <SPC> val <NL>          return <SPC> ( <NL>              sumRootToLeafHelper ( root . left , <SPC> val ) <NL>              + <SPC> sumRootToLeafHelper ( root . right , <SPC> val ) <NL>          ) <SPC> % <SPC> M <NL> <NL> <TAB> return <SPC> sumRootToLeafHelper ( root , <SPC> 0 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> solve ( self , <SPC> nums , <SPC> queries ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> prefix <SPC> = <SPC> { } <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> x , <SPC> y <SPC> in <SPC> queries : <NL>          if <SPC> y <SPC> * <SPC> y <SPC> > <SPC> len ( nums ) : <NL>              total <SPC> = <SPC> 0 <NL>              for <SPC> i <SPC> in <SPC> xrange ( x , <SPC> len ( nums ) , <SPC> y ) : <NL>                  total <SPC> += <SPC> nums [ i ] <NL>                  total <SPC> %= <SPC> MOD <NL>              result . append ( total ) <NL>          else : <NL>              begin <SPC> = <SPC> x <SPC> % <SPC> y <NL>              if <SPC> ( begin , <SPC> y ) <SPC> not <SPC> in <SPC> prefix : <NL>                  prefix [ ( begin , <SPC> y ) ] <SPC> = <SPC> [ 0 ] <NL>                  for <SPC> i <SPC> in <SPC> xrange ( begin , <SPC> len ( nums ) , <SPC> y ) : <NL>                      prefix [ ( begin , <SPC> y ) ] . append ( <NL>                          ( prefix [ ( begin , <SPC> y ) ] [ - 1 ] <SPC> + <SPC> nums [ i ] ) <SPC> % <SPC> MOD <NL>                      ) <NL>              result . append ( <NL>                  ( prefix [ ( begin , <SPC> y ) ] [ - 1 ] <SPC> - <SPC> prefix [ ( begin , <SPC> y ) ] [ x <SPC> // <SPC> y ] ) <SPC> % <SPC> MOD <NL>              ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> math <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> judgeSquareSum ( self , <SPC> c ) : <NL> <NL> <TAB> for <SPC> a <SPC> in <SPC> xrange ( int ( math . sqrt ( c ) ) <SPC> + <SPC> 1 ) : <NL>          b <SPC> = <SPC> int ( math . sqrt ( c <SPC> - <SPC> a <SPC> ** <SPC> 2 ) ) <NL>          if <SPC> a <SPC> ** <SPC> 2 <SPC> + <SPC> b <SPC> ** <SPC> 2 <SPC> == <SPC> c : <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumSubarrayMins ( self , <SPC> A ) : <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> left , <SPC> s1 <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( A ) , <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          count <SPC> = <SPC> 1 <NL>          while <SPC> s1 <SPC> and <SPC> s1 [ - 1 ] [ 0 ] <SPC> > <SPC> A [ i ] : <NL>              count <SPC> += <SPC> s1 . pop ( ) [ 1 ] <NL>          left [ i ] <SPC> = <SPC> count <NL>          s1 . append ( [ A [ i ] , <SPC> count ] ) <NL> <NL> <TAB> right , <SPC> s2 <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( A ) , <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( A ) ) ) : <NL>          count <SPC> = <SPC> 1 <NL>          while <SPC> s2 <SPC> and <SPC> s2 [ - 1 ] [ 0 ] <SPC> >= <SPC> A [ i ] : <NL>              count <SPC> += <SPC> s2 . pop ( ) [ 1 ] <NL>          right [ i ] <SPC> = <SPC> count <NL>          s2 . append ( [ A [ i ] , <SPC> count ] ) <NL> <NL> <TAB> return <SPC> sum ( a <SPC> * <SPC> l <SPC> * <SPC> r <SPC> for <SPC> a , <SPC> l , <SPC> r <SPC> in <SPC> itertools . izip ( A , <SPC> left , <SPC> right ) ) <SPC> % <SPC> M <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumSubseqWidths ( self , <SPC> A ) : <NL> <NL> <TAB> M <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> result , <SPC> c <SPC> = <SPC> 0 , <SPC> 1 <NL> <TAB> A . sort ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          result <SPC> = <SPC> ( result <SPC> + <SPC> ( A [ i ] <SPC> - <SPC> A [ len ( A ) <SPC> - <SPC> 1 <SPC> - <SPC> i ] ) <SPC> * <SPC> c <SPC> % <SPC> M ) <SPC> % <SPC> M <NL>          c <SPC> = <SPC> ( c <SPC> << <SPC> 1 ) <SPC> % <SPC> M <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getSum ( self , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> bit_length <SPC> = <SPC> 32 <NL> <TAB> neg_bit , <SPC> mask <SPC> = <SPC> ( 1 <SPC> << <SPC> bit_length ) <SPC> >> <SPC> 1 , <SPC> ~ ( ~ 0 <SPC> << <SPC> bit_length ) <NL> <NL> <TAB> a <SPC> = <SPC> ( a <SPC> | <SPC> ~ mask ) <SPC> if <SPC> ( a <SPC> & <SPC> neg_bit ) <SPC> else <SPC> ( a <SPC> & <SPC> mask ) <NL> <TAB> b <SPC> = <SPC> ( b <SPC> | <SPC> ~ mask ) <SPC> if <SPC> ( b <SPC> & <SPC> neg_bit ) <SPC> else <SPC> ( b <SPC> & <SPC> mask ) <NL> <NL> <TAB> while <SPC> b : <NL>          carry <SPC> = <SPC> a <SPC> & <SPC> b <NL>          a <SPC> ^= <SPC> b <NL>          a <SPC> = <SPC> ( a <SPC> | <SPC> ~ mask ) <SPC> if <SPC> ( a <SPC> & <SPC> neg_bit ) <SPC> else <SPC> ( a <SPC> & <SPC> mask ) <NL>          b <SPC> = <SPC> carry <SPC> << <SPC> 1 <NL>          b <SPC> = <SPC> ( b <SPC> | <SPC> ~ mask ) <SPC> if <SPC> ( b <SPC> & <SPC> neg_bit ) <SPC> else <SPC> ( b <SPC> & <SPC> mask ) <NL> <NL> <TAB> return <SPC> a <NL> <NL> <TAB> def <SPC> getSum2 ( self , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> MAX <SPC> = <SPC> 0x7FFFFFFF <NL> <NL> <TAB> MIN <SPC> = <SPC> 0x80000000 <NL> <NL> <TAB> mask <SPC> = <SPC> 0xFFFFFFFF <NL> <TAB> while <SPC> b : <NL> <NL>          a , <SPC> b <SPC> = <SPC> ( a <SPC> ^ <SPC> b ) <SPC> & <SPC> mask , <SPC> ( ( a <SPC> & <SPC> b ) <SPC> << <SPC> 1 ) <SPC> & <SPC> mask <NL> <NL> <TAB> return <SPC> a <SPC> if <SPC> a <SPC> <= <SPC> MAX <SPC> else <SPC> ~ ( a <SPC> ^ <SPC> mask ) <NL> <NL> <TAB> def <SPC> minus ( self , <SPC> a , <SPC> b ) : <NL> <TAB> b <SPC> = <SPC> self . getSum ( ~ b , <SPC> 1 ) <NL> <TAB> return <SPC> self . getSum ( a , <SPC> b ) <NL> <NL> <TAB> def <SPC> multiply ( self , <SPC> a , <SPC> b ) : <NL> <TAB> isNeg <SPC> = <SPC> ( a <SPC> > <SPC> 0 ) <SPC> ^ <SPC> ( b <SPC> > <SPC> 0 ) <NL> <TAB> x <SPC> = <SPC> a <SPC> if <SPC> a <SPC> > <SPC> 0 <SPC> else <SPC> self . getSum ( ~ a , <SPC> 1 ) <NL> <TAB> y <SPC> = <SPC> b <SPC> if <SPC> b <SPC> > <SPC> 0 <SPC> else <SPC> self . getSum ( ~ b , <SPC> 1 ) <NL> <TAB> ans <SPC> = <SPC> 0 <NL> <TAB> while <SPC> y <SPC> & <SPC> 0x01 : <NL>          ans <SPC> = <SPC> self . getSum ( ans , <SPC> x ) <NL>          y <SPC> >>= <SPC> 1 <NL>          x <SPC> <<= <SPC> 1 <NL> <TAB> return <SPC> self . getSum ( ~ ans , <SPC> 1 ) <SPC> if <SPC> isNeg <SPC> else <SPC> ans <NL> <NL> <TAB> def <SPC> divide ( self , <SPC> a , <SPC> b ) : <NL> <TAB> isNeg <SPC> = <SPC> ( a <SPC> > <SPC> 0 ) <SPC> ^ <SPC> ( b <SPC> > <SPC> 0 ) <NL> <TAB> x <SPC> = <SPC> a <SPC> if <SPC> a <SPC> > <SPC> 0 <SPC> else <SPC> self . getSum ( ~ a , <SPC> 1 ) <NL> <TAB> y <SPC> = <SPC> b <SPC> if <SPC> b <SPC> > <SPC> 0 <SPC> else <SPC> self . getSum ( ~ b , <SPC> 1 ) <NL> <TAB> ans <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> range ( 31 , <SPC> - 1 , <SPC> - 1 ) : <NL>          if <SPC> ( x <SPC> >> <SPC> i ) <SPC> >= <SPC> y : <NL>              x <SPC> = <SPC> self . minus ( x , <SPC> y <SPC> << <SPC> i ) <NL>              ans <SPC> = <SPC> self . getSum ( ans , <SPC> 1 <SPC> << <SPC> i ) <NL> <TAB> return <SPC> self . getSum ( ~ ans , <SPC> 1 ) <SPC> if <SPC> isNeg <SPC> else <SPC> ans <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> sumOfUnique ( self , <SPC> nums ) : <NL> <NL> <TAB> return <SPC> sum ( x <SPC> for <SPC> x , <SPC> c <SPC> in <SPC> collections . Counter ( nums ) . iteritems ( ) <SPC> if <SPC> c <SPC> == <SPC> 1 ) <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> sumNumbers ( self , <SPC> root ) : <NL> <TAB> return <SPC> self . sumNumbersRecu ( root , <SPC> 0 ) <NL> <NL> <TAB> def <SPC> sumNumbersRecu ( self , <SPC> root , <SPC> num ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> 0 <NL> <NL> <TAB> if <SPC> root . left <SPC> is <SPC> None <SPC> and <SPC> root . right <SPC> is <SPC> None : <NL>          return <SPC> num <SPC> * <SPC> 10 <SPC> + <SPC> root . val <NL> <NL> <TAB> return <SPC> self . sumNumbersRecu ( <NL>          root . left , <SPC> num <SPC> * <SPC> 10 <SPC> + <SPC> root . val <NL> <TAB> ) <SPC> + <SPC> self . sumNumbersRecu ( root . right , <SPC> num <SPC> * <SPC> 10 <SPC> + <SPC> root . val ) <NL> <NL> <NL> import <SPC> itertools <NL> import <SPC> re <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> summaryRanges ( self , <SPC> nums ) : <NL> <TAB> ranges <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> not <SPC> nums : <NL>          return <SPC> ranges <NL> <NL> <TAB> start , <SPC> end <SPC> = <SPC> nums [ 0 ] , <SPC> nums [ 0 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( nums ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> i <SPC> < <SPC> len ( nums ) <SPC> and <SPC> nums [ i ] <SPC> == <SPC> end <SPC> + <SPC> 1 : <NL>              end <SPC> = <SPC> nums [ i ] <NL>          else : <NL>              interval <SPC> = <SPC> str ( start ) <NL>              if <SPC> start <SPC> != <SPC> end : <NL>                  interval <SPC> += <SPC> "->" <SPC> + <SPC> str ( end ) <NL>              ranges . append ( interval ) <NL>              if <SPC> i <SPC> < <SPC> len ( nums ) : <NL>                  start <SPC> = <SPC> end <SPC> = <SPC> nums [ i ] <NL> <NL> <TAB> return <SPC> ranges <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> summaryRanges ( self , <SPC> nums ) : <NL> <TAB> return <SPC> [ <NL>          re . sub ( "->.*>" , <SPC> "->" , <SPC> "->" . join ( repr ( n ) <SPC> for <SPC> _ , <SPC> n <SPC> in <SPC> g ) ) <NL>          for <SPC> _ , <SPC> g <SPC> in <SPC> itertools . groupby ( enumerate ( nums ) , <SPC> lambda <SPC> i_n : <SPC> i_n [ 1 ] <SPC> - <SPC> i_n [ 0 ] ) <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> superEggDrop ( self , <SPC> K , <SPC> N ) : <NL> <NL> <TAB> def <SPC> check ( n , <SPC> K , <SPC> N ) : <NL> <NL>          total , <SPC> c <SPC> = <SPC> 0 , <SPC> 1 <NL>          for <SPC> k <SPC> in <SPC> xrange ( 1 , <SPC> K <SPC> + <SPC> 1 ) : <NL>              c <SPC> *= <SPC> n <SPC> - <SPC> k <SPC> + <SPC> 1 <NL>              c <SPC> //= <SPC> k <NL>              total <SPC> += <SPC> c <NL>              if <SPC> total <SPC> >= <SPC> N : <NL>                  return <SPC> True <NL>          return <SPC> False <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> N <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> check ( mid , <SPC> K , <SPC> N ) : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> superpalindromesInRange ( self , <SPC> L , <SPC> R ) : <NL> <NL> <TAB> def <SPC> is_palindrome ( k ) : <NL>          return <SPC> str ( k ) <SPC> == <SPC> str ( k ) [ : : - 1 ] <NL> <NL> <TAB> K <SPC> = <SPC> int ( ( 10 <SPC> ** <SPC> ( ( len ( R ) <SPC> + <SPC> 1 ) <SPC> * <SPC> 0.25 ) ) ) <NL> <TAB> l , <SPC> r <SPC> = <SPC> int ( L ) , <SPC> int ( R ) <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <NL> <TAB> for <SPC> k <SPC> in <SPC> xrange ( K ) : <NL>          s <SPC> = <SPC> str ( k ) <NL>          t <SPC> = <SPC> s <SPC> + <SPC> s [ - 2 : : - 1 ] <NL>          v <SPC> = <SPC> int ( t ) <SPC> ** <SPC> 2 <NL>          if <SPC> v <SPC> > <SPC> r : <NL>              break <NL>          if <SPC> v <SPC> >= <SPC> l <SPC> and <SPC> is_palindrome ( v ) : <NL>              result <SPC> += <SPC> 1 <NL> <NL> <TAB> for <SPC> k <SPC> in <SPC> xrange ( K ) : <NL>          s <SPC> = <SPC> str ( k ) <NL>          t <SPC> = <SPC> s <SPC> + <SPC> s [ : : - 1 ] <NL>          v <SPC> = <SPC> int ( t ) <SPC> ** <SPC> 2 <NL>          if <SPC> v <SPC> > <SPC> r : <NL>              break <NL>          if <SPC> v <SPC> >= <SPC> l <SPC> and <SPC> is_palindrome ( v ) : <NL>              result <SPC> += <SPC> 1 <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> superPow ( self , <SPC> a , <SPC> b ) : <NL> <NL> <TAB> def <SPC> myPow ( a , <SPC> n , <SPC> b ) : <NL>          result <SPC> = <SPC> 1 <NL>          x <SPC> = <SPC> a <SPC> % <SPC> b <NL>          while <SPC> n : <NL>              if <SPC> n <SPC> & <SPC> 1 : <NL>                  result <SPC> = <SPC> result <SPC> * <SPC> x <SPC> % <SPC> b <NL>              n <SPC> >>= <SPC> 1 <NL>              x <SPC> = <SPC> x <SPC> * <SPC> x <SPC> % <SPC> b <NL>          return <SPC> result <SPC> % <SPC> b <NL> <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> for <SPC> digit <SPC> in <SPC> b : <NL>          result <SPC> = <SPC> myPow ( result , <SPC> 10 , <SPC> 1337 ) <SPC> * <SPC> myPow ( a , <SPC> digit , <SPC> 1337 ) <SPC> % <SPC> 1337 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nthSuperUglyNumber ( self , <SPC> n , <SPC> primes ) : <NL> <NL> <TAB> heap , <SPC> uglies , <SPC> idx , <SPC> ugly_by_last_prime <SPC> = <SPC> [ ] , <SPC> [ <NL>          0 ] <SPC> * <SPC> n , <SPC> [ 0 ] <SPC> * <SPC> len ( primes ) , <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> uglies [ 0 ] <SPC> = <SPC> 1 <NL> <NL> <TAB> for <SPC> k , <SPC> p <SPC> in <SPC> enumerate ( primes ) : <NL>          heapq . heappush ( heap , <SPC> ( p , <SPC> k ) ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>          uglies [ i ] , <SPC> k <SPC> = <SPC> heapq . heappop ( heap ) <NL>          ugly_by_last_prime [ i ] <SPC> = <SPC> k <NL>          idx [ k ] <SPC> += <SPC> 1 <NL>          while <SPC> ugly_by_last_prime [ idx [ k ] ] <SPC> > <SPC> k : <NL>              idx [ k ] <SPC> += <SPC> 1 <NL>          heapq . heappush ( heap , <SPC> ( primes [ k ] <SPC> * <SPC> uglies [ idx [ k ] ] , <SPC> k ) ) <NL> <NL> <TAB> return <SPC> uglies [ - 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> nthSuperUglyNumber ( self , <SPC> n , <SPC> primes ) : <NL> <NL> <TAB> uglies , <SPC> idx , <SPC> heap , <SPC> ugly_set <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n , <SPC> [ 0 ] <SPC> * <SPC> len ( primes ) , <SPC> [ ] , <SPC> set ( [ 1 ] ) <NL> <TAB> uglies [ 0 ] <SPC> = <SPC> 1 <NL> <NL> <TAB> for <SPC> k , <SPC> p <SPC> in <SPC> enumerate ( primes ) : <NL>          heapq . heappush ( heap , <SPC> ( p , <SPC> k ) ) <NL>          ugly_set . add ( p ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>          uglies [ i ] , <SPC> k <SPC> = <SPC> heapq . heappop ( heap ) <NL>          while <SPC> ( primes [ k ] <SPC> * <SPC> uglies [ idx [ k ] ] ) <SPC> in <SPC> ugly_set : <NL>              idx [ k ] <SPC> += <SPC> 1 <NL>          heapq . heappush ( heap , <SPC> ( primes [ k ] <SPC> * <SPC> uglies [ idx [ k ] ] , <SPC> k ) ) <NL>          ugly_set . add ( primes [ k ] <SPC> * <SPC> uglies [ idx [ k ] ] ) <NL> <NL> <TAB> return <SPC> uglies [ - 1 ] <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> nthSuperUglyNumber ( self , <SPC> n , <SPC> primes ) : <NL> <NL> <TAB> uglies , <SPC> idx , <SPC> heap <SPC> = <SPC> [ 1 ] , <SPC> [ 0 ] <SPC> * <SPC> len ( primes ) , <SPC> [ ] <NL> <TAB> for <SPC> k , <SPC> p <SPC> in <SPC> enumerate ( primes ) : <NL>          heapq . heappush ( heap , <SPC> ( p , <SPC> k ) ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>          min_val , <SPC> k <SPC> = <SPC> heap [ 0 ] <NL>          uglies <SPC> += <SPC> [ min_val ] <NL> <NL>          while <SPC> heap [ 0 ] [ 0 ] <SPC> == <SPC> min_val : <NL>              min_val , <SPC> k <SPC> = <SPC> heapq . heappop ( heap ) <NL>              idx [ k ] <SPC> += <SPC> 1 <NL>              heapq . heappush ( heap , <SPC> ( primes [ k ] <SPC> * <SPC> uglies [ idx [ k ] ] , <SPC> k ) ) <NL> <NL> <TAB> return <SPC> uglies [ - 1 ] <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> nthSuperUglyNumber ( self , <SPC> n , <SPC> primes ) : <NL> <NL> <TAB> uglies <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> uglies [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> ugly_by_prime <SPC> = <SPC> list ( primes ) <NL> <TAB> idx <SPC> = <SPC> [ 0 ] <SPC> * <SPC> len ( primes ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>          uglies [ i ] <SPC> = <SPC> min ( ugly_by_prime ) <NL>          for <SPC> k <SPC> in <SPC> xrange ( len ( primes ) ) : <NL>              if <SPC> uglies [ i ] <SPC> == <SPC> ugly_by_prime [ k ] : <NL>                  idx [ k ] <SPC> += <SPC> 1 <NL>                  ugly_by_prime [ k ] <SPC> = <SPC> primes [ k ] <SPC> * <SPC> uglies [ idx [ k ] ] <NL> <NL> <TAB> return <SPC> uglies [ - 1 ] <NL> <NL> <NL> class <SPC> Solution5 ( object ) : <NL> <TAB> def <SPC> nthSuperUglyNumber ( self , <SPC> n , <SPC> primes ) : <NL> <NL> <TAB> ugly_number <SPC> = <SPC> 0 <NL> <NL> <TAB> heap <SPC> = <SPC> [ ] <NL> <TAB> heapq . heappush ( heap , <SPC> 1 ) <NL> <TAB> for <SPC> p <SPC> in <SPC> primes : <NL>          heapq . heappush ( heap , <SPC> p ) <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( n ) : <NL>          ugly_number <SPC> = <SPC> heapq . heappop ( heap ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( primes ) ) : <NL>              if <SPC> ugly_number <SPC> % <SPC> primes [ i ] <SPC> == <SPC> 0 : <NL>                  for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 ) : <NL>                      heapq . heappush ( heap , <SPC> ugly_number <SPC> * <SPC> primes [ j ] ) <NL>                  break <NL> <NL> <TAB> return <SPC> ugly_number <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findMinMoves ( self , <SPC> machines ) : <NL> <NL> <TAB> total <SPC> = <SPC> sum ( machines ) <NL> <TAB> if <SPC> total <SPC> % <SPC> len ( machines ) : <NL>          return <SPC> - 1 <NL> <NL> <TAB> result , <SPC> target , <SPC> curr <SPC> = <SPC> 0 , <SPC> total <SPC> / <SPC> len ( machines ) , <SPC> 0 <NL> <TAB> for <SPC> n <SPC> in <SPC> machines : <NL>          curr <SPC> += <SPC> n <SPC> - <SPC> target <NL>          result <SPC> = <SPC> max ( result , <SPC> max ( n <SPC> - <SPC> target , <SPC> abs ( curr ) ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> surfaceArea ( self , <SPC> grid ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>              if <SPC> grid [ i ] [ j ] : <NL>                  result <SPC> += <SPC> 2 <SPC> + <SPC> grid [ i ] [ j ] <SPC> * <SPC> 4 <NL>              if <SPC> i : <NL>                  result <SPC> -= <SPC> min ( grid [ i ] [ j ] , <SPC> grid [ i <SPC> - <SPC> 1 ] [ j ] ) <SPC> * <SPC> 2 <NL>              if <SPC> j : <NL>                  result <SPC> -= <SPC> min ( grid [ i ] [ j ] , <SPC> grid [ i ] [ j <SPC> - <SPC> 1 ] ) <SPC> * <SPC> 2 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> solve ( self , <SPC> board ) : <NL> <NL> <TAB> if <SPC> not <SPC> board : <NL>          return <NL> <NL> <TAB> q <SPC> = <SPC> collections . deque ( ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( board ) ) : <NL>          if <SPC> board [ i ] [ 0 ] <SPC> == <SPC> "O" : <NL>              board [ i ] [ 0 ] <SPC> = <SPC> "V" <NL>              q . append ( ( i , <SPC> 0 ) ) <NL>          if <SPC> board [ i ] [ len ( board [ 0 ] ) <SPC> - <SPC> 1 ] <SPC> == <SPC> "O" : <NL>              board [ i ] [ len ( board [ 0 ] ) <SPC> - <SPC> 1 ] <SPC> = <SPC> "V" <NL>              q . append ( ( i , <SPC> len ( board [ 0 ] ) <SPC> - <SPC> 1 ) ) <NL> <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( board [ 0 ] ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> board [ 0 ] [ j ] <SPC> == <SPC> "O" : <NL>              board [ 0 ] [ j ] <SPC> = <SPC> "V" <NL>              q . append ( ( 0 , <SPC> j ) ) <NL>          if <SPC> board [ len ( board ) <SPC> - <SPC> 1 ] [ j ] <SPC> == <SPC> "O" : <NL>              board [ len ( board ) <SPC> - <SPC> 1 ] [ j ] <SPC> = <SPC> "V" <NL>              q . append ( ( len ( board ) <SPC> - <SPC> 1 , <SPC> j ) ) <NL> <NL> <TAB> while <SPC> q : <NL>          i , <SPC> j <SPC> = <SPC> q . popleft ( ) <NL>          for <SPC> x , <SPC> y <SPC> in <SPC> [ ( i <SPC> + <SPC> 1 , <SPC> j ) , <SPC> ( i <SPC> - <SPC> 1 , <SPC> j ) , <SPC> ( i , <SPC> j <SPC> + <SPC> 1 ) , <SPC> ( i , <SPC> j <SPC> - <SPC> 1 ) ] : <NL>              if <SPC> ( <NL>                  0 <SPC> <= <SPC> x <SPC> < <SPC> len ( board ) <NL>                  and <SPC> 0 <SPC> <= <SPC> y <SPC> < <SPC> len ( board [ 0 ] ) <NL>                  and <SPC> board [ x ] [ y ] <SPC> == <SPC> "O" <NL>              ) : <NL>                  board [ x ] [ y ] <SPC> = <SPC> "V" <NL>                  q . append ( ( x , <SPC> y ) ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( board ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( board [ 0 ] ) ) : <NL>              if <SPC> board [ i ] [ j ] <SPC> != <SPC> "V" : <NL>                  board [ i ] [ j ] <SPC> = <SPC> "X" <NL>              else : <NL>                  board [ i ] [ j ] <SPC> = <SPC> "O" <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canTransform ( self , <SPC> start , <SPC> end ) : <NL> <NL> <TAB> if <SPC> start . count ( "X" ) <SPC> != <SPC> end . count ( "X" ) : <NL>          return <SPC> False <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( start ) <SPC> and <SPC> j <SPC> < <SPC> len ( end ) : <NL>          while <SPC> i <SPC> < <SPC> len ( start ) <SPC> and <SPC> start [ i ] <SPC> == <SPC> "X" : <NL>              i <SPC> += <SPC> 1 <NL>          while <SPC> j <SPC> < <SPC> len ( end ) <SPC> and <SPC> end [ j ] <SPC> == <SPC> "X" : <NL>              j <SPC> += <SPC> 1 <NL>          if <SPC> ( i <SPC> < <SPC> len ( start ) ) <SPC> != <SPC> ( j <SPC> < <SPC> len ( end ) ) : <NL>              return <SPC> False <NL>          elif <SPC> i <SPC> < <SPC> len ( start ) <SPC> and <SPC> j <SPC> < <SPC> len ( end ) : <NL>              if <SPC> ( <NL>                  start [ i ] <SPC> != <SPC> end [ j ] <NL>                  or <SPC> ( start [ i ] <SPC> == <SPC> "L" <SPC> and <SPC> i <SPC> < <SPC> j ) <NL>                  or <SPC> ( start [ i ] <SPC> == <SPC> "R" <SPC> and <SPC> i <SPC> > <SPC> j ) <NL>              ) : <NL>                  return <SPC> False <NL>          i <SPC> += <SPC> 1 <NL>          j <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxRepOpt1 ( self , <SPC> text ) : <NL> <NL> <TAB> K <SPC> = <SPC> 1 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> total_count , <SPC> count <SPC> = <SPC> collections . Counter ( ) , <SPC> collections . Counter ( ) <NL> <TAB> left , <SPC> max_count <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( text ) ) : <NL>          total_count [ text [ i ] ] <SPC> += <SPC> 1 <NL>          count [ text [ i ] ] <SPC> += <SPC> 1 <NL>          max_count <SPC> = <SPC> max ( max_count , <SPC> count [ text [ i ] ] ) <NL>          if <SPC> i <SPC> - <SPC> left <SPC> + <SPC> 1 <SPC> - <SPC> max_count <SPC> > <SPC> K : <NL>              count [ text [ left ] ] <SPC> -= <SPC> 1 <NL>              left <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> max ( result , <SPC> min ( i <SPC> - <SPC> left <SPC> + <SPC> 1 , <SPC> total_count [ text [ i ] ] ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> maxRepOpt1 ( self , <SPC> text ) : <NL> <NL> <TAB> A <SPC> = <SPC> [ [ c , <SPC> len ( list ( group ) ) ] <SPC> for <SPC> c , <SPC> group <SPC> in <SPC> itertools . groupby ( text ) ] <NL> <TAB> total_count <SPC> = <SPC> collections . Counter ( text ) <NL> <TAB> result <SPC> = <SPC> max ( min ( l <SPC> + <SPC> 1 , <SPC> total_count [ c ] ) <SPC> for <SPC> c , <SPC> l <SPC> in <SPC> A ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( A ) <SPC> - <SPC> 1 ) : <NL>          if <SPC> A [ i <SPC> - <SPC> 1 ] [ 0 ] <SPC> == <SPC> A [ i <SPC> + <SPC> 1 ] [ 0 ] <SPC> and <SPC> A [ i ] [ 1 ] <SPC> == <SPC> 1 : <NL>              result <SPC> = <SPC> max ( <NL>                  result , <SPC> min ( A [ i <SPC> - <SPC> 1 ] [ 1 ] <SPC> + <SPC> 1 <SPC> + <SPC> A [ i <SPC> + <SPC> 1 ] <NL>                              [ 1 ] , <SPC> total_count [ A [ i <SPC> + <SPC> 1 ] [ 0 ] ] ) <NL>              ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . next <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          return <SPC> "{} -> {}" . format ( self . val , <SPC> self . next ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> swapPairs ( self , <SPC> head ) : <NL> <TAB> dummy <SPC> = <SPC> ListNode ( 0 ) <NL> <TAB> dummy . next <SPC> = <SPC> head <NL> <TAB> current <SPC> = <SPC> dummy <NL> <TAB> while <SPC> current . next <SPC> and <SPC> current . next . next : <NL>          next_one , <SPC> next_two , <SPC> next_three <SPC> = <SPC> ( <NL>              current . next , <NL>              current . next . next , <NL>              current . next . next . next , <NL>          ) <NL>          current . next <SPC> = <SPC> next_two <NL>          next_two . next <SPC> = <SPC> next_one <NL>          next_one . next <SPC> = <SPC> next_three <NL>          current <SPC> = <SPC> next_one <NL> <TAB> return <SPC> dummy . next <NL> <NL> <NL> class <SPC> ListNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> val = 0 , <SPC> next = None ) : <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> swapNodes ( self , <SPC> head , <SPC> k ) : <NL> <NL> <TAB> left , <SPC> right , <SPC> curr <SPC> = <SPC> None , <SPC> None , <SPC> head <NL> <TAB> while <SPC> curr : <NL>          k <SPC> -= <SPC> 1 <NL>          if <SPC> right : <NL>              right <SPC> = <SPC> right . next <NL>          if <SPC> k <SPC> == <SPC> 0 : <NL>              left <SPC> = <SPC> curr <NL>              right <SPC> = <SPC> head <NL>          curr <SPC> = <SPC> curr . next <NL> <TAB> left . val , <SPC> right . val <SPC> = <SPC> right . val , <SPC> left . val <NL> <TAB> return <SPC> head <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ min ( x_root , <SPC> y_root ) ] <SPC> = <SPC> max ( x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> swimInWater ( self , <SPC> grid ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( grid ) <NL> <TAB> positions <SPC> = <SPC> [ None ] <SPC> * <SPC> ( n <SPC> ** <SPC> 2 ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              positions [ grid [ i ] [ j ] ] <SPC> = <SPC> ( i , <SPC> j ) <NL> <TAB> directions <SPC> = <SPC> ( ( - 1 , <SPC> 0 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 0 , <SPC> 1 ) ) <NL> <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( n <SPC> ** <SPC> 2 ) <NL> <TAB> for <SPC> elevation <SPC> in <SPC> xrange ( n <SPC> ** <SPC> 2 ) : <NL>          i , <SPC> j <SPC> = <SPC> positions [ elevation ] <NL>          for <SPC> direction <SPC> in <SPC> directions : <NL>              x , <SPC> y <SPC> = <SPC> i <SPC> + <SPC> direction [ 0 ] , <SPC> j <SPC> + <SPC> direction [ 1 ] <NL>              if <SPC> 0 <SPC> <= <SPC> x <SPC> < <SPC> n <SPC> and <SPC> 0 <SPC> <= <SPC> y <SPC> < <SPC> n <SPC> and <SPC> grid [ x ] [ y ] <SPC> <= <SPC> elevation : <NL>                  union_find . union_set ( i <SPC> * <SPC> n <SPC> + <SPC> j , <SPC> x <SPC> * <SPC> n <SPC> + <SPC> y ) <NL>                  if <SPC> union_find . find_set ( 0 ) <SPC> == <SPC> union_find . find_set ( n <SPC> ** <SPC> 2 <SPC> - <SPC> 1 ) : <NL>                      return <SPC> elevation <NL> <TAB> return <SPC> n <SPC> ** <SPC> 2 <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isSymmetric ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> stack . append ( root . left ) <NL> <TAB> stack . append ( root . right ) <NL> <NL> <TAB> while <SPC> stack : <NL>          p , <SPC> q <SPC> = <SPC> stack . pop ( ) , <SPC> stack . pop ( ) <NL> <NL>          if <SPC> p <SPC> is <SPC> None <SPC> and <SPC> q <SPC> is <SPC> None : <NL>              continue <NL> <NL>          if <SPC> p <SPC> is <SPC> None <SPC> or <SPC> q <SPC> is <SPC> None <SPC> or <SPC> p . val <SPC> != <SPC> q . val : <NL>              return <SPC> False <NL> <NL>          stack . append ( p . left ) <NL>          stack . append ( q . right ) <NL> <NL>          stack . append ( p . right ) <NL>          stack . append ( q . left ) <NL> <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> isSymmetric ( self , <SPC> root ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <NL> <TAB> return <SPC> self . isSymmetricRecu ( root . left , <SPC> root . right ) <NL> <NL> <TAB> def <SPC> isSymmetricRecu ( self , <SPC> left , <SPC> right ) : <NL> <TAB> if <SPC> left <SPC> is <SPC> None <SPC> and <SPC> right <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <TAB> if <SPC> left <SPC> is <SPC> None <SPC> or <SPC> right <SPC> is <SPC> None <SPC> or <SPC> left . val <SPC> != <SPC> right . val : <NL>          return <SPC> False <NL> <TAB> return <SPC> self . isSymmetricRecu ( left . left , <SPC> right . right ) <SPC> and <SPC> self . isSymmetricRecu ( <NL>          left . right , <SPC> right . left <NL> <TAB> ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . count <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ max ( x_root , <SPC> y_root ) ] <SPC> = <SPC> min ( x_root , <SPC> y_root ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> generateSentences ( self , <SPC> synonyms , <SPC> text ) : <NL> <NL> <TAB> def <SPC> assign_id ( x , <SPC> lookup , <SPC> inv_lookup ) : <NL>          if <SPC> x <SPC> in <SPC> lookup : <NL>              return <NL>          lookup [ x ] <SPC> = <SPC> len ( lookup ) <NL>          inv_lookup [ lookup [ x ] ] <SPC> = <SPC> x <NL> <NL> <TAB> lookup , <SPC> inv_lookup <SPC> = <SPC> { } , <SPC> { } <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> synonyms : <NL>          assign_id ( u , <SPC> lookup , <SPC> inv_lookup ) , <SPC> assign_id ( v , <SPC> lookup , <SPC> inv_lookup ) <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( len ( lookup ) ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> synonyms : <NL>          union_find . union_set ( lookup [ u ] , <SPC> lookup [ v ] ) <NL> <TAB> groups <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( union_find . set ) ) : <NL>          groups [ union_find . find_set ( i ) ] . append ( i ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> w <SPC> in <SPC> text . split ( " " ) : <NL>          if <SPC> w <SPC> not <SPC> in <SPC> lookup : <NL>              result . append ( [ w ] ) <NL>              continue <NL>          result . append ( <NL>              sorted ( <NL>                  map ( lambda <SPC> x : <SPC> inv_lookup [ x ] , <NL>                      groups [ union_find . find_set ( lookup [ w ] ) ] ) <NL>              ) <NL>          ) <NL> <TAB> return <SPC> [ " " . join ( sentense ) <SPC> for <SPC> sentense <SPC> in <SPC> itertools . product ( * result ) ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isValid ( self , <SPC> code ) : <NL> <NL> <TAB> def <SPC> validText ( s , <SPC> i ) : <NL>          j <SPC> = <SPC> i <NL>          i <SPC> = <SPC> s . find ( "<" , <SPC> i ) <NL>          return <SPC> i <SPC> != <SPC> j , <SPC> i <NL> <NL> <TAB> def <SPC> validCData ( s , <SPC> i ) : <NL>          if <SPC> s . find ( "<![CDATA[" , <SPC> i ) <SPC> != <SPC> i : <NL>              return <SPC> False , <SPC> i <NL>          j <SPC> = <SPC> s . find ( "]]>" , <SPC> i ) <NL>          if <SPC> j <SPC> == <SPC> - 1 : <NL>              return <SPC> False , <SPC> i <NL>          return <SPC> True , <SPC> j <SPC> + <SPC> 3 <NL> <NL> <TAB> def <SPC> parseTagName ( s , <SPC> i ) : <NL>          if <SPC> s [ i ] <SPC> != <SPC> "<" : <NL>              return <SPC> "" , <SPC> i <NL>          j <SPC> = <SPC> s . find ( ">" , <SPC> i ) <NL>          if <SPC> j <SPC> == <SPC> - 1 <SPC> or <SPC> not <SPC> ( 1 <SPC> <= <SPC> ( j <SPC> - <SPC> 1 <SPC> - <SPC> i ) <SPC> <= <SPC> 9 ) : <NL>              return <SPC> "" , <SPC> i <NL>          tag <SPC> = <SPC> s [ i <SPC> + <SPC> 1 : <SPC> j ] <NL>          for <SPC> c <SPC> in <SPC> tag : <NL>              if <SPC> not <SPC> ( ord ( "A" ) <SPC> <= <SPC> ord ( c ) <SPC> <= <SPC> ord ( "Z" ) ) : <NL>                  return <SPC> "" , <SPC> i <NL>          return <SPC> tag , <SPC> j <SPC> + <SPC> 1 <NL> <NL> <TAB> def <SPC> parseContent ( s , <SPC> i ) : <NL>          while <SPC> i <SPC> < <SPC> len ( s ) : <NL>              result , <SPC> i <SPC> = <SPC> validText ( s , <SPC> i ) <NL>              if <SPC> result : <NL>                  continue <NL>              result , <SPC> i <SPC> = <SPC> validCData ( s , <SPC> i ) <NL>              if <SPC> result : <NL>                  continue <NL>              result , <SPC> i <SPC> = <SPC> validTag ( s , <SPC> i ) <NL>              if <SPC> result : <NL>                  continue <NL>              break <NL>          return <SPC> i <NL> <NL> <TAB> def <SPC> validTag ( s , <SPC> i ) : <NL>          tag , <SPC> j <SPC> = <SPC> parseTagName ( s , <SPC> i ) <NL>          if <SPC> not <SPC> tag : <NL>              return <SPC> False , <SPC> i <NL>          j <SPC> = <SPC> parseContent ( s , <SPC> j ) <NL>          k <SPC> = <SPC> j <SPC> + <SPC> len ( tag ) <SPC> + <SPC> 2 <NL>          if <SPC> k <SPC> >= <SPC> len ( s ) <SPC> or <SPC> s [ j : <SPC> k <SPC> + <SPC> 1 ] <SPC> != <SPC> "</" <SPC> + <SPC> tag <SPC> + <SPC> ">" : <NL>              return <SPC> False , <SPC> i <NL>          return <SPC> True , <SPC> k <SPC> + <SPC> 1 <NL> <NL> <TAB> result , <SPC> i <SPC> = <SPC> validTag ( code , <SPC> 0 ) <NL> <TAB> return <SPC> result <SPC> and <SPC> i <SPC> == <SPC> len ( code ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> tallestBillboard ( self , <SPC> rods ) : <NL> <NL> <TAB> def <SPC> dp ( A ) : <NL>          lookup <SPC> = <SPC> collections . defaultdict ( int ) <NL>          lookup [ 0 ] <SPC> = <SPC> 0 <NL>          for <SPC> x <SPC> in <SPC> A : <NL>              for <SPC> d , <SPC> y <SPC> in <SPC> lookup . items ( ) : <NL>                  lookup [ d <SPC> + <SPC> x ] <SPC> = <SPC> max ( lookup [ d <SPC> + <SPC> x ] , <SPC> y ) <NL>                  lookup [ abs ( d <SPC> - <SPC> x ) ] <SPC> = <SPC> max ( lookup [ abs ( d <SPC> - <SPC> x ) ] , <SPC> y <SPC> + <SPC> min ( d , <SPC> x ) ) <NL>          return <SPC> lookup <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> dp ( rods [ : <SPC> len ( rods ) <SPC> // <SPC> 2 ] ) , <SPC> dp ( rods [ len ( rods ) <SPC> // <SPC> 2 : ] ) <NL> <TAB> return <SPC> max ( left [ d ] <SPC> + <SPC> right [ d ] <SPC> + <SPC> d <SPC> for <SPC> d <SPC> in <SPC> left <SPC> if <SPC> d <SPC> in <SPC> right ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findTargetSumWays ( self , <SPC> nums , <SPC> S ) : <NL> <NL> <TAB> def <SPC> subsetSum ( nums , <SPC> S ) : <NL>          dp <SPC> = <SPC> collections . defaultdict ( int ) <NL>          dp [ 0 ] <SPC> = <SPC> 1 <NL>          for <SPC> n <SPC> in <SPC> nums : <NL>              for <SPC> i <SPC> in <SPC> reversed ( xrange ( n , <SPC> S <SPC> + <SPC> 1 ) ) : <NL>                  if <SPC> i <SPC> - <SPC> n <SPC> in <SPC> dp : <NL>                      dp [ i ] <SPC> += <SPC> dp [ i <SPC> - <SPC> n ] <NL>          return <SPC> dp [ S ] <NL> <NL> <TAB> total <SPC> = <SPC> sum ( nums ) <NL> <TAB> if <SPC> total <SPC> < <SPC> S <SPC> or <SPC> ( S <SPC> + <SPC> total ) <SPC> % <SPC> 2 : <NL>          return <SPC> 0 <NL> <TAB> P <SPC> = <SPC> ( S <SPC> + <SPC> total ) <SPC> // <SPC> 2 <NL> <TAB> return <SPC> subsetSum ( nums , <SPC> P ) <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> Counter <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> leastInterval ( self , <SPC> tasks , <SPC> n ) : <NL> <NL> <TAB> counter <SPC> = <SPC> Counter ( tasks ) <NL> <TAB> _ , <SPC> max_count <SPC> = <SPC> counter . most_common ( 1 ) [ 0 ] <NL> <NL> <TAB> result <SPC> = <SPC> ( max_count <SPC> - <SPC> 1 ) <SPC> * <SPC> ( n <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> count <SPC> in <SPC> counter . values ( ) : <NL>          if <SPC> count <SPC> == <SPC> max_count : <NL>              result <SPC> += <SPC> 1 <NL> <TAB> return <SPC> max ( result , <SPC> len ( tasks ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findPoisonedDuration ( self , <SPC> timeSeries , <SPC> duration ) : <NL> <NL> <TAB> result <SPC> = <SPC> duration <SPC> * <SPC> len ( timeSeries ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( timeSeries ) ) : <NL>          result <SPC> -= <SPC> max ( 0 , <SPC> duration <SPC> - <SPC> ( timeSeries [ i ] <SPC> - <SPC> timeSeries [ i <SPC> - <SPC> 1 ] ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> parseTernary ( self , <SPC> expression ) : <NL> <NL> <TAB> if <SPC> not <SPC> expression : <NL>          return <SPC> "" <NL> <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> expression [ : : - 1 ] : <NL>          if <SPC> stack <SPC> and <SPC> stack [ - 1 ] <SPC> == <SPC> "?" : <NL>              stack . pop ( ) <NL>              first <SPC> = <SPC> stack . pop ( ) <NL>              stack . pop ( ) <NL>              second <SPC> = <SPC> stack . pop ( ) <NL> <NL>              if <SPC> c <SPC> == <SPC> "T" : <NL>                  stack . append ( first ) <NL>              else : <NL>                  stack . append ( second ) <NL>          else : <NL>              stack . append ( c ) <NL> <NL> <TAB> return <SPC> str ( stack [ - 1 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> fullJustify ( self , <SPC> words , <SPC> maxWidth ) : <NL> <NL> <TAB> def <SPC> addSpaces ( i , <SPC> spaceCnt , <SPC> maxWidth , <SPC> is_last ) : <NL>          if <SPC> i <SPC> < <SPC> spaceCnt : <NL> <NL>              return <SPC> ( <NL>                  1 <NL>                  if <SPC> is_last <NL>                  else <SPC> ( maxWidth <SPC> // <SPC> spaceCnt ) <SPC> + <SPC> int ( i <SPC> < <SPC> maxWidth <SPC> % <SPC> spaceCnt ) <NL>              ) <NL>          return <SPC> 0 <NL> <NL> <TAB> def <SPC> connect ( words , <SPC> maxWidth , <SPC> begin , <SPC> end , <SPC> length , <SPC> is_last ) : <NL>          s <SPC> = <SPC> [ ] <NL>          n <SPC> = <SPC> end <SPC> - <SPC> begin <NL>          for <SPC> i <SPC> in <SPC> xrange ( n ) : <NL>              s <SPC> += <SPC> ( words [ begin <SPC> + <SPC> i ] , ) <NL>              s <SPC> += <SPC> ( " " <SPC> * <SPC> addSpaces ( i , <SPC> n <SPC> - <SPC> 1 , <SPC> maxWidth <SPC> - <SPC> length , <SPC> is_last ) , ) <NL> <NL>          line <SPC> = <SPC> "" . join ( s ) <NL>          if <SPC> len ( line ) <SPC> < <SPC> maxWidth : <NL>              line <SPC> += <SPC> " " <SPC> * <SPC> ( maxWidth <SPC> - <SPC> len ( line ) ) <NL>          return <SPC> line <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> begin , <SPC> length <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) ) : <NL>          if <SPC> length <SPC> + <SPC> len ( words [ i ] ) <SPC> + <SPC> ( i <SPC> - <SPC> begin ) <SPC> > <SPC> maxWidth : <NL>              res <SPC> += <SPC> ( connect ( words , <SPC> maxWidth , <SPC> begin , <SPC> i , <SPC> length , <SPC> False ) , ) <NL>              begin , <SPC> length <SPC> = <SPC> i , <SPC> 0 <NL>          length <SPC> += <SPC> len ( words [ i ] ) <NL> <NL> <TAB> res <SPC> += <SPC> ( connect ( words , <SPC> maxWidth , <SPC> begin , <SPC> len ( words ) , <SPC> length , <SPC> True ) , ) <NL> <TAB> return <SPC> res <NL> <NL> <NL> import <SPC> threading <NL> <NL> <NL> class <SPC> DiningPhilosophers ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . _l <SPC> = <SPC> [ threading . Lock ( ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 5 ) ] <NL> <NL> <TAB> def <SPC> wantsToEat ( <NL>          self , <SPC> philosopher , <SPC> pickLeftFork , <SPC> pickRightFork , <SPC> eat , <SPC> putLeftFork , <SPC> putRightFork <NL> <TAB> ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> philosopher , <SPC> ( philosopher <SPC> + <SPC> 4 ) <SPC> % <SPC> 5 <NL> <TAB> first , <SPC> second <SPC> = <SPC> left , <SPC> right <NL> <TAB> if <SPC> philosopher <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>          first , <SPC> second <SPC> = <SPC> left , <SPC> right <NL> <TAB> else : <NL>          first , <SPC> second <SPC> = <SPC> right , <SPC> left <NL> <NL> <TAB> with <SPC> self . _l [ first ] : <NL>          with <SPC> self . _l [ second ] : <NL>              pickLeftFork ( ) <NL>              pickRightFork ( ) <NL>              eat ( ) <NL>              putLeftFork ( ) <NL>              putRightFork ( ) <NL> <NL> <NL> class <SPC> UnionFind ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> n ) : <NL> <TAB> self . set <SPC> = <SPC> range ( n ) <NL> <TAB> self . count <SPC> = <SPC> n <NL> <NL> <TAB> def <SPC> find_set ( self , <SPC> x ) : <NL> <TAB> if <SPC> self . set [ x ] <SPC> != <SPC> x : <NL>          self . set [ x ] <SPC> = <SPC> self . find_set ( self . set [ x ] ) <NL> <TAB> return <SPC> self . set [ x ] <NL> <NL> <TAB> def <SPC> union_set ( self , <SPC> x , <SPC> y ) : <NL> <TAB> x_root , <SPC> y_root <SPC> = <SPC> map ( self . find_set , <SPC> ( x , <SPC> y ) ) <NL> <TAB> if <SPC> x_root <SPC> == <SPC> y_root : <NL>          return <SPC> False <NL> <TAB> self . set [ max ( x_root , <SPC> y_root ) ] <SPC> = <SPC> min ( x_root , <SPC> y_root ) <NL> <TAB> self . count <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> earliestAcq ( self , <SPC> logs , <SPC> N ) : <NL> <NL> <TAB> logs . sort ( ) <NL> <TAB> union_find <SPC> = <SPC> UnionFind ( N ) <NL> <TAB> for <SPC> t , <SPC> a , <SPC> b <SPC> in <SPC> logs : <NL>          union_find . union_set ( a , <SPC> b ) <NL>          if <SPC> union_find . count <SPC> == <SPC> 1 : <NL>              return <SPC> t <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getStrongest ( self , <SPC> arr , <SPC> k ) : <NL> <NL> <TAB> arr . sort ( ) <NL> <TAB> m <SPC> = <SPC> arr [ ( len ( arr ) <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 ] <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( arr ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> len ( result ) <SPC> < <SPC> k : <NL>          if <SPC> m <SPC> - <SPC> arr [ left ] <SPC> > <SPC> arr [ right ] <SPC> - <SPC> m : <NL>              result . append ( arr [ left ] ) <NL>              left <SPC> += <SPC> 1 <NL>          else : <NL>              result . append ( arr [ right ] ) <NL>              right <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> getStrongest ( self , <SPC> arr , <SPC> k ) : <NL> <NL> <TAB> arr . sort ( ) <NL> <TAB> m <SPC> = <SPC> arr [ ( len ( arr ) <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 ] <NL> <TAB> arr . sort ( key = lambda <SPC> x : <SPC> ( - abs ( x <SPC> - <SPC> m ) , <SPC> - x ) ) <NL> <TAB> return <SPC> arr [ : k ] <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution_TLE ( object ) : <NL> <TAB> def <SPC> getStrongest ( self , <SPC> arr , <SPC> k ) : <NL> <NL> <TAB> def <SPC> nth_element ( nums , <SPC> n , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) : <NL>          def <SPC> partition_around_pivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare ) : <NL>              new_pivot_idx <SPC> = <SPC> left <NL>              nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>                  if <SPC> compare ( nums [ i ] , <SPC> nums [ right ] ) : <NL>                      nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                      new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>              nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>              return <SPC> new_pivot_idx <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> partition_around_pivot ( <NL>                  left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare <NL>              ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> n : <NL>                  return <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> n : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> nth_element ( arr , <SPC> ( len ( arr ) <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 ) <NL> <TAB> m <SPC> = <SPC> arr [ ( len ( arr ) <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 ] <NL> <TAB> nth_element ( <NL>          arr , <NL>          k , <NL>          lambda <SPC> a , <SPC> b : <SPC> abs ( a <SPC> - <SPC> m ) <SPC> > <SPC> abs ( b <SPC> - <SPC> m ) <SPC> if <SPC> abs ( a <SPC> - <NL>                                                      m ) <SPC> != <SPC> abs ( b <SPC> - <SPC> m ) <SPC> else <SPC> a <SPC> > <SPC> b , <NL> <TAB> ) <NL> <TAB> return <SPC> arr [ : k ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getHappyString ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> base <SPC> = <SPC> 2 <SPC> ** <SPC> ( n <SPC> - <SPC> 1 ) <NL> <TAB> if <SPC> k <SPC> > <SPC> 3 <SPC> * <SPC> base : <NL>          return <SPC> "" <NL> <TAB> result <SPC> = <SPC> [ chr ( ord ( "a" ) <SPC> + <SPC> ( k <SPC> - <SPC> 1 ) <SPC> // <SPC> base ) ] <NL> <TAB> while <SPC> base <SPC> > <SPC> 1 : <NL>          k <SPC> -= <SPC> ( k <SPC> - <SPC> 1 ) <SPC> // <SPC> base <SPC> * <SPC> base <NL>          base <SPC> //= <SPC> 2 <NL>          result . append ( <NL>              ( "a" <SPC> if <SPC> result [ - 1 ] <SPC> != <SPC> "a" <SPC> else <SPC> "b" ) <NL>              if <SPC> ( k <SPC> - <SPC> 1 ) <SPC> // <SPC> base <SPC> == <SPC> 0 <NL>              else <SPC> ( "c" <SPC> if <SPC> result [ - 1 ] <SPC> != <SPC> "c" <SPC> else <SPC> "b" ) <NL>          ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kWeakestRows ( self , <SPC> mat , <SPC> k ) : <NL> <NL> <TAB> result , <SPC> lookup <SPC> = <SPC> [ ] , <SPC> set ( ) <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( mat [ 0 ] ) ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( mat ) ) : <NL>              if <SPC> mat [ i ] [ j ] <SPC> or <SPC> i <SPC> in <SPC> lookup : <NL>                  continue <NL>              lookup . add ( i ) <NL>              result . append ( i ) <NL>              if <SPC> len ( result ) <SPC> == <SPC> k : <NL>                  return <SPC> result <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( mat ) ) : <NL>          if <SPC> i <SPC> in <SPC> lookup : <NL>              continue <NL>          lookup . add ( i ) <NL>          result . append ( i ) <NL>          if <SPC> len ( result ) <SPC> == <SPC> k : <NL>              break <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> kWeakestRows ( self , <SPC> mat , <SPC> k ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . OrderedDict ( ) <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( len ( mat [ 0 ] ) ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( mat ) ) : <NL>              if <SPC> mat [ i ] [ j ] <SPC> or <SPC> i <SPC> in <SPC> lookup : <NL>                  continue <NL>              lookup [ i ] <SPC> = <SPC> True <NL>              if <SPC> len ( lookup ) <SPC> == <SPC> k : <NL>                  return <SPC> lookup . keys ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( mat ) ) : <NL>          if <SPC> i <SPC> in <SPC> lookup : <NL>              continue <NL>          lookup [ i ] <SPC> = <SPC> True <NL>          if <SPC> len ( lookup ) <SPC> == <SPC> k : <NL>              break <NL> <TAB> return <SPC> lookup . keys ( ) <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> kWeakestRows ( self , <SPC> mat , <SPC> k ) : <NL> <NL> <TAB> def <SPC> nth_element ( nums , <SPC> n , <SPC> compare = lambda <SPC> a , <SPC> b : <SPC> a <SPC> < <SPC> b ) : <NL>          def <SPC> partition_around_pivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare ) : <NL>              new_pivot_idx <SPC> = <SPC> left <NL>              nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>                  if <SPC> compare ( nums [ i ] , <SPC> nums [ right ] ) : <NL>                      nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                      new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>              nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>              return <SPC> new_pivot_idx <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> partition_around_pivot ( <NL>                  left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare <NL>              ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> n : <NL>                  return <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> n : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> nums <SPC> = <SPC> [ ( sum ( mat [ i ] ) , <SPC> i ) <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( mat ) ) ] <NL> <TAB> nth_element ( nums , <SPC> k ) <NL> <TAB> return <SPC> map ( lambda <SPC> x : <SPC> x [ 1 ] , <SPC> sorted ( nums [ : k ] ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> kthFactor ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> def <SPC> kth_factor ( n , <SPC> k = 0 ) : <NL>          mid <SPC> = <SPC> None <NL>          i <SPC> = <SPC> 1 <NL>          while <SPC> i <SPC> * <SPC> i <SPC> <= <SPC> n : <NL>              if <SPC> not <SPC> n <SPC> % <SPC> i : <NL>                  mid <SPC> = <SPC> i <NL>                  k <SPC> -= <SPC> 1 <NL>                  if <SPC> not <SPC> k : <NL>                      break <NL>              i <SPC> += <SPC> 1 <NL>          return <SPC> mid , <SPC> - k <NL> <NL> <TAB> mid , <SPC> count <SPC> = <SPC> kth_factor ( n ) <NL> <TAB> total <SPC> = <SPC> 2 <SPC> * <SPC> count <SPC> - <SPC> ( mid <SPC> * <SPC> mid <SPC> == <SPC> n ) <NL> <TAB> if <SPC> k <SPC> > <SPC> total : <NL>          return <SPC> - 1 <NL> <TAB> result <SPC> = <SPC> kth_factor ( n , <SPC> k <SPC> if <SPC> k <SPC> <= <SPC> count <SPC> else <SPC> total <SPC> - <SPC> ( k <SPC> - <SPC> 1 ) ) [ 0 ] <NL> <TAB> return <SPC> result <SPC> if <SPC> k <SPC> <= <SPC> count <SPC> else <SPC> n <SPC> // <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> kthFactor ( self , <SPC> n , <SPC> k ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> i <SPC> = <SPC> 1 <NL> <TAB> while <SPC> i <SPC> * <SPC> i <SPC> <= <SPC> n : <NL>          if <SPC> not <SPC> n <SPC> % <SPC> i : <NL>              if <SPC> i <SPC> * <SPC> i <SPC> != <SPC> n : <NL>                  result . append ( i ) <NL>              k <SPC> -= <SPC> 1 <NL>              if <SPC> not <SPC> k : <NL>                  return <SPC> i <NL>          i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> - 1 <SPC> if <SPC> k <SPC> > <SPC> len ( result ) <SPC> else <SPC> n <SPC> // <SPC> result [ - k ] <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> shortestDistance ( self , <SPC> maze , <SPC> start , <SPC> destination ) : <NL> <NL> <TAB> start , <SPC> destination <SPC> = <SPC> tuple ( start ) , <SPC> tuple ( destination ) <NL> <NL> <TAB> def <SPC> neighbors ( maze , <SPC> node ) : <NL>          for <SPC> dir <SPC> in <SPC> [ ( - 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 1 , <SPC> 0 ) ] : <NL>              cur_node , <SPC> dist <SPC> = <SPC> list ( node ) , <SPC> 0 <NL>              while <SPC> ( <NL>                  0 <SPC> <= <SPC> cur_node [ 0 ] <SPC> + <SPC> dir [ 0 ] <SPC> < <SPC> len ( maze ) <NL>                  and <SPC> 0 <SPC> <= <SPC> cur_node [ 1 ] <SPC> + <SPC> dir [ 1 ] <SPC> < <SPC> len ( maze [ 0 ] ) <NL>                  and <SPC> not <SPC> maze [ cur_node [ 0 ] <SPC> + <SPC> dir [ 0 ] ] [ cur_node [ 1 ] <SPC> + <SPC> dir [ 1 ] ] <NL>              ) : <NL>                  cur_node [ 0 ] <SPC> += <SPC> dir [ 0 ] <NL>                  cur_node [ 1 ] <SPC> += <SPC> dir [ 1 ] <NL>                  dist <SPC> += <SPC> 1 <NL>              yield <SPC> dist , <SPC> tuple ( cur_node ) <NL> <NL> <TAB> heap <SPC> = <SPC> [ ( 0 , <SPC> start ) ] <NL> <TAB> visited <SPC> = <SPC> set ( ) <NL> <TAB> while <SPC> heap : <NL>          dist , <SPC> node <SPC> = <SPC> heapq . heappop ( heap ) <NL>          if <SPC> node <SPC> in <SPC> visited : <NL>              continue <NL>          if <SPC> node <SPC> == <SPC> destination : <NL>              return <SPC> dist <NL>          visited . add ( node ) <NL>          for <SPC> neighbor_dist , <SPC> neighbor <SPC> in <SPC> neighbors ( maze , <SPC> node ) : <NL>              heapq . heappush ( heap , <SPC> ( dist <SPC> + <SPC> neighbor_dist , <SPC> neighbor ) ) <NL> <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findShortestWay ( self , <SPC> maze , <SPC> ball , <SPC> hole ) : <NL> <NL> <TAB> ball , <SPC> hole <SPC> = <SPC> tuple ( ball ) , <SPC> tuple ( hole ) <NL> <TAB> dirs <SPC> = <SPC> { "u" : <SPC> ( - 1 , <SPC> 0 ) , <SPC> "r" : <SPC> ( 0 , <SPC> 1 ) , <SPC> "l" : <SPC> ( 0 , <SPC> - 1 ) , <SPC> "d" : <SPC> ( 1 , <SPC> 0 ) } <NL> <NL> <TAB> def <SPC> neighbors ( maze , <SPC> node ) : <NL>          for <SPC> dir , <SPC> vec <SPC> in <SPC> dirs . iteritems ( ) : <NL>              cur_node , <SPC> dist <SPC> = <SPC> list ( node ) , <SPC> 0 <NL>              while <SPC> ( <NL>                  0 <SPC> <= <SPC> cur_node [ 0 ] <SPC> + <SPC> vec [ 0 ] <SPC> < <SPC> len ( maze ) <NL>                  and <SPC> 0 <SPC> <= <SPC> cur_node [ 1 ] <SPC> + <SPC> vec [ 1 ] <SPC> < <SPC> len ( maze [ 0 ] ) <NL>                  and <SPC> not <SPC> maze [ cur_node [ 0 ] <SPC> + <SPC> vec [ 0 ] ] [ cur_node [ 1 ] <SPC> + <SPC> vec [ 1 ] ] <NL>              ) : <NL>                  cur_node [ 0 ] <SPC> += <SPC> vec [ 0 ] <NL>                  cur_node [ 1 ] <SPC> += <SPC> vec [ 1 ] <NL>                  dist <SPC> += <SPC> 1 <NL>                  if <SPC> tuple ( cur_node ) <SPC> == <SPC> hole : <NL>                      break <NL>              yield <SPC> tuple ( cur_node ) , <SPC> dir , <SPC> dist <NL> <NL> <TAB> heap <SPC> = <SPC> [ ( 0 , <SPC> "" , <SPC> ball ) ] <NL> <TAB> visited <SPC> = <SPC> set ( ) <NL> <TAB> while <SPC> heap : <NL>          dist , <SPC> path , <SPC> node <SPC> = <SPC> heapq . heappop ( heap ) <NL>          if <SPC> node <SPC> in <SPC> visited : <NL>              continue <NL>          if <SPC> node <SPC> == <SPC> hole : <NL>              return <SPC> path <NL>          visited . add ( node ) <NL>          for <SPC> neighbor , <SPC> dir , <SPC> neighbor_dist <SPC> in <SPC> neighbors ( maze , <SPC> node ) : <NL>              heapq . heappush ( heap , <SPC> ( dist <SPC> + <SPC> neighbor_dist , <SPC> path <SPC> + <SPC> dir , <SPC> neighbor ) ) <NL> <NL> <TAB> return <SPC> "impossible" <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> hasPath ( self , <SPC> maze , <SPC> start , <SPC> destination ) : <NL> <NL> <TAB> def <SPC> neighbors ( maze , <SPC> node ) : <NL>          for <SPC> i , <SPC> j <SPC> in <SPC> [ ( - 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( 1 , <SPC> 0 ) ] : <NL>              x , <SPC> y <SPC> = <SPC> node <NL>              while <SPC> ( <NL>                  0 <SPC> <= <SPC> x <SPC> + <SPC> i <SPC> < <SPC> len ( maze ) <NL>                  and <SPC> 0 <SPC> <= <SPC> y <SPC> + <SPC> j <SPC> < <SPC> len ( maze [ 0 ] ) <NL>                  and <SPC> not <SPC> maze [ x <SPC> + <SPC> i ] [ y <SPC> + <SPC> j ] <NL>              ) : <NL>                  x <SPC> += <SPC> i <NL>                  y <SPC> += <SPC> j <NL>              yield <SPC> x , <SPC> y <NL> <NL> <TAB> start , <SPC> destination <SPC> = <SPC> tuple ( start ) , <SPC> tuple ( destination ) <NL> <TAB> queue <SPC> = <SPC> collections . deque ( [ start ] ) <NL> <TAB> visited <SPC> = <SPC> set ( ) <NL> <TAB> while <SPC> queue : <NL>          node <SPC> = <SPC> queue . popleft ( ) <NL>          if <SPC> node <SPC> in <SPC> visited : <NL>              continue <NL>          if <SPC> node <SPC> == <SPC> destination : <NL>              return <SPC> True <NL>          visited . add ( node ) <NL>          for <SPC> neighbor <SPC> in <SPC> neighbors ( maze , <SPC> node ) : <NL>              queue . append ( neighbor ) <NL> <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> mostSimilar ( self , <SPC> n , <SPC> roads , <SPC> names , <SPC> targetPath ) : <NL> <NL> <TAB> adj <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> roads : <NL>          adj [ u ] . append ( v ) <NL>          adj [ v ] . append ( u ) <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( targetPath ) <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( targetPath ) <SPC> + <SPC> 1 ) : <NL>          for <SPC> v <SPC> in <SPC> xrange ( n ) : <NL>              dp [ i ] [ v ] <SPC> = <SPC> ( names [ v ] <SPC> != <SPC> targetPath [ i <SPC> - <SPC> 1 ] ) <SPC> + <SPC> min ( <NL>                  dp [ i <SPC> - <SPC> 1 ] [ u ] <SPC> for <SPC> u <SPC> in <SPC> adj [ v ] <NL>              ) <NL> <NL> <TAB> path <SPC> = <SPC> [ dp [ - 1 ] . index ( min ( dp [ - 1 ] ) ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 2 , <SPC> len ( targetPath ) <SPC> + <SPC> 1 ) ) : <NL>          for <SPC> u <SPC> in <SPC> adj [ path [ - 1 ] ] : <NL>              if <SPC> ( <NL>                  dp [ i <SPC> - <SPC> 1 ] [ u ] <SPC> + <SPC> ( names [ path [ - 1 ] ] <SPC> != <SPC> targetPath [ i <SPC> - <SPC> 1 ] ) <NL>                  == <SPC> dp [ i ] [ path [ - 1 ] ] <NL>              ) : <NL>                  path . append ( u ) <NL>                  break <NL> <TAB> return <SPC> path [ : : - 1 ] <NL> <NL> <NL> start , <SPC> end , <SPC> height <SPC> = <SPC> 0 , <SPC> 1 , <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> getSkyline ( self , <SPC> buildings ) : <NL> <TAB> intervals <SPC> = <SPC> self . ComputeSkylineInInterval ( buildings , <SPC> 0 , <SPC> len ( buildings ) ) <NL> <NL> <TAB> res <SPC> = <SPC> [ ] <NL> <TAB> last_end <SPC> = <SPC> - 1 <NL> <TAB> for <SPC> interval <SPC> in <SPC> intervals : <NL>          if <SPC> last_end <SPC> != <SPC> - 1 <SPC> and <SPC> last_end <SPC> < <SPC> interval [ start ] : <NL>              res . append ( [ last_end , <SPC> 0 ] ) <NL>          res . append ( [ interval [ start ] , <SPC> interval [ height ] ] ) <NL>          last_end <SPC> = <SPC> interval [ end ] <NL> <TAB> if <SPC> last_end <SPC> != <SPC> - 1 : <NL>          res . append ( [ last_end , <SPC> 0 ] ) <NL> <NL> <TAB> return <SPC> res <NL> <NL> <TAB> def <SPC> ComputeSkylineInInterval ( self , <SPC> buildings , <SPC> left_endpoint , <SPC> right_endpoint ) : <NL> <TAB> if <SPC> right_endpoint <SPC> - <SPC> left_endpoint <SPC> <= <SPC> 1 : <NL>          return <SPC> buildings [ left_endpoint : right_endpoint ] <NL> <TAB> mid <SPC> = <SPC> left_endpoint <SPC> + <SPC> ( ( right_endpoint <SPC> - <SPC> left_endpoint ) <SPC> / <SPC> 2 ) <NL> <TAB> left_skyline <SPC> = <SPC> self . ComputeSkylineInInterval ( buildings , <SPC> left_endpoint , <SPC> mid ) <NL> <TAB> right_skyline <SPC> = <SPC> self . ComputeSkylineInInterval ( <NL>          buildings , <SPC> mid , <SPC> right_endpoint ) <NL> <TAB> return <SPC> self . MergeSkylines ( left_skyline , <SPC> right_skyline ) <NL> <NL> <TAB> def <SPC> MergeSkylines ( self , <SPC> left_skyline , <SPC> right_skyline ) : <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> merged <SPC> = <SPC> [ ] <NL> <NL> <TAB> while <SPC> i <SPC> < <SPC> len ( left_skyline ) <SPC> and <SPC> j <SPC> < <SPC> len ( right_skyline ) : <NL>          if <SPC> left_skyline [ i ] [ end ] <SPC> < <SPC> right_skyline [ j ] [ start ] : <NL>              merged . append ( left_skyline [ i ] ) <NL>              i <SPC> += <SPC> 1 <NL>          elif <SPC> right_skyline [ j ] [ end ] <SPC> < <SPC> left_skyline [ i ] [ start ] : <NL>              merged . append ( right_skyline [ j ] ) <NL>              j <SPC> += <SPC> 1 <NL>          elif <SPC> left_skyline [ i ] [ start ] <SPC> <= <SPC> right_skyline [ j ] [ start ] : <NL>              i , <SPC> j <SPC> = <SPC> self . MergeIntersectSkylines ( <NL>                  merged , <SPC> left_skyline [ i ] , <SPC> i , <SPC> right_skyline [ j ] , <SPC> j <NL>              ) <NL>          else : <NL>              j , <SPC> i <SPC> = <SPC> self . MergeIntersectSkylines ( <NL>                  merged , <SPC> right_skyline [ j ] , <SPC> j , <SPC> left_skyline [ i ] , <SPC> i <NL>              ) <NL> <NL> <TAB> merged <SPC> += <SPC> left_skyline [ i : ] <NL> <TAB> merged <SPC> += <SPC> right_skyline [ j : ] <NL> <TAB> return <SPC> merged <NL> <NL> <TAB> def <SPC> MergeIntersectSkylines ( self , <SPC> merged , <SPC> a , <SPC> a_idx , <SPC> b , <SPC> b_idx ) : <NL> <TAB> if <SPC> a [ end ] <SPC> <= <SPC> b [ end ] : <NL>          if <SPC> a [ height ] <SPC> > <SPC> b [ height ] : <NL>              if <SPC> b [ end ] <SPC> != <SPC> a [ end ] : <NL>                  b [ start ] <SPC> = <SPC> a [ end ] <NL>                  merged . append ( a ) <NL>                  a_idx <SPC> += <SPC> 1 <NL>              else : <NL>                  b_idx <SPC> += <SPC> 1 <NL>          elif <SPC> a [ height ] <SPC> == <SPC> b [ height ] : <NL>              b [ start ] <SPC> = <SPC> a [ start ] <NL>              a_idx <SPC> += <SPC> 1 <NL>          else : <NL>              if <SPC> a [ start ] <SPC> != <SPC> b [ start ] : <NL>                  merged . append ( [ a [ start ] , <SPC> b [ start ] , <SPC> a [ height ] ] ) <NL>              a_idx <SPC> += <SPC> 1 <NL> <TAB> else : <NL>          if <SPC> a [ height ] <SPC> >= <SPC> b [ height ] : <NL>              b_idx <SPC> += <SPC> 1 <NL>          else : <NL> <NL>              if <SPC> a [ start ] <SPC> != <SPC> b [ start ] : <NL>                  merged . append ( [ a [ start ] , <SPC> b [ start ] , <SPC> a [ height ] ] ) <NL>              a [ start ] <SPC> = <SPC> b [ end ] <NL>              merged . append ( b ) <NL>              b_idx <SPC> += <SPC> 1 <NL> <TAB> return <SPC> a_idx , <SPC> b_idx <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> thirdMax ( self , <SPC> nums ) : <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> top <SPC> = <SPC> [ float ( "-inf" ) ] <SPC> * <SPC> 3 <NL> <TAB> for <SPC> num <SPC> in <SPC> nums : <NL>          if <SPC> num <SPC> > <SPC> top [ 0 ] : <NL>              top [ 0 ] , <SPC> top [ 1 ] , <SPC> top [ 2 ] <SPC> = <SPC> num , <SPC> top [ 0 ] , <SPC> top [ 1 ] <NL>              count <SPC> += <SPC> 1 <NL>          elif <SPC> num <SPC> != <SPC> top [ 0 ] <SPC> and <SPC> num <SPC> > <SPC> top [ 1 ] : <NL>              top [ 1 ] , <SPC> top [ 2 ] <SPC> = <SPC> num , <SPC> top [ 1 ] <NL>              count <SPC> += <SPC> 1 <NL>          elif <SPC> num <SPC> != <SPC> top [ 0 ] <SPC> and <SPC> num <SPC> != <SPC> top [ 1 ] <SPC> and <SPC> num <SPC> >= <SPC> top [ 2 ] : <NL>              top [ 2 ] <SPC> = <SPC> num <NL>              count <SPC> += <SPC> 1 <NL> <NL> <TAB> if <SPC> count <SPC> < <SPC> 3 : <NL>          return <SPC> top [ 0 ] <NL> <NL> <TAB> return <SPC> top [ 2 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> thousandSeparator ( self , <SPC> n ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> s <SPC> = <SPC> str ( n ) <NL> <TAB> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( str ( n ) ) : <NL>          if <SPC> i <SPC> and <SPC> ( len ( s ) <SPC> - <SPC> i ) <SPC> % <SPC> 3 <SPC> == <SPC> 0 : <NL>              result . append ( "." ) <NL>          result . append ( c ) <NL> <TAB> return <SPC> "" . join ( result ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> threeConsecutiveOdds ( self , <SPC> arr ) : <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> x <SPC> in <SPC> arr : <NL>          count <SPC> = <SPC> count <SPC> + <SPC> 1 <SPC> if <SPC> x <SPC> % <SPC> 2 <SPC> else <SPC> 0 <NL>          if <SPC> count <SPC> == <SPC> 3 : <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> threeEqualParts ( self , <SPC> A ) : <NL> <NL> <TAB> total <SPC> = <SPC> sum ( A ) <NL> <TAB> if <SPC> total <SPC> % <SPC> 3 <SPC> != <SPC> 0 : <NL>          return <SPC> [ - 1 , <SPC> - 1 ] <NL> <TAB> if <SPC> total <SPC> == <SPC> 0 : <NL>          return <SPC> [ 0 , <SPC> len ( A ) <SPC> - <SPC> 1 ] <NL> <NL> <TAB> count <SPC> = <SPC> total <SPC> // <SPC> 3 <NL> <TAB> nums <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 3 <NL> <TAB> c <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          if <SPC> A [ i ] <SPC> == <SPC> 1 : <NL>              if <SPC> c <SPC> % <SPC> count <SPC> == <SPC> 0 : <NL>                  nums [ c <SPC> // <SPC> count ] <SPC> = <SPC> i <NL>              c <SPC> += <SPC> 1 <NL> <NL> <TAB> while <SPC> nums [ 2 ] <SPC> != <SPC> len ( A ) : <NL>          if <SPC> not <SPC> A [ nums [ 0 ] ] <SPC> == <SPC> A [ nums [ 1 ] ] <SPC> == <SPC> A [ nums [ 2 ] ] : <NL>              return <SPC> [ - 1 , <SPC> - 1 ] <NL>          nums [ 0 ] <SPC> += <SPC> 1 <NL>          nums [ 1 ] <SPC> += <SPC> 1 <NL>          nums [ 2 ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> [ nums [ 0 ] <SPC> - <SPC> 1 , <SPC> nums [ 1 ] ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> ThroneInheritance ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> kingName ) : <NL> <NL> <TAB> self . __king <SPC> = <SPC> kingName <NL> <TAB> self . __family_tree <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> self . __dead <SPC> = <SPC> set ( ) <NL> <NL> <TAB> def <SPC> birth ( self , <SPC> parentName , <SPC> childName ) : <NL> <NL> <TAB> self . __family_tree [ parentName ] . append ( childName ) <NL> <NL> <TAB> def <SPC> death ( self , <SPC> name ) : <NL> <NL> <TAB> self . __dead . add ( name ) <NL> <NL> <TAB> def <SPC> getInheritanceOrder ( self ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> stk <SPC> = <SPC> [ self . __king ] <NL> <TAB> while <SPC> stk : <NL>          node <SPC> = <SPC> stk . pop ( ) <NL>          if <SPC> node <SPC> not <SPC> in <SPC> self . __dead : <NL>              result . append ( node ) <NL>          if <SPC> node <SPC> not <SPC> in <SPC> self . __family_tree : <NL>              continue <NL>          for <SPC> child <SPC> in <SPC> reversed ( self . __family_tree [ node ] ) : <NL>              stk . append ( child ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> tilingRectangle ( self , <SPC> n , <SPC> m ) : <NL> <NL> <TAB> def <SPC> find_next ( board ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( board ) ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( board [ 0 ] ) ) : <NL>                  if <SPC> not <SPC> board [ i ] [ j ] : <NL>                      return <SPC> i , <SPC> j <NL>          return <SPC> - 1 , <SPC> - 1 <NL> <NL> <TAB> def <SPC> find_max_length ( board , <SPC> i , <SPC> j ) : <NL>          max_length <SPC> = <SPC> 1 <NL>          while <SPC> i <SPC> + <SPC> max_length <SPC> - <SPC> 1 <SPC> < <SPC> len ( board ) <SPC> and <SPC> j <SPC> + <SPC> max_length <SPC> - <SPC> 1 <SPC> < <SPC> len ( <NL>              board [ 0 ] <NL>          ) : <NL>              for <SPC> r <SPC> in <SPC> xrange ( i , <SPC> i <SPC> + <SPC> max_length <SPC> - <SPC> 1 ) : <NL>                  if <SPC> board [ r ] [ j <SPC> + <SPC> max_length <SPC> - <SPC> 1 ] : <NL>                      return <SPC> max_length <SPC> - <SPC> 1 <NL>              for <SPC> c <SPC> in <SPC> xrange ( j , <SPC> j <SPC> + <SPC> max_length ) : <NL>                  if <SPC> board [ i <SPC> + <SPC> max_length <SPC> - <SPC> 1 ] [ c ] : <NL>                      return <SPC> max_length <SPC> - <SPC> 1 <NL>              max_length <SPC> += <SPC> 1 <NL>          return <SPC> max_length <SPC> - <SPC> 1 <NL> <NL> <TAB> def <SPC> fill ( board , <SPC> i , <SPC> j , <SPC> length , <SPC> val ) : <NL>          for <SPC> r <SPC> in <SPC> xrange ( i , <SPC> i <SPC> + <SPC> length ) : <NL>              for <SPC> c <SPC> in <SPC> xrange ( j , <SPC> j <SPC> + <SPC> length ) : <NL>                  board [ r ] [ c ] <SPC> = <SPC> val <NL> <NL> <TAB> def <SPC> backtracking ( board , <SPC> count , <SPC> result ) : <NL>          if <SPC> count <SPC> >= <SPC> result [ 0 ] : <NL>              return <NL>          i , <SPC> j <SPC> = <SPC> find_next ( board ) <NL>          if <SPC> ( i , <SPC> j ) <SPC> == <SPC> ( - 1 , <SPC> - 1 ) : <NL>              result [ 0 ] <SPC> = <SPC> min ( result [ 0 ] , <SPC> count ) <NL>              return <NL>          max_length <SPC> = <SPC> find_max_length ( board , <SPC> i , <SPC> j ) <NL>          for <SPC> k <SPC> in <SPC> reversed ( xrange ( 1 , <SPC> max_length <SPC> + <SPC> 1 ) ) : <NL>              fill ( board , <SPC> i , <SPC> j , <SPC> k , <SPC> 1 ) <NL>              backtracking ( board , <SPC> count <SPC> + <SPC> 1 , <SPC> result ) <NL>              fill ( board , <SPC> i , <SPC> j , <SPC> k , <SPC> 0 ) <NL> <NL> <TAB> if <SPC> m <SPC> > <SPC> n : <NL>          return <SPC> self . tilingRectangle ( m , <SPC> n ) <NL> <TAB> board <SPC> = <SPC> [ [ 0 ] <SPC> * <SPC> m <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> result <SPC> = <SPC> [ float ( "inf" ) ] <NL> <TAB> backtracking ( board , <SPC> 0 , <SPC> result ) <NL> <TAB> return <SPC> result [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> TimeMap ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . lookup <SPC> = <SPC> collections . defaultdict ( list ) <NL> <NL> <TAB> def <SPC> set ( self , <SPC> key , <SPC> value , <SPC> timestamp ) : <NL> <NL> <TAB> self . lookup [ key ] . append ( ( timestamp , <SPC> value ) ) <NL> <NL> <TAB> def <SPC> get ( self , <SPC> key , <SPC> timestamp ) : <NL> <NL> <TAB> A <SPC> = <SPC> self . lookup . get ( key , <SPC> None ) <NL> <TAB> if <SPC> A <SPC> is <SPC> None : <NL>          return <SPC> "" <NL> <TAB> i <SPC> = <SPC> bisect . bisect_right ( A , <SPC> ( timestamp <SPC> + <SPC> 1 , <SPC> 0 ) ) <NL> <TAB> return <SPC> A [ i <SPC> - <SPC> 1 ] [ 1 ] <SPC> if <SPC> i <SPC> else <SPC> "" <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numOfMinutes ( self , <SPC> n , <SPC> headID , <SPC> manager , <SPC> informTime ) : <NL> <NL> <TAB> children <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> child , <SPC> parent <SPC> in <SPC> enumerate ( manager ) : <NL>          if <SPC> parent <SPC> != <SPC> - 1 : <NL>              children [ parent ] . append ( child ) <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> stk <SPC> = <SPC> [ ( headID , <SPC> 0 ) ] <NL> <TAB> while <SPC> stk : <NL>          node , <SPC> curr <SPC> = <SPC> stk . pop ( ) <NL>          curr <SPC> += <SPC> informTime [ node ] <NL>          result <SPC> = <SPC> max ( result , <SPC> curr ) <NL>          if <SPC> node <SPC> not <SPC> in <SPC> children : <NL>              continue <NL>          for <SPC> c <SPC> in <SPC> children [ node ] : <NL>              stk . append ( ( c , <SPC> curr ) ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> numOfMinutes ( self , <SPC> n , <SPC> headID , <SPC> manager , <SPC> informTime ) : <NL> <NL> <TAB> def <SPC> dfs ( informTime , <SPC> children , <SPC> node ) : <NL>          return <SPC> ( <NL>              max ( dfs ( informTime , <SPC> children , <SPC> c ) <SPC> for <SPC> c <SPC> in <SPC> children [ node ] ) <NL>              if <SPC> node <SPC> in <SPC> children <NL>              else <SPC> 0 <NL>          ) <SPC> + <SPC> informTime [ node ] <NL> <NL> <TAB> children <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> child , <SPC> parent <SPC> in <SPC> enumerate ( manager ) : <NL>          if <SPC> parent <SPC> != <SPC> - 1 : <NL>              children [ parent ] . append ( child ) <NL> <TAB> return <SPC> dfs ( informTime , <SPC> children , <SPC> headID ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> toLowerCase ( self , <SPC> str ) : <NL> <NL> <TAB> return <SPC> "" . join ( <NL>          [ chr ( ord ( "a" ) <SPC> + <SPC> ord ( c ) <SPC> - <SPC> ord ( "A" ) ) <NL>           if <SPC> "A" <SPC> <= <SPC> c <SPC> <= <SPC> "Z" <SPC> else <SPC> c <SPC> for <SPC> c <SPC> in <SPC> str ] <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isToeplitzMatrix ( self , <SPC> matrix ) : <NL> <NL> <TAB> return <SPC> all ( <NL>          i <SPC> == <SPC> 0 <SPC> or <SPC> j <SPC> == <SPC> 0 <SPC> or <SPC> matrix [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> val <NL>          for <SPC> i , <SPC> row <SPC> in <SPC> enumerate ( matrix ) <NL>          for <SPC> j , <SPC> val <SPC> in <SPC> enumerate ( row ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isToeplitzMatrix ( self , <SPC> matrix ) : <NL> <NL> <TAB> for <SPC> row_index , <SPC> row <SPC> in <SPC> enumerate ( matrix ) : <NL>          for <SPC> digit_index , <SPC> digit <SPC> in <SPC> enumerate ( row ) : <NL>              if <SPC> not <SPC> row_index <SPC> or <SPC> not <SPC> digit_index : <NL>                  continue <NL>              if <SPC> matrix [ row_index <SPC> - <SPC> 1 ] [ digit_index <SPC> - <SPC> 1 ] <SPC> != <SPC> digit : <NL>                  return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> topKFrequent ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> counts <SPC> = <SPC> collections . Counter ( nums ) <NL> <TAB> buckets <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( nums ) <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> i , <SPC> count <SPC> in <SPC> counts . iteritems ( ) : <NL>          buckets [ count ] . append ( i ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( buckets ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( buckets [ i ] ) ) : <NL>              result . append ( buckets [ i ] [ j ] ) <NL>              if <SPC> len ( result ) <SPC> == <SPC> k : <NL>                  return <SPC> result <NL> <TAB> return <SPC> result <NL> <NL> <NL> from <SPC> random <SPC> import <SPC> randint <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> topKFrequent ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> counts <SPC> = <SPC> collections . Counter ( nums ) <NL> <TAB> p <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> key , <SPC> val <SPC> in <SPC> counts . iteritems ( ) : <NL>          p . append ( ( - val , <SPC> key ) ) <NL> <TAB> self . kthElement ( p , <SPC> k <SPC> - <SPC> 1 ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k ) : <NL>          result . append ( p [ i ] [ 1 ] ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> kthElement ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) : <NL>          pivot_value <SPC> = <SPC> nums [ pivot_idx ] <NL>          new_pivot_idx <SPC> = <SPC> left <NL>          nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>              if <SPC> nums [ i ] <SPC> < <SPC> pivot_value : <NL>                  nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                  new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>          nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>          return <SPC> new_pivot_idx <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          pivot_idx <SPC> = <SPC> randint ( left , <SPC> right ) <NL>          new_pivot_idx <SPC> = <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) <NL>          if <SPC> new_pivot_idx <SPC> == <SPC> k : <NL>              return <NL>          elif <SPC> new_pivot_idx <SPC> > <SPC> k : <NL>              right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> topKFrequent ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> return <SPC> [ key <SPC> for <SPC> key , <SPC> _ <SPC> in <SPC> collections . Counter ( nums ) . most_common ( k ) ] <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> heapq <NL> from <SPC> random <SPC> import <SPC> randint <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> topKFrequent ( self , <SPC> words , <SPC> k ) : <NL> <NL> <TAB> counts <SPC> = <SPC> collections . Counter ( words ) <NL> <TAB> p <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> key , <SPC> val <SPC> in <SPC> counts . iteritems ( ) : <NL>          p . append ( ( - val , <SPC> key ) ) <NL> <TAB> self . kthElement ( p , <SPC> k <SPC> - <SPC> 1 ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> sorted_p <SPC> = <SPC> sorted ( p [ : k ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( k ) : <NL>          result . append ( sorted_p [ i ] [ 1 ] ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> kthElement ( self , <SPC> nums , <SPC> k ) : <NL> <NL> <TAB> def <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) : <NL>          pivot_value <SPC> = <SPC> nums [ pivot_idx ] <NL>          new_pivot_idx <SPC> = <SPC> left <NL>          nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>              if <SPC> nums [ i ] <SPC> < <SPC> pivot_value : <NL>                  nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                  new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>          nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>          return <SPC> new_pivot_idx <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          pivot_idx <SPC> = <SPC> randint ( left , <SPC> right ) <NL>          new_pivot_idx <SPC> = <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) <NL>          if <SPC> new_pivot_idx <SPC> == <SPC> k : <NL>              return <NL>          elif <SPC> new_pivot_idx <SPC> > <SPC> k : <NL>              right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> topKFrequent ( self , <SPC> words , <SPC> k ) : <NL> <NL> <TAB> class <SPC> MinHeapObj ( object ) : <NL>          def <SPC> __init__ ( self , <SPC> val ) : <NL>              self . val <SPC> = <SPC> val <NL> <NL>          def <SPC> __lt__ ( self , <SPC> other ) : <NL>              return <SPC> ( <NL>                  self . val [ 1 ] <SPC> > <SPC> other . val [ 1 ] <NL>                  if <SPC> self . val [ 0 ] <SPC> == <SPC> other . val [ 0 ] <NL>                  else <SPC> self . val <SPC> < <SPC> other . val <NL>              ) <NL> <NL>          def <SPC> __eq__ ( self , <SPC> other ) : <NL>              return <SPC> self . val <SPC> == <SPC> other . val <NL> <NL>          def <SPC> __str__ ( self ) : <NL>              return <SPC> str ( self . val ) <NL> <NL> <TAB> counts <SPC> = <SPC> collections . Counter ( words ) <NL> <TAB> min_heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> word , <SPC> count <SPC> in <SPC> counts . iteritems ( ) : <NL>          heapq . heappush ( min_heap , <SPC> MinHeapObj ( ( count , <SPC> word ) ) ) <NL>          if <SPC> len ( min_heap ) <SPC> == <SPC> k <SPC> + <SPC> 1 : <NL>              heapq . heappop ( min_heap ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> min_heap : <NL>          result . append ( heapq . heappop ( min_heap ) . val [ 1 ] ) <NL> <TAB> return <SPC> result [ : : - 1 ] <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> topKFrequent ( self , <SPC> words , <SPC> k ) : <NL> <NL> <TAB> counts <SPC> = <SPC> collections . Counter ( words ) <NL> <TAB> buckets <SPC> = <SPC> [ [ ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( words ) <SPC> + <SPC> 1 ) ] <NL> <TAB> for <SPC> word , <SPC> count <SPC> in <SPC> counts . iteritems ( ) : <NL>          buckets [ count ] . append ( word ) <NL> <TAB> pairs <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( words ) ) ) : <NL>          for <SPC> word <SPC> in <SPC> buckets [ i ] : <NL>              pairs . append ( ( - i , <SPC> word ) ) <NL>          if <SPC> len ( pairs ) <SPC> >= <SPC> k : <NL>              break <NL> <TAB> pairs . sort ( ) <NL> <TAB> return <SPC> [ pair [ 1 ] <SPC> for <SPC> pair <SPC> in <SPC> pairs [ : k ] ] <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> Counter <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <TAB> def <SPC> topKFrequent ( self , <SPC> words , <SPC> k ) : <NL> <NL> <TAB> counter <SPC> = <SPC> Counter ( words ) <NL> <TAB> candidates <SPC> = <SPC> counter . keys ( ) <NL> <TAB> candidates . sort ( key = lambda <SPC> w : <SPC> ( - counter [ w ] , <SPC> w ) ) <NL> <TAB> return <SPC> candidates [ : k ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> probabilityOfHeads ( self , <SPC> prob , <SPC> target ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 0.0 ] <SPC> * <SPC> ( target <SPC> + <SPC> 1 ) <NL> <TAB> dp [ 0 ] <SPC> = <SPC> 1.0 <NL> <TAB> for <SPC> p <SPC> in <SPC> prob : <NL>          for <SPC> i <SPC> in <SPC> reversed ( xrange ( target <SPC> + <SPC> 1 ) ) : <NL>              dp [ i ] <SPC> = <SPC> ( dp [ i <SPC> - <SPC> 1 ] <SPC> if <SPC> i <SPC> >= <SPC> 1 <SPC> else <SPC> 0.0 ) <SPC> * <SPC> p <SPC> + <SPC> dp [ i ] <SPC> * <SPC> ( 1 <SPC> - <SPC> p ) <NL> <TAB> return <SPC> dp [ target ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> totalHammingDistance ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 32 ) : <NL>          counts <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 <NL>          for <SPC> num <SPC> in <SPC> nums : <NL>              counts [ ( num <SPC> >> <SPC> i ) <SPC> & <SPC> 1 ] <SPC> += <SPC> 1 <NL>          result <SPC> += <SPC> counts [ 0 ] <SPC> * <SPC> counts [ 1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> threading <NL> <NL> <NL> class <SPC> TrafficLight ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __l <SPC> = <SPC> threading . Lock ( ) <NL> <TAB> self . __light <SPC> = <SPC> 1 <NL> <NL> <TAB> def <SPC> carArrived ( self , <SPC> carId , <SPC> roadId , <SPC> direction , <SPC> turnGreen , <SPC> crossCar ) : <NL> <NL> <TAB> with <SPC> self . __l : <NL>          if <SPC> self . __light <SPC> != <SPC> roadId : <NL>              self . __light <SPC> = <SPC> roadId <NL>              turnGreen ( ) <NL>          crossCar ( ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> movesToChessboard ( self , <SPC> board ) : <NL> <NL> <TAB> N <SPC> = <SPC> len ( board ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> count <SPC> in <SPC> ( <NL>          collections . Counter ( map ( tuple , <SPC> board ) ) , <NL>          collections . Counter ( itertools . izip ( * board ) ) , <NL> <TAB> ) : <NL>          if <SPC> len ( count ) <SPC> != <SPC> 2 <SPC> or <SPC> sorted ( count . values ( ) ) <SPC> != <SPC> [ N <SPC> / <SPC> 2 , <SPC> ( N <SPC> + <SPC> 1 ) <SPC> / <SPC> 2 ] : <NL>              return <SPC> - 1 <NL> <NL>          seq1 , <SPC> seq2 <SPC> = <SPC> count <NL>          if <SPC> any ( x <SPC> == <SPC> y <SPC> for <SPC> x , <SPC> y <SPC> in <SPC> itertools . izip ( seq1 , <SPC> seq2 ) ) : <NL>              return <SPC> - 1 <NL>          begins <SPC> = <SPC> [ int ( seq1 . count ( 1 ) <SPC> * <SPC> 2 <SPC> > <SPC> N ) ] <SPC> if <SPC> N <SPC> % <SPC> 2 <SPC> else <SPC> [ 0 , <SPC> 1 ] <NL>          result <SPC> += <SPC> ( <NL>              min ( <NL>                  sum ( int ( i <SPC> % <SPC> 2 <SPC> != <SPC> v ) <SPC> for <SPC> i , <SPC> v <SPC> in <SPC> enumerate ( seq1 , <SPC> begin ) ) <NL>                  for <SPC> begin <SPC> in <SPC> begins <NL>              ) <NL>              / <SPC> 2 <NL>          ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> transpose ( self , <SPC> A ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ [ None ] <SPC> * <SPC> len ( A ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( A [ 0 ] ) ) ] <NL> <TAB> for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( A ) : <NL>          for <SPC> c , <SPC> val <SPC> in <SPC> enumerate ( row ) : <NL>              result [ c ] [ r ] <SPC> = <SPC> val <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> transpose ( self , <SPC> A ) : <NL> <NL> <TAB> return <SPC> zip ( * A ) <NL> <NL> <NL> from <SPC> heapq <SPC> import <SPC> heappush , <SPC> heappop <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> trapRainWater ( self , <SPC> heightMap ) : <NL> <NL> <TAB> m <SPC> = <SPC> len ( heightMap ) <NL> <TAB> if <SPC> not <SPC> m : <NL>          return <SPC> 0 <NL> <TAB> n <SPC> = <SPC> len ( heightMap [ 0 ] ) <NL> <TAB> if <SPC> not <SPC> n : <NL>          return <SPC> 0 <NL> <NL> <TAB> is_visited <SPC> = <SPC> [ [ False <SPC> for <SPC> i <SPC> in <SPC> xrange ( n ) ] <SPC> for <SPC> j <SPC> in <SPC> xrange ( m ) ] <NL> <NL> <TAB> heap <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          heappush ( heap , <SPC> [ heightMap [ i ] [ 0 ] , <SPC> i , <SPC> 0 ] ) <NL>          is_visited [ i ] [ 0 ] <SPC> = <SPC> True <NL>          heappush ( heap , <SPC> [ heightMap [ i ] [ n <SPC> - <SPC> 1 ] , <SPC> i , <SPC> n <SPC> - <SPC> 1 ] ) <NL>          is_visited [ i ] [ n <SPC> - <SPC> 1 ] <SPC> = <SPC> True <NL> <TAB> for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> - <SPC> 1 ) : <NL>          heappush ( heap , <SPC> [ heightMap [ 0 ] [ j ] , <SPC> 0 , <SPC> j ] ) <NL>          is_visited [ 0 ] [ j ] <SPC> = <SPC> True <NL>          heappush ( heap , <SPC> [ heightMap [ m <SPC> - <SPC> 1 ] [ j ] , <SPC> m <SPC> - <SPC> 1 , <SPC> j ] ) <NL>          is_visited [ m <SPC> - <SPC> 1 ] [ j ] <SPC> = <SPC> True <NL> <NL> <TAB> trap <SPC> = <SPC> 0 <NL> <TAB> while <SPC> heap : <NL>          height , <SPC> i , <SPC> j <SPC> = <SPC> heappop ( heap ) <NL>          for <SPC> ( dx , <SPC> dy ) <SPC> in <SPC> [ ( 1 , <SPC> 0 ) , <SPC> ( - 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> 1 ) , <SPC> ( 0 , <SPC> - 1 ) ] : <NL>              x , <SPC> y <SPC> = <SPC> i <SPC> + <SPC> dx , <SPC> j <SPC> + <SPC> dy <NL>              if <SPC> 0 <SPC> <= <SPC> x <SPC> < <SPC> m <SPC> and <SPC> 0 <SPC> <= <SPC> y <SPC> < <SPC> n <SPC> and <SPC> not <SPC> is_visited [ x ] [ y ] : <NL>                  trap <SPC> += <SPC> max ( 0 , <SPC> height <SPC> - <SPC> heightMap [ x ] [ y ] ) <NL>                  heappush ( heap , <SPC> [ max ( height , <SPC> heightMap [ x ] [ y ] ) , <SPC> x , <SPC> y ] ) <NL>                  is_visited [ x ] [ y ] <SPC> = <SPC> True <NL> <NL> <TAB> return <SPC> trap <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> trap ( self , <SPC> height ) : <NL> <NL> <TAB> result , <SPC> left , <SPC> right , <SPC> level <SPC> = <SPC> 0 , <SPC> 0 , <SPC> len ( height ) <SPC> - <SPC> 1 , <SPC> 0 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          if <SPC> height [ left ] <SPC> < <SPC> height [ right ] : <NL>              lower <SPC> = <SPC> height [ left ] <NL>              left <SPC> += <SPC> 1 <NL>          else : <NL>              lower <SPC> = <SPC> height [ right ] <NL>              right <SPC> -= <SPC> 1 <NL>          level <SPC> = <SPC> max ( level , <SPC> lower ) <NL>          result <SPC> += <SPC> level <SPC> - <SPC> lower <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> trap ( self , <SPC> A ) : <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> top <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          if <SPC> A [ top ] <SPC> < <SPC> A [ i ] : <NL>              top <SPC> = <SPC> i <NL> <NL> <TAB> second_top <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( top ) : <NL>          if <SPC> A [ second_top ] <SPC> < <SPC> A [ i ] : <NL>              second_top <SPC> = <SPC> i <NL>          result <SPC> += <SPC> A [ second_top ] <SPC> - <SPC> A [ i ] <NL> <NL> <TAB> second_top <SPC> = <SPC> len ( A ) <SPC> - <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( top , <SPC> len ( A ) ) ) : <NL>          if <SPC> A [ second_top ] <SPC> < <SPC> A [ i ] : <NL>              second_top <SPC> = <SPC> i <NL>          result <SPC> += <SPC> A [ second_top ] <SPC> - <SPC> A [ i ] <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <NL> <TAB> def <SPC> trap ( self , <SPC> A ) : <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> stack <SPC> = <SPC> [ ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          mid_height <SPC> = <SPC> 0 <NL>          while <SPC> stack : <NL>              [ pos , <SPC> height ] <SPC> = <SPC> stack . pop ( ) <NL>              result <SPC> += <SPC> ( min ( height , <SPC> A [ i ] ) <SPC> - <SPC> mid_height ) <SPC> * <SPC> ( i <SPC> - <SPC> pos <SPC> - <SPC> 1 ) <NL>              mid_height <SPC> = <SPC> height <NL> <NL>              if <SPC> A [ i ] <SPC> < <SPC> height : <NL>                  stack . append ( [ pos , <SPC> height ] ) <NL>                  break <NL>          stack . append ( [ i , <SPC> A [ i ] ] ) <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> treeDiameter ( self , <SPC> edges ) : <NL> <NL> <TAB> graph , <SPC> length <SPC> = <SPC> collections . defaultdict ( set ) , <SPC> 0 <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          graph [ u ] . add ( v ) <NL>          graph [ v ] . add ( u ) <NL> <TAB> curr_level <SPC> = <SPC> { <NL>          ( None , <SPC> u ) <SPC> for <SPC> u , <SPC> neighbors <SPC> in <SPC> graph . iteritems ( ) <SPC> if <SPC> len ( neighbors ) <SPC> == <SPC> 1 <NL> <TAB> } <NL> <TAB> while <SPC> curr_level : <NL>          curr_level <SPC> = <SPC> { <NL>              ( u , <SPC> v ) <SPC> for <SPC> prev , <SPC> u <SPC> in <SPC> curr_level <SPC> for <SPC> v <SPC> in <SPC> graph [ u ] <SPC> if <SPC> v <SPC> != <SPC> prev <NL>          } <NL>          length <SPC> += <SPC> 1 <NL> <TAB> return <SPC> max ( length <SPC> - <SPC> 1 , <SPC> 0 ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> fractions <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> getCoprimes ( self , <SPC> nums , <SPC> edges ) : <NL> <NL> <TAB> def <SPC> iter_dfs ( nums , <SPC> adj ) : <NL>          result <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( nums ) <NL>          path <SPC> = <SPC> collections . defaultdict ( list ) <NL>          stk <SPC> = <SPC> [ ( 1 , <SPC> ( - 1 , <SPC> 0 , <SPC> 0 ) ) ] <NL>          while <SPC> stk : <NL>              step , <SPC> params <SPC> = <SPC> stk . pop ( ) <NL>              if <SPC> step <SPC> == <SPC> 1 : <NL>                  prev , <SPC> node , <SPC> depth <SPC> = <SPC> params <NL>                  stk . append ( ( 4 , <SPC> ( node , ) ) ) <NL>                  stk . append ( ( 3 , <SPC> ( prev , <SPC> node , <SPC> depth ) ) ) <NL>                  stk . append ( ( 2 , <SPC> ( node , ) ) ) <NL>              elif <SPC> step <SPC> == <SPC> 2 : <NL>                  node <SPC> = <SPC> params [ 0 ] <NL>                  max_d <SPC> = <SPC> - 1 <NL>                  for <SPC> x <SPC> in <SPC> path . iterkeys ( ) : <NL>                      if <SPC> fractions . gcd ( nums [ node ] , <SPC> x ) <SPC> != <SPC> 1 : <NL>                          continue <NL>                      if <SPC> path [ x ] [ - 1 ] [ 1 ] <SPC> > <SPC> max_d : <NL>                          max_d <SPC> = <SPC> path [ x ] [ - 1 ] [ 1 ] <NL>                          result [ node ] <SPC> = <SPC> path [ x ] [ - 1 ] [ 0 ] <NL>              elif <SPC> step <SPC> == <SPC> 3 : <NL>                  prev , <SPC> node , <SPC> depth <SPC> = <SPC> params <NL>                  path [ nums [ node ] ] . append ( ( node , <SPC> depth ) ) <NL>                  for <SPC> nei <SPC> in <SPC> adj [ node ] : <NL>                      if <SPC> nei <SPC> == <SPC> prev : <NL>                          continue <NL>                      stk . append ( ( 1 , <SPC> ( node , <SPC> nei , <SPC> depth <SPC> + <SPC> 1 ) ) ) <NL>              elif <SPC> step <SPC> == <SPC> 4 : <NL>                  node <SPC> = <SPC> params [ 0 ] <NL>                  path [ nums [ node ] ] . pop ( ) <NL>                  if <SPC> not <SPC> path [ nums [ node ] ] : <NL>                      path . pop ( nums [ node ] ) <NL>          return <SPC> result <NL> <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          adj [ u ] . append ( v ) <NL>          adj [ v ] . append ( u ) <NL> <TAB> return <SPC> iter_dfs ( nums , <SPC> adj ) <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> fractions <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> getCoprimes ( self , <SPC> nums , <SPC> edges ) : <NL> <NL> <TAB> def <SPC> dfs ( nums , <SPC> adj , <SPC> prev , <SPC> node , <SPC> depth , <SPC> path , <SPC> result ) : <NL>          max_d <SPC> = <SPC> - 1 <NL>          for <SPC> x <SPC> in <SPC> path . iterkeys ( ) : <NL>              if <SPC> fractions . gcd ( nums [ node ] , <SPC> x ) <SPC> != <SPC> 1 : <NL>                  continue <NL>              if <SPC> path [ x ] [ - 1 ] [ 1 ] <SPC> > <SPC> max_d : <NL>                  max_d <SPC> = <SPC> path [ x ] [ - 1 ] [ 1 ] <NL>                  result [ node ] <SPC> = <SPC> path [ x ] [ - 1 ] [ 0 ] <NL>          path [ nums [ node ] ] . append ( ( node , <SPC> depth ) ) <NL>          for <SPC> nei <SPC> in <SPC> adj [ node ] : <NL>              if <SPC> nei <SPC> == <SPC> prev : <NL>                  continue <NL>              dfs ( nums , <SPC> adj , <SPC> node , <SPC> nei , <SPC> depth <SPC> + <SPC> 1 , <SPC> path , <SPC> result ) <NL>          path [ nums [ node ] ] . pop ( ) <NL>          if <SPC> not <SPC> path [ nums [ node ] ] : <NL>              path . pop ( nums [ node ] ) <NL> <NL> <TAB> adj <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> for <SPC> u , <SPC> v <SPC> in <SPC> edges : <NL>          adj [ u ] . append ( v ) <NL>          adj [ v ] . append ( u ) <NL> <TAB> result <SPC> = <SPC> [ - 1 ] <SPC> * <SPC> len ( nums ) <NL> <TAB> path <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> dfs ( nums , <SPC> adj , <SPC> - 1 , <SPC> 0 , <SPC> 0 , <SPC> path , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> from <SPC> functools <SPC> import <SPC> reduce <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> minimumTotal ( self , <SPC> triangle ) : <NL> <TAB> if <SPC> not <SPC> triangle : <NL>          return <SPC> 0 <NL> <NL> <TAB> cur <SPC> = <SPC> triangle [ 0 ] <SPC> + <SPC> [ float ( "inf" ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( triangle ) ) : <NL>          next <SPC> = <SPC> [ ] <NL>          next . append ( triangle [ i ] [ 0 ] <SPC> + <SPC> cur [ 0 ] ) <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> i <SPC> + <SPC> 1 ) : <NL>              next . append ( triangle [ i ] [ j ] <SPC> + <SPC> min ( cur [ j <SPC> - <SPC> 1 ] , <SPC> cur [ j ] ) ) <NL>          cur <SPC> = <SPC> next <SPC> + <SPC> [ float ( "inf" ) ] <NL> <NL> <TAB> return <SPC> reduce ( min , <SPC> cur ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> trimBST ( self , <SPC> root , <SPC> L , <SPC> R ) : <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> None <NL> <TAB> if <SPC> root . val <SPC> < <SPC> L : <NL>          return <SPC> self . trimBST ( root . right , <SPC> L , <SPC> R ) <NL> <TAB> if <SPC> root . val <SPC> > <SPC> R : <NL>          return <SPC> self . trimBST ( root . left , <SPC> L , <SPC> R ) <NL> <TAB> root . left , <SPC> root . right <SPC> = <SPC> self . trimBST ( root . left , <SPC> L , <SPC> R ) , <SPC> self . trimBST ( <NL>          root . right , <SPC> L , <SPC> R <NL> <TAB> ) <NL> <TAB> return <SPC> root <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> countTriplets ( self , <SPC> A ) : <NL> <NL> <TAB> def <SPC> FWT ( A , <SPC> v ) : <NL>          B <SPC> = <SPC> A [ : ] <NL>          d <SPC> = <SPC> 1 <NL>          while <SPC> d <SPC> < <SPC> len ( B ) : <NL>              for <SPC> i <SPC> in <SPC> xrange ( 0 , <SPC> len ( B ) , <SPC> d <SPC> << <SPC> 1 ) : <NL>                  for <SPC> j <SPC> in <SPC> xrange ( d ) : <NL>                      B [ i <SPC> + <SPC> j ] <SPC> += <SPC> B [ i <SPC> + <SPC> j <SPC> + <SPC> d ] <SPC> * <SPC> v <NL>              d <SPC> <<= <SPC> 1 <NL>          return <SPC> B <NL> <NL> <TAB> k <SPC> = <SPC> 3 <NL> <TAB> n , <SPC> max_A <SPC> = <SPC> 1 , <SPC> max ( A ) <NL> <TAB> while <SPC> n <SPC> <= <SPC> max_A : <NL>          n <SPC> *= <SPC> 2 <NL> <TAB> count <SPC> = <SPC> collections . Counter ( A ) <NL> <TAB> B <SPC> = <SPC> [ count [ i ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> C <SPC> = <SPC> FWT ( map ( lambda <SPC> x : <SPC> x <SPC> ** <SPC> k , <SPC> FWT ( B , <SPC> 1 ) ) , <SPC> - 1 ) <NL> <TAB> return <SPC> C [ 0 ] <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> countTriplets ( self , <SPC> A ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( A ) ) : <NL>              count [ A [ i ] <SPC> & <SPC> A [ j ] ] <SPC> += <SPC> 1 <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> k <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          for <SPC> v <SPC> in <SPC> count : <NL>              if <SPC> A [ k ] <SPC> & <SPC> v <SPC> == <SPC> 0 : <NL>                  result <SPC> += <SPC> count [ v ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> tupleSameProduct ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> count <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( nums ) ) : <NL>              result <SPC> += <SPC> count [ nums [ i ] <SPC> * <SPC> nums [ j ] ] <NL>              count [ nums [ i ] <SPC> * <SPC> nums [ j ] ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> 8 <SPC> * <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> import <SPC> random <NL> <NL> <NL> class <SPC> SkipNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> level = 0 , <SPC> val = None ) : <NL> <TAB> self . val <SPC> = <SPC> val <NL> <TAB> self . nexts <SPC> = <SPC> [ None ] <SPC> * <SPC> level <NL> <TAB> self . prevs <SPC> = <SPC> [ None ] <SPC> * <SPC> level <NL> <NL> <NL> class <SPC> SkipList ( object ) : <NL> <TAB> P_NUMERATOR , <SPC> P_DENOMINATOR <SPC> = <SPC> 1 , <SPC> 2 <NL> <TAB> MAX_LEVEL <SPC> = <SPC> 32 <NL> <NL> <TAB> def <SPC> __init__ ( self , <SPC> end = float ( "inf" ) , <SPC> can_duplicated = False ) : <NL> <TAB> random . seed ( 0 ) <NL> <TAB> self . __head <SPC> = <SPC> SkipNode ( ) <NL> <TAB> self . __len <SPC> = <SPC> 0 <NL> <TAB> self . __can_duplicated <SPC> = <SPC> can_duplicated <NL> <TAB> self . add ( end ) <NL> <NL> <TAB> def <SPC> lower_bound ( self , <SPC> target ) : <NL> <TAB> return <SPC> self . __lower_bound ( target , <SPC> self . __find_prev_nodes ( target ) ) <NL> <NL> <TAB> def <SPC> find ( self , <SPC> target ) : <NL> <TAB> return <SPC> self . __find ( target , <SPC> self . __find_prev_nodes ( target ) ) <NL> <NL> <TAB> def <SPC> add ( self , <SPC> val ) : <NL> <TAB> if <SPC> not <SPC> self . __can_duplicated <SPC> and <SPC> self . find ( val ) : <NL>          return <SPC> False <NL> <TAB> node <SPC> = <SPC> SkipNode ( self . __random_level ( ) , <SPC> val ) <NL> <TAB> if <SPC> len ( self . __head . nexts ) <SPC> < <SPC> len ( node . nexts ) : <NL>          self . __head . nexts . extend ( <NL>              [ None ] <SPC> * <SPC> ( len ( node . nexts ) <SPC> - <SPC> len ( self . __head . nexts ) ) <NL>          ) <NL> <TAB> prevs <SPC> = <SPC> self . __find_prev_nodes ( val ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( node . nexts ) ) : <NL>          node . nexts [ i ] <SPC> = <SPC> prevs [ i ] . nexts [ i ] <NL>          if <SPC> prevs [ i ] . nexts [ i ] : <NL>              prevs [ i ] . nexts [ i ] . prevs [ i ] <SPC> = <SPC> node <NL>          prevs [ i ] . nexts [ i ] <SPC> = <SPC> node <NL>          node . prevs [ i ] <SPC> = <SPC> prevs [ i ] <NL> <TAB> self . __len <SPC> += <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> remove ( self , <SPC> val ) : <NL> <TAB> prevs <SPC> = <SPC> self . __find_prev_nodes ( val ) <NL> <TAB> curr <SPC> = <SPC> self . __find ( val , <SPC> prevs ) <NL> <TAB> if <SPC> not <SPC> curr : <NL>          return <SPC> False <NL> <TAB> self . __len <SPC> -= <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( curr . nexts ) ) ) : <NL>          prevs [ i ] . nexts [ i ] <SPC> = <SPC> curr . nexts [ i ] <NL>          if <SPC> curr . nexts [ i ] : <NL>              curr . nexts [ i ] . prevs [ i ] <SPC> = <SPC> prevs [ i ] <NL>          if <SPC> not <SPC> self . __head . nexts [ i ] : <NL>              self . __head . nexts . pop ( ) <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> __lower_bound ( self , <SPC> val , <SPC> prevs ) : <NL> <TAB> if <SPC> prevs : <NL>          candidate <SPC> = <SPC> prevs [ 0 ] . nexts [ 0 ] <NL>          if <SPC> candidate : <NL>              return <SPC> candidate <NL> <TAB> return <SPC> None <NL> <NL> <TAB> def <SPC> __find ( self , <SPC> val , <SPC> prevs ) : <NL> <TAB> candidate <SPC> = <SPC> self . __lower_bound ( val , <SPC> prevs ) <NL> <TAB> if <SPC> candidate <SPC> and <SPC> candidate . val <SPC> == <SPC> val : <NL>          return <SPC> candidate <NL> <TAB> return <SPC> None <NL> <NL> <TAB> def <SPC> __find_prev_nodes ( self , <SPC> val ) : <NL> <TAB> prevs <SPC> = <SPC> [ None ] <SPC> * <SPC> len ( self . __head . nexts ) <NL> <TAB> curr <SPC> = <SPC> self . __head <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( self . __head . nexts ) ) ) : <NL>          while <SPC> curr . nexts [ i ] <SPC> and <SPC> curr . nexts [ i ] . val <SPC> < <SPC> val : <NL>              curr <SPC> = <SPC> curr . nexts [ i ] <NL>          prevs [ i ] <SPC> = <SPC> curr <NL> <TAB> return <SPC> prevs <NL> <NL> <TAB> def <SPC> __random_level ( self ) : <NL> <TAB> level <SPC> = <SPC> 1 <NL> <TAB> while <SPC> ( <NL>          random . randint ( 1 , <SPC> SkipList . P_DENOMINATOR ) <SPC> <= <SPC> SkipList . P_NUMERATOR <NL>          and <SPC> level <SPC> < <SPC> SkipList . MAX_LEVEL <NL> <TAB> ) : <NL>          level <SPC> += <SPC> 1 <NL> <TAB> return <SPC> level <NL> <NL> <TAB> def <SPC> __len__ ( self ) : <NL> <TAB> return <SPC> self . __len <SPC> - <SPC> 1 <NL> <NL> <TAB> def <SPC> __str__ ( self ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( self . __head . nexts ) ) ) : <NL>          result . append ( [ ] ) <NL>          curr <SPC> = <SPC> self . __head . nexts [ i ] <NL>          while <SPC> curr : <NL>              result [ - 1 ] . append ( str ( curr . val ) ) <NL>              curr <SPC> = <SPC> curr . nexts [ i ] <NL> <TAB> return <SPC> "\n" . join ( map ( lambda <SPC> x : <SPC> "->" . join ( x ) , <SPC> result ) ) <NL> <NL> <NL> class <SPC> TweetCounts ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __records <SPC> = <SPC> collections . defaultdict ( <NL>          lambda : <SPC> SkipList ( can_duplicated = True ) ) <NL> <TAB> self . __lookup <SPC> = <SPC> { "minute" : <SPC> 60 , <SPC> "hour" : <SPC> 3600 , <SPC> "day" : <SPC> 86400 } <NL> <NL> <TAB> def <SPC> recordTweet ( self , <SPC> tweetName , <SPC> time ) : <NL> <NL> <TAB> self . __records [ tweetName ] . add ( time ) <NL> <NL> <TAB> def <SPC> getTweetCountsPerFrequency ( self , <SPC> freq , <SPC> tweetName , <SPC> startTime , <SPC> endTime ) : <NL> <NL> <TAB> delta <SPC> = <SPC> self . __lookup [ freq ] <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( ( endTime <SPC> - <SPC> startTime ) <SPC> // <SPC> delta <SPC> + <SPC> 1 ) <NL> <TAB> it <SPC> = <SPC> self . __records [ tweetName ] . lower_bound ( startTime ) <NL> <TAB> while <SPC> it <SPC> is <SPC> not <SPC> None <SPC> and <SPC> it . val <SPC> <= <SPC> endTime : <NL>          result [ ( it . val <SPC> - <SPC> startTime ) <SPC> // <SPC> delta ] <SPC> += <SPC> 1 <NL>          it <SPC> = <SPC> it . nexts [ 0 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> bisect <NL> <NL> <NL> class <SPC> TweetCounts2 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __records <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> self . __lookup <SPC> = <SPC> { "minute" : <SPC> 60 , <SPC> "hour" : <SPC> 3600 , <SPC> "day" : <SPC> 86400 } <NL> <NL> <TAB> def <SPC> recordTweet ( self , <SPC> tweetName , <SPC> time ) : <NL> <NL> <TAB> bisect . insort ( self . __records [ tweetName ] , <SPC> time ) <NL> <NL> <TAB> def <SPC> getTweetCountsPerFrequency ( self , <SPC> freq , <SPC> tweetName , <SPC> startTime , <SPC> endTime ) : <NL> <NL> <TAB> delta <SPC> = <SPC> self . __lookup [ freq ] <NL> <TAB> i <SPC> = <SPC> startTime <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> while <SPC> i <SPC> <= <SPC> endTime : <NL>          j <SPC> = <SPC> min ( i <SPC> + <SPC> delta , <SPC> endTime <SPC> + <SPC> 1 ) <NL>          result . append ( <NL>              bisect . bisect_left ( self . __records [ tweetName ] , <SPC> j ) <NL>              - <SPC> bisect . bisect_left ( self . __records [ tweetName ] , <SPC> i ) <NL>          ) <NL>          i <SPC> += <SPC> delta <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TweetCounts3 ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __records <SPC> = <SPC> collections . defaultdict ( list ) <NL> <TAB> self . __lookup <SPC> = <SPC> { "minute" : <SPC> 60 , <SPC> "hour" : <SPC> 3600 , <SPC> "day" : <SPC> 86400 } <NL> <NL> <TAB> def <SPC> recordTweet ( self , <SPC> tweetName , <SPC> time ) : <NL> <NL> <TAB> self . __records [ tweetName ] . append ( time ) <NL> <NL> <TAB> def <SPC> getTweetCountsPerFrequency ( self , <SPC> freq , <SPC> tweetName , <SPC> startTime , <SPC> endTime ) : <NL> <NL> <TAB> delta <SPC> = <SPC> self . __lookup [ freq ] <NL> <TAB> result <SPC> = <SPC> [ 0 ] <SPC> * <SPC> ( ( endTime <SPC> - <SPC> startTime ) <SPC> // <SPC> delta <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> t <SPC> in <SPC> self . __records [ tweetName ] : <NL>          if <SPC> startTime <SPC> <= <SPC> t <SPC> <= <SPC> endTime : <NL>              result [ ( t <SPC> - <SPC> startTime ) <SPC> // <SPC> delta ] <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> random <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> twoCitySchedCost ( self , <SPC> costs ) : <NL> <NL> <TAB> def <SPC> kthElement ( nums , <SPC> k , <SPC> compare ) : <NL>          def <SPC> PartitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare ) : <NL>              new_pivot_idx <SPC> = <SPC> left <NL>              nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>                  if <SPC> compare ( nums [ i ] , <SPC> nums [ right ] ) : <NL>                      nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                      new_pivot_idx <SPC> += <SPC> 1 <NL> <NL>              nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>              return <SPC> new_pivot_idx <NL> <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> random . randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> PartitionAroundPivot ( <NL>                  left , <SPC> right , <SPC> pivot_idx , <SPC> nums , <SPC> compare <NL>              ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> k : <NL>                  return <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> k : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> kthElement ( costs , <SPC> len ( costs ) <SPC> // <SPC> 2 , <SPC> lambda <SPC> a , <SPC> b : <SPC> a [ 0 ] <SPC> - <SPC> a [ 1 ] <SPC> < <SPC> b [ 0 ] <SPC> - <SPC> b [ 1 ] ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( costs ) ) : <NL>          result <SPC> += <SPC> costs [ i ] [ 0 ] <SPC> if <SPC> i <SPC> < <SPC> len ( costs ) <SPC> // <SPC> 2 <SPC> else <SPC> costs [ i ] [ 1 ] <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> twoSumBSTs ( self , <SPC> root1 , <SPC> root2 , <SPC> target ) : <NL> <NL> <TAB> def <SPC> inorder_gen ( root , <SPC> asc = True ) : <NL>          result , <SPC> stack <SPC> = <SPC> [ ] , <SPC> [ ( root , <SPC> False ) ] <NL>          while <SPC> stack : <NL>              root , <SPC> is_visited <SPC> = <SPC> stack . pop ( ) <NL>              if <SPC> root <SPC> is <SPC> None : <NL>                  continue <NL>              if <SPC> is_visited : <NL>                  yield <SPC> root . val <NL>              else : <NL>                  if <SPC> asc : <NL>                      stack . append ( ( root . right , <SPC> False ) ) <NL>                      stack . append ( ( root , <SPC> True ) ) <NL>                      stack . append ( ( root . left , <SPC> False ) ) <NL>                  else : <NL>                      stack . append ( ( root . left , <SPC> False ) ) <NL>                      stack . append ( ( root , <SPC> True ) ) <NL>                      stack . append ( ( root . right , <SPC> False ) ) <NL> <NL> <TAB> left_gen , <SPC> right_gen <SPC> = <SPC> inorder_gen ( root1 , <SPC> True ) , <SPC> inorder_gen ( root2 , <SPC> False ) <NL> <TAB> left , <SPC> right <SPC> = <SPC> next ( left_gen ) , <SPC> next ( right_gen ) <NL> <TAB> while <SPC> left <SPC> is <SPC> not <SPC> None <SPC> and <SPC> right <SPC> is <SPC> not <SPC> None : <NL>          if <SPC> left <SPC> + <SPC> right <SPC> < <SPC> target : <NL>              left <SPC> = <SPC> next ( left_gen ) <NL>          elif <SPC> left <SPC> + <SPC> right <SPC> > <SPC> target : <NL>              right <SPC> = <SPC> next ( right_gen ) <NL>          else : <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> twoSum ( self , <SPC> nums , <SPC> target ) : <NL> <TAB> start , <SPC> end <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL> <NL> <TAB> while <SPC> start <SPC> != <SPC> end : <NL>          sum <SPC> = <SPC> nums [ start ] <SPC> + <SPC> nums [ end ] <NL>          if <SPC> sum <SPC> > <SPC> target : <NL>              end <SPC> -= <SPC> 1 <NL>          elif <SPC> sum <SPC> < <SPC> target : <NL>              start <SPC> += <SPC> 1 <NL>          else : <NL>              return <SPC> [ start <SPC> + <SPC> 1 , <SPC> end <SPC> + <SPC> 1 ] <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> defaultdict <NL> <NL> <NL> class <SPC> TwoSum ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <NL> <TAB> self . lookup <SPC> = <SPC> defaultdict ( int ) <NL> <NL> <TAB> def <SPC> add ( self , <SPC> number ) : <NL> <NL> <TAB> self . lookup [ number ] <SPC> += <SPC> 1 <NL> <NL> <TAB> def <SPC> find ( self , <SPC> value ) : <NL> <NL> <TAB> for <SPC> key <SPC> in <SPC> self . lookup : <NL>          num <SPC> = <SPC> value <SPC> - <SPC> key <NL>          if <SPC> num <SPC> in <SPC> self . lookup <SPC> and <SPC> ( num <SPC> != <SPC> key <SPC> or <SPC> self . lookup [ key ] <SPC> > <SPC> 1 ) : <NL>              return <SPC> True <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findTarget ( self , <SPC> root , <SPC> k ) : <NL> <NL> <TAB> class <SPC> BSTIterator ( object ) : <NL>          def <SPC> __init__ ( self , <SPC> root , <SPC> forward ) : <NL>              self . __node <SPC> = <SPC> root <NL>              self . __forward <SPC> = <SPC> forward <NL>              self . __s <SPC> = <SPC> [ ] <NL>              self . __cur <SPC> = <SPC> None <NL>              self . next ( ) <NL> <NL>          def <SPC> val ( self ) : <NL>              return <SPC> self . __cur <NL> <NL>          def <SPC> next ( self ) : <NL>              while <SPC> self . __node <SPC> or <SPC> self . __s : <NL>                  if <SPC> self . __node : <NL>                      self . __s . append ( self . __node ) <NL>                      self . __node <SPC> = <SPC> ( <NL>                          self . __node . left <SPC> if <SPC> self . __forward <SPC> else <SPC> self . __node . right <NL>                      ) <NL>                  else : <NL>                      self . __node <SPC> = <SPC> self . __s . pop ( ) <NL>                      self . __cur <SPC> = <SPC> self . __node . val <NL>                      self . __node <SPC> = <SPC> ( <NL>                          self . __node . right <SPC> if <SPC> self . __forward <SPC> else <SPC> self . __node . left <NL>                      ) <NL>                      break <NL> <NL> <TAB> if <SPC> not <SPC> root : <NL>          return <SPC> False <NL> <TAB> left , <SPC> right <SPC> = <SPC> BSTIterator ( root , <SPC> True ) , <SPC> BSTIterator ( root , <SPC> False ) <NL> <TAB> while <SPC> left . val ( ) <SPC> < <SPC> right . val ( ) : <NL>          if <SPC> left . val ( ) <SPC> + <SPC> right . val ( ) <SPC> == <SPC> k : <NL>              return <SPC> True <NL>          elif <SPC> left . val ( ) <SPC> + <SPC> right . val ( ) <SPC> < <SPC> k : <NL>              left . next ( ) <NL>          else : <NL>              right . next ( ) <NL> <TAB> return <SPC> False <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> twoSumLessThanK ( self , <SPC> A , <SPC> K ) : <NL> <NL> <TAB> A . sort ( ) <NL> <TAB> result <SPC> = <SPC> - 1 <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( A ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          if <SPC> A [ left ] <SPC> + <SPC> A [ right ] <SPC> >= <SPC> K : <NL>              right <SPC> -= <SPC> 1 <NL>          else : <NL>              result <SPC> = <SPC> max ( result , <SPC> A [ left ] <SPC> + <SPC> A [ right ] ) <NL>              left <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> twoSum ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { } <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          if <SPC> target <SPC> - <SPC> num <SPC> in <SPC> lookup : <NL>              return <SPC> [ lookup [ target <SPC> - <SPC> num ] , <SPC> i ] <NL>          lookup [ num ] <SPC> = <SPC> i <NL> <NL> <TAB> def <SPC> twoSum2 ( self , <SPC> nums , <SPC> target ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> nums : <NL>          j <SPC> = <SPC> target <SPC> - <SPC> i <NL>          tmp_nums_start_index <SPC> = <SPC> nums . index ( i ) <SPC> + <SPC> 1 <NL>          tmp_nums <SPC> = <SPC> nums [ tmp_nums_start_index : ] <NL>          if <SPC> j <SPC> in <SPC> tmp_nums : <NL>              return <SPC> [ nums . index ( i ) , <SPC> tmp_nums_start_index <SPC> + <SPC> tmp_nums . index ( j ) ] <NL> <NL> <NL> import <SPC> heapq <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> nthUglyNumber ( self , <SPC> n ) : <NL> <TAB> ugly_number <SPC> = <SPC> 0 <NL> <NL> <TAB> heap <SPC> = <SPC> [ ] <NL> <TAB> heapq . heappush ( heap , <SPC> 1 ) <NL> <TAB> for <SPC> _ <SPC> in <SPC> xrange ( n ) : <NL>          ugly_number <SPC> = <SPC> heapq . heappop ( heap ) <NL>          if <SPC> ugly_number <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>              heapq . heappush ( heap , <SPC> ugly_number <SPC> * <SPC> 2 ) <NL>          elif <SPC> ugly_number <SPC> % <SPC> 3 <SPC> == <SPC> 0 : <NL>              heapq . heappush ( heap , <SPC> ugly_number <SPC> * <SPC> 2 ) <NL>              heapq . heappush ( heap , <SPC> ugly_number <SPC> * <SPC> 3 ) <NL>          else : <NL>              heapq . heappush ( heap , <SPC> ugly_number <SPC> * <SPC> 2 ) <NL>              heapq . heappush ( heap , <SPC> ugly_number <SPC> * <SPC> 3 ) <NL>              heapq . heappush ( heap , <SPC> ugly_number <SPC> * <SPC> 5 ) <NL> <NL> <TAB> return <SPC> ugly_number <NL> <NL> <TAB> def <SPC> nthUglyNumber2 ( self , <SPC> n ) : <NL> <TAB> ugly <SPC> = <SPC> [ 1 ] <NL> <TAB> i2 <SPC> = <SPC> i3 <SPC> = <SPC> i5 <SPC> = <SPC> 0 <NL> <TAB> while <SPC> len ( ugly ) <SPC> < <SPC> n : <NL>          while <SPC> ugly [ i2 ] <SPC> * <SPC> 2 <SPC> <= <SPC> ugly [ - 1 ] : <NL>              i2 <SPC> += <SPC> 1 <NL>          while <SPC> ugly [ i3 ] <SPC> * <SPC> 3 <SPC> <= <SPC> ugly [ - 1 ] : <NL>              i3 <SPC> += <SPC> 1 <NL>          while <SPC> ugly [ i5 ] <SPC> * <SPC> 5 <SPC> <= <SPC> ugly [ - 1 ] : <NL>              i5 <SPC> += <SPC> 1 <NL>          ugly . append ( min ( ugly [ i2 ] <SPC> * <SPC> 2 , <SPC> ugly [ i3 ] <SPC> * <SPC> 3 , <SPC> ugly [ i5 ] <SPC> * <SPC> 5 ) ) <NL> <TAB> return <SPC> ugly [ - 1 ] <NL> <NL> <TAB> def <SPC> nthUglyNumber3 ( self , <SPC> n ) : <NL> <TAB> q2 , <SPC> q3 , <SPC> q5 <SPC> = <SPC> [ 2 ] , <SPC> [ 3 ] , <SPC> [ 5 ] <NL> <TAB> ugly <SPC> = <SPC> 1 <NL> <TAB> for <SPC> u <SPC> in <SPC> heapq . merge ( q2 , <SPC> q3 , <SPC> q5 ) : <NL>          if <SPC> n <SPC> == <SPC> 1 : <NL>              return <SPC> ugly <NL>          if <SPC> u <SPC> > <SPC> ugly : <NL>              ugly <SPC> = <SPC> u <NL>              n <SPC> -= <SPC> 1 <NL>              q2 <SPC> += <SPC> ( 2 <SPC> * <SPC> u , ) <NL>              q3 <SPC> += <SPC> ( 3 <SPC> * <SPC> u , ) <NL>              q5 <SPC> += <SPC> ( 5 <SPC> * <SPC> u , ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> ugly <SPC> = <SPC> sorted ( <NL>          2 <SPC> ** <SPC> a <SPC> * <SPC> 3 <SPC> ** <SPC> b <SPC> * <SPC> 5 <SPC> ** <SPC> c <NL>          for <SPC> a <SPC> in <SPC> range ( 32 ) <NL>          for <SPC> b <SPC> in <SPC> range ( 20 ) <NL>          for <SPC> c <SPC> in <SPC> range ( 14 ) <NL> <TAB> ) <NL> <NL> <TAB> def <SPC> nthUglyNumber ( self , <SPC> n ) : <NL> <TAB> return <SPC> self . ugly [ n <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> nthUglyNumber ( self , <SPC> n , <SPC> a , <SPC> b , <SPC> c ) : <NL> <NL> <TAB> def <SPC> gcd ( a , <SPC> b ) : <NL>          while <SPC> b : <NL>              a , <SPC> b <SPC> = <SPC> b , <SPC> a <SPC> % <SPC> b <NL>          return <SPC> a <NL> <NL> <TAB> def <SPC> lcm ( x , <SPC> y ) : <NL>          return <SPC> x <SPC> // <SPC> gcd ( x , <SPC> y ) <SPC> * <SPC> y <NL> <NL> <TAB> def <SPC> count ( x , <SPC> a , <SPC> b , <SPC> c , <SPC> lcm_a_b , <SPC> lcm_b_c , <SPC> lcm_c_a , <SPC> lcm_a_b_c ) : <NL>          return <SPC> ( <NL>              x <SPC> // <SPC> a <NL>              + <SPC> x <SPC> // <SPC> b <NL>              + <SPC> x <SPC> // <SPC> c <NL>              - <SPC> ( x <SPC> // <SPC> lcm_a_b <SPC> + <SPC> x <SPC> // <SPC> lcm_b_c <SPC> + <SPC> x <SPC> // <SPC> lcm_c_a ) <NL>              + <SPC> x <SPC> // <SPC> lcm_a_b_c <NL>          ) <NL> <NL> <TAB> lcm_a_b , <SPC> lcm_b_c , <SPC> lcm_c_a <SPC> = <SPC> lcm ( a , <SPC> b ) , <SPC> lcm ( b , <SPC> c ) , <SPC> lcm ( c , <SPC> a ) <NL> <TAB> lcm_a_b_c <SPC> = <SPC> lcm ( lcm_a_b , <SPC> lcm_b_c ) <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> 2 <SPC> * <SPC> 10 <SPC> ** <SPC> 9 <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> // <SPC> 2 <NL>          if <SPC> count ( mid , <SPC> a , <SPC> b , <SPC> c , <SPC> lcm_a_b , <SPC> lcm_b_c , <SPC> lcm_c_a , <SPC> lcm_a_b_c ) <SPC> >= <SPC> n : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isUgly ( self , <SPC> num ) : <NL> <TAB> if <SPC> num <SPC> == <SPC> 0 : <NL>          return <SPC> False <NL> <TAB> for <SPC> i <SPC> in <SPC> [ 2 , <SPC> 3 , <SPC> 5 ] : <NL>          while <SPC> num <SPC> % <SPC> i <SPC> == <SPC> 0 : <NL>              num <SPC> /= <SPC> i <NL> <TAB> return <SPC> num <SPC> == <SPC> 1 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> uncommonFromSentences ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( A . split ( ) ) <NL> <TAB> count <SPC> += <SPC> collections . Counter ( B . split ( ) ) <NL> <TAB> return <SPC> [ word <SPC> for <SPC> word <SPC> in <SPC> count <SPC> if <SPC> count [ word ] <SPC> == <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxUncrossedLines ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> if <SPC> len ( A ) <SPC> < <SPC> len ( B ) : <NL>          return <SPC> self . maxUncrossedLines ( B , <SPC> A ) <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 0 <SPC> for <SPC> _ <SPC> in <SPC> xrange ( len ( B ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( A ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( B ) ) : <NL>              dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] <SPC> = <SPC> max ( <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> + <SPC> int ( A [ i ] <SPC> == <SPC> B [ j ] ) , <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j <SPC> + <SPC> 1 ] , <NL>                  dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <NL>              ) <NL> <TAB> return <SPC> dp [ len ( A ) <SPC> % <SPC> 2 ] [ len ( B ) ] <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <TAB> def <SPC> __repr__ ( self ) : <NL> <TAB> if <SPC> self : <NL>          serial <SPC> = <SPC> [ ] <NL>          queue <SPC> = <SPC> [ self ] <NL> <NL>          while <SPC> queue : <NL>              cur <SPC> = <SPC> queue [ 0 ] <NL> <NL>              if <SPC> cur : <NL>                  serial . append ( cur . val ) <NL>                  queue . append ( cur . left ) <NL>                  queue . append ( cur . right ) <NL>              else : <NL>                  serial . append ( "#" ) <NL> <NL>              queue <SPC> = <SPC> queue [ 1 : ] <NL> <NL>          while <SPC> serial [ - 1 ] <SPC> == <SPC> "#" : <NL>              serial . pop ( ) <NL> <NL>          return <SPC> repr ( serial ) <NL> <NL> <TAB> else : <NL>          return <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> generateTrees ( self , <SPC> n ) : <NL> <TAB> return <SPC> self . generateTreesRecu ( 1 , <SPC> n ) <NL> <NL> <TAB> def <SPC> generateTreesRecu ( self , <SPC> low , <SPC> high ) : <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> low <SPC> > <SPC> high : <NL>          result . append ( None ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( low , <SPC> high <SPC> + <SPC> 1 ) : <NL>          left <SPC> = <SPC> self . generateTreesRecu ( low , <SPC> i <SPC> - <SPC> 1 ) <NL>          right <SPC> = <SPC> self . generateTreesRecu ( i <SPC> + <SPC> 1 , <SPC> high ) <NL>          for <SPC> j <SPC> in <SPC> left : <NL>              for <SPC> k <SPC> in <SPC> right : <NL>                  cur <SPC> = <SPC> TreeNode ( i ) <NL>                  cur . left <SPC> = <SPC> j <NL>                  cur . right <SPC> = <SPC> k <NL>                  result . append ( cur ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numTrees ( self , <SPC> n ) : <NL> <NL> <TAB> if <SPC> n <SPC> == <SPC> 0 : <NL>          return <SPC> 1 <NL> <NL> <TAB> def <SPC> combination ( n , <SPC> k ) : <NL>          count <SPC> = <SPC> 1 <NL> <NL>          for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> k <SPC> + <SPC> 1 ) : <NL>              count <SPC> = <SPC> count <SPC> * <SPC> ( n <SPC> - <SPC> i <SPC> + <SPC> 1 ) <SPC> / <SPC> i <NL>          return <SPC> count <NL> <NL> <TAB> return <SPC> combination ( 2 <SPC> * <SPC> n , <SPC> n ) <SPC> - <SPC> combination ( 2 <SPC> * <SPC> n , <SPC> n <SPC> - <SPC> 1 ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> numTrees ( self , <SPC> n ) : <NL> <TAB> counts <SPC> = <SPC> [ 1 , <SPC> 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          count <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( i ) : <NL>              count <SPC> += <SPC> counts [ j ] <SPC> * <SPC> counts [ i <SPC> - <SPC> j <SPC> - <SPC> 1 ] <NL>          counts . append ( count ) <NL> <TAB> return <SPC> counts [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numUniqueEmails ( self , <SPC> emails ) : <NL> <NL> <TAB> def <SPC> convert ( email ) : <NL>          name , <SPC> domain <SPC> = <SPC> email . split ( "@" ) <NL>          name <SPC> = <SPC> name [ : <SPC> name . index ( "+" ) ] <NL>          return <SPC> "" . join ( [ "" . join ( name . split ( "." ) ) , <SPC> "@" , <SPC> domain ] ) <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> email <SPC> in <SPC> emails : <NL>          lookup . add ( convert ( email ) ) <NL> <TAB> return <SPC> len ( lookup ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> uniqueMorseRepresentations ( self , <SPC> words ) : <NL> <NL> <TAB> MORSE <SPC> = <SPC> [ <NL>          ".-" , <NL>          "-..." , <NL>          "-.-." , <NL>          "-.." , <NL>          "." , <NL>          "..-." , <NL>          "--." , <NL>          "...." , <NL>          ".." , <NL>          ".---" , <NL>          "-.-" , <NL>          ".-.." , <NL>          "--" , <NL>          "-." , <NL>          "---" , <NL>          ".--." , <NL>          "--.-" , <NL>          ".-." , <NL>          "..." , <NL>          "-" , <NL>          "..-" , <NL>          "...-" , <NL>          ".--" , <NL>          "-..-" , <NL>          "-.--" , <NL>          "--.." , <NL> <TAB> ] <NL> <NL> <TAB> lookup <SPC> = <SPC> { "" . join ( MORSE [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <NL>                        for <SPC> c <SPC> in <SPC> word ) <SPC> for <SPC> word <SPC> in <SPC> words } <NL> <TAB> return <SPC> len ( lookup ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> uniqueOccurrences ( self , <SPC> arr ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( arr ) <NL> <TAB> lookup <SPC> = <SPC> set ( ) <NL> <TAB> for <SPC> v <SPC> in <SPC> count . itervalues ( ) : <NL>          if <SPC> v <SPC> in <SPC> lookup : <NL>              return <SPC> False <NL>          lookup . add ( v ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> uniqueOccurrences ( self , <SPC> arr ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( arr ) <NL> <TAB> return <SPC> len ( count ) <SPC> == <SPC> len ( set ( count . itervalues ( ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> uniquePathsWithObstacles ( self , <SPC> obstacleGrid ) : <NL> <NL> <TAB> m , <SPC> n <SPC> = <SPC> len ( obstacleGrid ) , <SPC> len ( obstacleGrid [ 0 ] ) <NL> <NL> <TAB> ways <SPC> = <SPC> [ 0 ] <SPC> * <SPC> n <NL> <TAB> ways [ 0 ] <SPC> = <SPC> 1 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( m ) : <NL>          if <SPC> obstacleGrid [ i ] [ 0 ] <SPC> == <SPC> 1 : <NL>              ways [ 0 ] <SPC> = <SPC> 0 <NL>          for <SPC> j <SPC> in <SPC> xrange ( n ) : <NL>              if <SPC> obstacleGrid [ i ] [ j ] <SPC> == <SPC> 1 : <NL>                  ways [ j ] <SPC> = <SPC> 0 <NL>              elif <SPC> j <SPC> > <SPC> 0 : <NL>                  ways [ j ] <SPC> += <SPC> ways [ j <SPC> - <SPC> 1 ] <NL> <TAB> return <SPC> ways [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> uniquePathsIII ( self , <SPC> grid ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <NL> <TAB> def <SPC> index ( grid , <SPC> r , <SPC> c ) : <NL>          return <SPC> 1 <SPC> << <SPC> ( r <SPC> * <SPC> len ( grid [ 0 ] ) <SPC> + <SPC> c ) <NL> <NL> <TAB> def <SPC> dp ( grid , <SPC> src , <SPC> dst , <SPC> todo , <SPC> lookup ) : <NL>          if <SPC> src <SPC> == <SPC> dst : <NL>              return <SPC> int ( todo <SPC> == <SPC> 0 ) <NL>          key <SPC> = <SPC> ( src , <SPC> todo ) <NL>          if <SPC> key <SPC> in <SPC> lookup : <NL>              return <SPC> lookup [ key ] <NL> <NL>          result <SPC> = <SPC> 0 <NL>          for <SPC> d <SPC> in <SPC> directions : <NL>              r , <SPC> c <SPC> = <SPC> src [ 0 ] <SPC> + <SPC> d [ 0 ] , <SPC> src [ 1 ] <SPC> + <SPC> d [ 1 ] <NL>              if <SPC> ( <NL>                  0 <SPC> <= <SPC> r <SPC> < <SPC> len ( grid ) <NL>                  and <SPC> 0 <SPC> <= <SPC> c <SPC> < <SPC> len ( grid [ 0 ] ) <NL>                  and <SPC> grid [ r ] [ c ] <SPC> % <SPC> 2 <SPC> == <SPC> 0 <NL>                  and <SPC> todo <SPC> & <SPC> index ( grid , <SPC> r , <SPC> c ) <NL>              ) : <NL>                  result <SPC> += <SPC> dp ( grid , <SPC> ( r , <SPC> c ) , <SPC> dst , <SPC> todo <SPC> ^ <NL>                               index ( grid , <SPC> r , <SPC> c ) , <SPC> lookup ) <NL> <NL>          lookup [ key ] <SPC> = <SPC> result <NL>          return <SPC> lookup [ key ] <NL> <NL> <TAB> todo <SPC> = <SPC> 0 <NL> <TAB> src , <SPC> dst <SPC> = <SPC> None , <SPC> None <NL> <TAB> for <SPC> r , <SPC> row <SPC> in <SPC> enumerate ( grid ) : <NL>          for <SPC> c , <SPC> val <SPC> in <SPC> enumerate ( row ) : <NL>              if <SPC> val <SPC> % <SPC> 2 <SPC> == <SPC> 0 : <NL>                  todo <SPC> |= <SPC> index ( grid , <SPC> r , <SPC> c ) <NL>              if <SPC> val <SPC> == <SPC> 1 : <NL>                  src <SPC> = <SPC> ( r , <SPC> c ) <NL>              elif <SPC> val <SPC> == <SPC> 2 : <NL>                  dst <SPC> = <SPC> ( r , <SPC> c ) <NL> <TAB> return <SPC> dp ( grid , <SPC> src , <SPC> dst , <SPC> todo , <SPC> { } ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> uniquePaths ( self , <SPC> m , <SPC> n ) : <NL> <TAB> if <SPC> m <SPC> < <SPC> n : <NL>          return <SPC> self . uniquePaths ( n , <SPC> m ) <NL> <TAB> ways <SPC> = <SPC> [ 1 ] <SPC> * <SPC> n <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> m ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> n ) : <NL>              ways [ j ] <SPC> += <SPC> ways [ j <SPC> - <SPC> 1 ] <NL> <NL> <TAB> return <SPC> ways [ n <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findSubstringInWraproundString ( self , <SPC> p ) : <NL> <NL> <TAB> letters <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 26 <NL> <TAB> result , <SPC> length <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( p ) ) : <NL>          curr <SPC> = <SPC> ord ( p [ i ] ) <SPC> - <SPC> ord ( "a" ) <NL>          if <SPC> i <SPC> > <SPC> 0 <SPC> and <SPC> ord ( p [ i <SPC> - <SPC> 1 ] ) <SPC> != <SPC> ( curr <SPC> - <SPC> 1 ) <SPC> % <SPC> 26 <SPC> + <SPC> ord ( "a" ) : <NL>              length <SPC> = <SPC> 0 <NL>          length <SPC> += <SPC> 1 <NL>          if <SPC> length <SPC> > <SPC> letters [ curr ] : <NL>              result <SPC> += <SPC> length <SPC> - <SPC> letters [ curr ] <NL>              letters [ curr ] <SPC> = <SPC> length <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> ValidWordAbbr ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> dictionary ) : <NL> <NL> <TAB> self . lookup_ <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> for <SPC> word <SPC> in <SPC> dictionary : <NL>          abbr <SPC> = <SPC> self . abbreviation ( word ) <NL>          self . lookup_ [ abbr ] . add ( word ) <NL> <NL> <TAB> def <SPC> isUnique ( self , <SPC> word ) : <NL> <NL> <TAB> abbr <SPC> = <SPC> self . abbreviation ( word ) <NL> <TAB> return <SPC> self . lookup_ [ abbr ] <SPC> <= <SPC> { word } <NL> <NL> <TAB> def <SPC> abbreviation ( self , <SPC> word ) : <NL> <TAB> if <SPC> len ( word ) <SPC> <= <SPC> 2 : <NL>          return <SPC> word <NL> <TAB> return <SPC> word [ 0 ] <SPC> + <SPC> str ( len ( word ) <SPC> - <SPC> 2 ) <SPC> + <SPC> word [ - 1 ] <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isUnivalTree ( self , <SPC> root ) : <NL> <NL> <TAB> s <SPC> = <SPC> [ root ] <NL> <TAB> while <SPC> s : <NL>          node <SPC> = <SPC> s . pop ( ) <NL>          if <SPC> not <SPC> node : <NL>              continue <NL>          if <SPC> node . val <SPC> != <SPC> root . val : <NL>              return <SPC> False <NL>          s . append ( node . left ) <NL>          s . append ( node . right ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isUnivalTree ( self , <SPC> root ) : <NL> <NL> <TAB> return <SPC> ( <NL>          not <SPC> root . left <NL>          or <SPC> ( root . left . val <SPC> == <SPC> root . val <SPC> and <SPC> self . isUnivalTree ( root . left ) ) <NL> <TAB> ) <SPC> and <SPC> ( <NL>          not <SPC> root . right <NL>          or <SPC> ( root . right . val <SPC> == <SPC> root . val <SPC> and <SPC> self . isUnivalTree ( root . right ) ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validUtf8 ( self , <SPC> data ) : <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> data : <NL>          if <SPC> count <SPC> == <SPC> 0 : <NL>              if <SPC> ( c <SPC> >> <SPC> 5 ) <SPC> == <SPC> 0b110 : <NL>                  count <SPC> = <SPC> 1 <NL>              elif <SPC> ( c <SPC> >> <SPC> 4 ) <SPC> == <SPC> 0b1110 : <NL>                  count <SPC> = <SPC> 2 <NL>              elif <SPC> ( c <SPC> >> <SPC> 3 ) <SPC> == <SPC> 0b11110 : <NL>                  count <SPC> = <SPC> 3 <NL>              elif <SPC> c <SPC> >> <SPC> 7 : <NL>                  return <SPC> False <NL>          else : <NL>              if <SPC> ( c <SPC> >> <SPC> 6 ) <SPC> != <SPC> 0b10 : <NL>                  return <SPC> False <NL>              count <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> count <SPC> == <SPC> 0 <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isAnagram ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> if <SPC> len ( s ) <SPC> != <SPC> len ( t ) : <NL>          return <SPC> False <NL> <TAB> count <SPC> = <SPC> collections . defaultdict ( int ) <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          count [ c ] <SPC> += <SPC> 1 <NL> <TAB> for <SPC> c <SPC> in <SPC> t : <NL>          count [ c ] <SPC> -= <SPC> 1 <NL>          if <SPC> count [ c ] <SPC> < <SPC> 0 : <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isAnagram ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> return <SPC> collections . Counter ( s ) <SPC> == <SPC> collections . Counter ( t ) <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <TAB> def <SPC> isAnagram ( self , <SPC> s , <SPC> t ) : <NL> <NL> <TAB> return <SPC> sorted ( s ) <SPC> == <SPC> sorted ( t ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isBoomerang ( self , <SPC> points ) : <NL> <NL> <TAB> return <SPC> ( points [ 0 ] [ 0 ] <SPC> - <SPC> points [ 1 ] [ 0 ] ) <SPC> * <SPC> ( points [ 0 ] [ 1 ] <SPC> - <SPC> points [ 2 ] [ 1 ] ) <SPC> - <SPC> ( <NL>          points [ 0 ] [ 0 ] <SPC> - <SPC> points [ 2 ] [ 0 ] <NL> <TAB> ) <SPC> * <SPC> ( points [ 0 ] [ 1 ] <SPC> - <SPC> points [ 1 ] [ 1 ] ) <SPC> != <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validMountainArray ( self , <SPC> A ) : <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> while <SPC> i <SPC> + <SPC> 1 <SPC> < <SPC> len ( A ) <SPC> and <SPC> A [ i ] <SPC> < <SPC> A [ i <SPC> + <SPC> 1 ] : <NL>          i <SPC> += <SPC> 1 <NL> <TAB> j <SPC> = <SPC> len ( A ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> j <SPC> - <SPC> 1 <SPC> >= <SPC> 0 <SPC> and <SPC> A [ j <SPC> - <SPC> 1 ] <SPC> > <SPC> A [ j ] : <NL>          j <SPC> -= <SPC> 1 <NL> <TAB> return <SPC> 0 <SPC> < <SPC> i <SPC> == <SPC> j <SPC> < <SPC> len ( A ) <SPC> - <SPC> 1 <NL> <NL> <NL> class <SPC> InputType ( object ) : <NL> <TAB> INVALID <SPC> = <SPC> 0 <NL> <TAB> SPACE <SPC> = <SPC> 1 <NL> <TAB> SIGN <SPC> = <SPC> 2 <NL> <TAB> DIGIT <SPC> = <SPC> 3 <NL> <TAB> DOT <SPC> = <SPC> 4 <NL> <TAB> EXPONENT <SPC> = <SPC> 5 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isNumber ( self , <SPC> s ) : <NL> <NL> <TAB> transition_table <SPC> = <SPC> [ <NL>          [ - 1 , <SPC> 0 , <SPC> 3 , <SPC> 1 , <SPC> 2 , <SPC> - 1 ] , <NL>          [ - 1 , <SPC> 8 , <SPC> - 1 , <SPC> 1 , <SPC> 4 , <SPC> 5 ] , <NL>          [ - 1 , <SPC> - 1 , <SPC> - 1 , <SPC> 4 , <SPC> - 1 , <SPC> - 1 ] , <NL>          [ - 1 , <SPC> - 1 , <SPC> - 1 , <SPC> 1 , <SPC> 2 , <SPC> - 1 ] , <NL>          [ - 1 , <SPC> 8 , <SPC> - 1 , <SPC> 4 , <SPC> - 1 , <SPC> 5 ] , <NL>          [ - 1 , <SPC> - 1 , <SPC> 6 , <SPC> 7 , <SPC> - 1 , <SPC> - 1 ] , <NL>          [ - 1 , <SPC> - 1 , <SPC> - 1 , <SPC> 7 , <SPC> - 1 , <SPC> - 1 ] , <NL>          [ - 1 , <SPC> 8 , <SPC> - 1 , <SPC> 7 , <SPC> - 1 , <SPC> - 1 ] , <NL>          [ - 1 , <SPC> 8 , <SPC> - 1 , <SPC> - 1 , <SPC> - 1 , <SPC> - 1 ] , <NL> <TAB> ] <NL> <NL> <TAB> state <SPC> = <SPC> 0 <NL> <TAB> for <SPC> char <SPC> in <SPC> s : <NL>          inputType <SPC> = <SPC> InputType . INVALID <NL>          if <SPC> char . isspace ( ) : <NL>              inputType <SPC> = <SPC> InputType . SPACE <NL>          elif <SPC> char <SPC> == <SPC> "+" <SPC> or <SPC> char <SPC> == <SPC> "-" : <NL>              inputType <SPC> = <SPC> InputType . SIGN <NL>          elif <SPC> char . isdigit ( ) : <NL>              inputType <SPC> = <SPC> InputType . DIGIT <NL>          elif <SPC> char <SPC> == <SPC> "." : <NL>              inputType <SPC> = <SPC> InputType . DOT <NL>          elif <SPC> char <SPC> == <SPC> "e" <SPC> or <SPC> char <SPC> == <SPC> "E" : <NL>              inputType <SPC> = <SPC> InputType . EXPONENT <NL> <NL>          state <SPC> = <SPC> transition_table [ state ] [ inputType ] <NL> <NL>          if <SPC> state <SPC> == <SPC> - 1 : <NL>              return <SPC> False <NL> <NL> <TAB> return <SPC> state <SPC> == <SPC> 1 <SPC> or <SPC> state <SPC> == <SPC> 4 <SPC> or <SPC> state <SPC> == <SPC> 7 <SPC> or <SPC> state <SPC> == <SPC> 8 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> isNumber ( self , <SPC> s ) : <NL> <NL> <TAB> import <SPC> re <NL> <NL> <TAB> return <SPC> bool ( re . match ( "^\s*[\+-]?((\d+(\.\d*)?)|\.\d+)([eE][\+-]?\d+)?\s*$" , <SPC> s ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validPalindrome ( self , <SPC> s ) : <NL> <NL> <TAB> def <SPC> validPalindrome ( s , <SPC> left , <SPC> right ) : <NL>          while <SPC> left <SPC> < <SPC> right : <NL>              if <SPC> s [ left ] <SPC> != <SPC> s [ right ] : <NL>                  return <SPC> False <NL>              left , <SPC> right <SPC> = <SPC> left <SPC> + <SPC> 1 , <SPC> right <SPC> - <SPC> 1 <NL>          return <SPC> True <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( s ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> left <SPC> < <SPC> right : <NL>          if <SPC> s [ left ] <SPC> != <SPC> s [ right ] : <NL>              return <SPC> validPalindrome ( s , <SPC> left , <SPC> right <SPC> - <SPC> 1 ) <SPC> or <SPC> validPalindrome ( <NL>                  s , <SPC> left <SPC> + <SPC> 1 , <SPC> right <NL>              ) <NL>          left , <SPC> right <SPC> = <SPC> left <SPC> + <SPC> 1 , <SPC> right <SPC> - <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isValidPalindrome ( self , <SPC> s , <SPC> k ) : <NL> <NL> <TAB> if <SPC> s <SPC> == <SPC> s [ : : - 1 ] : <NL>          return <SPC> True <NL> <NL> <TAB> dp <SPC> = <SPC> [ [ 1 ] <SPC> * <SPC> len ( s ) <SPC> for <SPC> _ <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( s ) ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( s ) ) : <NL>              if <SPC> s [ i ] <SPC> == <SPC> s [ j ] : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> 2 <SPC> + <SPC> dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <NL>                                        2 ] [ j <SPC> - <SPC> 1 ] <SPC> if <SPC> i <SPC> + <SPC> 1 <SPC> <= <SPC> j <SPC> - <SPC> 1 <SPC> else <SPC> 2 <NL>              else : <NL>                  dp [ i <SPC> % <SPC> 2 ] [ j ] <SPC> = <SPC> max ( dp [ ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 2 ] [ j ] , <SPC> dp [ i <SPC> % <SPC> 2 ] [ j <SPC> - <SPC> 1 ] ) <NL> <TAB> return <SPC> len ( s ) <SPC> <= <SPC> k <SPC> + <SPC> dp [ 0 ] [ - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isPalindrome ( self , <SPC> s ) : <NL> <TAB> i , <SPC> j <SPC> = <SPC> 0 , <SPC> len ( s ) <SPC> - <SPC> 1 <NL> <TAB> while <SPC> i <SPC> < <SPC> j : <NL>          while <SPC> i <SPC> < <SPC> j <SPC> and <SPC> not <SPC> s [ i ] . isalnum ( ) : <NL>              i <SPC> += <SPC> 1 <NL>          while <SPC> i <SPC> < <SPC> j <SPC> and <SPC> not <SPC> s [ j ] . isalnum ( ) : <NL>              j <SPC> -= <SPC> 1 <NL>          if <SPC> s [ i ] . lower ( ) <SPC> != <SPC> s [ j ] . lower ( ) : <NL>              return <SPC> False <NL>          i , <SPC> j <SPC> = <SPC> i <SPC> + <SPC> 1 , <SPC> j <SPC> - <SPC> 1 <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isValid ( self , <SPC> s ) : <NL> <TAB> stack , <SPC> lookup <SPC> = <SPC> [ ] , <SPC> { "(" : <SPC> ")" , <SPC> "{" : <SPC> "}" , <SPC> "[" : <SPC> "]" } <NL> <TAB> for <SPC> parenthese <SPC> in <SPC> s : <NL>          if <SPC> parenthese <SPC> in <SPC> lookup : <NL>              stack . append ( parenthese ) <NL>          elif <SPC> len ( stack ) <SPC> == <SPC> 0 <SPC> or <SPC> lookup [ stack . pop ( ) ] <SPC> != <SPC> parenthese : <NL>              return <SPC> False <NL> <TAB> return <SPC> len ( stack ) <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> checkValidString ( self , <SPC> s ) : <NL> <NL> <TAB> lower , <SPC> upper <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> s : <NL>          lower <SPC> += <SPC> 1 <SPC> if <SPC> c <SPC> == <SPC> "(" <SPC> else <SPC> - 1 <NL>          upper <SPC> -= <SPC> 1 <SPC> if <SPC> c <SPC> == <SPC> ")" <SPC> else <SPC> - 1 <NL>          if <SPC> upper <SPC> < <SPC> 0 : <NL>              break <NL>          lower <SPC> = <SPC> max ( lower , <SPC> 0 ) <NL> <TAB> return <SPC> lower <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isPerfectSquare ( self , <SPC> num ) : <NL> <NL> <TAB> left , <SPC> right <SPC> = <SPC> 1 , <SPC> num <NL> <TAB> while <SPC> left <SPC> <= <SPC> right : <NL>          mid <SPC> = <SPC> left <SPC> + <SPC> ( right <SPC> - <SPC> left ) <SPC> / <SPC> 2 <NL>          if <SPC> mid <SPC> >= <SPC> num <SPC> / <SPC> mid : <NL>              right <SPC> = <SPC> mid <SPC> - <SPC> 1 <NL>          else : <NL>              left <SPC> = <SPC> mid <SPC> + <SPC> 1 <NL> <TAB> return <SPC> left <SPC> == <SPC> num <SPC> / <SPC> left <SPC> and <SPC> num <SPC> % <SPC> left <SPC> == <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numPermsDISequence ( self , <SPC> S ) : <NL> <NL> <TAB> dp <SPC> = <SPC> [ 1 ] <SPC> * <SPC> ( len ( S ) <SPC> + <SPC> 1 ) <NL> <TAB> for <SPC> c <SPC> in <SPC> S : <NL>          if <SPC> c <SPC> == <SPC> "I" : <NL>              dp <SPC> = <SPC> dp [ : - 1 ] <NL>              for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( dp ) ) : <NL>                  dp [ i ] <SPC> += <SPC> dp [ i <SPC> - <SPC> 1 ] <NL>          else : <NL>              dp <SPC> = <SPC> dp [ 1 : ] <NL>              for <SPC> i <SPC> in <SPC> reversed ( xrange ( len ( dp ) <SPC> - <SPC> 1 ) ) : <NL>                  dp [ i ] <SPC> += <SPC> dp [ i <SPC> + <SPC> 1 ] <NL> <TAB> return <SPC> dp [ 0 ] <SPC> % <SPC> ( 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validSquare ( self , <SPC> p1 , <SPC> p2 , <SPC> p3 , <SPC> p4 ) : <NL> <NL> <TAB> def <SPC> dist ( p1 , <SPC> p2 ) : <NL>          return <SPC> ( p1 [ 0 ] <SPC> - <SPC> p2 [ 0 ] ) <SPC> ** <SPC> 2 <SPC> + <SPC> ( p1 [ 1 ] <SPC> - <SPC> p2 [ 1 ] ) <SPC> ** <SPC> 2 <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( <NL>          [ <NL>              dist ( p1 , <SPC> p2 ) , <NL>              dist ( p1 , <SPC> p3 ) , <NL>              dist ( p1 , <SPC> p4 ) , <NL>              dist ( p2 , <SPC> p3 ) , <NL>              dist ( p2 , <SPC> p4 ) , <NL>              dist ( p3 , <SPC> p4 ) , <NL>          ] <NL> <TAB> ) <NL> <TAB> return <SPC> 0 <SPC> not <SPC> in <SPC> lookup <SPC> and <SPC> len ( lookup ) <SPC> == <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isValidSudoku ( self , <SPC> board ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 9 ) : <NL>          if <SPC> not <SPC> self . isValidList ( <NL>              [ board [ i ] [ j ] <SPC> for <SPC> j <SPC> in <SPC> xrange ( 9 ) ] <NL>          ) <SPC> or <SPC> not <SPC> self . isValidList ( [ board [ j ] [ i ] <SPC> for <SPC> j <SPC> in <SPC> xrange ( 9 ) ] ) : <NL>              return <SPC> False <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 3 ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( 3 ) : <NL>              if <SPC> not <SPC> self . isValidList ( <NL>                  [ <NL>                      board [ m ] [ n ] <NL>                      for <SPC> n <SPC> in <SPC> xrange ( 3 <SPC> * <SPC> j , <SPC> 3 <SPC> * <SPC> j <SPC> + <SPC> 3 ) <NL>                      for <SPC> m <SPC> in <SPC> xrange ( 3 <SPC> * <SPC> i , <SPC> 3 <SPC> * <SPC> i <SPC> + <SPC> 3 ) <NL>                  ] <NL>              ) : <NL>                  return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> isValidList ( self , <SPC> xs ) : <NL> <TAB> xs <SPC> = <SPC> filter ( lambda <SPC> x : <SPC> x <SPC> != <SPC> "." , <SPC> xs ) <NL> <TAB> return <SPC> len ( set ( xs ) ) <SPC> == <SPC> len ( xs ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validTicTacToe ( self , <SPC> board ) : <NL> <NL> <TAB> def <SPC> win ( board , <SPC> player ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( 3 ) : <NL>              if <SPC> all ( board [ i ] [ j ] <SPC> == <SPC> player <SPC> for <SPC> j <SPC> in <SPC> xrange ( 3 ) ) : <NL>                  return <SPC> True <NL>              if <SPC> all ( board [ j ] [ i ] <SPC> == <SPC> player <SPC> for <SPC> j <SPC> in <SPC> xrange ( 3 ) ) : <NL>                  return <SPC> True <NL> <NL>          return <SPC> ( <NL>              player <SPC> == <SPC> board [ 1 ] [ 1 ] <SPC> == <SPC> board [ 0 ] [ 0 ] <SPC> == <SPC> board [ 2 ] [ 2 ] <NL>              or <SPC> player <SPC> == <SPC> board [ 1 ] [ 1 ] <SPC> == <SPC> board [ 0 ] [ 2 ] <SPC> == <SPC> board [ 2 ] [ 0 ] <NL>          ) <NL> <NL> <TAB> FIRST , <SPC> SECOND <SPC> = <SPC> ( "X" , <SPC> "O" ) <NL> <TAB> x_count <SPC> = <SPC> sum ( row . count ( FIRST ) <SPC> for <SPC> row <SPC> in <SPC> board ) <NL> <TAB> o_count <SPC> = <SPC> sum ( row . count ( SECOND ) <SPC> for <SPC> row <SPC> in <SPC> board ) <NL> <TAB> if <SPC> o_count <SPC> not <SPC> in <SPC> { x_count <SPC> - <SPC> 1 , <SPC> x_count } : <NL>          return <SPC> False <NL> <TAB> if <SPC> win ( board , <SPC> FIRST ) <SPC> and <SPC> x_count <SPC> - <SPC> 1 <SPC> != <SPC> o_count : <NL>          return <SPC> False <NL> <TAB> if <SPC> win ( board , <SPC> SECOND ) <SPC> and <SPC> x_count <SPC> != <SPC> o_count : <NL>          return <SPC> False <NL> <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> triangleNumber ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> nums . sort ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> reversed ( xrange ( 2 , <SPC> len ( nums ) ) ) : <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> i <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> < <SPC> right : <NL>              if <SPC> nums [ left ] <SPC> + <SPC> nums [ right ] <SPC> > <SPC> nums [ i ] : <NL>                  result <SPC> += <SPC> right <SPC> - <SPC> left <NL>                  right <SPC> -= <SPC> 1 <NL>              else : <NL>                  left <SPC> += <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> triangleNumber ( self , <SPC> nums ) : <NL> <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> nums . sort ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) <SPC> - <SPC> 2 ) : <NL>          if <SPC> nums [ i ] <SPC> == <SPC> 0 : <NL>              continue <NL>          k <SPC> = <SPC> i <SPC> + <SPC> 2 <NL>          for <SPC> j <SPC> in <SPC> xrange ( i <SPC> + <SPC> 1 , <SPC> len ( nums ) <SPC> - <SPC> 1 ) : <NL>              while <SPC> k <SPC> < <SPC> len ( nums ) <SPC> and <SPC> nums [ i ] <SPC> + <SPC> nums [ j ] <SPC> > <SPC> nums [ k ] : <NL>                  k <SPC> += <SPC> 1 <NL>              result <SPC> += <SPC> k <SPC> - <SPC> j <SPC> - <SPC> 1 <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validWordAbbreviation ( self , <SPC> word , <SPC> abbr ) : <NL> <NL> <TAB> i , <SPC> digit <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> abbr : <NL>          if <SPC> c . isdigit ( ) : <NL>              if <SPC> digit <SPC> == <SPC> 0 <SPC> and <SPC> c <SPC> == <SPC> "0" : <NL>                  return <SPC> False <NL>              digit <SPC> *= <SPC> 10 <NL>              digit <SPC> += <SPC> int ( c ) <NL>          else : <NL>              if <SPC> digit : <NL>                  i <SPC> += <SPC> digit <NL>                  digit <SPC> = <SPC> 0 <NL>              if <SPC> i <SPC> >= <SPC> len ( word ) <SPC> or <SPC> word [ i ] <SPC> != <SPC> c : <NL>                  return <SPC> False <NL>              i <SPC> += <SPC> 1 <NL> <TAB> if <SPC> digit : <NL>          i <SPC> += <SPC> digit <NL> <NL> <TAB> return <SPC> i <SPC> == <SPC> len ( word ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validWordSquare ( self , <SPC> words ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( words [ i ] ) ) : <NL>              if <SPC> j <SPC> >= <SPC> len ( words ) <SPC> or <SPC> i <SPC> >= <SPC> len ( words [ j ] ) <SPC> or <SPC> words [ j ] [ i ] <SPC> != <SPC> words [ i ] [ j ] : <NL>                  return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> isValidBST ( self , <SPC> root ) : <NL> <TAB> prev , <SPC> cur <SPC> = <SPC> None , <SPC> root <NL> <TAB> while <SPC> cur : <NL>          if <SPC> cur . left <SPC> is <SPC> None : <NL>              if <SPC> prev <SPC> and <SPC> prev . val <SPC> >= <SPC> cur . val : <NL>                  return <SPC> False <NL>              prev <SPC> = <SPC> cur <NL>              cur <SPC> = <SPC> cur . right <NL>          else : <NL>              node <SPC> = <SPC> cur . left <NL>              while <SPC> node . right <SPC> and <SPC> node . right <SPC> != <SPC> cur : <NL>                  node <SPC> = <SPC> node . right <NL> <NL>              if <SPC> node . right <SPC> is <SPC> None : <NL>                  node . right <SPC> = <SPC> cur <NL>                  cur <SPC> = <SPC> cur . left <NL>              else : <NL>                  if <SPC> prev <SPC> and <SPC> prev . val <SPC> >= <SPC> cur . val : <NL>                      return <SPC> False <NL>                  node . right <SPC> = <SPC> None <NL>                  prev <SPC> = <SPC> cur <NL>                  cur <SPC> = <SPC> cur . right <NL> <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> isValidBST ( self , <SPC> root ) : <NL> <TAB> return <SPC> self . isValidBSTRecu ( root , <SPC> float ( "-inf" ) , <SPC> float ( "inf" ) ) <NL> <NL> <TAB> def <SPC> isValidBSTRecu ( self , <SPC> root , <SPC> low , <SPC> high ) : <NL> <TAB> if <SPC> root <SPC> is <SPC> None : <NL>          return <SPC> True <NL> <NL> <TAB> return <SPC> ( <NL>          low <SPC> < <SPC> root . val <NL>          and <SPC> root . val <SPC> < <SPC> high <NL>          and <SPC> self . isValidBSTRecu ( root . left , <SPC> low , <SPC> root . val ) <NL>          and <SPC> self . isValidBSTRecu ( root . right , <SPC> root . val , <SPC> high ) <NL> <TAB> ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validateBinaryTreeNodes ( self , <SPC> n , <SPC> leftChild , <SPC> rightChild ) : <NL> <NL> <TAB> roots <SPC> = <SPC> set ( range ( n ) ) <SPC> - <SPC> set ( leftChild ) <SPC> - <SPC> set ( rightChild ) <NL> <TAB> if <SPC> len ( roots ) <SPC> != <SPC> 1 : <NL>          return <SPC> False <NL> <TAB> ( root , ) <SPC> = <SPC> roots <NL> <TAB> stk <SPC> = <SPC> [ root ] <NL> <TAB> lookup <SPC> = <SPC> set ( [ root ] ) <NL> <TAB> while <SPC> stk : <NL>          node <SPC> = <SPC> stk . pop ( ) <NL>          for <SPC> c <SPC> in <SPC> ( leftChild [ node ] , <SPC> rightChild [ node ] ) : <NL>              if <SPC> c <SPC> < <SPC> 0 : <NL>                  continue <NL>              if <SPC> c <SPC> in <SPC> lookup : <NL>                  return <SPC> False <NL>              lookup . add ( c ) <NL>              stk . append ( c ) <NL> <TAB> return <SPC> len ( lookup ) <SPC> == <SPC> n <NL> <NL> <NL> import <SPC> string <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validIPAddress ( self , <SPC> IP ) : <NL> <NL> <TAB> blocks <SPC> = <SPC> IP . split ( "." ) <NL> <TAB> if <SPC> len ( blocks ) <SPC> == <SPC> 4 : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( blocks ) ) : <NL>              if <SPC> ( <NL>                  not <SPC> blocks [ i ] . isdigit ( ) <NL>                  or <SPC> not <SPC> 0 <SPC> <= <SPC> int ( blocks [ i ] ) <SPC> < <SPC> 256 <NL>                  or <SPC> ( blocks [ i ] [ 0 ] <SPC> == <SPC> "0" <SPC> and <SPC> len ( blocks [ i ] ) <SPC> > <SPC> 1 ) <NL>              ) : <NL>                  return <SPC> "Neither" <NL>          return <SPC> "IPv4" <NL> <NL> <TAB> blocks <SPC> = <SPC> IP . split ( ":" ) <NL> <TAB> if <SPC> len ( blocks ) <SPC> == <SPC> 8 : <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( blocks ) ) : <NL>              if <SPC> not <SPC> ( 1 <SPC> <= <SPC> len ( blocks [ i ] ) <SPC> <= <SPC> 4 ) <SPC> or <SPC> not <SPC> all ( <NL>                  c <SPC> in <SPC> string . hexdigits <SPC> for <SPC> c <SPC> in <SPC> blocks [ i ] <NL>              ) : <NL>                  return <SPC> "Neither" <NL>          return <SPC> "IPv6" <NL> <TAB> return <SPC> "Neither" <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> validateStackSequences ( self , <SPC> pushed , <SPC> popped ) : <NL> <NL> <TAB> i <SPC> = <SPC> 0 <NL> <TAB> s <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> v <SPC> in <SPC> pushed : <NL>          s . append ( v ) <NL>          while <SPC> s <SPC> and <SPC> i <SPC> < <SPC> len ( popped ) <SPC> and <SPC> s [ - 1 ] <SPC> == <SPC> popped [ i ] : <NL>              s . pop ( ) <NL>              i <SPC> += <SPC> 1 <NL> <TAB> return <SPC> i <SPC> == <SPC> len ( popped ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isSolvable ( self , <SPC> words , <SPC> result ) : <NL> <NL> <TAB> def <SPC> backtracking ( words , <SPC> result , <SPC> i , <SPC> j , <SPC> carry , <SPC> lookup , <SPC> used ) : <NL>          if <SPC> j <SPC> == <SPC> len ( result ) : <NL>              return <SPC> carry <SPC> == <SPC> 0 <NL> <NL>          if <SPC> i <SPC> != <SPC> len ( words ) : <NL>              if <SPC> j <SPC> >= <SPC> len ( words [ i ] ) <SPC> or <SPC> words [ i ] [ j ] <SPC> in <SPC> lookup : <NL>                  return <SPC> backtracking ( words , <SPC> result , <SPC> i <SPC> + <SPC> 1 , <SPC> j , <SPC> carry , <SPC> lookup , <SPC> used ) <NL>              for <SPC> val <SPC> in <SPC> xrange ( 10 ) : <NL>                  if <SPC> val <SPC> in <SPC> used <SPC> or <SPC> ( val <SPC> == <SPC> 0 <SPC> and <SPC> j <SPC> == <SPC> len ( words [ i ] ) <SPC> - <SPC> 1 ) : <NL>                      continue <NL>                  lookup [ words [ i ] [ j ] ] <SPC> = <SPC> val <NL>                  used . add ( val ) <NL>                  if <SPC> backtracking ( words , <SPC> result , <SPC> i <SPC> + <SPC> 1 , <SPC> j , <SPC> carry , <SPC> lookup , <SPC> used ) : <NL>                      return <SPC> True <NL>                  used . remove ( val ) <NL>                  del <SPC> lookup [ words [ i ] [ j ] ] <NL>              return <SPC> False <NL> <NL>          carry , <SPC> val <SPC> = <SPC> divmod ( <NL>              carry <SPC> + <SPC> sum ( lookup [ w [ j ] ] <SPC> for <SPC> w <SPC> in <SPC> words <SPC> if <SPC> j <SPC> < <SPC> len ( w ) ) , <SPC> 10 <NL>          ) <NL>          if <SPC> result [ j ] <SPC> in <SPC> lookup : <NL>              return <SPC> val <SPC> == <SPC> lookup [ result [ j ] ] <SPC> and <SPC> backtracking ( <NL>                  words , <SPC> result , <SPC> 0 , <SPC> j <SPC> + <SPC> 1 , <SPC> carry , <SPC> lookup , <SPC> used <NL>              ) <NL>          if <SPC> val <SPC> in <SPC> used <SPC> or <SPC> ( val <SPC> == <SPC> 0 <SPC> and <SPC> j <SPC> == <SPC> len ( result ) <SPC> - <SPC> 1 ) : <NL>              return <SPC> False <NL>          lookup [ result [ j ] ] <SPC> = <SPC> val <NL>          used . add ( val ) <NL>          if <SPC> backtracking ( words , <SPC> result , <SPC> 0 , <SPC> j <SPC> + <SPC> 1 , <SPC> carry , <SPC> lookup , <SPC> used ) : <NL>              return <SPC> True <NL>          used . remove ( val ) <NL>          del <SPC> lookup [ result [ j ] ] <NL>          return <SPC> False <NL> <NL> <TAB> return <SPC> backtracking ( [ w [ : : - 1 ] <SPC> for <SPC> w <SPC> in <SPC> words ] , <SPC> result [ : : - 1 ] , <SPC> 0 , <SPC> 0 , <SPC> 0 , <SPC> { } , <SPC> set ( ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> verifyPreorder ( self , <SPC> preorder ) : <NL> <TAB> low , <SPC> i <SPC> = <SPC> float ( "-inf" ) , <SPC> - 1 <NL> <TAB> for <SPC> p <SPC> in <SPC> preorder : <NL>          if <SPC> p <SPC> < <SPC> low : <NL>              return <SPC> False <NL>          while <SPC> i <SPC> >= <SPC> 0 <SPC> and <SPC> p <SPC> > <SPC> preorder [ i ] : <NL>              low <SPC> = <SPC> preorder [ i ] <NL>              i <SPC> -= <SPC> 1 <NL>          i <SPC> += <SPC> 1 <NL>          preorder [ i ] <SPC> = <SPC> p <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> verifyPreorder ( self , <SPC> preorder ) : <NL> <TAB> low <SPC> = <SPC> float ( "-inf" ) <NL> <TAB> path <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> p <SPC> in <SPC> preorder : <NL>          if <SPC> p <SPC> < <SPC> low : <NL>              return <SPC> False <NL>          while <SPC> path <SPC> and <SPC> p <SPC> > <SPC> path [ - 1 ] : <NL>              low <SPC> = <SPC> path [ - 1 ] <NL>              path . pop ( ) <NL>          path . append ( p ) <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isValidSerialization ( self , <SPC> preorder ) : <NL> <NL> <TAB> def <SPC> split_iter ( s , <SPC> tok ) : <NL>          start <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s ) ) : <NL>              if <SPC> s [ i ] <SPC> == <SPC> tok : <NL>                  yield <SPC> s [ start : i ] <NL>                  start <SPC> = <SPC> i <SPC> + <SPC> 1 <NL>          yield <SPC> s [ start : ] <NL> <NL> <TAB> if <SPC> not <SPC> preorder : <NL>          return <SPC> False <NL> <NL> <TAB> depth , <SPC> cnt <SPC> = <SPC> 0 , <SPC> preorder . count ( "," ) <SPC> + <SPC> 1 <NL> <TAB> for <SPC> tok <SPC> in <SPC> split_iter ( preorder , <SPC> "," ) : <NL>          cnt <SPC> -= <SPC> 1 <NL>          if <SPC> tok <SPC> == <SPC> "#" : <NL>              depth <SPC> -= <SPC> 1 <NL>              if <SPC> depth <SPC> < <SPC> 0 : <NL>                  break <NL>          else : <NL>              depth <SPC> += <SPC> 1 <NL> <TAB> return <SPC> cnt <SPC> == <SPC> 0 <SPC> and <SPC> depth <SPC> < <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isAlienSorted ( self , <SPC> words , <SPC> order ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> { c : <SPC> i <SPC> for <SPC> i , <SPC> c <SPC> in <SPC> enumerate ( order ) } <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) <SPC> - <SPC> 1 ) : <NL>          word1 <SPC> = <SPC> words [ i ] <NL>          word2 <SPC> = <SPC> words [ i <SPC> + <SPC> 1 ] <NL>          for <SPC> k <SPC> in <SPC> xrange ( min ( len ( word1 ) , <SPC> len ( word2 ) ) ) : <NL>              if <SPC> word1 [ k ] <SPC> != <SPC> word2 [ k ] : <NL>                  if <SPC> lookup [ word1 [ k ] ] <SPC> > <SPC> lookup [ word2 [ k ] ] : <NL>                      return <SPC> False <NL>                  break <NL>          else : <NL>              if <SPC> len ( word1 ) <SPC> > <SPC> len ( word2 ) : <NL>                  return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> TreeNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> x ) : <NL> <TAB> self . val <SPC> = <SPC> x <NL> <TAB> self . left <SPC> = <SPC> None <NL> <TAB> self . right <SPC> = <SPC> None <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> verticalTraversal ( self , <SPC> root ) : <NL> <NL> <TAB> def <SPC> dfs ( node , <SPC> lookup , <SPC> x , <SPC> y ) : <NL>          if <SPC> not <SPC> node : <NL>              return <NL>          lookup [ x ] [ y ] . append ( node ) <NL>          dfs ( node . left , <SPC> lookup , <SPC> x <SPC> - <SPC> 1 , <SPC> y <SPC> + <SPC> 1 ) <NL>          dfs ( node . right , <SPC> lookup , <SPC> x <SPC> + <SPC> 1 , <SPC> y <SPC> + <SPC> 1 ) <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( lambda : <SPC> collections . defaultdict ( list ) ) <NL> <TAB> dfs ( root , <SPC> lookup , <SPC> 0 , <SPC> 0 ) <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> x <SPC> in <SPC> sorted ( lookup ) : <NL>          report <SPC> = <SPC> [ ] <NL>          for <SPC> y <SPC> in <SPC> sorted ( lookup [ x ] ) : <NL>              report . extend ( sorted ( node . val <SPC> for <SPC> node <SPC> in <SPC> lookup [ x ] [ y ] ) ) <NL>          result . append ( report ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> videoStitching ( self , <SPC> clips , <SPC> T ) : <NL> <NL> <TAB> if <SPC> T <SPC> == <SPC> 0 : <NL>          return <SPC> 0 <NL> <TAB> result <SPC> = <SPC> 1 <NL> <TAB> curr_reachable , <SPC> reachable <SPC> = <SPC> 0 , <SPC> 0 <NL> <TAB> clips . sort ( ) <NL> <TAB> for <SPC> left , <SPC> right <SPC> in <SPC> clips : <NL>          if <SPC> left <SPC> > <SPC> reachable : <NL>              break <NL>          elif <SPC> left <SPC> > <SPC> curr_reachable : <NL>              curr_reachable <SPC> = <SPC> reachable <NL>              result <SPC> += <SPC> 1 <NL>          reachable <SPC> = <SPC> max ( reachable , <SPC> right ) <NL>          if <SPC> reachable <SPC> >= <SPC> T : <NL>              return <SPC> result <NL> <TAB> return <SPC> - 1 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> spellchecker ( self , <SPC> wordlist , <SPC> queries ) : <NL> <NL> <TAB> vowels <SPC> = <SPC> set ( [ "a" , <SPC> "e" , <SPC> "i" , <SPC> "o" , <SPC> "u" ] ) <NL> <NL> <TAB> def <SPC> todev ( word ) : <NL>          return <SPC> "" . join ( "*" <SPC> if <SPC> c . lower ( ) <SPC> in <SPC> vowels <SPC> else <SPC> c . lower ( ) <SPC> for <SPC> c <SPC> in <SPC> word ) <NL> <NL> <TAB> words <SPC> = <SPC> set ( wordlist ) <NL> <TAB> caps <SPC> = <SPC> { } <NL> <TAB> vows <SPC> = <SPC> { } <NL> <NL> <TAB> for <SPC> word <SPC> in <SPC> wordlist : <NL>          caps . setdefault ( word . lower ( ) , <SPC> word ) <NL>          vows . setdefault ( todev ( word ) , <SPC> word ) <NL> <NL> <TAB> def <SPC> check ( query ) : <NL>          if <SPC> query <SPC> in <SPC> words : <NL>              return <SPC> query <NL>          lower <SPC> = <SPC> query . lower ( ) <NL>          if <SPC> lower <SPC> in <SPC> caps : <NL>              return <SPC> caps [ lower ] <NL>          devow <SPC> = <SPC> todev ( lower ) <NL>          if <SPC> devow <SPC> in <SPC> vows : <NL>              return <SPC> vows [ devow ] <NL>          return <SPC> "" <NL> <NL> <TAB> return <SPC> map ( check , <SPC> queries ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> robotSim ( self , <SPC> commands , <SPC> obstacles ) : <NL> <NL> <TAB> directions <SPC> = <SPC> [ ( 0 , <SPC> 1 ) , <SPC> ( 1 , <SPC> 0 ) , <SPC> ( 0 , <SPC> - 1 ) , <SPC> ( - 1 , <SPC> 0 ) ] <NL> <TAB> x , <SPC> y , <SPC> i <SPC> = <SPC> 0 , <SPC> 0 , <SPC> 0 <NL> <TAB> lookup <SPC> = <SPC> set ( map ( tuple , <SPC> obstacles ) ) <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> cmd <SPC> in <SPC> commands : <NL>          if <SPC> cmd <SPC> == <SPC> - 2 : <NL>              i <SPC> = <SPC> ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> 4 <NL>          elif <SPC> cmd <SPC> == <SPC> - 1 : <NL>              i <SPC> = <SPC> ( i <SPC> + <SPC> 1 ) <SPC> % <SPC> 4 <NL>          else : <NL>              for <SPC> k <SPC> in <SPC> xrange ( cmd ) : <NL>                  if <SPC> ( x <SPC> + <SPC> directions [ i ] [ 0 ] , <SPC> y <SPC> + <SPC> directions [ i ] [ 1 ] ) <SPC> not <SPC> in <SPC> lookup : <NL>                      x <SPC> += <SPC> directions [ i ] [ 0 ] <NL>                      y <SPC> += <SPC> directions [ i ] [ 1 ] <NL>                      result <SPC> = <SPC> max ( result , <SPC> x <SPC> * <SPC> x <SPC> + <SPC> y <SPC> * <SPC> y ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> deque <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wallsAndGates ( self , <SPC> rooms ) : <NL> <NL> <TAB> INF <SPC> = <SPC> 2147483647 <NL> <TAB> q <SPC> = <SPC> deque ( <NL>          [ ( i , <SPC> j ) <SPC> for <SPC> i , <SPC> row <SPC> in <SPC> enumerate ( rooms ) <NL>           for <SPC> j , <SPC> r <SPC> in <SPC> enumerate ( row ) <SPC> if <SPC> not <SPC> r ] <NL> <TAB> ) <NL> <TAB> while <SPC> q : <NL>          ( i , <SPC> j ) <SPC> = <SPC> q . popleft ( ) <NL>          for <SPC> I , <SPC> J <SPC> in <SPC> ( i <SPC> + <SPC> 1 , <SPC> j ) , <SPC> ( i <SPC> - <SPC> 1 , <SPC> j ) , <SPC> ( i , <SPC> j <SPC> + <SPC> 1 ) , <SPC> ( i , <SPC> j <SPC> - <SPC> 1 ) : <NL>              if <SPC> ( <NL>                  0 <SPC> <= <SPC> I <SPC> < <SPC> len ( rooms ) <NL>                  and <SPC> 0 <SPC> <= <SPC> J <SPC> < <SPC> len ( rooms [ 0 ] ) <NL>                  and <SPC> rooms [ I ] [ J ] <SPC> == <SPC> INF <NL>              ) : <NL>                  rooms [ I ] [ J ] <SPC> = <SPC> rooms [ i ] [ j ] <SPC> + <SPC> 1 <NL>                  q . append ( ( I , <SPC> J ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> canMeasureWater ( self , <SPC> x , <SPC> y , <SPC> z ) : <NL> <NL> <TAB> def <SPC> gcd ( a , <SPC> b ) : <NL>          while <SPC> b : <NL>              a , <SPC> b <SPC> = <SPC> b , <SPC> a <SPC> % <SPC> b <NL>          return <SPC> a <NL> <NL> <TAB> return <SPC> z <SPC> == <SPC> 0 <SPC> or <SPC> ( ( z <SPC> <= <SPC> x <SPC> + <SPC> y ) <SPC> and <SPC> ( z <SPC> % <SPC> gcd ( x , <SPC> y ) <SPC> == <SPC> 0 ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> numWaterBottles ( self , <SPC> numBottles , <SPC> numExchange ) : <NL> <NL> <TAB> result <SPC> = <SPC> numBottles <NL> <TAB> while <SPC> numBottles <SPC> >= <SPC> numExchange : <NL>          numBottles , <SPC> remainder <SPC> = <SPC> divmod ( numBottles , <SPC> numExchange ) <NL>          result <SPC> += <SPC> numBottles <NL>          numBottles <SPC> += <SPC> remainder <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> waysToMakeFair ( self , <SPC> nums ) : <NL> <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <SPC> * <SPC> 2 <NL> <TAB> suffix <SPC> = <SPC> [ sum ( nums [ i ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( k , <SPC> len ( nums ) , <SPC> 2 ) ) <SPC> for <SPC> k <SPC> in <SPC> xrange ( 2 ) ] <NL> <TAB> result <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i , <SPC> num <SPC> in <SPC> enumerate ( nums ) : <NL>          suffix [ i <SPC> % <SPC> 2 ] <SPC> -= <SPC> num <NL>          result <SPC> += <SPC> int ( prefix [ 0 ] <SPC> + <SPC> suffix [ 1 ] <SPC> == <SPC> prefix [ 1 ] <SPC> + <SPC> suffix [ 0 ] ) <NL>          prefix [ i <SPC> % <SPC> 2 ] <SPC> += <SPC> num <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> waysToSplit ( self , <SPC> nums ) : <NL> <NL> <TAB> MOD <SPC> = <SPC> 10 <SPC> ** <SPC> 9 <SPC> + <SPC> 7 <NL> <NL> <TAB> prefix <SPC> = <SPC> [ 0 ] <NL> <TAB> for <SPC> x <SPC> in <SPC> nums : <NL>          prefix . append ( prefix [ - 1 ] <SPC> + <SPC> x ) <NL> <NL> <TAB> result <SPC> = <SPC> left <SPC> = <SPC> right <SPC> = <SPC> 0 <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( nums ) ) : <NL>          left <SPC> = <SPC> max ( left , <SPC> i <SPC> + <SPC> 1 ) <NL>          while <SPC> ( <NL>              left <SPC> + <SPC> 1 <SPC> < <SPC> len ( nums ) <NL>              and <SPC> prefix [ i <SPC> + <SPC> 1 ] <SPC> > <SPC> prefix [ left <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ i <SPC> + <SPC> 1 ] <NL>          ) : <NL>              left <SPC> += <SPC> 1 <NL>          right <SPC> = <SPC> max ( right , <SPC> left ) <NL>          while <SPC> ( <NL>              right <SPC> + <SPC> 1 <SPC> < <SPC> len ( nums ) <NL>              and <SPC> prefix [ right <SPC> + <SPC> 1 ] <SPC> - <SPC> prefix [ i <SPC> + <SPC> 1 ] <SPC> <= <SPC> prefix [ - 1 ] <SPC> - <SPC> prefix [ right <SPC> + <SPC> 1 ] <NL>          ) : <NL>              right <SPC> += <SPC> 1 <NL>          result <SPC> = <SPC> ( result <SPC> + <SPC> ( right <SPC> - <SPC> left ) ) <SPC> % <SPC> MOD <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> threading <NL> import <SPC> Queue <NL> <NL> <NL> class <SPC> HtmlParser ( object ) : <NL> <TAB> def <SPC> getUrls ( self , <SPC> url ) : <NL> <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> NUMBER_OF_WORKERS <SPC> = <SPC> 8 <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __cv <SPC> = <SPC> threading . Condition ( ) <NL> <TAB> self . __q <SPC> = <SPC> Queue . Queue ( ) <NL> <NL> <TAB> def <SPC> crawl ( self , <SPC> startUrl , <SPC> htmlParser ) : <NL> <NL> <TAB> SCHEME <SPC> = <SPC> "http://" <NL> <NL> <TAB> def <SPC> hostname ( url ) : <NL>          pos <SPC> = <SPC> url . find ( "/" , <SPC> len ( SCHEME ) ) <NL>          if <SPC> pos <SPC> == <SPC> - 1 : <NL>              return <SPC> url <NL>          return <SPC> url [ : pos ] <NL> <NL> <TAB> def <SPC> worker ( htmlParser , <SPC> lookup ) : <NL>          while <SPC> True : <NL>              from_url <SPC> = <SPC> self . __q . get ( ) <NL>              if <SPC> from_url <SPC> is <SPC> None : <NL>                  break <NL>              name <SPC> = <SPC> hostname ( from_url ) <NL>              for <SPC> to_url <SPC> in <SPC> htmlParser . getUrls ( from_url ) : <NL>                  if <SPC> name <SPC> != <SPC> hostname ( to_url ) : <NL>                      continue <NL>                  with <SPC> self . __cv : <NL>                      if <SPC> to_url <SPC> not <SPC> in <SPC> lookup : <NL>                          lookup . add ( to_url ) <NL>                          self . __q . put ( to_url ) <NL>              self . __q . task_done ( ) <NL> <NL> <TAB> workers <SPC> = <SPC> [ ] <NL> <TAB> self . __q <SPC> = <SPC> Queue . Queue ( ) <NL> <TAB> self . __q . put ( startUrl ) <NL> <TAB> lookup <SPC> = <SPC> set ( [ startUrl ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . NUMBER_OF_WORKERS ) : <NL>          t <SPC> = <SPC> threading . Thread ( target = worker , <SPC> args = ( htmlParser , <SPC> lookup ) ) <NL>          t . start ( ) <NL>          workers . append ( t ) <NL> <TAB> self . __q . join ( ) <NL> <TAB> for <SPC> t <SPC> in <SPC> workers : <NL>          self . __q . put ( None ) <NL> <TAB> for <SPC> t <SPC> in <SPC> workers : <NL>          t . join ( ) <NL> <TAB> return <SPC> list ( lookup ) <NL> <NL> <NL> import <SPC> threading <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> NUMBER_OF_WORKERS <SPC> = <SPC> 8 <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . __cv <SPC> = <SPC> threading . Condition ( ) <NL> <TAB> self . __q <SPC> = <SPC> collections . deque ( ) <NL> <TAB> self . __working_count <SPC> = <SPC> 0 <NL> <NL> <TAB> def <SPC> crawl ( self , <SPC> startUrl , <SPC> htmlParser ) : <NL> <NL> <TAB> SCHEME <SPC> = <SPC> "http://" <NL> <NL> <TAB> def <SPC> hostname ( url ) : <NL>          pos <SPC> = <SPC> url . find ( "/" , <SPC> len ( SCHEME ) ) <NL>          if <SPC> pos <SPC> == <SPC> - 1 : <NL>              return <SPC> url <NL>          return <SPC> url [ : pos ] <NL> <NL> <TAB> def <SPC> worker ( htmlParser , <SPC> lookup ) : <NL>          while <SPC> True : <NL>              with <SPC> self . __cv : <NL>                  while <SPC> not <SPC> self . __q : <NL>                      self . __cv . wait ( ) <NL>                  from_url <SPC> = <SPC> self . __q . popleft ( ) <NL>                  if <SPC> from_url <SPC> is <SPC> None : <NL>                      break <NL>                  self . __working_count <SPC> += <SPC> 1 <NL>              name <SPC> = <SPC> hostname ( from_url ) <NL>              for <SPC> to_url <SPC> in <SPC> htmlParser . getUrls ( from_url ) : <NL>                  if <SPC> name <SPC> != <SPC> hostname ( to_url ) : <NL>                      continue <NL>                  with <SPC> self . __cv : <NL>                      if <SPC> to_url <SPC> not <SPC> in <SPC> lookup : <NL>                          lookup . add ( to_url ) <NL>                          self . __q . append ( to_url ) <NL>                          self . __cv . notifyAll ( ) <NL>              with <SPC> self . __cv : <NL>                  self . __working_count <SPC> -= <SPC> 1 <NL>                  if <SPC> not <SPC> self . __q <SPC> and <SPC> not <SPC> self . __working_count : <NL>                      self . __cv . notifyAll ( ) <NL> <NL> <TAB> workers <SPC> = <SPC> [ ] <NL> <TAB> self . __q <SPC> = <SPC> collections . deque ( [ startUrl ] ) <NL> <TAB> lookup <SPC> = <SPC> set ( [ startUrl ] ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( self . NUMBER_OF_WORKERS ) : <NL>          t <SPC> = <SPC> threading . Thread ( target = worker , <SPC> args = ( htmlParser , <SPC> lookup ) ) <NL>          t . start ( ) <NL>          workers . append ( t ) <NL> <TAB> with <SPC> self . __cv : <NL>          while <SPC> self . __q <SPC> or <SPC> self . __working_count : <NL>              self . __cv . wait ( ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( self . NUMBER_OF_WORKERS ) : <NL>              self . __q . append ( None ) <NL>          self . __cv . notifyAll ( ) <NL> <TAB> for <SPC> t <SPC> in <SPC> workers : <NL>          t . join ( ) <NL> <TAB> return <SPC> list ( lookup ) <NL> <NL> <NL> class <SPC> HtmlParser ( object ) : <NL> <TAB> def <SPC> getUrls ( self , <SPC> url ) : <NL> <NL> <TAB> pass <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> crawl ( self , <SPC> startUrl , <SPC> htmlParser ) : <NL> <NL> <TAB> SCHEME <SPC> = <SPC> "http://" <NL> <NL> <TAB> def <SPC> hostname ( url ) : <NL>          pos <SPC> = <SPC> url . find ( "/" , <SPC> len ( SCHEME ) ) <NL>          if <SPC> pos <SPC> == <SPC> - 1 : <NL>              return <SPC> url <NL>          return <SPC> url [ : pos ] <NL> <NL> <TAB> result <SPC> = <SPC> [ startUrl ] <NL> <TAB> lookup <SPC> = <SPC> set ( result ) <NL> <TAB> for <SPC> from_url <SPC> in <SPC> result : <NL>          name <SPC> = <SPC> hostname ( from_url ) <NL>          for <SPC> to_url <SPC> in <SPC> htmlParser . getUrls ( from_url ) : <NL>              if <SPC> to_url <SPC> not <SPC> in <SPC> lookup <SPC> and <SPC> name <SPC> == <SPC> hostname ( to_url ) : <NL>                  result . append ( to_url ) <NL>                  lookup . add ( to_url ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findBall ( self , <SPC> grid ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> c <SPC> in <SPC> xrange ( len ( grid [ 0 ] ) ) : <NL>          for <SPC> r <SPC> in <SPC> xrange ( len ( grid ) ) : <NL>              nc <SPC> = <SPC> c <SPC> + <SPC> grid [ r ] [ c ] <NL>              if <SPC> not <SPC> ( 0 <SPC> <= <SPC> nc <SPC> < <SPC> len ( grid [ 0 ] ) <SPC> and <SPC> grid [ r ] [ nc ] <SPC> == <SPC> grid [ r ] [ c ] ) : <NL>                  c <SPC> = <SPC> - 1 <NL>                  break <NL>              c <SPC> = <SPC> nc <NL>          result . append ( c ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> itertools <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> maxWidthOfVerticalArea ( self , <SPC> points ) : <NL> <NL> <TAB> sorted_x <SPC> = <SPC> sorted ( { x <SPC> for <SPC> x , <SPC> y <SPC> in <SPC> points } ) <NL> <TAB> return <SPC> max ( [ b <SPC> - <SPC> a <SPC> for <SPC> a , <SPC> b <SPC> in <SPC> itertools . izip ( sorted_x , <SPC> sorted_x [ 1 : ] ) ] <SPC> + <SPC> [ 0 ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wiggleSort ( self , <SPC> nums ) : <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> med <SPC> = <SPC> ( len ( nums ) <SPC> - <SPC> 1 ) <SPC> / <SPC> 2 <NL> <TAB> nums [ : : 2 ] , <SPC> nums [ 1 : : 2 ] <SPC> = <SPC> nums [ med : : - 1 ] , <SPC> nums [ : med : - 1 ] <NL> <NL> <NL> from <SPC> random <SPC> import <SPC> randint <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> wiggleSort ( self , <SPC> nums ) : <NL> <NL> <TAB> def <SPC> findKthLargest ( nums , <SPC> k ) : <NL>          left , <SPC> right <SPC> = <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> left <SPC> <= <SPC> right : <NL>              pivot_idx <SPC> = <SPC> randint ( left , <SPC> right ) <NL>              new_pivot_idx <SPC> = <SPC> partitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) <NL>              if <SPC> new_pivot_idx <SPC> == <SPC> k <SPC> - <SPC> 1 : <NL>                  return <SPC> nums [ new_pivot_idx ] <NL>              elif <SPC> new_pivot_idx <SPC> > <SPC> k <SPC> - <SPC> 1 : <NL>                  right <SPC> = <SPC> new_pivot_idx <SPC> - <SPC> 1 <NL>              else : <NL>                  left <SPC> = <SPC> new_pivot_idx <SPC> + <SPC> 1 <NL> <NL> <TAB> def <SPC> partitionAroundPivot ( left , <SPC> right , <SPC> pivot_idx , <SPC> nums ) : <NL>          pivot_value <SPC> = <SPC> nums [ pivot_idx ] <NL>          new_pivot_idx <SPC> = <SPC> left <NL>          nums [ pivot_idx ] , <SPC> nums [ right ] <SPC> = <SPC> nums [ right ] , <SPC> nums [ pivot_idx ] <NL>          for <SPC> i <SPC> in <SPC> xrange ( left , <SPC> right ) : <NL>              if <SPC> nums [ i ] <SPC> > <SPC> pivot_value : <NL>                  nums [ i ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ i ] <NL>                  new_pivot_idx <SPC> += <SPC> 1 <NL>          nums [ right ] , <SPC> nums [ new_pivot_idx ] <SPC> = <SPC> nums [ new_pivot_idx ] , <SPC> nums [ right ] <NL>          return <SPC> new_pivot_idx <NL> <NL> <TAB> def <SPC> reversedTriPartitionWithVI ( nums , <SPC> val ) : <NL>          def <SPC> idx ( i , <SPC> N ) : <NL>              return <SPC> ( 1 <SPC> + <SPC> 2 <SPC> * <SPC> ( i ) ) <SPC> % <SPC> N <NL> <NL>          N <SPC> = <SPC> len ( nums ) <SPC> / <SPC> 2 <SPC> * <SPC> 2 <SPC> + <SPC> 1 <NL>          i , <SPC> j , <SPC> n <SPC> = <SPC> 0 , <SPC> 0 , <SPC> len ( nums ) <SPC> - <SPC> 1 <NL>          while <SPC> j <SPC> <= <SPC> n : <NL>              if <SPC> nums [ idx ( j , <SPC> N ) ] <SPC> > <SPC> val : <NL>                  nums [ idx ( i , <SPC> N ) ] , <SPC> nums [ idx ( j , <SPC> N ) <NL>                                        ] <SPC> = <SPC> nums [ idx ( j , <SPC> N ) ] , <SPC> nums [ idx ( i , <SPC> N ) ] <NL>                  i <SPC> += <SPC> 1 <NL>                  j <SPC> += <SPC> 1 <NL>              elif <SPC> nums [ idx ( j , <SPC> N ) ] <SPC> < <SPC> val : <NL>                  nums [ idx ( j , <SPC> N ) ] , <SPC> nums [ idx ( n , <SPC> N ) <NL>                                        ] <SPC> = <SPC> nums [ idx ( n , <SPC> N ) ] , <SPC> nums [ idx ( j , <SPC> N ) ] <NL>                  n <SPC> -= <SPC> 1 <NL>              else : <NL>                  j <SPC> += <SPC> 1 <NL> <NL> <TAB> mid <SPC> = <SPC> ( len ( nums ) <SPC> - <SPC> 1 ) <SPC> / <SPC> 2 <NL> <TAB> findKthLargest ( nums , <SPC> mid <SPC> + <SPC> 1 ) <NL> <TAB> reversedTriPartitionWithVI ( nums , <SPC> nums [ mid ] ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wiggleSort ( self , <SPC> nums ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( nums ) ) : <NL>          if <SPC> ( ( i <SPC> % <SPC> 2 ) <SPC> and <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> > <SPC> nums [ i ] ) <SPC> or <SPC> ( <NL>              not <SPC> ( i <SPC> % <SPC> 2 ) <SPC> and <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> nums [ i ] <NL>          ) : <NL> <NL>              nums [ i <SPC> - <SPC> 1 ] , <SPC> nums [ i ] <SPC> = <SPC> nums [ i ] , <SPC> nums [ i <SPC> - <SPC> 1 ] <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> wiggleSort ( self , <SPC> nums ) : <NL> <NL> <TAB> nums . sort ( ) <NL> <TAB> med <SPC> = <SPC> ( len ( nums ) <SPC> - <SPC> 1 ) <SPC> // <SPC> 2 <NL> <TAB> nums [ : : 2 ] , <SPC> nums [ 1 : : 2 ] <SPC> = <SPC> nums [ med : : - 1 ] , <SPC> nums [ : med : - 1 ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wiggleMaxLength ( self , <SPC> nums ) : <NL> <NL> <TAB> if <SPC> len ( nums ) <SPC> < <SPC> 2 : <NL>          return <SPC> len ( nums ) <NL> <NL> <TAB> length , <SPC> up <SPC> = <SPC> 1 , <SPC> None <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( nums ) ) : <NL>          if <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> < <SPC> nums [ i ] <SPC> and <SPC> ( up <SPC> is <SPC> None <SPC> or <SPC> up <SPC> is <SPC> False ) : <NL>              length <SPC> += <SPC> 1 <NL>              up <SPC> = <SPC> True <NL>          elif <SPC> nums [ i <SPC> - <SPC> 1 ] <SPC> > <SPC> nums [ i ] <SPC> and <SPC> ( up <SPC> is <SPC> None <SPC> or <SPC> up <SPC> is <SPC> True ) : <NL>              length <SPC> += <SPC> 1 <NL>              up <SPC> = <SPC> False <NL> <NL> <TAB> return <SPC> length <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> isMatch ( self , <SPC> s , <SPC> p ) : <NL> <NL> <TAB> count <SPC> = <SPC> 0 <NL> <TAB> p_ptr , <SPC> s_ptr , <SPC> last_s_ptr , <SPC> last_p_ptr <SPC> = <SPC> 0 , <SPC> 0 , <SPC> - 1 , <SPC> - 1 <NL> <TAB> while <SPC> s_ptr <SPC> < <SPC> len ( s ) : <NL>          if <SPC> p_ptr <SPC> < <SPC> len ( p ) <SPC> and <SPC> ( s [ s_ptr ] <SPC> == <SPC> p [ p_ptr ] <SPC> or <SPC> p [ p_ptr ] <SPC> == <SPC> "?" ) : <NL>              s_ptr <SPC> += <SPC> 1 <NL>              p_ptr <SPC> += <SPC> 1 <NL>          elif <SPC> p_ptr <SPC> < <SPC> len ( p ) <SPC> and <SPC> p [ p_ptr ] <SPC> == <SPC> "*" : <NL>              p_ptr <SPC> += <SPC> 1 <NL>              last_s_ptr <SPC> = <SPC> s_ptr <NL>              last_p_ptr <SPC> = <SPC> p_ptr <NL>          elif <SPC> last_p_ptr <SPC> != <SPC> - 1 : <NL>              last_s_ptr <SPC> += <SPC> 1 <NL>              s_ptr <SPC> = <SPC> last_s_ptr <NL>              p_ptr <SPC> = <SPC> last_p_ptr <NL>          else : <NL>              assert <SPC> count <SPC> <= <SPC> ( len ( p ) <SPC> + <SPC> 1 ) <SPC> * <SPC> ( len ( s ) <SPC> + <SPC> 1 ) <NL>              return <SPC> False <NL>          count <SPC> += <SPC> 1 <NL> <NL> <TAB> while <SPC> p_ptr <SPC> < <SPC> len ( p ) <SPC> and <SPC> p [ p_ptr ] <SPC> == <SPC> "*" : <NL>          p_ptr <SPC> += <SPC> 1 <NL>          count <SPC> += <SPC> 1 <NL> <NL> <TAB> assert <SPC> count <SPC> <= <SPC> ( len ( p ) <SPC> + <SPC> 1 ) <SPC> * <SPC> ( len ( s ) <SPC> + <SPC> 1 ) <NL> <TAB> return <SPC> p_ptr <SPC> == <SPC> len ( p ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <NL> <TAB> def <SPC> isMatch ( self , <SPC> s , <SPC> p ) : <NL> <TAB> k <SPC> = <SPC> 2 <NL> <TAB> result <SPC> = <SPC> [ [ False <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( p ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( k ) ] <NL> <NL> <TAB> result [ 0 ] [ 0 ] <SPC> = <SPC> True <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( p ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> p [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "*" : <NL>              result [ 0 ] [ i ] <SPC> = <SPC> result [ 0 ] [ i <SPC> - <SPC> 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> + <SPC> 1 ) : <NL>          result [ i <SPC> % <SPC> k ] [ 0 ] <SPC> = <SPC> False <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( p ) <SPC> + <SPC> 1 ) : <NL>              if <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> != <SPC> "*" : <NL>                  result [ i <SPC> % <SPC> k ] [ j ] <SPC> = <SPC> result [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> k ] [ j <SPC> - <SPC> 1 ] <SPC> and <SPC> ( <NL>                      s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> or <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> "?" <NL>                  ) <NL>              else : <NL>                  result [ i <SPC> % <SPC> k ] [ j ] <SPC> = <SPC> result [ i <SPC> % <NL>                                            k ] [ j <SPC> - <SPC> 1 ] <SPC> or <SPC> result [ ( i <SPC> - <SPC> 1 ) <SPC> % <SPC> k ] [ j ] <NL> <NL> <TAB> return <SPC> result [ len ( s ) <SPC> % <SPC> k ] [ len ( p ) ] <NL> <NL> <NL> class <SPC> Solution3 ( object ) : <NL> <NL> <TAB> def <SPC> isMatch ( self , <SPC> s , <SPC> p ) : <NL> <TAB> result <SPC> = <SPC> [ [ False <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( p ) <SPC> + <SPC> 1 ) ] <SPC> for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> + <SPC> 1 ) ] <NL> <NL> <TAB> result [ 0 ] [ 0 ] <SPC> = <SPC> True <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( p ) <SPC> + <SPC> 1 ) : <NL>          if <SPC> p [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> "*" : <NL>              result [ 0 ] [ i ] <SPC> = <SPC> result [ 0 ] [ i <SPC> - <SPC> 1 ] <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( s ) <SPC> + <SPC> 1 ) : <NL>          result [ i ] [ 0 ] <SPC> = <SPC> False <NL>          for <SPC> j <SPC> in <SPC> xrange ( 1 , <SPC> len ( p ) <SPC> + <SPC> 1 ) : <NL>              if <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> != <SPC> "*" : <NL>                  result [ i ] [ j ] <SPC> = <SPC> result [ i <SPC> - <SPC> 1 ] [ j <SPC> - <SPC> 1 ] <SPC> and <SPC> ( <NL>                      s [ i <SPC> - <SPC> 1 ] <SPC> == <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> or <SPC> p [ j <SPC> - <SPC> 1 ] <SPC> == <SPC> "?" <NL>                  ) <NL>              else : <NL>                  result [ i ] [ j ] <SPC> = <SPC> result [ i ] [ j <SPC> - <SPC> 1 ] <SPC> or <SPC> result [ i <SPC> - <SPC> 1 ] [ j ] <NL> <NL> <TAB> return <SPC> result [ len ( s ) ] [ len ( p ) ] <NL> <NL> <NL> class <SPC> Solution4 ( object ) : <NL> <NL> <TAB> def <SPC> isMatch ( self , <SPC> s , <SPC> p ) : <NL> <TAB> if <SPC> not <SPC> p <SPC> or <SPC> not <SPC> s : <NL>          return <SPC> not <SPC> s <SPC> and <SPC> not <SPC> p <NL> <NL> <TAB> if <SPC> p [ 0 ] <SPC> != <SPC> "*" : <NL>          if <SPC> p [ 0 ] <SPC> == <SPC> s [ 0 ] <SPC> or <SPC> p [ 0 ] <SPC> == <SPC> "?" : <NL>              return <SPC> self . isMatch ( s [ 1 : ] , <SPC> p [ 1 : ] ) <NL>          else : <NL>              return <SPC> False <NL> <TAB> else : <NL>          while <SPC> len ( s ) <SPC> > <SPC> 0 : <NL>              if <SPC> self . isMatch ( s , <SPC> p [ 1 : ] ) : <NL>                  return <SPC> True <NL>              s <SPC> = <SPC> s [ 1 : ] <NL>          return <SPC> self . isMatch ( s , <SPC> p [ 1 : ] ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wordsAbbreviation ( self , <SPC> dict ) : <NL> <NL> <TAB> def <SPC> isUnique ( prefix , <SPC> words ) : <NL>          return <SPC> sum ( word . startswith ( prefix ) <SPC> for <SPC> word <SPC> in <SPC> words ) <SPC> == <SPC> 1 <NL> <NL> <TAB> def <SPC> toAbbr ( prefix , <SPC> word ) : <NL>          abbr <SPC> = <SPC> prefix <SPC> + <SPC> str ( len ( word ) <SPC> - <SPC> 1 <SPC> - <SPC> len ( prefix ) ) <SPC> + <SPC> word [ - 1 ] <NL>          return <SPC> abbr <SPC> if <SPC> len ( abbr ) <SPC> < <SPC> len ( word ) <SPC> else <SPC> word <NL> <NL> <TAB> abbr_to_word <SPC> = <SPC> collections . defaultdict ( set ) <NL> <TAB> word_to_abbr <SPC> = <SPC> { } <NL> <NL> <TAB> for <SPC> word <SPC> in <SPC> dict : <NL>          prefix <SPC> = <SPC> word [ : 1 ] <NL>          abbr_to_word [ toAbbr ( prefix , <SPC> word ) ] . add ( word ) <NL> <NL> <TAB> for <SPC> abbr , <SPC> conflicts <SPC> in <SPC> abbr_to_word . iteritems ( ) : <NL>          if <SPC> len ( conflicts ) <SPC> > <SPC> 1 : <NL>              for <SPC> word <SPC> in <SPC> conflicts : <NL>                  for <SPC> i <SPC> in <SPC> xrange ( 2 , <SPC> len ( word ) ) : <NL>                      prefix <SPC> = <SPC> word [ : i ] <NL>                      if <SPC> isUnique ( prefix , <SPC> conflicts ) : <NL>                          word_to_abbr [ word ] <SPC> = <SPC> toAbbr ( prefix , <SPC> word ) <NL>                          break <NL>          else : <NL>              word_to_abbr [ conflicts . pop ( ) ] <SPC> = <SPC> abbr <NL> <NL> <TAB> return <SPC> [ word_to_abbr [ word ] <SPC> for <SPC> word <SPC> in <SPC> dict ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wordBreak ( self , <SPC> s , <SPC> wordDict ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( s ) <NL> <NL> <TAB> max_len <SPC> = <SPC> 0 <NL> <TAB> for <SPC> string <SPC> in <SPC> wordDict : <NL>          max_len <SPC> = <SPC> max ( max_len , <SPC> len ( string ) ) <NL> <NL> <TAB> can_break <SPC> = <SPC> [ False <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n <SPC> + <SPC> 1 ) ] <NL> <TAB> valid <SPC> = <SPC> [ [ False ] <SPC> * <SPC> n <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n ) ] <NL> <TAB> can_break [ 0 ] <SPC> = <SPC> True <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          for <SPC> l <SPC> in <SPC> xrange ( 1 , <SPC> min ( i , <SPC> max_len ) <SPC> + <SPC> 1 ) : <NL>              if <SPC> can_break [ i <SPC> - <SPC> l ] <SPC> and <SPC> s [ i <SPC> - <SPC> l : <SPC> i ] <SPC> in <SPC> wordDict : <NL>                  valid [ i <SPC> - <SPC> l ] [ i <SPC> - <SPC> 1 ] <SPC> = <SPC> True <NL>                  can_break [ i ] <SPC> = <SPC> True <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> if <SPC> can_break [ - 1 ] : <NL>          self . wordBreakHelper ( s , <SPC> valid , <SPC> 0 , <SPC> [ ] , <SPC> result ) <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> wordBreakHelper ( self , <SPC> s , <SPC> valid , <SPC> start , <SPC> path , <SPC> result ) : <NL> <TAB> if <SPC> start <SPC> == <SPC> len ( s ) : <NL>          result . append ( " " . join ( path ) ) <NL>          return <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> len ( s ) ) : <NL>          if <SPC> valid [ start ] [ i ] : <NL>              path <SPC> += <SPC> [ s [ start : <SPC> i <SPC> + <SPC> 1 ] ] <NL>              self . wordBreakHelper ( s , <SPC> valid , <SPC> i <SPC> + <SPC> 1 , <SPC> path , <SPC> result ) <NL>              path . pop ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wordBreak ( self , <SPC> s , <SPC> wordDict ) : <NL> <NL> <TAB> n <SPC> = <SPC> len ( s ) <NL> <NL> <TAB> max_len <SPC> = <SPC> 0 <NL> <TAB> for <SPC> string <SPC> in <SPC> wordDict : <NL>          max_len <SPC> = <SPC> max ( max_len , <SPC> len ( string ) ) <NL> <NL> <TAB> can_break <SPC> = <SPC> [ False <SPC> for <SPC> _ <SPC> in <SPC> xrange ( n <SPC> + <SPC> 1 ) ] <NL> <TAB> can_break [ 0 ] <SPC> = <SPC> True <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> n <SPC> + <SPC> 1 ) : <NL>          for <SPC> l <SPC> in <SPC> xrange ( 1 , <SPC> min ( i , <SPC> max_len ) <SPC> + <SPC> 1 ) : <NL>              if <SPC> can_break [ i <SPC> - <SPC> l ] <SPC> and <SPC> s [ i <SPC> - <SPC> l : <SPC> i ] <SPC> in <SPC> wordDict : <NL>                  can_break [ i ] <SPC> = <SPC> True <NL>                  break <NL> <NL> <TAB> return <SPC> can_break [ - 1 ] <NL> <NL> <NL> from <SPC> collections <SPC> import <SPC> defaultdict <NL> from <SPC> string <SPC> import <SPC> ascii_lowercase <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findLadders ( self , <SPC> beginWord , <SPC> endWord , <SPC> wordList ) : <NL> <NL> <TAB> def <SPC> backtracking ( tree , <SPC> beginWord , <SPC> word ) : <NL>          return <SPC> ( <NL>              [ [ beginWord ] ] <NL>              if <SPC> word <SPC> == <SPC> beginWord <NL>              else <SPC> [ <NL>                  path <SPC> + <SPC> [ word ] <NL>                  for <SPC> new_word <SPC> in <SPC> tree [ word ] <NL>                  for <SPC> path <SPC> in <SPC> backtracking ( tree , <SPC> beginWord , <SPC> new_word ) <NL>              ] <NL>          ) <NL> <NL> <TAB> words <SPC> = <SPC> set ( wordList ) <NL> <TAB> if <SPC> endWord <SPC> not <SPC> in <SPC> words : <NL>          return <SPC> [ ] <NL> <TAB> tree <SPC> = <SPC> defaultdict ( set ) <NL> <TAB> is_found , <SPC> left , <SPC> right , <SPC> is_reversed <SPC> = <SPC> False , <SPC> { beginWord } , <SPC> { endWord } , <SPC> False <NL> <TAB> while <SPC> left : <NL>          words <SPC> -= <SPC> left <NL>          new_left <SPC> = <SPC> set ( ) <NL>          for <SPC> word <SPC> in <SPC> left : <NL>              for <SPC> new_word <SPC> in <SPC> ( <NL>                  word [ : i ] <SPC> + <SPC> c <SPC> + <SPC> word [ i <SPC> + <SPC> 1 : ] <NL>                  for <SPC> i <SPC> in <SPC> xrange ( len ( beginWord ) ) <NL>                  for <SPC> c <SPC> in <SPC> ascii_lowercase <NL>              ) : <NL>                  if <SPC> new_word <SPC> not <SPC> in <SPC> words : <NL>                      continue <NL>                  if <SPC> new_word <SPC> in <SPC> right : <NL>                      is_found <SPC> = <SPC> True <NL>                  else : <NL>                      new_left . add ( new_word ) <NL>                  tree [ new_word ] . add ( word ) <SPC> if <SPC> not <SPC> is_reversed <SPC> else <SPC> tree [ word ] . add ( <NL>                      new_word <NL>                  ) <NL>          if <SPC> is_found : <NL>              break <NL>          left <SPC> = <SPC> new_left <NL>          if <SPC> len ( left ) <SPC> > <SPC> len ( right ) : <NL>              left , <SPC> right , <SPC> is_reversed <SPC> = <SPC> right , <SPC> left , <SPC> not <SPC> is_reversed <NL> <TAB> return <SPC> backtracking ( tree , <SPC> beginWord , <SPC> endWord ) <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> findLadders ( self , <SPC> beginWord , <SPC> endWord , <SPC> wordList ) : <NL> <NL> <TAB> dictionary <SPC> = <SPC> set ( wordList ) <NL> <TAB> result , <SPC> cur , <SPC> visited , <SPC> found , <SPC> trace <SPC> = <SPC> ( <NL>          [ ] , <NL>          [ beginWord ] , <NL>          set ( [ beginWord ] ) , <NL>          False , <NL>          defaultdict ( list ) , <NL> <TAB> ) <NL> <NL> <TAB> while <SPC> cur <SPC> and <SPC> not <SPC> found : <NL>          for <SPC> word <SPC> in <SPC> cur : <NL>              visited . add ( word ) <NL> <NL>          next <SPC> = <SPC> set ( ) <NL>          for <SPC> word <SPC> in <SPC> cur : <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( word ) ) : <NL>                  for <SPC> c <SPC> in <SPC> ascii_lowercase : <NL>                      candidate <SPC> = <SPC> word [ : i ] <SPC> + <SPC> c <SPC> + <SPC> word [ i <SPC> + <SPC> 1 : ] <NL>                      if <SPC> candidate <SPC> not <SPC> in <SPC> visited <SPC> and <SPC> candidate <SPC> in <SPC> dictionary : <NL>                          if <SPC> candidate <SPC> == <SPC> endWord : <NL>                              found <SPC> = <SPC> True <NL>                          next . add ( candidate ) <NL>                          trace [ candidate ] . append ( word ) <NL>          cur <SPC> = <SPC> next <NL> <NL> <TAB> if <SPC> found : <NL>          self . backtrack ( result , <SPC> trace , <SPC> [ ] , <SPC> endWord ) <NL> <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> backtrack ( self , <SPC> result , <SPC> trace , <SPC> path , <SPC> word ) : <NL> <TAB> if <SPC> not <SPC> trace [ word ] : <NL>          path . append ( word ) <NL>          result . append ( path [ : : - 1 ] ) <NL>          path . pop ( ) <NL> <TAB> else : <NL>          for <SPC> prev <SPC> in <SPC> trace [ word ] : <NL>              path . append ( word ) <NL>              self . backtrack ( result , <SPC> trace , <SPC> path , <SPC> prev ) <NL>              path . pop ( ) <NL> <NL> <NL> from <SPC> string <SPC> import <SPC> ascii_lowercase <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> ladderLength ( self , <SPC> beginWord , <SPC> endWord , <SPC> wordList ) : <NL> <NL> <TAB> words <SPC> = <SPC> set ( wordList ) <NL> <TAB> if <SPC> endWord <SPC> not <SPC> in <SPC> words : <NL>          return <SPC> 0 <NL> <TAB> left , <SPC> right <SPC> = <SPC> { beginWord } , <SPC> { endWord } <NL> <TAB> ladder <SPC> = <SPC> 2 <NL> <TAB> while <SPC> left : <NL>          words <SPC> -= <SPC> left <NL>          new_left <SPC> = <SPC> set ( ) <NL>          for <SPC> word <SPC> in <SPC> left : <NL>              for <SPC> new_word <SPC> in <SPC> ( <NL>                  word [ : i ] <SPC> + <SPC> c <SPC> + <SPC> word [ i <SPC> + <SPC> 1 : ] <NL>                  for <SPC> i <SPC> in <SPC> xrange ( len ( beginWord ) ) <NL>                  for <SPC> c <SPC> in <SPC> ascii_lowercase <NL>              ) : <NL>                  if <SPC> new_word <SPC> not <SPC> in <SPC> words : <NL>                      continue <NL>                  if <SPC> new_word <SPC> in <SPC> right : <NL>                      return <SPC> ladder <NL>                  new_left . add ( new_word ) <NL>          left <SPC> = <SPC> new_left <NL>          ladder <SPC> += <SPC> 1 <NL>          if <SPC> len ( left ) <SPC> > <SPC> len ( right ) : <NL>              left , <SPC> right <SPC> = <SPC> right , <SPC> left <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> ladderLength ( self , <SPC> beginWord , <SPC> endWord , <SPC> wordList ) : <NL> <NL> <TAB> lookup <SPC> = <SPC> set ( wordList ) <NL> <TAB> if <SPC> endWord <SPC> not <SPC> in <SPC> lookup : <NL>          return <SPC> 0 <NL> <TAB> ladder <SPC> = <SPC> 2 <NL> <TAB> q <SPC> = <SPC> [ beginWord ] <NL> <TAB> while <SPC> q : <NL>          new_q <SPC> = <SPC> [ ] <NL>          for <SPC> word <SPC> in <SPC> q : <NL>              for <SPC> i <SPC> in <SPC> xrange ( len ( word ) ) : <NL>                  for <SPC> j <SPC> in <SPC> ascii_lowercase : <NL>                      new_word <SPC> = <SPC> word [ : i ] <SPC> + <SPC> j <SPC> + <SPC> word [ i <SPC> + <SPC> 1 : ] <NL>                      if <SPC> new_word <SPC> == <SPC> endWord : <NL>                          return <SPC> ladder <NL>                      if <SPC> new_word <SPC> in <SPC> lookup : <NL>                          lookup . remove ( new_word ) <NL>                          new_q . append ( new_word ) <NL>          q <SPC> = <SPC> new_q <NL>          ladder <SPC> += <SPC> 1 <NL> <TAB> return <SPC> 0 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wordPatternMatch ( self , <SPC> pattern , <SPC> str ) : <NL> <NL> <TAB> w2p , <SPC> p2w <SPC> = <SPC> { } , <SPC> { } <NL> <TAB> return <SPC> self . match ( pattern , <SPC> str , <SPC> 0 , <SPC> 0 , <SPC> w2p , <SPC> p2w ) <NL> <NL> <TAB> def <SPC> match ( self , <SPC> pattern , <SPC> str , <SPC> i , <SPC> j , <SPC> w2p , <SPC> p2w ) : <NL> <TAB> is_match <SPC> = <SPC> False <NL> <TAB> if <SPC> i <SPC> == <SPC> len ( pattern ) <SPC> and <SPC> j <SPC> == <SPC> len ( str ) : <NL>          is_match <SPC> = <SPC> True <NL> <TAB> elif <SPC> i <SPC> < <SPC> len ( pattern ) <SPC> and <SPC> j <SPC> < <SPC> len ( str ) : <NL>          p <SPC> = <SPC> pattern [ i ] <NL>          if <SPC> p <SPC> in <SPC> p2w : <NL>              w <SPC> = <SPC> p2w [ p ] <NL>              if <SPC> w <SPC> == <SPC> str [ j : <SPC> j <SPC> + <SPC> len ( w ) ] : <NL>                  is_match <SPC> = <SPC> self . match ( <NL>                      pattern , <SPC> str , <SPC> i <SPC> + <SPC> 1 , <SPC> j <SPC> + <SPC> len ( w ) , <SPC> w2p , <SPC> p2w ) <NL> <NL>          else : <NL>              for <SPC> k <SPC> in <SPC> xrange ( j , <SPC> len ( str ) ) : <NL>                  w <SPC> = <SPC> str [ j : <SPC> k <SPC> + <SPC> 1 ] <NL>                  if <SPC> w <SPC> not <SPC> in <SPC> w2p : <NL> <NL>                      w2p [ w ] , <SPC> p2w [ p ] <SPC> = <SPC> p , <SPC> w <NL>                      is_match <SPC> = <SPC> self . match ( pattern , <SPC> str , <SPC> i <SPC> + <SPC> 1 , <SPC> k <SPC> + <SPC> 1 , <SPC> w2p , <SPC> p2w ) <NL>                      w2p . pop ( w ) , <SPC> p2w . pop ( p ) <NL>                  if <SPC> is_match : <NL>                      break <NL> <TAB> return <SPC> is_match <NL> <NL> <NL> from <SPC> itertools <SPC> import <SPC> izip <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wordPattern ( self , <SPC> pattern , <SPC> str ) : <NL> <NL> <TAB> if <SPC> len ( pattern ) <SPC> != <SPC> self . wordCount ( str ) : <NL>          return <SPC> False <NL> <NL> <TAB> w2p , <SPC> p2w <SPC> = <SPC> { } , <SPC> { } <NL> <TAB> for <SPC> p , <SPC> w <SPC> in <SPC> izip ( pattern , <SPC> self . wordGenerator ( str ) ) : <NL>          if <SPC> w <SPC> not <SPC> in <SPC> w2p <SPC> and <SPC> p <SPC> not <SPC> in <SPC> p2w : <NL> <NL>              w2p [ w ] <SPC> = <SPC> p <NL>              p2w [ p ] <SPC> = <SPC> w <NL>          elif <SPC> w <SPC> not <SPC> in <SPC> w2p <SPC> or <SPC> w2p [ w ] <SPC> != <SPC> p : <NL> <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <TAB> def <SPC> wordCount ( self , <SPC> str ) : <NL> <TAB> cnt <SPC> = <SPC> 1 <SPC> if <SPC> str <SPC> else <SPC> 0 <NL> <TAB> for <SPC> c <SPC> in <SPC> str : <NL>          if <SPC> c <SPC> == <SPC> " " : <NL>              cnt <SPC> += <SPC> 1 <NL> <TAB> return <SPC> cnt <NL> <NL> <TAB> def <SPC> wordGenerator ( self , <SPC> str ) : <NL> <TAB> w <SPC> = <SPC> "" <NL> <TAB> for <SPC> c <SPC> in <SPC> str : <NL>          if <SPC> c <SPC> == <SPC> " " : <NL>              yield <SPC> w <NL>              w <SPC> = <SPC> "" <NL>          else : <NL>              w <SPC> += <SPC> c <NL> <TAB> yield <SPC> w <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> wordPattern ( self , <SPC> pattern , <SPC> str ) : <NL> <NL> <TAB> words <SPC> = <SPC> str . split ( ) <NL> <TAB> if <SPC> len ( pattern ) <SPC> != <SPC> len ( words ) : <NL>          return <SPC> False <NL> <NL> <TAB> w2p , <SPC> p2w <SPC> = <SPC> { } , <SPC> { } <NL> <TAB> for <SPC> p , <SPC> w <SPC> in <SPC> izip ( pattern , <SPC> words ) : <NL>          if <SPC> w <SPC> not <SPC> in <SPC> w2p <SPC> and <SPC> p <SPC> not <SPC> in <SPC> p2w : <NL> <NL>              w2p [ w ] <SPC> = <SPC> p <NL>              p2w [ p ] <SPC> = <SPC> w <NL>          elif <SPC> w <SPC> not <SPC> in <SPC> w2p <SPC> or <SPC> w2p [ w ] <SPC> != <SPC> p : <NL> <NL>              return <SPC> False <NL> <TAB> return <SPC> True <NL> <NL> <NL> class <SPC> TrieNode ( object ) : <NL> <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . is_string <SPC> = <SPC> False <NL> <TAB> self . leaves <SPC> = <SPC> { } <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> word ) : <NL> <TAB> cur <SPC> = <SPC> self <NL> <TAB> for <SPC> c <SPC> in <SPC> word : <NL>          if <SPC> not <SPC> c <SPC> in <SPC> cur . leaves : <NL>              cur . leaves [ c ] <SPC> = <SPC> TrieNode ( ) <NL>          cur <SPC> = <SPC> cur . leaves [ c ] <NL> <TAB> cur . is_string <SPC> = <SPC> True <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> findWords ( self , <SPC> board , <SPC> words ) : <NL> <NL> <TAB> visited <SPC> = <SPC> [ [ False <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( board [ 0 ] ) ) ] <NL>                 for <SPC> i <SPC> in <SPC> xrange ( len ( board ) ) ] <NL> <TAB> result <SPC> = <SPC> { } <NL> <TAB> trie <SPC> = <SPC> TrieNode ( ) <NL> <TAB> for <SPC> word <SPC> in <SPC> words : <NL>          trie . insert ( word ) <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( board ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( board [ 0 ] ) ) : <NL>              self . findWordsRecu ( board , <SPC> trie , <SPC> 0 , <SPC> i , <SPC> j , <SPC> visited , <SPC> [ ] , <SPC> result ) <NL> <NL> <TAB> return <SPC> result . keys ( ) <NL> <NL> <TAB> def <SPC> findWordsRecu ( self , <SPC> board , <SPC> trie , <SPC> cur , <SPC> i , <SPC> j , <SPC> visited , <SPC> cur_word , <SPC> result ) : <NL> <TAB> if <SPC> ( <NL>          not <SPC> trie <NL>          or <SPC> i <SPC> < <SPC> 0 <NL>          or <SPC> i <SPC> >= <SPC> len ( board ) <NL>          or <SPC> j <SPC> < <SPC> 0 <NL>          or <SPC> j <SPC> >= <SPC> len ( board [ 0 ] ) <NL>          or <SPC> visited [ i ] [ j ] <NL> <TAB> ) : <NL>          return <NL> <NL> <TAB> if <SPC> board [ i ] [ j ] <SPC> not <SPC> in <SPC> trie . leaves : <NL>          return <NL> <NL> <TAB> cur_word . append ( board [ i ] [ j ] ) <NL> <TAB> next_node <SPC> = <SPC> trie . leaves [ board [ i ] [ j ] ] <NL> <TAB> if <SPC> next_node . is_string : <NL>          result [ "" . join ( cur_word ) ] <SPC> = <SPC> True <NL> <NL> <TAB> visited [ i ] [ j ] <SPC> = <SPC> True <NL> <TAB> self . findWordsRecu ( <NL>          board , <SPC> next_node , <SPC> cur <SPC> + <SPC> 1 , <SPC> i <SPC> + <SPC> 1 , <SPC> j , <SPC> visited , <SPC> cur_word , <SPC> result <NL> <TAB> ) <NL> <TAB> self . findWordsRecu ( <NL>          board , <SPC> next_node , <SPC> cur <SPC> + <SPC> 1 , <SPC> i <SPC> - <SPC> 1 , <SPC> j , <SPC> visited , <SPC> cur_word , <SPC> result <NL> <TAB> ) <NL> <TAB> self . findWordsRecu ( <NL>          board , <SPC> next_node , <SPC> cur <SPC> + <SPC> 1 , <SPC> i , <SPC> j <SPC> + <SPC> 1 , <SPC> visited , <SPC> cur_word , <SPC> result <NL> <TAB> ) <NL> <TAB> self . findWordsRecu ( <NL>          board , <SPC> next_node , <SPC> cur <SPC> + <SPC> 1 , <SPC> i , <SPC> j <SPC> - <SPC> 1 , <SPC> visited , <SPC> cur_word , <SPC> result <NL> <TAB> ) <NL> <TAB> visited [ i ] [ j ] <SPC> = <SPC> False <NL> <TAB> cur_word . pop ( ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <NL> <TAB> def <SPC> exist ( self , <SPC> board , <SPC> word ) : <NL> <TAB> visited <SPC> = <SPC> [ [ False <SPC> for <SPC> j <SPC> in <SPC> xrange ( len ( board [ 0 ] ) ) ] <NL>                 for <SPC> i <SPC> in <SPC> xrange ( len ( board ) ) ] <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( board ) ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( len ( board [ 0 ] ) ) : <NL>              if <SPC> self . existRecu ( board , <SPC> word , <SPC> 0 , <SPC> i , <SPC> j , <SPC> visited ) : <NL>                  return <SPC> True <NL> <NL> <TAB> return <SPC> False <NL> <NL> <TAB> def <SPC> existRecu ( self , <SPC> board , <SPC> word , <SPC> cur , <SPC> i , <SPC> j , <SPC> visited ) : <NL> <TAB> if <SPC> cur <SPC> == <SPC> len ( word ) : <NL>          return <SPC> True <NL> <NL> <TAB> if <SPC> ( <NL>          i <SPC> < <SPC> 0 <NL>          or <SPC> i <SPC> >= <SPC> len ( board ) <NL>          or <SPC> j <SPC> < <SPC> 0 <NL>          or <SPC> j <SPC> >= <SPC> len ( board [ 0 ] ) <NL>          or <SPC> visited [ i ] [ j ] <NL>          or <SPC> board [ i ] [ j ] <SPC> != <SPC> word [ cur ] <NL> <TAB> ) : <NL>          return <SPC> False <NL> <NL> <TAB> visited [ i ] [ j ] <SPC> = <SPC> True <NL> <TAB> result <SPC> = <SPC> ( <NL>          self . existRecu ( board , <SPC> word , <SPC> cur <SPC> + <SPC> 1 , <SPC> i <SPC> + <SPC> 1 , <SPC> j , <SPC> visited ) <NL>          or <SPC> self . existRecu ( board , <SPC> word , <SPC> cur <SPC> + <SPC> 1 , <SPC> i <SPC> - <SPC> 1 , <SPC> j , <SPC> visited ) <NL>          or <SPC> self . existRecu ( board , <SPC> word , <SPC> cur <SPC> + <SPC> 1 , <SPC> i , <SPC> j <SPC> + <SPC> 1 , <SPC> visited ) <NL>          or <SPC> self . existRecu ( board , <SPC> word , <SPC> cur <SPC> + <SPC> 1 , <SPC> i , <SPC> j <SPC> - <SPC> 1 , <SPC> visited ) <NL> <TAB> ) <NL> <TAB> visited [ i ] [ j ] <SPC> = <SPC> False <NL> <NL> <TAB> return <SPC> result <NL> <NL> <NL> class <SPC> TrieNode ( object ) : <NL> <TAB> def <SPC> __init__ ( self ) : <NL> <TAB> self . indices <SPC> = <SPC> [ ] <NL> <TAB> self . children <SPC> = <SPC> [ None ] <SPC> * <SPC> 26 <NL> <NL> <TAB> def <SPC> insert ( self , <SPC> words , <SPC> i ) : <NL> <TAB> cur <SPC> = <SPC> self <NL> <TAB> for <SPC> c <SPC> in <SPC> words [ i ] : <NL>          if <SPC> not <SPC> cur . children [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] : <NL>              cur . children [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <SPC> = <SPC> TrieNode ( ) <NL>          cur <SPC> = <SPC> cur . children [ ord ( c ) <SPC> - <SPC> ord ( "a" ) ] <NL>          cur . indices . append ( i ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wordSquares ( self , <SPC> words ) : <NL> <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <NL> <TAB> trie <SPC> = <SPC> TrieNode ( ) <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( len ( words ) ) : <NL>          trie . insert ( words , <SPC> i ) <NL> <NL> <TAB> curr <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> s <SPC> in <SPC> words : <NL>          curr . append ( s ) <NL>          self . wordSquaresHelper ( words , <SPC> trie , <SPC> curr , <SPC> result ) <NL>          curr . pop ( ) <NL> <NL> <TAB> return <SPC> result <NL> <NL> <TAB> def <SPC> wordSquaresHelper ( self , <SPC> words , <SPC> trie , <SPC> curr , <SPC> result ) : <NL> <TAB> if <SPC> len ( curr ) <SPC> >= <SPC> len ( words [ 0 ] ) : <NL>          return <SPC> result . append ( list ( curr ) ) <NL> <NL> <TAB> node <SPC> = <SPC> trie <NL> <TAB> for <SPC> s <SPC> in <SPC> curr : <NL>          node <SPC> = <SPC> node . children [ ord ( s [ len ( curr ) ] ) <SPC> - <SPC> ord ( "a" ) ] <NL>          if <SPC> not <SPC> node : <NL>              return <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> node . indices : <NL>          curr . append ( words [ i ] ) <NL>          self . wordSquaresHelper ( words , <SPC> trie , <SPC> curr , <SPC> result ) <NL>          curr . pop ( ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> wordSubsets ( self , <SPC> A , <SPC> B ) : <NL> <NL> <TAB> count <SPC> = <SPC> collections . Counter ( ) <NL> <TAB> for <SPC> b <SPC> in <SPC> B : <NL>          for <SPC> c , <SPC> n <SPC> in <SPC> collections . Counter ( b ) . items ( ) : <NL>              count [ c ] <SPC> = <SPC> max ( count [ c ] , <SPC> n ) <NL> <TAB> result <SPC> = <SPC> [ ] <NL> <TAB> for <SPC> a <SPC> in <SPC> A : <NL>          count <SPC> = <SPC> collections . Counter ( a ) <NL>          if <SPC> all ( count [ c ] <SPC> >= <SPC> count [ c ] <SPC> for <SPC> c <SPC> in <SPC> count ) : <NL>              result . append ( a ) <NL> <TAB> return <SPC> result <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> hasGroupsSizeX ( self , <SPC> deck ) : <NL> <NL> <TAB> def <SPC> gcd ( a , <SPC> b ) : <NL>          while <SPC> b : <NL>              a , <SPC> b <SPC> = <SPC> b , <SPC> a <SPC> % <SPC> b <NL>          return <SPC> a <NL> <NL> <TAB> vals <SPC> = <SPC> collections . Counter ( deck ) . values ( ) <NL> <TAB> return <SPC> reduce ( gcd , <SPC> vals ) <SPC> >= <SPC> 2 <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> xorOperation ( self , <SPC> n , <SPC> start ) : <NL> <NL> <TAB> def <SPC> xorNums ( n , <SPC> start ) : <NL>          def <SPC> xorNumsBeginEven ( n , <SPC> start ) : <NL>              assert <SPC> start <SPC> % <SPC> 2 <SPC> == <SPC> 0 <NL> <NL>              return <SPC> ( ( n <SPC> // <SPC> 2 ) <SPC> % <SPC> 2 ) <SPC> ^ <SPC> ( ( start <SPC> + <SPC> n <SPC> - <SPC> 1 ) <SPC> if <SPC> n <SPC> % <SPC> 2 <SPC> else <SPC> 0 ) <NL> <NL>          return <SPC> ( <NL>              start <SPC> ^ <SPC> xorNumsBeginEven ( n <SPC> - <SPC> 1 , <SPC> start <SPC> + <SPC> 1 ) <NL>              if <SPC> start <SPC> % <SPC> 2 <NL>              else <SPC> xorNumsBeginEven ( n , <SPC> start ) <NL>          ) <NL> <NL> <TAB> return <SPC> int ( n <SPC> % <SPC> 2 <SPC> and <SPC> start <SPC> % <SPC> 2 ) <SPC> + <SPC> 2 <SPC> * <SPC> xorNums ( n , <SPC> start <SPC> // <SPC> 2 ) <NL> <NL> <NL> import <SPC> operator <NL> <NL> <NL> class <SPC> Solution2 ( object ) : <NL> <TAB> def <SPC> xorOperation ( self , <SPC> n , <SPC> start ) : <NL> <NL> <TAB> return <SPC> reduce ( operator . xor , <SPC> ( i <SPC> for <SPC> i <SPC> in <SPC> xrange ( start , <SPC> start <SPC> + <SPC> 2 <SPC> * <SPC> n , <SPC> 2 ) ) ) <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> xorQueries ( self , <SPC> arr , <SPC> queries ) : <NL> <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( 1 , <SPC> len ( arr ) ) : <NL>          arr [ i ] <SPC> ^= <SPC> arr [ i <SPC> - <SPC> 1 ] <NL> <TAB> return <SPC> [ <NL>          arr [ right ] <SPC> ^ <SPC> arr [ left <SPC> - <SPC> 1 ] <SPC> if <SPC> left <SPC> else <SPC> arr [ right ] <NL>          for <SPC> left , <SPC> right <SPC> in <SPC> queries <NL> <TAB> ] <NL> <NL> <NL> class <SPC> Solution ( object ) : <NL> <TAB> def <SPC> convert ( self , <SPC> s , <SPC> numRows ) : <NL> <NL> <TAB> if <SPC> numRows <SPC> == <SPC> 1 : <NL>          return <SPC> s <NL> <TAB> step , <SPC> zigzag <SPC> = <SPC> 2 <SPC> * <SPC> numRows <SPC> - <SPC> 2 , <SPC> "" <NL> <TAB> for <SPC> i <SPC> in <SPC> xrange ( numRows ) : <NL>          for <SPC> j <SPC> in <SPC> xrange ( i , <SPC> len ( s ) , <SPC> step ) : <NL>              zigzag <SPC> += <SPC> s [ j ] <NL>              if <SPC> 0 <SPC> < <SPC> i <SPC> < <SPC> numRows <SPC> - <SPC> 1 <SPC> and <SPC> j <SPC> + <SPC> step <SPC> - <SPC> 2 <SPC> * <SPC> i <SPC> < <SPC> len ( s ) : <NL>                  zigzag <SPC> += <SPC> s [ j <SPC> + <SPC> step <SPC> - <SPC> 2 <SPC> * <SPC> i ] <NL> <TAB> return <SPC> zigzag <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> ZigzagIterator ( object ) : <NL> <TAB> def <SPC> __init__ ( self , <SPC> v1 , <SPC> v2 ) : <NL> <NL> <TAB> self . q <SPC> = <SPC> collections . deque ( [ ( len ( v ) , <SPC> iter ( v ) ) <SPC> for <SPC> v <SPC> in <SPC> ( v1 , <SPC> v2 ) <SPC> if <SPC> v ] ) <NL> <NL> <TAB> def <SPC> next ( self ) : <NL> <NL> <TAB> len , <SPC> iter <SPC> = <SPC> self . q . popleft ( ) <NL> <TAB> if <SPC> len <SPC> > <SPC> 1 : <NL>          self . q . append ( ( len <SPC> - <SPC> 1 , <SPC> iter ) ) <NL> <TAB> return <SPC> next ( iter ) <NL> <NL> <TAB> def <SPC> hasNext ( self ) : <NL> <NL> <TAB> return <SPC> bool ( self . q ) <NL> <NL> <NL> import <SPC> collections <NL> <NL> <NL> class <SPC> Solution_TLE_BUT_CORRECT ( object ) : <NL> <TAB> def <SPC> findMinStep ( self , <SPC> board , <SPC> hand ) : <NL> <NL> <TAB> def <SPC> shrink ( s ) : <NL>          stack <SPC> = <SPC> [ ] <NL>          start <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> + <SPC> 1 ) : <NL>              if <SPC> i <SPC> == <SPC> len ( s ) <SPC> or <SPC> s [ i ] <SPC> != <SPC> s [ start ] : <NL>                  if <SPC> stack <SPC> and <SPC> stack [ - 1 ] [ 0 ] <SPC> == <SPC> s [ start ] : <NL>                      stack [ - 1 ] [ 1 ] <SPC> += <SPC> i <SPC> - <SPC> start <NL>                      if <SPC> stack [ - 1 ] [ 1 ] <SPC> >= <SPC> 3 : <NL>                          stack . pop ( ) <NL>                  elif <SPC> s <SPC> and <SPC> i <SPC> - <SPC> start <SPC> < <SPC> 3 : <NL>                      stack <SPC> += <SPC> ( [ s [ start ] , <SPC> i <SPC> - <SPC> start ] , ) <NL>                  start <SPC> = <SPC> i <NL>          result <SPC> = <SPC> [ ] <NL>          for <SPC> p <SPC> in <SPC> stack : <NL>              result <SPC> += <SPC> [ p [ 0 ] ] <SPC> * <SPC> p [ 1 ] <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> findMinStepHelper ( board , <SPC> hand , <SPC> lookup ) : <NL>          if <SPC> not <SPC> board : <NL>              return <SPC> 0 <NL>          if <SPC> not <SPC> hand : <NL>              return <SPC> float ( "inf" ) <NL>          if <SPC> tuple ( hand ) <SPC> in <SPC> lookup [ tuple ( board ) ] : <NL>              return <SPC> lookup [ tuple ( board ) ] [ tuple ( hand ) ] <NL> <NL>          result <SPC> = <SPC> float ( "inf" ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( hand ) ) : <NL>              for <SPC> j <SPC> in <SPC> xrange ( len ( board ) <SPC> + <SPC> 1 ) : <NL>                  next_board <SPC> = <SPC> shrink ( board [ 0 : j ] <SPC> + <SPC> hand [ i : <SPC> i <SPC> + <SPC> 1 ] <SPC> + <SPC> board [ j : ] ) <NL>                  next_hand <SPC> = <SPC> hand [ 0 : i ] <SPC> + <SPC> hand [ i <SPC> + <SPC> 1 : ] <NL>                  result <SPC> = <SPC> min ( <NL>                      result , <SPC> findMinStepHelper ( <NL>                          next_board , <SPC> next_hand , <SPC> lookup ) <SPC> + <SPC> 1 <NL>                  ) <NL>          lookup [ tuple ( board ) ] [ tuple ( hand ) ] <SPC> = <SPC> result <NL>          return <SPC> result <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( dict ) <NL> <TAB> board , <SPC> hand <SPC> = <SPC> list ( board ) , <SPC> list ( hand ) <NL> <TAB> result <SPC> = <SPC> findMinStepHelper ( board , <SPC> hand , <SPC> lookup ) <NL> <TAB> return <SPC> - 1 <SPC> if <SPC> result <SPC> == <SPC> float ( "inf" ) <SPC> else <SPC> result <NL> <NL> <NL> class <SPC> Solution_WRONG_GREEDY_BUT_ACCEPT ( object ) : <NL> <TAB> def <SPC> findMinStep ( self , <SPC> board , <SPC> hand ) : <NL> <NL> <TAB> def <SPC> shrink ( s ) : <NL>          stack <SPC> = <SPC> [ ] <NL>          start <SPC> = <SPC> 0 <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( s ) <SPC> + <SPC> 1 ) : <NL>              if <SPC> i <SPC> == <SPC> len ( s ) <SPC> or <SPC> s [ i ] <SPC> != <SPC> s [ start ] : <NL>                  if <SPC> stack <SPC> and <SPC> stack [ - 1 ] [ 0 ] <SPC> == <SPC> s [ start ] : <NL>                      stack [ - 1 ] [ 1 ] <SPC> += <SPC> i <SPC> - <SPC> start <NL>                      if <SPC> stack [ - 1 ] [ 1 ] <SPC> >= <SPC> 3 : <NL>                          stack . pop ( ) <NL>                  elif <SPC> s <SPC> and <SPC> i <SPC> - <SPC> start <SPC> < <SPC> 3 : <NL>                      stack <SPC> += <SPC> ( [ s [ start ] , <SPC> i <SPC> - <SPC> start ] , ) <NL>                  start <SPC> = <SPC> i <NL>          result <SPC> = <SPC> [ ] <NL>          for <SPC> p <SPC> in <SPC> stack : <NL>              result <SPC> += <SPC> [ p [ 0 ] ] <SPC> * <SPC> p [ 1 ] <NL>          return <SPC> result <NL> <NL> <TAB> def <SPC> find ( board , <SPC> c , <SPC> j ) : <NL>          for <SPC> i <SPC> in <SPC> xrange ( j , <SPC> len ( board ) ) : <NL>              if <SPC> board [ i ] <SPC> == <SPC> c : <NL>                  return <SPC> i <NL>          return <SPC> - 1 <NL> <NL> <TAB> def <SPC> findMinStepHelper ( board , <SPC> hand , <SPC> lookup ) : <NL>          if <SPC> not <SPC> board : <NL>              return <SPC> 0 <NL>          if <SPC> not <SPC> hand : <NL>              return <SPC> float ( "inf" ) <NL>          if <SPC> tuple ( hand ) <SPC> in <SPC> lookup [ tuple ( board ) ] : <NL>              return <SPC> lookup [ tuple ( board ) ] [ tuple ( hand ) ] <NL> <NL>          result <SPC> = <SPC> float ( "inf" ) <NL>          for <SPC> i <SPC> in <SPC> xrange ( len ( hand ) ) : <NL>              j <SPC> = <SPC> 0 <NL>              while <SPC> j <SPC> < <SPC> len ( board ) : <NL>                  k <SPC> = <SPC> find ( board , <SPC> hand [ i ] , <SPC> j ) <NL>                  if <SPC> k <SPC> == <SPC> - 1 : <NL>                      break <NL> <NL>                  if <SPC> k <SPC> < <SPC> len ( board ) <SPC> - <SPC> 1 <SPC> and <SPC> board [ k ] <SPC> == <SPC> board [ k <SPC> + <SPC> 1 ] : <NL>                      next_board <SPC> = <SPC> shrink ( board [ 0 : k ] <SPC> + <SPC> board [ k <SPC> + <SPC> 2 : ] ) <NL>                      next_hand <SPC> = <SPC> hand [ 0 : i ] <SPC> + <SPC> hand [ i <SPC> + <SPC> 1 : ] <NL>                      result <SPC> = <SPC> min ( <NL>                          result , <SPC> findMinStepHelper ( <NL>                              next_board , <SPC> next_hand , <SPC> lookup ) <SPC> + <SPC> 1 <NL>                      ) <NL>                      k <SPC> += <SPC> 1 <NL>                  elif <SPC> i <SPC> > <SPC> 0 <SPC> and <SPC> hand [ i ] <SPC> == <SPC> hand [ i <SPC> - <SPC> 1 ] : <NL>                      next_board <SPC> = <SPC> shrink ( board [ 0 : k ] <SPC> + <SPC> board [ k <SPC> + <SPC> 1 : ] ) <NL>                      next_hand <SPC> = <SPC> hand [ 0 : <SPC> i <SPC> - <SPC> 1 ] <SPC> + <SPC> hand [ i <SPC> + <SPC> 1 : ] <NL>                      result <SPC> = <SPC> min ( <NL>                          result , <SPC> findMinStepHelper ( <NL>                              next_board , <SPC> next_hand , <SPC> lookup ) <SPC> + <SPC> 2 <NL>                      ) <NL>                  j <SPC> = <SPC> k <SPC> + <SPC> 1 <NL> <NL>          lookup [ tuple ( board ) ] [ tuple ( hand ) ] <SPC> = <SPC> result <NL>          return <SPC> result <NL> <NL> <TAB> lookup <SPC> = <SPC> collections . defaultdict ( dict ) <NL> <TAB> board , <SPC> hand <SPC> = <SPC> list ( board ) , <SPC> list ( hand ) <NL> <TAB> hand . sort ( ) <NL> <TAB> result <SPC> = <SPC> findMinStepHelper ( board , <SPC> hand , <SPC> lookup ) <NL> <TAB> return <SPC> - 1 <SPC> if <SPC> result <SPC> == <SPC> float ( "inf" ) <SPC> else <SPC> result <NL>