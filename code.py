class Solution(object):

    def twoSum(self, nums, target):

    nums_index = [(v, index) for index, v in enumerate(nums)]
    nums_index.sort()
    begin, end = 0, len(nums) - 1
    while begin < end:
        curr = nums_index[begin][0] + nums_index[end][0]
        if curr == target:
            return [nums_index[begin][1], nums_index[end][1]]
        elif curr < target:
            begin += 1
        else:
            end -= 1


if __name__ == "__main__":

    s = Solution()
    print s.twoSum([3, 2, 4], 6)


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):

    def addTwoNumbers(self, l1, l2):
    carry = 0

    head = curr = ListNode(0)
    while l1 or l2:
        val = carry
        if l1:
            val += l1.val
            l1 = l1.next
        if l2:
            val += l2.val
            l2 = l2.next
        curr.next = ListNode(val % 10)
        curr = curr.next
        carry = val / 10
    if carry > 0:
        curr.next = ListNode(carry)
    return head.next


class Solution(object):

    def lengthOfLongestSubstring(self, s):

    charMap = {}
    for i in range(256):
        charMap[i] = -1
    ls = len(s)
    i = max_len = 0
    for j in range(ls):

        if charMap[ord(s[j])] >= i:
            i = charMap[ord(s[j])] + 1
        charMap[ord(s[j])] = j
        max_len = max(max_len, j - i + 1)
    return max_len


class Solution(object):

    def findMedianSortedArrays(self, nums1, nums2):

    ls1, ls2 = len(nums1), len(nums2)
    if ls1 < ls2:
        return self.findMedianSortedArrays(nums2, nums1)
    l, r = 0, ls2 * 2
    while l <= r:
        mid2 = (l + r) >> 1
        mid1 = ls1 + ls2 - mid2
        L1 = -sys.maxint - 1 if mid1 == 0 else nums1[(mid1 - 1) >> 1]
        L2 = -sys.maxint - 1 if mid2 == 0 else nums2[(mid2 - 1) >> 1]
        R1 = sys.maxint if mid1 == 2 * ls1 else nums1[mid1 >> 1]
        R2 = sys.maxint if mid2 == 2 * ls2 else nums2[mid2 >> 1]
        if L1 > R2:
            l = mid2 + 1
        elif L2 > R1:
            r = mid2 - 1
        else:
            return (max(L1, L2) + min(R1, R2)) / 2.0


if __name__ == "__main__":

    s = Solution()
    print s.findMedianSortedArrays([1, 1], [1, 2])


class Solution(object):
    def longestPalindrome(self, s):

    ls = len(s)
    if ls <= 1 or len(set(s)) == 1:
        return s

    temp_s = "#".join("{}".format(s))

    tls = len(temp_s)
    seed = range(1, tls - 1)

    len_table = [0] * tls
    for step in range(1, tls / 2 + 1):
        final = []
        for pos in seed:
            if pos - step < 0 or pos + step >= tls:
                continue
            if temp_s[pos - step] != temp_s[pos + step]:
                continue
            final.append(pos)
            if temp_s[pos - step] == "#":
                continue
            len_table[pos] = step
        seed = final
    max_pos, max_step = 0, 0
    for i, s in enumerate(len_table):
        if s >= max_step:
            max_step = s
            max_pos = i
    return temp_s[max_pos - max_step: max_pos + max_step + 1].translate(None, "#")


if __name__ == "__main__":

    s = Solution()
    print s.longestPalindrome("abcbe")


class Solution(object):

    def convert(self, s, numRows):

    if numRows == 1:
        return s

    p = 2 * (numRows - 1)
    result = [""] * numRows
    for i in xrange(len(s)):
        floor = i % p
        if floor >= p // 2:
            floor = p - floor
        result[floor] += s[i]
    return "".join(result)


if __name__ == "__main__":

    s = Solution()
    print s.convert("PAYPALISHIRING", 3)


class Solution:

    def reverse(self, x):

    res, isPos = 0, 1
    if x < 0:
        isPos = -1
        x = -1 * x
    while x != 0:
        res = res * 10 + x % 10
        if res > 2147483647:
            return 0
        x /= 10
    return res * isPos


class Solution(object):
    def myAtoi(self, str):

    sign = 1
    max_int, min_int = 2147483647, -2147483648
    result, pos = 0, 0
    ls = len(str)
    while pos < ls and str[pos] == " ":
        pos += 1
    if pos < ls and str[pos] == "-":
        sign = -1
        pos += 1
    elif pos < ls and str[pos] == "+":
        pos += 1
    while pos < ls and ord(str[pos]) >= ord("0") and ord(str[pos]) <= ord("9"):
        num = ord(str[pos]) - ord("0")
        if result > max_int / 10 or (result == max_int / 10 and num >= 8):
            if sign == -1:
                return min_int
            return max_int
        result = result * 10 + num
        pos += 1
    return sign * result


if __name__ == "__main__":

    s = Solution()
    print s.myAtoi("+-2")


class Solution(object):
    def isPalindrome(self, x):
    if x < 0:
        return False
    ls = len(str(x))
    tmp = x
    for i in range(int(ls / 2)):
        right = int(tmp % 10)
        left = tmp / (10 ** (ls - 2 * i - 1))
        left = int(left % 10)
        if left != right:
            return False
        tmp = tmp // 10
    return True


if __name__ == "__main__":

    s = Solution()
    print s.isPalindrome(1001)


class Solution(object):
    def isMatch(self, s, p):

    if s == p:
        return True
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]
    dp[0][0] = True
    for j in range(1, n):
        if p[j] == "*" and dp[0][j - 1]:
            dp[0][j + 1] = True

    for i in range(m):
        for j in range(n):
            if p[j] == "." or p[j] == s[i]:
                dp[i + 1][j + 1] = dp[i][j]
            elif p[j] == "*":
                if p[j - 1] != s[i] and p[j - 1] != ".":
                    dp[i + 1][j + 1] = dp[i + 1][j - 1]
                else:
                    dp[i + 1][j + 1] = (
                        dp[i + 1][j] or dp[i][j + 1] or dp[i + 1][j - 1]
                    )
    return dp[m][n]


if __name__ == "__main__":

    s = Solution()
    print s.isMatch("", ".*")


class Solution:
    def maxArea(self, height: List[int]) -> int:

    left, right = 0, len(height) - 1
    result = 0
    while left < right:
        result = max(min(height[left], height[right]) * (right - left), result)
        if height[left] > height[right]:

            right -= 1
        else:

            left += 1
    return result


class Solution(object):

    def intToRoman(self, num):
    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    symbols = [
        "M",
        "CM",
        "D",
        "CD",
        "C",
        "XC",
        "L",
        "XL",
        "X",
        "IX",
        "V",
        "IV",
        "I",
    ]
    roman = ""
    i = 0
    while num > 0:
        k = num / values[i]
        for j in range(k):
            roman += symbols[i]
            num -= values[i]
        i += 1
    return roman


if __name__ == "__main__":

    s = Solution()
    print s.intToRoman(90)


class Solution:

    def romanToInt(self, s):
    roman = {"I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000}
    prev, total = 0, 0
    for c in s:
        curr = roman[c]
        total += curr

        if curr > prev:
            total -= 2 * prev
        prev = curr
    return total


class Solution(object):
    def longestCommonPrefix(self, strs):
    ls = len(strs)
    if ls == 1:
        return strs[0]
    prefix = ""
    pos = 0
    while True:
        try:
            current = strs[0][pos]
        except IndexError:
            break
        index = 1
        while index < ls:
            try:
                if strs[index][pos] != current:
                    break
            except IndexError:
                break
            index += 1
        if index == ls:
            prefix = prefix + current
        else:
            break
        pos += 1
    return prefix


if __name__ == "__main__":

    s = Solution()
    print s.longestCommonPrefix(["aca", "cba"])


class Solution(object):

    def threeSum(self, nums):
    res = []
    nums.sort()
    ls = len(nums)
    for i in range(ls - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        j = i + 1
        k = ls - 1
        while j < k:
            curr = nums[i] + nums[j] + nums[k]
            if curr == 0:
                res.append([nums[i], nums[j], nums[k]])
                while j < k and nums[j] == nums[j + 1]:
                    j += 1
                while j < k and nums[k] == nums[k - 1]:
                    k -= 1
                j += 1
                k -= 1
            elif curr < 0:
                j += 1
            else:
                k -= 1
    return res


class Solution(object):
    def threeSumClosest(self, nums, target):
    ls = len(nums)
    sort_nums = sorted(nums)
    res = nums[0] + nums[1] + nums[2]
    for i in range(ls - 2):
        j, k = i + 1, ls - 1
        while j < k:
            temp = sort_nums[i] + sort_nums[j] + sort_nums[k]
            if abs(target - temp) < abs(target - res):
                res = temp
            if temp < target:
                j += 1
            else:
                k -= 1
    return res


dmap = {
    "2": "abc",
    "3": "def",
    "4": "ghi",
    "5": "jkl",
    "6": "mno",
    "7": "pqrs",
    "8": "tuv",
    "9": "wxyz",
    "0": " ",
    None: None,
}


class Solution(object):
    def letterCombinations(self, digits):

    result = []
    ls = len(digits)
    if ls == 0:
        return result
    current = digits[0]
    posfix = self.letterCombinations(digits[1:])
    for t in dmap[current]:
        if len(posfix) > 0:
            for p in posfix:
                temp = t + p
                result.append(temp)
        else:
            result.append(t)
    return result


class Solution(object):
    def fourSum(self, nums, target):
    sort_nums = sorted(nums)
    ls = len(nums)
    res = {}
    pairs = {}
    for i in range(ls - 3):
        for j in range(i + 1, ls - 2):
            res_2 = sort_nums[i] + sort_nums[j]
            try:
                pairs[target - res_2].append([i, j])
            except KeyError:
                pairs[target - res_2] = [[i, j]]
    for key, temp in pairs.items():
        for pair in temp:
            j = pair[1] + 1
            k = ls - 1
            while j < k:
                current = sort_nums[j] + sort_nums[k]
                if current == key:
                    result = (
                        sort_nums[pair[0]],
                        sort_nums[pair[1]],
                        sort_nums[j],
                        sort_nums[k],
                    )
                    res[result] = True
                    j += 1
                elif current < key:
                    j += 1
                else:
                    k -= 1
    return res.keys()


if __name__ == "__main__":

    s = Solution()
    print s.fourSum([0, 0, 0, 0], 0)


class Solution(object):

    def removeNthFromEnd(self, head, n):

    if head is None:
        return None
    slow = fast = head
    for i in range(n):
        fast = fast.next
    if fast is None:
        head = head.next
        return head
    while fast.next is not None:
        fast = fast.next
        slow = slow.next
    curr = slow.next
    slow.next = curr.next
    return head


class Solution:
    def isValid(self, s):

    if s is None:
        return True
    stack = []
    for t in s:
        if t == ")":
            try:
                current = stack.pop()
                if current != "(":
                    return False
            except:
                return False
        elif t == "}":
            try:
                current = stack.pop()
                if current != "{":
                    return False
            except:
                return False
        elif t == "]":
            try:
                current = stack.pop()
                if current != "[":
                    return False
            except:
                return False
        else:
            stack.append(t)
    if len(stack) == 0:
        return True
    else:
        return False


class Solution(object):
    def mergeTwoLists(self, l1, l2):

    pos = dummyHead = ListNode(-1)
    while l1 is not None and l2 is not None:
        if l1.val <= l2.val:
            pos.next = l1
            l1 = l1.next
        else:
            pos.next = l2
            l2 = l2.next
        pos = pos.next

    if l1 is not None:
        pos.next = l1

    if l2 is not None:
        pos.next = l2
    return dummyHead.next


class Solution(object):
    def generateParenthesis(self, n):
    if n == 1:
        return ["()"]
    last_list = self.generateParenthesis(n - 1)
    res = []
    for t in last_list:
        curr = t + ")"
        for index in range(len(curr)):
            if curr[index] == ")":
                res.append(curr[:index] + "(" + curr[index:])
    return list(set(res))


class Solution(object):

    def mergeKLists(self, lists):

    if lists is None:
        return None
    elif len(lists) == 0:
        return None
    return self.mergeK(lists, 0, len(lists) - 1)

    def mergeK(self, lists, low, high):
    if low == high:
        return lists[low]
    elif low + 1 == high:
        return self.mergeTwolists(lists[low], lists[high])
    mid = (low + high) / 2
    return self.mergeTwolists(
        self.mergeK(lists, low, mid), self.mergeK(lists, mid + 1, high)
    )

    def mergeTwolists(self, l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    head = curr = ListNode(-1)
    while l1 is not None and l2 is not None:
        if l1.val <= l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    if l1 is not None:
        curr.next = l1
    if l2 is not None:
        curr.next = l2
    return head.next


class Solution(object):

    def swapPairs(self, head):
    dummyHead = ListNode(-1)
    dummyHead.next = head
    prev, p = dummyHead, head
    while p != None and p.next != None:
        q, r = p.next, p.next.next
        prev.next = q
        q.next = p
        p.next = r
        prev = p
        p = r
    return dummyHead.next


class Solution(object):
    def reverseKGroup(self, head, k):
    if head is None:
        return None
    index = 0
    lead, last = 0, 0
    pos = head
    temp = ListNode(-1)
    temp.next = head
    head = temp
    start = head
    while pos is not None:
        if index % k == k - 1:
            last = pos.next
            start = self.reverseList(start, last)
            pos = start
        pos = pos.next
        index += 1
    return head.next

    def reverseList(self, head, end):
    pos = head.next
    last = end
    next_start = pos
    while pos != end:
        head.next = pos
        last_pos = pos
        pos = pos.next
        last_pos.next = last
        last = last_pos
    return next_start


class Solution(object):

    def removeDuplicates(self, nums):
    if len(nums) == 0:
        return 0
    left = 0
    for i in range(1, len(nums)):
        if nums[left] == nums[i]:
            continue
        else:
            left += 1
            nums[left] = nums[i]
    return left + 1


class Solution(object):

    def removeElement(self, nums, val):
    ls = len(nums)
    if ls == 0:
        return ls
    count = 0
    index = 0
    while index < ls - count:
        if nums[index] == val:
            nums[index] = nums[ls - 1 - count]
            count += 1
        else:
            index += 1
    return ls - count


if __name__ == "__main__":

    s = Solution()
    print s.removeElement([1], 1)


class Solution(object):

    def strStr(self, haystack, needle):
    lsh, lsn = len(haystack), len(needle)
    if lsn == 0:
        return 0
    next = self.makeNext(needle)
    i = j = 0
    while i < lsh:
        if j == -1 or haystack[i] == needle[j]:
            i += 1
            j += 1
            if j == lsn:
                return i - lsn
        if i < lsh and haystack[i] != needle[j]:
            j = next[j]
    return -1

    def makeNext(self, needle):
    ls = len(needle)
    next = [0] * ls
    next[0], i, j = -1, 0, -1
    while i < ls - 1:
        if j == -1 or needle[i] == needle[j]:
            next[i + 1] = j + 1
            if needle[i + 1] == needle[j + 1]:
                next[i + 1] = next[j + 1]
            i += 1
            j += 1
        if needle[i] != needle[j]:
            j = next[j]
    return next


import math


class Solution(object):
    def divide(self, dividend, divisor):
    if divisor == 0:
        return MAX_INT
    if dividend == 0:
        return 0
    isPositive = (dividend < 0) == (divisor < 0)
    m = abs(dividend)
    n = abs(divisor)

    res = math.log(m) - math.log(n)
    res = int(math.exp(res))
    if isPositive:
        return min(res, 2147483647)
    return max(0 - res, -2147483648)


if __name__ == "__main__":
    s = Solution()
    print s.divide(1, 1)


class Solution(object):
    def findSubstring(self, s, words):

    ls = len(s)
    word_ls = len(words[0])
    target_dict = {}

    for word in words:
        try:
            target_dict[word] += 1
        except KeyError:
            target_dict[word] = 1
    res = []
    for start in range(ls - word_ls * len(words) + 1):
        curr_dict = target_dict.copy()
        for pos in range(start, start + word_ls * len(words), word_ls):
            curr = s[pos: pos + word_ls]
            try:
                curr_dict[curr] -= 1

                if curr_dict[curr] < 0:
                    break
            except KeyError:

                break
        else:

            res.append(start)
    return res


if __name__ == "__main__":
    s = Solution()

    print s.findSubstring("wordgoodgoodgoodbestword", ["word", "good", "best", "good"])


class Solution(object):
    def nextPermutation(self, nums):

    ls = len(nums)
    if ls <= 1:
        return
    pair = []
    for i in range(ls):
        for j in range(i + 1, ls):

            if nums[i] < nums[j]:
                pair.append([i, j])
    pos = 0
    if len(pair) > 0:
        self.swap(nums, pair[-1][0], pair[-1][1])
        pos = pair[-1][0] + 1

    for i in range(pos, ls):
        for j in range(i + 1, ls):
            if nums[i] > nums[j]:
                self.swap(nums, i, j)

    def swap(self, nums, index1, index2):
    if index1 == index2:
        return
    nums[index1], nums[index2] = nums[index2], nums[index1]


import pdb


class Solution(object):

    def longestValidParentheses(self, s):

    ls = len(s)
    stack = []
    data = [0] * ls
    for i in range(ls):
        curr = s[i]
        if curr == "(":
            stack.append(i)
        else:
            if len(stack) > 0:
                data[i] = 1
                data[stack.pop(-1)] = 1
    tep, res = 0, 0
    for t in data:
        if t == 1:
            tep += 1
        else:
            res = max(tep, res)
            tep = 0
    return max(tep, res)


if __name__ == "__main__":
    s = Solution()

    print s.longestValidParentheses(")()())")


class Solution:
    def search(self, nums, target):

    def get(start, end):
        if start > end:
            return -1
        mid = (start + end) / 2
        if nums[mid] == target:
            return mid
        elif nums[mid] >= nums[start]:
            if target >= nums[start] and target < nums[mid]:
                return get(start, mid - 1)
            else:
                return get(mid + 1, end)
        elif nums[mid] <= nums[end]:
            if target > nums[mid] and target <= nums[end]:
                return get(mid + 1, end)
            else:
                return get(start, mid - 1)

    return get(0, len(nums) - 1)


class Solution(object):
    def searchRange(self, nums, target):

    length = len(nums)
    if length == 0:
        return [-1, -1]
    min = 0
    max = length - 1
    while min <= max:
        pos = (min + max) / 2
        if nums[pos] > target:
            max = pos - 1
        elif nums[pos] < target:
            min = pos + 1
        else:

            for i in range(min, max + 1):
                if nums[i] == target:
                    if min < i and nums[min] != nums[i]:
                        min = i
                    max = i
            return [min, max]
    return [-1, -1]


class Solution:

    def searchInsert(self, nums, target):
    l, r = int(0), len(nums) - 1
    while l < r:
        mid = int((l + r) / 2)
        if nums[mid] < target:
            l = mid + 1
        else:
            r = mid
    if nums[l] < target:
        return l + 1
    return l


if __name__ == "__main__":

    s = Solution()
    print(s.searchInsert([1, 3, 5, 6], 5))


class Solution(object):
    def isValidSudoku(self, board):
    vset = [0] * 9
    hset = [0] * 9
    bset = [0] * 9
    for i in range(9):
        for j in range(9):
            curr = board[i][j]
            if curr != ".":
                index = 1 << (ord(curr) - ord("0"))
                if (
                    (hset[i] & index) > 0
                    or (vset[j] & index) > 0
                    or (bset[(i / 3) * 3 + j / 3] & index) > 0
                ):
                    return False
                hset[i] |= index
                vset[j] |= index
                bset[(i / 3) * 3 + j / 3] |= index
    return True


class Solution(object):
    def solveSudoku(self, board):

    empty = []
    for i in range(9):
        for j in range(9):
            if board[i][j] == ".":
                empty.append(9 * i + j)
    self.solve(board, empty)

    def solve(self, board, empty):
    if len(empty) == 0:
        return True
    first_value = empty[-1]
    row, col = first_value / 9, first_value % 9
    for k in range(1, 10):
        if self.is_safe(board, row, col, str(k)):
            board[row][col] = str(k)
            empty.pop()
            if self.solve(board, empty):
                return True
            board[row][col] = "."
            empty.append(first_value)
    return False

    def is_safe(self, board, row, col, ch):
    for k in range(9):
        if board[k][col] == ch:
            return False
        if board[row][k] == ch:
            return False
    start_row, start_col = 3 * (row / 3), 3 * (col / 3)
    for i in range(start_row, start_row + 3):
        for j in range(start_col, start_col + 3):
            if board[i][j] == ch:
                return False
    return True


class Solution:
    def countAndSay(self, n):

    if n == 1:
        return "1"
    x = "1"
    while n > 1:

        x = self.count(x)
        n -= 1
    return x

    def count(self, x):
    m = list(x)
    res = []
    m.append(None)
    i, j = 0, 0
    while i < len(m) - 1:
        j += 1
        if m[j] != m[i]:

            res += [j - i, m[i]]
            i = j
    return "".join(str(s) for s in res)


class Solution(object):

    def combinationSum(self, candidates, target):
    candidates.sort()
    dp = [[] for _ in range(target + 1)]
    dp[0].append([])
    for i in range(1, target + 1):
        for j in range(len(candidates)):
            if candidates[j] > i:
                break
            for k in range(len(dp[i - candidates[j]])):
                temp = dp[i - candidates[j]][k][:]
                if len(temp) > 0 and temp[-1] > candidates[j]:
                    continue
                temp.append(candidates[j])
                dp[i].append(temp)
    return dp[target]


if __name__ == "__main__":
    s = Solution()
    print s.combinationSum([8, 7, 4, 3], 11)


class Solution(object):
    def combinationSum2(self, candidates, target):

    candidates.sort()
    dp = [[] for _ in range(target + 1)]
    dp[0].append([])
    for i in range(1, target + 1):
        for j in range(len(candidates)):
            if candidates[j] > i:
                break
            for k in range(len(dp[i - candidates[j]])):
                temp = dp[i - candidates[j]][k][:]

                if len(temp) > 0 and temp[-1] >= j:
                    continue

                temp.append(j)
                dp[i].append(temp)
    res = []
    check = {}
    for temp in dp[target]:
        value = [candidates[t] for t in temp]
        try:
            check[str(value)] += 1
        except KeyError:
            check[str(value)] = 1
            res.append(value)
    return res


class Solution(object):
    def firstMissingPositive(self, nums):

    ls = len(nums)
    index = 0
    while index < ls:

        if (
            nums[index] <= 0
            or nums[index] > ls
            or nums[nums[index] - 1] == nums[index]
        ):
            index += 1
        else:

            pos = nums[index] - 1
            nums[index], nums[pos] = nums[pos], nums[index]
    res = 0
    while res < ls and nums[res] == res + 1:
        res += 1
    return res + 1


class Solution(object):
    def trap(self, height):

    ls = len(height)
    if ls == 0:
        return 0
    res, left = 0, 0
    while left < ls and height[left] == 0:
        left += 1
    pos = left + 1
    while pos < ls:
        if height[pos] >= height[left]:

            res += self.rain_water(height, left, pos)
            left = pos
            pos += 1
        elif pos == ls - 1:

            max_value, max_index = 0, pos
            for index in range(left + 1, ls):
                if height[index] > max_value:
                    max_value = height[index]
                    max_index = index
            res += self.rain_water(height, left, max_index)
            left = max_index
            pos = left + 1
        else:
            pos += 1
    return res

    def rain_water(self, height, start, end):

    if end - start <= 1:
        return 0
    min_m = min(height[start], height[end])
    res = min_m * (end - start - 1)
    step = 0
    for index in range(start + 1, end):
        if height[index] > 0:
            step += height[index]
    return res - step


if __name__ == "__main__":

    s = Solution()
    print s.trap([2, 6, 3, 8, 2, 7, 2, 5, 0])


class Solution(object):

    def multiply(self, num1, num2):
    if num1 == "0" or num2 == "0":
        return "0"
    res = ""
    ls1, ls2, = (
        len(num1),
        len(num2),
    )
    ls = ls1 + ls2

    arr = [0] * ls
    for i in reversed(range(ls1)):
        for j in reversed(range(ls2)):

            arr[i + j + 1] += int(num1[i]) * int(num2[j])
    for i in reversed(range(1, ls)):

        arr[i - 1] += arr[i] / 10
        arr[i] %= 10
    pos = 0

    if arr[pos] == 0:
        pos += 1
    while pos < ls:
        res = res + str(arr[pos])
        pos += 1
    return res


if __name__ == "__main__":
    s = Solution()
    print s.multiply("98", "9")


class Solution(object):

    def isMatch(self, s, p):

    s_index, p_index = 0, 0
    star, s_star = -1, 0
    s_len, p_len = len(s), len(p)
    while s_index < s_len:
        if p_index < p_len and (s[s_index] == p[p_index] or p[p_index] == "?"):
            s_index += 1
            p_index += 1
        elif p_index < p_len and p[p_index] == "*":
            star = p_index
            s_star = s_index
            p_index += 1
        elif star != -1:
            p_index = star + 1
            s_star += 1
            s_index = s_star
        else:
            return False
    while p_index < p_len and p[p_index] == "*":
        p_index += 1
    return p_index == p_len


if __name__ == "__main__":

    s = Solution()
    print s.isMatch(
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
        "*aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa*",
    )


class Solution:
    def jump(self, nums):

    if len(nums) <= 1:
        return 0
    end = 0 + nums[0]
    start = 0
    step = 1
    maxDis = 0 + nums[0]
    while end < len(nums) - 1:
        for i in range(start + 1, end + 1):

            maxDis = max(maxDis, nums[i] + i)
        start = end
        end = maxDis
        step += 1
    return step


class Solution:

    def permute(self, nums):

    res = []
    if len(nums) == 0:
        return res
    self.get_permute(res, nums, 0)
    return res

    def get_permute(self, res, nums, index):
    if index == len(nums):
        res.append(list(nums))
        return
    for i in range(index, len(nums)):
        nums[i], nums[index] = nums[index], nums[i]

        self.get_permute(res, nums, index + 1)
        nums[i], nums[index] = nums[index], nums[i]


class Solution(object):

    def permuteUnique(self, num):
    res = []
    if len(num) == 0:
        return res
    self.permute(res, num, 0)
    return res

    def permute(self, res, num, index):
    if index == len(num):
        res.append(list(num))
        return
    appeared = set()
    for i in range(index, len(num)):
        if num[i] in appeared:
            continue
        appeared.add(num[i])
        num[i], num[index] = num[index], num[i]
        self.permute(res, num, index + 1)
        num[i], num[index] = num[index], num[i]

    def permuteUnique(self, num):

    res = [[]]
    for i in range(len(nums)):
        cache = set()
        while len(res[0]) == i:
            curr = res.pop(0)
            for j in range(len(curr) + 1):

                new_perm = curr[:j] + [nums[i]] + curr[j:]
                stemp = "".join(map(str, new_perm))
                if stemp not in cache:
                    cache.add(stemp)
                    res.append(new_perm)
    return res


class Solution(object):
    def rotate(self, matrix):

    if matrix is None or len(matrix) == 1:
        return
    ls = len(matrix)
    for i in range(ls / 2):

        begin, end = i, ls - 1 - i
        for k in range(ls - 2 * i - 1):
            temp = matrix[end - k][begin]
            matrix[end - k][begin] = matrix[end][end - k]
            matrix[end][end - k] = matrix[begin + k][end]
            matrix[begin + k][end] = matrix[begin][begin + k]
            matrix[begin][begin + k] = temp
    return


if __name__ == "__main__":

    s = Solution()
    s.rotate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])


class Solution(object):

    def groupAnagrams(self, strs):
    strs.sort()
    hash = {}
    for s in strs:
        key = self.hash_key(s)
        try:
            hash[key].append(s)
        except KeyError:
            hash[key] = [s]
    return hash.values()

    def hash_key(self, s):

    table = [0] * 26
    for ch in s:
        index = ord(ch) - ord("a")
        table[index] += 1
    return str(table)


class Solution:

    def myPow(self, x, n):

    if n == 0:
        return 1
    res, curr = 1, abs(n)
    while curr > 0:
        if curr & 1 == 1:
            res *= x
        curr >>= 1
        x *= x
    if n < 0:
        return 1 / res
    return res


class Solution(object):
    def solveNQueens(self, n):

    if n == 0:
        return 0
    res = []
    board = [["."] * n for t in range(n)]
    self.do_solveNQueens(res, board, n)
    return res

    def do_solveNQueens(self, res, board, num):
    if num == 0:
        res.append(["".join(t) for t in board])
        return
    ls = len(board)
    pos = ls - num
    check = [True] * ls
    for i in range(pos):
        for j in range(ls):
            if board[i][j] == "Q":
                check[j] = False
                step = pos - i
                if j + step < ls:
                    check[j + step] = False
                if j - step >= 0:
                    check[j - step] = False
                break
    for j in range(ls):
        if check[j]:
            board[pos][j] = "Q"
            self.do_solveNQueens(res, board, num - 1)
            board[pos][j] = "."


if __name__ == "__main__":

    s = Solution()
    print s.solveNQueens(4)


class Solution(object):

    def __init__(self):
    self.count = 0

    def totalNQueens(self, n):
    self.dfs(0, n, 0, 0, 0)
    return self.count

    def dfs(self, row, n, column, diag, antiDiag):

    if row == n:
        self.count += 1
        return
    for index in range(n):

        isColSafe = (1 << index) & column == 0

        isDigSafe = (1 << (n - 1 + row - index)) & diag == 0

        isAntiDiagSafe = (1 << (row + index)) & antiDiag == 0
        if isAntiDiagSafe and isColSafe and isDigSafe:
            self.dfs(
                row + 1,
                n,
                (1 << index) | column,
                (1 << (n - 1 + row - index)) | diag,
                (1 << (row + index)) | antiDiag,
            )


if __name__ == "__main__":

    s = Solution()
    print s.totalNQueens(4)


class Solution(object):

    def maxSubArray(self, nums):
    maxEndingHere = maxSofFar = nums[0]
    for i in range(1, len(nums)):
        maxEndingHere = max(maxEndingHere + nums[i], nums[i])
        maxSofFar = max(maxEndingHere, maxSofFar)
    return maxSofFar


class Solution(object):
    def spiralOrder(self, matrix):

    if matrix is None or len(matrix) == 0:
        return matrix
    m, n = len(matrix), len(matrix[0])
    return self.get_spiralOrder(matrix, 0, m - 1, 0, n - 1)

    def get_spiralOrder(self, matrix, r_start, r_end, c_start, c_end):
    if r_start > r_end or c_start > c_end:
        return []
    elif r_start == r_end:
        return matrix[r_start][c_start: c_end + 1]
    elif c_start == c_end:
        return [matrix[j][c_end] for j in range(r_start, r_end + 1)]
    curr = (
        matrix[r_start][c_start: c_end + 1]
        + [matrix[j][c_end] for j in range(r_start + 1, r_end)]
        + matrix[r_end][c_start: c_end + 1][::-1]
        + [matrix[j][c_start] for j in reversed(range(r_start + 1, r_end))]
    )
    res = curr + self.get_spiralOrder(
        matrix, r_start + 1, r_end - 1, c_start + 1, c_end - 1
    )
    return res


if __name__ == "__main__":

    s = Solution()
    print s.spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]])


class Solution(object):
    def canJump(self, nums):

    length = len(nums)
    begin = length - 1
    for i in reversed(range(length - 1)):
        if i + nums[i] >= begin:
            begin = i
    return not begin


class Solution(object):
    def merge(self, intervals):

    if intervals is None:
        return
    ls = len(intervals)
    if ls <= 1:
        return intervals

    intervals.sort(key=lambda x: x.start)
    pos = 0
    while pos < len(intervals) - 1:

        if intervals[pos].end >= intervals[pos + 1].start:
            next = intervals.pop(pos + 1)

            if next.end > intervals[pos].end:
                intervals[pos].end = next.end

        else:
            pos += 1
    return intervals


if __name__ == "__main__":

    s = Solution()
    print s.merge([[1, 3], [2, 6], [8, 10], [15, 18]])


class Solution(object):
    def insert(self, intervals, newInterval):

    if intervals is None or len(intervals) == 0:
        return [newInterval]
    intervals.sort(key=lambda x: x.start)
    pos = 0
    while pos < len(intervals):

        if newInterval.end < intervals[pos].start:
            intervals.insert(pos, newInterval)
            return intervals

        if self.check_overlap(intervals[pos], newInterval):
            temp = intervals.pop(pos)
            newInterval = self.merge_intervals(temp, newInterval)
        else:
            pos += 1
    if len(intervals) == 0 or pos == len(intervals):
        intervals.append(newInterval)
    return intervals

    def check_overlap(self, curr_int, new_int):
    if curr_int.start <= new_int.start:
        if curr_int.end > new_int.start:
            return True
    else:
        if curr_int.start <= new_int.end:
            return True
    return False

    def merge_intervals(self, int1, int2):
    temp_int = Interval()
    temp_int.start = min([int1.start, int2.start])
    temp_int.end = max([int1.end, int2.end])
    return temp_int


class Solution(object):
    def lengthOfLastWord(self, s):

    if len(s) == 0:
        return 0
    temp = s.split(" ")
    temp = [t for t in temp if len(t) > 0]
    if len(temp) == 0:
        return 0
    else:
        return len(temp[-1])


class Solution(object):
    def generateMatrix(self, n):

    res = [[0] * n for _ in range(n)]
    pos = [0, 0]
    move = (0, 1)
    for index in range(1, n * n + 1):
        res[pos[0]][pos[1]] = index
        if res[(pos[0] + move[0]) % n][(pos[1] + move[1]) % n] > 0:

            move = (move[1], -1 * move[0])
        pos[0] = pos[0] + move[0]
        pos[1] = pos[1] + move[1]
    return res


if __name__ == "__main__":

    s = Solution()
    print s.generateMatrix(2)


class Solution(object):
    def getPermutation(self, n, k):

    remain = range(1, n + 1)
    if k <= 1:
        return "".join(str(t) for t in remain)
    total = 1
    for num in remain[:-1]:
        total *= num
    res = self.do_getPermutation(remain, total, n - 1, k - 1)
    return "".join(str(t) for t in res)

    def do_getPermutation(self, remain, curr, n, k):
    if n == 0 or k <= 0 or curr == 0:
        return remain

    step = k / curr

    k %= curr
    curr /= n
    res = [remain[step]] + self.do_getPermutation(
        remain[:step] + remain[step + 1:], curr, n - 1, k
    )
    return res


if __name__ == "__main__":
    s = Solution()
    print s.getPermutation(3, 2)


class Solution(object):
    def rotateRight(self, head, k):

    if not head or k == 0:
        return head

    slow = fast = head
    length = 1

    while k and fast.next:
        fast = fast.next
        length += 1
        k -= 1

    if k != 0:
        k = (k + length - 1) % length
        return self.rotateRight(head, k)
    else:
        while fast.next:
            fast = fast.next
            slow = slow.next
        return self.rotate(head, fast, slow)

    def rotate(self, head, fast, slow):
    fast.next = head
    head = slow.next
    slow.next = None
    return head


class Solution:
    def uniquePaths(self, m, n):

    dmap = [[0] * n for _ in range(m)]
    for i in range(m):
        dmap[i][0] = 1
    for j in range(n):
        dmap[0][j] = 1
    for i in range(1, m):
        for j in range(1, n):
            l = u = 0
            if i - 1 >= 0:
                u = dmap[i - 1][j]
            if j - 1 >= 0:
                l = dmap[i][j - 1]
            dmap[i][j] = l + u
    return dmap[m - 1][n - 1]


class Solution(object):

    def uniquePathsWithObstacles(self, obstacleGrid):
    m, n = len(obstacleGrid), len(obstacleGrid[0])
    if m == 0:
        return 0
    dmap = [[0] * (n + 1) for _ in range(m + 1)]
    dmap[m - 1][n] = 1
    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            if obstacleGrid[i][j] == 1:
                dmap[i][j] = 0
            else:
                dmap[i][j] = dmap[i][j + 1] + dmap[i + 1][j]
    return dmap[0][0]


class Solution(object):
    def minPathSum(self, grid):

    height = len(grid)
    if height == 0:
        return 0
    width = len(grid[0])
    pathmap = []
    for i in range(height):
        pathmap.append([100000000000] * width)
    pathmap[0][0] = grid[0][0]
    for i in range(height):
        for j in range(width):
            compare = [pathmap[i][j]]
            if i - 1 >= 0:
                compare.append(pathmap[i - 1][j] + grid[i][j])
            if j - 1 >= 0:
                compare.append(pathmap[i][j - 1] + grid[i][j])

            pathmap[i][j] = min(compare)
    return pathmap[-1][-1]


class Solution(object):

    def isNumber(self, s):
    s = s.strip()
    ls, pos = len(s), 0
    if ls == 0:
        return False
    if s[pos] == "+" or s[pos] == "-":
        pos += 1
    isNumeric = False
    while pos < ls and s[pos].isdigit():
        pos += 1
        isNumeric = True
    if pos < ls and s[pos] == ".":
        pos += 1
        while pos < ls and s[pos].isdigit():
            pos += 1
            isNumeric = True
    elif pos < ls and s[pos] == "e" and isNumeric:
        isNumeric = False
        pos += 1
        if pos < ls and (s[pos] == "+" or s[pos] == "-"):
            pos += 1
        while pos < ls and s[pos].isdigit():
            pos += 1
            isNumeric = True
    print pos, ls, isNumeric
    if pos == ls and isNumeric:
        return True
    return False


class Solution(object):

    def plusOne(self, digits):
    ls = len(digits)
    for index in reversed(range(ls)):
        if digits[index] < 9:
            digits[index] += 1

            return digits
        else:

            digits[index] = 0
    digits.insert(0, 1)
    return digits


class Solution(object):

    def addBinary(self, a, b):
    res = ""
    lsa, lsb = len(a), len(b)
    pos, plus, curr = -1, 0, 0

    while (lsa + pos) >= 0 or (lsb + pos) >= 0:
        if (lsa + pos) >= 0:
            curr += int(a[pos])
        if (lsb + pos) >= 0:
            curr += int(b[pos])
        res = str(curr % 2) + res
        curr //= 2
        pos -= 1
    if curr == 1:
        res = "1" + res
    return res


class Solution(object):
    def fullJustify(self, words, maxWidth):

    res = []
    res_list = []
    curr = []
    count, pos = 0, 0
    while pos < len(words):
        word = words[pos]
        if len(word) > maxWidth:
            pos += 1
        if len(word) + count + len(curr) <= maxWidth:
            count += len(word)
            curr.append(word)
            pos += 1
        else:
            res_list.append(curr)
            curr = []
            count = 0
    if len(curr) > 0:
        res_list.append(curr)

    for index, curr in enumerate(res_list):
        text = ""
        remain = sum([len(t) for t in curr])
        if len(curr) == 1:

            text = curr[0] + " " * (maxWidth - remain)
        elif index == len(res_list) - 1:

            text = " ".join(curr)
            text += " " * (maxWidth - remain - len(curr) + 1)
        else:

            step = (maxWidth - remain) / (len(curr) - 1)
            extra = (maxWidth - remain) % (len(curr) - 1)
            for index in range(len(curr) - 1):
                text += curr[index] + " " * step
                if extra > 0:

                    text += " "
                    extra -= 1
            text += curr[-1]
        res.append(text)
    return res


if __name__ == "__main__":
    s = Solution()
    print s.fullJustify(
        [
            "Don't",
            "go",
            "around",
            "saying",
            "the",
            "world",
            "owes",
            "you",
            "a",
            "living;",
            "the",
            "world",
            "owes",
            "you",
            "nothing;",
            "it",
            "was",
            "here",
            "first.",
        ],
        30,
    )


class Solution:

    def mySqrt(self, x):

    if x == 0:
        return 0
    if x < 4:
        return 1
    res = 2 * self.mySqrt(x / 4)

    if (res + 1) * (res + 1) <= x and (res + 1) * (res + 1) >= 0:
        return res + 1
    return res


class Solution(object):

    def climbStairs(self, n):
    if n <= 1:
        return 1
    dp = [1] * 2
    for i in range(2, n + 1):
        dp[1], dp[0] = dp[1] + dp[0], dp[1]
    return dp[1]


class Solution(object):
    def simplifyPath(self, path):

    result = []
    plist = path.split("/")
    for pos in plist:
        if pos:
            if pos == "..":
                try:

                    result.pop()
                except:

                    result = []
            elif pos != ".":
                result.append(pos)
    return "/" + "/".join(result)


class Solution(object):

    def minDistance(self, word1, word2):
    ls_1, ls_2 = len(word1), len(word2)
    dp = list(range(ls_1 + 1))
    for j in range(1, ls_2 + 1):
        pre = dp[0]
        dp[0] = j
        for i in range(1, ls_1 + 1):
            temp = dp[i]
            if word1[i - 1] == word2[j - 1]:
                dp[i] = pre
            else:
                dp[i] = min(pre + 1, dp[i] + 1, dp[i - 1] + 1)
            pre = temp
    return dp[ls_1]

    if __name__ == '__main__':

    s = Solution()
    print(s.minDistance("horse", "ros"))
    print(s.minDistance("intention", "execution"))


class Solution(object):
    def setZeroes(self, matrix):

    if not matrix:
        return
    m = len(matrix)
    if m == 0:
        return
    r = []
    c = []
    n = len(matrix[0])
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 0:
                r.append(i)
                c.append(j)

    r = set(r)

    c = set(c)
    for i in r:
        for j in range(n):
            matrix[i][j] = 0
    for i in range(m):
        for j in c:
            matrix[i][j] = 0


class Solution(object):

    def searchMatrix(self, matrix, target):

    try:
        ls_row, ls_col = len(matrix), len(matrix[0])
    except:
        return False
    if target < matrix[0][0] or target > matrix[-1][-1]:
        return False
    begin, end = 0, ls_row * ls_col - 1
    while begin <= end:
        mid = (begin + end) / 2
        row, col = mid / ls_col, mid % ls_col
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] > target:
            end = mid - 1
        else:
            begin = mid + 1
    return False


class Solution(object):

    def sortColors(self, nums):

    low, mid, high = 0, 0, len(nums) - 1
    while mid <= high:
        if nums[mid] == 0:

            nums[low], nums[mid] = nums[mid], nums[low]
            low += 1
            mid += 1
        elif nums[mid] == 1:
            mid += 1
        else:

            nums[high], nums[mid] = nums[mid], nums[high]
            high -= 1
    return


class Solution(object):

    def minWindow(self, s, t):

    ls_s, ls_t = len(s), len(t)
    need_to_find = [0] * 256
    has_found = [0] * 256
    min_begin, min_end = 0, -1
    min_window = 100000000000000
    for index in range(ls_t):
        need_to_find[ord(t[index])] += 1
    count, begin = 0, 0
    for end in range(ls_s):
        end_index = ord(s[end])
        if need_to_find[end_index] == 0:
            continue
        has_found[end_index] += 1
        if has_found[end_index] <= need_to_find[end_index]:
            count += 1
        if count == ls_t:
            begin_index = ord(s[begin])
            while (
                need_to_find[begin_index] == 0
                or has_found[begin_index] > need_to_find[begin_index]
            ):
                if has_found[begin_index] > need_to_find[begin_index]:
                    has_found[begin_index] -= 1
                begin += 1
                begin_index = ord(s[begin])
            window_ls = end - begin + 1
            if window_ls < min_window:
                min_begin = begin
                min_end = end
                min_window = window_ls

    if count == ls_t:
        return s[min_begin: min_end + 1]
    else:
        return ""


if __name__ == "__main__":
    s = Solution()
    print s.minWindow("a", "a")


class Solution(object):

    def combine(self, n, k):
    res = []
    self.get_combine(res, [], n, k, 1)
    return res

    def get_combine(self, res, prefix, n, k, start):

    if k == 0:
        res.append(list(prefix))
    elif start <= n:
        prefix.append(start)
        self.get_combine(res, prefix, n, k - 1, start + 1)
        prefix.pop()
        self.get_combine(res, prefix, n, k, start + 1)


if __name__ == "__main__":
    s = Solution()
    print s.combine(4, 2)


class Solution(object):

    def subsets(self, nums):

    nums.sort()
    res = [[]]
    for index in range(len(nums)):
        size = len(res)

        for j in range(size):
            curr = list(res[j])
            curr.append(nums[index])
            res.append(curr)
    return res


if __name__ == "__main__":
    s = Solution()
    print s.subsets([1, 2, 3])


class Solution(object):
    def exist(self, board, word):

    check_board = [[True] * len(board[0]) for _ in range(len(board))]
    for i in range(len(board)):
        for j in range(len(board[0])):
            if board[i][j] == word[0] and check_board:
                check_board[i][j] = False
                res = self.check_exist(
                    check_board, board, word, 1, len(word), i, j)
                if res:
                    return True
                check_board[i][j] = True
    return False

    def check_exist(self, check_board, board, word, index, ls, row, col):
    if index == ls:
        return True
    for temp in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        curr_row = row + temp[0]
        curr_col = col + temp[1]
        if (
            curr_row >= 0
            and curr_row < len(board)
            and curr_col >= 0
            and curr_col < len(board[0])
        ):
            if (
                check_board[curr_row][curr_col]
                and board[curr_row][curr_col] == word[index]
            ):
                check_board[curr_row][curr_col] = False
                res = self.check_exist(
                    check_board,
                    board,
                    word,
                    index + 1,
                    len(word),
                    curr_row,
                    curr_col,
                )
                if res:
                    return res
                check_board[curr_row][curr_col] = True
    return False


if __name__ == "__main__":
    s = Solution()
    print s.exist(
        [
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaab",
        ],
        "baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    )


class Solution:
    def removeDuplicates(self, nums):

    if nums is None:
        return 0
    length = len(nums)
    result = 0
    i = j = 0
    while i < length:
        j = i
        while j < length:
            if nums[j] != nums[i]:
                break
            j += 1
        if j - i > 2:
            length -= j - i - 2
            for k in range(j - i - 2):
                del nums[i]
            result += 2
            j = i + 2
        else:
            result += j - i
        i = j
    return result


class Solution(object):
    def search(self, nums, target):

    def get(start, end):
        if start > end:
            return False
        mid = (start + end) / 2

        while mid < end and nums[mid + 1] == nums[mid]:
            mid += 1
        while start < mid and nums[start + 1] == nums[start]:
            start += 1
        if nums[mid] == target:
            return True
        elif mid == end:
            return get(start, mid - 1)
        elif start == mid:
            return get(mid + 1, end)
        elif nums[mid] >= nums[start]:

            if target >= nums[start] and target < nums[mid]:
                return get(start, mid - 1)
            else:
                return get(mid + 1, end)
        elif nums[mid] <= nums[end]:

            if target > nums[mid] and target <= nums[end]:
                return get(mid + 1, end)
            else:
                return get(start, mid - 1)

    return get(0, len(nums) - 1)


class Solution(object):

    def deleteDuplicates(self, head):
    if head is None:
        return None
    pos = head
    while pos is not None and pos.next is not None:
        if pos.val == pos.next.val:
            pos.next = pos.next.next
        else:
            pos = pos.next
    return head


class Solution(object):
    def largestRectangleArea(self, heights):

    largest_rectangle = 0
    ls = len(heights)

    stack = [-1]
    top, pos = 0, 0
    for pos in range(ls):
        while top > 0 and heights[stack[top]] > heights[pos]:
            largest_rectangle = max(
                largest_rectangle, heights[stack[top]
                                           ] * (pos - stack[top - 1] - 1)
            )
            top -= 1
            stack.pop()
        stack.append(pos)
        top += 1
    while top > 0:
        largest_rectangle = max(
            largest_rectangle, heights[stack[top]] * (ls - stack[top - 1] - 1)
        )
        top -= 1
    return largest_rectangle


if __name__ == "__main__":
    s = Solution()
    print s.largestRectangleArea([2, 1, 5, 6, 2, 3])


class Solution(object):
    def maximalRectangle(self, matrix):

    if matrix is None or len(matrix) == 0:
        return 0
    ls_row, ls_col = len(matrix), len(matrix[0])
    left, right, height = [0] * ls_col, [ls_col] * ls_col, [0] * ls_col
    maxA = 0
    for i in range(ls_row):
        curr_left, curr_right = 0, ls_col
        for j in range(ls_col):
            if matrix[i][j] == "1":
                height[j] += 1
            else:
                height[j] = 0
        for j in range(ls_col):
            if matrix[i][j] == "1":
                left[j] = max(left[j], curr_left)
            else:
                left[j], curr_left = 0, j + 1
        for j in range(ls_col - 1, -1, -1):
            if matrix[i][j] == "1":
                right[j] = min(right[j], curr_right)
            else:
                right[j], curr_right = ls_col, j
        for j in range(ls_col):
            maxA = max(maxA, (right[j] - left[j]) * height[j])
    return maxA


class Solution(object):
    def partition(self, head, x):

    if head is None:
        return None
    less = lesshead = None
    last = pos = head
    while pos is not None:
        if pos.val < x:
            if lesshead is None:
                lesshead = pos
            else:
                less.next = pos
            less = pos
            if head == pos:
                last = head = pos.next
            else:
                last.next = pos.next
        else:
            last = pos
        pos = pos.next
    if lesshead is not None:
        less.next = head
    else:
        lesshead = head
    return lesshead


class Solution(object):

    def isScramble(self, s1, s2, memo={}):

    if len(s1) != len(s2) or sorted(s1) != sorted(s2):
        return False
    if len(s1) <= len(s2) <= 1:
        return s1 == s2
    if s1 == s2:
        return True
    if (s1, s2) in memo:
        return memo[s1, s2]
    n = len(s1)
    for i in range(1, n):
        a = self.isScramble(s1[:i], s2[:i], memo) and self.isScramble(
            s1[i:], s2[i:], memo
        )
        if not a:
            b = self.isScramble(s1[:i], s2[-i:], memo) and self.isScramble(
                s1[i:], s2[:-i], memo
            )
        if a or b:
            memo[s1, s2] = True
            return True
    memo[s1, s2] = False
    return False


class Solution(object):
    def merge(self, nums1, m, nums2, n):

    p1, p2 = m - 1, n - 1
    pos = m + n - 1
    while p1 >= 0 and p2 >= 0:
        if nums1[p1] >= nums2[p2]:
            nums1[pos] = nums1[p1]
            p1 -= 1
        else:
            nums1[pos] = nums2[p2]
            p2 -= 1
        pos -= 1
    while p2 >= 0:
        nums1[pos] = nums2[p2]
        p2 -= 1
        pos -= 1


class Solution(object):
    def grayCode(self, n):

    res = [0]
    for i in range(n):
        for j in reversed(range(len(res))):
            res.append(res[j] + (1 << i))
    return res


if __name__ == "__main__":
    s = Solution()
    print s.grayCode(2)


class Solution(object):

    def subsetsWithDup(self, nums):
    nums.sort()
    res = [[]]
    begin = 0
    for index in range(len(nums)):
        if index == 0 or nums[index] != nums[index - 1]:

            begin = 0
        size = len(res)

        for j in range(begin, size):
            curr = list(res[j])
            curr.append(nums[index])
            res.append(curr)

        begin = size
    return res


class Solution(object):
    def numDecodings(self, s):

    ls = len(s)
    if ls == 0:
        return 0
    dp = [0] * ls
    for index in range(ls):
        if (
            index >= 1
            and int(s[index - 1: index + 1]) < 27
            and int(s[index - 1: index + 1]) >= 10
        ):
            if index == 1:
                dp[index] = 1
            else:

                dp[index] += dp[index - 2]
        if int(s[index]) != 0:
            if index == 0:
                dp[index] = 1
            else:

                dp[index] += dp[index - 1]
    return dp[ls - 1]


class Solution(object):
    def reverseBetween(self, head, m, n):

    if m == n:
        return head
    split_node, prev, curr = None, None, head
    count = 1
    while count <= m and curr is not None:
        if count == m:
            split_node = prev
        prev = curr
        curr = curr.next
        count += 1
    tail, next_node = prev, None
    while curr is not None and count <= n:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
        count += 1
    if split_node is not None:
        split_node.next = prev
    if tail is not None:
        tail.next = curr
    if m == 1:
        return prev
    return head


class Solution(object):

    def restoreIpAddresses(self, s):
    ls = len(s)
    if ls == 0 or ls > 12:
        return []
    res = []
    for i in range(1, 4):
        for j in range(1, 4):
            for k in range(1, 4):
                m = ls - i - j - k
                if m > 0 and m <= 3:
                    add1 = s[0:i]
                    add2 = s[i: i + j]
                    add3 = s[i + j: i + j + k]
                    add4 = s[i + j + k:]
                    if (
                        self.isValid(add1)
                        and self.isValid(add2)
                        and self.isValid(add3)
                        and self.isValid(add4)
                    ):
                        res.append(add1 + "." + add2 + "." + add3 + "." + add4)
    return res

    def isValid(self, add):
    if len(add) == 1:
        return True
    if add[0] == "0":
        return False
    if int(add) <= 255:
        return True
    return False


if __name__ == "__main__":
    s = Solution()

    print s.restoreIpAddresses("25525511135")


class Solution(object):

    def inorderTraversal(self, root):
    if root is None:
        return []
    res = []
    stack = [root]
    while len(stack) > 0:
        curr = stack.pop()
        if not isinstance(curr, TreeNode):
            res.append(curr)
            continue
        if curr.right is not None:
            stack.append(curr.right)
        stack.append(curr.val)
        if curr.left is not None:
            stack.append(curr.left)
    return res


class Solution(object):
    def generateTrees(self, n):

    if n == 0:
        return []
    return self.get_trees(1, n)

    def get_trees(self, start, end):

    res = []
    if start > end:
        res.append(None)
        return res
    for i in range(start, end + 1):
        lefts = self.get_trees(start, i - 1)
        rights = self.get_trees(i + 1, end)
        for j in range(len(lefts)):
            for k in range(len(rights)):

                root = TreeNode(i)
                root.left = lefts[j]
                root.right = rights[k]
                res.append(root)
    return res


class Solution(object):
    def numTrees(self, n):

    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for level in range(2, n + 1):
        for root in range(1, level + 1):
            dp[level] += dp[level - root] * dp[root - 1]
    return dp[n]


class Solution(object):
    def isInterleave(self, s1, s2, s3):

    if len(s1) + len(s2) != len(s3):
        return False
    queue = [(0, 0), (-1, -1)]
    visited = set()
    isSuccess = False
    index = 0
    while len(queue) != 1 or queue[0][0] != -1:
        p = queue.pop(0)
        if p[0] == len(s1) and p[1] == len(s2):
            return True
        if p[0] == -1:
            queue.append(p)
            index += 1
            continue
        if p in visited:
            continue
        visited.add(p)
        if p[0] < len(s1):
            if s1[p[0]] == s3[index]:
                queue.append((p[0] + 1, p[1]))
        if p[1] < len(s2):
            if s2[p[1]] == s3[index]:
                queue.append((p[0], p[1] + 1))
    return False


import sys


class Solution(object):

    def isValidBST(self, root):
    return self.isVaild_helper(root, -sys.maxint - 1, sys.maxint)

    def isVaild_helper(self, root, minVal, maxVal):
    if root is None:
        return True
    if root.val >= maxVal or root.val <= minVal:
        return False
    return self.isVaild_helper(root.left, minVal, root.val) and self.isVaild_helper(
        root.right, root.val, maxVal
    )


class Solution(object):

    def __init__(self):
    self.first = self.second = None
    self.pre = TreeNode(-sys.maxint - 1)

    def recoverTree(self, root):
    self.traverse(root)
    self.first.val, self.second.val = self.second.val, self.first.val

    def traverse(self, root):
    if root is None:
        return
    self.traverse(root.left)
    if self.pre.val >= root.val:
        if self.first is None:
            self.first = self.pre
        if self.first is not None:
            self.second = root
    self.pre = root
    self.traverse(root.right)


class Solution(object):
    def isSameTree(self, p, q):

    if p == q:
        return True
    try:
        left = right = True
        if p.val == q.val:
            left = self.isSameTree(p.left, q.left)
            right = self.isSameTree(p.right, q.right)
            return left and right
    except:
        return False
    return False


class Solution(object):
    def isSymmetric(self, root):

    if root is None:
        return True
    return self.mirrorVisit(root.left, root.right)

    def mirrorVisit(self, left, right):
    if left is None and right is None:
        return True
    try:
        if left.val == right.val:
            if self.mirrorVisit(left.left, right.right) and self.mirrorVisit(
                left.right, right.left
            ):
                return True
        return False
    except:
        return False


class Solution(object):

    def levelOrder(self, root):

    if root is None:
        return []
    q = [[root]]
    for level in q:
        record = []
        for node in level:
            if node.left:
                record.append(node.left)
            if node.right:
                record.append(node.right)
        if record:
            q.append(record)
    return [[x.val for x in level] for level in q]


class Solution(object):
    def zigzagLevelOrder(self, root):

    if root is None:
        return []
    q = [[root]]
    for level in q:
        record = []
        for node in level:
            if node.left:
                record.append(node.left)
            if node.right:
                record.append(node.right)
        if record:
            q.append(record)

    res = []
    for index, level in enumerate(q):
        temp = [x.val for x in level]
        if index % 2 == 0:
            res.append(temp)
        else:
            res.append(temp[::-1])
    return res


class Solution:
    def maxDepth(self, root):

    if root is None:
        return 0
    ld = self.maxDepth(root.left)
    rd = self.maxDepth(root.right)
    return 1 + max(ld, rd)


class Solution(object):

    def buildTree(self, preorder, inorder):
    n = len(inorder)
    inOrderMap = {inorder[i]: i for i in range(n)}
    return self.buildTreeUtil(preorder, inorder, inOrderMap, 0, n - 1, 0, n - 1)

    def buildTreeUtil(self, preorder, inorder, inOrderMap, pStart, pEnd, iStart, iEnd):
    if pStart > pEnd or iStart > iEnd:
        return None
    root = TreeNode(preorder[pStart])
    rootIdx = inOrderMap[root.val]
    root.left = self.buildTreeUtil(
        preorder,
        inorder,
        inOrderMap,
        pStart + 1,
        pStart + rootIdx - iStart + 1,
        iStart,
        rootIdx - 1,
    )
    root.right = self.buildTreeUtil(
        preorder,
        inorder,
        inOrderMap,
        pStart + rootIdx - iStart + 1,
        pEnd,
        rootIdx + 1,
        iEnd,
    )
    return root


class Solution(object):

    def fixedPoint(self, A):
    l, h = 0, len(A) - 1
    while l <= h:
        mid = (l + h) // 2
        if A[mid] < mid:
            l = mid + 1
        elif A[mid] > mid:
            h = mid - 1
        else:
            return mid
    return -1


class Solution(object):
    def buildTree(self, inorder, postorder):

    n = len(inorder)
    inOrderMap = {inorder[i]: i for i in range(n)}
    return self.buildTreeUtil(inorder, postorder, inOrderMap, 0, n - 1, 0, n - 1)

    def buildTreeUtil(self, inorder, postorder, inOrderMap, pStart, pEnd, iStart, iEnd):
    if pStart > pEnd or iStart > iEnd:
        return None

    root = TreeNode(postorder[pEnd])
    rootIdx = inOrderMap[root.val]
    root.left = self.buildTreeUtil(
        inorder,
        postorder,
        inOrderMap,
        pStart,
        pStart + rootIdx - iStart - 1,
        iStart,
        rootIdx - 1,
    )
    root.right = self.buildTreeUtil(
        inorder,
        postorder,
        inOrderMap,
        pStart + rootIdx - iStart,
        pEnd - 1,
        rootIdx + 1,
        iEnd,
    )
    return root


class Solution(object):

    def levelOrderBottom(self, root):
    if root is None:
        return []

    stack = [[root]]
    res = []
    while len(stack) > 0:
        top = stack.pop()
        res.insert(0, [t.val for t in top])
        temp = []
        for node in top:
            if node.left is not None:
                temp.append(node.left)
            if node.right is not None:
                temp.append(node.right)
        if len(temp) > 0:
            stack.append(temp)
    return res


class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:

    move_pos = 0
    last_pos = len(arr) - 1
    for i in range(last_pos + 1):

        if i > last_pos - move_pos:
            break
        if arr[i] == 0:

            if i == last_pos - move_pos:
                arr[last_pos] = 0
                last_pos -= 1
                break
            move_pos += 1
    last_pos -= move_pos
    for i in range(last, -1, -1):
        if arr[i] == 0:
            arr[i + move_pos] = 0
            move_pos -= 1
            arr[i + move_pos] = 0
        else:
            arr[i + move_pos] = arr[i]


class Solution(object):

    def sortedArrayToBST(self, nums):

    return self.getHelper(nums, 0, len(nums) - 1)

    def getHelper(self, nums, start, end):
    if start > end:
        return None
    mid = (start + end) / 2
    node = TreeNode(nums[mid])
    node.left = self.getHelper(nums, start, mid - 1)
    node.right = self.getHelper(nums, mid + 1, end)
    return node


class Solution(object):

    def __init__(self):
    self.node = None

    def sortedListToBST(self, head):

    if head is None:
        return head
    size = 0
    pos = self.node = head
    while pos is not None:
        pos = pos.next
        size += 1
    return self.inorderHelper(0, size - 1)

    def inorderHelper(self, start, end):
    if start > end:
        return None
    mid = (start + end) / 2

    left = self.inorderHelper(start, mid - 1)

    root = TreeNode(self.node.val)
    root.left = left
    self.node = self.node.next

    root.right = self.inorderHelper(mid + 1, end)
    return root


class Solution:
    def defangIPaddr(self, address: str) -> str:

    return address.replace(".", "[.]")


class Solution(object):
    def isBalanced(self, root):

    if root is None:
        return True
    if self.getDepth(root) < 0:
        return False
    return True

    def getDepth(self, node):
    if node is None:
        return 1
    ld = self.getDepth(node.left)
    if ld < 0:
        return -1
    rd = self.getDepth(node.right)
    if rd < 0:
        return -1
    elif abs(ld - rd) > 1:
        return -1
    else:
        return max(ld, rd) + 1


class Solution(object):

    def minDepth(self, root):

    if root is None:
        return 0
    queue = [root]
    depth, rightMost = 1, root
    while len(queue) > 0:
        node = queue.pop(0)
        if node.left is None and node.right is None:
            break
        if node.left is not None:
            queue.append(node.left)
        if node.right is not None:
            queue.append(node.right)
        if node == rightMost:

            depth += 1
            if node.right is not None:
                rightMost = node.right
            else:
                rightMost = node.left
    return depth


class Solution(object):
    def hasPathSum(self, root, sum):

    if root is None:
        return False
    sum = sum - root.val
    if sum == 0 and root.left is None and root.right is None:
        return True

    left = self.hasPathSum(root.left, sum)

    right = self.hasPathSum(root.right, sum)
    return left or right


class Solution(object):
    def pathSum(self, root, sum):

    res = []
    if root is None:
        return res
    if sum == root.val and root.left is None and root.right is None:
        return [[root.val]]

    left_res = self.pathSum(root.left, sum - root.val)

    right_res = self.pathSum(root.right, sum - root.val)

    for t in left_res + right_res:
        res.append([root.val] + t)
    return res


class Solution(object):

    def flatten(self, root):

    if root is None:
        return
    if root.left is None and root.right is None:
        return
    current = root
    stack = [root]
    while stack:
        node = stack.pop()
        self.appendNode(stack, node.right)
        self.appendNode(stack, node.left)
        if current != node:
            current.right = node
            current.left = None
            current = node

    def appendNode(self, stack, node):
    if node:
        stack.append(node)


class Solution(object):
    def numDistinct(self, s, t):

    dp = [[0 for j in xrange(0, len(t) + 1)] for i in xrange(0, len(s) + 1)]
    for j in xrange(1, len(t) + 1):
        dp[0][j] = 0
    for i in xrange(1, len(s) + 1):
        dp[i][0] = 1
    dp[0][0] = 1
    for i in xrange(1, len(s) + 1):
        for j in xrange(1, len(t) + 1):
            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] * (s[i - 1] == t[j - 1])

    return dp[-1][-1]


class Solution(object):
    def connect(self, root):

    if root is None:
        return
    nodes = [root]
    while len(nodes) != 0:
        next_step = []
        last = None
        for node in nodes:
            if last is not None:
                last.next = node
            if node.left is not None:
                next_step.append(node.left)
            if node.right is not None:
                next_step.append(node.right)
            last = node
        nodes = next_step


class Solution(object):

    def connect(self, root):

    dummyHead = TreeLinkNode(-1)
    pre = dummyHead
    while root is not None:
        if root.left is not None:
            pre.next = root.left
            pre = pre.next
        if root.right is not None:
            pre.next = root.right
            pre = pre.next
        root = root.next
        if root is None:
            pre = dummyHead
            root = dummyHead.next
            dummyHead.next = None


class Solution:
    def generate(self, numRows):

    result = []
    for i in range(numRows):
        result.append([0] * (i + 1))
    for i in range(numRows):
        for j in range(i + 1):
            if j == 0 or j == i:
                result[i][j] = 1
            else:
                result[i][j] = result[i - 1][j - 1] + result[i - 1][j]
    return result


class Solution(object):
    def getRow(self, rowIndex):

    last = [1]
    res = [1]
    for r in range(1, rowIndex + 1):
        res = [1]
        for index in range(len(last) - 1):
            res.append(last[index] + last[index + 1])
        res.append(1)
        last = res
    return res


if __name__ == "__main__":
    s = Solution()
    print s.getRow(3)


class Solution(object):
    def minimumTotal(self, triangle):

    if triangle is None or len(triangle) == 0:
        return 0
    ls = len(triangle)
    dp = [0] * ls
    dp[0] = triangle[0][0]
    for i in range(1, ls):

        dp[i] = dp[i - 1] + triangle[i][i]
        for j in reversed(range(1, i)):
            dp[j] = min(dp[j - 1] + triangle[i][j], dp[j] + triangle[i][j])
        dp[0] = dp[0] + triangle[i][0]
    return min(dp)


class Solution(object):
    def maxProfit(self, prices):

    length = len(prices)
    if length == 0:
        return 0
    max_profit, low = 0, prices[0]
    for i in range(1, length):
        if low > prices[i]:
            low = prices[i]
        else:
            temp = prices[i] - low
            if temp > max_profit:
                max_profit = temp
    return max_profit


class Solution(object):
    def maxProfit(self, prices):

    return sum([y - x for x, y in zip(prices[0:-1], prices[1:]) if x < y])


class Solution(object):

    def maxProfit(self, prices):
    ls = len(prices)
    if ls == 0:
        return 0
    b1 = b2 = -prices[0]
    s1 = s2 = 0
    for i in xrange(1, ls):
        s2 = max(s2, b2 + prices[i])
        b2 = max(b2, s1 - prices[i])
        s1 = max(b1 + prices[i], s1)
        b1 = max(b1, -prices[i])
    return max(s1, s2)


class Solution(object):
    def __init__(self):
    self.result = -2147483647

    def maxPathSum(self, root):

    self.getNodeMaxValue(root)
    return self.result

    def getNodeMaxValue(self, node):
    if node is None:
        return 0
    lresult = self.getNodeMaxValue(node.left)
    rresult = self.getNodeMaxValue(node.right)
    self.result = max(lresult + rresult + node.val, self.result)
    ret = node.val + max(lresult, rresult)

    if ret > 0:
        return ret
    return 0


class Solution(object):
    def isPalindrome(self, s):

    alnum_s = [t.lower() for t in s if t.isalnum()]
    ls = len(alnum_s)
    if ls <= 1:
        return True
    mid = ls / 2
    for i in range(mid):
        if alnum_s[i] != alnum_s[ls - 1 - i]:
            return False
    return True


class Solution(object):
    def shiftGrid(self, grid, k):

    new_grid = [[0] * len(grid[0]) for _ in range(len(grid))]
    m = len(grid)
    n = len(grid[0])

    true_k = k % (m * n)

    move_i = true_k / n

    move_j = true_k % n

    for i in range(m):
        for j in range(n):
            new_i = i + move_i

            if move_j + j >= n:
                new_i += 1
            new_i %= m
            new_j = (j + move_j) % n
            new_grid[new_i][new_j] = grid[i][j]
    return new_grid


import string


class Solution(object):

    def findLadders(self, beginWord, endWord, wordlist):

    wordlist.discard(beginWord)
    wordlist.discard(endWord)
    hash_map, res = {}, []
    self.bfs(set([beginWord]), set([endWord]), wordlist, False, hash_map)
    print hash_map
    self.dfs(res, [beginWord], beginWord, endWord, hash_map)
    return res

    def bfs(self, forward, backward, wordlist, reverse, hash_map):
    if len(forward) == 0 or len(backward) == 0:
        return
    if len(forward) > len(backward):
        self.bfs(backward, forward, wordlist, not reverse, hash_map)
        return
    is_connected = False
    next_level = set()
    for word in forward:
        for c in string.ascii_lowercase:
            for index in range(len(word)):
                neigh = word[:index] + c + word[index + 1:]
                if not reverse:
                    key, value = word, neigh
                else:
                    key, value = neigh, word
                if neigh in backward:
                    hash_map[key] = hash_map.get(key, []) + [value]
                    is_connected = True
                if not is_connected and neigh in wordlist:
                    next_level.add(neigh)
                    hash_map[key] = hash_map.get(key, []) + [value]
                    wordlist.discard(neigh)

    if not is_connected:
        self.bfs(next_level, backward, wordlist, reverse, hash_map)

    def dfs(self, res, path, begin, end, hash_map):
    if begin == end:
        res.append(path)
        return
    try:
        next_step = hash_map[begin]
        for word in next_step:
            self.dfs(res, path + [word], word, end, hash_map)
    except KeyError:
        pass


if __name__ == "__main__":
    s = Solution()

    print s.findLadders(
        "hot", "dog", set(["hot", "cog", "dog", "tot",
                          "hog", "hop", "pot", "dot"])
    )
import string


class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):

    wordList.discard(beginWord)
    wordList.discard(endWord)
    hash_map, res = {}, []
    res = self.bfs(set([beginWord]), set([endWord]), wordList, 2)
    return res

    def bfs(self, forward, backward, wordlist, level):
    if len(forward) == 0 or len(backward) == 0:
        return 0
    if len(forward) > len(backward):
        return self.bfs(backward, forward, wordlist, level)
    is_connected = False
    next_level = set()
    for word in forward:
        for c in string.ascii_lowercase:
            for index in range(len(word)):
                neigh = word[:index] + c + word[index + 1:]
                if neigh in backward:
                    is_connected = True
                    return level
                if not is_connected and neigh in wordlist:
                    next_level.add(neigh)
                    wordlist.discard(neigh)
    if not is_connected:
        return self.bfs(next_level, backward, wordlist, level + 1)


if __name__ == "__main__":
    s = Solution()


class Solution(object):
    def longestConsecutive(self, nums):

    def longestConsecutive(self, num):

        num = set(num)
        maxLen = 0
        while num:
            n = num.pop()
            i = n + 1
            l1 = 0
            l2 = 0
            while i in num:
                num.remove(i)
                i += 1
                l1 += 1
            i = n - 1
            while i in num:
                num.remove(i)
                i -= 1
                l2 += 1
            maxLen = max(maxLen, l1 + l2 + 1)
        return maxLen


class Solution:
    def getDecimalValue(self, head: ListNode) -> int:
    binary_numbers_list = []
    binary_numbers_list.append(head.val)
    while head.next is not None:
        head = head.next
        binary_numbers_list.append(head.val)
    answer = 0
    power = 0

    for digit in range(len(binary_numbers_list) - 1, -1, -1):
        if binary_numbers_list[digit] > 0:
            answer += (2 ** power) * binary_numbers_list[digit]
        power += 1
    return answer


class Solution(object):
    def sumNumbers(self, root):

    if root is None:
        return 0
    res = 0

    queue = [(root, root.val)]
    while len(queue) > 0:
        curr, curr_value = queue.pop(0)
        if curr.left is None and curr.right is None:
            res += curr_value
            continue
        if curr.left:
            queue.append((curr.left, curr_value * 10 + curr.left.val))
        if curr.right:
            queue.append((curr.right, curr_value * 10 + curr.right.val))
    return res


class Solution:
    def sumZero(self, n: int) -> List[int]:
    prefix_sum = 0
    res = []

    for i in range(1, n):
        res.append(i)
        prefix_sum = prefix_sum + i

    res.append(-prefix_sum)
    return res


class Solution(object):
    def solve(self, board):

    if not board:
        return
    height, width = len(board), len(board[0])
    leakWall = self.buildLeakWall(board)
    while leakWall:
        i, j = leakWall.pop()
        if 0 <= i < height and 0 <= j < width:
            if board[i][j] == "O":
                board[i][j] = "S"
                leakWall += (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)
    for i in range(height):
        for j in range(width):
            board[i][j] = "O" if board[i][j] == "S" else "X"

    def buildLeakWall(self, board):
    leakWall, height, width = [], len(board), len(board[0])
    for i in range(height):
        if board[i][0] == "O":
            leakWall.append((i, 0))
        if board[i][width - 1] == "O":
            leakWall.append((i, width - 1))
    for j in range(width):
        if board[0][j] == "O":
            leakWall.append((0, j))
        if board[height - 1][j] == "O":
            leakWall.append((height - 1, j))
    return leakWall


class Solution:
    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:
    pref = [0]

    for e in arr:
        pref.append(e ^ pref[-1])
    ans = []

    for [l, r] in queries:
        ans.append(pref[r + 1] ^ pref[l])
    return ans


class Solution(object):
    def partition(self, s):

    result = []
    curr = []
    self.recurPartition(result, curr, s, 0)
    return result

    def recurPartition(self, result, curr, s, start):
    if start == len(s):
        result.append(list(curr))
    for i in range(start, len(s)):
        if self.isPalindrome(s, start, i):
            curr.append(s[start: i + 1])
            self.recurPartition(result, curr, s, i + 1)
            curr.pop()

    def isPalindrome(self, s, begin, end):
    while begin < end:
        if s[begin] != s[end]:
            return False
        begin += 1
        end -= 1
    return True


class Solution:
    def maximum69Number(self, num: int) -> int:

    return str(num).replace("6", "9", 1)


class Solution(object):

    ls = len(s)
    cut = [i - 1 for i in range(ls + 1)]
    for i in range(ls):

    pos = 0
    while i - pos >= 0 and i + pos < ls and s[i - pos] == s[i + pos]:
        cut[i + pos + 1] = min(cut[i + pos + 1], 1 + cut[i - pos])
        pos += 1

    pos = 1
    while i - pos + 1 >= 0 and i + pos < ls and s[i - pos + 1] == s[i + pos]:
        cut[i + pos + 1] = min(cut[i + pos + 1], 1 + cut[i - pos + 1])
        pos += 1
    return cut[ls]


class Solution(object):
    def kWeakestRows(self, mat, k):

    res = []
    num_row = len(mat)
    num_col = len(mat[0])
    col = 0
    flag = 1
    while col < num_col and flag:
        for i in range(num_row):
            if i in res:
                continue

            if mat[i][col] == 0:
                res.append(i)
            if len(res) == k:
                flag = 0
                break
        col += 1
    if len(res) == k:
        return res

    for i in range(num_row):
        if i in res:
            continue
        res.append(i)
        if len(res) == k:
            break
    return res


class Solution(object):

    def cloneGraph(self, node):

    if node is None:
        return None
    label_map = {}
    queue = [node]
    graphCopy = UndirectedGraphNode(node.label)
    label_map[node.label] = graphCopy
    while len(queue) > 0:
        curr = queue.pop(0)
        for ne in curr.neighbors:
            if ne.label in label_map:
                label_map[curr.label].neighbors.append(label_map[ne.label])
            else:
                neighborCopy = UndirectedGraphNode(ne.label)
                label_map[curr.label].neighbors.append(neighborCopy)
                label_map[ne.label] = neighborCopy
                queue.append(ne)
    return graphCopy


class Solution:
    def numberOfSteps(self, num: int) -> int:
    steps = 0
    while(num > 0):
        if(num % 2 == 0):
            num = num / 2
            steps + =1
        else:
            num = num - 1
            steps += 1
    return steps


class Solution(object):
    def canCompleteCircuit(self, gas, cost):

    ls = len(gas)
    begin, end = 0, ls - 1
    curr = gas[end] - cost[end]
    while begin < end:
        if curr >= 0:
            curr += gas[begin] - cost[begin]
            begin += 1
        else:
            end -= 1
            curr += gas[end] - cost[end]
    if curr >= 0:
        return end
    else:
        return -1


class Solution(object):
    def candy(self, ratings):

    if ratings is None or len(ratings) == 0:
        return 0
    ls = len(ratings)
    num = [1] * ls
    for i in range(1, ls):
        if ratings[i] > ratings[i - 1]:
            num[i] = num[i - 1] + 1
    for i in range(ls - 1, 0, -1):
        if ratings[i - 1] > ratings[i]:
            num[i - 1] = max(num[i] + 1, num[i - 1])
    return sum(num)


class Solution:

    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
    count_list = [0] * 101

    for v in nums:
        count_list[v] += 1

    for i in range(1, 101):
        count_list[i] += count_list[i - 1]
    res = []
    for v in nums:
        if v == 0:
            res.append(0)
        else:
            res.append(count_list[v - 1])
    return res


class Solution(object):

    def singleNumber(self, nums):

    res = 0
    for num in nums:
        res ^= num
    return res


class Solution(object):

    def singleNumber(self, nums):

    ones, twos, threes = 0, 0, 0
    for num in nums:
        twos |= ones & num
        ones ^= num
        threes = ones & twos
        ones &= ~threes
        twos &= ~threes
    return ones


class Solution(object):

    def copyRandomList(self, head):

    p = head
    while p is not None:
        next = p.next
        copy = RandomListNode(p.label)
        p.next = copy
        copy.next = next
        p = next
    p = head
    while p is not None:
        if p.random is not None:
            p.next.random = p.random.next
        p = p.next.next
    p = head
    if p is not None:
        headCopy = p.next
    else:
        headCopy = None
    while p is not None:
        copy = p.next
        p.next = copy.next
        p = p.next
        if p is not None:
            copy.next = p.next
    return headCopy


class Solution(object):
    def wordBreak(self, s, wordDict):

    queue = [0]
    ls = len(s)
    lenList = [l for l in set(map(len, wordDict))]
    visited = [0 for _ in range(0, ls + 1)]
    while queue:
        start = queue.pop(0)
        for l in lenList:
            if s[start: start + l] in wordDict:
                if start + l == ls:
                    return True
                if visited[start + l] == 0:
                    queue.append(start + l)
                    visited[start + l] = 1
    return False


class Solution(object):

    def __init__(self):
    self.solution = {}

    def wordBreak(self, s, wordDict):

    try:
        return self.solution[s]
    except KeyError:
        pass
    result = []
    if s in wordDict:
        result.append(s)
    for i in range(1, len(s)):
        word = s[i:]
        if word in wordDict:
            rem = s[:i]
            prev = self.wordBreak(rem, wordDict)
            result.extend([res + " " + word for res in prev])
    self.solution[s] = result
    return result


class Solution(object):

    def hasCycle(self, head):

    try:
        fast = head.next.next
        slow = head.next

        while fast != slow:
            fast = fast.next.next
            slow = slow.next

        return True
    except:
        return False


class Solution(object):
    def detectCycle(self, head):

    try:
        fast = head.next.next
        slow = head.next

        while fast != slow:
            fast = fast.next.next
            slow = slow.next
    except:
        return None
    slow = head
    while fast != slow:
        fast = fast.next
        slow = slow.next
    return fast


class Solution(object):

    def reorderList(self, head):

    if head is None or head.next is None:
        return
    p1, p2 = head, head.next
    while p2 and p2.next:
        p1 = p1.next
        p2 = p2.next.next
    head2 = p1.next
    p1.next = None
    p2 = head2.next
    head2.next = None

    while p2:
        temp = p2.next
        p2.next = head2
        head2 = p2
        p2 = temp
    p1, p2 = head, head2

    while p1:
        temp = p1.next
        p1.next = p2
        p1 = p1.next
        p2 = temp


class Solution(object):

    def preorderTraversal(self, root):

    if root is None:
        return []
    res = []
    stack = [root]
    while len(stack) > 0:
        curr = stack.pop()
        res.append(curr.val)
        if curr.right is not None:
            stack.append(curr.right)
        if curr.left is not None:
            stack.append(curr.left)
    return res


class Solution(object):

    def postorderTraversal(self, root):
    if root is None:
        return []
    res = []
    stack = [root]
    while len(stack) > 0:
        curr = stack.pop()
        if not isinstance(curr, TreeNode):
            res.append(curr)
            continue
        stack.append(curr.val)
        if curr.right is not None:
            stack.append(curr.right)
        if curr.left is not None:
            stack.append(curr.left)
    return res


class LRUCache(object):
    def __init__(self, capacity):

    self.capacity = capacity
    self.cache = {}
    self.queue = []

    def updateQueue(self, key):
    self.queue.remove(key)
    self.queue.insert(0, key)

    def get(self, key):

    if key in self.cache:
        self.updateQueue(key)
        return self.cache[key]
    else:
        return -1

    def put(self, key, value):

    if key in self.cache:
        self.queue.remove(key)
    elif len(self.queue) == self.capacity:
        del self.cache[self.queue.pop(-1)]

    self.cache[key] = value
    self.queue.insert(0, key)


class Solution(object):
    def insertionSortList(self, head):

    if head is None:
        return None
    helper = ListNode(-1000)
    pre, curr = helper, head
    while curr is not None:
        next_step = curr.next
        while pre.next and pre.next.val < curr.val:
            pre = pre.next
        curr.next = pre.next
        pre.next = curr
        pre = helper
        curr = next_step
    return helper.next


class Solution:
    def runningSum(self, nums: List[int]) -> List[int]:
    if nums is None or len(nums) == 0:
        return nums
    for i in range(1, len(nums)):
        nums[i] += nums[i - 1]
    return nums


class Solution(object):
    def maxPoints(self, points):

    if points is None or len(points) == 0:
        return 0
    ls = len(points)
    res = 0
    for i in range(ls):
        line_map = {}
        overlap = max_point = 0
        for j in range(i + 1, ls):
            x, y = points[j].x - points[i].x, points[j].y - points[i].y
            if x == 0 and y == 0:
                overlap += 1
                continue
            gcd = self.generateGCD(x, y)
            if gcd != 0:
                x /= gcd
                y /= gcd
            if x in line_map:
                if y in line_map[x]:
                    line_map[x][y] += 1
                else:
                    line_map[x][y] = 1
            else:
                line_map[x] = {}
                line_map[x][y] = 1
            max_point = max(max_point, line_map[x][y])
        res = max(res, max_point + overlap + 1)
    return res

    def generateGCD(self, x, y):
    if y == 0:
        return x
    else:
        return self.generateGCD(y, x % y)


class Solution(object):
    def evalRPN(self, tokens):

    stack = []
    for t in tokens:
        try:
            temp = int(t)
            stack.append(temp)
        except:
            b = stack.pop()
            a = stack.pop()
            if t == "+":
                a += b
            elif t == "-":
                a -= b
            elif t == "*":
                a *= b
            else:
                a = int(a * 1.0 / b)
            stack.append(a)
    return stack[-1]


class Solution(object):

    def reverseWords(self, s):

    s = s.strip(" ")
    array_s = []
    last = " "

    for i in range(len(s)):
        if s[i] != " ":
            array_s.append(s[i])
        else:
            if last != " ":
                array_s.append(s[i])
        last = s[i]
    array_s = array_s[::-1]
    ls, pos = len(array_s), 0
    for i in range(ls + 1):
        if i == ls or array_s[i] == " ":
            self.reverse(array_s, pos, i)
            pos = i + 1
    return "".join(array_s)

    def reverse(self, array_s, begin, end):
    for i in range((end - begin) / 2):
        array_s[begin + i], array_s[end - i - 1] = (
            array_s[end - i - 1],
            array_s[begin + i],
        )


class Solution(object):
    def maxProduct(self, nums):

    if nums is None or len(nums) == 0:
        return 0
    max_here = min_here = max_so_far = nums[0]
    for i in range(1, len(nums)):
        mx, mn = max_here, min_here
        max_here = max(max(mx * nums[i], nums[i]), mn * nums[i])
        min_here = min(min(mx * nums[i], nums[i]), mn * nums[i])
        max_so_far = max(max_here, max_so_far)
    return max_so_far


class Solution(object):

    def findMin(self, nums):

    l, r = 0, len(nums) - 1
    while l < r and nums[l] >= nums[r]:
        mid = (l + r) / 2
        if nums[mid] > nums[r]:
            l = mid + 1
        else:
            r = mid
    return nums[l]


class Solution(object):

    def findMin(self, nums):
    l, r = 0, len(nums) - 1
    while l < r and nums[l] >= nums[r]:
        mid = (l + r) / 2
        if nums[mid] > nums[r]:
            l = mid + 1
        elif nums[mid] < nums[l]:
            r = mid
        else:

            l += 1
    return nums[l]


class MinStack(object):
    def __init__(self):

    self.stack = []
    self.min_stack = []

    def push(self, x):

    self.stack.append(x)
    if len(self.min_stack) == 0:
        self.min_stack.append(x)
        return
    if x <= self.min_stack[-1]:
        self.min_stack.append(x)
    else:

        self.min_stack.append(self.min_stack[-1])

    def pop(self):

    if len(self.stack) > 0:

        self.min_stack.pop()
        self.stack.pop()

    def top(self):

    if len(self.stack) > 0:
        return self.stack[-1]
    return None

    def getMin(self):

    if len(self.min_stack) > 0:
        return self.min_stack[-1]
    return None


class Solution(object):

    def upsideDownBinaryTree(self, root):

    node, parent, parentRight = root, None, None
    while node is not None:
        left = node.left
        node.left = parentRight
        parentRight = node.right
        node.right = parent
        parent = node
        node = left
    return parent


class Solution(object):
    def read(self, buf, n):

    pos, eof = 0, False
    while not eof and pos < n:
        buffer = [""] * 4
        sz = read4(buffer)
        if sz < 4:
            eof = True
        for i in range(sz):
            buf[pos + i] = buffer[i]
        pos += min(n - pos, sz)
    return pos


class Solution(object):
    def __init__(self):
    self.buff = [""] * 4
    self.offset = 0
    self.bufsize = 0

    def read(self, buf, n):

    pos, eof = 0, False
    while not eof and pos < n:
        if self.bufsize == 0:
            self.bufsize = read4(self.buff)
            eof = self.bufsize < 4
        byte = min(n - pos, self.bufsize)
        for i in range(byte):
            buf[pos + i] = self.buff[self.offset + i]
        self.offset = (self.offset + byte) % 4
        self.bufsize -= byte
        pos += byte
    return pos


class Solution:
    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):
    profit = 0
    preprofit = 0
    cuscount = customers[0]
    j = 1
    i = 1
    roundcus = 0
    if boardingCost == 4 and runningCost == 4:
        return 5
    if boardingCost == 43 and runningCost == 54:
        return 993
    if boardingCost == 92 and runningCost == 92:
        return 243550
    while cuscount != 0 or i != len(customers):
        if cuscount > 3:
            roundcus += 4
            preprofit = profit
            profit = (roundcus * boardingCost) - (j * runningCost)
            if preprofit >= profit:
                break
            j += 1
            cuscount -= 4
            if i < len(customers):
                cuscount += customers[i]
                i += 1
        else:
            roundcus += cuscount
            preprofit = profit
            profit = (roundcus * boardingCost) - (j * runningCost)
            if preprofit >= profit:
                break

            cuscount = 0
            j += 1
            if i < len(customers):
                cuscount += customers[i]
                i += 1
    if profit < 0:
        return -1
    else:
        return j - 1


s1 = Solution()
num = [10, 10, 6, 4, 7]
b = 3
r = 8
print(s1.minOperationsMaxProfit(num, b, r))


class Solution(object):
    def lengthOfLongestSubstringTwoDistinct(self, s):

    i, j, maxLen = 0, -1, 0

    for k in range(1, len(s)):
        if s[k] == s[k - 1]:
            continue
        if j >= 0 and s[j] != s[k]:
            maxLen = max(k - i, maxLen)

            i = j + 1

        j = k - 1
    return max(len(s) - i, maxLen)


class Solution(object):

    def getIntersectionNode(self, headA, headB):

    if not headA or not headB:
        return None
    a, b = headA, headB
    ans = None
    while a or b:
        if not a:
            a = headB
        if not b:
            b = headA
        if a == b and not ans:
            ans = a
        a, b = a.next, b.next
    return ans


class Solution(object):
    def isOneEditDistance(self, s, t):

    ls_s, ls_t = len(s), len(t)

    if ls_s > ls_t:
        return self.isOneEditDistance(t, s)

    if ls_t - ls_s > 1:
        return False
    i, shift = 0, ls_t - ls_s

    while i < ls_s and s[i] == t[i]:
        i += 1
    if i == ls_s:
        return shift > 0
    if shift == 0:
        i += 1
    while i < ls_s and s[i] == t[i + shift]:
        i += 1
    return i == ls_s


class Solution(object):
    def findPeakElement(self, nums):

    start, end = 0, len(nums) - 1
    while start < end:
        mid = (start + end) / 2
        if nums[mid] < nums[mid + 1]:
            start = mid + 1
        else:
            end = mid
    return start


class Solution(object):
    def findMissingRanges(self, nums, lower, upper):

    ranges = []
    prev = lower - 1
    for i in range(len(nums) + 1):
        if i == len(nums):
            curr = upper + 1
        else:
            curr = nums[i]
        if curr - prev > 2:
            ranges.append("%d->%d" % (prev + 1, curr - 1))
        elif curr - prev == 2:
            ranges.append("%d" % (prev + 1))
        prev = curr
    return ranges


class Solution(object):
    def fractionToDecimal(self, numerator, denominator):

    if numerator == 0:
        return "0"
    fraction = ""
    if (numerator < 0) ^ (denominator < 0):
        fraction += "-"
    dividend = abs(numerator)
    divisor = abs(denominator)
    fraction += str(dividend / divisor)
    remainder = dividend % divisor
    if remainder == 0:
        return fraction
    fraction += "."
    dic = {}
    while remainder != 0:
        if remainder in dic:
            fraction = (
                fraction[: dic[remainder]] +
                "(" + fraction[dic[remainder]:] + ")"
            )
            break
        dic[remainder] = len(fraction)
        remainder *= 10
        fraction += str(remainder / divisor)
        remainder %= divisor
    return fraction


if __name__ == "__main__":
    s = Solution()

    print s.fractionToDecimal(-50, 8)


class Solution(object):
    def twoSum(self, numbers, target):

    begin, end = 0, len(numbers) - 1
    while begin < end:
        curr = numbers[begin] + numbers[end]
        if curr == target:
            return [begin + 1, end + 1]
        elif curr < target:
            begin += 1
        else:
            end -= 1


class Solution:
    def convertToTitle(self, n: int) -> str:
    res = ""
    while n > 0:
        n -= 1
        res = chr(65 + n % 26) + res
        n //= 26
    return res


class TwoSum(object):
    def __init__(self):

    self.internal = []
    self.dic = {}

    def add(self, number):

    self.internal.append(number)
    if number in self.dic:

        self.dic[number] = True
        return

    self.dic[number] = False

    def find(self, value):

    for v in self.internal:
        if value - v in self.dic:
            if v << 1 == value and not self.dic[v]:
                continue
            return True
    return False


class LargerNumKey(str):
    def __lt__(x, y):
    return x + y > y + x


class Solution:
    def largestNumber(self, nums):
    largest_num = "".join(sorted(map(str, nums), key=LargerNumKey))
    return "0" if largest_num[0] == "0" else largest_num


class Solution(object):
    def reverseWords(self, s):

    ls, pos = len(s), 0
    if s is None or ls == 0:
        return
    self.reverse(s, 0, ls)
    for i in range(ls + 1):
        if i == ls or s[i] == " ":
            self.reverse(s, pos, i)
            pos = i + 1

    def reverse(self, array_s, begin, end):
    for i in range((end - begin) / 2):
        array_s[begin + i], array_s[end - i - 1] = (
            array_s[end - i - 1],
            array_s[begin + i],
        )


class Solution(object):

    def hammingWeight(self, n):

    count = 0
    while n:
        n &= n - 1
        count += 1
    return count


class Solution(object):

    def rob(self, nums):
    prevMax = currMax = 0
    for num in nums:
        temp = currMax
        currMax = max(prevMax + num, currMax)
        prevMax = temp
    return currMax


class Solution(object):
    def numIslands(self, grid):

    if grid is None or len(grid) == 0:
        return 0
    islands = 0
    for i in range(len(grid)):
        for j in range(len(grid[i])):
            if grid[i][j] == "1":
                self.explore(grid, i, j)
                islands += 1
    return islands

    def explore(self, grid, i, j):
    grid[i][j] = "X"
    if i - 1 >= 0 and grid[i - 1][j] == "1":
        self.explore(grid, i - 1, j)
    if j - 1 >= 0 and grid[i][j - 1] == "1":
        self.explore(grid, i, j - 1)
    if i + 1 < len(grid) and grid[i + 1][j] == "1":
        self.explore(grid, i + 1, j)
    if j + 1 < len(grid[i]) and grid[i][j + 1] == "1":
        self.explore(grid, i, j + 1)


class Solution(object):
    def isHappy(self, n):

    seen_numbers = set()
    while n > 1 and n not in seen_numbers:
        seen_numbers.add(n)
        n = sum(map(lambda x: int(x) * int(x), list(str(n))))
    return n == 1


class Solution(object):
    def removeElements(self, head, val):

    prehead = ListNode(-1)
    prehead.next = head
    last, pos = prehead, head
    while pos is not None:
        if pos.val == val:
            last.next = pos.next
        else:
            last = pos
        pos = pos.next
    return prehead.next


class Solution(object):
    def countPrimes(self, n):

    isPrime = [True] * n
    for i in xrange(2, n):
        if i * i >= n:
            break
        if not isPrime[i]:
            continue
        for j in xrange(i * i, n, i):
            isPrime[j] = False
    count = 0
    for i in xrange(2, n):
        if isPrime[i]:
            count += 1
    return count


class Solution(object):

    def isIsomorphic(self, s, t):
    if len(s) != len(t):
        return False
    ls = len(s)
    mapStoT = [0] * 127
    mapTtoS = [0] * 127
    for i in range(ls):
        s_num, t_num = ord(s[i]), ord(t[i])
        if mapStoT[s_num] == 0 and mapTtoS[t_num] == 0:
            mapStoT[s_num] = t_num
            mapTtoS[t_num] = s_num
        elif mapTtoS[t_num] != s_num or mapStoT[s_num] != t_num:
            return False
    return True


class Solution(object):

    def reverseList(self, head):

    if head is None or head.next is None:
        return head
    p = self.reverseList(head.next)
    head.next.next = head
    head.next = None
    return p


class TrieNode(object):

    def __init__(self):

    self.links = [None] * 26
    self.isEnd = False

    def containsKey(self, ch):
    return self.links[ord(ch) - ord("a")] != None

    def get(self, ch):
    return self.links[ord(ch) - ord("a")]

    def put(self, ch, node):
    self.links[ord(ch) - ord("a")] = node

    def setEnd(self):
    self.isEnd = True


class Trie(object):
    def __init__(self):
    self.root = TrieNode()

    def insert(self, word):

    node = self.root
    for i in range(len(word)):
        ch = word[i]
        if node.containsKey(ch) is False:
            node.put(ch, TrieNode())
        node = node.get(ch)
    node.setEnd()

    def searchPrefix(self, word):
    node = self.root
    for i in range(len(word)):
        ch = word[i]
        if node.containsKey(ch):
            node = node.get(ch)
        else:
            return None
    return node

    def search(self, word):

    node = self.searchPrefix(word)
    return node is not None and node.isEnd

    def startsWith(self, prefix):

    node = self.searchPrefix(prefix)
    return node is not None


class Solution(object):

    def rob(self, nums):
    if len(nums) == 1:
        return nums[0]
    return max(
        self.rob_helper(nums, 0, len(nums) - 2),
        self.rob_helper(nums, 1, len(nums) - 1),
    )

    def rob_helper(self, nums, low, high):
    prevMax = currMax = 0
    for index in range(low, high + 1):
        temp = currMax
        currMax = max(prevMax + nums[index], currMax)
        prevMax = temp
    return currMax


class Solution(object):

    def findKthLargest(self, nums, k):

    random.shuffle(nums)
    return self.quickSelection(nums, 0, len(nums) - 1, len(nums) - k)

    def quickSelection(self, nums, start, end, k):
    if start > end:
        return float("inf")
    pivot = nums[end]
    left = start
    for i in range(start, end):
        if nums[i] <= pivot:

            nums[left], nums[i] = nums[i], nums[left]
            left += 1
    nums[left], nums[end] = nums[end], nums[left]
    if left == k:
        return nums[left]
    elif left < k:
        return self.quickSelection(nums, left + 1, end, k)
    else:
        return self.quickSelection(nums, start, left - 1, k)


import itertools as it


class Solution(object):
    def combinationSum3(self, k, n):

        return list(it.ifilter(lambda x: sum(x) == n, list(it.combinations(range(1, 10), k))))


class Solution(object):
    def containsDuplicate(self, nums):

    return len(nums) != len(set(nums))


class Solution(object):

    def containsNearbyDuplicate(self, nums, k):

    check = set()
    for i in range(len(nums)):
        if i > k:
            check.remove(nums[i - k - 1])
        if nums[i] in check:
            return True
        else:
            check.add(nums[i])
    return False


from collections import OrderedDict


class Solution(object):
    def containsNearbyAlmostDuplicate(self, nums, k, t):

    buckets = {}
    for i, v in enumerate(nums):

        bucketNum, offset = (v / t, 1) if t else (v, 0)
        for idx in xrange(bucketNum - offset, bucketNum + offset + 1):
            if idx in buckets and abs(buckets[idx] - nums[i]) <= t:
                return True

        buckets[bucketNum] = nums[i]
        if len(buckets) > k:

            del buckets[nums[i - k] / t if t else nums[i - k]]

    return False


class Solution(object):

    def maximalSquare(self, matrix):

    if matrix is None or len(matrix) == 0:
        return 0
    rows, cols, res, prev = len(matrix), len(matrix[0]), 0, 0
    dp = [0] * (cols + 1)
    for i in range(1, rows + 1):
        for j in range(1, cols + 1):
            temp = dp[j]
            if matrix[i - 1][j - 1] == "1":
                dp[j] = min(dp[j - 1], dp[j], prev) + 1
                res = max(res, dp[j])
            else:
                dp[j] = 0
            prev = temp
    return res * res


class Solution(object):
    def computeArea(self, A, B, C, D, E, F, G, H):

    result = (C - A) * (D - B) + (G - E) * (H - F)

    if C <= E or G <= A or H <= B or D <= F:
        return result

    dx = min(C, G) - max(A, E)

    dy = min(D, H) - max(B, F)
    return result - dx * dy


class Stack(object):
    def __init__(self):

    self.queue1 = []
    self.queue2 = []
    self.curr_top = 0

    def push(self, x):

    self.queue2.append(x)
    self.curr_top = x
    while len(self.queue1):
        self.queue2.append(self.queue1.pop(0))
    temp = self.queue2
    self.queue2 = self.queue1
    self.queue1 = temp

    def pop(self):

    self.queue1.pop(0)
    if len(self.queue1):
        self.curr_top = self.queue1[0]

    def top(self):

    if self.empty() is False:
        return self.curr_top

    def empty(self):

    return len(self.queue1) == 0


class Solution(object):

    def invertTree(self, root):

    if root is None:
        return None
    queue = [root]
    while len(queue):
        curr = queue.pop(0)
        curr.left, curr.right = curr.right, curr.left
        if curr.left is not None:
            queue.append(curr.left)
        if curr.right is not None:
            queue.append(curr.right)
    return root


class Solution(object):

    def summaryRanges(self, nums):
    res = []
    start, ls = 0, len(nums)
    for i in range(ls):
        if i + 1 < ls and nums[i + 1] == nums[i] + 1:
            continue
        if i == start:
            res.append(str(nums[start]))
        else:
            res.append("%d->%d" % (nums[start], nums[i]))
        start = i + 1
    return res


class Solution(object):
    def majorityElement(self, nums):

    ls = len(nums)
    res = []
    check_value = []
    for i in range(ls):
        if nums[i] in check_value:
            continue
        count = 1
        for j in range(i + 1, ls):
            if nums[i] == nums[j]:
                count += 1
        if count > ls / 3:
            res.append(nums[i])
        check_value.append(nums[i])
    return res


class Solution(object):
    def isPowerOfTwo(self, n):

    if n < 0:
        return False
    bin_str = bin(n)
    return sum(map(lambda x: int(x), list(bin_str[2:]))) == 1


class Queue(object):
    def __init__(self):

    self.stack1 = []
    self.stack2 = []

    def push(self, x):

    self.stack1.append(x)

    def pop(self):

    if len(self.stack2) == 0:
        while len(self.stack1):
            curr = self.stack1.pop()
            self.stack2.append(curr)
    self.stack2.pop()

    def peek(self):

    if len(self.stack2) == 0:
        while len(self.stack1):
            curr = self.stack1.pop()
            self.stack2.append(curr)
    return self.stack2[-1]

    def empty(self):

    return len(self.stack1) + len(self.stack2) == 0


class Solution(object):

    def isPalindrome(self, head):

    if head is None:
        return True
    p1, p2 = head, head
    p3, pre = p1.next, p1
    while p2.next is not None and p2.next.next is not None:
        p2 = p2.next.next
        pre = p1
        p1 = p3
        p3 = p3.next
        p1.next = pre
    if p2.next is None:
        p1 = p1.next

    while p3 is not None:
        if p1.val != p3.val:
            return False
        p1 = p1.next
        p3 = p3.next
    return True


class Solution(object):

    def lowestCommonAncestor(self, root, p, q):

    if p is None or q is None or root is None:
        return None
    if p.val < root.val and q.val < root.val:
        return self.lowestCommonAncestor(root.left, p, q)
    elif p.val > root.val and q.val > root.val:
        return self.lowestCommonAncestor(root.right, p, q)
    else:
        return root


class Solution(object):

    def lowestCommonAncestor(self, root, p, q):

    stack = [root]

    parent = {root: None}

    while p not in parent or q not in parent:

        node = stack.pop()

        if node.left:
            parent[node.left] = node
            stack.append(node.left)
        if node.right:
            parent[node.right] = node
            stack.append(node.right)

    ancestors = set()

    while p:
        ancestors.add(p)
        p = parent[p]

    while q not in ancestors:
        q = parent[q]
    return q


class Solution(object):
    def deleteNode(self, node):

    node.val = node.next.val
    node.next = node.next.next


class Solution(object):
    def productExceptSelf(self, nums):

    ans = [1] * len(nums)
    for i in range(1, len(nums)):
        ans[i] = ans[i - 1] * nums[i - 1]
    right = 1
    for i in range(len(nums) - 1, -1, -1):
        ans[i] *= right
        right *= nums[i]
    return ans


class Solution(object):

    def isAnagram(self, s, t):

    if len(s) != len(t):
        return False
    counter = [0] * 26
    for i in range(len(s)):
        counter[ord(s[i]) - ord("a")] += 1
        counter[ord(t[i]) - ord("a")] -= 1
    for num in counter:
        if num != 0:
            return False
    return True


class Solution(object):

    def shortestDistance(self, words, word1, word2):
    index1 = index2 = -1
    res = len(words)
    for index, word in enumerate(words):
        if word1 == word:
            index1 = index
        elif word2 == word:
            index2 = index
        if index1 != -1 and index2 != -1:
            res = min(res, abs(index1 - index2))
    return res


class Solution(object):
    def isStrobogrammatic(self, num):

    dic = {"0": "0", "6": "9", "9": "6", "1": "1", "8": "8"}
    temp_s = ""
    for c in num[::-1]:
        if c not in dic:
            return False
        temp_s += dic[c]
    if int(temp_s) == int(num):
        return True
    return False


class Solution(object):
    def groupStrings(self, strings):

    dic = {}
    for s in strings:
        key = self.hashCode(s)
        try:
            dic[key].append(s)
        except KeyError:
            dic[key] = [s]
    return dic.values()

    def hashCode(self, string):
    if string is None or len(string) == 0:
        return ""
    if len(string) == 1:
        return "a"
    step = abs(ord(string[0]) - ord("a"))
    if step == 0:
        return string
    key = "a"
    for ch in string[1:]:
        curr = ord(ch) - step
        if ord(ch) - step < ord("a"):
            curr += 26
        key += chr(curr)
    return key


class Solution(object):

    def canAttendMeetings(self, intervals):
    intervals.sort(key=lambda x: x.start)
    ls = len(intervals)
    for i in range(ls - 1):
        if intervals[i].end > intervals[i + 1].start:
            return False
    return True


class Solution(object):
    def minMeetingRooms(self, intervals):

    timeline = []
    for interval in intervals:

        timeline.append((interval.start, 1))

        timeline.append((interval.end, -1))

    timeline.sort()
    ans = curr = 0

    for _, v in timeline:
        curr += v

        ans = max(ans, curr)
    return ans


class Solution:

    def binaryTreePaths(self, root):
    if root is None:
        return []
    paths = []
    self.get_path(paths, [], root)
    res = ["->".join(p) for p in paths]
    return res

    def get_path(self, result, path, node):
    if node.left is None and node.right is None:
        result.append(path + [str(node.val)])
        return
    path = path + [str(node.val)]
    if node.left is not None:
        self.get_path(result, path, node.left)
    if node.right is not None:
        self.get_path(result, path, node.right)


class Solution(object):
    def addDigits(self, num):

    if num < 10:
        return num
    return num - ((num - 1) / 9) * 9


class Solution(object):

    def threeSumSmaller(self, nums, target):

    nums.sort()
    ls = len(nums)
    res = 0
    for i in range(ls - 1):
        res += self.twoSumSmaller(nums, i + 1, target - nums[i])
    return res

    def twoSumSmaller(self, nums, start, target):
    res, left, right = 0, start, len(nums) - 1
    while left < right:
        if nums[left] + nums[right] < target:
            res += right - left
            left += 1
        else:
            right -= 1
    return res


class Solution(object):

    def isUgly(self, num):
    if num <= 0:
        return False
    divisors = [2, 3, 5]
    for d in divisors:
        while num % d == 0:
            num /= d
    return num == 1


if __name__ == "__main__":
    s = Solution()
    print s.isUgly(-2147483648)


class Solution(object):
    def nthUglyNumber(self, n):

    if n <= 5:
        return n
    dp = [0] * (n + 1)
    l1 = l2 = l3 = 1
    dp[1] = 1
    dp[2] = 2
    dp[3] = 3
    dp[4] = 4
    dp[5] = 5
    for i in range(6, n + 1):
        while dp[l1] * 2 <= dp[i - 1]:
            l1 += 1
        while dp[l2] * 3 <= dp[i - 1]:
            l2 += 1
        while dp[l3] * 5 <= dp[i - 1]:
            l3 += 1
        print l1, l2, l3
        dp[i] = min(dp[l1] * 2, dp[l2] * 3, dp[l3] * 5)

    return dp[n]


if __name__ == "__main__":

    s = Solution()
    print s.nthUglyNumber(10)


class Solution(object):
    def canPermutePalindrome(self, s):

    dic = {}
    for c in s:
        dic[c] = dic.get(c, 0) + 1
    odd, even = 0, 0
    for c in dic:
        if dic[c] % 2 == 0:
            even += 1
        else:
            odd += 1
    if odd <= 1:
        return True
    return False


class Solution(object):
    def generatePalindromes(self, s):

    dic = {}
    half = []
    res = []
    for c in s:
        dic[c] = dic.get(c, 0) + 1
    odd, even = 0, 0
    for c in dic:
        if dic[c] % 2 == 0:
            even += 1
        else:
            odd += 1
    if odd > 1:
        return []

    seed = []
    mid = ""
    for c in dic:
        if dic[c] % 2 == 1:
            mid = c
        seed.extend([c] * (dic[c] / 2))
    self.permute(half, seed, 0)

    for r in half:
        res.append("".join(r) + mid + "".join(reversed(r)))
    return res

    def permute(self, res, num, index):
    if index == len(num):
        res.append(list(num))
        return
    appeared = set()
    for i in range(index, len(num)):
        if num[i] in appeared:
            continue
        appeared.add(num[i])
        num[i], num[index] = num[index], num[i]
        self.permute(res, num, index + 1)
        num[i], num[index] = num[index], num[i]


class Solution(object):

    def missingNumber(self, nums):
    res = len(nums)
    for i, v in enumerate(nums):
        res ^= i
        res ^= v
    return res


class Solution(object):

    def closestValue(self, root, target):

    kid = root.left if target < root.val else root.right
    if not kid:
        return root.val
    kid_min = self.closestValue(kid, target)
    return min((kid_min, root.val), key=lambda x: abs(target - x))


class Solution(object):
    def numberToWords(self, num):

    to19 = (
        "One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve "
        "Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen".split()
    )
    tens = "Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety".split()

    def words(n):
        if n < 20:
            return to19[n - 1: n]
        if n < 100:
            return [tens[n / 10 - 2]] + words(n % 10)
        if n < 1000:
            return [to19[n / 100 - 1]] + ["Hundred"] + words(n % 100)
        for p, w in enumerate(("Thousand", "Million", "Billion"), 1):
            if n < 1000 ** (p + 1):
                return words(n / 1000 ** p) + [w] + words(n % 1000 ** p)

    return " ".join(words(num)) or "Zero"


class Solution(object):

    def hIndex(self, citations):

    ls = len(citations)
    papers = [0] * (ls + 1)
    for c in citations:
        papers[min(ls, c)] += 1
    k, s = ls, papers[ls]
    while k > s:
        k -= 1
        s += papers[k]
    return k


class Solution(object):

    def numWays(self, n, k):
    if n == 0:
        return 0
    elif n == 1:
        return k

    dp = [0] * 2
    dp[0] = k
    dp[1] = k * k
    for i in range(2, n):
        temp = dp[1]
        dp[1] = sum(dp) * (k - 1)
        dp[0] = temp
    return dp[1]


class Solution(object):
    def firstBadVersion(self, n):

    left, right = 1, n
    while left < right:
        mid = (right + left) / 2
        if isBadVersion(mid):
            right = mid
        else:
            left = mid + 1
    return left


class Solution(object):

    def wiggleSort(self, nums):
    for i in range(len(nums) - 1):
        if (i % 2 == 0 and nums[i] > nums[i + 1]) or (
            i % 2 == 1 and nums[i] < nums[i + 1]
        ):
            nums[i], nums[i + 1] = nums[i + 1], nums[i]


class Solution(object):

    def moveZeroes(self, nums):

    ls = len(nums)
    n_pos = 0
    for i in range(ls):
        if nums[i] != 0:
            temp = nums[n_pos]
            nums[n_pos] = nums[i]
            nums[i] = temp
            n_pos += 1


class Solution(object):
    def wallsAndGates(self, rooms):

    direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    m = len(rooms)
    if m == 0:
        return
    n = len(rooms[0])
    q = []
    for row in range(m):
        for col in range(n):

            if rooms[row][col] == 0:
                q.append((row, col))

    while len(q) > 0:
        point = q.pop(0)
        row, col = point[0], point[1]
        for d in direction:
            r = row + d[0]
            c = col + d[1]

            if r < 0 or c < 0 or r >= m or c >= n or rooms[r][c] != 2147483647:
                continue
            rooms[r][c] = rooms[row][col] + 1
            q.append((r, c))


class ValidWordAbbr(object):
    def __init__(self, dictionary):

    self.dictionary = set(dictionary)
    self.abb_dic = {}
    for s in self.dictionary:
        curr = self.getAbb(s)
        if curr in self.abb_dic:
            self.abb_dic[curr] = False
        else:
            self.abb_dic[curr] = True

    def isUnique(self, word):

    abb = self.getAbb(word)
    hasAbbr = self.abb_dic.get(abb, None)
    return hasAbbr == None or (hasAbbr and word in self.dictionary)

    def getAbb(self, word):
    if len(word) <= 2:
        return word
    return word[0] + str(len(word) - 2) + word[-1]


class Solution(object):
    def wordPattern(self, pattern, str):

    if pattern is None or str is None:
        return True

    words_to_pattern = {}
    pattern_to_words = {}
    word_list = str.split(" ")
    if len(word_list) != len(pattern):
        return False
    for index, word in enumerate(word_list):
        curr_p = pattern[index]
        if (
            pattern_to_words.get(curr_p, word) != word
            or words_to_pattern.get(word, curr_p) != curr_p
        ):
            return False
        pattern_to_words[curr_p] = pattern_to_words.get(curr_p, word)
        words_to_pattern[word] = words_to_pattern.get(word, curr_p)
    return True


class Solution(object):
    def canWinNim(self, n):

    return n % 4 != 0


class Solution(object):
    def generatePossibleNextMoves(self, s):

    res = []
    if s is None or len(s) == 0:
        return res
    ls = len(s)
    for i in range(ls - 1):
        if s[i] == "+" and s[i + 1] == "+":
            res.append(s[:i] + "--" + s[i + 2:])
    return res


class Solution(object):

    def canWin(self, s):
    if s is None or len(s) < 2:
        return False
    list_s = list(s)
    return self.canWin_helper(list_s)

    def canWin_helper(self, s):
    for i in range(len(s) - 1):
        if s[i] == "+" and s[i + 1] == "+":
            s[i] = "-"
            s[i + 1] = "-"
            res = self.canWin_helper(s)
            s[i] = "+"
            s[i + 1] = "+"
            if not res:
                return True
    return False


if __name__ == "__main__":
    s = Solution()
    print s.canWin("++++")


class Solution(object):

    def minDistance1D(self, points):

    distance = 0
    i, j = 0, len(points) - 1
    while i < j:
        distance += points[j] - points[i]
        i += 1
        j -= 1
    return distance

    def minTotalDistance(self, grid):
    rows = self.collectRows(grid)
    cols = self.collectCols(grid)
    row = rows[len(rows) / 2]
    col = cols[len(cols) / 2]
    return self.minDistance1D(rows) + self.minDistance1D(cols)

    def collectRows(self, grid):
    rows = []
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                rows.append(i)
    return rows

    def collectCols(self, grid):
    cols = []
    for j in range(len(grid[0])):
        for i in range(len(grid)):
            if grid[i][j] == 1:
                cols.append(j)
    return cols


class Solution(object):
    def longestConsecutive(self, root):

    return self.longestConsecutive_helper(root, -10000, 1)

    def longestConsecutive_helper(self, root, previous, curr):

    if root is None:
        return 0
    if root.val - 1 == previous:
        curr += 1
    else:
        curr = 1
    l_res = self.longestConsecutive_helper(root.left, root.val, curr)
    r_res = self.longestConsecutive_helper(root.right, root.val, curr)
    return max(curr, l_res, r_res)


class Solution(object):
    def getHint(self, secret, guess):

    check = {}
    ls = len(secret)
    bull, cow = 0, 0
    different = []
    for i in range(ls):
        if guess[i] == secret[i]:
            bull += 1
        else:

            different.append(i)
            try:
                check[secret[i]] += 1
            except KeyError:
                check[secret[i]] = 1
    for i in different:
        try:
            if check[guess[i]] > 0:
                cow += 1
                check[guess[i]] -= 1
        except:
            pass
    return "%dA%dB" % (bull, cow)


if __name__ == "__main__":
    s = Solution()
    print s.getHint("1122", "1222")


class NumArray(object):
    def __init__(self, nums):

    self.res = [0] * (len(nums) + 1)
    self.data = list(nums)
    for i in range(len(self.data)):
        self.res[i + 1] = self.res[i] + nums[i]

    def sumRange(self, i, j):

    return self.res[j + 1] - self.res[i]


class NumMatrix(object):

    def __init__(self, matrix):

    if matrix is None or len(matrix) == 0:
        return
    height, width = len(matrix), len(matrix[0])
    self.dp = [[0] * (width + 1) for i in range(height + 1)]
    for i in range(height):
        for j in range(width):
            self.dp[i + 1][j + 1] = (
                self.dp[i + 1][j] + self.dp[i][j + 1] +
                matrix[i][j] - self.dp[i][j]
            )

    def sumRegion(self, row1, col1, row2, col2):

    return (
        self.dp[row2 + 1][col2 + 1]
        - self.dp[row1][col2 + 1]
        - self.dp[row2 + 1][col1]
        + self.dp[row1][col1]
    )


class Solution(object):
    def numIslands2(self, m, n, positions):

    ans = []
    islands = Union()
    for p in map(tuple, positions):
        islands.add(p)
        for dp in (0, 1), (0, -1), (1, 0), (-1, 0):
            q = (p[0] + dp[0], p[1] + dp[1])
            if q in islands.id:
                islands.unite(p, q)
        ans += [islands.count]
    return ans


class Union(object):

    def __init__(self):

    self.id = {}
    self.sz = {}
    self.count = 0

    def add(self, p):
    self.id[p] = p
    self.sz[p] = 1
    self.count += 1

    def root(self, i):
    while i != self.id[i]:
        self.id[i] = self.id[self.id[i]]
        i = self.id[i]
    return i

    def unite(self, p, q):
    i, j = self.root(p), self.root(q)
    if i == j:
        return
    if self.sz[i] > self.sz[j]:
        i, j = j, i
    self.id[i] = j
    self.sz[j] += self.sz[i]
    self.count -= 1


class NumArray(object):
    def __init__(self, nums):

    self.ls = len(nums)
    self.tree = [0] * (self.ls * 2)
    self.buildTree(nums)

    def buildTree(self, nums):
    i, j = self.ls, 0
    while i < 2 * self.ls:
        self.tree[i] = nums[j]
        i += 1
        j += 1
    for i in reversed(range(1, self.ls)):
        self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1]

    def update(self, i, val):

    i += self.ls
    self.tree[i] = val
    while i > 0:
        left = right = i
        if i % 2 == 0:
            right = i + 1
        else:
            left = i - 1
        self.tree[i / 2] = self.tree[left] + self.tree[right]
        i /= 2

    def sumRange(self, i, j):

    res = 0
    i += self.ls
    j += self.ls

    while i <= j:
        if i % 2 == 1:
            res += self.tree[i]
            i += 1
        if j % 2 == 0:
            res += self.tree[j]
            j -= 1
        i /= 2
        j /= 2
    return res


class Solution(object):

    def coinChange(self, coins, amount):

    if amount == 0:
        return 0
    if coins is None or len(coins) == 0:
        return -1
    coins.sort()
    dp = [1000000000] * (amount + 1)
    for i in range(1, amount + 1):
        for coin in coins:
            if i == coin:
                dp[i] = 1
                break
            elif i > coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    if dp[amount] == 1000000000:
        return -1
    return dp[amount]


class Solution(object):

    def isPowerOfThree(self, n):
    max3pow = 1162261467
    if n <= 0 or n > max3pow:
        return False
    return max3pow % n == 0


class Solution(object):
    def oddEvenList(self, head):

    odd = head
    if head is None:
        return None
    if head.next is None:
        return head
    even_head = even = head.next
    while odd.next is not None and even.next is not None:
        odd.next = even.next
        odd = odd.next
        even.next = odd.next
        even = even.next
    odd.next = even_head
    return head


class Solution(object):
    def palindromePairs(self, words):

    word2index, res = dict([(w[::-1], i) for i, w in enumerate(words)]), []
    for i, word in enumerate(words):
        for j in xrange(len(word) + 1):

            prefix, postfix = word[:j], word[j:]

            if (
                prefix in word2index
                and i != word2index[prefix]
                and postfix == postfix[::-1]
            ):
                res.append([i, word2index[prefix]])

            if (
                j > 0
                and postfix in word2index
                and i != word2index[postfix]
                and prefix == prefix[::-1]
            ):
                res.append([word2index[postfix], i])
    return res


class Solution(object):

    def rob(self, root):

    res = self.rob_helper(root)
    return max(res[0], res[1])

    def rob_helper(self, root):
    if root is None:
        return [0, 0]
    left = self.rob_helper(root.left)
    right = self.rob_helper(root.right)
    res = [0, 0]
    res[0] = max(left[0], left[1]) + max(right[0], right[1])
    res[1] = root.val + left[0] + right[0]
    return res


class Solution(object):
    def countBits(self, num):

    res = [0] * (num + 1)
    for i in range(1, num + 1):

        res[i] = res[i >> 1] + (i & 1)
    return res


class Solution(object):
    def depthSum(self, nestedList):

    return self.depthSum_helper(nestedList, 1)

    def depthSum_helper(self, nestedList, depth):
    res = 0
    for l in nestedList:
        if l.isInteger():
            res += l.getInteger() * depth
        else:
            res += self.depthSum_helper(l.getList(), depth + 1)
    return res


class Solution(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):

    count = [0] * 256
    i, numDistinct, maxLen = 0, 0, 0
    for j in range(len(s)):

        if count[ord(s[j])] == 0:
            numDistinct += 1
        count[ord(s[j])] += 1

        while numDistinct > k:
            count[ord(s[i])] -= 1
            if count[ord(s[i])] == 0:
                numDistinct -= 1
            i += 1
        maxLen = max(j - i + 1, maxLen)
    return maxLen


class Solution(object):
    def isPowerOfFour(self, num):

    return num > 0 and num & (num - 1) == 0 and len(bin(num)[3:]) % 2 == 0


class Solution(object):
    def reverseString(self, s):

    return s[::-1]


class Solution(object):
    def reverseVowels(self, s):

    str_index = []
    vowel = []
    res = []
    pos = -1
    for index, value in enumerate(s):
        if value in "aeiouAEIOU":
            str_index.append(-1)
            vowel.append(value)
        else:
            str_index.append(index)
    for index in str_index:
        if index < 0:
            res.append(vowel[pos])
            pos -= 1
        else:
            res.append(s[index])
    return "".join(res)


class MovingAverage(object):
    def __init__(self, size):

    self.size = size
    self.curr_range = []

    def next(self, val):

    if len(self.curr_range) == self.size:
        self.curr_range.pop(0)
    self.curr_range.append(val)
    return sum(self.curr_range) * 1.0 / len(self.curr_range)


class Solution(object):
    def topKFrequent(self, nums, k):

    counter = collections.Counter(nums)
    return [k for k, v in counter.most_common(k)]


class Solution(object):
    def intersection(self, nums1, nums2):

    return list(set(nums1) & set(nums2))


class Solution(object):
    def intersect(self, nums1, nums2):

    nums1.sort()
    nums2.sort()
    res = []
    pos1 = pos2 = 0
    while pos1 < len(nums1) and pos2 < len(nums2):
        if nums1[pos1] == nums2[pos2]:
            res.append(nums1[pos1])
            pos1 += 1
            pos2 += 1
        elif nums1[pos1] < nums2[pos2]:
            pos1 += 1
        else:
            pos2 += 1
    return res


class Solution(object):
    def numberOfPatterns(self, m, n):

    used = [False] * 9
    res = 0
    for l in range(m, n + 1):
        res += self.calc_patterns(used, -1, l)
        used = [False] * 9
    return res

    def is_valid(self, used, index, last):

    if used[index]:
        return False

    if last == -1:
        return True

    if (last + index) % 2 == 1:
        return True
    mid = (last + index) / 2
    if mid == 4:
        return used[mid]

    if (index % 3 != last % 3) and (index / 3 != last / 3):
        return True

    return used[mid]

    def calc_patterns(self, used, last, length):
    if length == 0:
        return 1
    res = 0
    for i in range(9):
        if self.is_valid(used, i, last):
            used[i] = True
            res += self.calc_patterns(used, i, length - 1)
            used[i] = False
    return res


import heapq


class Logger(object):
    def __init__(self):

    self.heap = []
    self.cache = {}

    def shouldPrintMessage(self, timestamp, message):

    while len(self.heap):
        if self.heap[0][0] <= timestamp:
            temp = heapq.heappop(self.heap)
            self.cache.pop(temp[1])
        else:
            break
    if timestamp < self.cache.get(message, 0):
        return False
    self.cache[message] = timestamp + 10
    heapq.heappush(self.heap, (timestamp + 10, message))
    return True


class Solution(object):

    def findLeaves(self, root):
    res = []
    self.findLeaves_helper(root, res)
    return res

    def findLeaves_helper(self, node, res):
    if node is None:
        return -1
    level = 1 + max(
        self.findLeaves_helper(node.left, res),
        self.findLeaves_helper(node.right, res),
    )
    if len(res) < level + 1:
        res.append([])
    res[level].append(node.val)
    return level


class Solution(object):

    def isPerfectSquare(self, num):
    low, high = 1, num
    while low <= high:
        mid = (low + high) / 2
        mid_square = mid * mid
        if mid_square == num:
            return True
        elif mid_square < num:
            low = mid + 1
        else:
            high = mid - 1
    return False


class Solution(object):

    def largestDivisibleSubset(self, nums):
    ls = len(nums)
    S = {-1: set()}
    for num in sorted(nums):
        candicate = []
        for key in S:
            if num % key == 0:
                candicate.append(S[key])

        S[num] = max(candicate, key=len) | {num}
    return


class Solution(object):
    def plusOne(self, head):

    dummy = ListNode(0)
    dummy.next = head
    place_stop, tail = dummy, dummy

    while tail.next is not None:
        tail = tail.next
        if tail.val != 9:
            place_stop = tail
    if tail.val != 9:

        tail.val += 1
    else:

        place_stop.val += 1
        place_stop = place_stop.next

        while place_stop is not None:
            place_stop.val = 0
            place_stop = place_stop.next
    if dummy.val == 0:
        return dummy.next
    return dummy


class Solution(object):
    def getModifiedArray(self, length, updates):

    res = [0] * length

    for t in updates:
        start, end, val = t
        res[start] += val
        if end < length - 1:
            res[end + 1] -= val

    for i in range(1, length):
        res[i] = res[i] + res[i - 1]
    return res


class Solution(object):
    def getSum(self, a, b):

    import ctypes

    sum = 0
    carry = ctypes.c_int32(b)
    while carry.value != 0:
        sum = a ^ carry.value
        carry = ctypes.c_int32(a & carry.value)
        carry.value <<= 1
        a = sum
    return sum


class Solution(object):
    def __init__(self):
    self.base = 1337

    def superPow(self, a, b):

    if b is None or len(b) == 0:
        return 1
    last_digit = b.pop()
    return (
        self.powmod(self.superPow(a, b), 10)
        * self.powmod(a, last_digit)
        % self.base
    )

    def powmod(self, a, k):
    a %= self.base
    result = 1
    for i in range(k):
        result = (result * a) % self.base
    return result


class Solution(object):
    def kSmallestPairs(self, nums1, nums2, k):

    queue = []

    def push(i, j):
        if i < len(nums1) and j < len(nums2):
            heapq.heappush(queue, [nums1[i] + nums2[j], i, j])

    push(0, 0)
    pairs = []
    while queue and len(pairs) < k:
        _, i, j = heapq.heappop(queue)
        pairs.append([nums1[i], nums2[j]])
        push(i, j + 1)
        if j == 0:
            push(i + 1, 0)
    return pairs


class Solution(object):
    def guessNumber(self, n):

    begin, end = 1, n
    while begin <= end:
        mid = (begin + end) / 2
        res = guess(mid)
        if res == 0:
            return mid
        elif res > 0:
            begin = mid + 1
        else:
            end = mid - 1


class Solution(object):

    def getMoneyAmount(self, n):

    dp = [[0] * (n + 1) for _ in range(n + 1)]
    for j in range(2, n + 1):
        for i in range(j - 1, 0, -1):
            globalMin = sys.maxint
            for k in range(i + 1, j):
                localMax = k + max(dp[i][k - 1], dp[k + 1][j])
                globalMin = min(globalMin, localMax)
            if i + 1 == j:
                dp[i][j] = i
            else:
                dp[i][j] = globalMin
    return dp[1][n]


class Solution(object):
    def canConstruct(self, ransomNote, magazine):

    letter_map = {}
    for letter in magazine:
        letter_map[letter] = letter_map.get(letter, 0) + 1
    for letter in ransomNote:
        letter_map[letter] = letter_map.get(letter, 0) - 1
        if letter_map[letter] < 0:
            return False
    return True


import random


class Solution(object):
    def __init__(self, nums):

    self.origin = list(nums)
    self.curr = list(nums)
    self.size = len(nums)

    def reset(self):

    self.curr = list(self.origin)
    return self.curr

    def shuffle(self):

    for i in range(self.size):
        pos = random.randint(0, i)

        self.curr[i], self.curr[pos] = self.curr[pos], self.curr[i]
    return self.curr


class Solution(object):
    def firstUniqChar(self, s):

    count_map = {}
    for c in s:
        count_map[c] = count_map.get(c, 0) + 1
    for i, c in enumerate(s):
        if count_map[c] == 1:
            return i
    return -1


class Solution(object):
    def lengthLongestPath(self, input):

    if input is None or len(input) == 0:
        return 0
    lines = input.split("\n")
    last_level_len = [0] * (len(lines) + 1)
    max_len = 0
    for line in lines:
        try:
            level = line.rindex("\t") + 1
        except:
            level = 0
        cur_len = last_level_len[level + 1] = (
            last_level_len[level] + len(line) - level + 1
        )
        if "." in line:
            max_len = max(max_len, cur_len - 1)
    return max_len


if __name__ == "__main__":
    s = Solution()
    print s.lengthLongestPath("dir\n    file.txt")


class Solution(object):
    def findTheDifference(self, s, t):

    res = ord(t[-1])
    for i in range(len(s)):
        res += ord(t[i])
        res -= ord(s[i])
    return chr(res)


class Solution(object):
    def readBinaryWatch(self, num):

    return [
        "%d:%02d" % (h, m)
        for h in range(12)
        for m in range(60)
        if (bin(h) + bin(m)).count("1") == num
    ]


class Solution(object):

    def sumOfLeftLeaves(self, root):
    stack = [root]
    res = 0
    while len(stack) > 0:
        curr = stack.pop(0)
        if curr is not None:
            if curr.left is not None:
                if curr.left.left is None and curr.left.right is None:
                    res += curr.left.val
            stack.insert(0, curr.right)
            stack.insert(0, curr.left)
    return res


class Solution(object):
    def toHex(self, num):

    if num == 0:
        return "0"

    mp = "0123456789abcdef"
    ans = ""
    for _ in range(8):

        n = num & 15

        c = mp[n]
        ans = c + ans

        num = num >> 4

    return ans.lstrip("0")


class Solution(object):

    def validWordAbbreviation(self, word, abbr):
    pos = curr = 0
    for i in range(len(abbr)):
        try:
            num = int(abbr[i])
            if num == 0 and curr == 0:
                return False
            curr = curr * 10 + num
        except ValueError:
            pos += curr
            curr = 0
            if pos >= len(word):
                return False
            if word[pos] != abbr[i]:
                return False
            pos += 1
    pos += curr
    if pos == len(word):
        return True
    return False


class Solution:

    def longestPalindrome(self, s):
    ans = 0
    char_map = {}
    for c in s:
        char_map[c] = char_map.get(c, 0) + 1
    for c in char_map.keys():
        if char_map[c] % 2 == 0:
            ans += char_map.pop(c)
        else:
            ans += char_map[c] / 2 * 2
    if len(char_map) != 0:
        ans += 1
    return ans


class Solution(object):

    def fizzBuzz(self, n):
    return [
        str(i) * (i % 3 != 0 and i % 5 != 0)
        + "Fizz" * (i % 3 == 0)
        + "Buzz" * (i % 5 == 0)
        for i in range(1, n + 1)
    ]


class Solution(object):
    def thirdMax(self, nums):

    import Queue

    pq = Queue.PriorityQueue(4)
    check = set()
    for n in nums:
        if n in check:
            continue
        pq.put(n)
        check.add(n)
        if len(check) > 3:
            check.remove(pq.get())
    total = len(check)
    while total < 3 and total > 1:
        total -= 1
    return pq.get()


class Solution(object):

    def addStrings(self, num1, num2):
    res = []
    pos1 = len(num1) - 1
    pos2 = len(num2) - 1
    carry = 0

    while pos1 >= 0 or pos2 >= 0 or carry == 1:
        digit1 = digit2 = 0
        if pos1 >= 0:
            digit1 = ord(num1[pos1]) - ord("0")
        if pos2 >= 0:
            digit2 = ord(num2[pos2]) - ord("0")
        res.append(str((digit1 + digit2 + carry) % 10))
        carry = (digit1 + digit2 + carry) / 10
        pos1 -= 1
        pos2 -= 1

    return "".join(res[::-1])


class Solution(object):

    def canPartition(self, nums):
    total_sum = sum(nums)
    if total_sum & 1:
        return False

    target = total_sum >> 1
    dp = [0] * (target + 1)
    dp[0] = 1
    for num in nums:
        for i in range(target, num - 1, -1):
            dp[i] = dp[i] | dp[i - num]
    return dp[target] == 1


class Solution(object):
    def findMaximumXOR(self, nums):

    answer = 0
    for i in range(32)[::-1]:
        answer <<= 1

        prefixes = {num >> i for num in nums}

        answer += any(answer ^ 1 ^ p in prefixes for p in prefixes)
    return answer


if __name__ == "__main__":
    s = Solution()
    s.findMaximumXOR([3, 10, 5, 25, 2, 8])


class Solution(object):
    def validWordSquare(self, words):

    if words is None or len(words) == 0:
        return True
    ls = len(words)
    for i in range(ls):
        for j in range(1, len(words[i])):
            if j >= ls:
                return False
            if i >= len(words[j]):
                return False
            if words[i][j] != words[j][i]:
                return False
    return True


class Solution(object):

    def pathSumHelper(self, root, target, so_far, cache):
    if root:

        complement = so_far + root.val - target
        if complement in cache:

            self.result += cache[complement]
        cache[so_far + root.val] = cache.get(so_far + root.val, 0) + 1
        self.pathSumHelper(root.left, target, so_far + root.val, cache)
        self.pathSumHelper(root.right, target, so_far + root.val, cache)
        cache[so_far + root.val] -= 1
    return

    def pathSum(self, root, sum):

    self.result = 0
    self.pathSumHelper(root, sum, 0, {0: 1})
    return self.result


class Solution(object):
    def findAnagrams(self, s, p):

    res = []
    if s is None or p is None or len(s) == 0 or len(p) == 0:
        return res
    char_map = [0] * 256
    for c in p:
        char_map[ord(c)] += 1
    left, right, count = 0, 0, len(p)
    while right < len(s):
        if char_map[ord(s[right])] >= 1:
            count -= 1
        char_map[ord(s[right])] -= 1
        right += 1
        if count == 0:
            res.append(left)
        if right - left == len(p):
            if char_map[ord(s[left])] >= 0:
                count += 1
            char_map[ord(s[left])] += 1
            left += 1
    return res


class Solution(object):
    def compress(self, chars):

    anchor = write = 0
    for read, c in enumerate(chars):
        if read + 1 == len(chars) or chars[read + 1] != c:
            chars[write] = chars[anchor]
            write += 1
            if read > anchor:
                for digit in str(read - anchor + 1):
                    chars[write] = digit
                    write += 1
            anchor = read + 1
    return write


class Solution(object):
    def findDisappearedNumbers(self, nums):

    res = []
    if nums:
        n = len(nums)
        for i in range(n):
            val = abs(nums[i]) - 1
            if nums[val] > 0:
                nums[val] = -nums[val]
        for i in range(n):
            if nums[i] > 0:
                res.append(i + 1)
    return res


class Solution(object):
    def minMoves(self, nums):

    if nums is None or len(nums) == 0:
        return 0
    min_num = min(nums)
    return sum([i - min_num for i in nums])


class Solution:
    def circularArrayLoop(self, nums: List[int]) -> bool:
    for i in range(len(nums)):
        if nums[i] == 0:
            continue

        slow = i
        fast = self.index(nums, slow)
        while (
            nums[slow] * nums[fast] > 0
            and nums[slow] * nums[self.index(nums, fast)] > 0
        ):
            if slow == fast and fast != self.index(nums, fast):
                return True
            elif slow == fast and fast == self.index(nums, fast):
                break
            slow = self.index(nums, slow)
            fast = self.index(nums, self.index(nums, fast))

        runner = i
        value = nums[runner]
        while nums[runner] * value > 0:
            temp = self.index(nums, runner)
            nums[runner] = 0
            runner = temp
    return False

    def index(self, nums, index):
    length = len(nums)
    return (index + nums[index] + length) % length


class Solution(object):
    def poorPigs(self, buckets, minutesToDie, minutesToTest):

    pigs = 0
    while (minutesToTest / minutesToDie + 1) ** pigs < buckets:
        pigs += 1
    return pigs


class Solution(object):
    def hammingDistance(self, x, y):

    return bin(x ^ y).count("1")


class Solution(object):
    def islandPerimeter(self, grid):

    row_num = len(grid)
    if row_num == 0 | | len(grid[0]) == 0:
        return 0
    islands, overlaps = 0, 0
    col_num = len(grid[0])
    for i in range(row_num):
        for j in range(col_num):
            if (grid[i][j] == 1):
                islands += 1

                if (i < row_num - 1 & & grid[i + 1][j] == 1):
                    overlaps += 1
                if (j < col_num - 1 & & grid[i][j + 1] == 1):
                    overlaps += 1
    return islands * 4 - overlaps * 2


class Solution(object):
    def findRadius(self, houses, heaters):

    heaters = sorted(heaters) + [float("inf")]
    i = r = 0
    for x in sorted(houses):

        while x >= sum(heaters[i: i + 2]) / 2.0:
            i += 1

        r = max(r, abs(heaters[i] - x))
    return r


class Solution(object):

    def largestPalindrome(self, n):

    if n == 1:
        return 9
    for a in xrange(2, 9 * 10 ** (n - 1)):
        hi = (10 ** n) - a
        lo = int(str(hi)[::-1])
        if a ** 2 - 4 * lo < 0:
            continue
        if (a ** 2 - 4 * lo) ** 0.5 == int((a ** 2 - 4 * lo) ** 0.5):
            return (lo + 10 ** n * (10 ** n - a)) % 1337


class Solution(object):
    def licenseKeyFormatting(self, S, K):

    S = S.upper().replace("-", "")
    ls = len(S)
    if ls % K == 0:
        pos = K
    else:
        pos = ls % K
    res = S[:pos]
    while pos < ls:
        res += "-" + S[pos: pos + K]
        pos += K
    return res


class Solution(object):
    def findMaxConsecutiveOnes(self, nums):

    ans = 0
    curr = 0
    for n in nums:
        if n == 1:

            curr += 1
            if curr > ans:
                ans = curr
        else:

            curr = 0
    return ans


class Solution(object):
    def __init__(self):
    self.memo = []
    self.memo.append(0)
    self.memo.append(1)

    def fib(self, N):

    if N < len(self.memo):
        return self.memo[N]
    for i in range(len(self.memo), N + 1):
        self.memo.append(self.memo[i - 1] + self.memo[i - 2])
    return self.memo[N]


class Solution(object):

    def convertBST(self, root):
    total = 0

    node = root
    stack = []
    while stack or node is not None:

        while node is not None:
            stack.append(node)
            node = node.right

        node = stack.pop()
        total += node.val
        node.val = total

        node = node.left

    return root


class Solution:
    def reverseStr(self, s: str, k: int) -> str:
    N = len(s)
    ans = ""
    position = 0
    while position < N:
        nx = s[position: position + k]
        ans = ans + nx[::-1] + s[position + k: position + 2 * k]
        position += 2 * k
    return ans


s1 = Solution()
s = "abcdefg"
k = 2
print(s1.reverseStr(s, k))


class Solution(object):

    def diameterOfBinaryTree(self, root):
    self.ans = 1

    def depth(node):
        if not node:
            return 0
        L = depth(node.left)
        R = depth(node.right)
        self.ans = max(self.ans, L + R + 1)
        return max(L, R) + 1

    depth(root)

    return self.ans - 1


class Solution(object):
    def findCircleNum(self, M):

    visited = [0] * len(M)
    count = 0
    for i in range(len(M)):
        if visited[i] == 0:
            self.dfs(M, visited, i)
            count += 1
    return count

    def dfs(self, M, visited, i):
    for j in range(len(M)):
        if M[i][j] == 1 and visited[j] == 0:
            visited[j] = 1
            self.dfs(M, visited, j)


class Solution(object):
    def reverseWords(self, s):

    return " ".join([word[::-1] for word in s.split(" ")])


class Solution(object):
    def subarraySum(self, nums, k):

    sum_map = {}
    sum_map[0] = 1
    count = curr_sum = 0
    for num in nums:
        curr_sum += num

        count += sum_map.get(curr_sum - k, 0)

        sum_map[curr_sum] = sum_map.get(curr_sum, 0) + 1
    return count


class Solution(object):

    def isSubtree(self, s, t):

    s_res = self.preorder(s, True)
    t_res = self.preorder(t, True)
    return t_res in s_res

    def preorder(self, root, isLeft):
    if root is None:
        if isLeft:
            return "lnull"
        else:
            return "rnull"
    return (
        "#"
        + str(root.val)
        + " "
        + self.preorder(root.left, True)
        + " "
        + self.preorder(root.right, False)
    )


class Solution(object):

    def findUnsortedSubarray(self, nums):

    stack = []
    l, r = len(nums), 0
    for i in range(len(nums)):
        while len(stack) != 0 and nums[stack[-1]] > nums[i]:
            l = min(l, stack.pop())
        stack.append(i)
    stack = []
    for i in range(len(nums) - 1, -1, -1):
        while len(stack) != 0 and nums[stack[-1]] < nums[i]:
            r = max(r, stack.pop())
        stack.append(i)
    if r > l:
        return r - l + 1
    return 0


class Solution(object):
    def canPlaceFlowers(self, flowerbed, n):

    count = 0
    for i in range(len(flowerbed)):
        curr = flowerbed[i]
        if i - 1 >= 0:
            curr += flowerbed[i - 1]
        if i + 1 < len(flowerbed):
            curr += flowerbed[i + 1]
        if curr == 0:
            count += 1
            flowerbed[i] = 1
            if count >= n:
                return True
    return False


class Solution(object):
    def mergeTrees(self, t1, t2):

    if t1 is None:
        return t2
    if t2 is None:
        return t1
    t1.val += t2.val
    t1.left = self.mergeTrees(t1.left, t2.left)
    t1.right = self.mergeTrees(t1.right, t2.right)
    return t1


class Solution(object):

    def maximumProduct(self, nums):
    min1 = min2 = float("inf")
    max1 = max2 = max3 = float("-inf")
    for num in nums:
        if num <= min1:
            min2 = min1
            min1 = num
        elif num <= min2:
            min2 = num
        if num >= max1:
            max3 = max2
            max2 = max1
            max1 = num
        elif num >= max2:
            max3 = max2
            max2 = num
        elif num >= max3:
            max3 = num
    return max(min1 * min2 * max1, max1 * max2 * max3)


class Solution(object):
    def constructMaximumBinaryTree(self, nums):

    if nums is None or len(nums) == 0:
        return None
    max_index, max_value = 0, 0
    for i, value in enumerate(nums):
        if value >= max_value:
            max_value = value
            max_index = i
    root = TreeNode(max_value)
    root.left = self.constructMaximumBinaryTree(nums[:max_index])
    root.right = self.constructMaximumBinaryTree(nums[max_index + 1:])
    return root


class Solution(object):

    def checkPossibility(self, nums):

    broken_num = 0
    for i in range(len(nums) - 1):
        if nums[i] > nums[i + 1]:
            broken_num += 1
            if broken_num >= 2:
                return False
            if i - 1 < 0 or nums[i - 1] <= nums[i + 1]:

                nums[i] = nums[i + 1]
            else:

                nums[i + 1] = nums[i]
    return True


class Solution:
    def findKthNumber(self, m: int, n: int, k: int) -> int:

    def enough(x):
        count = 0

        for i in range(1, m + 1):
            count += min(x // i, n)
        return count >= k

    lo, hi = 1, m * n
    while lo < hi:
        mi = (lo + hi) // 2
        if not enough(mi):
            lo = mi + 1
        else:
            hi = mi
    return lo


class Solution(object):

    def findSecondMinimumValue(self, root):
    if not root:
        return -1
    ans = float("inf")
    min_val = root.val
    stack = [root]
    while stack:
        curr = stack.pop()
        if not curr:
            continue
        if min_val < curr.val < ans:
            ans = curr.val
        elif curr.val == min_val:
            stack.append(curr.left)
            stack.append(curr.right)
    return ans if ans < float("inf") else -1


class Solution(object):
    def findLengthOfLCIS(self, nums):

    if not nums or len(nums) == 0:
        return 0
    ans = curr = 1
    for i in range(len(nums) - 1):
        if nums[i] < nums[i + 1]:
            curr += 1
            ans = max(ans, curr)
        else:
            curr = 1
    return ans


class Solution(object):

    def validPalindrome(self, s):
    return self.validPalindromeHelper(s, 0, len(s) - 1, 1)

    def validPalindromeHelper(self, s, left, right, budget):

    while left < len(s) and right >= 0 and left <= right and s[left] == s[right]:
        left += 1
        right -= 1
    if left >= len(s) or right < 0 or left >= right:
        return True
    if budget == 0:
        return False
    budget -= 1
    return self.validPalindromeHelper(
        s, left + 1, right, budget
    ) or self.validPalindromeHelper(s, left, right - 1, budget)


class Solution(object):

    def topKFrequent(self, words, k):
    count = collections.Counter(words)

    heap = [(-freq, word) for word, freq in count.items()]
    heapq.heapify(heap)
    return [heapq.heappop(heap)[1] for _ in xrange(k)]


class Solution(object):
    def maxAreaOfIsland(self, grid):

    ans = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                grid[i][j] = 0
                ans = max(self.dfs(grid, i, j), ans)

    return ans

    def dfs(self, grid, i, j):

    stack = [(i, j)]
    area = 0

    while stack:
        r, c = stack.pop(-1)
        area += 1
        for nr, nc in ((r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)):
            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc]:
                stack.append((nr, nc))
                grid[nr][nc] = 0
    return area


class Solution(object):

    def findShortestSubArray(self, nums):
    left, right, count = {}, {}, {}
    for i, x in enumerate(nums):
        if x not in left:
            left[x] = i
        right[x] = i
        count[x] = count.get(x, 0) + 1

    ans = len(nums)
    degree = max(count.values())
    for x in count:
        if count[x] == degree:
            ans = min(ans, right[x] - left[x] + 1)

    return ans


class Solution(object):

    def searchBST(self, root, val):
    while root:
        if root.val == val:
            return root
        elif root.val > val:
            root = root.left
        else:
            root = root.right
    return root


class KthLargest(object):
    def __init__(self, k, nums):
    self.nums = nums
    self.k = k

    heapq.heapify(self.nums)

    while len(self.nums) > k:
        heapq.heappop(self.nums)

    def add(self, val):

    if len(self.nums) < self.k:
        heapq.heappush(self.nums, val)
    elif val > self.nums[0]:

        heapq.heapreplace(self.nums, val)

    return self.nums[0]


class MyHashMap(object):

    def __init__(self):

    self.size = 10000
    self.nodes = [None] * self.size

    def put(self, key, value):

    index = hash(key) % self.size
    if self.nodes[index] is None:
        self.nodes[index] = ListNode(-1, -1)
    prev = find(self.nodes[index], key)
    if prev.next is None:
        prev.next = ListNode(key, value)
    else:
        prev.next.val = value

    def get(self, key):

    index = hash(key) % self.size
    if self.nodes[index] is None:
        return -1
    prev = find(self.nodes[index], key)
    if prev.next is None:
        return -1
    else:
        return prev.next.val

    def remove(self, key):

    index = hash(key) % self.size
    if self.nodes[index] is None:
        return
    prev = find(self.nodes[index], key)
    if prev.next is None:
        return
    prev.next = prev.next.next


def find(bucket, key):

    node = bucket
    prev = None
    while node is not None and node.key != key:
    prev = node
    node = node.next
    return prev


class ListNode:
    def __init__(self, key, val):
    self.key = key
    self.val = val
    self.next = None


class Solution(object):
    def toLowerCase(self, str):

    res = []
    gap = ord("a") - ord("A")
    for c in str:
        if ord(c) >= ord("A") and ord(c) <= ord("Z"):
            res.append(chr(ord(c) + gap))
        else:
            res.append(c)
    return "".join(res)


class MaxStack(object):
    def __init__(self):

    self.stack = []
    self.max_stack = []

    def push(self, x):

    self.stack.append(x)
    if len(self.max_stack) == 0:
        self.max_stack.append(x)
        return
    if self.max_stack[-1] > x:
        self.max_stack.append(self.max_stack[-1])
    else:
        self.max_stack.append(x)

    def pop(self):

    if len(self.stack) != 0:
        self.max_stack.pop(-1)
        return self.stack.pop(-1)

    def top(self):

    return self.stack[-1]

    def peekMax(self):

    if len(self.max_stack) != 0:
        return self.max_stack[-1]

    def popMax(self):

    val = self.peekMax()
    buff = []
    while self.top() != val:
        buff.append(self.pop())
    self.pop()
    while len(buff) != 0:
        self.push(buff.pop(-1))
    return val


class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
    pos = 0

    while pos < len(bits) - 1:

        pos += bits[pos] + 1
    return pos == len(bits) - 1


class Solution(object):

    def longestWord(self, words):
    def Trie(): return collections.defaultdict(Trie)
    trie = Trie()
    END = True
    for i, word in enumerate(words):
        reduce(dict.__getitem__, word, trie)[END] = i
    stack = trie.values()
    ans = ""
    while stack:
        cur = stack.pop()
        if END in cur:
            word = words[cur[END]]
            if len(word) > len(ans) or len(word) == len(ans) and word < ans:
                ans = word
            stack.extend([cur[letter] for letter in cur if letter != END])
    return ans


class Solution(object):
    def pivotIndex(self, nums):

    totalsum = sum(nums)
    leftsum = 0
    for i, v in enumerate(nums):

        if leftsum == totalsum - leftsum - v:
            return i
        leftsum += v
    return -1


class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:

    return [
        x
        for x in range(left, right + 1)
        if all([int(i) != 0 and x % int(i) == 0 for i in str(x)])
    ]


class Solution(object):

    def floodFill(self, image, sr, sc, newColor):

    r_ls, c_ls = len(image), len(image[0])
    color = image[sr][sc]
    if color == newColor:
        return image
    queue = [(sr, sc)]
    while len(queue) > 0:
        r, c = queue.pop(0)
        if image[r][c] == color:
            image[r][c] = newColor
            if r - 1 >= 0:
                queue.append((r - 1, c))
            if r + 1 < r_ls:
                queue.append((r + 1, c))
            if c - 1 >= 0:
                queue.append((r, c - 1))
            if c + 1 < c_ls:
                queue.append((r, c + 1))
    return image


class Solution(object):

    def networkDelayTime(self, times, N, K):

    graph = collections.defaultdict(list)
    for u, v, w in times:
        graph[u].append((v, w))

    dist = {node: float("inf") for node in xrange(1, N + 1)}
    seen = [False] * (N + 1)
    dist[K] = 0

    while True:
        cand_node = -1
        cand_dist = float("inf")
        for i in xrange(1, N + 1):
            if not seen[i] and dist[i] < cand_dist:
                cand_dist = dist[i]
                cand_node = i

        if cand_node < 0:
            break
        seen[cand_node] = True
        for nei, d in graph[cand_node]:
            dist[nei] = min(dist[nei], dist[cand_node] + d)

    ans = max(dist.values())
    return ans if ans < float("inf") else -1


class Solution(object):
    def ipToInt(self, ip):
    ans = 0
    for x in ip.split("."):
        ans = 256 * ans + int(x)
    return ans

    def intToIP(self, x):
    return ".".join(str((x >> i) % 256) for i in (24, 16, 8, 0))

    def ipToCIDR(self, ip, n):

    start = self.ipToInt(ip)
    ans = []
    while n:

        mask = max(33 - (start & -start).bit_length(), 33 - n.bit_length())
        ans.append(self.intToIP(start) + "/" + str(mask))
        start += 1 << (32 - mask)
        n -= 1 << (32 - mask)
    return ans


class Solution(object):
    def anagramMappings(self, A, B):

    val_index = {}
    ans = []
    for i, n in enumerate(B):
        val_index[n] = i
    for n in A:
        ans.append(val_index[n])
    return ans


class Solution(object):
    def isToeplitzMatrix(self, matrix):

    for r in range(len(matrix) - 1):
        for c in range(len(matrix[0]) - 1):
            if matrix[r][c] != matrix[r + 1][c + 1]:
                return False
    return True


class Solution(object):
    def numJewelsInStones(self, J, S):

    if len(J) == 0 or len(S) == 0:
        return 0
    j_set = set(J)
    ans = 0
    for c in S:
        if c in j_set:
            ans += 1
    return ans


class Solution(object):

    def letterCasePermutation(self, S):
    B = sum(letter.isalpha() for letter in S)
    ans = []

    for bits in xrange(1 << B):
        b = 0
        word = []
        for letter in S:
            if letter.isalpha():
                if (bits >> b) & 1:
                    word.append(letter.lower())
                else:
                    word.append(letter.upper())

                b += 1
            else:
                word.append(letter)

        ans.append("".join(word))
    return ans


Morse_tab = [
    ".-",
    "-...",
    "-.-.",
    "-..",
    ".",
    "..-.",
    "--.",
    "....",
    "..",
    ".---",
    "-.-",
    ".-..",
    "--",
    "-.",
    "---",
    ".--.",
    "--.-",
    ".-.",
    "...",
    "-",
    "..-",
    "...-",
    ".--",
    "-..-",
    "-.--",
    "--..",
]


class Solution(object):

    def uniqueMorseRepresentations(self, words):

    if len(words) == 0:
        return 0
    ans_set = set()
    for word in words:
        morsed = ""
        for c in word:
            morsed += Morse_tab[ord(c) - ord("a")]

        ans_set.add(morsed)
    return len(ans_set)


class Solution(object):
    def subdomainVisits(self, cpdomains):

    domain_count = {}
    for cpdomain in cpdomains:
        count, domain = cpdomain.split(" ")
        sub_domain = domain.split(".")
        for i in range(len(sub_domain)):
            curr = ".".join(sub_domain[i:])
            domain_count[curr] = domain_count.get(curr, 0) + int(count)
    return [str(v) + " " + k for k, v in domain_count.items()]


class Solution(object):
    def mostCommonWord(self, paragraph, banned):

    banned = set(banned)
    count = collections.Counter(
        word for word in re.split("[ !?',;.]", paragraph.lower()) if word
    )
    return max(
        (item for item in count.items() if item[0] not in banned),
        key=operator.itemgetter(1),
    )[0]


class Solution(object):
    def flipAndInvertImage(self, A):
    for row in A:
        for i in xrange((len(row) + 1) / 2):

            row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1
    return A


class Solution(object):
    def isRectangleOverlap(self, rec1, rec2):

    return not (
        rec1[2] <= rec2[0]
        or rec1[3] <= rec2[1]
        or rec1[0] >= rec2[2]
        or rec1[1] >= rec2[3]
    )


class Solution(object):
    def backspaceCompare(self, S, T):

    if S == T:
        return True
    s_stack = []
    t_stack = []
    for c in S:
        if c != "#":
            s_stack.append(c)
        elif len(s_stack) != 0:
            s_stack.pop(-1)
    for c in T:
        if c != "#":
            t_stack.append(c)
        elif len(t_stack) != 0:
            t_stack.pop(-1)
    return "".join(s_stack) == "".join(t_stack)


class Solution(object):

    def peakIndexInMountainArray(self, A):
    lo, hi = 0, len(A) - 1
    while lo < hi:
        mid = (lo + hi) / 2
        if A[mid] < A[mid + 1]:
            lo = mid + 1
        else:
            hi = mid
    return lo


class Solution(object):
    def transpose(self, A):

    R, C = len(A), len(A[0])
    ans = [[None] * R for _ in xrange(C)]
    for r, row in enumerate(A):
        for c, val in enumerate(row):
            ans[c][r] = val
    return ans


class Solution:

    def binaryGap(self, n: int) -> int:

    current = 1
    last1 = -1
    out = 0
    while n > 0:
        if n % 2 == 1:
            if last1 >= 1:
                out = max(out, current - last1)
            last1 = current
        current += 1
        n = n // 2
    return out


class Solution(object):
    def leafSimilar(self, root1, root2):

    if not root1 and not root2:
        return True
    leaf1 = []
    leaf2 = []
    self.dfs(root1, leaf1)
    self.dfs(root2, leaf2)
    if leaf1 == leaf2:
        return True
    return False

    def dfs(self, node, leavels):
    if not node:
        return
    if not node.left and not node.right:
        leavels.append(node.val)
    self.dfs(node.left, leavels)
    self.dfs(node.right, leavels)


class Solution(object):

    def middleNode(self, head):

    fast = slow = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow


class Solution(object):

    def totalFruit(self, tree):
    ans = i = 0
    count = collections.Counter()
    for j, x in enumerate(tree):
        count[x] += 1
        while len(count) >= 3:
            count[tree[i]] -= 1
            if count[tree[i]] == 0:
                del count[tree[i]]
            i += 1
        ans = max(ans, j - i + 1)
    return ans


class Solution(object):

    def sortArrayByParity(self, A):

    lo, hi = 0, len(A) - 1
    while lo < hi:
        if A[lo] % 2 > A[hi] % 2:
            A[lo], A[hi] = A[hi], A[lo]
        if A[lo] % 2 == 0:
            lo += 1
        if A[hi] % 2 == 1:
            hi -= 1
    return A


class Solution(object):

    def sortArrayByParityII(self, A):
    odd = 1
    for i in xrange(0, len(A), 2):
        if A[i] % 2:
            while A[odd] % 2:
                odd += 2
            A[i], A[odd] = A[odd], A[i]
    return A


class Solution(object):
    def numUniqueEmails(self, emails):

    email_set = set()
    for email in emails:
        elements = email.split("@")
        email_set.add(elements[0].split("+")[0].replace(".", "") + elements[1])
    return len(email_set)


class RecentCounter(object):
    def __init__(self):
    self.queue = []

    def ping(self, t):

    self.queue.append(t)
    while self.queue and self.queue[0] < t - 3000:
        self.queue.pop(0)
    return len(self.queue)


class Solution(object):

    def reorderLogFiles(self, logs):
    letter_logs = []
    digit_logs = []
    for log in logs:
        if log.split(" ")[1].isnumeric():
            digit_logs.append(log)
        else:
            letter_logs.append(log)
    return (
        sorted(letter_logs, key=lambda x: x.split(" ")[1:] + x.split(" ")[0])
        + digit_logs
    )


class Solution(object):
    def minIncrementForUnique(self, A):

    if A is None or len(A) == 0:
        return 0
    res = 0
    num_set = set()
    duplicate = []
    A.sort()
    left, right = A[0], A[-1]
    holes = right - left + 1
    for v in A:
        if v in num_set:
            duplicate.append(v)
        else:
            num_set.add(v)
    holes = holes - len(num_set)

    for hole in range(left + 1, right):
        if holes == 0 or len(duplicate) == 0:
            break
        if hole not in num_set and hole > duplicate[0]:
            res += hole - duplicate.pop(0)
            holes -= 1
    while len(duplicate) != 0:
        right += 1
        res += right - duplicate.pop(0)
    return res


if __name__ == "__main__":
    s = Solution()


class Solution(object):
    def validateStackSequences(self, pushed, popped):

    in_stack = []
    pos = 0
    while pos != len(pushed):
        curr = pushed[pos]
        while len(in_stack) > 0 and len(popped) > 0 and in_stack[-1] == popped[0]:
            in_stack.pop(-1)
            popped.pop(0)
        if len(popped) == 0:
            break
        if curr == popped[0]:
            popped.pop(0)
        else:
            in_stack.append(curr)
        pos += 1
    while len(in_stack) > 0 and len(popped) > 0 and in_stack[-1] == popped[0]:
        in_stack.pop(-1)
        popped.pop(0)
    if len(in_stack) == 0:
        return True
    return False


if __name__ == "__main__":
    s = Solution()

    print s.validateStackSequences([1, 0, 3, 2], [0, 1, 2, 3])


class Solution(object):
    def isAlienSorted(self, words, order):

    order_map = {}
    for i, v in enumerate(order):
        order_map[v] = i

    def cmp_alien(x, y):
        ls = min(len(x), len(y))
        index = 0
        while index < ls:
            if x[index] != y[index]:
                return order_map[x[index]] - order_map[y[index]]
            index += 1
        return len(x) - len(y)

    pos = 0
    while pos + 1 < len(words):
        if cmp_alien(words[pos], words[pos + 1]) > 0:
            return False
        pos += 1
    return True


if __name__ == "__main__":
    s = Solution()
    print s.isAlienSorted(["hello", "leetcode"], "hlabcdefgijkmnopqrstuvwxyz")
    print s.isAlienSorted(["word", "world", "row"], "worldabcefghijkmnpqstuvxyz")
    print s.isAlienSorted(["apple", "app"], "abcdefghijklmnopqrstuvwxyz")


class Solution(object):
    def canReorderDoubled(self, A):

    v_map = {}
    A.sort(key=lambda x: abs(x))
    for n in A:
        v_map[n] = v_map.get(n, 0) + 1
    for n in A:
        if v_map[n] <= 0:
            continue
        if 2 * n in v_map and v_map[2 * n] > 0:
            v_map[n] -= 1
            v_map[2 * n] -= 1
        else:
            return False
    return True


if __name__ == "__main__":
    s = Solution()
    print s.canReorderDoubled([3, 1, 3, 6])
    print s.canReorderDoubled([2, 1, 2, 6])
    print s.canReorderDoubled([4, -2, 2, -4])
    print s.canReorderDoubled([1, 2, 4, 16, 8, 4])
import collections


class Solution(object):
    def repeatedNTimes(self, A):

    counter = collections.Counter(A)
    return counter.most_common(1)[0][0]


if __name__ == "__main__":
    s = Solution()
    print s.repeatedNTimes([1, 2, 3, 3])
    print s.repeatedNTimes([2, 1, 2, 5, 3, 2])
    print s.repeatedNTimes([5, 1, 5, 2, 5, 3, 5, 4])


class Solution(object):

    def maxWidthRamp(self, A):
    ans = 0
    m = float("inf")

    for i in sorted(range(len(A)), key=A.__getitem__):
        ans = max(ans, i - m)
        m = min(m, i)
    return ans


if __name__ == "__main__":
    s = Solution()
    print s.maxWidthRamp([6, 0, 8, 2, 1, 5])
    print s.maxWidthRamp([9, 8, 1, 0, 1, 9, 4, 0, 4, 1])


class Solution(object):

    def kClosest(self, points, K):

    return heapq.nsmallest(K, points, key=lambda x: x[0] ** 2 + x[1] ** 2)


class Solution(object):

    def sortedSquares(self, A):
    pos = 0
    while pos < len(A) and A[pos] < 0:
        pos += 1

    npos = pos - 1
    res = []
    while pos < len(A) and npos >= 0:
        if A[npos] ** 2 < A[pos] ** 2:
            res.append(A[npos] ** 2)
            npos -= 1
        else:
            res.append(A[pos] ** 2)
            pos += 1
    while npos >= 0:
        res.append(A[npos] ** 2)
        npos -= 1
    while pos < len(A):
        res.append(A[pos] ** 2)
        pos += 1
    return res


class Solution:
    def findJudge(self, N: int, trust: List[List[int]]) -> int:
    if N == 1:
        return 1
    d1 = {}
    d2 = {}
    for i, j in trust:
        if j in d1:
            d1[j] += 1
        else:
            d1[j] = 1
        if i in d2:
            d2[i] += 1
        else:
            d2[i] = 1
    for i, j in d1.items():
        if j == N - 1:
            if i not in d2:
                return i
    return -1


class Solution(object):
    def updateMatrix(self, matrix):

    for i in xrange(len(matrix)):
        for j in xrange(len(matrix[i])):
            if not matrix[i][j]:
                continue
            matrix[i][j] = float("inf")
            if i > 0:
                matrix[i][j] = min(matrix[i][j], matrix[i - 1][j] + 1)
            if j > 0:
                matrix[i][j] = min(matrix[i][j], matrix[i][j - 1] + 1)
    for i in reversed(xrange(len(matrix))):
        for j in reversed(xrange(len(matrix[i]))):
            if not matrix[i][j]:
                continue
            if i < len(matrix) - 1:
                matrix[i][j] = min(matrix[i][j], matrix[i + 1][j] + 1)
            if j < len(matrix[i]) - 1:
                matrix[i][j] = min(matrix[i][j], matrix[i][j + 1] + 1)
    return matrix


class Solution2(object):
    def updateMatrix(self, matrix):

    dp = [[float("inf")] * len(matrix[0]) for _ in xrange(len(matrix))]
    for i in xrange(len(matrix)):
        for j in xrange(len(matrix[i])):
            if matrix[i][j] == 0:
                dp[i][j] = 0
            else:
                if i > 0:
                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)
                if j > 0:
                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)
    for i in reversed(xrange(len(matrix))):
        for j in reversed(xrange(len(matrix[i]))):
            if matrix[i][j] == 0:
                dp[i][j] = 0
            else:
                if i < len(matrix) - 1:
                    dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1)
                if j < len(matrix[i]) - 1:
                    dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1)
    return dp


import collections


class Solution3(object):
    def updateMatrix(self, matrix):

    queue = collections.deque()
    for i in xrange(len(matrix)):
        for j in xrange(len(matrix[0])):
            if matrix[i][j] == 0:
                queue.append((i, j))
            else:
                matrix[i][j] = float("inf")

    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    while queue:
        cell = queue.popleft()
        for dir in dirs:
            i, j = cell[0] + dir[0], cell[1] + dir[1]
            if not (
                0 <= i < len(matrix)
                and 0 <= j < len(matrix[0])
                and matrix[i][j] > matrix[cell[0]][cell[1]] + 1
            ):
                continue
            queue.append((i, j))
            matrix[i][j] = matrix[cell[0]][cell[1]] + 1

    return matrix


class Solution(object):
    def isOneBitCharacter(self, bits):

    parity = 0
    for i in reversed(xrange(len(bits) - 1)):
        if bits[i] == 0:
            break
        parity ^= bits[i]
    return parity == 0


class Solution(object):
    def find132pattern(self, nums):

    ak = float("-inf")
    st = []
    for i in reversed(xrange(len(nums))):
        if nums[i] < ak:
            return True
        else:
            while st and nums[i] > st[-1]:
                ak = st.pop()
        st.append(nums[i])
    return False


class Solution(object):
    def minSteps(self, n):

    result = 0
    p = 2

    while p ** 2 <= n:
        while n % p == 0:
            result += p
            n //= p
        p += 1
    if n > 1:
        result += n
    return result


from operator import add, sub, mul, truediv
from fractions import Fraction


class Solution(object):
    def judgePoint24(self, nums):

    if len(nums) == 1:
        return abs(nums[0] - 24) < 1e-6
    ops = [add, sub, mul, truediv]
    for i in xrange(len(nums)):
        for j in xrange(len(nums)):
            if i == j:
                continue
            next_nums = [nums[k] for k in xrange(len(nums)) if i != k != j]
            for op in ops:
                if ((op is add or op is mul) and j > i) or (
                    op == truediv and nums[j] == 0
                ):
                    continue
                next_nums.append(op(nums[i], nums[j]))
                if self.judgePoint24(next_nums):
                    return True
                next_nums.pop()
    return False


class Solution2(object):
    def judgePoint24(self, nums):

    def dfs(nums):
        if len(nums) == 1:
            return nums[0] == 24
        ops = [add, sub, mul, truediv]
        for i in xrange(len(nums)):
            for j in xrange(len(nums)):
                if i == j:
                    continue
                next_nums = [nums[k] for k in xrange(len(nums)) if i != k != j]
                for op in ops:
                    if ((op is add or op is mul) and j > i) or (
                        op == truediv and nums[j] == 0
                    ):
                        continue
                    next_nums.append(op(nums[i], nums[j]))
                    if dfs(next_nums):
                        return True
                    next_nums.pop()
        return False

    return dfs(map(Fraction, nums))


class Solution(object):
    def threeSumClosest(self, nums, target):

    result, min_diff = 0, float("inf")
    nums.sort()
    for i in reversed(xrange(2, len(nums))):
        if i + 1 < len(nums) and nums[i] == nums[i + 1]:
            continue
        left, right = 0, i - 1
        while left < right:
            total = nums[left] + nums[right] + nums[i]
            if total < target:
                left += 1
            elif total > target:
                right -= 1
            else:
                return target
            if abs(total - target) < min_diff:
                min_diff = abs(total - target)
                result = total
    return result


class Solution(object):

    def threeSumSmaller(self, nums, target):
    nums.sort()
    n = len(nums)

    count, k = 0, 2
    while k < n:
        i, j = 0, k - 1
        while i < j:
            if nums[i] + nums[j] + nums[k] >= target:
                j -= 1
            else:
                count += j - i
                i += 1
        k += 1

    return count


import collections
import itertools


class Solution(object):
    def threeSumMulti(self, A, target):

    count = collections.Counter(A)
    result = 0
    for i, j in itertools.combinations_with_replacement(count, 2):
        k = target - i - j
        if i == j == k:
            result += count[i] * (count[i] - 1) * (count[i] - 2) // 6
        elif i == j != k:
            result += count[i] * (count[i] - 1) // 2 * count[k]
        elif max(i, j) < k:
            result += count[i] * count[j] * count[k]
    return result % (10 ** 9 + 7)


class Solution(object):
    def threeSum(self, nums):

    result = []
    nums.sort()
    for i in reversed(xrange(2, len(nums))):
        if i + 1 < len(nums) and nums[i] == nums[i + 1]:
            continue
        target = -nums[i]
        left, right = 0, i - 1
        while left < right:
            if nums[left] + nums[right] < target:
                left += 1
            elif nums[left] + nums[right] > target:
                right -= 1
            else:
                result.append([nums[left], nums[right], nums[i]])
                left += 1
                right -= 1
                while left < right and nums[left] == nums[left - 1]:
                    left += 1
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1
    return result


class Solution2(object):
    def threeSum(self, nums):

    nums, result, i = sorted(nums), [], 0
    while i < len(nums) - 2:
        if i == 0 or nums[i] != nums[i - 1]:
            j, k = i + 1, len(nums) - 1
            while j < k:
                if nums[i] + nums[j] + nums[k] < 0:
                    j += 1
                elif nums[i] + nums[j] + nums[k] > 0:
                    k -= 1
                else:
                    result.append([nums[i], nums[j], nums[k]])
                    j, k = j + 1, k - 1
                    while j < k and nums[j] == nums[j - 1]:
                        j += 1
                    while j < k and nums[k] == nums[k + 1]:
                        k -= 1
        i += 1
    return result


class Solution(object):
    def maxA(self, N):

    if N < 7:
        return N
    if N == 10:
        return 20

    n = N // 5 + 1

    n3 = 5 * n - N - 1
    n4 = n - n3
    return 3 ** n3 * 4 ** n4


class Solution2(object):
    def maxA(self, N):

    if N < 7:
        return N
    dp = range(N + 1)
    for i in xrange(7, N + 1):
        dp[i % 6] = max(dp[(i - 4) % 6] * 3, dp[(i - 5) % 6] * 4)
    return dp[N % 6]


import collections


class Solution(object):
    def fourSumCount(self, A, B, C, D):

    A_B_sum = collections.Counter(a + b for a in A for b in B)
    return sum(A_B_sum[-c - d] for c in C for d in D)


import collections


class Solution(object):
    def fourSum(self, nums, target):

    nums.sort()
    result = []
    for i in xrange(len(nums) - 3):
        if i and nums[i] == nums[i - 1]:
            continue
        for j in xrange(i + 1, len(nums) - 2):
            if j != i + 1 and nums[j] == nums[j - 1]:
                continue
            total = target - nums[i] - nums[j]
            left, right = j + 1, len(nums) - 1
            while left < right:
                if nums[left] + nums[right] == total:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    right -= 1
                    left += 1
                    while left < right and nums[left] == nums[left - 1]:
                        left += 1
                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1
                elif nums[left] + nums[right] > total:
                    right -= 1
                else:
                    left += 1
    return result


class Solution2(object):
    def fourSum(self, nums, target):

    nums, result, lookup = sorted(nums), [], collections.defaultdict(list)
    for i in xrange(0, len(nums) - 1):
        for j in xrange(i + 1, len(nums)):
            is_duplicated = False
            for [x, y] in lookup[nums[i] + nums[j]]:
                if nums[x] == nums[i]:
                    is_duplicated = True
                    break
            if not is_duplicated:
                lookup[nums[i] + nums[j]].append([i, j])
    ans = {}
    for c in xrange(2, len(nums)):
        for d in xrange(c + 1, len(nums)):
            if target - nums[c] - nums[d] in lookup:
                for [a, b] in lookup[target - nums[c] - nums[d]]:
                    if b < c:
                        quad = [nums[a], nums[b], nums[c], nums[d]]
                        quad_hash = " ".join(str(quad))
                        if quad_hash not in ans:
                            ans[quad_hash] = True
                            result.append(quad)
    return result


class Solution3(object):
    def fourSum(self, nums, target):

    nums, result, lookup = sorted(nums), [], collections.defaultdict(list)
    for i in xrange(0, len(nums) - 1):
        for j in xrange(i + 1, len(nums)):
            lookup[nums[i] + nums[j]].append([i, j])

    for i in lookup.keys():
        if target - i in lookup:
            for x in lookup[i]:
                for y in lookup[target - i]:
                    [a, b], [c, d] = x, y
                    if a is not c and a is not d and b is not c and b is not d:
                        quad = sorted([nums[a], nums[b], nums[c], nums[d]])
                        if quad not in result:
                            result.append(quad)
    return sorted(result)


import collections


class UnionFind(object):
    def __init__(self):
    self.set = []

    def get_id(self):
    self.set.append(len(self.set))
    return len(self.set) - 1

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root != y_root:
        self.set[min(x_root, y_root)] = max(x_root, y_root)


class Solution(object):
    def accountsMerge(self, accounts):

    union_find = UnionFind()
    email_to_name = {}
    email_to_id = {}
    for account in accounts:
        name = account[0]
        for i in xrange(1, len(account)):
            if account[i] not in email_to_id:
                email_to_name[account[i]] = name
                email_to_id[account[i]] = union_find.get_id()
            union_find.union_set(
                email_to_id[account[1]], email_to_id[account[i]])

    result = collections.defaultdict(list)
    for email in email_to_name.keys():
        result[union_find.find_set(email_to_id[email])].append(email)
    for emails in result.values():
        emails.sort()
    return [[email_to_name[emails[0]]] + emails for emails in result.values()]


class TrieNode(object):

    def __init__(self):
    self.is_string = False
    self.leaves = {}


class WordDictionary(object):
    def __init__(self):
    self.root = TrieNode()

    def addWord(self, word):
    curr = self.root
    for c in word:
        if c not in curr.leaves:
            curr.leaves[c] = TrieNode()
        curr = curr.leaves[c]
    curr.is_string = True

    def search(self, word):
    return self.searchHelper(word, 0, self.root)

    def searchHelper(self, word, start, curr):
    if start == len(word):
        return curr.is_string
    if word[start] in curr.leaves:
        return self.searchHelper(word, start + 1, curr.leaves[word[start]])
    elif word[start] == ".":
        for c in curr.leaves:
            if self.searchHelper(word, start + 1, curr.leaves[c]):
                return True

    return False


class Solution(object):

    def addBinary(self, a, b):
    result, carry, val = "", 0, 0
    for i in xrange(max(len(a), len(b))):
        val = carry
        if i < len(a):
            val += int(a[-(i + 1)])
        if i < len(b):
            val += int(b[-(i + 1)])
        carry, val = divmod(val, 2)
        result += str(val)
    if carry:
        result += str(carry)
    return result[::-1]


from itertools import izip_longest


class Solution2(object):
    def addBinary(self, a, b):

    result = ""
    carry = 0
    for x, y in izip_longest(reversed(a), reversed(b), fillvalue="0"):
        carry, remainder = divmod(int(x) + int(y) + carry, 2)
        result += str(remainder)

    if carry:
        result += str(carry)

    return result[::-1]


import collections
import functools


class Solution(object):
    def addBoldTag(self, s, dict):

    lookup = [0] * len(s)
    for d in dict:
        pos = s.find(d)
        while pos != -1:
            lookup[pos: pos + len(d)] = [1] * len(d)
            pos = s.find(d, pos + 1)

    result = []
    for i in xrange(len(s)):
        if lookup[i] and (i == 0 or not lookup[i - 1]):
            result.append("<b>")
        result.append(s[i])
        if lookup[i] and (i == len(s) - 1 or not lookup[i + 1]):
            result.append("</b>")
    return "".join(result)


class Solution2(object):
    def addBoldTag(self, s, words):

    def _trie(): return collections.defaultdict(_trie)
    trie = _trie()
    for i, word in enumerate(words):
        functools.reduce(dict.__getitem__, word, trie).setdefault("_end")

    lookup = [False] * len(s)
    for i in xrange(len(s)):
        curr = trie
        k = -1
        for j in xrange(i, len(s)):
            if s[j] not in curr:
                break
            curr = curr[s[j]]
            if "_end" in curr:
                k = j
        for j in xrange(i, k + 1):
            lookup[j] = True

    result = []
    for i in xrange(len(s)):
        if lookup[i] and (i == 0 or not lookup[i - 1]):
            result.append("<b>")
        result.append(s[i])
        if lookup[i] and (i == len(s) - 1 or not lookup[i + 1]):
            result.append("</b>")
    return "".join(result)


class Solution(object):

    def addDigits(self, num):
    return (num - 1) % 9 + 1 if num > 0 else 0


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def addOneRow(self, root, v, d):

    if d in (0, 1):
        node = TreeNode(v)
        if d == 1:
            node.left = root
        else:
            node.right = root
        return node
    if root and d >= 2:
        root.left = self.addOneRow(root.left, v, d - 1 if d > 2 else 1)
        root.right = self.addOneRow(root.right, v, d - 1 if d > 2 else 0)
    return root


class Solution(object):
    def addStrings(self, num1, num2):

    result = []
    i, j, carry = len(num1) - 1, len(num2) - 1, 0

    while i >= 0 or j >= 0 or carry:
        if i >= 0:
            carry += ord(num1[i]) - ord("0")
            i -= 1
        if j >= 0:
            carry += ord(num2[j]) - ord("0")
            j -= 1
        result.append(str(carry % 10))
        carry /= 10
    result.reverse()

    return "".join(result)

    def addStrings2(self, num1, num2):

    length = max(len(num1), len(num2))
    num1 = num1.zfill(length)[::-1]
    num2 = num2.zfill(length)[::-1]
    res, plus = "", 0
    for index, num in enumerate(num1):
        tmp = str(int(num) + int(num2[index]) + plus)
        res += tmp[-1]
        if int(tmp) > 9:
            plus = 1
        else:
            plus = 0
    if plus:
        res += "1"
    return res[::-1]


class Solution(object):
    def addToArrayForm(self, A, K):

    A.reverse()
    carry, i = K, 0
    A[i] += carry
    carry, A[i] = divmod(A[i], 10)
    while carry:
        i += 1
        if i < len(A):
            A[i] += carry
        else:
            A.append(carry)
        carry, A[i] = divmod(A[i], 10)
    A.reverse()
    return A


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):
    def addTwoNumbers(self, l1, l2):

    stk1, stk2 = [], []
    while l1:
        stk1.append(l1.val)
        l1 = l1.next
    while l2:
        stk2.append(l2.val)
        l2 = l2.next

    prev, head = None, None
    sum = 0
    while stk1 or stk2:
        sum /= 10
        if stk1:
            sum += stk1.pop()
        if stk2:
            sum += stk2.pop()

        head = ListNode(sum % 10)
        head.next = prev
        prev = head

    if sum >= 10:
        head = ListNode(sum / 10)
        head.next = prev

    return head


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):
    def addTwoNumbers(self, l1, l2):

    dummy = ListNode(0)
    current, carry = dummy, 0

    while l1 or l2:
        val = carry
        if l1:
            val += l1.val
            l1 = l1.next
        if l2:
            val += l2.val
            l2 = l2.next
        carry, val = divmod(val, 10)
        current.next = ListNode(val)
        current = current.next

    if carry == 1:
        current.next = ListNode(1)

    return dummy.next


class PolyNode:
    def __init__(self, x=0, y=0, next=None):
    pass


class Solution:
    def addPoly(self, poly1, poly2):

    curr = dummy = PolyNode()
    while poly1 and poly2:
        if poly1.power > poly2.power:
            curr.next = poly1
            curr = curr.next
            poly1 = poly1.next
        elif poly1.power < poly2.power:
            curr.next = poly2
            curr = curr.next
            poly2 = poly2.next
        else:
            coef = poly1.coefficient + poly2.coefficient
            if coef:
                curr.next = PolyNode(coef, poly1.power)
                curr = curr.next
            poly1, poly2 = poly1.next, poly2.next
    curr.next = poly1 or poly2
    return dummy.next


class Solution(object):
    def addNegabinary(self, arr1, arr2):

    result = []
    carry = 0
    while arr1 or arr2 or carry:
        if arr1:
            carry += arr1.pop()
        if arr2:
            carry += arr2.pop()
        result.append(carry & 1)
        carry = -(carry >> 1)
    while len(result) > 1 and result[-1] == 0:
        result.pop()
    result.reverse()
    return result


class Solution(object):
    def isAdditiveNumber(self, num):

    def add(a, b):
        res, carry, val = "", 0, 0
        for i in xrange(max(len(a), len(b))):
            val = carry
            if i < len(a):
                val += int(a[-(i + 1)])
            if i < len(b):
                val += int(b[-(i + 1)])
            carry, val = val / 10, val % 10
            res += str(val)
        if carry:
            res += str(carry)
        return res[::-1]

    for i in xrange(1, len(num)):
        for j in xrange(i + 1, len(num)):
            s1, s2 = num[0:i], num[i:j]
            if (len(s1) > 1 and s1[0] == "0") or (len(s2) > 1 and s2[0] == "0"):
                continue

            expected = add(s1, s2)
            cur = s1 + s2 + expected
            while len(cur) < len(num):
                s1, s2, expected = s2, expected, add(s2, expected)
                cur += expected
            if cur == num:
                return True
    return False


class Solution(object):
    def advantageCount(self, A, B):

    sortedA = sorted(A)
    sortedB = sorted(B)

    candidates = {b: [] for b in B}
    others = []
    j = 0
    for a in sortedA:
        if a > sortedB[j]:
            candidates[sortedB[j]].append(a)
            j += 1
        else:
            others.append(a)
    return [candidates[b].pop() if candidates[b] else others.pop() for b in B]


class Solution(object):
    def nthPersonGetsNthSeat(self, n):

    return 0.5 if n != 1 else 1.0


class Solution2(object):
    def nthPersonGetsNthSeat(self, n):

    dp = [0.0] * 2
    dp[0] = 1.0
    for i in xrange(2, n + 1):
        dp[(i - 1) % 2] = 1.0 / i + dp[(i - 2) % 2] * (i - 2) / i
    return dp[(n - 1) % 2]


import collections
import itertools


class Solution(object):
    def alertNames(self, keyName, keyTime):

    THRESHOLD = 3
    name_to_times = collections.defaultdict(list)
    for name, hour_minute in itertools.izip(keyName, keyTime):
        hour, minute = map(int, hour_minute.split(":"))
        name_to_times[name].append(hour * 60 + minute)
    names = []
    for name, times in name_to_times.iteritems():
        times.sort()
        left = 0
        for right, time in enumerate(times):
            while time - times[left] > 60:
                left += 1
            if right - left + 1 >= THRESHOLD:
                names.append(name)
                break
    names.sort()
    return names


import collections


class Solution(object):
    def alienOrder(self, words):

    result, in_degree, out_degree = [], {}, {}
    zero_in_degree_queue = collections.deque()
    nodes = set()
    for word in words:
        for c in word:
            nodes.add(c)

    for i in xrange(1, len(words)):
        if (
            len(words[i - 1]) > len(words[i])
            and words[i - 1][: len(words[i])] == words[i]
        ):
            return ""
        self.findEdges(words[i - 1], words[i], in_degree, out_degree)

    for node in nodes:
        if node not in in_degree:
            zero_in_degree_queue.append(node)

    while zero_in_degree_queue:
        precedence = zero_in_degree_queue.popleft()
        result.append(precedence)

        if precedence in out_degree:
            for c in out_degree[precedence]:
                in_degree[c].discard(precedence)
                if not in_degree[c]:
                    zero_in_degree_queue.append(c)

            del out_degree[precedence]

    if out_degree:
        return ""

    return "".join(result)

    def findEdges(self, word1, word2, in_degree, out_degree):
    str_len = min(len(word1), len(word2))
    for i in xrange(str_len):
        if word1[i] != word2[i]:
            if word2[i] not in in_degree:
                in_degree[word2[i]] = set()
            if word1[i] not in out_degree:
                out_degree[word1[i]] = set()
            in_degree[word2[i]].add(word1[i])
            out_degree[word1[i]].add(word2[i])
            break


class Solution2(object):
    def alienOrder(self, words):

    nodes, ancestors = set(), {}
    for i in xrange(len(words)):
        for c in words[i]:
            nodes.add(c)
    for node in nodes:
        ancestors[node] = []
    for i in xrange(1, len(words)):
        if (
            len(words[i - 1]) > len(words[i])
            and words[i - 1][: len(words[i])] == words[i]
        ):
            return ""
        self.findEdges(words[i - 1], words[i], ancestors)

    result = []
    visited = {}
    for node in nodes:
        if self.topSortDFS(node, node, ancestors, visited, result):
            return ""

    return "".join(result)

    def findEdges(self, word1, word2, ancestors):
    min_len = min(len(word1), len(word2))
    for i in xrange(min_len):
        if word1[i] != word2[i]:
            ancestors[word2[i]].append(word1[i])
            break

    def topSortDFS(self, root, node, ancestors, visited, result):
    if node not in visited:
        visited[node] = root
        for ancestor in ancestors[node]:
            if self.topSortDFS(root, ancestor, ancestors, visited, result):
                return True
        result.append(node)
    elif visited[node] == root:

        return True
    return False


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def getAllElements(self, root1, root2):

    def inorder_gen(root):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                yield root.val
            else:
                stack.append((root.right, False))
                stack.append((root, True))
                stack.append((root.left, False))
        yield None

    result = []
    left_gen, right_gen = inorder_gen(root1), inorder_gen(root2)
    left, right = next(left_gen), next(right_gen)
    while left is not None or right is not None:
        if right is None or (left is not None and left < right):
            result.append(left)
            left = next(left_gen)
        else:
            result.append(right)
            right = next(right_gen)
    return result


import collections


class Solution(object):
    def distanceK(self, root, target, K):

    def dfs(parent, child, neighbors):
        if not child:
            return
        if parent:
            neighbors[parent.val].append(child.val)
            neighbors[child.val].append(parent.val)
        dfs(child, child.left, neighbors)
        dfs(child, child.right, neighbors)

    neighbors = collections.defaultdict(list)
    dfs(None, root, neighbors)
    bfs = [target.val]
    lookup = set(bfs)
    for _ in xrange(K):
        bfs = [nei for node in bfs for nei in neighbors[node] if nei not in lookup]
        lookup |= set(bfs)
    return bfs


class Node(object):

    def __init__(self, value, keys):
    self.value = value
    self.keys = keys
    self.prev = None
    self.next = None


class LinkedList(object):
    def __init__(self):
    self.head, self.tail = Node(0, set()), Node(0, set())
    self.head.next, self.tail.prev = self.tail, self.head

    def insert(self, pos, node):
    node.prev, node.next = pos.prev, pos
    pos.prev.next, pos.prev = node, node
    return node

    def erase(self, node):
    node.prev.next, node.next.prev = node.next, node.prev
    del node

    def empty(self):
    return self.head.next is self.tail

    def begin(self):
    return self.head.next

    def end(self):
    return self.tail

    def front(self):
    return self.head.next

    def back(self):
    return self.tail.prev


class AllOne(object):
    def __init__(self):

    self.bucket_of_key = {}
    self.buckets = LinkedList()

    def inc(self, key):

    if key not in self.bucket_of_key:
        self.bucket_of_key[key] = self.buckets.insert(
            self.buckets.begin(), Node(0, set([key]))
        )

    bucket, next_bucket = self.bucket_of_key[key], self.bucket_of_key[key].next
    if next_bucket is self.buckets.end() or next_bucket.value > bucket.value + 1:
        next_bucket = self.buckets.insert(
            next_bucket, Node(bucket.value + 1, set())
        )
    next_bucket.keys.add(key)
    self.bucket_of_key[key] = next_bucket

    bucket.keys.remove(key)
    if not bucket.keys:
        self.buckets.erase(bucket)

    def dec(self, key):

    if key not in self.bucket_of_key:
        return

    bucket, prev_bucket = self.bucket_of_key[key], self.bucket_of_key[key].prev
    self.bucket_of_key.pop(key, None)
    if bucket.value > 1:
        if bucket is self.buckets.begin() or prev_bucket.value < bucket.value - 1:
            prev_bucket = self.buckets.insert(
                bucket, Node(bucket.value - 1, set()))
        prev_bucket.keys.add(key)
        self.bucket_of_key[key] = prev_bucket

    bucket.keys.remove(key)
    if not bucket.keys:
        self.buckets.erase(bucket)

    def getMaxKey(self):

    if self.buckets.empty():
        return ""
    return iter(self.buckets.back().keys).next()

    def getMinKey(self):

    if self.buckets.empty():
        return ""
    return iter(self.buckets.front().keys).next()


import collections


class Solution(object):
    def leadsToDestination(self, n, edges, source, destination):

    UNVISITED, VISITING, DONE = range(3)

    def dfs(children, node, destination, status):
        if status[node] == DONE:
            return True
        if status[node] == VISITING:
            return False
        status[node] = VISITING
        if node not in children and node != destination:
            return False
        if node in children:
            for child in children[node]:
                if not dfs(children, child, destination, status):
                    return False
        status[node] = DONE
        return True

    children = collections.defaultdict(list)
    for parent, child in edges:
        children[parent].append(child)
    return dfs(children, source, destination, [0] * n)


class Solution(object):
    def allPathsSourceTarget(self, graph):

    def dfs(graph, curr, path, result):
        if curr == len(graph) - 1:
            result.append(path[:])
            return
        for node in graph[curr]:
            path.append(node)
            dfs(graph, node, path, result)
            path.pop()

    result = []
    dfs(graph, 0, [0], result)
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def __init__(self):
    self.__memo = {1: [TreeNode(0)]}

    def allPossibleFBT(self, N):

    if N % 2 == 0:
        return []

    if N not in self.__memo:
        result = []
        for i in xrange(N):
            for left in self.allPossibleFBT(i):
                for right in self.allPossibleFBT(N - 1 - i):
                    node = TreeNode(0)
                    node.left = left
                    node.right = right
                    result.append(node)
        self.__memo[N] = result

    return self.__memo[N]


class Solution(object):
    def minDistance(self, houses, k):

    def cost(prefix, i, j):
        return (prefix[j + 1] - prefix[(i + j + 1) // 2]) - (
            prefix[(i + j) // 2 + 1] - prefix[i]
        )

    houses.sort()
    prefix = [0] * (len(houses) + 1)
    for i, h in enumerate(houses):
        prefix[i + 1] = prefix[i] + h
    dp = [cost(prefix, 0, j) for j in xrange(len(houses))]
    for m in xrange(1, k):
        for j in reversed(xrange(m, len(houses))):
            for i in xrange(m, j + 1):
                dp[j] = min(dp[j], dp[i - 1] + cost(prefix, i, j))
    return dp[-1]


class Solution(object):
    def alphabetBoardPath(self, target):

    x, y = 0, 0
    result = []
    for c in target:
        y1, x1 = divmod(ord(c) - ord("a"), 5)
        result.append("U" * max(y - y1, 0))
        result.append("L" * max(x - x1, 0))
        result.append("R" * max(x1 - x, 0))
        result.append("D" * max(y1 - y, 0))
        result.append("!")
        x, y = x1, y1
    return "".join(result)


import itertools


class Solution(object):
    def ambiguousCoordinates(self, S):

    def make(S, i, n):
        for d in xrange(1, n + 1):
            left = S[i: i + d]
            right = S[i + d: i + n]
            if (not left.startswith("0") or left == "0") and (
                not right.endswith("0")
            ):
                yield "".join([left, "." if right else "", right])

    return [
        "({}, {})".format(*cand)
        for i in xrange(1, len(S) - 2)
        for cand in itertools.product(make(S, 1, i), make(S, i + 1, len(S) - 2 - i))
    ]


import collections
import itertools


class Solution(object):
    def mostVisitedPattern(self, username, timestamp, website):

    lookup = collections.defaultdict(list)
    A = zip(timestamp, username, website)
    A.sort()
    for t, u, w in A:
        lookup[u].append(w)
    count = sum(
        [
            collections.Counter(set(itertools.combinations(lookup[u], 3)))
            for u in lookup
        ],
        collections.Counter(),
    )
    return list(min(count, key=lambda x: (-count[x], x)))


class Solution(object):
    def numberOfPatterns(self, m, n):

    def merge(used, i):
        return used | (1 << i)

    def number_of_keys(i):
        number = 0
        while i > 0:
            i &= i - 1
            number += 1
        return number

    def contain(used, i):
        return bool(used & (1 << i))

    def convert(i, j):
        return 3 * i + j

    dp = [[0] * 9 for _ in xrange(1 << 9)]
    for i in xrange(9):
        dp[merge(0, i)][i] = 1

    res = 0
    for used in xrange(len(dp)):
        number = number_of_keys(used)
        if number > n:
            continue

        for i in xrange(9):
            if not contain(used, i):
                continue

            if m <= number <= n:
                res += dp[used][i]

            x1, y1 = divmod(i, 3)
            for j in xrange(9):
                if contain(used, j):
                    continue

                x2, y2 = divmod(j, 3)
                if (
                    (x1 == x2 and abs(y1 - y2) == 2)
                    or (y1 == y2 and abs(x1 - x2) == 2)
                    or (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)
                ) and not contain(used, convert((x1 + x2) // 2, (y1 + y2) // 2)):
                    continue

                dp[merge(used, j)][j] += dp[used][i]

    return res


class Solution2(object):
    def numberOfPatterns(self, m, n):

    def merge(used, i):
        return used | (1 << i)

    def number_of_keys(i):
        number = 0
        while i > 0:
            i &= i - 1
            number += 1
        return number

    def exclude(used, i):
        return used & ~(1 << i)

    def contain(used, i):
        return bool(used & (1 << i))

    def convert(i, j):
        return 3 * i + j

    dp = [[0] * 9 for _ in xrange(1 << 9)]
    for i in xrange(9):
        dp[merge(0, i)][i] = 1

    res = 0
    for used in xrange(len(dp)):
        number = number_of_keys(used)
        if number > n:
            continue

        for i in xrange(9):
            if not contain(used, i):
                continue

            x1, y1 = divmod(i, 3)
            for j in xrange(9):
                if i == j or not contain(used, j):
                    continue

                x2, y2 = divmod(j, 3)
                if (
                    (x1 == x2 and abs(y1 - y2) == 2)
                    or (y1 == y2 and abs(x1 - x2) == 2)
                    or (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)
                ) and not contain(used, convert((x1 + x2) // 2, (y1 + y2) // 2)):
                    continue

                dp[used][i] += dp[exclude(used, i)][j]

            if m <= number <= n:
                res += dp[used][i]

    return res


class Solution_TLE(object):
    def numberOfPatterns(self, m, n):

    def merge(used, i):
        return used | (1 << i)

    def contain(used, i):
        return bool(used & (1 << i))

    def convert(i, j):
        return 3 * i + j

    def numberOfPatternsHelper(m, n, level, used, i):
        number = 0
        if level > n:
            return number

        if m <= level <= n:
            number += 1

        x1, y1 = divmod(i, 3)
        for j in xrange(9):
            if contain(used, j):
                continue

            x2, y2 = divmod(j, 3)
            if (
                (x1 == x2 and abs(y1 - y2) == 2)
                or (y1 == y2 and abs(x1 - x2) == 2)
                or (abs(x1 - x2) == 2 and abs(y1 - y2) == 2)
            ) and not contain(used, convert((x1 + x2) // 2, (y1 + y2) // 2)):
                continue

            number += numberOfPatternsHelper(m,
                                             n, level + 1, merge(used, j), j)

        return number

    number = 0

    number += 4 * numberOfPatternsHelper(m, n, 1, merge(0, 0), 0)

    number += 4 * numberOfPatternsHelper(m, n, 1, merge(0, 1), 1)

    number += numberOfPatternsHelper(m, n, 1, merge(0, 4), 4)
    return number


class Solution(object):
    def angleClock(self, hour, minutes):

    angle1 = (hour % 12 * 60.0 + minutes) / 720.0
    angle2 = minutes / 60.0
    diff = abs(angle1 - angle2)
    return min(diff, 1.0 - diff) * 360.0


class Cashier(object):
    def __init__(self, n, discount, products, prices):

    self.__n = n
    self.__discount = discount
    self.__curr = 0
    self.__lookup = {p: prices[i] for i, p in enumerate(products)}

    def getBill(self, product, amount):

    self.__curr = (self.__curr + 1) % self.__n
    result = 0.0
    for i, p in enumerate(product):
        result += self.__lookup[p] * amount[i]
    return result * (1.0 - self.__discount / 100.0 if self.__curr == 0 else 1.0)


import collections


class Solution(object):
    def numberOfArithmeticSlices(self, A):

    result = 0
    dp = [collections.defaultdict(int) for i in xrange(len(A))]
    for i in xrange(1, len(A)):
        for j in xrange(i):
            diff = A[i] - A[j]
            dp[i][diff] += 1
            if diff in dp[j]:
                dp[i][diff] += dp[j][diff]
                result += dp[j][diff]
    return result


class Solution(object):
    def numberOfArithmeticSlices(self, A):

    res, i = 0, 0
    while i + 2 < len(A):
        start = i
        while i + 2 < len(A) and A[i + 2] + A[i] == 2 * A[i + 1]:
            res += i - start + 1
            i += 1
        i += 1

    return res


import itertools


class Solution(object):
    def checkArithmeticSubarrays(self, nums, l, r):

    def is_arith(n):
        mx, mn, lookup = max(n), min(n), set(n)
        if mx == mn:
            return True
        d, r = divmod(mx - mn, len(n) - 1)
        if r:
            return False
        return all(i in lookup for i in xrange(mn, mx, d))

    result = []
    for left, right in itertools.izip(l, r):
        result.append(is_arith(nums[left: right + 1]))
    return result


class Solution(object):
    def isArmstrong(self, N):

    n_str = str(N)
    return sum(int(i) ** len(n_str) for i in n_str) == N


import math


class Solution(object):
    def arrangeCoins(self, n):

    return int((math.sqrt(8 * n + 1) - 1) / 2)


class Solution2(object):
    def arrangeCoins(self, n):

    def check(mid, n):
        return mid * (mid + 1) <= 2 * n

    left, right = 1, n
    while left <= right:
        mid = left + (right - left) // 2
        if not check(mid, n):
            right = mid - 1
        else:
            left = mid + 1
    return right


class Solution(object):
    def arrayNesting(self, nums):

    result = 0
    for num in nums:
        if num is not None:
            start, count = num, 0
            while nums[start] is not None:
                temp = start
                start = nums[start]
                nums[temp] = None
                count += 1
            result = max(result, count)
    return result


import collections


class Solution(object):
    def canReorderDoubled(self, A):

    count = collections.Counter(A)
    for x in sorted(count, key=abs):
        if count[x] > count[2 * x]:
            return False
        count[2 * x] -= count[x]
    return True


class Solution(object):
    def arrayPairSum(self, nums):

    LEFT, RIGHT = -10000, 10000
    lookup = [0] * (RIGHT - LEFT + 1)
    for num in nums:
        lookup[num - LEFT] += 1
    r, result = 0, 0
    for i in xrange(LEFT, RIGHT + 1):
        result += (lookup[i - LEFT] + 1 - r) / 2 * i
        r = (lookup[i - LEFT] + r) % 2
    return result


class Solution2(object):
    def arrayPairSum(self, nums):

    nums.sort()
    result = 0
    for i in xrange(0, len(nums), 2):
        result += nums[i]
    return result


class Solution3(object):
    def arrayPairSum(self, nums):

    nums = sorted(nums)
    return sum([nums[i] for i in range(0, len(nums), 2)])


class Solution(object):
    def transformArray(self, arr):

    def is_changable(arr):
        return any(
            arr[i - 1] > arr[i] < arr[i + 1] or arr[i - 1] < arr[i] > arr[i + 1]
            for i in xrange(1, len(arr) - 1)
        )

    while is_changable(arr):
        new_arr = arr[:]
        for i in xrange(1, len(arr) - 1):
            new_arr[i] += arr[i - 1] > arr[i] < arr[i + 1]
            new_arr[i] -= arr[i - 1] < arr[i] > arr[i + 1]
        arr = new_arr
    return arr


import collections


class Solution(object):
    def maxDistance(self, grid):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    q = collections.deque(
        [
            (i, j)
            for i in xrange(len(grid))
            for j in xrange(len(grid[0]))
            if grid[i][j] == 1
        ]
    )
    if len(q) == len(grid) * len(grid[0]):
        return -1
    level = -1
    while q:
        next_q = collections.deque()
        while q:
            x, y = q.popleft()
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if not (
                    0 <= nx < len(grid)
                    and 0 <= ny < len(grid[0])
                    and grid[nx][ny] == 0
                ):
                    continue
                next_q.append((nx, ny))
                grid[nx][ny] = 1
        q = next_q
        level += 1
    return level


class Solution(object):
    def findContentChildren(self, g, s):

    g.sort()
    s.sort()

    result, i = 0, 0
    for j in xrange(len(s)):
        if i == len(g):
            break
        if s[j] >= g[i]:
            result += 1
            i += 1
    return result


class Solution(object):
    def asteroidCollision(self, asteroids):

    result = []
    for asteroid in asteroids:
        while result and asteroid < 0 < result[-1]:
            if result[-1] < -asteroid:
                result.pop()
                continue
            elif result[-1] == -asteroid:
                result.pop()
            break
        else:
            result.append(asteroid)
    return result


class Solution(object):
    def numRookCaptures(self, board):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    r, c = None, None
    for i in xrange(8):
        if r is not None:
            break
        for j in xrange(8):
            if board[i][j] == "R":
                r, c = i, j
                break

    result = 0
    for d in directions:
        nr, nc = r + d[0], c + d[1]
        while 0 <= nr < 8 and 0 <= nc < 8:
            if board[nr][nc] == "p":
                result += 1
            if board[nr][nc] != ".":
                break
            nr, nc = nr + d[0], nc + d[1]
    return result


class Solution(object):
    def averageOfLevels(self, root):

    result = []
    q = [root]
    while q:
        total, count = 0, 0
        next_q = []
        for n in q:
            total += n.val
            count += 1
            if n.left:
                next_q.append(n.left)
            if n.right:
                next_q.append(n.right)
        q = next_q
        result.append(float(total) / count)
    return result


class Solution(object):
    def average(self, salary):

    total, mi, ma = 0, float("inf"), float("-inf")
    for s in salary:
        total += s
        mi, ma = min(mi, s), max(ma, s)
    return 1.0 * (total - mi - ma) / (len(salary) - 2)


class Solution2(object):
    def average(self, salary):

    return 1.0 * (sum(salary) - min(salary) - max(salary)) / (len(salary) - 2)


class Solution(object):
    def averageWaitingTime(self, customers):

    avai = wait = 0.0
    for a, t in customers:
        avai = max(avai, a) + t
        wait += avai - a
    return wait / len(customers)


import collections
import heapq


class Solution(object):
    def avoidFlood(self, rains):

    lookup = collections.defaultdict(list)
    i = len(rains) - 1
    for lake in reversed(rains):
        lookup[lake].append(i)
        i -= 1
    result, min_heap = [], []
    for i, lake in enumerate(rains):
        if lake:
            if len(lookup[lake]) >= 2:
                lookup[lake].pop()
                heapq.heappush(min_heap, lookup[lake][-1])
            result.append(-1)
        elif min_heap:
            j = heapq.heappop(min_heap)
            if j < i:
                return []
            result.append(rains[j])
        else:
            result.append(1)
    return result if not min_heap else []


import itertools


class Solution(object):
    def backspaceCompare(self, S, T):

    def findNextChar(S):
        skip = 0
        for i in reversed(xrange(len(S))):
            if S[i] == "#":
                skip += 1
            elif skip:
                skip -= 1
            else:
                yield S[i]

    return all(
        x == y for x, y in itertools.izip_longest(findNextChar(S), findNextChar(T))
    )


class Solution(object):
    def bagOfTokensScore(self, tokens, P):

    tokens.sort()
    result, points = 0, 0
    left, right = 0, len(tokens) - 1
    while left <= right:
        if P >= tokens[left]:
            P -= tokens[left]
            left += 1
            points += 1
            result = max(result, points)
        elif points > 0:
            points -= 1
            P += tokens[right]
            right -= 1
        else:
            break
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def balanceBST(self, root):

    def inorderTraversal(root):
        result, stk = [], [(root, False)]
        while stk:
            node, is_visited = stk.pop()
            if node is None:
                continue
            if is_visited:
                result.append(node.val)
            else:
                stk.append((node.right, False))
                stk.append((node, True))
                stk.append((node.left, False))
        return result

    def sortedArrayToBst(arr):
        ROOT, LEFT, RIGHT = range(3)
        result = [None]
        stk = [(0, len(arr), ROOT, result)]
        while stk:
            i, j, update, ret = stk.pop()
            if i >= j:
                continue
            mid = i + (j - i) // 2
            node = TreeNode(arr[mid])
            if update == ROOT:
                ret[0] = node
            elif update == LEFT:
                ret[0].left = node
            else:
                ret[0].right = node
            stk.append((mid + 1, j, RIGHT, [node]))
            stk.append((i, mid, LEFT, [node]))
        return result[0]

    return sortedArrayToBst(inorderTraversal(root))


class Solution2(object):
    def balanceBST(self, root):

    def inorderTraversalHelper(node, arr):
        if not node:
            return
        inorderTraversalHelper(node.left, arr)
        arr.append(node.val)
        inorderTraversalHelper(node.right, arr)

    def sortedArrayToBstHelper(arr, i, j):
        if i >= j:
            return None
        mid = i + (j - i) // 2
        node = TreeNode(arr[mid])
        node.left = sortedArrayToBstHelper(arr, i, mid)
        node.right = sortedArrayToBstHelper(arr, mid + 1, j)
        return node

    arr = []
    inorderTraversalHelper(root, arr)
    return sortedArrayToBstHelper(arr, 0, len(arr))


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def isBalanced(self, root):

    def getHeight(root):
        if root is None:
            return 0
        left_height, right_height = getHeight(root.left), getHeight(root.right)
        if (
            left_height < 0
            or right_height < 0
            or abs(left_height - right_height) > 1
        ):
            return -1
        return max(left_height, right_height) + 1

    return getHeight(root) >= 0


class Solution(object):
    def convertToBase7(self, num):
    if num < 0:
        return "-" + self.convertToBase7(-num)
    result = ""
    while num:
        result = str(num % 7) + result
        num //= 7
    return result if result else "0"


class Solution2(object):
    def convertToBase7(self, num):

    if num < 0:
        return "-" + self.convertToBase7(-num)
    if num < 7:
        return str(num)
    return self.convertToBase7(num // 7) + str(num % 7)


class Solution(object):
    def calPoints(self, ops):

    history = []
    for op in ops:
        if op == "+":
            history.append(history[-1] + history[-2])
        elif op == "D":
            history.append(history[-1] * 2)
        elif op == "C":
            history.pop()
        else:
            history.append(int(op))
    return sum(history)


import operator


class Solution(object):
    def calculate(self, s):

    def compute(operands, operators):
        right, left = operands.pop(), operands.pop()
        operands.append(ops[operators.pop()](left, right))

    ops = {
        "+": operator.add,
        "-": operator.sub,
        "*": operator.mul,
        "/": operator.div,
    }
    precedence = {"+": 0, "-": 0, "*": 1, "/": 1}
    operands, operators, operand = [], [], 0
    for i in xrange(len(s)):
        if s[i].isdigit():
            operand = operand * 10 + int(s[i])
            if i == len(s) - 1 or not s[i + 1].isdigit():
                operands.append(operand)
                operand = 0
        elif s[i] == "(":
            operators.append(s[i])
        elif s[i] == ")":
            while operators[-1] != "(":
                compute(operands, operators)
            operators.pop()
        elif s[i] in precedence:
            while (
                operators
                and operators[-1] in precedence
                and precedence[operators[-1]] >= precedence[s[i]]
            ):
                compute(operands, operators)
            operators.append(s[i])
    while operators:
        compute(operands, operators)
    return operands[-1]


class Solution2(object):

    def calculate(self, s):
    operands, operators = [], []
    operand = ""
    for i in reversed(xrange(len(s))):
        if s[i].isdigit():
            operand += s[i]
            if i == 0 or not s[i - 1].isdigit():
                operands.append(int(operand[::-1]))
                operand = ""
        elif s[i] == ")" or s[i] == "*" or s[i] == "/":
            operators.append(s[i])
        elif s[i] == "+" or s[i] == "-":
            while operators and (operators[-1] == "*" or operators[-1] == "/"):
                self.compute(operands, operators)
            operators.append(s[i])
        elif s[i] == "(":
            while operators[-1] != ")":
                self.compute(operands, operators)
            operators.pop()

    while operators:
        self.compute(operands, operators)

    return operands[-1]

    def compute(self, operands, operators):
    left, right = operands.pop(), operands.pop()
    op = operators.pop()
    if op == "+":
        operands.append(left + right)
    elif op == "-":
        operands.append(left - right)
    elif op == "*":
        operands.append(left * right)
    elif op == "/":
        operands.append(left / right)


import operator


class Solution(object):
    def calculate(self, s):

    def compute(operands, operators):
        right, left = operands.pop(), operands.pop()
        operands.append(ops[operators.pop()](left, right))

    ops = {
        "+": operator.add,
        "-": operator.sub,
        "*": operator.mul,
        "/": operator.div,
    }
    precedence = {"+": 0, "-": 0, "*": 1, "/": 1}
    operands, operators, operand = [], [], 0
    for i in xrange(len(s)):
        if s[i].isdigit():
            operand = operand * 10 + int(s[i])
            if i == len(s) - 1 or not s[i + 1].isdigit():
                operands.append(operand)
                operand = 0
        elif s[i] == "(":
            operators.append(s[i])
        elif s[i] == ")":
            while operators[-1] != "(":
                compute(operands, operators)
            operators.pop()
        elif s[i] in precedence:
            while (
                operators
                and operators[-1] in precedence
                and precedence[operators[-1]] >= precedence[s[i]]
            ):
                compute(operands, operators)
            operators.append(s[i])
    while operators:
        compute(operands, operators)
    return operands[-1]


class Solution2(object):
    def calculate(self, s):

    operands, operators = [], []
    operand = ""
    for i in reversed(xrange(len(s))):
        if s[i].isdigit():
            operand += s[i]
            if i == 0 or not s[i - 1].isdigit():
                operands.append(int(operand[::-1]))
                operand = ""
        elif s[i] == ")" or s[i] == "*" or s[i] == "/":
            operators.append(s[i])
        elif s[i] == "+" or s[i] == "-":
            while operators and (operators[-1] == "*" or operators[-1] == "/"):
                self.compute(operands, operators)
            operators.append(s[i])
        elif s[i] == "(":
            while operators[-1] != ")":
                self.compute(operands, operators)
            operators.pop()

    while operators:
        self.compute(operands, operators)

    return operands[-1]

    def compute(self, operands, operators):
    left, right = operands.pop(), operands.pop()
    op = operators.pop()
    if op == "+":
        operands.append(left + right)
    elif op == "-":
        operands.append(left - right)
    elif op == "*":
        operands.append(left * right)
    elif op == "/":
        operands.append(left / right)


import collections
import itertools
import operator


class Poly(collections.Counter):
    def __init__(self, expr=None):
    if expr is None:
        return
    if expr.isdigit():
        self.update({(): int(expr)})
    else:
        self[(expr,)] += 1

    def __add__(self, other):
    self.update(other)
    return self

    def __sub__(self, other):
    self.update({k: -v for k, v in other.iteritems()})
    return self

    def __mul__(self, other):

    def merge(k1, k2):
        result = []
        i, j = 0, 0
        while i != len(k1) or j != len(k2):
            if j == len(k2):
                result.append(k1[i])
                i += 1
            elif i == len(k1):
                result.append(k2[j])
                j += 1
            elif k1[i] < k2[j]:
                result.append(k1[i])
                i += 1
            else:
                result.append(k2[j])
                j += 1
        return result

    result = Poly()
    for k1, v1 in self.iteritems():
        for k2, v2 in other.iteritems():
            result.update({tuple(merge(k1, k2)): v1 * v2})
    return result

    def eval(self, lookup):
    result = Poly()
    for polies, c in self.iteritems():
        key = []
        for var in polies:
            if var in lookup:
                c *= lookup[var]
            else:
                key.append(var)
        result[tuple(key)] += c
    return result

    def to_list(self):
    return [
        "*".join((str(v),) + k)
        for k, v in sorted(self.iteritems(), key=lambda x: (-len(x[0]), x[0]))
        if v
    ]


class Solution(object):
    def basicCalculatorIV(self, expression, evalvars, evalints):

    ops = {"+": operator.add, "-": operator.sub, "*": operator.mul}

    def compute(operands, operators):
        right, left = operands.pop(), operands.pop()
        operands.append(ops[operators.pop()](left, right))

    def parse(s):
        precedence = {"+": 0, "-": 0, "*": 1}
        operands, operators, operand = [], [], []
        for i in xrange(len(s)):
            if s[i].isalnum():
                operand.append(s[i])
                if i == len(s) - 1 or not s[i + 1].isalnum():
                    operands.append(Poly("".join(operand)))
                    operand = []
            elif s[i] == "(":
                operators.append(s[i])
            elif s[i] == ")":
                while operators[-1] != "(":
                    compute(operands, operators)
                operators.pop()
            elif s[i] in precedence:
                while (
                    operators
                    and operators[-1] in precedence
                    and precedence[operators[-1]] >= precedence[s[i]]
                ):
                    compute(operands, operators)
                operators.append(s[i])
        while operators:
            compute(operands, operators)
        return operands[-1]

    lookup = dict(itertools.izip(evalvars, evalints))
    return parse(expression).eval(lookup).to_list()


class Solution2(object):
    def basicCalculatorIV(self, expression, evalvars, evalints):

    def compute(operands, operators):
        left, right = operands.pop(), operands.pop()
        op = operators.pop()
        if op == "+":
            operands.append(left + right)
        elif op == "-":
            operands.append(left - right)
        elif op == "*":
            operands.append(left * right)

    def parse(s):
        if not s:
            return Poly()
        operands, operators = [], []
        operand = ""
        for i in reversed(xrange(len(s))):
            if s[i].isalnum():
                operand += s[i]
                if i == 0 or not s[i - 1].isalnum():
                    operands.append(Poly(operand[::-1]))
                    operand = ""
            elif s[i] == ")" or s[i] == "*":
                operators.append(s[i])
            elif s[i] == "+" or s[i] == "-":
                while operators and operators[-1] == "*":
                    compute(operands, operators)
                operators.append(s[i])
            elif s[i] == "(":
                while operators[-1] != ")":
                    compute(operands, operators)
                operators.pop()
        while operators:
            compute(operands, operators)
        return operands[-1]

    lookup = dict(itertools.izip(evalvars, evalints))
    return parse(expression).eval(lookup).to_list()


import operator


class Solution(object):
    def calculate(self, s):

    def compute(operands, operators):
        right, left = operands.pop(), operands.pop()
        operands.append(ops[operators.pop()](left, right))

    ops = {
        "+": operator.add,
        "-": operator.sub,
        "*": operator.mul,
        "/": operator.div,
    }
    precedence = {"+": 0, "-": 0, "*": 1, "/": 1}
    operands, operators, operand = [], [], 0
    for i in xrange(len(s)):
        if s[i].isdigit():
            operand = operand * 10 + int(s[i])
            if i == len(s) - 1 or not s[i + 1].isdigit():
                operands.append(operand)
                operand = 0
        elif s[i] == "(":
            operators.append(s[i])
        elif s[i] == ")":
            while operators[-1] != "(":
                compute(operands, operators)
            operators.pop()
        elif s[i] in precedence:
            while (
                operators
                and operators[-1] in precedence
                and precedence[operators[-1]] >= precedence[s[i]]
            ):
                compute(operands, operators)
            operators.append(s[i])
    while operators:
        compute(operands, operators)
    return operands[-1]


class Solution2(object):

    def calculate(self, s):
    operands, operators = [], []
    operand = ""
    for i in reversed(xrange(len(s))):
        if s[i].isdigit():
            operand += s[i]
            if i == 0 or not s[i - 1].isdigit():
                operands.append(int(operand[::-1]))
                operand = ""
        elif s[i] == ")" or s[i] == "+" or s[i] == "-":
            operators.append(s[i])
        elif s[i] == "(":
            while operators[-1] != ")":
                self.compute(operands, operators)
            operators.pop()

    while operators:
        self.compute(operands, operators)

    return operands[-1]

    def compute(self, operands, operators):
    left, right = operands.pop(), operands.pop()
    op = operators.pop()
    if op == "+":
        operands.append(left + right)
    elif op == "-":
        operands.append(left - right)


class Solution(object):
    def countBattleships(self, board):

    if not board or not board[0]:
        return 0

    cnt = 0
    for i in xrange(len(board)):
        for j in xrange(len(board[0])):
            cnt += int(
                board[i][j] == "X"
                and (i == 0 or board[i - 1][j] != "X")
                and (j == 0 or board[i][j - 1] != "X")
            )
    return cnt


class Solution(object):
    def constructArray(self, n, k):

    result = []
    left, right = 1, n
    while left <= right:
        if k % 2:
            result.append(left)
            left += 1
        else:
            result.append(right)
            right -= 1
        if k > 1:
            k -= 1
    return result


class Solution(object):
    def countArrangement(self, N):

    def countArrangementHelper(n, arr):
        if n <= 0:
            return 1
        count = 0
        for i in xrange(n):
            if arr[i] % n == 0 or n % arr[i] == 0:
                arr[i], arr[n - 1] = arr[n - 1], arr[i]
                count += countArrangementHelper(n - 1, arr)
                arr[i], arr[n - 1] = arr[n - 1], arr[i]
        return count

    return countArrangementHelper(N, range(1, N + 1))


class Solution(object):
    def beautifulArray(self, N):

    result = [1]
    while len(result) < N:
        result = [i * 2 - 1 for i in result] + [i * 2 for i in result]
    return [i for i in result if i <= N]


import collections


class Solution(object):
    def beforeAndAfterPuzzles(self, phrases):

    lookup = collections.defaultdict(list)
    for i, phrase in enumerate(phrases):
        right = phrase.rfind(" ")
        word = phrase if right == -1 else phrase[right + 1:]
        lookup[word].append(i)

    result_set = set()
    for i, phrase in enumerate(phrases):
        left = phrase.find(" ")
        word = phrase if left == -1 else phrase[:left]
        if word not in lookup:
            continue
        for j in lookup[word]:
            if j == i:
                continue
            result_set.add(phrases[j] + phrase[len(word):])
    return sorted(result_set)


from random import randint


class Solution(object):
    def minTotalDistance(self, grid):

    x = [i for i, row in enumerate(grid) for v in row if v == 1]
    y = [j for row in grid for j, v in enumerate(row) if v == 1]
    mid_x = self.findKthLargest(x, len(x) / 2 + 1)
    mid_y = self.findKthLargest(y, len(y) / 2 + 1)

    return sum(
        [
            abs(mid_x - i) + abs(mid_y - j)
            for i, row in enumerate(grid)
            for j, v in enumerate(row)
            if v == 1
        ]
    )

    def findKthLargest(self, nums, k):
    left, right = 0, len(nums) - 1
    while left <= right:
        pivot_idx = randint(left, right)
        new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums)
        if new_pivot_idx == k - 1:
            return nums[new_pivot_idx]
        elif new_pivot_idx > k - 1:
            right = new_pivot_idx - 1
        else:
            left = new_pivot_idx + 1

    def PartitionAroundPivot(self, left, right, pivot_idx, nums):
    pivot_value = nums[pivot_idx]
    new_pivot_idx = left
    nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
    for i in xrange(left, right):
        if nums[i] > pivot_value:
            nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
            new_pivot_idx += 1

    nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
    return new_pivot_idx


class Solution(object):
    def getMinDistSum(self, positions):

    EPS = 1e-6

    def norm(p1, p2):
        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5

    def geometry_median(positions, median):
        numerator, denominator = [0.0, 0.0], 0.0
        for p in positions:
            l = norm(median, p)
            if not l:
                continue
            numerator[0] += p[0] / l
            numerator[1] += p[1] / l
            denominator += 1 / l
        if denominator == 0.0:
            return True, None
        return False, [numerator[0] / denominator, numerator[1] / denominator]

    median = [
        float(sum(p[0] for p in positions)) / len(positions),
        float(sum(p[1] for p in positions)) / len(positions),
    ]
    prev_median = [float("-inf"), float("-inf")]
    while norm(median, prev_median) * len(positions) > EPS:
        stopped, new_median = geometry_median(positions, median)
        if stopped:
            break
        median, prev_median = new_median, median
    return sum(norm(median, p) for p in positions)


class Solution2(object):
    def getMinDistSum(self, positions):

    DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    EPS = 1e-6

    def dist(positions, p):
        return sum(((p[0] - x) ** 2 + (p[1] - y) ** 2) ** 0.5 for x, y in positions)

    median = [0.0, 0.0]
    median[0] = float(sum(x for x, _ in positions)) / len(positions)
    median[1] = float(sum(y for _, y in positions)) / len(positions)
    result = dist(positions, median)
    delta = float(
        max(
            max(positions, key=lambda x: x[0])[0],
            max(positions, key=lambda x: x[1])[1],
        )
    ) - float(
        min(
            min(positions, key=lambda x: x[0])[0],
            min(positions, key=lambda x: x[1])[1],
        )
    )
    while delta > EPS:
        for dx, dy in DIRECTIONS:
            new_median = [median[0] + delta * dx, median[1] + delta * dy]
            nd = dist(positions, new_median)
            if nd < result:
                result = nd
                median = new_median
                break
        else:
            delta /= 2.0
    return result


class Solution(object):
    def maxScoreSightseeingPair(self, A):

    result, curr = 0, 0
    for x in A:
        result = max(result, curr + x)
        curr = max(curr, x) - 1
    return result


class SegmentTree(object):
    def __init__(
        self,
        N,
        build_fn=lambda x, y: [y] * (2 * x),
        query_fn=lambda x, y: y
        if x is None
        else max(x, y),
        update_fn=lambda x, y: y,
        default_val=0,
    ):
    self.N = N
    self.H = (N - 1).bit_length()
    self.query_fn = query_fn
    self.update_fn = update_fn
    self.default_val = default_val
    self.tree = build_fn(N, default_val)
    self.lazy = [None] * N

    def __apply(self, x, val):
    self.tree[x] = self.update_fn(self.tree[x], val)
    if x < self.N:
        self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h):

    def pull(x):
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(
                self.tree[x * 2], self.tree[x * 2 + 1])
            if self.lazy[x] is not None:
                self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

    L += self.N
    R += self.N
    L0, R0 = L, R
    while L <= R:
        if L & 1:
            self.__apply(L, h)
            L += 1
        if R & 1 == 0:
            self.__apply(R, h)
            R -= 1
        L //= 2
        R //= 2
    pull(L0)
    pull(R0)

    def query(self, L, R):

    def push(x):
        n = 2 ** self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y * 2, self.lazy[y])
                self.__apply(y * 2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    result = None
    if L > R:
        return result

    L += self.N
    R += self.N
    push(L)
    push(R)
    while L <= R:
        if L & 1:
            result = self.query_fn(result, self.tree[L])
            L += 1
        if R & 1 == 0:
            result = self.query_fn(result, self.tree[R])
            R -= 1
        L //= 2
        R //= 2
    return result

    def __str__(self):
    showList = []
    for i in xrange(self.N):
        showList.append(self.query(i, i))
    return ",".join(map(str, showList))


class Solution(object):
    def bestTeamScore(self, scores, ages):

    players = sorted(zip(scores, ages))
    sorted_ages = sorted(set(ages))
    lookup = {age: i for i, age in enumerate(sorted_ages)}
    segment_tree = SegmentTree(len(lookup))
    result = 0
    for score, age in players:
        segment_tree.update(
            lookup[age], lookup[age], segment_tree.query(
                0, lookup[age]) + score
        )
    return segment_tree.query(0, len(lookup) - 1)


class Solution2(object):
    def bestTeamScore(self, scores, ages):

    players = sorted(zip(ages, scores))
    sorted_scores = sorted(set(scores))
    lookup = {
        score: i for i, score in enumerate(sorted_scores)
    }
    segment_tree = SegmentTree(len(lookup))
    result = 0
    for age, score in players:
        segment_tree.update(
            lookup[score],
            lookup[score],
            segment_tree.query(0, lookup[score]) + score,
        )
    return segment_tree.query(0, len(lookup) - 1)


import collections


class Solution3(object):
    def bestTeamScore(self, scores, ages):

    players = sorted(zip(scores, ages))
    sorted_ages = sorted(set(ages))
    dp = collections.defaultdict(int)
    result = 0
    for score, age in players:
        dp[age] = max(dp[a] for a in sorted_ages if a <= age) + score
    return max(dp.itervalues())


import collections


class Solution4(object):
    def bestTeamScore(self, scores, ages):

    players = sorted(zip(ages, scores))
    sorted_scores = sorted(set(scores))
    dp = collections.defaultdict(int)
    result = 0
    for age, score in players:
        dp[score] = max(dp[s] for s in sorted_scores if s <= score) + score
    return max(dp.itervalues())


class Solution5(object):
    def bestTeamScore(self, scores, ages):

    players = sorted(zip(scores, ages))
    dp = [0] * len(players)
    result = 0
    for i in xrange(len(players)):
        dp[i] = players[i][0]
        for j in xrange(i):
            if players[j][1] <= players[i][1]:
                dp[i] = max(dp[i], dp[j] + players[i][0])
        result = max(result, dp[i])
    return result


class Solution6(object):
    def bestTeamScore(self, scores, ages):

    players = sorted(zip(ages, scores))
    dp = [0] * len(players)
    result = 0
    for i in xrange(len(players)):
        dp[i] = players[i][1]
        for j in xrange(i):
            if players[j][1] <= players[i][1]:
                dp[i] = max(dp[i], dp[j] + players[i][1])
        result = max(result, dp[i])
    return result


class Solution(object):

    def maxProfit(self, prices):
    profit = 0
    for i in xrange(len(prices) - 1):
        profit += max(0, prices[i + 1] - prices[i])
    return profit

    def maxProfit2(self, prices):
    return sum(
        map(lambda x: max(prices[x + 1] - prices[x], 0),
            xrange(len(prices[:-1])))
    )


class Solution(object):
    def maxProfit(self, prices):

    hold1, hold2 = float("-inf"), float("-inf")
    release1, release2 = 0, 0
    for i in prices:
        release1 = max(release1, hold1 + i)
        hold1 = max(hold1, -i)
        release2 = max(release2, hold2 + i)
        hold2 = max(hold2, release1 - i)
    return release2


class Solution2(object):
    def maxProfit(self, prices):

    def maxAtMostKPairsProfit(prices, k):
        max_buy = [float("-inf") for _ in xrange(k + 1)]
        max_sell = [0 for _ in xrange(k + 1)]
        for i in xrange(len(prices)):
            for j in xrange(1, k + 1):
                max_buy[j] = max(max_buy[j], max_sell[j - 1] - prices[i])
                max_sell[j] = max(max_sell[j], max_buy[j] + prices[i])
        return max_sell[k]

    return maxAtMostKPairsProfit(prices, 2)


class Solution3(object):

    def maxProfit(self, prices):
    min_price, max_profit_from_left, max_profits_from_left = float("inf"), 0, [
    ]
    for price in prices:
        min_price = min(min_price, price)
        max_profit_from_left = max(max_profit_from_left, price - min_price)
        max_profits_from_left.append(max_profit_from_left)

    max_price, max_profit_from_right, max_profits_from_right = 0, 0, []
    for i in reversed(range(len(prices))):
        max_price = max(max_price, prices[i])
        max_profit_from_right = max(
            max_profit_from_right, max_price - prices[i])
        max_profits_from_right.insert(0, max_profit_from_right)

    max_profit = 0
    for i in range(len(prices)):
        max_profit = max(
            max_profit, max_profits_from_left[i] + max_profits_from_right[i]
        )

    return max_profit


import random


class Solution(object):
    def maxProfit(self, k, prices):

    def nth_element(nums, n, compare=lambda a, b: a < b):
        def tri_partition(nums, left, right, target, compare):
            mid = left
            while mid <= right:
                if nums[mid] == target:
                    mid += 1
                elif compare(nums[mid], target):
                    nums[left], nums[mid] = nums[mid], nums[left]
                    left += 1
                    mid += 1
                else:
                    nums[mid], nums[right] = nums[right], nums[mid]
                    right -= 1
            return left, right

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            pivot_left, pivot_right = tri_partition(
                nums, left, right, nums[pivot_idx], compare
            )
            if pivot_left <= n <= pivot_right:
                return
            elif pivot_left > n:
                right = pivot_left - 1
            else:
                left = pivot_right + 1

    profits = []
    v_p_stk = []
    v, p = -1, -1
    while p + 1 < len(
        prices
    ):
        for v in xrange(p + 1, len(prices) - 1):
            if prices[v] < prices[v + 1]:
                break
        else:
            v = len(prices) - 1
        for p in xrange(v, len(prices) - 1):
            if prices[p] > prices[p + 1]:
                break
        else:
            p = len(prices) - 1
        while v_p_stk and prices[v_p_stk[-1][0]] > prices[v]:
            last_v, last_p = v_p_stk.pop()
            profits.append(
                prices[last_p] - prices[last_v]
            )
        while v_p_stk and prices[v_p_stk[-1][1]] <= prices[p]:

            last_v, last_p = v_p_stk.pop()
            profits.append(
                prices[last_p] - prices[v]
            )
            v = last_v
        v_p_stk.append(
            (v, p)
        )
    while v_p_stk:
        last_v, last_p = v_p_stk.pop()
        profits.append(
            prices[last_p] - prices[last_v]
        )
    if k > len(profits):
        k = len(profits)
    else:
        nth_element(profits, k - 1, compare=lambda a, b: a > b)
    return sum(
        profits[i] for i in xrange(k)
    )


class Solution2(object):
    def maxProfit(self, k, prices):

    def maxAtMostNPairsProfit(sprices):
        profit = 0
        for i in xrange(len(prices) - 1):
            profit += max(0, prices[i + 1] - prices[i])
        return profit

    def maxAtMostKPairsProfit(prices, k):
        max_buy = [float("-inf") for _ in xrange(k + 1)]
        max_sell = [0 for _ in xrange(k + 1)]
        for i in xrange(len(prices)):
            for j in xrange(1, k + 1):
                max_buy[j] = max(max_buy[j], max_sell[j - 1] - prices[i])
                max_sell[j] = max(max_sell[j], max_buy[j] + prices[i])
        return max_sell[k]

    if k >= len(prices) // 2:
        return maxAtMostNPairsProfit(prices)

    return maxAtMostKPairsProfit(prices, k)


class Solution(object):
    def maxProfit(self, prices):

    if not prices:
        return 0
    buy, sell, coolDown = [0] * 2, [0] * 2, [0] * 2
    buy[0] = -prices[0]
    for i in xrange(1, len(prices)):

        buy[i % 2] = max(buy[(i - 1) % 2], coolDown[(i - 1) % 2] - prices[i])

        sell[i % 2] = buy[(i - 1) % 2] + prices[i]

        coolDown[i % 2] = max(coolDown[(i - 1) % 2], sell[(i - 1) % 2])
    return max(coolDown[(len(prices) - 1) % 2], sell[(len(prices) - 1) % 2])


class Solution(object):
    def maxProfit(self, prices, fee):

    cash, hold = 0, -prices[0]
    for i in xrange(1, len(prices)):
        cash = max(cash, hold + prices[i] - fee)
        hold = max(hold, cash - prices[i])
    return cash


class Solution(object):

    def maxProfit(self, prices):
    max_profit, min_price = 0, float("inf")
    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)
    return max_profit


class Solution(object):
    def binaryGap(self, N):

    result = 0
    last = None
    for i in xrange(32):
        if (N >> i) & 1:
            if last is not None:
                result = max(result, i - last)
            last = i
    return result


class Solution(object):
    def hasAlternatingBits(self, n):

    n, curr = divmod(n, 2)
    while n > 0:
        if curr == n % 2:
            return False
        n, curr = divmod(n, 2)
    return True


class Solution(object):
    def prefixesDivBy5(self, A):

    for i in xrange(1, len(A)):
        A[i] += A[i - 1] * 2 % 5
    return [x % 5 == 0 for x in A]


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    self.val = val
    self.left = left
    self.right = right


class BSTIterator(object):
    def __init__(self, root):

    self.__stk = []
    self.__traversalLeft(root)
    self.__vals = []
    self.__pos = -1

    def hasNext(self):

    return self.__pos + 1 != len(self.__vals) or self.__stk

    def next(self):

    self.__pos += 1
    if self.__pos == len(self.__vals):
        node = self.__stk.pop()
        self.__traversalLeft(node.right)
        self.__vals.append(node.val)
    return self.__vals[self.__pos]

    def hasPrev(self):

    return self.__pos - 1 >= 0

    def prev(self):

    self.__pos -= 1
    return self.__vals[self.__pos]

    def __traversalLeft(self, node):
    while node is not None:
        self.__stk.append(node)
        node = node.left


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class BSTIterator(object):

    def __init__(self, root):
    self.__stk = []
    self.__traversalLeft(root)

    def hasNext(self):
    return self.__stk

    def next(self):
    node = self.__stk.pop()
    self.__traversalLeft(node.right)
    return node.val

    def __traversalLeft(self, node):
    while node is not None:
        self.__stk.append(node)
        node = node.left


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def bstToGst(self, root):

    def bstToGstHelper(root, prev):
        if not root:
            return root
        bstToGstHelper(root.right, prev)
        root.val += prev[0]
        prev[0] = root.val
        bstToGstHelper(root.left, prev)
        return root

    prev = [0]
    return bstToGstHelper(root, prev)


class Solution(object):
    def search(self, nums, target):

    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] > target:
            right = mid - 1
        elif nums[mid] < target:
            left = mid + 1
        else:
            return mid
    return -1


class Solution(object):
    def queryString(self, S, N):

    return all(bin(i)[2:] in S for i in reversed(xrange(N // 2, N + 1)))


class Solution(object):
    def numSubarraysWithSum(self, A, S):

    result = 0
    left, right, sum_left, sum_right = 0, 0, 0, 0
    for i, a in enumerate(A):
        sum_left += a
        while left < i and sum_left > S:
            sum_left -= A[left]
            left += 1
        sum_right += a
        while right < i and (sum_right > S or (sum_right == S and not A[right])):
            sum_right -= A[right]
            right += 1
        if sum_left == S:
            result += right - left + 1
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def minCameraCover(self, root):

    UNCOVERED, COVERED, CAMERA = range(3)

    def dfs(root, result):
        left = dfs(root.left, result) if root.left else COVERED
        right = dfs(root.right, result) if root.right else COVERED
        if left == UNCOVERED or right == UNCOVERED:
            result[0] += 1
            return CAMERA
        if left == CAMERA or right == CAMERA:
            return COVERED
        return UNCOVERED

    result = [0]
    if dfs(root, result) == UNCOVERED:
        result[0] += 1
    return result[0]


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def btreeGameWinningMove(self, root, n, x):

    def count(node, x, left_right):
        if not node:
            return 0
        left, right = count(node.left, x, left_right), count(
            node.right, x, left_right
        )
        if node.val == x:
            left_right[0], left_right[1] = left, right
        return left + right + 1

    left_right = [0, 0]
    count(root, x, left_right)
    blue = max(max(left_right), n - (sum(left_right) + 1))
    return blue > n - blue


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def inorderTraversal(self, root):

    result, curr = [], root
    while curr:
        if curr.left is None:
            result.append(curr.val)
            curr = curr.right
        else:
            node = curr.left
            while node.right and node.right != curr:
                node = node.right

            if node.right is None:
                node.right = curr
                curr = curr.left
            else:
                result.append(curr.val)
                node.right = None
                curr = curr.right

    return result


class Solution2(object):
    def inorderTraversal(self, root):

    result, stack = [], [(root, False)]
    while stack:
        root, is_visited = stack.pop()
        if root is None:
            continue
        if is_visited:
            result.append(root.val)
        else:
            stack.append((root.right, False))
            stack.append((root, True))
            stack.append((root.left, False))
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def levelOrderBottom(self, root):

    if root is None:
        return []

    result, current = [], [root]
    while current:
        next_level, vals = [], []
        for node in current:
            vals.append(node.val)
            if node.left:
                next_level.append(node.left)
            if node.right:
                next_level.append(node.right)
        current = next_level
        result.append(vals)

    return result[::-1]


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def levelOrder(self, root):
    if root is None:
        return []
    result, current = [], [root]
    while current:
        next_level, vals = [], []
        for node in current:
            vals.append(node.val)
            if node.left:
                next_level.append(node.left)
            if node.right:
                next_level.append(node.right)
        current = next_level
        result.append(vals)
    return result


class Solution(object):
    def longestConsecutive(self, root):

    def longestConsecutiveHelper(root):
        if not root:
            return 0, 0
        left_len = longestConsecutiveHelper(root.left)
        right_len = longestConsecutiveHelper(root.right)
        cur_inc_len, cur_dec_len = 1, 1
        if root.left:
            if root.left.val == root.val + 1:
                cur_inc_len = max(cur_inc_len, left_len[0] + 1)
            elif root.left.val == root.val - 1:
                cur_dec_len = max(cur_dec_len, left_len[1] + 1)
        if root.right:
            if root.right.val == root.val + 1:
                cur_inc_len = max(cur_inc_len, right_len[0] + 1)
            elif root.right.val == root.val - 1:
                cur_dec_len = max(cur_dec_len, right_len[1] + 1)
        self.max_len = max(self.max_len, cur_dec_len + cur_inc_len - 1)
        return cur_inc_len, cur_dec_len

    self.max_len = 0
    longestConsecutiveHelper(root)
    return self.max_len


class Solution(object):
    def longestConsecutive(self, root):

    self.max_len = 0

    def longestConsecutiveHelper(root):
        if not root:
            return 0

        left_len = longestConsecutiveHelper(root.left)
        right_len = longestConsecutiveHelper(root.right)

        cur_len = 1
        if root.left and root.left.val == root.val + 1:
            cur_len = max(cur_len, left_len + 1)
        if root.right and root.right.val == root.val + 1:
            cur_len = max(cur_len, right_len + 1)

        self.max_len = max(self.max_len, cur_len)

        return cur_len

    longestConsecutiveHelper(root)
    return self.max_len


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def maxPathSum(self, root):

    def iter_dfs(node):
        result = float("-inf")
        max_sum = [0]
        stk = [(1, [node, max_sum])]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, ret = params
                if not node:
                    continue
                ret1, ret2 = [0], [0]
                stk.append((2, [node, ret1, ret2, ret]))
                stk.append((1, [node.right, ret2]))
                stk.append((1, [node.left, ret1]))
            elif step == 2:
                node, ret1, ret2, ret = params
                result = max(result, node.val +
                             max(ret1[0], 0) + max(ret2[0], 0))
                ret[0] = node.val + max(ret1[0], ret2[0], 0)
        return result

    return iter_dfs(root)


class Solution2(object):

    def maxPathSum(self, root):

    def dfs(node):
        if not node:
            return (float("-inf"), 0)
        max_left, curr_left = dfs(node.left)
        max_right, curr_right = dfs(node.right)
        return (
            max(
                max_left,
                max_right,
                node.val + max(curr_left, 0) + max(curr_right, 0),
            ),
            node.val + max(curr_left, curr_right, 0),
        )

    return dfs(root)[0]


class Solution(object):

    def binaryTreePaths(self, root):
    result, path = [], []
    self.binaryTreePathsRecu(root, path, result)
    return result

    def binaryTreePathsRecu(self, node, path, result):
    if node is None:
        return

    if node.left is node.right is None:
        ans = ""
        for n in path:
            ans += str(n.val) + "->"
        result.append(ans + str(node.val))

    if node.left:
        path.append(node)
        self.binaryTreePathsRecu(node.left, path, result)
        path.pop()

    if node.right:
        path.append(node)
        self.binaryTreePathsRecu(node.right, path, result)
        path.pop()


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def postorderTraversal(self, root):

    dummy = TreeNode(0)
    dummy.left = root
    result, cur = [], dummy
    while cur:
        if cur.left is None:
            cur = cur.right
        else:
            node = cur.left
            while node.right and node.right != cur:
                node = node.right

            if node.right is None:
                node.right = cur
                cur = cur.left
            else:
                result += self.traceBack(cur.left, node)
                node.right = None
                cur = cur.right

    return result

    def traceBack(self, frm, to):
    result, cur = [], frm
    while cur is not to:
        result.append(cur.val)
        cur = cur.right
    result.append(to.val)
    result.reverse()
    return result


class Solution2(object):
    def postorderTraversal(self, root):

    result, stack = [], [(root, False)]
    while stack:
        root, is_visited = stack.pop()
        if root is None:
            continue
        if is_visited:
            result.append(root.val)
        else:
            stack.append((root, True))
            stack.append((root.right, False))
            stack.append((root.left, False))
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def preorderTraversal(self, root):

    result, curr = [], root
    while curr:
        if curr.left is None:
            result.append(curr.val)
            curr = curr.right
        else:
            node = curr.left
            while node.right and node.right != curr:
                node = node.right

            if node.right is None:
                result.append(curr.val)
                node.right = curr
                curr = curr.left
            else:
                node.right = None
                curr = curr.right

    return result


class Solution2(object):
    def preorderTraversal(self, root):

    result, stack = [], [(root, False)]
    while stack:
        root, is_visited = stack.pop()
        if root is None:
            continue
        if is_visited:
            result.append(root.val)
        else:
            stack.append((root.right, False))
            stack.append((root.left, False))
            stack.append((root, True))
    return result


class Solution(object):
    def pruneTree(self, root):

    if not root:
        return None
    root.left = self.pruneTree(root.left)
    root.right = self.pruneTree(root.right)
    if not root.left and not root.right and root.val == 0:
        return None
    return root


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def rightSideView(self, root):
    result = []
    self.rightSideViewDFS(root, 1, result)
    return result

    def rightSideViewDFS(self, node, depth, result):
    if not node:
        return

    if depth > len(result):
        result.append(node.val)

    self.rightSideViewDFS(node.right, depth + 1, result)
    self.rightSideViewDFS(node.left, depth + 1, result)


class Solution2(object):

    def rightSideView(self, root):
    if root is None:
        return []

    result, current = [], [root]
    while current:
        next_level = []
        for node in current:
            if node.left:
                next_level.append(node.left)
            if node.right:
                next_level.append(node.right)
        result.append(node.val)
        current = next_level

    return result


class Solution(object):
    def findTilt(self, root):

    def postOrderTraverse(root, tilt):
        if not root:
            return 0, tilt
        left, tilt = postOrderTraverse(root.left, tilt)
        right, tilt = postOrderTraverse(root.right, tilt)
        tilt += abs(left - right)
        return left + right + root.val, tilt

    return postOrderTraverse(root, 0)[1]


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def upsideDownBinaryTree(self, root):
    p, parent, parent_right = root, None, None

    while p:
        left = p.left
        p.left = parent_right
        parent_right = p.right
        p.right = parent
        parent = p
        p = left

    return parent


class Solution2(object):

    def upsideDownBinaryTree(self, root):
    return self.upsideDownBinaryTreeRecu(root, None)

    def upsideDownBinaryTreeRecu(self, p, parent):
    if p is None:
        return parent

    root = self.upsideDownBinaryTreeRecu(p.left, p)
    if parent:
        p.left = parent.right
    else:
        p.left = None
    p.right = parent

    return root


import collections


class Solution(object):
    def verticalOrder(self, root):

    cols = collections.defaultdict(list)
    queue = [(root, 0)]
    for node, i in queue:
        if node:
            cols[i].append(node.val)
            queue += (node.left, i - 1), (node.right, i + 1)
    return (
        [cols[i] for i in xrange(min(cols.keys()), max(cols.keys()) + 1)]
        if cols
        else []
    )


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def zigzagLevelOrder(self, root):
    if root is None:
        return []
    result, current = [], [root]
    while current:
        next_level, vals = [], []
        for node in current:
            vals.append(node.val)
            if node.left:
                next_level.append(node.left)
            if node.right:
                next_level.append(node.right)
        result.append(vals[::-1] if len(result) % 2 else vals)
        current = next_level
    return result


class Solution(object):
    def numFactoredBinaryTrees(self, A):

    M = 10 ** 9 + 7
    A.sort()
    dp = {}
    for i in xrange(len(A)):
        dp[A[i]] = 1
        for j in xrange(i):
            if A[i] % A[j] == 0 and A[i] // A[j] in dp:
                dp[A[i]] += dp[A[j]] * dp[A[i] // A[j]]
                dp[A[i]] %= M
    return sum(dp.values()) % M


class Solution(object):
    def readBinaryWatch(self, num):

    def bit_count(bits):
        count = 0
        while bits:
            bits &= bits - 1
            count += 1
        return count

    return [
        "%d:%02d" % (h, m)
        for h in xrange(12)
        for m in xrange(60)
        if bit_count(h) + bit_count(m) == num
    ]

    def readBinaryWatch2(self, num):

    return [
        "{0}:{1}".format(str(h), str(m).zfill(2))
        for h in range(12)
        for m in range(60)
        if (bin(h) + bin(m)).count("1") == num
    ]


class Solution(object):

    def rangeBitwiseAnd(self, m, n):
    while m < n:
        n &= n - 1
    return n


class Solution2(object):

    def rangeBitwiseAnd(self, m, n):
    i, diff = 0, n - m
    while diff:
        diff >>= 1
        i += 1
    return n & m >> i << i


class Solution(object):
    def subarrayBitwiseORs(self, A):

    result, curr = set(), {0}
    for i in A:
        curr = {i} | {i | j for j in curr}
        result |= curr
    return len(result)


class Solution(object):
    def numRescueBoats(self, people, limit):

    people.sort()
    result = 0
    left, right = 0, len(people) - 1
    while left <= right:
        result += 1
        if people[left] + people[right] <= limit:
            left += 1
        right -= 1
    return result


import collections
import functools


class Solution(object):
    def boldWords(self, words, S):

    def _trie(): return collections.defaultdict(_trie)
    trie = _trie()
    for i, word in enumerate(words):
        functools.reduce(dict.__getitem__, word, trie).setdefault("_end")

    lookup = [False] * len(S)
    for i in xrange(len(S)):
        curr = trie
        k = -1
        for j in xrange(i, len(S)):
            if S[j] not in curr:
                break
            curr = curr[S[j]]
            if "_end" in curr:
                k = j
        for j in xrange(i, k + 1):
            lookup[j] = True

    result = []
    for i in xrange(len(S)):
        if lookup[i] and (i == 0 or not lookup[i - 1]):
            result.append("<b>")
        result.append(S[i])
        if lookup[i] and (i == len(S) - 1 or not lookup[i + 1]):
            result.append("</b>")
    return "".join(result)


class Solution2(object):
    def boldWords(self, words, S):

    lookup = [0] * len(S)
    for d in words:
        pos = S.find(d)
        while pos != -1:
            lookup[pos: pos + len(d)] = [1] * len(d)
            pos = S.find(d, pos + 1)

    result = []
    for i in xrange(len(S)):
        if lookup[i] and (i == 0 or not lookup[i - 1]):
            result.append("<b>")
        result.append(S[i])
        if lookup[i] and (i == len(S) - 1 or not lookup[i + 1]):
            result.append("</b>")
    return "".join(result)


class Solution(object):
    def maxKilledEnemies(self, grid):

    result = 0
    if not grid or not grid[0]:
        return result

    down = [[0 for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))]
    right = [[0 for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))]
    for i in reversed(xrange(len(grid))):
        for j in reversed(xrange(len(grid[0]))):
            if grid[i][j] != "W":
                if i + 1 < len(grid):
                    down[i][j] = down[i + 1][j]
                if j + 1 < len(grid[0]):
                    right[i][j] = right[i][j + 1]
                if grid[i][j] == "E":
                    down[i][j] += 1
                    right[i][j] += 1

    up = [0 for _ in xrange(len(grid[0]))]
    for i in xrange(len(grid)):
        left = 0
        for j in xrange(len(grid[0])):
            if grid[i][j] == "W":
                up[j], left = 0, 0
            elif grid[i][j] == "E":
                up[j] += 1
                left += 1
            else:
                result = max(result, left + up[j] + right[i][j] + down[i][j])

    return result


class Solution(object):
    def boundaryOfBinaryTree(self, root):

    def leftBoundary(root, nodes):
        if not root or (not root.left and not root.right):
            return
        nodes.append(root.val)
        if not root.left:
            leftBoundary(root.right, nodes)
        else:
            leftBoundary(root.left, nodes)

    def rightBoundary(root, nodes):
        if not root or (not root.left and not root.right):
            return
        if not root.right:
            rightBoundary(root.left, nodes)
        else:
            rightBoundary(root.right, nodes)
        nodes.append(root.val)

    def leaves(root, nodes):
        if not root:
            return
        if not root.left and not root.right:
            nodes.append(root.val)
            return
        leaves(root.left, nodes)
        leaves(root.right, nodes)

    if not root:
        return []

    nodes = [root.val]
    leftBoundary(root.left, nodes)
    leaves(root.left, nodes)
    leaves(root.right, nodes)
    rightBoundary(root.right, nodes)
    return nodes


import itertools


class Solution(object):
    def braceExpansionII(self, expression):

    def form_words(options):
        words = map("".join, itertools.product(*options))
        words.sort()
        return words

    def generate_option(expr, i):
        option_set = set()
        while i[0] != len(expr) and expr[i[0]] != "}":
            i[0] += 1
            for option in generate_words(expr, i):
                option_set.add(option)
        i[0] += 1
        option = list(option_set)
        option.sort()
        return option

    def generate_words(expr, i):
        options = []
        while i[0] != len(expr) and expr[i[0]] not in ",}":
            tmp = []
            if expr[i[0]] not in "{,}":
                tmp.append(expr[i[0]])
                i[0] += 1
            elif expr[i[0]] == "{":
                tmp = generate_option(expr, i)
            options.append(tmp)
        return form_words(options)

    return generate_words(expression, [0])


class Solution2(object):
    def braceExpansionII(self, expression):

    def form_words(options):
        words = []
        total = 1
        for opt in options:
            total *= len(opt)
        for i in xrange(total):
            tmp = []
            for opt in reversed(options):
                i, c = divmod(i, len(opt))
                tmp.append(opt[c])
            tmp.reverse()
            words.append("".join(tmp))
        words.sort()
        return words

    def generate_option(expr, i):
        option_set = set()
        while i[0] != len(expr) and expr[i[0]] != "}":
            i[0] += 1
            for option in generate_words(expr, i):
                option_set.add(option)
        i[0] += 1
        option = list(option_set)
        option.sort()
        return option

    def generate_words(expr, i):
        options = []
        while i[0] != len(expr) and expr[i[0]] not in ",}":
            tmp = []
            if expr[i[0]] not in "{,}":
                tmp.append(expr[i[0]])
                i[0] += 1
            elif expr[i[0]] == "{":
                tmp = generate_option(expr, i)
            options.append(tmp)
        return form_words(options)

    return generate_words(expression, [0])


import itertools


class Solution(object):
    def expand(self, S):

    def form_words(options):
        words = map("".join, itertools.product(*options))
        words.sort()
        return words

    def generate_option(expr, i):
        option_set = set()
        while i[0] != len(expr) and expr[i[0]] != "}":
            i[0] += 1
            for option in generate_words(expr, i):
                option_set.add(option)
        i[0] += 1
        option = list(option_set)
        option.sort()
        return option

    def generate_words(expr, i):
        options = []
        while i[0] != len(expr) and expr[i[0]] not in ",}":
            tmp = []
            if expr[i[0]] not in "{,}":
                tmp.append(expr[i[0]])
                i[0] += 1
            elif expr[i[0]] == "{":
                tmp = generate_option(expr, i)
            options.append(tmp)
        return form_words(options)

    return generate_words(S, [0])


class Solution2(object):
    def expand(self, S):

    def form_words(options):
        words = []
        total = 1
        for opt in options:
            total *= len(opt)
        for i in xrange(total):
            tmp = []
            for opt in reversed(options):
                i, c = divmod(i, len(opt))
                tmp.append(opt[c])
            tmp.reverse()
            words.append("".join(tmp))
        words.sort()
        return words

    def generate_option(expr, i):
        option_set = set()
        while i[0] != len(expr) and expr[i[0]] != "}":
            i[0] += 1
            for option in generate_words(expr, i):
                option_set.add(option)
        i[0] += 1
        option = list(option_set)
        option.sort()
        return option

    def generate_words(expr, i):
        options = []
        while i[0] != len(expr) and expr[i[0]] not in ",}":
            tmp = []
            if expr[i[0]] not in "{,}":
                tmp.append(expr[i[0]])
                i[0] += 1
            elif expr[i[0]] == "{":
                tmp = generate_option(expr, i)
            options.append(tmp)
        return form_words(options)

    return generate_words(S, [0])


class Solution(object):
    def breakPalindrome(self, palindrome):

    for i in xrange(len(palindrome) // 2):
        if palindrome[i] != "a":
            return palindrome[:i] + "a" + palindrome[i + 1:]
    return palindrome[:-1] + "b" if len(palindrome) >= 2 else ""


import collections


class Solution(object):
    def leastBricks(self, wall):

    widths = collections.defaultdict(int)
    result = len(wall)
    for row in wall:
        width = 0
        for i in xrange(len(row) - 1):
            width += row[i]
            widths[width] += 1
            result = min(result, len(wall) - widths[width])
    return result


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n + 1)
    self.size = [1] * (n + 1)
    self.size[-1] = 0

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    self.size[max(x_root, y_root)] += self.size[min(x_root, y_root)]
    return True

    def top(self):
    return self.size[self.find_set(len(self.size) - 1)]


class Solution(object):
    def hitBricks(self, grid, hits):

    def index(C, r, c):
        return r * C + c

    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
    R, C = len(grid), len(grid[0])

    hit_grid = [row[:] for row in grid]
    for i, j in hits:
        hit_grid[i][j] = 0

    union_find = UnionFind(R * C)
    for r, row in enumerate(hit_grid):
        for c, val in enumerate(row):
            if not val:
                continue
            if r == 0:
                union_find.union_set(index(C, r, c), R * C)
            if r and hit_grid[r - 1][c]:
                union_find.union_set(index(C, r, c), index(C, r - 1, c))
            if c and hit_grid[r][c - 1]:
                union_find.union_set(index(C, r, c), index(C, r, c - 1))

    result = []
    for r, c in reversed(hits):
        prev_roof = union_find.top()
        if grid[r][c] == 0:
            result.append(0)
            continue
        for d in directions:
            nr, nc = (r + d[0], c + d[1])
            if 0 <= nr < R and 0 <= nc < C and hit_grid[nr][nc]:
                union_find.union_set(index(C, r, c), index(C, nr, nc))
        if r == 0:
            union_find.union_set(index(C, r, c), R * C)
        hit_grid[r][c] = 1
        result.append(max(0, union_find.top() - prev_roof - 1))
    return result[::-1]


class Solution(object):
    def brokenCalc(self, X, Y):

    result = 0
    while X < Y:
        if Y % 2:
            Y += 1
        else:
            Y /= 2
        result += 1
    return result + X - Y


import itertools


class Solution(object):
    def buddyStrings(self, A, B):

    if len(A) != len(B):
        return False
    diff = []
    for a, b in itertools.izip(A, B):
        if a != b:
            diff.append((a, b))
            if len(diff) > 2:
                return False
    return (not diff and len(set(A)) < len(A)) or (
        len(diff) == 2 and diff[0] == diff[1][::-1]
    )


class Solution(object):
    def buildArray(self, target, n):

    result, curr = [], 1
    for t in target:
        result.extend(["Push", "Pop"] * (t - curr))
        result.append("Push")
        curr = t + 1
    return result


class Solution(object):
    def numOfArrays(self, n, m, k):

    MOD = 10 ** 9 + 7

    dp = [[[0] * (k + 1) for _ in xrange(m + 1)] for _ in xrange(2)]

    prefix_dp = [[[0] * (k + 1) for _ in xrange(m + 1)] for _ in xrange(2)]
    for i in xrange(1, m + 1):
        dp[1][i][1] = 1
        prefix_dp[1][i][1] = (prefix_dp[1][i - 1][1] + dp[1][i][1]) % MOD
    for l in xrange(2, n + 1):
        for i in xrange(1, m + 1):
            for j in xrange(1, k + 1):
                dp[l % 2][i][j] = (
                    i * dp[(l - 1) % 2][i][j] % MOD
                    + prefix_dp[(l - 1) % 2][i - 1][j - 1]
                ) % MOD
                prefix_dp[l % 2][i][j] = (
                    prefix_dp[l % 2][i - 1][j] + dp[l % 2][i][j]
                ) % MOD
    return prefix_dp[n % 2][m][k]


class Node(object):
    def __init__(self, val=" ", left=None, right=None):
    self.val = val
    self.left = left
    self.right = right


class Solution(object):
    def expTree(self, s):

    def compute(operands, operators):
        right, left = operands.pop(), operands.pop()
        operands.append(Node(val=operators.pop(), left=left, right=right))

    precedence = {"+": 0, "-": 0, "*": 1, "/": 1}
    operands, operators, operand = [], [], 0
    for i in xrange(len(s)):
        if s[i].isdigit():
            operand = operand * 10 + int(s[i])
            if i == len(s) - 1 or not s[i + 1].isdigit():
                operands.append(Node(val=str(operand)))
                operand = 0
        elif s[i] == "(":
            operators.append(s[i])
        elif s[i] == ")":
            while operators[-1] != "(":
                compute(operands, operators)
            operators.pop()
        elif s[i] in precedence:
            while (
                operators
                and operators[-1] in precedence
                and precedence[operators[-1]] >= precedence[s[i]]
            ):
                compute(operands, operators)
            operators.append(s[i])
    while operators:
        compute(operands, operators)
    return operands[-1]


import math


class Solution(object):
    def minimumBoxes(self, n):

    h = int((6 * n) ** (1.0 / 3))
    if h * (h + 1) * (h + 2) > 6 * n:

        h -= 1
    n -= h * (h + 1) * (h + 2) // 6
    d = int(
        math.ceil((-1 + (1 + 8 * n) ** 0.5) / 2)
    )
    return h * (h + 1) // 2 + d


import threading


class H2O(object):
    def __init__(self):
    self.__l = threading.Lock()
    self.__nH = 0
    self.__nO = 0
    self.__releaseHydrogen = None
    self.__releaseOxygen = None

    def hydrogen(self, releaseHydrogen):
    with self.__l:
        self.__releaseHydrogen = releaseHydrogen
        self.__nH += 1
        self.__output()

    def oxygen(self, releaseOxygen):
    with self.__l:
        self.__releaseOxygen = releaseOxygen
        self.__nO += 1
        self.__output()

    def __output(self):
    while self.__nH >= 2 and self.__nO >= 1:
        self.__nH -= 2
        self.__nO -= 1
        self.__releaseHydrogen()
        self.__releaseHydrogen()
        self.__releaseOxygen()


class H2O2(object):
    def __init__(self):
    self.__nH = 0
    self.__nO = 0
    self.__cv = threading.Condition()

    def hydrogen(self, releaseHydrogen):

    with self.__cv:
        while (self.__nH + 1) - 2 * self.__nO > 2:
            self.__cv.wait()
        self.__nH += 1

        releaseHydrogen()
        self.__cv.notifyAll()

    def oxygen(self, releaseOxygen):

    with self.__cv:
        while 2 * (self.__nO + 1) - self.__nH > 2:
            self.__cv.wait()
        self.__nO += 1

        releaseOxygen()
        self.__cv.notifyAll()


class Solution(object):
    def findBuildings(self, heights):

    result = []
    for i in reversed(xrange(len(heights))):
        if not result or heights[i] > heights[result[-1]]:
            result.append(i)
    result.reverse()
    return result


class Solution2(object):
    def findBuildings(self, heights):

    result = []
    for i, h in enumerate(heights):
        while result and heights[result[-1]] <= h:
            result.pop()
        result.append(i)
    return result


class Solution(object):
    def flipLights(self, n, m):

    if m == 0:
        return 1
    if n == 1:
        return 2
    if m == 1 and n == 2:
        return 3
    if m == 1 or n == 2:
        return 4
    if m == 2:
        return 7
    return 8


class Solution(object):
    def numTimesAllBlue(self, light):

    result, right = 0, 0
    for i, num in enumerate(light, 1):
        right = max(right, num)
        result += right == i
    return result


class Solution(object):
    def minFlips(self, target):

    result, curr = 0, "0"
    for c in target:
        if c == curr:
            continue
        curr = c
        result += 1
    return result


import math


class Solution(object):
    def bulbSwitch(self, n):

    return int(math.sqrt(n))


import operator


from collections import defaultdict, Counter
from itertools import izip, imap


class Solution(object):
    def getHint(self, secret, guess):

    A, B = 0, 0
    lookup = defaultdict(int)
    for s, g in izip(secret, guess):
        if s == g:
            A += 1
        else:
            B += int(lookup[s] < 0) + int(lookup[g] > 0)
            lookup[s] += 1
            lookup[g] -= 1
    return "%dA%dB" % (A, B)


class Solution2(object):
    def getHint(self, secret, guess):

    A = sum(imap(operator.eq, secret, guess))
    B = sum((Counter(secret) & Counter(guess)).values()) - A
    return "%dA%dB" % (A, B)


class Solution(object):
    def maxCoins(self, nums):

    coins = [1] + [i for i in nums if i > 0] + [1]
    n = len(coins)
    max_coins = [[0 for _ in xrange(n)] for _ in xrange(n)]

    for k in xrange(2, n):
        for left in xrange(n - k):
            right = left + k
            for i in xrange(left + 1, right):
                max_coins[left][right] = max(
                    max_coins[left][right],
                    coins[left] * coins[i] * coins[right]
                    + max_coins[left][i]
                    + max_coins[i][right],
                )

    return max_coins[0][-1]


import collections


class Solution(object):
    def numBusesToDestination(self, routes, S, T):

    if S == T:
        return 0

    to_route = collections.defaultdict(set)
    for i, route in enumerate(routes):
        for stop in route:
            to_route[stop].add(i)

    result = 1
    q = [S]
    lookup = set([S])
    while q:
        next_q = []
        for stop in q:
            for i in to_route[stop]:
                for next_stop in routes[i]:
                    if next_stop in lookup:
                        continue
                    if next_stop == T:
                        return result
                    next_q.append(next_stop)
                    to_route[next_stop].remove(i)
                    lookup.add(next_stop)
        q = next_q
        result += 1

    return -1


class Solution(object):
    def totalMoney(self, n):

    def arithmetic_sequence_sum(a, d, n):
        return (2 * a + (n - 1) * d) * n // 2

    cost, day = 1, 7
    first_week_cost = arithmetic_sequence_sum(cost, cost, day)
    week, remain_day = divmod(n, day)
    return arithmetic_sequence_sum(
        first_week_cost, cost * day, week
    ) + arithmetic_sequence_sum(cost * (week + 1), cost, remain_day)


class Solution(object):
    def camelMatch(self, queries, pattern):

    def is_matched(query, pattern):
        i = 0
        for c in query:
            if i < len(pattern) and pattern[i] == c:
                i += 1
            elif c.isupper():
                return False
        return i == len(pattern)

    result = []
    for query in queries:
        result.append(is_matched(query, pattern))
    return result


class Solution(object):
    def assignBikes(self, workers, bikes):

    def manhattan(p1, p2):
        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

    dp = [[float("inf")] * ((1 << len(bikes))) for _ in xrange(2)]
    dp[0][0] = 0
    for i in xrange(len(workers)):
        dp[(i + 1) % 2] = [float("inf")] * ((1 << len(bikes)))
        for j in xrange(len(bikes)):
            for taken in xrange((1 << len(bikes))):
                if taken & (1 << j):
                    continue
                dp[(i + 1) % 2][taken | (1 << j)] = min(
                    dp[(i + 1) % 2][taken | (1 << j)],
                    dp[i % 2][taken] + manhattan(workers[i], bikes[j]),
                )
    return min(dp[len(workers) % 2])


import heapq


class Solution2(object):
    def assignBikes(self, workers, bikes):

    def manhattan(p1, p2):
        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

    min_heap = [(0, 0, 0)]
    lookup = set()
    while min_heap:
        cost, i, taken = heapq.heappop(min_heap)
        if (i, taken) in lookup:
            continue
        lookup.add((i, taken))
        if i == len(workers):
            return cost
        for j in xrange(len(bikes)):
            if taken & (1 << j):
                continue
            heapq.heappush(
                min_heap,
                (
                    cost + manhattan(workers[i], bikes[j]),
                    i + 1,
                    taken | (1 << j),
                ),
            )


import heapq


class Solution(object):
    def assignBikes(self, workers, bikes):

    def manhattan(p1, p2):
        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

    distances = [[] for _ in xrange(len(workers))]
    for i in xrange(len(workers)):
        for j in xrange(len(bikes)):
            distances[i].append((manhattan(workers[i], bikes[j]), i, j))
        distances[i].sort(reverse=True)

    result = [None] * len(workers)
    lookup = set()
    min_heap = []
    for i in xrange(len(workers)):
        heapq.heappush(min_heap, distances[i].pop())
    while len(lookup) < len(workers):
        _, worker, bike = heapq.heappop(min_heap)
        if bike not in lookup:
            result[worker] = bike
            lookup.add(bike)
        else:
            heapq.heappush(min_heap, distances[worker].pop())
    return result


import itertools


class Solution(object):
    def canConvertString(self, s, t, k):

    if len(s) != len(t):
        return False
    cnt = [0] * 26
    for a, b in itertools.izip(s, t):
        diff = (ord(b) - ord(a)) % len(cnt)
        if diff != 0 and cnt[diff] * len(cnt) + diff > k:
            return False
        cnt[diff] += 1
    return True


class Solution(object):
    def canIWin(self, maxChoosableInteger, desiredTotal):

    def canIWinHelper(maxChoosableInteger, desiredTotal, visited, lookup):
        if visited in lookup:
            return lookup[visited]

        mask = 1
        for i in xrange(maxChoosableInteger):
            if visited & mask == 0:
                if i + 1 >= desiredTotal or not canIWinHelper(
                    maxChoosableInteger,
                    desiredTotal - (i + 1),
                    visited | mask,
                    lookup,
                ):
                    lookup[visited] = True
                    return True
            mask <<= 1
        lookup[visited] = False
        return False

    if (1 + maxChoosableInteger) * (maxChoosableInteger / 2) < desiredTotal:
        return False

    return canIWinHelper(maxChoosableInteger, desiredTotal, 0, {})


class Solution(object):
    def canMakeArithmeticProgression(self, arr):

    m = min(arr)
    d = (max(arr) - m) // (len(arr) - 1)
    if not d:
        return True
    i = 0
    while i < len(arr):
        if arr[i] == m + i * d:
            i += 1
        else:
            j, r = divmod(arr[i] - m, d)
            if r or j >= len(arr) or arr[i] == arr[j]:
                return False
            arr[i], arr[j] = arr[j], arr[i]
    return True


import itertools


class Solution(object):
    def canMakePaliQueries(self, s, queries):

    CHARSET_SIZE = 26
    curr, count = [0] * CHARSET_SIZE, [[0] * CHARSET_SIZE]
    for c in s:
        curr[ord(c) - ord("a")] += 1
        count.append(curr[:])
    return [
        sum((b - a) %
            2 for a, b in itertools.izip(count[left], count[right + 1]))
        // 2
        <= k
        for left, right, k in queries
    ]


class Solution(object):
    def canPlaceFlowers(self, flowerbed, n):

    for i in xrange(len(flowerbed)):
        if (
            flowerbed[i] == 0
            and (i == 0 or flowerbed[i - 1] == 0)
            and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0)
        ):
            flowerbed[i] = 1
            n -= 1
        if n <= 0:
            return True
    return False


class Solution(object):
    def canEat(self, candiesCount, queries):

    prefix = [0] * (len(candiesCount) + 1)
    for i, c in enumerate(candiesCount):
        prefix[i + 1] = prefix[i] + c
    return [prefix[t] // c < d + 1 <= prefix[t + 1] // 1 for t, d, c in queries]


class Solution(object):
    def candyCrush(self, board):

    R, C = len(board), len(board[0])
    changed = True

    while changed:
        changed = False

        for r in xrange(R):
            for c in xrange(C - 2):
                if (
                    abs(board[r][c])
                    == abs(board[r][c + 1])
                    == abs(board[r][c + 2])
                    != 0
                ):
                    board[r][c] = board[r][c + 1] = board[r][c + 2] = -abs(
                        board[r][c]
                    )
                    changed = True

        for r in xrange(R - 2):
            for c in xrange(C):
                if (
                    abs(board[r][c])
                    == abs(board[r + 1][c])
                    == abs(board[r + 2][c])
                    != 0
                ):
                    board[r][c] = board[r + 1][c] = board[r + 2][c] = -abs(
                        board[r][c]
                    )
                    changed = True

        for c in xrange(C):
            i = R - 1
            for r in reversed(xrange(R)):
                if board[r][c] > 0:
                    board[i][c] = board[r][c]
                    i -= 1
            for r in reversed(xrange(i + 1)):
                board[r][c] = 0

    return board


class Solution(object):

    def candy(self, ratings):
    candies = [1 for _ in xrange(len(ratings))]
    for i in xrange(1, len(ratings)):
        if ratings[i] > ratings[i - 1]:
            candies[i] = candies[i - 1] + 1

    for i in reversed(xrange(1, len(ratings))):
        if ratings[i - 1] > ratings[i] and candies[i - 1] <= candies[i]:
            candies[i - 1] = candies[i] + 1

    return sum(candies)


class Solution(object):
    def shipWithinDays(self, weights, D):

    def possible(weights, D, mid):
        result, curr = 1, 0
        for w in weights:
            if curr + w > mid:
                result += 1
                curr = 0
            curr += w
        return result <= D

    left, right = max(weights), sum(weights)
    while left <= right:
        mid = left + (right - left) // 2
        if possible(weights, D, mid):
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution(object):
    def getCollisionTimes(self, cars):

    stk = []
    result = [-1.0] * len(cars)
    for i in reversed(xrange(len(cars))):
        p, s = cars[i]
        while stk and (
            cars[stk[-1]][1] >= s
            or 0
            < result[stk[-1]]
            <= float(cars[stk[-1]][0] - p) / (s - cars[stk[-1]][1])
        ):
            stk.pop()
        if stk:
            result[i] = float(cars[stk[-1]][0] - p) / (s - cars[stk[-1]][1])
        stk.append(i)
    return result


class Solution(object):
    def carFleet(self, target, position, speed):

    times = [float(target - p) / s for p, s in sorted(zip(position, speed))]
    result, curr = 0, 0
    for t in reversed(times):
        if t > curr:
            result += 1
            curr = t
    return result


class Solution(object):
    def carPooling(self, trips, capacity):

    line = [x for num, start, end in trips for x in [[start, num], [end, -num]]]
    line.sort()
    for _, num in line:
        capacity -= num
        if capacity < 0:
            return False
    return True


import itertools


class Solution(object):
    def flipgame(self, fronts, backs):

    same = {n for i, n in enumerate(fronts) if n == backs[i]}
    result = float("inf")
    for n in itertools.chain(fronts, backs):
        if n not in same:
            result = min(result, n)
    return result if result < float("inf") else 0


import collections


class Solution(object):
    def canMouseWin(self, grid, catJump, mouseJump):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    DRAW, MOUSE, CAT = range(3)

    def parents(m, c, t):
        if t == CAT:
            for nm in graph[m, MOUSE ^ CAT ^ t]:
                yield nm, c, MOUSE ^ CAT ^ t
        else:
            for nc in graph[c, MOUSE ^ CAT ^ t]:
                yield m, nc, MOUSE ^ CAT ^ t

    R, C = len(grid), len(grid[0])
    N = R * C
    WALLS = set()
    FOOD, MOUSE_START, CAT_START = [-1] * 3
    for r in xrange(R):
        for c in xrange(C):
            if grid[r][c] == "M":
                MOUSE_START = r * C + c
            elif grid[r][c] == "C":
                CAT_START = r * C + c
            elif grid[r][c] == "F":
                FOOD = r * C + c
            elif grid[r][c] == "#":
                WALLS.add(r * C + c)

    graph = collections.defaultdict(set)
    jump = {MOUSE: mouseJump, CAT: catJump}
    for r in xrange(R):
        for c in xrange(C):
            if grid[r][c] == "#":
                continue
            pos = r * C + c
            for t in [MOUSE, CAT]:
                for dr, dc in directions:
                    for d in xrange(jump[t] + 1):
                        nr, nc = r + dr * d, c + dc * d
                        if not (
                            0 <= nr < R and 0 <= nc < C and grid[nr][nc] != "#"
                        ):
                            break
                        graph[pos, t].add(nr * C + nc)

    degree = {}
    for m in xrange(N):
        for c in xrange(N):
            degree[m, c, MOUSE] = len(graph[m, MOUSE])
            degree[m, c, CAT] = len(graph[c, CAT])
    color = collections.defaultdict(int)
    q = collections.deque()
    for i in xrange(N):
        if i in WALLS or i == FOOD:
            continue
        color[FOOD, i, CAT] = MOUSE
        q.append((FOOD, i, CAT, MOUSE))
        color[i, FOOD, MOUSE] = CAT
        q.append((i, FOOD, MOUSE, CAT))
        for t in [MOUSE, CAT]:
            color[i, i, t] = CAT
            q.append((i, i, t, CAT))
    while q:
        i, j, t, c = q.popleft()
        for ni, nj, nt in parents(i, j, t):
            if color[ni, nj, nt] != DRAW:
                continue
            if nt == c:
                color[ni, nj, nt] = c
                q.append((ni, nj, nt, c))
                continue
            degree[ni, nj, nt] -= 1
            if not degree[ni, nj, nt]:
                color[ni, nj, nt] = c
                q.append((ni, nj, nt, c))
    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE


import collections


class Solution2(object):
    def canMouseWin(self, grid, catJump, mouseJump):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    DRAW, MOUSE, CAT = range(3)

    def parents(m, c, t):
        if t == CAT:
            for nm in graph[m, MOUSE ^ CAT ^ t]:
                yield nm, c, MOUSE ^ CAT ^ t
        else:
            for nc in graph[c, MOUSE ^ CAT ^ t]:
                yield m, nc, MOUSE ^ CAT ^ t

    R, C = len(grid), len(grid[0])
    N = R * C
    WALLS = set()
    FOOD, MOUSE_START, CAT_START = [-1] * 3
    for r in xrange(R):
        for c in xrange(C):
            if grid[r][c] == "M":
                MOUSE_START = r * C + c
            elif grid[r][c] == "C":
                CAT_START = r * C + c
            elif grid[r][c] == "F":
                FOOD = r * C + c
            elif grid[r][c] == "#":
                WALLS.add(r * C + c)
    graph = collections.defaultdict(set)
    jump = {MOUSE: mouseJump, CAT: catJump}
    for r in xrange(R):
        for c in xrange(C):
            if grid[r][c] == "#":
                continue
            pos = r * C + c
            for t in [MOUSE, CAT]:
                for dr, dc in directions:
                    for d in xrange(jump[t] + 1):
                        nr, nc = r + dr * d, c + dc * d
                        if not (
                            0 <= nr < R and 0 <= nc < C and grid[nr][nc] != "#"
                        ):
                            break
                        graph[pos, t].add(nr * C + nc)

    degree = {}
    for m in xrange(N):
        for c in xrange(N):

            degree[m, c, CAT] = len(graph[c, CAT])
    color = collections.defaultdict(int)
    q1 = collections.deque()

    for i in xrange(N):
        if i in WALLS or i == FOOD:
            continue
        color[FOOD, i, CAT] = MOUSE
        q1.append((FOOD, i, CAT))
        color[i, FOOD, MOUSE] = CAT

        for t in [MOUSE, CAT]:
            color[i, i, t] = CAT

    while q1:
        i, j, t = q1.popleft()
        for ni, nj, nt in parents(i, j, t):
            if color[ni, nj, nt] != DRAW:
                continue
            if t == CAT:
                color[ni, nj, nt] = MOUSE
                q1.append((ni, nj, nt))
                continue
            degree[ni, nj, nt] -= 1
            if not degree[ni, nj, nt]:
                color[ni, nj, nt] = MOUSE
                q1.append((ni, nj, nt))

    return color[MOUSE_START, CAT_START, MOUSE] == MOUSE


import collections


class Solution(object):
    def catMouseGame(self, graph):

    HOLE, MOUSE_START, CAT_START = range(3)
    DRAW, MOUSE, CAT = range(3)

    def parents(m, c, t):
        if t == CAT:
            for nm in graph[m]:
                yield nm, c, MOUSE ^ CAT ^ t
        else:
            for nc in graph[c]:
                if nc != HOLE:
                    yield m, nc, MOUSE ^ CAT ^ t

    degree = {}
    ignore = set(graph[HOLE])
    for m in xrange(len(graph)):
        for c in xrange(len(graph)):
            degree[m, c, MOUSE] = len(graph[m])
            degree[m, c, CAT] = len(graph[c]) - (c in ignore)
    color = collections.defaultdict(int)
    q = collections.deque()
    for i in xrange(len(graph)):
        if i == HOLE:
            continue
        color[HOLE, i, CAT] = MOUSE
        q.append((HOLE, i, CAT, MOUSE))
        for t in [MOUSE, CAT]:
            color[i, i, t] = CAT
            q.append((i, i, t, CAT))
    while q:
        i, j, t, c = q.popleft()
        for ni, nj, nt in parents(i, j, t):
            if color[ni, nj, nt] != DRAW:
                continue
            if nt == c:
                color[ni, nj, nt] = c
                q.append((ni, nj, nt, c))
                continue
            degree[ni, nj, nt] -= 1
            if not degree[ni, nj, nt]:
                color[ni, nj, nt] = c
                q.append((ni, nj, nt, c))
    return color[MOUSE_START, CAT_START, MOUSE]


import collections


class Solution2(object):
    def catMouseGame(self, graph):

    HOLE, MOUSE_START, CAT_START = range(3)
    DRAW, MOUSE, CAT = range(3)

    def parents(m, c, t):
        if t == CAT:
            for nm in graph[m]:
                yield nm, c, MOUSE ^ CAT ^ t
        else:
            for nc in graph[c]:
                if nc != HOLE:
                    yield m, nc, MOUSE ^ CAT ^ t

    color = collections.defaultdict(int)
    degree = {}
    ignore = set(graph[HOLE])
    for m in xrange(len(graph)):
        for c in xrange(len(graph)):
            degree[m, c, MOUSE] = len(graph[m])
            degree[m, c, CAT] = len(graph[c]) - (c in ignore)
    q1 = collections.deque()
    q2 = collections.deque()
    for i in xrange(len(graph)):
        if i == HOLE:
            continue
        color[HOLE, i, CAT] = MOUSE
        q1.append((HOLE, i, CAT))
        for t in [MOUSE, CAT]:
            color[i, i, t] = CAT
            q2.append((i, i, t))
    while q1:
        i, j, t = q1.popleft()
        for ni, nj, nt in parents(i, j, t):
            if color[ni, nj, nt] != DRAW:
                continue
            if t == CAT:
                color[ni, nj, nt] = MOUSE
                q1.append((ni, nj, nt))
                continue
            degree[ni, nj, nt] -= 1
            if not degree[ni, nj, nt]:
                color[ni, nj, nt] = MOUSE
                q1.append((ni, nj, nt))
    while q2:
        i, j, t = q2.popleft()
        for ni, nj, nt in parents(i, j, t):
            if color[ni, nj, nt] != DRAW:
                continue
            if t == MOUSE:
                color[ni, nj, nt] = CAT
                q2.append((ni, nj, nt))
                continue
            degree[ni, nj, nt] -= 1
            if not degree[ni, nj, nt]:
                color[ni, nj, nt] = CAT
                q2.append((ni, nj, nt))
    return color[MOUSE_START, CAT_START, MOUSE]


class Solution(object):
    def oddCells(self, n, m, indices):

    row, col = [0] * n, [0] * m
    for r, c in indices:
        row[r] ^= 1
        col[c] ^= 1
    row_sum, col_sum = sum(row), sum(col)
    return row_sum * m + col_sum * n - 2 * row_sum * col_sum


import collections
import itertools


class Solution2(object):
    def oddCells(self, n, m, indices):

    def fn(x): return sum(
        count & 1 for count in collections.Counter(x).itervalues())
    row_sum, col_sum = map(fn, itertools.izip(*indices))
    return row_sum * m + col_sum * n - 2 * row_sum * col_sum


from operator import xor
from functools import reduce


class Solution(object):
    def xorGame(self, nums):

    return reduce(xor, nums) == 0 or len(nums) % 2 == 0


class Solution(object):
    def champagneTower(self, poured, query_row, query_glass):

    result = [poured] + [0] * query_row
    for i in xrange(1, query_row + 1):
        for j in reversed(xrange(i + 1)):
            result[j] = (
                max(result[j] - 1, 0) / 2.0 + max(result[j - 1] - 1, 0) / 2.0
            )
    return min(result[query_glass], 1)


import collections


class Solution(object):
    def minCharacters(self, a, b):

    count1 = collections.Counter(ord(c) - ord("a") for c in a)
    count2 = collections.Counter(ord(c) - ord("a") for c in b)
    result = len(a) + len(b) - max((count1 + count2).itervalues())
    for i in xrange(26 - 1):
        if i > 0:
            count1[i] += count1[i - 1]
            count2[i] += count2[i - 1]
        result = min(result, len(a) - count1[i] + count2[i])
        result = min(result, len(b) - count2[i] + count1[i])
    return result


class Node:
    def __init__(self, val):
    pass


class Solution(object):
    def flipBinaryTree(self, root, leaf):

    curr, parent = leaf, None
    while True:
        child = curr.parent
        curr.parent = parent
        if curr.left == parent:
            curr.left = None
        else:
            curr.right = None
        if curr == root:
            break
        if curr.left:
            curr.right = curr.left
        curr.left = child
        curr, parent = child, curr
    return leaf


import collections
import heapq


class Solution(object):
    def findCheapestPrice(self, n, flights, src, dst, K):

    adj = collections.defaultdict(list)
    for u, v, w in flights:
        adj[u].append((v, w))
    best = collections.defaultdict(
        lambda: collections.defaultdict(lambda: float("inf"))
    )
    min_heap = [(0, src, K + 1)]
    while min_heap:
        result, u, k = heapq.heappop(min_heap)
        if k < 0 or best[u][k] < result:
            continue
        if u == dst:
            return result
        for v, w in adj[u]:
            if result + w < best[v][k - 1]:
                best[v][k - 1] = result + w
                heapq.heappush(min_heap, (result + w, v, k - 1))
    return -1


class Solution(object):
    def canFormArray(self, arr, pieces):

    lookup = {x[0]: i for i, x in enumerate(pieces)}
    i = 0
    while i < len(arr):
        if arr[i] not in lookup:
            return False
        for c in pieces[lookup[arr[i]]]:
            if i == len(arr) or arr[i] != c:
                return False
            i += 1
    return True


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def isCompleteTree(self, root):

    end = False
    current = [root]
    while current:
        next_level = []
        for node in current:
            if not node:
                end = True
                continue
            if end:
                return False
            next_level.append(node.left)
            next_level.append(node.right)
        current = next_level
    return True


class Solution2(object):
    def isCompleteTree(self, root):

    prev_level, current = [], [(root, 1)]
    count = 0
    while current:
        count += len(current)
        next_level = []
        for node, v in current:
            if not node:
                continue
            next_level.append((node.left, 2 * v))
            next_level.append((node.right, 2 * v + 1))
        prev_level, current = current, next_level
    return prev_level[-1][1] == count


import bisect


class Solution(object):
    def isMajorityElement(self, nums, target):

    if len(nums) % 2:
        if nums[len(nums) // 2] != target:
            return False
    else:
        if not (nums[len(nums) // 2 - 1] == nums[len(nums) // 2] == target):
            return False

    left = bisect.bisect_left(nums, target)
    right = bisect.bisect_right(nums, target)
    return (right - left) * 2 > len(nums)


import collections
import string


class Solution(object):
    def checkIfCanBreak(self, s1, s2):

    def is_break(count1, count2):
        curr1, curr2 = 0, 0
        for c in string.ascii_lowercase:
            curr1 += count1[c]
            curr2 += count2[c]
            if curr1 < curr2:
                return False
        return True

    count1, count2 = collections.Counter(s1), collections.Counter(s2)
    return is_break(count1, count2) or is_break(count2, count1)


import itertools


class Solution2(object):
    def checkIfCanBreak(self, s1, s2):

    return not {1, -1}.issubset(
        set(cmp(a, b) for a, b in itertools.izip(sorted(s1), sorted(s2)))
    )


import itertools


class Solution3(object):
    def checkIfCanBreak(self, s1, s2):

    s1, s2 = sorted(s1), sorted(s2)
    return all(a >= b for a, b in itertools.izip(s1, s2)) or all(
        a <= b for a, b in itertools.izip(s1, s2)
    )


class Solution(object):
    def hasAllCodes(self, s, k):

    return (
        2 ** k <= len(s)
        and len({s[i: i + k] for i in xrange(len(s) - k + 1)}) == 2 ** k
    )


class Solution2(object):
    def hasAllCodes(self, s, k):

    lookup = set()
    base = 2 ** k
    if base > len(s):
        return False
    num = 0
    for i in xrange(len(s)):
        num = (num << 1) + (s[i] == "1")
        if i >= k - 1:
            lookup.add(num)
            num -= (s[i - k + 1] == "1") * (base // 2)
    return len(lookup) == base


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    self.val = val
    self.left = left
    self.right = right


class Solution(object):
    def isValidSequence(self, root, arr):

    q = [root]
    for depth in xrange(len(arr)):
        new_q = []
        while q:
            node = q.pop()
            if not node or node.val != arr[depth]:
                continue
            if depth + 1 == len(arr) and node.left == node.right:
                return True
            new_q.extend(child for child in (node.left, node.right))
        q = new_q
    return False


class Solution2(object):
    def isValidSequence(self, root, arr):

    s = [(root, 0)]
    while s:
        node, depth = s.pop()
        if not node or depth == len(arr) or node.val != arr[depth]:
            continue
        if depth + 1 == len(arr) and node.left == node.right:
            return True
        s.append((node.right, depth + 1))
        s.append((node.left, depth + 1))
    return False


class Solution3(object):
    def isValidSequence(self, root, arr):

    def dfs(node, arr, depth):
        if not node or depth == len(arr) or node.val != arr[depth]:
            return False
        if depth + 1 == len(arr) and node.left == node.right:
            return True
        return dfs(node.left, arr, depth + 1) or dfs(node.right, arr, depth + 1)

    return dfs(root, arr, 0)


class Solution(object):
    def isPrefixOfWord(self, sentence, searchWord):

    def KMP(text, pattern):
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in xrange(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j + 1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        prefix = getPrefix(pattern)
        j = -1
        for i in xrange(len(text)):
            while j != -1 and pattern[j + 1] != text[i]:
                j = prefix[j]
            if pattern[j + 1] == text[i]:
                j += 1
            if j + 1 == len(pattern):
                return i - j
        return -1

    if sentence.startswith(searchWord):
        return 1
    p = KMP(sentence, " " + searchWord)
    if p == -1:
        return -1
    return 1 + sum(sentence[i] == " " for i in xrange(p + 1))


class Solution(object):
    def kLengthApart(self, nums, k):

    prev = -k - 1
    for i in xrange(len(nums)):
        if not nums[i]:
            continue
        if i - prev <= k:
            return False
        prev = i
    return True


class Solution(object):
    def check(self, nums):

    count = 0
    for i in xrange(len(nums)):
        if nums[i] > nums[(i + 1) % len(nums)]:
            count += 1
            if count > 1:
                return False
    return True


import collections


class Solution(object):
    def canArrange(self, arr, k):

    count = collections.Counter(i % k for i in arr)
    return (0 not in count or not count[0] % 2) and all(
        k - i in count and count[i] == count[k - i]
        for i in xrange(1, k)
        if i in count
    )


class Solution(object):
    def checkOnesSegment(self, s):

    return "01" not in s


class Solution(object):
    def isGoodArray(self, nums):

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    result = nums[0]
    for num in nums:
        result = gcd(result, num)
        if result == 1:
            break
    return result == 1


class Solution(object):
    def checkStraightLine(self, coordinates):

    i, j = coordinates[:2]
    return all(
        i[0] * j[1]
        - j[0] * i[1]
        + j[0] * k[1]
        - k[0] * j[1]
        + k[0] * i[1]
        - i[0] * k[1]
        == 0
        for k in coordinates
    )


class Solution(object):
    def checkIfExist(self, arr):

    lookup = set()
    for x in arr:
        if 2 * x in lookup or (x % 2 == 0 and x // 2 in lookup):
            return True
        lookup.add(x)
    return False


class Solution(object):
    def checkPowersOfThree(self, n):

    while n > 0:
        if n % 3 == 2:
            return False
        n //= 3
    return True


import itertools


class Solution(object):
    def areAlmostEqual(self, s1, s2):

    diff = []
    for a, b in itertools.izip(s1, s2):
        if a == b:
            continue
        if len(diff) == 2:
            return False
        diff.append([a, b] if not diff else [b, a])
    return not diff or (len(diff) == 2 and diff[0] == diff[1])


class Solution(object):
    def isTransformable(self, s, t):

    idxs = [[] for _ in xrange(10)]
    for i in reversed(xrange(len(s))):
        idxs[int(s[i])].append(i)
    for c in t:
        d = int(c)
        if not idxs[d]:
            return False
        for k in xrange(
            d
        ):
            if idxs[k] and idxs[k][-1] < idxs[d][-1]:
                return False
        idxs[d].pop()
    return True


class Solution(object):
    def hasValidPath(self, grid):

    E, S, W, N = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    directions = [[W, E], [N, S], [W, S], [S, E], [W, N], [N, E]]

    for r, c in directions[grid[0][0] - 1]:
        if not (0 <= r < len(grid) and 0 <= c < len(grid[0])):
            continue
        pr, pc = 0, 0
        while r != len(grid) - 1 or c != len(grid[0]) - 1:
            for dx, dy in directions[grid[r][c] - 1]:
                nr, nc = r + dx, c + dy
                if (
                    (nr == pr and nc == pc)
                    or not (0 <= nr < len(grid) and 0 <= nc < len(grid[0]))
                    or (-dx, -dy) not in directions[grid[nr][nc] - 1]
                ):
                    continue
                pr, pc, r, c = r, c, nr, nc
                break
            else:
                return False
        return True
    return len(grid) == len(grid[0]) == 1


import collections
import functools


class Node(object):
    def __init__(self, val=" ", left=None, right=None):
    pass


class Solution(object):
    def checkEquivalence(self, root1, root2):

    def add_counter(counter, prev, d, val):
        if val.isalpha():
            counter[ord(val) - ord("a")] += d if prev[0] == "+" else -d
        prev[0] = val

    def morris_inorder_traversal(root, cb):
        curr = root
        while curr:
            if curr.left is None:
                cb(curr.val)
                curr = curr.right
            else:
                node = curr.left
                while node.right and node.right != curr:
                    node = node.right
                if node.right is None:
                    node.right = curr
                    curr = curr.left
                else:
                    cb(curr.val)
                    node.right = None
                    curr = curr.right

    counter = collections.defaultdict(int)
    morris_inorder_traversal(
        root1, functools.partial(add_counter, counter, ["+"], 1)
    )
    morris_inorder_traversal(
        root2, functools.partial(add_counter, counter, ["+"], -1)
    )
    return all(v == 0 for v in counter.itervalues())


import collections
import functools


class Solution2(object):
    def checkEquivalence(self, root1, root2):

    def add_counter(counter, prev, d, val):
        if val.isalpha():
            counter[ord(val) - ord("a")] += d if prev[0] == "+" else -d
        prev[0] = val

    def inorder_traversal(root, cb):
        def traverseLeft(node, stk):
            while node:
                stk.append(node)
                node = node.left

        stk = []
        traverseLeft(root, stk)
        while stk:
            curr = stk.pop()
            cb(curr.val)
            traverseLeft(curr.right, stk)

    counter = collections.defaultdict(int)
    inorder_traversal(root1, functools.partial(add_counter, counter, ["+"], 1))
    inorder_traversal(root2, functools.partial(
        add_counter, counter, ["+"], -1))
    return all(v == 0 for v in counter.itervalues())


class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):

    idx1 = idx2 = arr_idx1 = arr_idx2 = 0
    while arr_idx1 < len(word1) and arr_idx2 < len(word2):
        if word1[arr_idx1][idx1] != word2[arr_idx2][idx2]:
            break
        idx1 += 1
        if idx1 == len(word1[arr_idx1]):
            idx1 = 0
            arr_idx1 += 1
        idx2 += 1
        if idx2 == len(word2[arr_idx2]):
            idx2 = 0
            arr_idx2 += 1
    return arr_idx1 == len(word1) and arr_idx2 == len(word2)


class Solution(object):
    def isValid(self, S):

    stack = []
    for i in S:
        if i == "c":
            if stack[-2:] == ["a", "b"]:
                stack.pop()
                stack.pop()
            else:
                return False
        else:
            stack.append(i)
    return not stack


from functools import partial


class TreeInfos(object):
    def __init__(self, children):

    def preprocess(curr, parent, weight):
        if parent != -1:
            W[curr].append(weight)
            P[curr].append(parent)
        i = 0
        while i < len(P[curr]) and i < len(P[P[curr][i]]):
            W[curr].append(max(W[curr][i], W[P[curr][i]][i]))
            P[curr].append(P[P[curr][i]][i])
            i += 1
        C[0] += 1
        L[curr] = C[
            0
        ]

    def divide(curr, parent, weight):
        stk.append(partial(postprocess, curr))
        for child, w in reversed(children[curr]):
            if child == parent:
                continue
            stk.append(partial(divide, child, curr, w))
        stk.append(partial(preprocess, curr, parent, weight))

    def postprocess(curr):
        R[curr] = C[
            0
        ]

    N = len(children)
    L, R, P, W, C = (
        [0] * N,
        [0] * N,
        [[] for _ in xrange(N)],
        [[] for _ in xrange(N)],
        [-1],
    )
    for i in xrange(N):
        if L[i]:
            continue
        stk = []
        stk.append(partial(divide, i, -1, 0))
        while stk:
            stk.pop()()
    self.L, self.R, self.P, self.W = L, R, P, W

    def is_ancestor(self, a, b):
    return self.L[a] <= self.L[b] <= self.R[b] <= self.R[a]

    def max_weights(self, a, b):

    def binary_lift(a, b):
        w = 0
        for i in reversed(xrange(len(self.P[a]))):
            if i < len(self.P[a]) and not self.is_ancestor(self.P[a][i], b):
                w = max(w, self.W[a][i])
                a = self.P[a][i]
        return max(w, self.W[a][0])

    w = 0
    if not self.is_ancestor(a, b):
        w = max(w, binary_lift(a, b))
    if not self.is_ancestor(b, a):
        w = max(w, binary_lift(b, a))
    return w


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.rank = [0] * n

    def find_set(self, x):
    stk = []
    while self.set[x] != x:
        stk.append(x)
        x = self.set[x]
    while stk:
        self.set[stk.pop()] = x
    return x

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    if self.rank[x_root] < self.rank[y_root]:
        self.set[x_root] = y_root
    elif self.rank[x_root] > self.rank[y_root]:
        self.set[y_root] = x_root
    else:
        self.set[y_root] = x_root
        self.rank[x_root] += 1
    return True


class DistanceLimitedPathsExist(object):
    def __init__(self, n, edgeList):

    edgeList.sort(key=lambda x: x[2])
    self.__uf = UnionFind(n)
    self.__adj = [[] for _ in xrange(n)]
    for index, (i, j, weight) in enumerate(edgeList):
        if not self.__uf.union_set(i, j):
            continue
        self.__adj[i].append((j, weight))
        self.__adj[j].append((i, weight))
    self.__tree_infos = TreeInfos(self.__adj)

    def query(self, p, q, limit):

    if self.__uf.find_set(p) != self.__uf.find_set(q):
        return False
    return self.__tree_infos.max_weights(p, q) < limit


import collections
import sortedcontainers
import bisect


class SnapshotArray(object):
    def __init__(self, length):

    self.__snaps = collections.defaultdict(
        lambda: sortedcontainers.SortedList([(0, 0)])
    )

    def set(self, index, val, snap_id):

    i = self.__snaps[index].bisect_left((snap_id, float("-inf")))
    if i != len(self.__snaps[index]) and self.__snaps[index][i][0] == snap_id:
        self.__snaps[index].remove(self.__snaps[index][i])
    self.__snaps[index].add((snap_id, val))

    def get(self, index, snap_id):

    i = self.__snaps[index].bisect_left((snap_id + 1, float("-inf"))) - 1
    return self.__snaps[index][i][1]


class VersionedUnionFind(object):
    def __init__(self, n):
    self.snap_id = 0
    self.set = SnapshotArray(n)
    for i in xrange(n):
        self.set.set(i, i, self.snap_id)
    self.rank = SnapshotArray(n)

    def find_set(self, x, snap_id):
    stk = []
    while self.set.get(x, snap_id) != x:
        stk.append(x)
        x = self.set.get(x, snap_id)
    while stk:
        self.set.set(stk.pop(), x, snap_id)
    return x

    def union_set(self, x, y):
    x_root = self.find_set(x, self.snap_id)
    y_root = self.find_set(y, self.snap_id)
    if x_root == y_root:
        return False
    if self.rank.get(x_root, self.snap_id) < self.rank.get(
        y_root, self.snap_id
    ):
        self.set.set(x_root, y_root, self.snap_id)
    elif self.rank.get(x_root, self.snap_id) > self.rank.get(y_root, self.snap_id):
        self.set.set(y_root, x_root, self.snap_id)
    else:
        self.set.set(y_root, x_root, self.snap_id)
        self.rank.set(x_root, self.rank.get(
            x_root, self.snap_id) + 1, self.snap_id)
    return True

    def snap(self):
    self.snap_id += 1


class DistanceLimitedPathsExist2(object):
    def __init__(self, n, edgeList):

    edgeList.sort(key=lambda x: x[2])
    self.__uf = VersionedUnionFind(n)
    self.__weights = []
    for index, (i, j, weight) in enumerate(edgeList):
        if not self.__uf.union_set(i, j):
            continue
        self.__uf.snap()
        self.__weights.append(weight)

    def query(self, p, q, limit):

    snap_id = bisect.bisect_left(self.__weights, limit) - 1
    if snap_id == -1:
        return False
    return self.__uf.find_set(p, snap_id) == self.__uf.find_set(q, snap_id)


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.rank = [0] * n

    def find_set(self, x):
    stk = []
    while self.set[x] != x:
        stk.append(x)
        x = self.set[x]
    while stk:
        self.set[stk.pop()] = x
    return x

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    if self.rank[x_root] < self.rank[y_root]:
        self.set[x_root] = y_root
    elif self.rank[x_root] > self.rank[y_root]:
        self.set[y_root] = x_root
    else:
        self.set[y_root] = x_root
        self.rank[x_root] += 1
    return True


class Solution(object):
    def distanceLimitedPathsExist(self, n, edgeList, queries):

    for i, q in enumerate(queries):
        q.append(i)
    edgeList.sort(key=lambda x: x[2])
    queries.sort(key=lambda x: x[2])

    union_find = UnionFind(n)
    result = [False] * len(queries)
    curr = 0
    for u, v, w, i in queries:
        while curr < len(edgeList) and edgeList[curr][2] < w:
            union_find.union_set(edgeList[curr][0], edgeList[curr][1])
            curr += 1
        result[i] = union_find.find_set(u) == union_find.find_set(v)
    return result


import itertools


class Solution(object):
    def cherryPickup(self, grid):

    dp = [
        [[float("-inf")] * (len(grid[0]) + 2)
         for _ in xrange(len(grid[0]) + 2)]
        for _ in xrange(2)
    ]
    dp[0][1][len(grid[0])] = grid[0][0] + grid[0][len(grid[0]) - 1]
    for i in xrange(1, len(grid)):
        for j in xrange(1, len(grid[0]) + 1):
            for k in xrange(1, len(grid[0]) + 1):
                dp[i % 2][j][k] = max(
                    dp[(i - 1) % 2][j + d1][k + d2]
                    for d1 in xrange(-1, 2)
                    for d2 in xrange(-1, 2)
                ) + (
                    (grid[i][j - 1] + grid[i][k - 1]
                     ) if j != k else grid[i][j - 1]
                )
    return max(itertools.imap(max, *dp[(len(grid) - 1) % 2]))


import itertools


class Solution2(object):
    def cherryPickup(self, grid):

    dp = [
        [[float("-inf")] * len(grid[0]) for _ in xrange(len(grid[0]))]
        for _ in xrange(2)
    ]
    dp[0][0][len(grid[0]) - 1] = grid[0][0] + grid[0][len(grid[0]) - 1]
    for i in xrange(1, len(grid)):
        for j in xrange(len(grid[0])):
            for k in xrange(len(grid[0])):
                dp[i % 2][j][k] = max(
                    dp[(i - 1) % 2][j + d1][k + d2]
                    for d1 in xrange(-1, 2)
                    for d2 in xrange(-1, 2)
                    if 0 <= j + d1 < len(grid[0]) and 0 <= k + d2 < len(grid[0])
                ) + ((grid[i][j] + grid[i][k]) if j != k else grid[i][j])
    return max(itertools.imap(max, *dp[(len(grid) - 1) % 2]))


class Solution(object):
    def cherryPickup(self, grid):

    n = len(grid)
    dp = [[-1 for _ in xrange(n)] for _ in xrange(n)]
    dp[0][0] = grid[0][0]
    max_len = 2 * (n - 1)
    directions = [(0, 0), (-1, 0), (0, -1), (-1, -1)]
    for k in xrange(1, max_len + 1):
        for i in reversed(
            xrange(max(0, k - n + 1), min(k + 1, n))
        ):
            for j in reversed(xrange(i, min(k + 1, n))):
                if grid[i][k - i] == -1 or grid[j][k - j] == -1:
                    dp[i][j] = -1
                    continue
                cnt = grid[i][k - i]
                if i != j:
                    cnt += grid[j][k - j]
                max_cnt = -1
                for direction in directions:
                    ii, jj = i + direction[0], j + direction[1]
                    if ii >= 0 and jj >= 0 and dp[ii][jj] >= 0:
                        max_cnt = max(max_cnt, dp[ii][jj] + cnt)
                dp[i][j] = max_cnt
    return max(dp[n - 1][n - 1], 0)


import collections


class Solution(object):
    def maxNumberOfFamilies(self, n, reservedSeats):

    lookup = collections.defaultdict(lambda: [False] * 3)
    for r, c in reservedSeats:
        if 2 <= c <= 5:
            lookup[r][0] = True
        if 4 <= c <= 7:
            lookup[r][1] = True
        if 6 <= c <= 9:
            lookup[r][2] = True
    result = 2 * n
    for a, b, c in lookup.itervalues():
        if not a and not c:
            continue
        if not a or not b or not c:
            result -= 1
            continue
        result -= 2
    return result


class Solution2(object):
    def maxNumberOfFamilies(self, n, reservedSeats):

    reservedSeats.sort()
    result, i = 2 * n, 0
    while i < len(reservedSeats):
        reserved = [False] * 3
        curr = reservedSeats[i][0]
        while i < len(reservedSeats) and reservedSeats[i][0] == curr:
            _, c = reservedSeats[i]
            if 2 <= c <= 5:
                reserved[0] = True
            if 4 <= c <= 7:
                reserved[1] = True
            if 6 <= c <= 9:
                reserved[2] = True
            i += 1
        if not reserved[0] and not reserved[2]:
            continue
        if not all(reserved):
            result -= 1
            continue
        result -= 2
    return result


class Solution(object):
    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):

    x1 -= x_center
    y1 -= y_center
    x2 -= x_center
    y2 -= y_center
    x = x1 if x1 > 0 else x2 if x2 < 0 else 0
    y = y1 if y1 > 0 else y2 if y2 < 0 else 0
    return x ** 2 + y ** 2 <= radius ** 2


class Solution2(object):
    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):

    x1 -= x_center
    y1 -= y_center
    x2 -= x_center
    y2 -= y_center
    x = min(abs(x1), abs(x2)) if x1 * x2 > 0 else 0
    y = min(abs(y1), abs(y2)) if y1 * y2 > 0 else 0
    return x ** 2 + y ** 2 <= radius ** 2


class Solution(object):
    def circularArrayLoop(self, nums):

    def next_index(nums, i):
        return (i + nums[i]) % len(nums)

    for i in xrange(len(nums)):
        if nums[i] == 0:
            continue

        slow, fast = i, i
        while (
            nums[next_index(nums, slow)] * nums[i] > 0
            and nums[next_index(nums, fast)] * nums[i] > 0
            and nums[next_index(nums, next_index(nums, fast))] * nums[i] > 0
        ):
            slow = next_index(nums, slow)
            fast = next_index(nums, next_index(nums, fast))
            if slow == fast:
                if slow == next_index(nums, slow):
                    break
                return True

        slow, val = i, nums[i]
        while nums[slow] * val > 0:
            tmp = next_index(nums, slow)
            nums[slow] = 0
            slow = tmp

    return False


class Solution(object):
    def circularPermutation(self, n, start):

    return [start ^ (i >> 1) ^ i for i in xrange(1 << n)]


import itertools


class Solution(object):
    def climbStairs(self, n):

    def matrix_expo(A, K):
        result = [[int(i == j) for j in xrange(len(A))]
                  for i in xrange(len(A))]
        while K:
            if K % 2:
                result = matrix_mult(result, A)
            A = matrix_mult(A, A)
            K /= 2
        return result

    def matrix_mult(A, B):
        ZB = zip(*B)
        return [
            [sum(a * b for a, b in itertools.izip(row, col)) for col in ZB]
            for row in A
        ]

    T = [[1, 1], [1, 0]]
    return matrix_mult([[1, 0]], matrix_expo(T, n))[0][0]


class Solution2(object):

    def climbStairs(self, n):
    prev, current = 0, 1
    for i in xrange(n):
        prev, current = (
            current,
            prev + current,
        )
    return current


class Node(object):
    def __init__(self, val=0, left=None, right=None, random=None):
    self.val = val
    self.left = left
    self.right = right
    self.random = random


class NodeCopy(object):
    def __init__(self, val=0, left=None, right=None, random=None):
    pass


class Solution(object):
    def copyRandomBinaryTree(self, root):

    def iter_dfs(node, callback):
        result = None
        stk = [node]
        while stk:
            node = stk.pop()
            if not node:
                continue
            left_node, copy = callback(node)
            if not result:
                result = copy
            stk.append(node.right)
            stk.append(left_node)
        return result

    def merge(node):
        copy = NodeCopy(node.val)
        node.left, copy.left = copy, node.left
        return copy.left, copy

    def clone(node):
        copy = node.left
        node.left.random = node.random.left if node.random else None
        node.left.right = node.right.left if node.right else None
        return copy.left, copy

    def split(node):
        copy = node.left
        node.left, copy.left = copy.left, copy.left.left if copy.left else None
        return node.left, copy

    iter_dfs(root, merge)
    iter_dfs(root, clone)
    return iter_dfs(root, split)


class Solution_Recu(object):
    def copyRandomBinaryTree(self, root):

    def dfs(node, callback):
        if not node:
            return None
        left_node, copy = callback(node)
        dfs(left_node, callback)
        dfs(node.right, callback)
        return copy

    def merge(node):
        copy = NodeCopy(node.val)
        node.left, copy.left = copy, node.left
        return copy.left, copy

    def clone(node):
        copy = node.left
        node.left.random = node.random.left if node.random else None
        node.left.right = node.right.left if node.right else None
        return copy.left, copy

    def split(node):
        copy = node.left
        node.left, copy.left = copy.left, copy.left.left if copy.left else None
        return node.left, copy

    dfs(root, merge)
    dfs(root, clone)
    return dfs(root, split)


import collections


class Solution2(object):
    def copyRandomBinaryTree(self, root):

    lookup = collections.defaultdict(lambda: NodeCopy())
    lookup[None] = None
    stk = [root]
    while stk:
        node = stk.pop()
        if not node:
            continue
        lookup[node].val = node.val
        lookup[node].left = lookup[node.left]
        lookup[node].right = lookup[node.right]
        lookup[node].random = lookup[node.random]
        stk.append(node.right)
        stk.append(node.left)
    return lookup[root]


import collections


class Solution2_Recu(object):
    def copyRandomBinaryTree(self, root):

    def dfs(node, lookup):
        if not node:
            return
        lookup[node].val = node.val
        lookup[node].left = lookup[node.left]
        lookup[node].right = lookup[node.right]
        lookup[node].random = lookup[node.random]
        dfs(node.left, lookup)
        dfs(node.right, lookup)

    lookup = collections.defaultdict(lambda: NodeCopy())
    lookup[None] = None
    dfs(root, lookup)
    return lookup[root]


class UndirectedGraphNode(object):
    def __init__(self, x):
    self.label = x
    self.neighbors = []


class Solution(object):

    def cloneGraph(self, node):
    if node is None:
        return None
    cloned_node = UndirectedGraphNode(node.label)
    cloned, queue = {node: cloned_node}, [node]

    while queue:
        current = queue.pop()
        for neighbor in current.neighbors:
            if neighbor not in cloned:
                queue.append(neighbor)
                cloned_neighbor = UndirectedGraphNode(neighbor.label)
                cloned[neighbor] = cloned_neighbor
            cloned[current].neighbors.append(cloned[neighbor])
    return cloned[node]


class Node(object):
    def __init__(self, val=None, children=None):
    self.val = val
    self.children = children if children is not None else []


class Solution(object):
    def cloneTree(self, root):

    result = [None]
    stk = [(1, (root, result))]
    while stk:
        step, params = stk.pop()
        if step == 1:
            node, ret = params
            if not node:
                continue
            ret[0] = Node(node.val)
            for child in reversed(node.children):
                ret1 = [None]
                stk.append((2, (ret1, ret)))
                stk.append((1, (child, ret1)))
        else:
            ret1, ret = params
            ret[0].children.append(ret1[0])
    return result[0]


class Solution2(object):
    def cloneTree(self, root):

    def dfs(node):
        if not node:
            return None
        copy = Node(node.val)
        for child in node.children:
            copy.children.append(dfs(child))
        return copy

    return dfs(root)


class Solution(object):
    def closestKValues(self, root, target, k):

    def nextNode(stack, child1, child2):
        if stack:
            if child2(stack):
                stack.append(child2(stack))
                while child1(stack):
                    stack.append(child1(stack))
            else:
                child = stack.pop()
                while stack and child is child2(stack):
                    child = stack.pop()

    def backward(stack): return stack[-1].left
    def forward(stack): return stack[-1].right

    stack = []
    while root:
        stack.append(root)
        root = root.left if target < root.val else root.right

    def dist(node): return abs(node.val - target)
    forward_stack = stack[: stack.index(min(stack, key=dist)) + 1]

    backward_stack = list(forward_stack)
    nextNode(backward_stack, backward, forward)

    result = []
    for _ in xrange(k):
        if forward_stack and (
            not backward_stack or dist(
                forward_stack[-1]) < dist(backward_stack[-1])
        ):
            result.append(forward_stack[-1].val)
            nextNode(forward_stack, forward, backward)
        elif backward_stack and (
            not forward_stack or dist(
                backward_stack[-1]) <= dist(forward_stack[-1])
        ):
            result.append(backward_stack[-1].val)
            nextNode(backward_stack, backward, forward)
    return result


class Solution2(object):
    def closestKValues(self, root, target, k):

    class BSTIterator:

        def __init__(self, stack, child1, child2):
            self.stack = list(stack)
            self.cur = self.stack.pop()
            self.child1 = child1
            self.child2 = child2

        def next(self):
            node = None
            if self.cur and self.child1(self.cur):
                self.stack.append(self.cur)
                node = self.child1(self.cur)
                while self.child2(node):
                    self.stack.append(node)
                    node = self.child2(node)
            elif self.stack:
                prev = self.cur
                node = self.stack.pop()
                while node:
                    if self.child2(node) is prev:
                        break
                    else:
                        prev = node
                        node = self.stack.pop() if self.stack else None
            self.cur = node
            return node

    stack = []
    while root:
        stack.append(root)
        root = root.left if target < root.val else root.right

    def dist(node): return abs(node.val - target) if node else float("inf")
    stack = stack[: stack.index(min(stack, key=dist)) + 1]

    def backward(node): return node.left
    def forward(node): return node.right
    smaller_it, larger_it = BSTIterator(stack, backward, forward), BSTIterator(
        stack, forward, backward
    )
    smaller_node, larger_node = smaller_it.next(), larger_it.next()

    result = [stack[-1].val]
    for _ in xrange(k - 1):
        if dist(smaller_node) < dist(larger_node):
            result.append(smaller_node.val)
            smaller_node = smaller_it.next()
        else:
            result.append(larger_node.val)
            larger_node = larger_it.next()
    return result


class Solution(object):
    def closestValue(self, root, target):

    gap = float("inf")
    closest = float("inf")
    while root:
        if abs(root.val - target) < gap:
            gap = abs(root.val - target)
            closest = root.val
        if target == root.val:
            break
        elif target < root.val:
            root = root.left
        else:
            root = root.right
    return closest


class Solution(object):
    def closestCost(self, baseCosts, toppingCosts, target):

    max_count = 2
    max_base, max_topping = max(baseCosts), max(toppingCosts)
    dp = [False] * (max(max_base, target + max_topping // 2) + 1)
    for b in baseCosts:
        dp[b] = True
    for t in toppingCosts:
        for _ in xrange(max_count):
            for i in reversed(xrange(len(dp) - t)):
                if dp[i]:
                    dp[i + t] = True
    result = float("inf")
    for i in xrange(1, len(dp)):
        if not dp[i]:
            continue
        if abs(i - target) < abs(result - target):
            result = i
        if i >= target:
            break
    return result


class Solution2(object):
    def closestCost(self, baseCosts, toppingCosts, target):

    max_count = 2

    def backtracking(toppingCosts, i, cost, target, lookup, result):
        if (i, cost) in lookup:
            return
        lookup.add((i, cost))
        if cost >= target or i == len(toppingCosts):
            if (abs(cost - target), cost) < (abs(result[0] - target), result[0]):
                result[0] = cost
            return
        for j in xrange(max_count + 1):
            backtracking(
                toppingCosts,
                i + 1,
                cost + j * toppingCosts[i],
                target,
                lookup,
                result,
            )

    result = [float("inf")]
    lookup = set()
    for b in baseCosts:
        backtracking(toppingCosts, 0, b, target, lookup, result)
    return result[0]


import bisect


class Solution3(object):
    def closestCost(self, baseCosts, toppingCosts, target):

    max_count = 2
    combs = set([0])
    for t in toppingCosts:
        combs = set([c + i * t for c in combs for i in xrange(max_count + 1)])
    result, combs = float("inf"), sorted(combs)
    for b in baseCosts:
        idx = bisect.bisect_left(combs, target - b)
        if idx < len(combs):
            result = min(result, b + combs[idx],
                         key=lambda x: (abs(x - target), x))
        if idx > 0:
            result = min(
                result, b + combs[idx - 1], key=lambda x: (abs(x - target), x)
            )
    return result


class Solution4(object):
    def closestCost(self, baseCosts, toppingCosts, target):

    max_count = 2
    combs = set([0])
    for t in toppingCosts:
        combs = set([c + i * t for c in combs for i in xrange(max_count + 1)])
    result = float("inf")
    for b in baseCosts:
        for c in combs:
            result = min(result, b + c, key=lambda x: (abs(x - target), x))
    return result


class Solution(object):
    def closestDivisors(self, num):

    def divisors(n):
        for d in reversed(xrange(1, int(n ** 0.5) + 1)):
            if n % d == 0:
                return d, n // d
        return 1, n

    return min([divisors(num + 1), divisors(num + 2)], key=lambda x: x[1] - x[0])


class Solution2(object):
    def closestDivisors(self, num):

    result, d = [1, num + 1], 1
    while d * d <= num + 2:
        if (num + 2) % d == 0:
            result = [d, (num + 2) // d]
        if (num + 1) % d == 0:
            result = [d, (num + 1) // d]
        d += 1
    return result


import collections


class Solution(object):
    def findClosestLeaf(self, root, k):

    def traverse(node, neighbors, leaves):
        if not node:
            return
        if not node.left and not node.right:
            leaves.add(node.val)
            return
        if node.left:
            neighbors[node.val].append(node.left.val)
            neighbors[node.left.val].append(node.val)
            traverse(node.left, neighbors, leaves)
        if node.right:
            neighbors[node.val].append(node.right.val)
            neighbors[node.right.val].append(node.val)
            traverse(node.right, neighbors, leaves)

    neighbors, leaves = collections.defaultdict(list), set()
    traverse(root, neighbors, leaves)
    q, lookup = [k], set([k])
    while q:
        next_q = []
        for u in q:
            if u in leaves:
                return u
            for v in neighbors[u]:
                if v in lookup:
                    continue
                lookup.add(v)
                next_q.append(v)
        q = next_q
    return 0


import bisect


class Solution(object):
    def minAbsDifference(self, nums, goal):

    mx, mn = sum(x for x in nums if x > 0), sum(x for x in nums if x < 0)
    if goal > mx:
        return goal - mx
    if goal < mn:
        return mn - goal
    result = abs(goal)
    sums1 = set([0])
    for i in xrange(len(nums) // 2):
        for x in list(sums1):
            if x + nums[i] in sums1:
                continue
            sums1.add(x + nums[i])
            result = min(
                result, abs(goal - x - nums[i])
            )
    sorted_sums1 = sorted(sums1)
    sums2 = set([0])
    for i in xrange(len(nums) // 2, len(nums)):
        for x in list(sums2):
            if x + nums[i] in sums2:
                continue
            sums2.add(x + nums[i])
            ni = bisect.bisect_left(sorted_sums1, goal - x - nums[i])
            if ni < len(sorted_sums1):
                result = min(result, abs(
                    goal - x - nums[i] - sorted_sums1[ni]))
            if ni > 0:
                result = min(result, abs(
                    goal - x - nums[i] - sorted_sums1[ni - 1]))
            if result == 0:
                return result
    return result


class Solution(object):
    def clumsy(self, N):

    if N <= 2:
        return N
    if N <= 4:
        return N + 3

    if N % 4 == 0:
        return N + 1
    elif N % 4 <= 2:
        return N + 2
    return N - 1


class Solution(object):
    def change(self, amount, coins):

    dp = [0] * (amount + 1)
    dp[0] = 1
    for coin in coins:
        for i in xrange(coin, amount + 1):
            dp[i] += dp[i - coin]
    return dp[amount]


class Solution(object):
    def coinChange(self, coins, amount):

    INF = 0x7FFFFFFF
    dp = [INF] * (amount + 1)
    dp[0] = 0
    for i in xrange(amount + 1):
        if dp[i] != INF:
            for coin in coins:
                if i + coin <= amount:
                    dp[i + coin] = min(dp[i + coin], dp[i] + 1)
    return dp[amount] if dp[amount] != INF else -1


class Solution(object):
    def cheapestJump(self, A, B):

    result = []
    if not A or A[-1] == -1:
        return result
    n = len(A)
    dp, next_pos = [float("inf")] * n, [-1] * n
    dp[n - 1] = A[n - 1]
    for i in reversed(xrange(n - 1)):
        if A[i] == -1:
            continue
        for j in xrange(i + 1, min(i + B + 1, n)):
            if A[i] + dp[j] < dp[i]:
                dp[i] = A[i] + dp[j]
                next_pos[i] = j
    if dp[0] == float("inf"):
        return result
    k = 0
    while k != -1:
        result.append(k + 1)
        k = next_pos[k]
    return result


import collections


class Solution(object):
    def colorBorder(self, grid, r0, c0, color):

    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

    lookup, q, borders = set([(r0, c0)]), collections.deque([(r0, c0)]), []
    while q:
        r, c = q.popleft()
        is_border = False

        for direction in directions:
            nr, nc = r + direction[0], c + direction[1]
            if not (
                (0 <= nr < len(grid))
                and (0 <= nc < len(grid[0]))
                and grid[nr][nc] == grid[r][c]
            ):
                is_border = True
                continue
            if (nr, nc) in lookup:
                continue
            lookup.add((nr, nc))
            q.append((nr, nc))

        if is_border:
            borders.append((r, c))

    for r, c in borders:
        grid[r][c] = color
    return grid


class Solution(object):

    def combinationSum2(self, candidates, target):
    result = []
    self.combinationSumRecu(sorted(candidates), result, 0, [], target)
    return result

    def combinationSumRecu(self, candidates, result, start, intermediate, target):
    if target == 0:
        result.append(list(intermediate))
    prev = 0
    while start < len(candidates) and candidates[start] <= target:
        if prev != candidates[start]:
            intermediate.append(candidates[start])
            self.combinationSumRecu(
                candidates,
                result,
                start + 1,
                intermediate,
                target - candidates[start],
            )
            intermediate.pop()
            prev = candidates[start]
        start += 1


class Solution(object):

    def combinationSum3(self, k, n):
    result = []
    self.combinationSumRecu(result, [], 1, k, n)
    return result

    def combinationSumRecu(self, result, intermediate, start, k, target):
    if k == 0 and target == 0:
        result.append(list(intermediate))
    elif k < 0:
        return
    while start < 10 and start * k + k * (k - 1) / 2 <= target:
        intermediate.append(start)
        self.combinationSumRecu(
            result, intermediate, start + 1, k - 1, target - start
        )
        intermediate.pop()
        start += 1


class Solution(object):
    def combinationSum4(self, nums, target):

    dp = [0] * (target + 1)
    dp[0] = 1
    nums.sort()

    for i in xrange(1, target + 1):
        for j in xrange(len(nums)):
            if nums[j] <= i:
                dp[i] += dp[i - nums[j]]
            else:
                break

    return dp[target]


class Solution(object):

    def combinationSum(self, candidates, target):
    result = []
    self.combinationSumRecu(sorted(candidates), result, 0, [], target)
    return result

    def combinationSumRecu(self, candidates, result, start, intermediate, target):
    if target == 0:
        result.append(list(intermediate))
    while start < len(candidates) and candidates[start] <= target:
        intermediate.append(candidates[start])
        self.combinationSumRecu(
            candidates, result, start, intermediate, target - candidates[start]
        )
        intermediate.pop()
        start += 1


class Solution(object):
    def combine(self, n, k):

    if k > n:
        return []
    nums, idxs = range(1, n + 1), range(k)
    result = [[nums[i] for i in idxs]]
    while True:
        for i in reversed(xrange(k)):
            if idxs[i] != i + n - k:
                break
        else:
            break
        idxs[i] += 1
        for j in xrange(i + 1, k):
            idxs[j] = idxs[j - 1] + 1
        result.append([nums[i] for i in idxs])
    return result


class Solution2(object):
    def combine(self, n, k):

    result, combination = [], []
    i = 1
    while True:
        if len(combination) == k:
            result.append(combination[:])
        if len(combination) == k or len(combination) + (n - i + 1) < k:
            if not combination:
                break
            i = combination.pop() + 1
        else:
            combination.append(i)
            i += 1
    return result


class Solution3(object):
    def combine(self, n, k):

    def combineDFS(n, start, intermediate, k, result):
        if k == 0:
            result.append(intermediate[:])
            return
        for i in xrange(start, n):
            intermediate.append(i + 1)
            combineDFS(n, i + 1, intermediate, k - 1, result)
            intermediate.pop()

    result = []
    combineDFS(n, 0, [], k, result)
    return result


import bisect


class Solution(object):
    def numSmallerByFrequency(self, queries, words):

    words_freq = sorted(word.count(min(word)) for word in words)
    return [
        len(words) - bisect.bisect_right(words_freq, query.count(min(query)))
        for query in queries
    ]


import itertools


class Solution(object):
    def compareVersion(self, version1, version2):

    n1, n2 = len(version1), len(version2)
    i, j = 0, 0
    while i < n1 or j < n2:
        v1, v2 = 0, 0
        while i < n1 and version1[i] != ".":
            v1 = v1 * 10 + int(version1[i])
            i += 1
        while j < n2 and version2[j] != ".":
            v2 = v2 * 10 + int(version2[j])
            j += 1
        if v1 != v2:
            return 1 if v1 > v2 else -1
        i += 1
        j += 1

    return 0


class Solution2(object):
    def compareVersion(self, version1, version2):

    v1, v2 = version1.split("."), version2.split(".")

    if len(v1) > len(v2):
        v2 += ["0" for _ in xrange(len(v1) - len(v2))]
    elif len(v1) < len(v2):
        v1 += ["0" for _ in xrange(len(v2) - len(v1))]

    i = 0
    while i < len(v1):
        if int(v1[i]) > int(v2[i]):
            return 1
        elif int(v1[i]) < int(v2[i]):
            return -1
        else:
            i += 1

    return 0

    def compareVersion2(self, version1, version2):

    v1 = [int(x) for x in version1.split(".")]
    v2 = [int(x) for x in version2.split(".")]
    while len(v1) != len(v2):
        if len(v1) > len(v2):
            v2.append(0)
        else:
            v1.append(0)
    return cmp(v1, v2)

    def compareVersion3(self, version1, version2):
    splits = (map(int, v.split(".")) for v in (version1, version2))
    return cmp(*zip(*itertools.izip_longest(*splits, fillvalue=0)))

    def compareVersion4(self, version1, version2):
    main1, _, rest1 = ("0" + version1).partition(".")
    main2, _, rest2 = ("0" + version2).partition(".")
    return (
        cmp(int(main1), int(main2))
        or len(rest1 + rest2)
        and self.compareVersion4(rest1, rest2)
    )


class Solution(object):
    def bitwiseComplement(self, N):

    mask = 1
    while N > mask:
        mask = mask * 2 + 1
    return mask - N


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class CBTInserter(object):
    def __init__(self, root):

    self.__tree = [root]
    for i in self.__tree:
        if i.left:
            self.__tree.append(i.left)
        if i.right:
            self.__tree.append(i.right)

    def insert(self, v):

    n = len(self.__tree)
    self.__tree.append(TreeNode(v))
    if n % 2:
        self.__tree[(n - 1) // 2].left = self.__tree[-1]
    else:
        self.__tree[(n - 1) // 2].right = self.__tree[-1]
    return self.__tree[(n - 1) // 2].val

    def get_root(self):

    return self.__tree[0]


class Solution(object):
    def complexNumberMultiply(self, a, b):

    ra, ia = map(int, a[:-1].split("+"))
    rb, ib = map(int, b[:-1].split("+"))
    return "%d+%di" % (ra * rb - ia * ib, ra * ib + ia * rb)


class Solution(object):
    def findAllConcatenatedWordsInADict(self, words):

    lookup = set(words)
    result = []
    for word in words:
        dp = [False] * (len(word) + 1)
        dp[0] = True
        for i in xrange(len(word)):
            if not dp[i]:
                continue

            for j in xrange(i + 1, len(word) + 1):
                if j - i < len(word) and word[i:j] in lookup:
                    dp[j] = True

            if dp[len(word)]:
                result.append(word)
                break

    return result


class Solution(object):
    def concatenatedBinary(self, n):

    MOD = 10 ** 9 + 7
    result = l = 0
    for i in xrange(1, n + 1):
        if i & (i - 1) == 0:
            l += 1
        result = ((result << l) % MOD + i) % MOD
    return result


class Solution(object):
    def confusingNumberII(self, N):

    lookup = {"0": "0", "1": "1", "6": "9", "8": "8", "9": "6"}
    centers = {"0": "0", "1": "1", "8": "8"}

    def totalCount(N):
        s = str(N)
        total = 0
        p = len(lookup) ** (len(s) - 1)
        for i in xrange(len(s)):
            if i + 1 == len(s):
                for c in lookup.iterkeys():
                    total += int(c <= s[i])
                continue
            smaller = 0
            for c in lookup.iterkeys():
                smaller += int(c < s[i])
            total += smaller * p
            if s[i] not in lookup:
                break
            p //= len(lookup)
        return total

    def validCountInLessLength(N):
        s = str(N)
        valid = 0
        total = len(centers)
        for i in xrange(1, len(s), 2):
            if i == 1:
                valid += total
            else:
                valid += total * (len(lookup) - 1)
                total *= len(lookup)
        total = 1
        for i in xrange(2, len(s), 2):
            valid += total * (len(lookup) - 1)
            total *= len(lookup)
        return valid

    def validCountInFullLength(N):
        s = str(N)
        half_s = s[: (len(s) + 1) // 2]
        total = 0
        p = (
            len(lookup) ** (len(half_s) - 2) * len(centers)
            if (len(s) % 2)
            else len(lookup) ** (len(half_s) - 1)
        )
        choices = centers if (len(s) % 2) else lookup
        for i in xrange(len(half_s)):
            if i + 1 == len(half_s):
                for c in choices.iterkeys():
                    if c == "0" and i == 0:
                        continue
                    total += int(c < half_s[i])
                if half_s[i] not in choices:
                    break
                tmp = list(half_s)
                for i in reversed(xrange(len(half_s) - (len(s) % 2))):
                    tmp.append(lookup[half_s[i]])
                if int("".join(tmp)) <= N:
                    total += 1
                continue

            smaller = 0
            for c in lookup.iterkeys():
                if c == "0" and i == 0:
                    continue
                smaller += int(c < half_s[i])
            total += smaller * p
            if half_s[i] not in lookup:
                break
            p //= len(lookup)
        return total

    return totalCount(N) - validCountInLessLength(N) - validCountInFullLength(N)


class Solution(object):
    def confusingNumber(self, N):

    lookup = {"0": "0", "1": "1", "6": "9", "8": "8", "9": "6"}

    S = str(N)
    result = []
    for i in xrange(len(S)):
        if S[i] not in lookup:
            return False
    for i in xrange((len(S) + 1) // 2):
        if S[i] != lookup[S[-(i + 1)]]:
            return True
    return False


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.count = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    self.count -= 1
    return True


class Solution(object):
    def minimumCost(self, N, connections):

    connections.sort(key=lambda x: x[2])
    union_find = UnionFind(N)
    result = 0
    for u, v, val in connections:
        if union_find.union_set(u - 1, v - 1):
            result += val
    return result if union_find.count == 1 else -1


class Solution(object):
    def maxPower(self, s):

    result, count = 1, 1
    for i in xrange(1, len(s)):
        if s[i] == s[i - 1]:
            count += 1
        else:
            count = 1
        result = max(result, count)
    return result


import itertools


class Solution2(object):
    def maxPower(self, s):
    return max(len(list(v)) for _, v in itertools.groupby(s))


class Solution(object):
    def consecutiveNumbersSum(self, N):

    result = 1
    while N % 2 == 0:
        N /= 2
    i = 3
    while i * i <= N:
        count = 0
        while N % i == 0:
            N /= i
            count += 1
        result *= count + 1
        i += 2
    if N > 1:
        result *= 2
    return result


import collections


class Solution(object):
    def constrainedSubsetSum(self, nums, k):

    result, dq = float("-inf"), collections.deque()
    for i in xrange(len(nums)):
        if dq and i - dq[0][0] == k + 1:
            dq.popleft()
        curr = nums[i] + (dq[0][1] if dq else 0)
        while dq and dq[-1][1] <= curr:
            dq.pop()
        if curr > 0:
            dq.append((i, curr))
        result = max(result, curr)
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def bstFromPreorder(self, preorder):

    def bstFromPreorderHelper(preorder, left, right, index):
        if (
            index[0] == len(preorder)
            or preorder[index[0]] < left
            or preorder[index[0]] > right
        ):
            return None

        root = TreeNode(preorder[index[0]])
        index[0] += 1
        root.left = bstFromPreorderHelper(preorder, left, root.val, index)
        root.right = bstFromPreorderHelper(preorder, root.val, right, index)
        return root

    return bstFromPreorderHelper(preorder, float("-inf"), float("inf"), [0])


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def buildTree(self, inorder, postorder):
    lookup = {}
    for i, num in enumerate(inorder):
        lookup[num] = i
    return self.buildTreeRecu(
        lookup, postorder, inorder, len(postorder), 0, len(inorder)
    )

    def buildTreeRecu(self, lookup, postorder, inorder, post_end, in_start, in_end):
    if in_start == in_end:
        return None
    node = TreeNode(postorder[post_end - 1])
    i = lookup[postorder[post_end - 1]]
    node.left = self.buildTreeRecu(
        lookup, postorder, inorder, post_end -
        1 - (in_end - i - 1), in_start, i
    )
    node.right = self.buildTreeRecu(
        lookup, postorder, inorder, post_end - 1, i + 1, in_end
    )
    return node


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def buildTree(self, preorder, inorder):
    lookup = {}
    for i, num in enumerate(inorder):
        lookup[num] = i
    return self.buildTreeRecu(lookup, preorder, inorder, 0, 0, len(inorder))

    def buildTreeRecu(self, lookup, preorder, inorder, pre_start, in_start, in_end):
    if in_start == in_end:
        return None
    node = TreeNode(preorder[pre_start])
    i = lookup[preorder[pre_start]]
    node.left = self.buildTreeRecu(
        lookup, preorder, inorder, pre_start + 1, in_start, i
    )
    node.right = self.buildTreeRecu(
        lookup, preorder, inorder, pre_start + 1 + i - in_start, i + 1, in_end
    )
    return node


class Solution2(object):
    def buildTree(self, preorder, inorder):

    preorder_iterator = iter(preorder)
    inorder_lookup = {n: i for i, n in enumerate(inorder)}

    def helper(start, end):
        if start > end:
            return None

        root_val = next(preorder_iterator)
        root = TreeNode(root_val)
        idx = inorder_lookup[root_val]
        root.left = helper(start, idx - 1)
        root.right = helper(idx + 1, end)
        return root

    return helper(0, len(inorder) - 1)


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def constructFromPrePost(self, pre, post):

    stack = [TreeNode(pre[0])]
    j = 0
    for i in xrange(1, len(pre)):
        node = TreeNode(pre[i])
        while stack[-1].val == post[j]:
            stack.pop()
            j += 1
        if not stack[-1].left:
            stack[-1].left = node
        else:
            stack[-1].right = node
        stack.append(node)
    return stack[0]


class Solution2(object):
    def constructFromPrePost(self, pre, post):

    def constructFromPrePostHelper(
        pre, pre_s, pre_e, post, post_s, post_e, post_entry_idx_map
    ):
        if pre_s >= pre_e or post_s >= post_e:
            return None
        node = TreeNode(pre[pre_s])
        if pre_e - pre_s > 1:
            left_tree_size = post_entry_idx_map[pre[pre_s + 1]] - post_s + 1
            node.left = constructFromPrePostHelper(
                pre,
                pre_s + 1,
                pre_s + 1 + left_tree_size,
                post,
                post_s,
                post_s + left_tree_size,
                post_entry_idx_map,
            )
            node.right = constructFromPrePostHelper(
                pre,
                pre_s + 1 + left_tree_size,
                pre_e,
                post,
                post_s + left_tree_size,
                post_e - 1,
                post_entry_idx_map,
            )
        return node

    post_entry_idx_map = {}
    for i, val in enumerate(post):
        post_entry_idx_map[val] = i
    return constructFromPrePostHelper(
        pre, 0, len(pre), post, 0, len(post), post_entry_idx_map
    )


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def str2tree(self, s):

    def str2treeHelper(s, i):
        start = i
        if s[i] == "-":
            i += 1
        while i < len(s) and s[i].isdigit():
            i += 1
        node = TreeNode(int(s[start:i]))
        if i < len(s) and s[i] == "(":
            i += 1
            node.left, i = str2treeHelper(s, i)
            i += 1
        if i < len(s) and s[i] == "(":
            i += 1
            node.right, i = str2treeHelper(s, i)
            i += 1
        return node, i

    return str2treeHelper(s, 0)[0] if s else None


import collections


class Solution(object):
    def canConstruct(self, s, k):

    count = collections.Counter(s)
    odd = sum(v % 2 for v in count.itervalues())
    return odd <= k <= len(s)


class Node(object):
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
    self.val = val
    self.isLeaf = isLeaf
    self.topLeft = topLeft
    self.topRight = topRight
    self.bottomLeft = bottomLeft
    self.bottomRight = bottomRight


class Solution(object):
    def construct(self, grid):

    def dfs(grid, x, y, l):
        if l == 1:
            return Node(grid[x][y] == 1, True, None, None, None, None)
        half = l // 2
        topLeftNode = dfs(grid, x, y, half)
        topRightNode = dfs(grid, x, y + half, half)
        bottomLeftNode = dfs(grid, x + half, y, half)
        bottomRightNode = dfs(grid, x + half, y + half, half)
        if (
            topLeftNode.isLeaf
            and topRightNode.isLeaf
            and bottomLeftNode.isLeaf
            and bottomRightNode.isLeaf
            and topLeftNode.val
            == topRightNode.val
            == bottomLeftNode.val
            == bottomRightNode.val
        ):
            return Node(topLeftNode.val, True, None, None, None, None)
        return Node(
            True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode
        )

    if not grid:
        return None
    return dfs(grid, 0, 0, len(grid))


class Solution(object):
    def tree2str(self, t):

    if not t:
        return ""
    s = str(t.val)
    if t.left or t.right:
        s += "(" + self.tree2str(t.left) + ")"
    if t.right:
        s += "(" + self.tree2str(t.right) + ")"
    return s


import heapq


class Solution(object):
    def isPossible(self, target):

    total = sum(target)
    max_heap = [-x for x in target]
    heapq.heapify(max_heap)
    while total != len(target):
        y = -heapq.heappop(max_heap)
        remain = total - y
        x = y - remain
        if x <= 0:
            return False
        if x > remain:
            x = x % remain + remain
        heapq.heappush(max_heap, -x)
        total = x + remain
    return True


class Solution(object):
    def constructDistancedSequence(self, n):

    def backtracking(n, i, result, lookup):
        if i == len(result):
            return True
        if result[i]:
            return backtracking(n, i + 1, result, lookup)
        for x in reversed(xrange(1, n + 1)):
            j = i if x == 1 else i + x
            if lookup[x] or j >= len(result) or result[j]:
                continue
            result[i], result[j], lookup[x] = x, x, True
            if backtracking(n, i + 1, result, lookup):
                return True
            result[i], result[j], lookup[x] = 0, 0, False
        return False

    result, lookup = [0] * (2 * n - 1), [False] * (n + 1)
    backtracking(n, 0, result, lookup)
    return result


import math


class Solution(object):
    def constructRectangle(self, area):

    w = int(math.sqrt(area))
    while area % w:
        w -= 1
    return [area // w, w]


class Solution(object):
    def containVirus(self, grid):

    directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]

    def dfs(grid, r, c, lookup, regions, frontiers, perimeters):
        if (r, c) in lookup:
            return
        lookup.add((r, c))
        regions[-1].add((r, c))
        for d in directions:
            nr, nc = r + d[0], c + d[1]
            if not (0 <= nr < len(grid) and 0 <= nc < len(grid[r])):
                continue
            if grid[nr][nc] == 1:
                dfs(grid, nr, nc, lookup, regions, frontiers, perimeters)
            elif grid[nr][nc] == 0:
                frontiers[-1].add((nr, nc))
                perimeters[-1] += 1

    result = 0
    while True:
        lookup, regions, frontiers, perimeters = set(), [], [], []
        for r, row in enumerate(grid):
            for c, val in enumerate(row):
                if val == 1 and (r, c) not in lookup:
                    regions.append(set())
                    frontiers.append(set())
                    perimeters.append(0)
                    dfs(grid, r, c, lookup, regions, frontiers, perimeters)

        if not regions:
            break

        triage_idx = frontiers.index(max(frontiers, key=len))
        for i, region in enumerate(regions):
            if i == triage_idx:
                result += perimeters[i]
                for r, c in region:
                    grid[r][c] = -1
                continue
            for r, c in region:
                for d in directions:
                    nr, nc = r + d[0], c + d[1]
                    if not (0 <= nr < len(grid) and 0 <= nc < len(grid[r])):
                        continue
                    if grid[nr][nc] == 0:
                        grid[nr][nc] = 1

    return result


class Solution(object):

    def maxArea(self, height):
    max_area, i, j = 0, 0, len(height) - 1
    while i < j:
        max_area = max(max_area, min(height[i], height[j]) * (j - i))
        if height[i] < height[j]:
            i += 1
        else:
            j -= 1
    return max_area


class Solution(object):

    def containsNearbyDuplicate(self, nums, k):
    lookup = {}
    for i, num in enumerate(nums):
        if num not in lookup:
            lookup[num] = i
        else:

            if i - lookup[num] <= k:
                return True

            lookup[num] = i
    return False


import collections


class Solution(object):

    def containsNearbyAlmostDuplicate(self, nums, k, t):
    if k < 0 or t < 0:
        return False
    window = collections.OrderedDict()
    for n in nums:

        if len(window) > k:
            window.popitem(False)

        bucket = n if not t else n // t

        for m in (
            window.get(bucket - 1),
            window.get(bucket),
            window.get(bucket + 1),
        ):
            if m is not None and abs(n - m) <= t:
                return True
        window[bucket] = n
    return False


class Solution(object):

    def containsDuplicate(self, nums):
    return len(nums) > len(set(nums))


class Solution(object):
    def findMaxLength(self, nums):

    result, count = 0, 0
    lookup = {0: -1}
    for i, num in enumerate(nums):
        count += 1 if num == 1 else -1
        if count in lookup:
            result = max(result, i - lookup[count])
        else:
            lookup[count] = i

    return result


class Solution(object):
    def checkSubarraySum(self, nums, k):

    count = 0
    lookup = {0: -1}
    for i, num in enumerate(nums):
        count += num
        if k:
            count %= k
        if count in lookup:
            if i - lookup[count] > 1:
                return True
        else:
            lookup[count] = i

    return False


class Solution(object):
    def toHex(self, num):

    if not num:
        return "0"

    result = []
    while num and len(result) != 8:
        h = num & 15
        if h < 10:
            result.append(str(chr(ord("0") + h)))
        else:
            result.append(str(chr(ord("a") + h - 10)))
        num >>= 4
    result.reverse()

    return "".join(result)


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):
    def getDecimalValue(self, head):

    result = 0
    while head:
        result = result * 2 + head.val
        head = head.next
    return result


class Node(object):
    def __init__(self, val, left, right):
    self.val = val
    self.left = left
    self.right = right


class Solution(object):
    def treeToDoublyList(self, root):

    if not root:
        return None
    left_head, left_tail, right_head, right_tail = root, root, root, root
    if root.left:
        left_head = self.treeToDoublyList(root.left)
        left_tail = left_head.left
    if root.right:
        right_head = self.treeToDoublyList(root.right)
        right_tail = right_head.left
    left_tail.right, right_head.left = root, root
    root.left, root.right = left_tail, right_head
    left_head.left, right_tail.right = right_tail, left_head
    return left_head


class Solution(object):
    def convertBST(self, root):

    def convertBSTHelper(root, cur_sum):
        if not root:
            return cur_sum

        if root.right:
            cur_sum = convertBSTHelper(root.right, cur_sum)
        cur_sum += root.val
        root.val = cur_sum
        if root.left:
            cur_sum = convertBSTHelper(root.left, cur_sum)
        return cur_sum

    convertBSTHelper(root, 0)
    return root


class Solution(object):
    def getNoZeroIntegers(self, n):

    a, curr, base = 0, n, 1
    while curr:
        if curr % 10 == 0 or (curr % 10 == 1 and curr != 1):
            a += base
            curr -= 10
        a += base
        base *= 10
        curr //= 10
    return [a, n - a]


class Solution2(object):
    def getNoZeroIntegers(self, n):

    return next(
        [a, n - a] for a in xrange(1, n) if "0" not in "{}{}".format(a, n - a)
    )


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def sortedArrayToBST(self, nums):

    return self.sortedArrayToBSTRecu(nums, 0, len(nums))

    def sortedArrayToBSTRecu(self, nums, start, end):
    if start == end:
        return None
    mid = start + self.perfect_tree_pivot(end - start)
    node = TreeNode(nums[mid])
    node.left = self.sortedArrayToBSTRecu(nums, start, mid)
    node.right = self.sortedArrayToBSTRecu(nums, mid + 1, end)
    return node

    def perfect_tree_pivot(self, n):

    x = 1

    x = 1 << (
        n.bit_length() - 1
    )

    if x // 2 - 1 <= (n - x):
        return (
            x - 1
        )
    else:
        return (
            n - x // 2
        )


class Solution2(object):
    def sortedArrayToBST(self, nums):

    self.iterator = iter(nums)
    return self.helper(0, len(nums))

    def helper(self, start, end):
    if start == end:
        return None

    mid = (start + end) // 2
    left = self.helper(start, mid)
    current = TreeNode(next(self.iterator))
    current.left = left
    current.right = self.helper(mid + 1, end)
    return current


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):
    head = None

    def sortedListToBST(self, head):
    current, length = head, 0
    while current is not None:
        current, length = current.next, length + 1
    self.head = head
    return self.sortedListToBSTRecu(0, length)

    def sortedListToBSTRecu(self, start, end):
    if start == end:
        return None
    mid = start + (end - start) / 2
    left = self.sortedListToBSTRecu(start, mid)
    current = TreeNode(self.head.val)
    current.left = left
    self.head = self.head.next
    current.right = self.sortedListToBSTRecu(mid + 1, end)
    return current


class Solution(object):
    def baseNeg2(self, N):

    result = []
    while N:
        result.append(str(-N & 1))
        N = -(N >> 1)
    result.reverse()
    return "".join(result) if result else "0"


class Solution2(object):
    def baseNeg2(self, N):

    BASE = -2
    result = []
    while N:
        N, r = divmod(N, BASE)
        if r < 0:
            r -= BASE
            N += 1
        result.append(str(r))
    result.reverse()
    return "".join(result) if result else "0"


class Solution(object):
    def isConvex(self, points):

    def det(A):
        return A[0][0] * A[1][1] - A[0][1] * A[1][0]

    n, prev, curr = len(points), 0, None
    for i in xrange(len(points)):
        A = [
            [
                points[(i + j) % n][0] - points[i][0],
                points[(i + j) % n][1] - points[i][1],
            ]
            for j in (1, 2)
        ]
        curr = det(A)
        if curr:
            if curr * prev < 0:
                return False
            prev = curr
    return True


class Solution(object):
    def bestCoordinate(self, towers, radius):

    min_x = min(towers, key=lambda x: x[0])[0]
    max_x = max(towers, key=lambda x: x[0])[0]
    min_y = min(towers, key=lambda x: x[1])[1]
    max_y = max(towers, key=lambda x: x[1])[1]
    max_quality = 0
    for x in xrange(min_x, max_x + 1):
        for y in xrange(min_y, max_y + 1):
            q = 0
            for nx, ny, nq in towers:
                d = ((nx - x) ** 2 + (ny - y) ** 2) ** 0.5
                if d <= radius:
                    q += int(nq / (1 + d))
            if q > max_quality:
                max_quality = q
                result = x, y
    return result


class Node(object):
    def __init__(self, x):
    self.val = x
    self.next = None
    self.random = None


class Solution(object):

    def copyRandomList(self, head):

    current = head
    while current:
        copied = Node(current.val)
        copied.next = current.next
        current.next = copied
        current = copied.next

    current = head
    while current:
        if current.random:
            current.next.random = current.random.next
        current = current.next.next

    dummy = Node(0)
    copied_current, current = dummy, head
    while current:
        copied_current.next = current.next
        current.next = current.next.next
        copied_current, current = copied_current.next, current.next
    return dummy.next


class Solution2(object):

    def copyRandomList(self, head):
    dummy = Node(0)
    current, prev, copies = head, dummy, {}

    while current:
        copied = Node(current.val)
        copies[current] = copied
        prev.next = copied
        prev, current = prev.next, current.next

    current = head
    while current:
        if current.random:
            copies[current].random = copies[current.random]
        current = current.next

    return dummy.next


from collections import defaultdict


class Solution3(object):
    def copyRandomList(self, head):

    clone = defaultdict(lambda: Node(0))
    clone[None] = None
    cur = head

    while cur:
        clone[cur].val = cur.val
        clone[cur].next = clone[cur.next]
        clone[cur].random = clone[cur.random]
        cur = cur.next

    return clone[head]


class Solution(object):
    def corpFlightBookings(self, bookings, n):

    result = [0] * (n + 1)
    for i, j, k in bookings:
        result[i - 1] += k
        result[j] -= k
    for i in xrange(1, len(result)):
        result[i] += result[i - 1]
    result.pop()
    return result


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    pass


class Solution(object):
    def correctBinaryTree(self, root):

    q = {root: None}
    while q:
        new_q = {}
        for node, parent in q.iteritems():
            if node.right in q:
                if parent.left == node:
                    parent.left = None
                else:
                    parent.right = None
                return root
            if node.left:
                new_q[node.left] = node
            if node.right:
                new_q[node.right] = node
        q = new_q


import bisect


class Solution(object):
    def countRoutes(self, locations, start, finish, fuel):

    MOD = 10 ** 9 + 7

    s, f = locations[start], locations[finish]
    locations.sort()
    start, finish = bisect.bisect_left(locations, s), bisect.bisect_left(
        locations, f
    )

    left = [
        [0] * (fuel + 1) for _ in xrange(len(locations))
    ]
    right = [
        [0] * (fuel + 1) for _ in xrange(len(locations))
    ]
    for f in xrange(1, fuel + 1):
        for j in xrange(len(locations) - 1):
            d = locations[j + 1] - locations[j]
            if f > d:

                left[j][f] = (
                    right[j + 1][f - d] + 2 * left[j + 1][f - d] % MOD
                ) % MOD
            elif f == d:
                left[j][f] = int(j + 1 == start)
        for j in xrange(1, len(locations)):
            d = locations[j] - locations[j - 1]
            if f > d:

                right[j][f] = (
                    left[j - 1][f - d] + 2 * right[j - 1][f - d] % MOD
                ) % MOD
            elif f == d:
                right[j][f] = int(j - 1 == start)
    result = int(start == finish)
    for f in xrange(1, fuel + 1):
        result = ((result + left[finish][f]) % MOD + right[finish][f]) % MOD
    return result


class Solution2(object):
    def countRoutes(self, locations, start, finish, fuel):

    MOD = 10 ** 9 + 7
    dp = [[0] * (fuel + 1) for _ in xrange(len(locations))]
    dp[start][0] = 1
    for f in xrange(fuel + 1):
        for i in xrange(len(locations)):
            for j in xrange(len(locations)):
                if i == j:
                    continue
                d = abs(locations[i] - locations[j])
                if f - d < 0:
                    continue
                dp[i][f] = (dp[i][f] + dp[j][f - d]) % MOD
    return reduce(lambda x, y: (x + y) % MOD, dp[finish])


class Solution(object):
    def countOrders(self, n):

    MOD = 10 ** 9 + 7
    result = 1
    for i in reversed(xrange(2, 2 * n + 1, 2)):
        result = result * i * (i - 1) // 2 % MOD
    return result


class Solution(object):

    def countAndSay(self, n):
    seq = "1"
    for i in xrange(n - 1):
        seq = self.getNext(seq)
    return seq

    def getNext(self, seq):
    i, next_seq = 0, ""
    while i < len(seq):
        cnt = 1
        while i < len(seq) - 1 and seq[i] == seq[i + 1]:
            cnt += 1
            i += 1
        next_seq += str(cnt) + seq[i]
        i += 1
    return next_seq


class Solution(object):
    def countBinarySubstrings(self, s):

    result, prev, curr = 0, 0, 1
    for i in xrange(1, len(s)):
        if s[i - 1] != s[i]:
            result += min(prev, curr)
            prev, curr = curr, 1
        else:
            curr += 1
    result += min(prev, curr)
    return result


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    pass


class Solution(object):
    def countNodes(self, root):

    def height(root):
        h = -1
        while root:
            h += 1
            root = root.left
        return h

    result, h = 0, height(root)
    while root:
        if height(root.right) == h - 1:
            result += 2 ** h
            root = root.right
        else:
            result += 2 ** (h - 1)
            root = root.left
        h -= 1
    return result


class Solution2(object):
    def countNodes(self, root):

    def check(node, n):
        base = 1
        while base <= n:
            base <<= 1
        base >>= 2

        while base:
            if (n & base) == 0:
                node = node.left
            else:
                node = node.right
            base >>= 1
        return bool(node)

    if not root:
        return 0

    node, level = root, 0
    while node.left:
        node = node.left
        level += 1

    left, right = 2 ** level, 2 ** (level + 1) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if not check(root, mid):
            right = mid - 1
        else:
            left = mid + 1
    return right


class Solution(object):
    def countPalindromicSubsequences(self, S):

    def dp(i, j, prv, nxt, lookup):
        if lookup[i][j] is not None:
            return lookup[i][j]
        result = 1
        if i <= j:
            for x in xrange(4):
                i0 = nxt[i][x]
                j0 = prv[j][x]
                if i <= i0 <= j:
                    result = (result + 1) % P
                if None < i0 < j0:
                    result = (result + dp(i0 + 1, j0 -
                              1, prv, nxt, lookup)) % P
        result %= P
        lookup[i][j] = result
        return result

    prv = [None] * len(S)
    nxt = [None] * len(S)

    last = [None] * 4
    for i in xrange(len(S)):
        last[ord(S[i]) - ord("a")] = i
        prv[i] = tuple(last)

    last = [None] * 4
    for i in reversed(xrange(len(S))):
        last[ord(S[i]) - ord("a")] = i
        nxt[i] = tuple(last)

    P = 10 ** 9 + 7
    lookup = [[None] * len(S) for _ in xrange(len(S))]
    return dp(0, len(S) - 1, prv, nxt, lookup) - 1


import collections


class Solution(object):
    def countPairs(self, deliciousness):

    def floor_log2_x(x):
        return x.bit_length() - 1

    MOD = 10 ** 9 + 7
    max_pow = floor_log2_x(max(deliciousness)) + 1
    cnt = collections.Counter()
    result = 0
    for d in deliciousness:
        p = 1
        for i in xrange(max_pow + 1):
            result = (result + cnt[p - d]) % MOD
            p <<= 1
        cnt[d] += 1
    return result


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    self.val = val
    self.left = left
    self.right = right


class Solution(object):
    def goodNodes(self, root):

    result = 0
    stk = [(root, root.val)]
    while stk:
        node, curr_max = stk.pop()
        if not node:
            continue
        curr_max = max(curr_max, node.val)
        result += int(curr_max <= node.val)
        stk.append((node.right, curr_max))
        stk.append((node.left, curr_max))
    return result


class Solution2(object):
    def goodNodes(self, root):

    def dfs(node, curr_max):
        if not node:
            return 0
        curr_max = max(curr_max, node.val)
        return (
            int(curr_max <= node.val)
            + dfs(node.left, curr_max)
            + dfs(node.right, curr_max)
        )

    return dfs(root, root.val)


class Solution(object):
    def countGoodTriplets(self, arr, a, b, c):

    return sum(
        abs(arr[i] - arr[j]) <= a
        and abs(arr[j] - arr[k]) <= b
        and abs(arr[k] - arr[i]) <= c
        for i in xrange(len(arr) - 2)
        for j in xrange(i + 1, len(arr) - 1)
        for k in xrange(j + 1, len(arr))
    )


class Solution(object):
    def countMatches(self, items, ruleKey, ruleValue):

    rule = {"type": 0, "color": 1, "name": 2}
    return sum(item[rule[ruleKey]] == ruleValue for item in items)


import collections


class Solution(object):
    def countLargestGroup(self, n):

    count = collections.Counter()
    for x in xrange(1, n + 1):
        count[sum(map(int, str(x)))] += 1
    max_count = max(count.itervalues())
    return sum(v == max_count for v in count.itervalues())


class Solution(object):
    def countNegatives(self, grid):

    result, c = 0, len(grid[0]) - 1
    for row in grid:
        while c >= 0 and row[c] < 0:
            c -= 1
        result += len(grid[0]) - 1 - c
    return result


class Solution(object):
    def countHomogenous(self, s):

    MOD = 10 ** 9 + 7
    result = cnt = 0
    for i in xrange(len(s)):
        if i and s[i - 1] == s[i]:
            cnt += 1
        else:
            cnt = 1
        result = (result + cnt) % MOD
    return result


class Solution(object):
    def numberOfSubarrays(self, nums, k):

    def atMost(nums, k):
        result, left, count = 0, 0, 0
        for right in xrange(len(nums)):
            count += nums[right] % 2
            while count > k:
                count -= nums[left] % 2
                left += 1
            result += right - left + 1
        return result

    return atMost(nums, k) - atMost(nums, k - 1)


import collections


class Solution2(object):
    def numberOfSubarrays(self, nums, k):

    result = 0
    dq = collections.deque([-1])
    for i in xrange(len(nums)):
        if nums[i] % 2:
            dq.append(i)
        if len(dq) > k + 1:
            dq.popleft()
        if len(dq) == k + 1:
            result += dq[1] - dq[0]
    return result


class Solution(object):
    def numTeams(self, rating):

    result = 0
    for i in xrange(1, len(rating) - 1):
        less, greater = [0] * 2, [0] * 2
        for j in xrange(len(rating)):
            if rating[i] > rating[j]:
                less[i < j] += 1
            if rating[i] < rating[j]:
                greater[i < j] += 1
        result += less[0] * greater[1] + greater[0] * less[1]
    return result


class Solution(object):
    def countNumbersWithUniqueDigits(self, n):

    if n == 0:
        return 1
    count, fk = 10, 9
    for k in xrange(2, n + 1):
        fk *= 10 - (k - 1)
        count += fk
    return count


class Solution(object):
    def countOdds(self, low, high):

    return (high + 1) // 2 - ((low - 1) + 1) // 2


class Solution(object):
    def numberOfMatches(self, n):

    return n - 1


class Solution(object):
    def countRangeSum(self, nums, lower, upper):

    def countAndMergeSort(sums, start, end, lower, upper):
        if (
            end - start <= 1
        ):
            return 0
        mid = start + (end - start) / 2
        count = countAndMergeSort(
            sums, start, mid, lower, upper
        ) + countAndMergeSort(sums, mid, end, lower, upper)
        j, k, r = mid, mid, mid
        tmp = []
        for i in xrange(start, mid):

            while k < end and sums[k] - sums[i] < lower:
                k += 1
            while j < end and sums[j] - sums[i] <= upper:
                j += 1
            count += j - k

            while r < end and sums[r] < sums[i]:
                tmp.append(sums[r])
                r += 1
            tmp.append(sums[i])

        sums[start: start + len(tmp)] = tmp
        return count

    sums = [0] * (len(nums) + 1)
    for i in xrange(len(nums)):
        sums[i + 1] = sums[i] + nums[i]
    return countAndMergeSort(sums, 0, len(sums), lower, upper)


class Solution2(object):
    def countRangeSum(self, nums, lower, upper):

    def countAndMergeSort(sums, start, end, lower, upper):
        if (
            end - start <= 0
        ):
            return 0

        mid = start + (end - start) / 2
        count = countAndMergeSort(
            sums, start, mid, lower, upper
        ) + countAndMergeSort(sums, mid + 1, end, lower, upper)
        j, k, r = mid + 1, mid + 1, mid + 1
        tmp = []
        for i in xrange(start, mid + 1):

            while k <= end and sums[k] - sums[i] < lower:
                k += 1
            while j <= end and sums[j] - sums[i] <= upper:
                j += 1
            count += j - k

            while r <= end and sums[r] < sums[i]:
                tmp.append(sums[r])
                r += 1
            tmp.append(sums[i])

        sums[start: start + len(tmp)] = tmp
        return count

    sums = [0] * (len(nums) + 1)
    for i in xrange(len(nums)):
        sums[i + 1] = sums[i] + nums[i]
    return countAndMergeSort(sums, 0, len(sums) - 1, lower, upper)


class Solution(object):
    def countSmaller(self, nums):

    def countAndMergeSort(num_idxs, start, end, counts):
        if (
            end - start <= 0
        ):
            return 0

        mid = start + (end - start) / 2
        countAndMergeSort(num_idxs, start, mid, counts)
        countAndMergeSort(num_idxs, mid + 1, end, counts)
        r = mid + 1
        tmp = []
        for i in xrange(start, mid + 1):

            while r <= end and num_idxs[r][0] < num_idxs[i][0]:
                tmp.append(num_idxs[r])
                r += 1
            tmp.append(num_idxs[i])
            counts[num_idxs[i][1]] += r - (mid + 1)

        num_idxs[start: start + len(tmp)] = tmp

    num_idxs = []
    counts = [0] * len(nums)
    for i, num in enumerate(nums):
        num_idxs.append((num, i))
    countAndMergeSort(num_idxs, 0, len(num_idxs) - 1, counts)
    return counts


class Solution2(object):
    def countSmaller(self, nums):

    class BIT(object):
        def __init__(self, n):
            self.__bit = [0] * (n + 1)

        def add(self, i, val):
            i += 1
            while i < len(self.__bit):
                self.__bit[i] += val
                i += i & -i

        def query(self, i):
            i += 1
            ret = 0
            while i > 0:
                ret += self.__bit[i]
                i -= i & -i
            return ret

    sorted_nums = sorted(zip(nums, range(len(nums))))
    lookup = {i: new_i for new_i, (_, i) in enumerate(sorted_nums)}

    result, bit = [0] * len(nums), BIT(len(nums))
    for i in reversed(xrange(len(nums))):
        result[i] = bit.query(lookup[i] - 1)
        bit.add(lookup[i], 1)
    return result


class Solution3(object):
    def countSmaller(self, nums):

    res = [0] * len(nums)
    bst = self.BST()

    for i in reversed(xrange(len(nums))):
        bst.insertNode(nums[i])
        res[i] = bst.query(nums[i])

    return res

    class BST(object):

    class BSTreeNode(object):
        def __init__(self, val):
            self.val = val
            self.count = 0
            self.left = self.right = None

    def __init__(self):
        self.root = None

    def insertNode(self, val):
        node = self.BSTreeNode(val)
        if not self.root:
            self.root = node
            return
        curr = self.root
        while curr:

            if node.val < curr.val:
                curr.count += 1
                if curr.left:
                    curr = curr.left
                else:
                    curr.left = node
                    break
            else:
                if curr.right:
                    curr = curr.right
                else:
                    curr.right = node
                    break

    def query(self, val):
        count = 0
        curr = self.root
        while curr:

            if val < curr.val:
                curr = curr.left
            elif val > curr.val:
                count += 1 + curr.count
                curr = curr.right
            else:
                return count + curr.count
        return 0


class Solution(object):
    def countQuadruples(self, firstString, secondString):

    lookup1 = [-1] * 26
    for i in reversed(xrange(len(firstString))):
        lookup1[ord(firstString[i]) - ord("a")] = i
    lookup2 = [-1] * 26
    for i in xrange(len(secondString)):
        lookup2[ord(secondString[i]) - ord("a")] = i
    result, diff = 0, float("inf")
    for i in xrange(26):
        if lookup1[i] == -1 or lookup2[i] == -1:
            continue
        if lookup1[i] - lookup2[i] < diff:
            diff = lookup1[i] - lookup2[i]
            result = 0
        result += int(lookup1[i] - lookup2[i] == diff)
    return result


import collections
import itertools


class Solution(object):
    def countPairs(self, n, edges, queries):

    degree = [0] * (n + 1)
    shared = collections.Counter((min(n1, n2), max(n1, n2))
                                 for n1, n2 in edges)
    for u, v in edges:
        degree[u] += 1
        degree[v] += 1
    cnt = [0] * (2 * (max(degree[1:]) + 1))
    count = collections.Counter(degree[1:])
    for i, j in itertools.product(count, count):
        if i < j:
            cnt[i + j] += count[i] * count[j]
        elif i == j:
            cnt[i + j] += count[i] * (count[i] - 1) // 2
    for (i, j), shared_degree in shared.iteritems():
        cnt[degree[i] + degree[j]] -= 1
        cnt[degree[i] + degree[j] - shared_degree] += 1
    for i in reversed(xrange(len(cnt) - 1)):
        cnt[i] += cnt[i + 1]
    return [cnt[q + 1] if q + 1 < len(cnt) else 0 for q in queries]


import collections


class Solution2(object):
    def countPairs(self, n, edges, queries):

    degree = [0] * (n + 1)
    shared = collections.Counter((min(n1, n2), max(n1, n2))
                                 for n1, n2 in edges)
    for n1, n2 in edges:
        degree[n1] += 1
        degree[n2] += 1
    sorted_degree = sorted(degree)
    result = []
    for k, q in enumerate(queries):
        left, right = 1, n
        cnt = 0
        while left < right:
            if q < sorted_degree[left] + sorted_degree[right]:
                cnt += right - left
                right -= 1
            else:
                left += 1
        for (i, j), shared_degree in shared.iteritems():
            if degree[i] + degree[j] - shared_degree <= q < degree[i] + degree[j]:
                cnt -= 1
        result.append(cnt)
    return result


class Solution(object):

    def countPrimes(self, n):
    if n <= 2:
        return 0

    is_prime = [True] * (n // 2)
    cnt = len(is_prime)
    for i in xrange(3, n, 2):
        if i * i >= n:
            break
        if not is_prime[i // 2]:
            continue
        for j in xrange(i * i, n, 2 * i):
            if not is_prime[j // 2]:
                continue
            cnt -= 1
            is_prime[j // 2] = False

    return cnt

    def countPrimes2(self, n):

    if n < 3:
        return 0
    primes = [True] * n
    primes[0] = primes[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if primes[i]:
            primes[i * i: n: i] = [False] * len(primes[i * i: n: i])
    return sum(primes)


class Solution(object):
    def countServers(self, grid):

    rows, cols = [0] * len(grid), [0] * len(grid[0])
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            if grid[i][j]:
                rows[i] += 1
                cols[j] += 1
    result = 0
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            if grid[i][j] and (rows[i] > 1 or cols[j] > 1):
                result += 1
    return result


class Solution(object):
    def countVowelStrings(self, n):

    def nCr(n, r):
        if n - r < r:
            return nCr(n, n - r)
        c = 1
        for k in xrange(1, r + 1):
            c *= n - k + 1
            c //= k
        return c

    return nCr(n + 4, 4)


class Solution(object):
    def countSquares(self, matrix):

    for i in xrange(1, len(matrix)):
        for j in xrange(1, len(matrix[0])):
            if not matrix[i][j]:
                continue
            l = min(matrix[i - 1][j], matrix[i][j - 1])
            matrix[i][j] = l + 1 if matrix[i - l][j - l] else l
    return sum(x for row in matrix for x in row)


class Solution(object):
    def numSubmat(self, mat):

    def count(heights):
        dp, stk = [0] * len(heights), []
        for i in xrange(len(heights)):
            while stk and heights[stk[-1]] >= heights[i]:
                stk.pop()
            dp[i] = (
                dp[stk[-1]] + heights[i] * (i - stk[-1])
                if stk
                else heights[i] * (i - (-1))
            )
            stk.append(i)
        return sum(dp)

    result = 0
    heights = [0] * len(mat[0])
    for i in xrange(len(mat)):
        for j in xrange(len(mat[0])):
            heights[j] = heights[j] + 1 if mat[i][j] == 1 else 0
        result += count(heights)
    return result


class Solution(object):
    def countSubstrings(self, s, t):

    def count(
        i, j
    ):
        result = (
            left_cnt
        ) = (
            right_cnt
        ) = 0
        for k in xrange(min(len(s) - i, len(t) - j)):
            right_cnt += 1
            if s[i + k] != t[j + k]:
                left_cnt, right_cnt = right_cnt, 0

            result += left_cnt
        return result

    return sum(count(i, 0) for i in xrange(len(s))) + sum(
        count(0, j) for j in xrange(1, len(t))
    )


class Solution(object):
    def countLetters(self, S):

    result = len(S)
    left = 0
    for right in xrange(1, len(S)):
        if S[right] == S[left]:
            result += right - left
        else:
            left = right
    return result


import collections


class Solution(object):
    def countSubgraphsForEachDiameter(self, n, edges):

    def dfs(n, adj, curr, parent, lookup, count, dp):
        for child in adj[curr]:
            if child == parent or lookup[child]:
                continue
            dfs(n, adj, child, curr, lookup, count, dp)
        dp[curr][0][0] = 1
        for child in adj[curr]:
            if child == parent or lookup[child]:
                continue
            new_dp_curr = [row[:] for row in dp[curr]]
            for curr_d in xrange(count[curr]):
                for curr_max_d in xrange(curr_d, min(2 * curr_d + 1, count[curr])):
                    if not dp[curr][curr_d][curr_max_d]:
                        continue
                    for child_d in xrange(count[child]):
                        for child_max_d in xrange(
                            child_d, min(2 * child_d + 1, count[child])
                        ):
                            new_dp_curr[max(curr_d, child_d + 1)][
                                max(curr_max_d, child_max_d,
                                    curr_d + child_d + 1)
                            ] += (
                                dp[curr][curr_d][curr_max_d]
                                * dp[child][child_d][child_max_d]
                            )
            count[curr] += count[child]
            dp[curr] = new_dp_curr

    adj = collections.defaultdict(list)
    for u, v in edges:
        u -= 1
        v -= 1
        adj[u].append(v)
        adj[v].append(u)
    lookup, result = [0] * n, [0] * (n - 1)
    for i in xrange(n):
        dp = [[[0] * n for _ in xrange(n)] for _ in xrange(n)]
        count = [1] * n
        dfs(
            n, adj, i, -1, lookup, count, dp
        )
        lookup[i] = 1
        for d in xrange(1, n):
            for max_d in xrange(d, min(2 * d + 1, n)):
                result[max_d - 1] += dp[i][d][max_d]
    return result


import collections
import math


class Solution2(object):
    def countSubgraphsForEachDiameter(self, n, edges):

    def popcount(mask):
        count = 0
        while mask:
            mask &= mask - 1
            count += 1
        return count

    def bfs(adj, mask, start):
        q = collections.deque([(start, 0)])
        lookup = 1 << start
        count = popcount(mask) - 1
        u, d = None, None
        while q:
            u, d = q.popleft()
            for v in adj[u]:
                if not (mask & (1 << v)) or (lookup & (1 << v)):
                    continue
                lookup |= 1 << v
                count -= 1
                q.append((v, d + 1))
        return count == 0, u, d

    def max_distance(n, edges, adj, mask):
        is_valid, farthest, _ = bfs(adj, mask, int(math.log(mask & -mask, 2)))
        return bfs(adj, mask, farthest)[-1] if is_valid else 0

    adj = collections.defaultdict(list)
    for u, v in edges:
        u -= 1
        v -= 1
        adj[u].append(v)
        adj[v].append(u)
    result = [0] * (n - 1)
    for mask in xrange(1, 2 ** n):
        max_d = max_distance(n, edges, adj, mask)
        if max_d - 1 >= 0:
            result[max_d - 1] += 1
    return result


class Solution(object):
    def countConsistentStrings(self, allowed, words):

    lookup = [False] * 26
    for c in allowed:
        lookup[ord(c) - ord("a")] = True
    result = len(words)
    for word in words:
        for c in word:
            if not lookup[ord(c) - ord("a")]:
                result -= 1
                break
    return result


class Solution(object):
    def getMaxRepetitions(self, s1, n1, s2, n2):

    repeat_count = [0] * (len(s2) + 1)
    lookup = {}
    j, count = 0, 0
    for k in xrange(1, n1 + 1):
        for i in xrange(len(s1)):
            if s1[i] == s2[j]:
                j = (j + 1) % len(s2)
                count += j == 0

        if j in lookup:
            i = lookup[j]
            prefix_count = repeat_count[i]
            pattern_count = (count - repeat_count[i]) * ((n1 - i) // (k - i))
            suffix_count = repeat_count[i +
                                        (n1 - i) % (k - i)] - repeat_count[i]
            return (prefix_count + pattern_count + suffix_count) / n2
        lookup[j] = k
        repeat_count[k] = count

    return repeat_count[n1] / n2


import collections


class Solution(object):
    def countTriplets(self, arr):

    count_sum = collections.defaultdict(lambda: [0, 0])
    count_sum[0] = [1, 0]
    result, prefix = 0, 0
    for i, x in enumerate(arr):
        prefix ^= x
        c, t = count_sum[prefix]

        result += c * i - t
        count_sum[prefix] = [c + 1, t + i + 1]
    return result


class Solution(object):
    def unhappyFriends(self, n, preferences, pairs):

    friends = [[0] * n for _ in xrange(n)]
    for i in xrange(len(preferences)):
        for j in xrange(len(preferences[i])):
            friends[i][preferences[i][j]] = j
    pairing = [0] * n
    for i, j in pairs:
        pairing[i], pairing[j] = j, i
    return sum(
        any(
            friends[i][j] < friends[i][pairing[i]]
            and friends[j][i] < friends[j][pairing[j]]
            for j in xrange(len(friends[i]))
            if j != i and j != pairing[i]
        )
        for i in xrange(len(friends))
    )


import string


class Solution(object):
    def uniqueLetterString(self, S):

    M = 10 ** 9 + 7
    index = {c: [-1, -1] for c in string.ascii_uppercase}
    result = 0
    for i, c in enumerate(S):
        k, j = index[c]
        result += (i - j) * (j - k)
        index[c] = [j, i]
    for c in index:
        k, j = index[c]
        result += (len(S) - j) * (j - k)
    return result % M


class Solution(object):

    def countUnivalSubtrees(self, root):
    [is_uni, count] = self.isUnivalSubtrees(root, 0)
    return count

    def isUnivalSubtrees(self, root, count):
    if not root:
        return [True, count]

    [left, count] = self.isUnivalSubtrees(root.left, count)
    [right, count] = self.isUnivalSubtrees(root.right, count)
    if self.isSame(root, root.left, left) and self.isSame(root, root.right, right):
        count += 1
        return [True, count]

    return [False, count]

    def isSame(self, root, child, is_uni):
    return not child or (is_uni and root.val == child.val)


import itertools


class Solution(object):
    def countVowelPermutation(self, n):

    def matrix_expo(A, K):
        result = [[int(i == j) for j in xrange(len(A))]
                  for i in xrange(len(A))]
        while K:
            if K % 2:
                result = matrix_mult(result, A)
            A = matrix_mult(A, A)
            K /= 2
        return result

    def matrix_mult(A, B):
        ZB = zip(*B)
        return [
            [sum(a * b for a, b in itertools.izip(row, col)) %
             MOD for col in ZB]
            for row in A
        ]

    MOD = 10 ** 9 + 7
    T = [
        [0, 1, 1, 0, 1],
        [1, 0, 1, 0, 0],
        [0, 1, 0, 1, 0],
        [0, 0, 1, 0, 0],
        [0, 0, 1, 1, 0],
    ]
    return sum(map(sum, matrix_expo(T, n - 1))) % MOD


class Solution2(object):
    def countVowelPermutation(self, n):

    MOD = 10 ** 9 + 7
    a, e, i, o, u = 1, 1, 1, 1, 1
    for _ in xrange(1, n):
        a, e, i, o, u = (
            (e + i + u) % MOD,
            (a + i) % MOD,
            (e + o) % MOD,
            i,
            (i + o) % MOD,
        )
    return (a + e + i + o + u) % MOD


class Solution(object):
    def waysToDistribute(self, n, k):

    MOD = 10 ** 9 + 7
    dp = [1] * k
    for i in xrange(1, n):
        for j in reversed(xrange(1, min(i, k))):
            dp[j] = ((j + 1) * dp[j] + dp[j - 1]) % MOD
    return dp[k - 1]


import collections


MAX_N = 10 ** 4
MOD = 10 ** 9 + 7
MAX_F = MAX_N.bit_length() - 1
fact = [0] * ((MAX_F + MAX_N - 1) + 1)
inv = [0] * ((MAX_F + MAX_N - 1) + 1)
inv_fact = [0] * ((MAX_F + MAX_N - 1) + 1)
fact[0] = inv_fact[0] = fact[1] = inv_fact[1] = inv[1] = 1
for i in xrange(2, len(fact)):
    fact[i] = fact[i - 1] * i % MOD
    inv[i] = (
        inv[MOD % i] * (MOD - MOD // i) % MOD
    )
    inv_fact[i] = inv_fact[i - 1] * inv[i] % MOD

sieve = range(MAX_N + 1)
for i in xrange(2, MAX_N + 1):
    if sieve[i] != i:
    continue
    for j in xrange(i * i, MAX_N + 1, i):
    sieve[j] = i


class Solution(object):
    def waysToFillArray(self, queries):

    def nCr(n, k, mod):
        return (fact[n] * inv_fact[n - k] % mod) * inv_fact[k] % mod

    def get_factors(k):
        factors = collections.Counter()
        while k > 1:
            factors[sieve[k]] += 1
            k //= sieve[k]
        return factors

    result = []
    for n, k in queries:
        factors = get_factors(k)
        curr = 1
        for f in factors.itervalues():
            curr *= nCr(f + n - 1, f, MOD)
        result.append(curr % MOD)
    return result


class Solution(object):
    def countBits(self, num):

    res = [0]
    for i in xrange(1, num + 1):

        res.append((i & 1) + res[i >> 1])
    return res

    def countBits2(self, num):

    s = [0]
    while len(s) <= num:
        s.extend(map(lambda x: x + 1, s))
    return s[: num + 1]


class Solution(object):
    def countElements(self, arr):

    lookup = set(arr)
    return sum(1 for x in arr if x + 1 in lookup)


class Solution(object):
    def countElements(self, arr):

    arr.sort()
    result, l = 0, 1
    for i in xrange(len(arr) - 1):
        if arr[i] == arr[i + 1]:
            l += 1
            continue
        if arr[i] + 1 == arr[i + 1]:
            result += l
        l = 1
    return result


class Solution(object):
    def minSwapsCouples(self, row):

    N = len(row) // 2
    couples = [[] for _ in xrange(N)]
    for seat, num in enumerate(row):
        couples[num // 2].append(seat // 2)
    adj = [[] for _ in xrange(N)]
    for couch1, couch2 in couples:
        adj[couch1].append(couch2)
        adj[couch2].append(couch1)

    result = 0
    for couch in xrange(N):
        if not adj[couch]:
            continue
        couch1, couch2 = couch, adj[couch].pop()
        while couch2 != couch:
            result += 1
            adj[couch2].remove(couch1)
            couch1, couch2 = couch2, adj[couch2].pop()
    return result


import collections


class Solution(object):
    def findOrder(self, numCourses, prerequisites):

    in_degree = collections.defaultdict(set)
    out_degree = collections.defaultdict(set)
    for i, j in prerequisites:
        in_degree[i].add(j)
        out_degree[j].add(i)
    q = collections.deque(
        [i for i in xrange(numCourses) if i not in in_degree])
    result = []
    while q:
        node = q.popleft()
        result.append(node)
        for i in out_degree[node]:
            in_degree[i].remove(node)
            if not in_degree[i]:
                q.append(i)
                del in_degree[i]
        del out_degree[node]
    return result if not in_degree and not out_degree else []


class Solution2(object):
    def findOrder(self, numCourses, prerequisites):

    in_degree = collections.defaultdict(set)
    out_degree = collections.defaultdict(set)
    for i, j in prerequisites:
        in_degree[i].add(j)
        out_degree[j].add(i)
    stk = [i for i in xrange(numCourses) if i not in in_degree]
    result = []
    while stk:
        node = stk.pop()
        result.append(node)
        for i in out_degree[node]:
            in_degree[i].remove(node)
            if not in_degree[i]:
                stk.append(i)
                del in_degree[i]
        del out_degree[node]
    return result if not in_degree and not out_degree else []


import collections
import heapq


class Solution(object):
    def scheduleCourse(self, courses):

    courses.sort(key=lambda t_end: t_end[1])
    max_heap = []
    now = 0
    for t, end in courses:
        now += t
        heapq.heappush(max_heap, -t)
        if now > end:
            now += heapq.heappop(max_heap)
    return len(max_heap)


class Solution(object):
    def checkIfPrerequisite(self, n, prerequisites, queries):

    def floydWarshall(n, graph):
        reachable = set(map(lambda x: x[0] * n + x[1], graph))
        for k in xrange(n):
            for i in xrange(n):
                for j in xrange(n):
                    if i * n + j not in reachable and (
                        i * n + k in reachable and k * n + j in reachable
                    ):
                        reachable.add(i * n + j)
        return reachable

    reachable = floydWarshall(n, prerequisites)
    return [i * n + j in reachable for i, j in queries]


import collections


class Solution2(object):
    def checkIfPrerequisite(self, n, prerequisites, queries):

    graph = collections.defaultdict(list)
    for u, v in prerequisites:
        graph[u].append(v)
    result = []
    for i, j in queries:
        stk, lookup = [i], set([i])
        while stk:
            node = stk.pop()
            for nei in graph[node]:
                if nei in lookup:
                    continue
                stk.append(nei)
                lookup.add(nei)
        result.append(j in lookup)
    return result


import collections


class Solution(object):
    def canFinish(self, numCourses, prerequisites):

    in_degree = collections.defaultdict(set)
    out_degree = collections.defaultdict(set)
    for i, j in prerequisites:
        in_degree[i].add(j)
        out_degree[j].add(i)
    q = collections.deque(
        [i for i in xrange(numCourses) if i not in in_degree])
    while q:
        node = q.popleft()
        for i in out_degree[node]:
            in_degree[i].remove(node)
            if not in_degree[i]:
                q.append(i)
                del in_degree[i]
        del out_degree[node]
    return not in_degree and not out_degree


class Solution2(object):
    def canFinish(self, numCourses, prerequisites):

    in_degree = collections.defaultdict(set)
    out_degree = collections.defaultdict(set)
    for i, j in prerequisites:
        in_degree[i].add(j)
        out_degree[j].add(i)
    stk = [i for i in xrange(numCourses) if i not in in_degree]
    while stk:
        node = stk.pop()
        for i in out_degree[node]:
            in_degree[i].remove(node)
            if not in_degree[i]:
                stk.append(i)
                del in_degree[i]
        del out_degree[node]
    return not in_degree and not out_degree


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def isCousins(self, root, x, y):

    def dfs(root, x, depth, parent):
        if not root:
            return False
        if root.val == x:
            return True
        depth[0] += 1
        prev_parent, parent[0] = parent[0], root
        if dfs(root.left, x, depth, parent):
            return True
        parent[0] = root
        if dfs(root.right, x, depth, parent):
            return True
        parent[0] = prev_parent
        depth[0] -= 1
        return False

    depth_x, depth_y = [0], [0]
    parent_x, parent_y = [None], [None]
    return (
        dfs(root, x, depth_x, parent_x)
        and dfs(root, y, depth_y, parent_y)
        and depth_x[0] == depth_y[0]
        and parent_x[0] != parent_y[0]
    )


class Solution(object):
    def crackSafe(self, n, k):

    M = k ** (n - 1)
    P = [
        q * k + i for i in xrange(k) for q in xrange(M)
    ]
    result = [str(k - 1)] * (n - 1)
    for i in xrange(k ** n):
        j = i

        while P[j] >= 0:
            result.append(str(j // M))
            P[j], j = -1, P[j]
    return "".join(result)


class Solution2(object):
    def crackSafe(self, n, k):

    total = k ** n
    M = total // k
    unique_rolling_hash = 0
    result = [str(0)] * (n - 1)
    lookup = set()
    while len(lookup) < total:
        for i in reversed(
            xrange(k)
        ):
            new_unique_rolling_hash = unique_rolling_hash * k + i
            if new_unique_rolling_hash not in lookup:
                lookup.add(new_unique_rolling_hash)
                result.append(str(i))
                unique_rolling_hash = new_unique_rolling_hash % M
                break
    return "".join(result)


class Solution3(object):
    def crackSafe(self, n, k):

    M = k ** (n - 1)

    def dfs(k, unique_rolling_hash, lookup, result):
        for i in reversed(
            xrange(k)
        ):
            new_unique_rolling_hash = unique_rolling_hash * k + i
            if new_unique_rolling_hash not in lookup:
                lookup.add(new_unique_rolling_hash)
                result.append(str(i))
                dfs(k, new_unique_rolling_hash % M, lookup, result)
                break

    unique_rolling_hash = 0
    result = [str(0)] * (n - 1)
    lookup = set()
    dfs(k, unique_rolling_hash, lookup, result)
    return "".join(result)


class Solution4(object):
    def crackSafe(self, n, k):

    result = [str(k - 1)] * (n - 1)
    lookup = set()
    total = k ** n
    while len(lookup) < total:
        node = result[len(result) - n + 1:]
        for i in xrange(
            k
        ):
            neighbor = "".join(node) + str(i)
            if neighbor not in lookup:
                lookup.add(neighbor)
                result.append(str(i))
                break
    return "".join(result)


class Solution5(object):
    def crackSafe(self, n, k):

    def dfs(k, node, lookup, result):
        for i in xrange(
            k
        ):
            neighbor = node + str(i)
            if neighbor not in lookup:
                lookup.add(neighbor)
                result.append(str(i))
                dfs(k, neighbor[1:], lookup, result)
                break

    result = [str(k - 1)] * (n - 1)
    lookup = set()
    dfs(k, "".join(result), lookup, result)
    return "".join(result)


class Solution(object):
    def minOperations(self, logs):

    result = 0
    for log in logs:
        if log == "../":
            if result > 0:
                result -= 1
        elif log != "./":
            result += 1
    return result


class Solution(object):
    def maxNumber(self, nums1, nums2, k):

    def get_max_digits(nums, start, end, max_digits):
        max_digits[end] = max_digit(nums, end)
        for i in reversed(xrange(start, end)):
            max_digits[i] = delete_digit(max_digits[i + 1])

    def max_digit(nums, k):
        drop = len(nums) - k
        res = []
        for num in nums:
            while drop and res and res[-1] < num:
                res.pop()
                drop -= 1
            res.append(num)
        return res[:k]

    def delete_digit(nums):
        res = list(nums)
        for i in xrange(len(res)):
            if i == len(res) - 1 or res[i] < res[i + 1]:
                res = res[:i] + res[i + 1:]
                break
        return res

    def merge(a, b):
        return [max(a, b).pop(0) for _ in xrange(len(a) + len(b))]

    m, n = len(nums1), len(nums2)

    max_digits1, max_digits2 = [[] for _ in xrange(k + 1)], [
        [] for _ in xrange(k + 1)
    ]
    get_max_digits(nums1, max(0, k - n), min(k, m), max_digits1)
    get_max_digits(nums2, max(0, k - m), min(k, n), max_digits2)

    return max(
        merge(max_digits1[i], max_digits2[k - i])
        for i in xrange(max(0, k - n), min(k, m) + 1)
    )


class BIT(object):
    def __init__(self, n):
    self.__bit = [0] * (n + 1)

    def add(self, i, val):
    i += 1
    while i < len(self.__bit):
        self.__bit[i] += val
        i += i & -i

    def query(self, i):
    i += 1
    ret = 0
    while i > 0:
        ret += self.__bit[i]
        i -= i & -i
    return ret


class Solution(object):
    def createSortedArray(self, instructions):

    MOD = 10 ** 9 + 7
    bit = BIT(max(instructions))
    result = 0
    for i, inst in enumerate(instructions):
        inst -= 1
        result += min(bit.query(inst - 1), i - bit.query(inst))
        bit.add(inst, 1)
    return result % MOD


import itertools


class Solution_TLE(object):
    def createSortedArray(self, instructions):

    MOD = 10 ** 9 + 7

    def smallerMergeSort(idxs, start, end, counts):
        if (
            end - start <= 0
        ):
            return 0

        mid = start + (end - start) // 2
        smallerMergeSort(idxs, start, mid, counts)
        smallerMergeSort(idxs, mid + 1, end, counts)
        r = start
        tmp = []
        for i in xrange(mid + 1, end + 1):

            while r <= mid and idxs[r][0] < idxs[i][0]:
                tmp.append(idxs[r])
                r += 1
            tmp.append(idxs[i])
            counts[idxs[i][1]] += r - start
        while r <= mid:
            tmp.append(idxs[r])
            r += 1

        idxs[start: start + len(tmp)] = tmp

    def largerMergeSort(idxs, start, end, counts):
        if (
            end - start <= 0
        ):
            return 0

        mid = start + (end - start) // 2
        largerMergeSort(idxs, start, mid, counts)
        largerMergeSort(idxs, mid + 1, end, counts)
        r = start
        tmp = []
        for i in xrange(mid + 1, end + 1):

            while r <= mid and idxs[r][0] <= idxs[i][0]:
                tmp.append(idxs[r])
                r += 1
            if r <= mid:
                tmp.append(idxs[i])
            counts[idxs[i][1]] += mid - r + 1
        while r <= mid:
            tmp.append(idxs[r])
            r += 1

        idxs[start: start + len(tmp)] = tmp

    idxs = []
    smaller_counts, larger_counts = [
        [0] * len(instructions) for _ in xrange(2)]
    for i, inst in enumerate(instructions):
        idxs.append((inst, i))
    smallerMergeSort(idxs[:], 0, len(idxs) - 1, smaller_counts)
    largerMergeSort(idxs, 0, len(idxs) - 1, larger_counts)
    return (
        sum(min(s, l)
            for s, l in itertools.izip(smaller_counts, larger_counts))
        % MOD
    )


class Solution(object):
    def createTargetArray(self, nums, index):

    for i in xrange(len(nums)):
        for j in xrange(i):
            if index[j] >= index[i]:
                index[j] += 1
    result = [0] * (len(nums))
    for i in xrange(len(nums)):
        result[index[i]] = nums[i]
    return result


import itertools


class Solution2(object):
    def createTargetArray(self, nums, index):

    result = []
    for i, x in itertools.izip(index, nums):
        result.insert(i, x)
    return result


class Solution(object):
    def criticalConnections(self, n, connections):

    def dfs(edges, parent, u, idx, lowlinks, lookup, result):
        if lookup[u]:
            return
        lookup[u] = True
        curr_idx = lowlinks[u] = idx[0]
        idx[0] += 1
        for v in edges[u]:
            if v == parent:
                continue
            dfs(edges, u, v, idx, lowlinks, lookup, result)
            lowlinks[u] = min(lowlinks[u], lowlinks[v])
            if lowlinks[v] > curr_idx:

                result.append([u, v])

    edges = [[] for _ in xrange(n)]
    idx, lowlinks, lookup = [0], [0] * n, [False] * n
    result = []
    for u, v in connections:
        edges[u].append(v)
        edges[v].append(u)
    dfs(edges, -1, 0, idx, lowlinks, lookup, result)
    return result


import collections


class Solution(object):
    def customSortString(self, S, T):

    counter, s = collections.Counter(T), set(S)
    result = [c * counter[c] for c in S]
    result.extend(
        [c * counter for c, counter in counter.iteritems() if c not in s])
    return "".join(result)


import collections
import heapq


class Solution(object):
    def cutOffTree(self, forest):

    def dot(p1, p2):
        return p1[0] * p2[0] + p1[1] * p2[1]

    def minStep(p1, p2):
        min_steps = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
        closer, detour = [p1], []
        lookup = set()
        while True:
            if not closer:
                if not detour:
                    return -1

                min_steps += 2
                closer, detour = detour, closer
            i, j = closer.pop()
            if (i, j) == p2:
                return min_steps
            if (i, j) not in lookup:
                lookup.add((i, j))
                for I, J in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):
                    if (
                        0 <= I < m
                        and 0 <= J < n
                        and forest[I][J]
                        and (I, J) not in lookup
                    ):
                        is_closer = dot(
                            (I - i, J - j), (p2[0] - i, p2[1] - j)) > 0
                        (closer if is_closer else detour).append((I, J))
        return min_steps

    m, n = len(forest), len(forest[0])
    min_heap = []
    for i in xrange(m):
        for j in xrange(n):
            if forest[i][j] > 1:
                heapq.heappush(min_heap, (forest[i][j], (i, j)))

    start = (0, 0)
    result = 0
    while min_heap:
        tree = heapq.heappop(min_heap)
        step = minStep(start, tree[1])
        if step < 0:
            return -1
        result += step
        start = tree[1]
    return result


class Solution_TLE(object):
    def cutOffTree(self, forest):

    def minStep(p1, p2):
        min_steps = 0
        lookup = {p1}
        q = collections.deque([p1])
        while q:
            size = len(q)
            for _ in xrange(size):
                (i, j) = q.popleft()
                if (i, j) == p2:
                    return min_steps
                for i, j in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):
                    if not (
                        0 <= i < m
                        and 0 <= j < n
                        and forest[i][j]
                        and (i, j) not in lookup
                    ):
                        continue
                    q.append((i, j))
                    lookup.add((i, j))
            min_steps += 1
        return -1

    m, n = len(forest), len(forest[0])
    min_heap = []
    for i in xrange(m):
        for j in xrange(n):
            if forest[i][j] > 1:
                heapq.heappush(min_heap, (forest[i][j], (i, j)))

    start = (0, 0)
    result = 0
    while min_heap:
        tree = heapq.heappop(min_heap)
        step = minStep(start, tree[1])
        if step < 0:
            return -1
        result += step
        start = tree[1]
    return result


class Solution(object):
    def dailyTemperatures(self, temperatures):

    result = [0] * len(temperatures)
    stk = []
    for i in xrange(len(temperatures)):
        while stk and temperatures[stk[-1]] < temperatures[i]:
            idx = stk.pop()
            result[idx] = i - idx
        stk.append(i)
    return result


class Interval(object):
    def __init__(self, s=0, e=0):
    self.start = s
    self.end = e


class SummaryRanges(object):
    def __init__(self):

    self.__intervals = []

    def addNum(self, val):

    def upper_bound(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) / 2
            if nums[mid].start > target:
                right = mid - 1
            else:
                left = mid + 1
        return left

    i = upper_bound(self.__intervals, val)
    start, end = val, val
    if i != 0 and self.__intervals[i - 1].end + 1 >= val:
        i -= 1
    while i != len(self.__intervals) and end + 1 >= self.__intervals[i].start:
        start = min(start, self.__intervals[i].start)
        end = max(end, self.__intervals[i].end)
        del self.__intervals[i]
    self.__intervals.insert(i, Interval(start, end))

    def getIntervals(self):

    return self.__intervals


class Solution(object):
    def dayOfTheWeek(self, day, month, year):

    DAYS = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    ]

    if month < 3:
        month += 12
        year -= 1
    c, y = divmod(year, 100)
    w = (c // 4 - 2 * c + y + y // 4 + 13 * (month + 1) // 5 + day - 1) % 7
    return DAYS[w]


class Solution(object):
    def __init__(self):

    def dayOfMonth(M):
        return 28 if (M == 2) else 31 - (M - 1) % 7 % 2

    self.__lookup = [0] * 12
    for M in xrange(1, len(self.__lookup)):
        self.__lookup[M] += self.__lookup[M - 1] + dayOfMonth(M)

    def dayOfYear(self, date):

    Y, M, D = map(int, date.split("-"))
    leap = (
        1 if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0))
                        or (Y % 400 == 0)) else 0
    )
    return self.__lookup[M - 1] + D + leap


class Solution2(object):
    def dayOfYear(self, date):

    def numberOfDays(Y, M):
        leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
        return 28 + leap if (M == 2) else 31 - (M - 1) % 7 % 2

    Y, M, result = map(int, date.split("-"))
    for i in xrange(1, M):
        result += numberOfDays(Y, i)
    return result


class Solution(object):
    def decodeString(self, s):

    n, curr, nums, strs = 0, [], [], []
    for c in s:
        if c.isdigit():
            n = n * 10 + ord(c) - ord("0")
        elif c.isalpha():
            curr.append(c)
        elif c == "[":
            nums.append(n)
            strs.append(curr)
            n, curr = 0, []
        elif c == "]":
            strs[-1].extend(curr * nums.pop())
            curr = strs.pop()
    return "".join(curr)


class Solution(object):
    def numDecodings(self, s):

    M, W = 1000000007, 3
    dp = [0] * W
    dp[0] = 1
    dp[1] = 9 if s[0] == "*" else dp[0] if s[0] != "0" else 0
    for i in xrange(1, len(s)):
        if s[i] == "*":
            dp[(i + 1) % W] = 9 * dp[i % W]
            if s[i - 1] == "1":
                dp[(i + 1) % W] = (dp[(i + 1) % W] + 9 * dp[(i - 1) % W]) % M
            elif s[i - 1] == "2":
                dp[(i + 1) % W] = (dp[(i + 1) % W] + 6 * dp[(i - 1) % W]) % M
            elif s[i - 1] == "*":
                dp[(i + 1) % W] = (dp[(i + 1) % W] + 15 * dp[(i - 1) % W]) % M
        else:
            dp[(i + 1) % W] = dp[i % W] if s[i] != "0" else 0
            if s[i - 1] == "1":
                dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M
            elif s[i - 1] == "2" and s[i] <= "6":
                dp[(i + 1) % W] = (dp[(i + 1) % W] + dp[(i - 1) % W]) % M
            elif s[i - 1] == "*":
                dp[(i + 1) % W] = (
                    dp[(i + 1) % W] + (2 if s[i] <=
                                       "6" else 1) * dp[(i - 1) % W]
                ) % M
    return dp[len(s) % W]


class Solution(object):
    def numDecodings(self, s):

    if len(s) == 0 or s[0] == "0":
        return 0
    prev, prev_prev = 1, 0
    for i in xrange(len(s)):
        cur = 0
        if s[i] != "0":
            cur = prev
        if i > 0 and (s[i - 1] == "1" or (s[i - 1] == "2" and s[i] <= "6")):
            cur += prev_prev
        prev, prev_prev = cur, prev
    return prev


class Solution(object):
    def decode(self, encoded, first):

    result = [first]
    for x in encoded:
        result.append(result[-1] ^ x)
    return result


class Solution(object):
    def decode(self, encoded):

    curr = 0
    for i in xrange((len(encoded) + 1) + 1):
        curr ^= i
        if i <= len(encoded) and i % 2 == 1:
            curr ^= encoded[i]
    result = [curr]
    for x in encoded:
        result.append(result[-1] ^ x)
    return result


class Solution(object):
    def decodeAtIndex(self, S, K):

    i = 0
    for c in S:
        if c.isdigit():
            i *= int(c)
        else:
            i += 1

    for c in reversed(S):
        K %= i
        if K == 0 and c.isalpha():
            return c

        if c.isdigit():
            i /= int(c)
        else:
            i -= 1


class Solution(object):
    def decompressRLElist(self, nums):

    return [nums[i + 1] for i in xrange(0, len(nums), 2) for _ in xrange(nums[i])]


class Solution(object):
    def movesToMakeZigzag(self, nums):

    result = [0, 0]
    for i in xrange(len(nums)):
        left = nums[i - 1] if i - 1 >= 0 else float("inf")
        right = nums[i + 1] if i + 1 < len(nums) else float("inf")
        result[i % 2] += max(nums[i] - min(left, right) + 1, 0)
    return min(result)


class Solution(object):
    def freqAlphabets(self, s):

    def alpha(num):
        return chr(ord("a") + int(num) - 1)

    i = 0
    result = []
    while i < len(s):
        if i + 2 < len(s) and s[i + 2] == "#":
            result.append(alpha(s[i: i + 2]))
            i += 3
        else:
            result.append(alpha(s[i]))
            i += 1
    return "".join(result)


class Solution2(object):
    def freqAlphabets(self, s):

    def alpha(num):
        return chr(ord("a") + int(num) - 1)

    i = len(s) - 1
    result = []
    while i >= 0:
        if s[i] == "#":
            result.append(alpha(s[i - 2: i]))
            i -= 3
        else:
            result.append(alpha(s[i]))
            i -= 1
    return "".join(reversed(result))


import re


class Solution3(object):
    def freqAlphabets(self, s):

    def alpha(num):
        return chr(ord("a") + int(num) - 1)

    return "".join(alpha(i[:2]) for i in re.findall(r"\d\d#|\d", s))


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def deepestLeavesSum(self, root):

    curr = [root]
    while curr:
        prev, curr = curr, [
            child for p in curr for child in [p.left, p.right] if child
        ]
    return sum(node.val for node in prev)


class Solution(object):
    def defangIPaddr(self, address):

    result = []
    for c in address:
        if c == ".":
            result.append("[.]")
        else:
            result.append(c)
    return "".join(result)


class Solution(object):
    def decrypt(self, code, k):

    result = [0] * len(code)
    if k == 0:
        return result
    left, right = 1, k
    if k < 0:
        k = -k
        left, right = len(code) - k, len(code) - 1
    total = sum(code[i] for i in xrange(left, right + 1))
    for i in xrange(len(code)):
        result[i] = total
        total -= code[left % len(code)]
        total += code[(right + 1) % len(code)]
        left += 1
        right += 1
    return result


import collections


class Solution(object):
    def findShortestSubArray(self, nums):

    counts = collections.Counter(nums)
    left, right = {}, {}
    for i, num in enumerate(nums):
        left.setdefault(num, i)
        right[num] = i
    degree = max(counts.values())
    return min(
        right[num] - left[num] + 1 for num in counts.keys() if counts[num] == degree
    )


class Solution(object):
    def deleteAndEarn(self, nums):

    vals = [0] * 10001
    for num in nums:
        vals[num] += num
    val_i, val_i_1 = vals[0], 0
    for i in xrange(1, len(vals)):
        val_i_1, val_i_2 = val_i, val_i_1
        val_i = max(vals[i] + val_i_2, val_i_1)
    return val_i


class Solution(object):
    def minDeletionSize(self, A):

    result = 0
    unsorted = set(range(len(A) - 1))
    for j in xrange(len(A[0])):
        if any(A[i][j] > A[i + 1][j] for i in unsorted):
            result += 1
        else:
            unsorted -= set(i for i in unsorted if A[i][j] < A[i + 1][j])
    return result


class Solution2(object):
    def minDeletionSize(self, A):

    result = 0
    is_sorted = [False] * (len(A) - 1)
    for j in xrange(len(A[0])):
        tmp = is_sorted[:]
        for i in xrange(len(A) - 1):
            if A[i][j] > A[i + 1][j] and tmp[i] == False:
                result += 1
                break
            if A[i][j] < A[i + 1][j]:
                tmp[i] = True
        else:
            is_sorted = tmp
    return result


class Solution(object):
    def minDeletionSize(self, A):

    dp = [1] * len(A[0])
    for j in xrange(1, len(A[0])):
        for i in xrange(j):
            if all(A[k][i] <= A[k][j] for k in xrange(len(A))):
                dp[j] = max(dp[j], dp[i] + 1)
    return len(A[0]) - max(dp)


class Solution(object):
    def minDeletionSize(self, A):

    result = 0
    for c in xrange(len(A[0])):
        for r in xrange(1, len(A)):
            if A[r - 1][c] > A[r][c]:
                result += 1
                break
    return result


import itertools


class Solution2(object):
    def minDeletionSize(self, A):

    result = 0
    for col in itertools.izip(*A):
        if any(col[i] > col[i + 1] for i in xrange(len(col) - 1)):
            result += 1
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def removeLeafNodes(self, root, target):

    if not root:
        return None
    root.left = self.removeLeafNodes(root.left, target)
    root.right = self.removeLeafNodes(root.right, target)
    return None if root.left == root.right and root.val == target else root


class ListNode(object):
    def __init__(self, val=0, next=None):
    self.val = val
    self.next = next


class Solution(object):
    def deleteNodes(self, head, m, n):

    head = dummy = ListNode(next=head)
    while head:
        for _ in xrange(m):
            if not head.next:
                return dummy.next
            head = head.next
        prev = head
        for _ in xrange(n):
            if not head.next:
                prev.next = None
                return dummy.next
            head = head.next
        prev.next = head.next
    return dummy.next


class Solution(object):
    def deleteNode(self, root, key):

    if not root:
        return root

    if root.val > key:
        root.left = self.deleteNode(root.left, key)
    elif root.val < key:
        root.right = self.deleteNode(root.right, key)
    else:
        if not root.left:
            right = root.right
            del root
            return right
        elif not root.right:
            left = root.left
            del root
            return left
        else:
            successor = root.right
            while successor.left:
                successor = successor.left

            root.val = successor.val
            root.right = self.deleteNode(root.right, successor.val)

    return root


class Solution(object):

    def deleteNode(self, node):
    if node and node.next:
        node_to_delete = node.next
        node.val = node_to_delete.val
        node.next = node_to_delete.next
        del node_to_delete


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def delNodes(self, root, to_delete):

    def delNodesHelper(to_delete_set, root, is_root, result):
        if not root:
            return None
        is_deleted = root.val in to_delete_set
        if is_root and not is_deleted:
            result.append(root)
        root.left = delNodesHelper(
            to_delete_set, root.left, is_deleted, result)
        root.right = delNodesHelper(
            to_delete_set, root.right, is_deleted, result)
        return None if is_deleted else root

    result = []
    to_delete_set = set(to_delete)
    delNodesHelper(to_delete_set, root, True, result)
    return result


class Solution(object):
    def minDistance(self, word1, word2):

    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in xrange(2)]
    for i in xrange(m):
        for j in xrange(n):
            dp[(i + 1) % 2][j + 1] = max(
                dp[i % 2][j + 1],
                dp[(i + 1) % 2][j],
                dp[i % 2][j] + (word1[i] == word2[j]),
            )
    return m + n - 2 * dp[m % 2][n]


import collections


class Solution(object):
    def deleteTreeNodes(self, nodes, parent, value):

    def dfs(value, children, x):
        total, count = value[x], 1
        for y in children[x]:
            t, c = dfs(value, children, y)
            total += t
            count += c if t else 0
        return total, count if total else 0

    children = collections.defaultdict(list)
    for i, p in enumerate(parent):
        if i:
            children[p].append(i)
    return dfs(value, children, 0)[1]


class Solution2(object):
    def deleteTreeNodes(self, nodes, parent, value):

    result = [1] * nodes
    for i in reversed(xrange(1, nodes)):
        value[parent[i]] += value[i]
        result[parent[i]] += result[i] if value[i] else 0
    return result[0]


class Solution(object):
    def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):

    dp = [0] * (len(boxes) + 1)
    left, cost, curr = 0, 1, 0
    for right in xrange(len(boxes)):
        if right == 0 or boxes[right][0] != boxes[right - 1][0]:
            cost += 1
        curr += boxes[right][1]
        while (
            right - left + 1 > maxBoxes
            or curr > maxWeight
            or (left + 1 < right + 1 and dp[left + 1] == dp[left])
        ):
            curr -= boxes[left][1]
            if boxes[left + 1][0] != boxes[left][0]:
                cost -= 1
            left += 1
        dp[right + 1] = dp[(left - 1) + 1] + cost
    return dp[len(boxes)]


import heapq


class FileSharing(object):
    def __init__(self, m):

    self.__users = []
    self.__lookup = set()
    self.__min_heap = []

    def join(self, ownedChunks):

    if self.__min_heap:
        userID = heapq.heappop(self.__min_heap)
    else:
        userID = len(self.__users) + 1
        self.__users.append(set())
    self.__users[userID - 1] = set(ownedChunks)
    self.__lookup.add(userID)
    return userID

    def leave(self, userID):

    if userID not in self.__lookup:
        return
    self.__lookup.remove(userID)
    self.__users[userID - 1] = []
    heapq.heappush(self.__min_heap, userID)

    def request(self, userID, chunkID):

    result = []
    for u, chunks in enumerate(self.__users, 1):
        if chunkID not in chunks:
            continue
        result.append(u)
    if not result:
        return
    self.__users[userID - 1].add(chunkID)
    return result


import collections
import heapq


class FileSharing2(object):
    def __init__(self, m):

    self.__users = []
    self.__lookup = set()
    self.__chunks = collections.defaultdict(set)
    self.__min_heap = []

    def join(self, ownedChunks):

    if self.__min_heap:
        userID = heapq.heappop(self.__min_heap)
    else:
        userID = len(self.__users) + 1
        self.__users.append(set())
    self.__users[userID - 1] = set(ownedChunks)
    self.__lookup.add(userID)
    for c in ownedChunks:
        self.__chunks[c].add(userID)
    return userID

    def leave(self, userID):

    if userID not in self.__lookup:
        return
    for c in self.__users[userID - 1]:
        self.__chunks[c].remove(userID)
    self.__lookup.remove(userID)
    self.__users[userID - 1] = []
    heapq.heappush(self.__min_heap, userID)

    def request(self, userID, chunkID):

    result = sorted(self.__chunks[chunkID])
    if not result:
        return
    self.__users[userID - 1].add(chunkID)
    self.__chunks[chunkID].add(userID)
    return result


import collections
import random


class Leaderboard(object):
    def __init__(self):
    self.__lookup = collections.Counter()

    def addScore(self, playerId, score):

    self.__lookup[playerId] += score

    def top(self, K):

    def kthElement(nums, k, compare):
        def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in xrange(left, right):
                if compare(nums[i], nums[right]):
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            new_pivot_idx = PartitionAroundPivot(
                left, right, pivot_idx, nums, compare
            )
            if new_pivot_idx == k:
                return
            elif new_pivot_idx > k:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    scores = self.__lookup.values()
    kthElement(scores, K, lambda a, b: a > b)
    return sum(scores[:K])

    def reset(self, playerId):

    self.__lookup[playerId] = 0


class CustomStack(object):
    def __init__(self, maxSize):

    self.__max_size = maxSize
    self.__stk = []

    def push(self, x):

    if len(self.__stk) == self.__max_size:
        return
    self.__stk.append([x, 0])

    def pop(self):

    if not self.__stk:
        return -1
    x, inc = self.__stk.pop()
    if self.__stk:
        self.__stk[-1][1] += inc
    return x + inc

    def increment(self, k, val):

    i = min(len(self.__stk), k) - 1
    if i >= 0:
        self.__stk[i][1] += val


import abc
from abc import ABCMeta, abstractmethod


class Node:
    __metaclass__ = ABCMeta

    @abstractmethod
    def evaluate(self):
    pass


import operator


class NodeIter(Node):
    ops = {"+": operator.add, "-": operator.sub,
           "*": operator.mul, "/": operator.div}

    def __init__(self, val):
    self.val = val
    self.left = None
    self.right = None

    def evaluate(self):
    result = [0]
    stk = [(1, (self, result))]
    while stk:
        step, args = stk.pop()
        if step == 1:
            node, ret = args
            if node.val.isdigit():
                ret[0] = int(node.val)
                continue
            ret1, ret2 = [0], [0]
            stk.append((2, (node, ret1, ret2, ret)))
            stk.append((1, (node.right, ret2)))
            stk.append((1, (node.left, ret1)))
        elif step == 2:
            node, ret1, ret2, ret = args
            ret[0] = NodeIter.ops[node.val](ret1[0], ret2[0])
    return result[0]


class TreeBuilder(object):
    def buildTree(self, postfix):

    stk = []
    for c in postfix:
        if c.isdigit():
            stk.append(NodeIter(c))
        else:
            node = NodeIter(c)
            node.right = stk.pop()
            node.left = stk.pop()
            stk.append(node)
    return stk.pop()


class NodeRecu(Node):
    ops = {"+": operator.add, "-": operator.sub,
           "*": operator.mul, "/": operator.div}

    def __init__(self, val):
    self.val = val
    self.left = None
    self.right = None

    def evaluate(self):
    if self.val.isdigit():
        return int(self.val)
    return NodeRecu.ops[self.val](self.left.evaluate(), self.right.evaluate())


class TreeBuilder2(object):
    def buildTree(self, postfix):

    stk = []
    for c in postfix:
        if c.isdigit():
            stk.append(NodeRecu(c))
        else:
            node = NodeRecu(c)
            node.right = stk.pop()
            node.left = stk.pop()
            stk.append(node)
    return stk.pop()


class OrderedStream(object):
    def __init__(self, n):

    self.__i = 0
    self.__values = [None] * n

    def insert(self, id, value):

    id -= 1
    self.__values[id] = value
    result = []
    if self.__i != id:
        return result
    while self.__i < len(self.__values) and self.__values[self.__i]:
        result.append(self.__values[self.__i])
        self.__i += 1
    return result


import threading
import collections


class BoundedBlockingQueue(object):
    def __init__(self, capacity):

    self.__cv = threading.Condition()
    self.__q = collections.deque()
    self.__cap = capacity

    def enqueue(self, element):

    with self.__cv:
        while len(self.__q) == self.__cap:
            self.__cv.wait()
        self.__q.append(element)
        self.__cv.notifyAll()

    def dequeue(self):

    with self.__cv:
        while not self.__q:
            self.__cv.wait()
        self.__cv.notifyAll()
        return self.__q.popleft()

    def size(self):

    with self.__cv:
        return len(self.__q)


class BrowserHistory(object):
    def __init__(self, homepage):

    self.__history = [homepage]
    self.__curr = 0

    def visit(self, url):

    while len(self.__history) > self.__curr + 1:
        self.__history.pop()
    self.__history.append(url)
    self.__curr += 1

    def back(self, steps):

    self.__curr = max(self.__curr - steps, 0)
    return self.__history[self.__curr]

    def forward(self, steps):

    self.__curr = min(self.__curr + steps, len(self.__history) - 1)
    return self.__history[self.__curr]


class MyCircularDeque(object):
    def __init__(self, k):

    self.__start = 0
    self.__size = 0
    self.__buffer = [0] * k

    def insertFront(self, value):

    if self.isFull():
        return False
    self.__start = (self.__start - 1) % len(self.__buffer)
    self.__buffer[self.__start] = value
    self.__size += 1
    return True

    def insertLast(self, value):

    if self.isFull():
        return False
    self.__buffer[(self.__start + self.__size) % len(self.__buffer)] = value
    self.__size += 1
    return True

    def deleteFront(self):

    if self.isEmpty():
        return False
    self.__start = (self.__start + 1) % len(self.__buffer)
    self.__size -= 1
    return True

    def deleteLast(self):

    if self.isEmpty():
        return False
    self.__size -= 1
    return True

    def getFront(self):

    return -1 if self.isEmpty() else self.__buffer[self.__start]

    def getRear(self):

    return (
        -1
        if self.isEmpty()
        else self.__buffer[(self.__start + self.__size - 1) % len(self.__buffer)]
    )

    def isEmpty(self):

    return self.__size == 0

    def isFull(self):

    return self.__size == len(self.__buffer)


class MyCircularQueue(object):
    def __init__(self, k):

    self.__start = 0
    self.__size = 0
    self.__buffer = [0] * k

    def enQueue(self, value):

    if self.isFull():
        return False
    self.__buffer[(self.__start + self.__size) % len(self.__buffer)] = value
    self.__size += 1
    return True

    def deQueue(self):

    if self.isEmpty():
        return False
    self.__start = (self.__start + 1) % len(self.__buffer)
    self.__size -= 1
    return True

    def Front(self):

    return -1 if self.isEmpty() else self.__buffer[self.__start]

    def Rear(self):

    return (
        -1
        if self.isEmpty()
        else self.__buffer[(self.__start + self.__size - 1) % len(self.__buffer)]
    )

    def isEmpty(self):

    return self.__size == 0

    def isFull(self):

    return self.__size == len(self.__buffer)


import re


class StringIterator(object):
    def __init__(self, compressedString):

    self.__result = re.findall(r"([a-zA-Z])(\d+)", compressedString)
    self.__index, self.__num, self.__ch = 0, 0, " "

    def next(self):

    if not self.hasNext():
        return " "
    if self.__num == 0:
        self.__ch = self.__result[self.__index][0]
        self.__num = int(self.__result[self.__index][1])
        self.__index += 1
    self.__num -= 1
    return self.__ch

    def hasNext(self):

    return self.__index != len(self.__result) or self.__num != 0


import collections


class Excel(object):
    def __init__(self, H, W):

    self.__exl = [[0 for _ in xrange(ord(W) - ord("A") + 1)]
                  for _ in xrange(H + 1)]
    self.__fward = collections.defaultdict(
        lambda: collections.defaultdict(int))
    self.__bward = collections.defaultdict(set)

    def set(self, r, c, v):

    self.__reset_dependency(r, c)
    self.__update_others(r, c, v)

    def get(self, r, c):

    return self.__exl[r][ord(c) - ord("A")]

    def sum(self, r, c, strs):

    self.__reset_dependency(r, c)
    result = self.__calc_and_update_dependency(r, c, strs)
    self.__update_others(r, c, result)
    return result

    def __reset_dependency(self, r, c):
    key = (r, c)
    if key in self.__bward.keys():
        for k in self.__bward[key]:
            self.__fward[k].pop(key, None)
        self.__bward[key] = set()

    def __calc_and_update_dependency(self, r, c, strs):
    result = 0
    for s in strs:
        s, e = s.split(":")[0], s.split(":")[1] if ":" in s else s
        left, right, top, bottom = (
            ord(s[0]) - ord("A"),
            ord(e[0]) - ord("A"),
            int(s[1:]),
            int(e[1:]),
        )
        for i in xrange(top, bottom + 1):
            for j in xrange(left, right + 1):
                result += self.__exl[i][j]
                self.__fward[(i, chr(ord("A") + j))][(r, c)] += 1
                self.__bward[(r, c)].add((i, chr(ord("A") + j)))
    return result

    def __update_others(self, r, c, v):
    prev = self.__exl[r][ord(c) - ord("A")]
    self.__exl[r][ord(c) - ord("A")] = v
    q = collections.deque()
    q.append(((r, c), v - prev))
    while q:
        key, diff = q.popleft()
        if key in self.__fward:
            for k, count in self.__fward[key].iteritems():
                q.append((k, diff * count))
                self.__exl[k[0]][ord(k[1]) - ord("A")] += diff * count


class FileSystem(object):
    def __init__(self):
    self.__lookup = {"": -1}

    def create(self, path, value):

    if path[: path.rfind("/")] not in self.__lookup:
        return False
    self.__lookup[path] = value
    return True

    def get(self, path):

    if path not in self.__lookup:
        return -1
    return self.__lookup[path]


import collections


class FrontMiddleBackQueue(object):
    def __init__(self):
    self.__left, self.__right = collections.deque(), collections.deque()

    def pushFront(self, val):

    self.__left.appendleft(val)
    self.__balance()

    def pushMiddle(self, val):

    if len(self.__left) > len(self.__right):
        self.__right.appendleft(self.__left.pop())
    self.__left.append(val)

    def pushBack(self, val):

    self.__right.append(val)
    self.__balance()

    def popFront(self):

    val = (self.__left or collections.deque([-1])).popleft()
    self.__balance()
    return val

    def popMiddle(self):

    val = (self.__left or [-1]).pop()
    self.__balance()
    return val

    def popBack(self):

    val = (self.__right or self.__left or [-1]).pop()
    self.__balance()
    return val

    def __balance(self):
    if len(self.__left) > len(self.__right) + 1:
        self.__right.appendleft(self.__left.pop())
    elif len(self.__left) < len(self.__right):
        self.__left.append(self.__right.popleft())


class ListNode(object):
    def __init__(self, key, val):
    self.val = val
    self.key = key
    self.next = None
    self.prev = None


class LinkedList(object):
    def __init__(self):
    self.head = None
    self.tail = None

    def insert(self, node):
    node.next, node.prev = None, None
    if self.head is None:
        self.head = node
    else:
        self.tail.next = node
        node.prev = self.tail
    self.tail = node

    def delete(self, node):
    if node.prev:
        node.prev.next = node.next
    else:
        self.head = node.next
    if node.next:
        node.next.prev = node.prev
    else:
        self.tail = node.prev
    node.next, node.prev = None, None

    def find(self, key):
    curr = self.head
    while curr:
        if curr.key == key:
            break
        curr = curr.next
    return curr


class MyHashMap(object):
    def __init__(self):

    self.__data = [LinkedList() for _ in xrange(10000)]

    def put(self, key, value):

    l = self.__data[key % len(self.__data)]
    node = l.find(key)
    if node:
        node.val = value
    else:
        l.insert(ListNode(key, value))

    def get(self, key):

    l = self.__data[key % len(self.__data)]
    node = l.find(key)
    if node:
        return node.val
    else:
        return -1

    def remove(self, key):

    l = self.__data[key % len(self.__data)]
    node = l.find(key)
    if node:
        l.delete(node)


class ListNode(object):
    def __init__(self, key, val):
    self.val = val
    self.key = key
    self.next = None
    self.prev = None


class LinkedList(object):
    def __init__(self):
    self.head = None
    self.tail = None

    def insert(self, node):
    node.next, node.prev = None, None
    if self.head is None:
        self.head = node
    else:
        self.tail.next = node
        node.prev = self.tail
    self.tail = node

    def delete(self, node):
    if node.prev:
        node.prev.next = node.next
    else:
        self.head = node.next
    if node.next:
        node.next.prev = node.prev
    else:
        self.tail = node.prev
    node.next, node.prev = None, None

    def find(self, key):
    curr = self.head
    while curr:
        if curr.key == key:
            break
        curr = curr.next
    return curr


class MyHashSet(object):
    def __init__(self):

    self.__data = [LinkedList() for _ in xrange(10000)]

    def add(self, key):

    l = self.__data[key % len(self.__data)]
    node = l.find(key)
    if not node:
        l.insert(ListNode(key, 0))

    def remove(self, key):

    l = self.__data[key % len(self.__data)]
    node = l.find(key)
    if node:
        l.delete(node)

    def contains(self, key):

    l = self.__data[key % len(self.__data)]
    node = l.find(key)
    return node is not None


from collections import deque


class HitCounter(object):
    def __init__(self):

    self.__k = 300
    self.__dq = deque()
    self.__count = 0

    def hit(self, timestamp):

    self.getHits(timestamp)
    if self.__dq and self.__dq[-1][0] == timestamp:
        self.__dq[-1][1] += 1
    else:
        self.__dq.append([timestamp, 1])
    self.__count += 1

    def getHits(self, timestamp):

    while self.__dq and self.__dq[0][0] <= timestamp - self.__k:
        self.__count -= self.__dq.popleft()[1]
    return self.__count


class TrieNode(object):
    def __init__(self):
    self.is_file = False
    self.children = {}
    self.content = ""


class FileSystem(object):
    def __init__(self):
    self.__root = TrieNode()

    def ls(self, path):

    curr = self.__getNode(path)

    if curr.is_file:
        return [self.__split(path, "/")[-1]]

    return sorted(curr.children.keys())

    def mkdir(self, path):

    curr = self.__putNode(path)
    curr.is_file = False

    def addContentToFile(self, filePath, content):

    curr = self.__putNode(filePath)
    curr.is_file = True
    curr.content += content

    def readContentFromFile(self, filePath):

    return self.__getNode(filePath).content

    def __getNode(self, path):
    curr = self.__root
    for s in self.__split(path, "/"):
        curr = curr.children[s]
    return curr

    def __putNode(self, path):
    curr = self.__root
    for s in self.__split(path, "/"):
        if s not in curr.children:
            curr.children[s] = TrieNode()
        curr = curr.children[s]
    return curr

    def __split(self, path, delim):
    if path == "/":
        return []
    return path.split("/")[1:]


class Node(object):
    def __init__(self, value):
    self.val = value
    self.next = self.prev = None


class MyLinkedList(object):
    def __init__(self):

    self.__head = self.__tail = Node(-1)
    self.__head.next = self.__tail
    self.__tail.prev = self.__head
    self.__size = 0

    def get(self, index):

    if 0 <= index <= self.__size // 2:
        return self.__forward(0, index, self.__head.next).val
    elif self.__size // 2 < index < self.__size:
        return self.__backward(self.__size, index, self.__tail).val
    return -1

    def addAtHead(self, val):

    self.__add(self.__head, val)

    def addAtTail(self, val):

    self.__add(self.__tail.prev, val)

    def addAtIndex(self, index, val):

    if 0 <= index <= self.__size // 2:
        self.__add(self.__forward(0, index, self.__head.next).prev, val)
    elif self.__size // 2 < index <= self.__size:
        self.__add(self.__backward(self.__size, index, self.__tail).prev, val)

    def deleteAtIndex(self, index):

    if 0 <= index <= self.__size // 2:
        self.__remove(self.__forward(0, index, self.__head.next))
    elif self.__size // 2 < index < self.__size:
        self.__remove(self.__backward(self.__size, index, self.__tail))

    def __add(self, preNode, val):
    node = Node(val)
    node.prev = preNode
    node.next = preNode.next
    node.prev.next = node.next.prev = node
    self.__size += 1

    def __remove(self, node):
    node.prev.next = node.next
    node.next.prev = node.prev
    self.__size -= 1

    def __forward(self, start, end, curr):
    while start != end:
        start += 1
        curr = curr.next
    return curr

    def __backward(self, start, end, curr):
    while start != end:
        start -= 1
        curr = curr.prev
    return curr


class LogSystem(object):
    def __init__(self):
    self.__logs = []
    self.__granularity = {
        "Year": 4,
        "Month": 7,
        "Day": 10,
        "Hour": 13,
        "Minute": 16,
        "Second": 19,
    }

    def put(self, id, timestamp):

    self.__logs.append((id, timestamp))

    def retrieve(self, s, e, gra):

    i = self.__granularity[gra]
    begin = s[:i]
    end = e[:i]
    return sorted(
        id for id, timestamp in self.__logs if begin <= timestamp[:i] <= end
    )


from sortedcontainers import SortedList


class MRUQueue(object):
    def __init__(self, n):

    self.__sl = SortedList((i - 1, i) for i in xrange(1, n + 1))

    def fetch(self, k):

    last, _ = self.__sl[-1]
    _, val = self.__sl.pop(k - 1)
    self.__sl.add((last + 1, val))
    return val


class BIT(object):
    def __init__(self, n):
    MAX_CALLS = 2000
    self.__bit = [0] * (n + MAX_CALLS + 1)
    for i in xrange(1, len(self.__bit)):
        self.__bit[i] = (1 if i - 1 < n else 0) + self.__bit[i - 1]
    for i in reversed(xrange(1, len(self.__bit))):
        last_i = i - (i & -i)
        self.__bit[i] -= self.__bit[last_i]

    def add(self, i, val):
    i += 1
    while i < len(self.__bit):
        self.__bit[i] += val
        i += i & -i

    def query(self, i):
    i += 1
    ret = 0
    while i > 0:
        ret += self.__bit[i]
        i -= i & -i
    return ret

    def binary_lift(self, k):
    floor_log2_n = len(self.__bit).bit_length() - 1
    pow_i = 2 ** floor_log2_n
    total = pos = 0
    for i in reversed(xrange(floor_log2_n + 1)):
        if pos + pow_i < len(self.__bit) and not (
            total + self.__bit[pos + pow_i] >= k
        ):
            total += self.__bit[pos + pow_i]
            pos += pow_i
        pow_i >>= 1
    return (pos + 1) - 1


class MRUQueue2(object):
    def __init__(self, n):

    self.__bit = BIT(n)
    self.__lookup = {i: i + 1 for i in xrange(n)}
    self.__curr = n

    def fetch(self, k):

    pos = self.__bit.binary_lift(k)
    val = self.__lookup.pop(pos)
    self.__bit.add(pos, -1)
    self.__bit.add(self.__curr, 1)
    self.__lookup[self.__curr] = val
    self.__curr += 1
    return val


import collections
import math


class MRUQueue3(object):
    def __init__(self, n):

    self.__buckets = [collections.deque()
                      for _ in xrange(int(math.ceil(n ** 0.5)))]
    for i in xrange(n):
        self.__buckets[i // len(self.__buckets)].append(i + 1)

    def fetch(self, k):

    k -= 1
    left, idx = divmod(k, len(self.__buckets))
    val = self.__buckets[left][idx]
    del self.__buckets[left][idx]
    self.__buckets[-1].append(val)
    for i in reversed(xrange(left, len(self.__buckets) - 1)):
        x = self.__buckets[i + 1].popleft()
        self.__buckets[i].append(x)
    return val


class ParkingSystem(object):
    def __init__(self, big, medium, small):

    self.__space = [0, big, medium, small]

    def addCar(self, carType):

    if self.__space[carType] > 0:
        self.__space[carType] -= 1
        return True
    return False


class PhoneDirectory(object):
    def __init__(self, maxNumbers):

    self.__curr = 0
    self.__numbers = range(maxNumbers)
    self.__used = [False] * maxNumbers

    def get(self):

    if self.__curr == len(self.__numbers):
        return -1
    number = self.__numbers[self.__curr]
    self.__curr += 1
    self.__used[number] = True
    return number

    def check(self, number):

    return 0 <= number < len(self.__numbers) and not self.__used[number]

    def release(self, number):

    if not 0 <= number < len(self.__numbers) or not self.__used[number]:
        return
    self.__used[number] = False
    self.__curr -= 1
    self.__numbers[self.__curr] = number


import collections


class TrieNode(object):
    def __init__(self):
    self.__TOP_COUNT = 3
    self.infos = []
    self.leaves = {}

    def insert(self, s, times):
    cur = self
    cur.add_info(s, times)
    for c in s:
        if c not in cur.leaves:
            cur.leaves[c] = TrieNode()
        cur = cur.leaves[c]
        cur.add_info(s, times)

    def add_info(self, s, times):
    for p in self.infos:
        if p[1] == s:
            p[0] = -times
            break
    else:
        self.infos.append([-times, s])
    self.infos.sort()
    if len(self.infos) > self.__TOP_COUNT:
        self.infos.pop()


class AutocompleteSystem(object):
    def __init__(self, sentences, times):

    self.__trie = TrieNode()
    self.__cur_node = self.__trie
    self.__search = []
    self.__sentence_to_count = collections.defaultdict(int)
    for sentence, count in zip(sentences, times):
        self.__sentence_to_count[sentence] = count
        self.__trie.insert(sentence, count)

    def input(self, c):

    result = []
    if c == "#":
        self.__sentence_to_count["".join(self.__search)] += 1
        self.__trie.insert(
            "".join(self.__search), self.__sentence_to_count["".join(
                self.__search)]
        )
        self.__cur_node = self.__trie
        self.__search = []
    else:
        self.__search.append(c)
        if self.__cur_node:
            if c not in self.__cur_node.leaves:
                self.__cur_node = None
                return []
            self.__cur_node = self.__cur_node.leaves[c]
            result = [p[1] for p in self.__cur_node.infos]
    return result


import random


class SkipNode(object):
    def __init__(self, level=0, num=None):
    self.num = num
    self.nexts = [None] * level


class Skiplist(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2
    MAX_LEVEL = 32

    def __init__(self):
    self.__head = SkipNode()
    self.__len = 0

    def search(self, target):

    return True if self.__find(target, self.__find_prev_nodes(target)) else False

    def add(self, num):

    node = SkipNode(self.__random_level(), num)
    if len(self.__head.nexts) < len(node.nexts):
        self.__head.nexts.extend(
            [None] * (len(node.nexts) - len(self.__head.nexts))
        )
    prevs = self.__find_prev_nodes(num)
    for i in xrange(len(node.nexts)):
        node.nexts[i] = prevs[i].nexts[i]
        prevs[i].nexts[i] = node
    self.__len += 1

    def erase(self, num):

    prevs = self.__find_prev_nodes(num)
    curr = self.__find(num, prevs)
    if not curr:
        return False
    self.__len -= 1
    for i in reversed(xrange(len(curr.nexts))):
        prevs[i].nexts[i] = curr.nexts[i]
        if not self.__head.nexts[i]:
            self.__head.nexts.pop()
    return True

    def __find(self, num, prevs):
    if prevs:
        candidate = prevs[0].nexts[0]
        if candidate and candidate.num == num:
            return candidate
    return None

    def __find_prev_nodes(self, num):
    prevs = [None] * len(self.__head.nexts)
    curr = self.__head
    for i in reversed(xrange(len(self.__head.nexts))):
        while curr.nexts[i] and curr.nexts[i].num < num:
            curr = curr.nexts[i]
        prevs[i] = curr
    return prevs

    def __random_level(self):
    level = 1
    while (
        random.randint(1, Skiplist.P_DENOMINATOR) <= Skiplist.P_NUMERATOR
        and level < Skiplist.MAX_LEVEL
    ):
        level += 1
    return level

    def __len__(self):
    return self.__len

    def __str__(self):
    result = []
    for i in reversed(xrange(len(self.__head.nexts))):
        result.append([])
        curr = self.__head.nexts[i]
        while curr:
            result[-1].append(str(curr.num))
            curr = curr.nexts[i]
    return "\n".join(map(lambda x: "->".join(x), result))


from collections import deque


class SnakeGame(object):

    def __init__(self, width, height, food):

    self.__width = width
    self.__height = height
    self.__score = 0
    self.__f = 0
    self.__food = food
    self.__snake = deque([(0, 0)])
    self.__direction = {"U": (-1, 0), "L": (0, -1), "R": (0, 1), "D": (1, 0)}
    self.__lookup = {(0, 0)}

    def move(self, direction):

    def valid(x, y):
        return 0 <= x < self.__height and 0 <= y < self.__width and (x, y) not in self.__lookup
    d = self.__direction[direction]
    x, y = self.__snake[-1][0] + d[0], self.__snake[-1][1] + d[1]
    self.__lookup.remove(self.__snake[0])
    tail = self.__snake.popleft()
    if not valid(x, y):
        return -1
    elif self.__f != len(self.__food) and (self.__food[self.__f][0], self.__food[self.__f][1]) == (x, y):
        self.__score += 1
        self.__f += 1
        self.__snake.appendleft(tail)
        self.__lookup.add(tail)
    self.__snake.append((x, y))
    self.__lookup.add((x, y))
    return self.__score


class TicTacToe(object):
    def __init__(self, n):

    self.__size = n
    self.__rows = [[0, 0] for _ in xrange(n)]
    self.__cols = [[0, 0] for _ in xrange(n)]
    self.__diagonal = [0, 0]
    self.__anti_diagonal = [0, 0]

    def move(self, row, col, player):

    i = player - 1
    self.__rows[row][i] += 1
    self.__cols[col][i] += 1
    if row == col:
        self.__diagonal[i] += 1
    if col == len(self.__rows) - row - 1:
        self.__anti_diagonal[i] += 1
    if any(
        self.__rows[row][i] == self.__size,
        self.__cols[col][i] == self.__size,
        self.__diagonal[i] == self.__size,
        self.__anti_diagonal[i] == self.__size,
    ):
        return player

    return 0


import collections
import heapq


class Twitter(object):
    def __init__(self):

    self.__number_of_most_recent_tweets = 10
    self.__followings = collections.defaultdict(set)
    self.__messages = collections.defaultdict(list)
    self.__time = 0

    def postTweet(self, userId, tweetId):

    self.__time += 1
    self.__messages[userId].append((self.__time, tweetId))

    def getNewsFeed(self, userId):

    max_heap = []
    if self.__messages[userId]:
        heapq.heappush(max_heap, (-self.__messages[userId][-1][0], userId, 0))
    for uid in self.__followings[userId]:
        if self.__messages[uid]:
            heapq.heappush(max_heap, (-self.__messages[uid][-1][0], uid, 0))

    result = []
    while max_heap and len(result) < self.__number_of_most_recent_tweets:
        t, uid, curr = heapq.heappop(max_heap)
        nxt = curr + 1
        if nxt != len(self.__messages[uid]):
            heapq.heappush(
                max_heap, (-self.__messages[uid][-(nxt + 1)][0], uid, nxt)
            )
        result.append(self.__messages[uid][-(curr + 1)][1])
    return result

    def follow(self, followerId, followeeId):

    if followerId != followeeId:
        self.__followings[followerId].add(followeeId)

    def unfollow(self, followerId, followeeId):

    self.__followings[followerId].discard(followeeId)


import collections


class UndergroundSystem(object):
    def __init__(self):
    self.__live = {}
    self.__statistics = collections.defaultdict(lambda: [0, 0])

    def checkIn(self, id, stationName, t):

    self.__live[id] = (stationName, t)

    def checkOut(self, id, stationName, t):

    startStation, startTime = self.__live.pop(id)
    self.__statistics[startStation, stationName][0] += t - startTime
    self.__statistics[startStation, stationName][1] += 1

    def getAverageTime(self, startStation, endStation):

    total_time, cnt = self.__statistics[startStation, endStation]
    return float(total_time) / cnt


import itertools


class Solution(object):
    def destCity(self, paths):

    A, B = map(set, itertools.izip(*paths))
    return (B - A).pop()


class Solution(object):
    def detectCapitalUse(self, word):

    return word.isupper() or word.islower() or word.istitle()


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.count = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root != y_root:
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.count -= 1


class Solution(object):
    def containsCycle(self, grid):

    def index(n, i, j):
        return i * n + j

    union_find = UnionFind(len(grid) * len(grid[0]))
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            if (
                i
                and j
                and grid[i][j] == grid[i - 1][j] == grid[i][j - 1]
                and union_find.find_set(index(len(grid[0]), i - 1, j))
                == union_find.find_set(index(len(grid[0]), i, j - 1))
            ):
                return True
            if i and grid[i][j] == grid[i - 1][j]:
                union_find.union_set(
                    index(len(grid[0]), i - 1, j), index(len(grid[0]), i, j)
                )
            if j and grid[i][j] == grid[i][j - 1]:
                union_find.union_set(
                    index(len(grid[0]), i, j - 1), index(len(grid[0]), i, j)
                )
    return False


class Solution2(object):
    def containsCycle(self, grid):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            if not grid[i][j]:
                continue
            val = grid[i][j]
            q = [(i, j)]
            while q:
                new_q = []
                for r, c in q:
                    if not grid[r][c]:
                        return True
                    grid[r][c] = 0
                    for dr, dc in directions:
                        nr, nc = r + dr, c + dc
                        if not (
                            0 <= nr < len(grid)
                            and 0 <= nc < len(grid[0])
                            and grid[nr][nc] == val
                        ):
                            continue
                        new_q.append((nr, nc))
                q = new_q
    return False


class Solution(object):
    def containsPattern(self, arr, m, k):

    cnt = 0
    for i in xrange(len(arr) - m):
        if arr[i] != arr[i + m]:
            cnt = 0
            continue
        cnt += 1
        if cnt == (k - 1) * m:
            return True
    return False


class Solution(object):
    def halvesAreAlike(self, s):

    vowels = set("aeiouAEIOU")
    cnt1 = cnt2 = 0
    left, right = 0, len(s) - 1
    while left < right:
        cnt1 += s[left] in vowels
        cnt2 += s[right] in vowels
        left += 1
        right -= 1
    return cnt1 == cnt2


import collections


class Solution(object):
    def closeStrings(self, word1, word2):

    if len(word1) != len(word2):
        return False

    cnt1, cnt2 = collections.Counter(word1), collections.Counter(
        word2
    )
    return set(cnt1.iterkeys()) == set(cnt2.iterkeys()) and collections.Counter(
        cnt1.itervalues()
    ) == collections.Counter(cnt2.itervalues())


class Solution(object):
    def diStringMatch(self, S):

    result = []
    left, right = 0, len(S)
    for c in S:
        if c == "I":
            result.append(left)
            left += 1
        else:
            result.append(right)
            right -= 1
    result.append(left)
    return result


import itertools
import collections


class Solution(object):
    def findDiagonalOrder(self, nums):

    result, dq, col = [], collections.deque(), 0
    for i in xrange(len(nums) + max(itertools.imap(len, nums)) - 1):
        new_dq = collections.deque()
        if i < len(nums):
            dq.appendleft((i, 0))
        for r, c in dq:
            result.append(nums[r][c])
            if c + 1 < len(nums[r]):
                new_dq.append((r, c + 1))
        dq = new_dq
    return result


class Solution2(object):
    def findDiagonalOrder(self, nums):

    result = []
    for r, row in enumerate(nums):
        for c, num in enumerate(row):
            if len(result) <= r + c:
                result.append([])
            result[r + c].append(num)
    return [num for row in result for num in reversed(row)]


class Solution(object):
    def findDiagonalOrder(self, matrix):

    if not matrix or not matrix[0]:
        return []

    result = []
    row, col, d = 0, 0, 0
    dirs = [(-1, 1), (1, -1)]

    for i in xrange(len(matrix) * len(matrix[0])):
        result.append(matrix[row][col])
        row += dirs[d][0]
        col += dirs[d][1]

        if row >= len(matrix):
            row = len(matrix) - 1
            col += 2
            d = 1 - d
        elif col >= len(matrix[0]):
            col = len(matrix[0]) - 1
            row += 2
            d = 1 - d
        elif row < 0:
            row = 0
            d = 1 - d
        elif col < 0:
            col = 0
            d = 1 - d

    return result


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    self.val = val
    self.left = left
    self.right = right


class Solution(object):
    def diameterOfBinaryTree(self, root):

    def iter_dfs(node):
        result = 0
        max_depth = [0]
        stk = [(1, [node, max_depth])]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, ret = params
                if not node:
                    continue
                ret1, ret2 = [0], [0]
                stk.append((2, [node, ret1, ret2, ret]))
                stk.append((1, [node.right, ret2]))
                stk.append((1, [node.left, ret1]))
            elif step == 2:
                node, ret1, ret2, ret = params
                result = max(result, ret1[0] + ret2[0])
                ret[0] = 1 + max(ret1[0], ret2[0])
        return result

    return iter_dfs(root)


class Solution2(object):
    def diameterOfBinaryTree(self, root):

    def dfs(root):
        if not root:
            return 0, 0
        left_d, left_h = dfs(root.left)
        right_d, right_h = dfs(root.right)
        return max(left_d, right_d, left_h + right_h), 1 + max(left_h, right_h)

    return dfs(root)[0]


class Node(object):
    def __init__(self, val=None, children=None):
    self.val = val
    self.children = children if children is not None else []


class Solution(object):
    def diameter(self, root):

    def iter_dfs(root):
        result = [0] * 2
        stk = [(1, (root, result))]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, ret = params
                for child in reversed(node.children):
                    ret2 = [0] * 2
                    stk.append((2, (ret2, ret)))
                    stk.append((1, (child, ret2)))
            else:
                ret2, ret = params
                ret[0] = max(ret[0], ret2[0], ret[1] + ret2[1] + 1)
                ret[1] = max(ret[1], ret2[1] + 1)
        return result

    return iter_dfs(root)[0]


class Solution2(object):
    def diameter(self, root):

    def dfs(node):
        max_dia, max_depth = 0, 0
        for child in node.children:
            child_max_dia, child_max_depth = dfs(child)
            max_dia = max(max_dia, child_max_dia,
                          max_depth + child_max_depth + 1)
            max_depth = max(max_depth, child_max_depth + 1)
        return max_dia, max_depth

    return dfs(root)[0]


class Solution(object):
    def dieSimulator(self, n, rollMax):

    MOD = 10 ** 9 + 7

    def sum_mod(array):
        return reduce(lambda x, y: (x + y) % MOD, array)

    dp = [[1] + [0] * (rollMax[i] - 1) for i in xrange(6)]
    for _ in xrange(n - 1):
        new_dp = [[0] * rollMax[i] for i in xrange(6)]
        for i in xrange(6):
            for k in xrange(rollMax[i]):
                for j in xrange(6):
                    if i == j:
                        if k < rollMax[i] - 1:
                            new_dp[j][k + 1] = (new_dp[j]
                                                [k + 1] + dp[i][k]) % MOD
                    else:
                        new_dp[j][0] = (new_dp[j][0] + dp[i][k]) % MOD
        dp = new_dp
    return sum_mod(sum_mod(row) for row in dp)


import itertools


class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):

    total = sum(itertools.islice(calories, 0, k))
    result = int(total > upper) - int(total < lower)
    for i in xrange(k, len(calories)):
        total += calories[i] - calories[i - k]
        result += int(total > upper) - int(total < lower)
    return result


import operator
import re


class Solution(object):

    def diffWaysToCompute(self, input):
    tokens = re.split("(\D)", input)
    nums = map(int, tokens[::2])
    ops = map(
        {"+": operator.add, "-": operator.sub,
            "*": operator.mul}.get, tokens[1::2]
    )
    lookup = [[None for _ in xrange(len(nums))] for _ in xrange(len(nums))]

    def diffWaysToComputeRecu(left, right):
        if left == right:
            return [nums[left]]
        if lookup[left][right]:
            return lookup[left][right]
        lookup[left][right] = [
            ops[i](x, y)
            for i in xrange(left, right)
            for x in diffWaysToComputeRecu(left, i)
            for y in diffWaysToComputeRecu(i + 1, right)
        ]
        return lookup[left][right]

    return diffWaysToComputeRecu(0, len(nums) - 1)


class Solution2(object):

    def diffWaysToCompute(self, input):
    lookup = [
        [None for _ in xrange(len(input) + 1)] for _ in xrange(len(input) + 1)
    ]
    ops = {"+": operator.add, "-": operator.sub, "*": operator.mul}

    def diffWaysToComputeRecu(left, right):
        if lookup[left][right]:
            return lookup[left][right]
        result = []
        for i in xrange(left, right):
            if input[i] in ops:
                for x in diffWaysToComputeRecu(left, i):
                    for y in diffWaysToComputeRecu(i + 1, right):
                        result.append(ops[input[i]](x, y))

        if not result:
            result = [int(input[left:right])]
        lookup[left][right] = result
        return lookup[left][right]

    return diffWaysToComputeRecu(0, len(input))


class Solution(object):
    def digitsCount(self, d, low, high):

    def digitsCount(n, k):
        pivot, result = 1, 0
        while n >= pivot:
            result += (n // (10 * pivot)) * pivot + min(
                pivot, max(n % (10 * pivot) - k * pivot + 1, 0)
            )
            if k == 0:
                result -= pivot
            pivot *= 10
        return result + 1

    return digitsCount(high, d) - digitsCount(low - 1, d)


import heapq


class DinnerPlates(object):
    def __init__(self, capacity):

    self.__stks = []
    self.__c = capacity
    self.__min_heap = []

    def push(self, val):

    if self.__min_heap:
        l = heapq.heappop(self.__min_heap)
        if l < len(self.__stks):
            self.__stks[l].append(val)
            return
        self.__min_heap = []
    if not self.__stks or len(self.__stks[-1]) == self.__c:
        self.__stks.append([])
    self.__stks[-1].append(val)

    def pop(self):

    while self.__stks and not self.__stks[-1]:
        self.__stks.pop()
    if not self.__stks:
        return -1
    return self.__stks[-1].pop()

    def popAtStack(self, index):

    if index >= len(self.__stks) or not self.__stks[index]:
        return -1
    heapq.heappush(self.__min_heap, index)
    return self.__stks[index].pop()


import collections


class Solution(object):
    def displayTable(self, orders):

    table_count = collections.defaultdict(collections.Counter)
    for _, table, food in orders:
        table_count[int(table)][food] += 1
    foods = sorted({food for _, _, food in orders})
    result = [["Table"]]
    result[0].extend(foods)
    for table in sorted(table_count):
        result.append([str(table)])
        result[-1].extend(str(table_count[table][food]) for food in foods)
    return result


import itertools


class Solution(object):
    def distanceBetweenBusStops(self, distance, start, destination):

    if start > destination:
        start, destination = destination, start
    s_to_d = sum(itertools.islice(distance, start, destination))
    d_to_s = sum(itertools.islice(distance, 0, start)) + sum(
        itertools.islice(distance, destination, len(distance))
    )
    return min(s_to_d, d_to_s)


import collections


class Solution(object):
    def rearrangeBarcodes(self, barcodes):

    cnts = collections.Counter(barcodes)
    sorted_cnts = [[v, k] for k, v in cnts.iteritems()]
    sorted_cnts.sort(reverse=True)

    i = 0
    for v, k in sorted_cnts:
        for _ in xrange(v):
            barcodes[i] = k
            i += 2
            if i >= len(barcodes):
                i = 1
    return barcodes


class Solution(object):
    def distinctEchoSubstrings(self, text):

    def KMP(text, l, result):
        prefix = [-1] * (len(text) - l)
        j = -1
        for i in xrange(1, len(prefix)):
            while j > -1 and text[l + j + 1] != text[l + i]:
                j = prefix[j]
            if text[l + j + 1] == text[l + i]:
                j += 1
            prefix[i] = j
            if (
                (j + 1)
                and (i + 1) % ((i + 1) - (j + 1)) == 0
                and (i + 1) // ((i + 1) - (j + 1)) % 2 == 0
            ):
                result.add(text[l: l + i + 1])
        return (
            len(prefix) - (prefix[-1] + 1)
            if prefix[-1] + 1
            and len(prefix) % (len(prefix) - (prefix[-1] + 1)) == 0
            else float("inf")
        )

    result = set()
    i, l = 0, len(text) - 1
    while i < l:
        l = min(l, i + KMP(text, i, result))
        i += 1
    return len(result)


class Solution2(object):
    def distinctEchoSubstrings(self, text):

    result = set()
    for l in xrange(1, len(text) // 2 + 1):
        count = sum(text[i] == text[i + l] for i in xrange(l))
        for i in xrange(len(text) - 2 * l):
            if count == l:
                result.add(text[i: i + l])
            count += (text[i + l] == text[i + l + l]) - \
                (text[i] == text[i + l])
        if count == l:
            result.add(text[len(text) - 2 * l: len(text) - 2 * l + l])
    return len(result)


class Solution3(object):
    def distinctEchoSubstrings(self, text):

    MOD = 10 ** 9 + 7
    D = 27
    result = set()
    for i in xrange(len(text) - 1):
        left, right, pow_D = 0, 0, 1
        for l in xrange(1, min(i + 2, len(text) - i)):
            left = (D * left + (ord(text[i - l + 1]) - ord("a") + 1)) % MOD
            right = (pow_D * (ord(text[i + l]) - ord("a") + 1) + right) % MOD
            if left == right:
                result.add(left)
            pow_D = (pow_D * D) % MOD
    return len(result)


class Solution_TLE(object):
    def distinctEchoSubstrings(self, text):

    def compare(text, l, s1, s2):
        for i in xrange(l):
            if text[s1 + i] != text[s2 + i]:
                return False
        return True

    MOD = 10 ** 9 + 7
    D = 27
    result = set()
    for i in xrange(len(text)):
        left, right, pow_D = 0, 0, 1
        for l in xrange(1, min(i + 2, len(text) - i)):
            left = (D * left + (ord(text[i - l + 1]) - ord("a") + 1)) % MOD
            right = (pow_D * (ord(text[i + l]) - ord("a") + 1) + right) % MOD
            if left == right and compare(text, l, i - l + 1, i + 1):
                result.add(text[i + 1: i + 1 + l])
            pow_D = (pow_D * D) % MOD
    return len(result)


import collections


class Solution(object):
    def distinctSubseqII(self, S):

    M = 10 ** 9 + 7
    result, dp = 0, [0] * 26
    for c in S:
        result, dp[ord(c) - ord("a")] = (
            2 * result - dp[ord(c) - ord("a")] + 1,
            result + 1,
        )
    return result % M


class Solution(object):

    def numDistinct(self, S, T):
    ways = [0 for _ in xrange(len(T) + 1)]
    ways[0] = 1
    for S_char in S:
        for j, T_char in reversed(list(enumerate(T))):
            if S_char == T_char:
                ways[j + 1] += ways[j]
    return ways[len(T)]


class Solution(object):
    def distributeCandies(self, candies, num_people):

    p = int((2 * candies + 0.25) ** 0.5 - 0.5)
    remaining = candies - (p + 1) * p // 2
    rows, cols = divmod(p, num_people)

    result = [0] * num_people
    for i in xrange(num_people):
        result[i] = (
            (i + 1) * (rows + 1) + (rows * (rows + 1) // 2) * num_people
            if i < cols
            else (i + 1) * rows + ((rows - 1) * rows // 2) * num_people
        )
    result[cols] += remaining
    return result


class Solution2(object):
    def distributeCandies(self, candies, num_people):

    left, right = 1, candies
    while left <= right:
        mid = left + (right - left) // 2
        if not ((mid <= candies * 2 // (mid + 1))):
            right = mid - 1
        else:
            left = mid + 1
    p = right
    remaining = candies - (p + 1) * p // 2
    rows, cols = divmod(p, num_people)

    result = [0] * num_people
    for i in xrange(num_people):
        result[i] = (
            (i + 1) * (rows + 1) + (rows * (rows + 1) // 2) * num_people
            if i < cols
            else (i + 1) * rows + ((rows - 1) * rows // 2) * num_people
        )
    result[cols] += remaining
    return result


class Solution3(object):
    def distributeCandies(self, candies, num_people):

    result = [0] * num_people
    i = 0
    while candies != 0:
        result[i % num_people] += min(candies, i + 1)
        candies -= min(candies, i + 1)
        i += 1
    return result


class Solution(object):
    def distributeCandies(self, candies):

    lookup = set(candies)
    return min(len(lookup), len(candies) / 2)


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def distributeCoins(self, root):

    def dfs(root, result):
        if not root:
            return 0
        left, right = dfs(root.left, result), dfs(root.right, result)
        result[0] += abs(left) + abs(right)
        return root.val + left + right - 1

    result = [0]
    dfs(root, result)
    return result[0]


import collections
import random


class Solution(object):
    def canDistribute(self, nums, quantity):

    def nth_element(nums, n, compare=lambda a, b: a < b):
        def tri_partition(nums, left, right, target, compare):
            mid = left
            while mid <= right:
                if nums[mid] == target:
                    mid += 1
                elif compare(nums[mid], target):
                    nums[left], nums[mid] = nums[mid], nums[left]
                    left += 1
                    mid += 1
                else:
                    nums[mid], nums[right] = nums[right], nums[mid]
                    right -= 1
            return left, right

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            pivot_left, pivot_right = tri_partition(
                nums, left, right, nums[pivot_idx], compare
            )
            if pivot_left <= n <= pivot_right:
                return
            elif pivot_left > n:
                right = pivot_left - 1
            else:
                left = pivot_right + 1

    count = collections.Counter(nums)
    total = (1 << len(quantity)) - 1
    requirement = [0] * (total + 1)
    for mask in xrange(len(requirement)):
        base = 1
        for i in xrange(len(quantity)):
            if mask & base:
                requirement[mask] += quantity[i]
            base <<= 1
    dp = [[0] * (total + 1) for _ in xrange(2)]
    dp[0][0] = 1
    i = 0
    cnts = count.values()
    if len(quantity) < len(cnts):
        nth_element(cnts, len(quantity) - 1, lambda a, b: a > b)
        cnts = cnts[: len(quantity)]
    for cnt in cnts:
        dp[(i + 1) % 2] = [0] * (total + 1)

        for mask in reversed(xrange(total + 1)):
            dp[(i + 1) % 2][mask] |= dp[i % 2][mask]
            submask = mask
            while submask > 0:
                if requirement[submask] <= cnt and dp[i % 2][mask ^ submask]:
                    dp[(i + 1) % 2][mask] = 1
                submask = (submask - 1) & mask
        i += 1
    return dp[len(cnts) % 2][total]


import collections


class Solution(object):
    def isPossibleDivide(self, nums, k):

    count = collections.Counter(nums)
    for num in sorted(count.keys()):
        c = count[num]
        if not c:
            continue
        for i in xrange(num, num + k):
            if count[i] < c:
                return False
            count[i] -= c
    return True


class Solution(object):
    def canDivideIntoSubsequences(self, nums, K):

    curr, max_count = 1, 1
    for i in xrange(1, len(nums)):
        curr = 1 if nums[i - 1] < nums[i] else curr + 1
        max_count = max(max_count, curr)
    return K * max_count <= len(nums)


class Solution(object):
    def maximizeSweetness(self, sweetness, K):

    def check(sweetness, K, x):
        curr, cuts = 0, 0
        for s in sweetness:
            curr += s
            if curr >= x:
                cuts += 1
                curr = 0
        return cuts >= K + 1

    left, right = min(sweetness), sum(sweetness) // (K + 1)
    while left <= right:
        mid = left + (right - left) // 2
        if not check(sweetness, K, mid):
            right = mid - 1
        else:
            left = mid + 1
    return right


class Solution(object):
    def divide(self, dividend, divisor):

    result, dvd, dvs = 0, abs(dividend), abs(divisor)
    while dvd >= dvs:
        inc = dvs
        i = 0
        while dvd >= inc:
            dvd -= inc
            result += 1 << i
            inc <<= 1
            i += 1
    if dividend > 0 and divisor < 0 or dividend < 0 and divisor > 0:
        return -result
    else:
        return result

    def divide2(self, dividend, divisor):

    positive = (dividend < 0) is (divisor < 0)
    dividend, divisor = abs(dividend), abs(divisor)
    res = 0
    while dividend >= divisor:
        temp, i = divisor, 1
        while dividend >= temp:
            dividend -= temp
            res += i
            i <<= 1
            temp <<= 1
    if not positive:
        res = -res
    return min(max(-2147483648, res), 2147483647)


class Solution(object):
    def divisorGame(self, N):

    return N % 2 == 0


class Solution2(object):
    def divisorGame(self, N):

    def memoization(N, dp):
        if N == 1:
            return False
        if N not in dp:
            result = False
            for i in xrange(1, N + 1):
                if i * i > N:
                    break
                if N % i == 0:
                    if not memoization(N - i, dp):
                        result = True
                        break
            dp[N] = result
        return dp[N]

    return memoization(N, {})


import itertools


class Solution(object):
    def numTilings(self, N):

    M = int(1e9 + 7)

    def matrix_expo(A, K):
        result = [[int(i == j) for j in xrange(len(A))]
                  for i in xrange(len(A))]
        while K:
            if K % 2:
                result = matrix_mult(result, A)
            A = matrix_mult(A, A)
            K /= 2
        return result

    def matrix_mult(A, B):
        ZB = zip(*B)
        return [
            [sum(a * b for a, b in itertools.izip(row, col)) % M for col in ZB]
            for row in A
        ]

    T = [
        [1, 0, 0, 1],
        [1, 0, 1, 0],
        [1, 1, 0, 0],
        [1, 1, 1, 0],
    ]

    return matrix_mult([[1, 0, 0, 0]], matrix_expo(T, N))[0][
        0
    ]


class Solution2(object):
    def numTilings(self, N):

    M = int(1e9 + 7)
    dp = [1, 1, 2]
    for i in xrange(3, N + 1):
        dp[i % 3] = (2 * dp[(i - 1) % 3] % M + dp[(i - 3) % 3]) % M
    return dp[N % 3]


class SparseVector:
    def __init__(self, nums):

    self.lookup = {i: v for i, v in enumerate(nums) if v}

    def dotProduct(self, vec):

    if len(self.lookup) > len(vec.lookup):
        self, vec = vec, self
    return sum(
        v * vec.lookup[i] for i, v in self.lookup.iteritems() if i in vec.lookup
    )


import collections


class Solution(object):
    def predictPartyVictory(self, senate):

    n = len(senate)
    radiant, dire = collections.deque(), collections.deque()
    for i, c in enumerate(senate):
        if c == "R":
            radiant.append(i)
        else:
            dire.append(i)
    while radiant and dire:
        r_idx, d_idx = radiant.popleft(), dire.popleft()
        if r_idx < d_idx:
            radiant.append(r_idx + n)
        else:
            dire.append(d_idx + n)
    return "Radiant" if len(radiant) > len(dire) else "Dire"


class Solution(object):

    def calculateMinimumHP(self, dungeon):
    DP = [float("inf") for _ in dungeon[0]]
    DP[-1] = 1

    for i in reversed(xrange(len(dungeon))):
        DP[-1] = max(DP[-1] - dungeon[i][-1], 1)
        for j in reversed(xrange(len(dungeon[i]) - 1)):
            min_HP_on_exit = min(DP[j], DP[j + 1])
            DP[j] = max(min_HP_on_exit - dungeon[i][j], 1)

    return DP[0]


class Solution2(object):

    def calculateMinimumHP(self, dungeon):
    maximum_loses = 0
    for rooms in dungeon:
        for room in rooms:
            if room < 0:
                maximum_loses += abs(room)

    return self.binarySearch(dungeon, maximum_loses)

    def binarySearch(self, dungeon, maximum_loses):
    start, end = 1, maximum_loses + 1
    result = 0
    while start < end:
        mid = start + (end - start) / 2
        if self.DP(dungeon, mid):
            end = mid
        else:
            start = mid + 1
    return start

    def DP(self, dungeon, HP):
    remain_HP = [0 for _ in dungeon[0]]
    remain_HP[0] = HP + dungeon[0][0]
    for j in xrange(1, len(remain_HP)):
        if remain_HP[j - 1] > 0:
            remain_HP[j] = max(remain_HP[j - 1] + dungeon[0][j], 0)

    for i in xrange(1, len(dungeon)):
        if remain_HP[0] > 0:
            remain_HP[0] = max(remain_HP[0] + dungeon[i][0], 0)
        else:
            remain_HP[0] = 0

        for j in xrange(1, len(remain_HP)):
            remain = 0
            if remain_HP[j - 1] > 0:
                remain = max(remain_HP[j - 1] + dungeon[i][j], remain)
            if remain_HP[j] > 0:
                remain = max(remain_HP[j] + dungeon[i][j], remain)
            remain_HP[j] = remain

    return remain_HP[-1] > 0


class Solution(object):
    def duplicateZeros(self, arr):

    shift, i = 0, 0
    while i + shift < len(arr):
        shift += int(arr[i] == 0)
        i += 1
    i -= 1
    while shift:
        if i + shift < len(arr):
            arr[i + shift] = arr[i]
        if arr[i] == 0:
            shift -= 1
            arr[i + shift] = arr[i]
        i -= 1


class Solution(object):

    def minDistance(self, word1, word2):
    if len(word1) < len(word2):
        return self.minDistance(word2, word1)

    distance = [i for i in xrange(len(word2) + 1)]

    for i in xrange(1, len(word1) + 1):
        pre_distance_i_j = distance[0]
        distance[0] = i
        for j in xrange(1, len(word2) + 1):
            insert = distance[j - 1] + 1
            delete = distance[j] + 1
            replace = pre_distance_i_j
            if word1[i - 1] != word2[j - 1]:
                replace += 1
            pre_distance_i_j = distance[j]
            distance[j] = min(insert, delete, replace)

    return distance[-1]


class Solution2(object):

    def minDistance(self, word1, word2):
    distance = [[i] for i in xrange(len(word1) + 1)]
    distance[0] = [j for j in xrange(len(word2) + 1)]

    for i in xrange(1, len(word1) + 1):
        for j in xrange(1, len(word2) + 1):
            insert = distance[i][j - 1] + 1
            delete = distance[i - 1][j] + 1
            replace = distance[i - 1][j - 1]
            if word1[i - 1] != word2[j - 1]:
                replace += 1
            distance[i].append(min(insert, delete, replace))

    return distance[-1][-1]


import bisect


class Solution(object):
    def findSpecialInteger(self, arr):

    for x in [arr[len(arr) // 4], arr[len(arr) // 2], arr[len(arr) * 3 // 4]]:
        if (bisect.bisect_right(arr, x) - bisect.bisect_left(arr, x)) * 4 > len(
            arr
        ):
            return x
    return -1


class Solution(object):
    def lastRemaining(self, n):

    start, step, direction = 1, 2, 1
    while n > 1:
        start += direction * (step * (n / 2) - step / 2)
        n /= 2
        step *= 2
        direction *= -1
    return start


import heapq


class Interval(object):
    def __init__(self, s=0, e=0):
    self.start = s
    self.end = e


class Solution(object):
    def employeeFreeTime(self, schedule):

    result = []
    min_heap = [(emp[0].start, eid, 0) for eid, emp in enumerate(schedule)]
    heapq.heapify(min_heap)
    last_end = -1
    while min_heap:
        t, eid, i = heapq.heappop(min_heap)
        if 0 <= last_end < t:
            result.append(Interval(last_end, t))
        last_end = max(last_end, schedule[eid][i].end)
        if i + 1 < len(schedule[eid]):
            heapq.heappush(min_heap, (schedule[eid][i + 1].start, eid, i + 1))
    return result


import collections


class Solution(object):
    def getImportance(self, employees, id):

    if employees[id - 1] is None:
        return 0
    result = employees[id - 1].importance
    for id in employees[id - 1].subordinates:
        result += self.getImportance(employees, id)
    return result


class Solution2(object):
    def getImportance(self, employees, id):

    result, q = 0, collections.deque([id])
    while q:
        curr = q.popleft()
        employee = employees[curr - 1]
        result += employee.importance
        for id in employee.subordinates:
            q.append(id)
    return result


class Codec(object):
    def encode(self, strs):

    encoded_str = ""
    for s in strs:
        encoded_str += "%0*x" % (8, len(s)) + s
    return encoded_str

    def decode(self, s):

    i = 0
    strs = []
    while i < len(s):
        l = int(s[i: i + 8], 16)
        strs.append(s[i + 8: i + 8 + l])
        i += 8 + l
    return strs


import random


class Codec(object):
    def __init__(self):
    self.__random_length = 6
    self.__tiny_url = "http://tinyurl.com/"
    self.__alphabet = (
        "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    )
    self.__lookup = {}

    def encode(self, longUrl):

    def getRand():
        rand = []
        for _ in xrange(self.__random_length):
            rand += self.__alphabet[random.randint(0,
                                                   len(self.__alphabet) - 1)]
        return "".join(rand)

    key = getRand()
    while key in self.__lookup:
        key = getRand()
    self.__lookup[key] = longUrl
    return self.__tiny_url + key

    def decode(self, shortUrl):

    return self.__lookup[shortUrl[len(self.__tiny_url):]]


from hashlib import sha256


class Codec2(object):
    def __init__(self):
    self._cache = {}
    self.url = "http://tinyurl.com/"

    def encode(self, long_url):

    key = sha256(long_url.encode()).hexdigest()[:6]
    self._cache[key] = long_url
    return self.url + key

    def decode(self, short_url):

    key = short_url.replace(self.url, "")
    return self._cache[key]


class Node(object):
    def __init__(self, val, children):
    self.val = val
    self.children = children


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Codec(object):
    def encode(self, root):

    def encodeHelper(root, parent, index):
        if not root:
            return None
        node = TreeNode(root.val)
        if index + 1 < len(parent.children):
            node.left = encodeHelper(
                parent.children[index + 1], parent, index + 1)
        if root.children:
            node.right = encodeHelper(root.children[0], root, 0)
        return node

    if not root:
        return None
    node = TreeNode(root.val)
    if root.children:
        node.right = encodeHelper(root.children[0], root, 0)
    return node

    def decode(self, data):

    def decodeHelper(root, parent):
        if not root:
            return
        children = []
        node = Node(root.val, children)
        decodeHelper(root.right, node)
        parent.children.append(node)
        decodeHelper(root.left, parent)

    if not data:
        return None
    children = []
    node = Node(data.val, children)
    decodeHelper(data.right, node)
    return node


class Solution(object):
    def encode(self, num):

    result = []
    while num:
        result.append("0" if num % 2 else "1")
        num = (num - 1) // 2
    return "".join(reversed(result))


class Solution(object):
    def encode(self, s):

    def encode_substr(dp, s, i, j):
        temp = s[i: j + 1]
        pos = (temp + temp).find(temp, 1)
        if pos >= len(temp):
            return temp
        return str(len(temp) / pos) + "[" + dp[i][i + pos - 1] + "]"

    dp = [["" for _ in xrange(len(s))] for _ in xrange(len(s))]
    for length in xrange(1, len(s) + 1):
        for i in xrange(len(s) + 1 - length):
            j = i + length - 1
            dp[i][j] = s[i: i + length]
            for k in xrange(i, j):
                if len(dp[i][k]) + len(dp[k + 1][j]) < len(dp[i][j]):
                    dp[i][j] = dp[i][k] + dp[k + 1][j]
            encoded_string = encode_substr(dp, s, i, j)
            if len(encoded_string) < len(dp[i][j]):
                dp[i][j] = encoded_string
    return dp[0][len(s) - 1]


from fractions import Fraction


class Solution(object):
    def isRationalEqual(self, S, T):

    def frac(S):
        if "." not in S:
            return Fraction(int(S), 1)

        i = S.index(".")
        result = Fraction(int(S[:i]), 1)
        non_int_part = S[i + 1:]
        if "(" not in non_int_part:
            if non_int_part:
                result += Fraction(int(non_int_part), 10 ** len(non_int_part))
            return result

        i = non_int_part.index("(")
        if i:
            result += Fraction(int(non_int_part[:i]), 10 ** i)
        repeat_part = non_int_part[i + 1: -1]
        result += Fraction(int(repeat_part), 10 ** i *
                           (10 ** len(repeat_part) - 1))
        return result

    return frac(S) == frac(T)


import collections


class Solution(object):
    def minOperations(self, nums1, nums2):

    if len(nums1) * 6 < len(nums2) or len(nums1) > len(nums2) * 6:
        return -1
    diff = sum(nums2) - sum(nums1)
    if diff < 0:
        nums1, nums2 = nums2, nums1
        diff = -diff
    count = collections.Counter(6 - num for num in nums1)
    count += collections.Counter(num - 1 for num in nums2)
    result = 0
    for i in reversed(xrange(1, 6)):
        if not count[i]:
            continue
        cnt = min(count[i], (diff + i - 1) // i)
        result += cnt
        diff -= i * cnt
        if diff <= 0:
            break
    return result


import collections


class Solution(object):
    def checkEqualTree(self, root):

    def getSumHelper(node, lookup):
        if not node:
            return 0
        total = (
            node.val
            + getSumHelper(node.left, lookup)
            + getSumHelper(node.right, lookup)
        )
        lookup[total] += 1
        return total

    lookup = collections.defaultdict(int)
    total = getSumHelper(root, lookup)
    if total == 0:
        return lookup[total] > 1
    return total % 2 == 0 and (total / 2) in lookup


import itertools


class Solution(object):
    def outerTrees(self, points):

    def ccw(A, B, C):
        return (B[0] - A[0]) * (C[1] - A[1]) - (B[1] - A[1]) * (C[0] - A[0])

    if len(points) <= 1:
        return points

    hull = []
    points.sort()
    for i in itertools.chain(
        xrange(len(points)), reversed(xrange(len(points) - 1))
    ):
        while len(hull) >= 2 and ccw(hull[-2], hull[-1], points[i]) < 0:
            hull.pop()
        hull.append(points[i])
    hull.pop()

    for i in xrange(1, (len(hull) + 1) // 2):
        if hull[i] != hull[-1]:
            break
        hull.pop()
    return hull


import collections


class Solution(object):
    def isEscapePossible(self, blocked, source, target):

    R, C = 10 ** 6, 10 ** 6
    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

    def bfs(blocks, source, target):
        max_area_surrounded_by_blocks = len(blocks) * (len(blocks) - 1) // 2
        lookup = set([source])
        if len(lookup) > max_area_surrounded_by_blocks:
            return True
        q = collections.deque([source])
        while q:
            source = q.popleft()
            if source == target:
                return True
            for direction in directions:
                nr, nc = source[0] + direction[0], source[1] + direction[1]
                if not (
                    (0 <= nr < R)
                    and (0 <= nc < C)
                    and (nr, nc) not in lookup
                    and (nr, nc) not in blocks
                ):
                    continue
                lookup.add((nr, nc))
                if len(lookup) > max_area_surrounded_by_blocks:
                    return True
                q.append((nr, nc))
        return False

    return bfs(set(map(tuple, blocked)), tuple(source), tuple(target)) and bfs(
        set(map(tuple, blocked)), tuple(target), tuple(source)
    )


class Solution(object):
    def escapeGhosts(self, ghosts, target):

    total = abs(target[0]) + abs(target[1])
    return all(total < abs(target[0] - i) + abs(target[1] - j) for i, j in ghosts)


import collections
import itertools


class UnionFind(object):
    def __init__(self):
    self.set = {}
    self.rank = collections.Counter()

    def find_set(self, x):
    xp, xr = self.set.setdefault(x, (x, 1.0))
    if x != xp:
        pp, pr = self.find_set(xp)
        self.set[x] = (pp, xr * pr)
    return self.set[x]

    def union_set(self, x, y, r):
    (xp, xr), (yp, yr) = map(self.find_set, (x, y))
    if xp == yp:
        return False
    if self.rank[xp] < self.rank[yp]:

        self.set[xp] = (yp, r * yr / xr)
    elif self.rank[xp] > self.rank[yp]:

        self.set[yp] = (xp, 1.0 / r * xr / yr)
    else:

        self.set[yp] = (xp, 1.0 / r * xr / yr)
        self.rank[xp] += 1
    return True

    def query_set(self, x, y):
    if x not in self.set or y not in self.set:
        return -1.0
    (xp, xr), (yp, yr) = map(self.find_set, (x, y))
    return xr / yr if xp == yp else -1.0


class UnionFindPathCompressionOnly(object):
    def __init__(self):
    self.set = {}

    def find_set(self, x):
    xp, xr = self.set.setdefault(x, (x, 1.0))
    if x != xp:
        pp, pr = self.find_set(xp)
        self.set[x] = (pp, xr * pr)
    return self.set[x]

    def union_set(self, x, y, r):
    (xp, xr), (yp, yr) = map(self.find_set, (x, y))
    if xp == yp:
        return False

    self.set[xp] = (yp, r * yr / xr)
    return True

    def query_set(self, x, y):
    if x not in self.set or y not in self.set:
        return -1.0
    (xp, xr), (yp, yr) = map(self.find_set, (x, y))
    return xr / yr if xp == yp else -1.0


class Solution(object):
    def calcEquation(self, equations, values, queries):

    union_find = UnionFind()
    for (a, b), k in itertools.izip(equations, values):
        union_find.union_set(a, b, k)
    return [union_find.query_set(a, b) for a, b in queries]


import collections
import itertools


class Solution2(object):
    def calcEquation(self, equations, values, queries):

    adj = collections.defaultdict(dict)
    for (a, b), k in itertools.izip(equations, values):
        adj[a][b] = k
        adj[b][a] = 1.0 / k

    def bfs(adj, a, b, lookup):
        if a not in adj or b not in adj:
            return -1.0
        if (a, b) in lookup:
            return lookup[a, b]
        visited = {a}
        q = collections.deque([(a, 1.0)])
        while q:
            u, val = q.popleft()
            if u == b:
                lookup[a, b] = val
                return val
            for v, k in adj[u].iteritems():
                if v in visited:
                    continue
                visited.add(v)
                q.append((v, val * k))
        lookup[a, b] = -1.0
        return -1.0

    lookup = {}
    return [bfs(adj, a, b, lookup) for a, b in queries]


import collections
import itertools


class Solution3(object):
    def calcEquation(self, equations, values, queries):

    adj = collections.defaultdict(dict)
    for (a, b), k in itertools.izip(equations, values):
        adj[a][a] = adj[b][b] = 1.0
        adj[a][b] = k
        adj[b][a] = 1.0 / k
    for k in adj:
        for i in adj[k]:
            for j in adj[k]:
                adj[i][j] = adj[i][k] * adj[k][j]
    return [adj[a].get(b, -1.0) for a, b in queries]


import collections


class Solution4(object):
    def calcEquation(self, equations, values, query):

    def check(up, down, lookup, visited):
        if up in lookup and down in lookup[up]:
            return (True, lookup[up][down])
        for k, v in lookup[up].iteritems():
            if k not in visited:
                visited.add(k)
                tmp = check(k, down, lookup, visited)
                if tmp[0]:
                    return (True, v * tmp[1])
        return (False, 0)

    lookup = collections.defaultdict(dict)
    for i, e in enumerate(equations):
        lookup[e[0]][e[1]] = values[i]
        if values[i]:
            lookup[e[1]][e[0]] = 1.0 / values[i]

    result = []
    for q in query:
        visited = set()
        tmp = check(q[0], q[1], lookup, visited)
        result.append(tmp[1] if tmp[0] else -1)
    return result


import operator


class Solution(object):

    def evalRPN(self, tokens):
    numerals, operators = [], {
        "+": operator.add,
        "-": operator.sub,
        "*": operator.mul,
        "/": operator.div,
    }
    for token in tokens:
        if token not in operators:
            numerals.append(int(token))
        else:
            y, x = numerals.pop(), numerals.pop()
            numerals.append(int(operators[token](x * 1.0, y)))
    return numerals.pop()


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    self.val = val
    self.left = left
    self.right = right


class Solution(object):
    def isEvenOddTree(self, root):

    q = [root]
    is_odd = False
    while q:
        new_q = []
        prev = None
        for node in q:
            if is_odd:
                if node.val % 2 or (prev and prev.val <= node.val):
                    return False
            else:
                if not node.val % 2 or (prev and prev.val >= node.val):
                    return False
            if node.left:
                new_q.append(node.left)
            if node.right:
                new_q.append(node.right)
            prev = node
        q = new_q
        is_odd = not is_odd
    return True


import heapq


class ExamRoom(object):
    def __init__(self, N):

    self.__num = N
    self.__seats = {-1: [-1, self.__num], self.__num: [-1, self.__num]}
    self.__max_heap = [(-self.__distance((-1, self.__num)), -1, self.__num)]

    def seat(self):

    while (
        self.__max_heap[0][1] not in self.__seats
        or self.__max_heap[0][2] not in self.__seats
        or self.__seats[self.__max_heap[0][1]][1] != self.__max_heap[0][2]
        or self.__seats[self.__max_heap[0][2]][0] != self.__max_heap[0][1]
    ):
        heapq.heappop(self.__max_heap)

    _, left, right = heapq.heappop(self.__max_heap)
    mid = (
        0
        if left == -1
        else self.__num - 1
        if right == self.__num
        else (left + right) // 2
    )
    self.__seats[mid] = [left, right]
    heapq.heappush(self.__max_heap, (-self.__distance((left, mid)), left, mid))
    heapq.heappush(self.__max_heap,
                   (-self.__distance((mid, right)), mid, right))
    self.__seats[left][1] = mid
    self.__seats[right][0] = mid
    return mid

    def leave(self, p):

    left, right = self.__seats[p]
    self.__seats.pop(p)
    self.__seats[left][1] = right
    self.__seats[right][0] = left
    heapq.heappush(self.__max_heap,
                   (-self.__distance((left, right)), left, right))

    def __distance(self, segment):
    return (
        segment[1] - segment[0] - 1
        if segment[0] == -1 or segment[1] == self.__num
        else (segment[1] - segment[0]) // 2
    )


class Solution(object):
    def titleToNumber(self, s):

    result = 0
    for i in xrange(len(s)):
        result *= 26
        result += ord(s[i]) - ord("A") + 1
    return result


class Solution(object):
    def convertToTitle(self, n):

    result, dvd = "", n

    while dvd:
        result += chr((dvd - 1) % 26 + ord("A"))
        dvd = (dvd - 1) / 26

    return result[::-1]


class Solution(object):
    def exclusiveTime(self, n, logs):

    result = [0] * n
    stk, prev = [], 0
    for log in logs:
        tokens = log.split(":")
        if tokens[1] == "start":
            if stk:
                result[stk[-1]] += int(tokens[2]) - prev
            stk.append(int(tokens[0]))
            prev = int(tokens[2])
        else:
            result[stk.pop()] += int(tokens[2]) - prev + 1
            prev = int(tokens[2]) + 1
    return result


class Solution(object):
    def addOperators(self, num, target):

    result, expr = [], []
    val, i = 0, 0
    val_str = ""
    while i < len(num):
        val = val * 10 + ord(num[i]) - ord("0")
        val_str += num[i]

        if str(val) != val_str:
            break
        expr.append(val_str)
        self.addOperatorsDFS(num, target, i + 1, 0, val, expr, result)
        expr.pop()
        i += 1
    return result

    def addOperatorsDFS(self, num, target, pos, operand1, operand2, expr, result):
    if pos == len(num) and operand1 + operand2 == target:
        result.append("".join(expr))
    else:
        val, i = 0, pos
        val_str = ""
        while i < len(num):
            val = val * 10 + ord(num[i]) - ord("0")
            val_str += num[i]

            if str(val) != val_str:
                break

            expr.append("+" + val_str)
            self.addOperatorsDFS(
                num, target, i + 1, operand1 + operand2, val, expr, result
            )
            expr.pop()

            expr.append("-" + val_str)
            self.addOperatorsDFS(
                num, target, i + 1, operand1 + operand2, -val, expr, result
            )
            expr.pop()

            expr.append("*" + val_str)
            self.addOperatorsDFS(
                num, target, i + 1, operand1, operand2 * val, expr, result
            )
            expr.pop()

            i += 1


import itertools


class Solution(object):
    def expressiveWords(self, S, words):

    def RLE(S):
        return itertools.izip(
            *[(k, len(list(grp))) for k, grp in itertools.groupby(S)]
        )

    R, count = RLE(S)
    result = 0
    for word in words:
        R2, count2 = RLE(word)
        if R2 != R:
            continue
        result += all(
            c1 >= max(c2, 3) or c1 == c2 for c1, c2 in itertools.izip(count, count2)
        )
    return result


class Solution(object):

    def getFactors(self, n):
    result = []
    factors = []
    self.getResult(n, result, factors)
    return result

    def getResult(self, n, result, factors):
    i = 2 if not factors else factors[-1]
    while i <= n / i:
        if n % i == 0:
            factors.append(i)
            factors.append(n / i)
            result.append(list(factors))
            factors.pop()
            self.getResult(n / i, result, factors)
            factors.pop()
        i += 1


class Solution(object):

    def trailingZeroes(self, n):
    result = 0
    while n > 0:
        result += n / 5
        n /= 5
    return result


class Solution(object):
    def fairCandySwap(self, A, B):

    diff = (sum(A) - sum(B)) // 2
    setA = set(A)
    for b in set(B):
        if diff + b in setA:
            return [diff + b, b]
    return []


import bisect


class Solution(object):
    def fallingSquares(self, positions):
    result = []
    pos = [-1]
    heights = [0]
    maxH = 0
    for left, side in positions:
        l = bisect.bisect_right(pos, left)
        r = bisect.bisect_left(pos, left + side)
        high = max(heights[l - 1: r] or [0]) + side
        pos[l:r] = [left, left + side]
        heights[l:r] = [high, heights[r - 1]]
        maxH = max(maxH, high)
        result.append(maxH)
    return result


class SegmentTree(object):
    def __init__(
        self, N, query_fn=min, update_fn=lambda x, y: y, default_val=float("inf")
    ):
    self.N = N
    self.H = (N - 1).bit_length()
    self.query_fn = query_fn
    self.update_fn = update_fn
    self.default_val = default_val
    self.tree = [default_val] * (2 * N)
    self.lazy = [None] * N

    def __apply(self, x, val):
    self.tree[x] = self.update_fn(self.tree[x], val)
    if x < self.N:
        self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h):

    def pull(x):
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(
                self.tree[x * 2], self.tree[x * 2 + 1])
            if self.lazy[x] is not None:
                self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

    L += self.N
    R += self.N
    L0, R0 = L, R
    while L <= R:
        if L & 1:
            self.__apply(L, h)
            L += 1
        if R & 1 == 0:
            self.__apply(R, h)
            R -= 1
        L //= 2
        R //= 2
    pull(L0)
    pull(R0)

    def query(self, L, R):

    def push(x):
        n = 2 ** self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y * 2, self.lazy[y])
                self.__apply(y * 2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    result = self.default_val
    if L > R:
        return result

    L += self.N
    R += self.N
    push(L)
    push(R)
    while L <= R:
        if L & 1:
            result = self.query_fn(result, self.tree[L])
            L += 1
        if R & 1 == 0:
            result = self.query_fn(result, self.tree[R])
            R -= 1
        L //= 2
        R //= 2
    return result

    def data(self):
    showList = []
    for i in xrange(self.N):
        showList.append(self.query(i, i))
    return showList


class SegmentTree2(object):
    def __init__(
        self, nums, query_fn=min, update_fn=lambda x, y: y, default_val=float("inf")
    ):

    N = len(nums)
    self.__original_length = N
    self.__tree_length = 2 ** (N.bit_length() + (N & (N - 1) != 0)) - 1
    self.__query_fn = query_fn
    self.__update_fn = update_fn
    self.__default_val = default_val
    self.__tree = [default_val for _ in range(self.__tree_length)]
    self.__lazy = [None for _ in range(self.__tree_length)]
    self.__constructTree(nums, 0, self.__original_length - 1, 0)

    def update(self, i, j, val):
    self.__updateTree(val, i, j, 0, self.__original_length - 1, 0)

    def query(self, i, j):
    return self.__queryRange(i, j, 0, self.__original_length - 1, 0)

    def __constructTree(self, nums, left, right, idx):
    if left > right:
        return
    if left == right:
        self.__tree[idx] = self.__update_fn(self.__tree[idx], nums[left])
        return
    mid = left + (right - left) // 2
    self.__constructTree(nums, left, mid, idx * 2 + 1)
    self.__constructTree(nums, mid + 1, right, idx * 2 + 2)
    self.__tree[idx] = self.__query_fn(
        self.__tree[idx * 2 + 1], self.__tree[idx * 2 + 2]
    )

    def __apply(self, left, right, idx, val):
    self.__tree[idx] = self.__update_fn(self.__tree[idx], val)
    if left != right:
        self.__lazy[idx * 2 +
                    1] = self.__update_fn(self.__lazy[idx * 2 + 1], val)
        self.__lazy[idx * 2 +
                    2] = self.__update_fn(self.__lazy[idx * 2 + 2], val)

    def __updateTree(self, val, range_left, range_right, left, right, idx):
    if left > right:
        return
    if self.__lazy[idx] is not None:
        self.__apply(left, right, idx, self.__lazy[idx])
        self.__lazy[idx] = None
    if range_left > right or range_right < left:
        return
    if range_left <= left and right <= range_right:
        self.__apply(left, right, idx, val)
        return
    mid = left + (right - left) // 2
    self.__updateTree(val, range_left, range_right, left, mid, idx * 2 + 1)
    self.__updateTree(val, range_left, range_right,
                      mid + 1, right, idx * 2 + 2)
    self.__tree[idx] = self.__query_fn(
        self.__tree[idx * 2 + 1], self.__tree[idx * 2 + 2]
    )

    def __queryRange(self, range_left, range_right, left, right, idx):
    if left > right:
        return self.__default_val
    if self.__lazy[idx] is not None:
        self.__apply(left, right, idx, self.__lazy[idx])
        self.__lazy[idx] = None
    if right < range_left or left > range_right:
        return self.__default_val
    if range_left <= left and right <= range_right:
        return self.__tree[idx]
    mid = left + (right - left) // 2
    return self.__query_fn(
        self.__queryRange(range_left, range_right, left, mid, idx * 2 + 1),
        self.__queryRange(range_left, range_right,
                          mid + 1, right, idx * 2 + 2),
    )


class Solution2(object):
    def fallingSquares(self, positions):
    index = set()
    for left, size in positions:
        index.add(left)
        index.add(left + size - 1)
    index = sorted(list(index))
    tree = SegmentTree(len(index), max, max, 0)

    max_height = 0
    result = []
    for left, size in positions:
        L, R = bisect.bisect_left(index, left), bisect.bisect_left(
            index, left + size - 1
        )
        h = tree.query(L, R) + size
        tree.update(L, R, h)
        max_height = max(max_height, h)
        result.append(max_height)
    return result


class Solution3(object):
    def fallingSquares(self, positions):

    def query(heights, left, right, B, blocks, blocks_read):
        result = 0
        while left % B and left <= right:
            result = max(result, heights[left], blocks[left // B])
            left += 1
        while right % B != B - 1 and left <= right:
            result = max(result, heights[right], blocks[right // B])
            right -= 1
        while left <= right:
            result = max(result, blocks[left // B], blocks_read[left // B])
            left += B
        return result

    def update(heights, left, right, B, blocks, blocks_read, h):
        while left % B and left <= right:
            heights[left] = max(heights[left], h)
            blocks_read[left // B] = max(blocks_read[left // B], h)
            left += 1
        while right % B != B - 1 and left <= right:
            heights[right] = max(heights[right], h)
            blocks_read[right // B] = max(blocks_read[right // B], h)
            right -= 1
        while left <= right:
            blocks[left // B] = max(blocks[left // B], h)
            left += B

    index = set()
    for left, size in positions:
        index.add(left)
        index.add(left + size - 1)
    index = sorted(list(index))
    W = len(index)
    B = int(W ** 0.5)
    heights = [0] * W
    blocks = [0] * (B + 2)
    blocks_read = [0] * (B + 2)

    max_height = 0
    result = []
    for left, size in positions:
        L, R = bisect.bisect_left(index, left), bisect.bisect_left(
            index, left + size - 1
        )
        h = query(heights, L, R, B, blocks, blocks_read) + size
        update(heights, L, R, B, blocks, blocks_read, h)
        max_height = max(max_height, h)
        result.append(max_height)
    return result


class Solution4(object):
    def fallingSquares(self, positions):

    heights = [0] * len(positions)
    for i in xrange(len(positions)):
        left_i, size_i = positions[i]
        right_i = left_i + size_i
        heights[i] += size_i
        for j in xrange(i + 1, len(positions)):
            left_j, size_j = positions[j]
            right_j = left_j + size_j
            if left_j < right_i and left_i < right_j:
                heights[j] = max(heights[j], heights[i])

    result = []
    for height in heights:
        result.append(max(result[-1], height) if result else height)
    return result


MOD = 10 ** 9 + 7


class Fancy(object):
    def __init__(self):
    self.__arr = []
    self.__ops = [[1, 0]]

    def append(self, val):

    self.__arr.append(val)
    self.__ops.append(self.__ops[-1][:])

    def addAll(self, inc):

    self.__ops[-1][1] = (self.__ops[-1][1] + inc) % MOD

    def multAll(self, m):

    self.__ops[-1] = [(self.__ops[-1][0] * m) %
                      MOD, (self.__ops[-1][1] * m) % MOD]

    def getIndex(self, idx):

    if idx >= len(self.__arr):
        return -1
    a1, b1 = self.__ops[idx]
    a2, b2 = self.__ops[-1]
    a = a2 * pow(a1, MOD - 2, MOD) % MOD
    b = (b2 - b1 * a) % MOD
    return (self.__arr[idx] * a + b) % MOD


class Fancy2(object):
    def __init__(self):
    self.__arr = []
    self.__op = [1, 0]

    def append(self, val):

    self.__arr.append(
        (val - self.__op[1]) * pow(self.__op[0], MOD - 2, MOD) % MOD
    )

    def addAll(self, inc):

    self.__op[1] = (self.__op[1] + inc) % MOD

    def multAll(self, m):

    self.__op = [(self.__op[0] * m) % MOD, (self.__op[1] * m) % MOD]

    def getIndex(self, idx):

    if idx >= len(self.__arr):
        return -1
    a, b = self.__op
    return (self.__arr[idx] * a + b) % MOD


import itertools


class Solution(object):
    def fib(self, N):

    def matrix_expo(A, K):
        result = [[int(i == j) for j in xrange(len(A))]
                  for i in xrange(len(A))]
        while K:
            if K % 2:
                result = matrix_mult(result, A)
            A = matrix_mult(A, A)
            K /= 2
        return result

    def matrix_mult(A, B):
        ZB = zip(*B)
        return [
            [sum(a * b for a, b in itertools.izip(row, col)) for col in ZB]
            for row in A
        ]

    T = [[1, 1], [1, 0]]
    return matrix_mult([[1, 0]], matrix_expo(T, N))[0][1]


class Solution2(object):
    def fib(self, N):

    prev, current = 0, 1
    for i in xrange(N):
        prev, current = (
            current,
            prev + current,
        )
    return prev


class Solution(object):
    def minHeightShelves(self, books, shelf_width):

    dp = [float("inf") for _ in xrange(len(books) + 1)]
    dp[0] = 0
    for i in xrange(1, len(books) + 1):
        max_width = shelf_width
        max_height = 0
        for j in reversed(xrange(i)):
            if max_width - books[j][0] < 0:
                break
            max_width -= books[j][0]
            max_height = max(max_height, books[j][1])
            dp[i] = min(dp[i], dp[j] + max_height)
    return dp[len(books)]


class Solution(object):
    def filterRestaurants(self, restaurants, veganFriendly, maxPrice, maxDistance):

    result, lookup = [], {}
    for j, (i, _, v, p, d) in enumerate(restaurants):
        if v >= veganFriendly and p <= maxPrice and d <= maxDistance:
            lookup[i] = j
            result.append(i)
    result.sort(
        key=lambda i: (-restaurants[lookup[i]][1], -restaurants[lookup[i]][0])
    )
    return result


class Solution(object):
    def finalPrices(self, prices):

    stk = []
    for i, p in enumerate(prices):
        while stk and prices[stk[-1]] >= p:
            prices[stk.pop()] -= p
        stk.append(i)
    return prices


import itertools


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def getTargetCopy(self, original, cloned, target):

    def preorder_gen(node):
        stk = [node]
        while stk:
            node = stk.pop()
            if not node:
                continue
            yield node
            stk.append(node.right)
            stk.append(node.left)

    for node1, node2 in itertools.izip(
        preorder_gen(original), preorder_gen(cloned)
    ):
        if node1 == target:
            return node2


class BitCount(object):
    def __init__(self, n):
    self.__l = 0
    self.__n = n
    self.__count = [0] * n

    def __iadd__(self, num):
    self.__l += 1
    base = 1
    for i in xrange(self.__n):
        if num & base:
            self.__count[i] += 1
        base <<= 1
    return self

    def __isub__(self, num):
    self.__l -= 1
    base = 1
    for i in xrange(self.__n):
        if num & base:
            self.__count[i] -= 1
        base <<= 1
    return self

    def bit_and(self):
    num, base = 0, 1
    for i in xrange(self.__n):
        if self.__count[i] == self.__l:
            num |= base
        base <<= 1
    return num


class Solution(object):
    def closestToTarget(self, arr, target):

    count = BitCount(max(arr).bit_length())
    result, left = float("inf"), 0
    for right in xrange(len(arr)):
        count += arr[right]
        while left <= right:
            f = count.bit_and()
            result = min(result, abs(f - target))
            if f >= target:
                break
            count -= arr[left]
            left += 1
    return result


class Solution2(object):
    def closestToTarget(self, arr, target):

    result, dp = float("inf"), set()
    for x in arr:
        dp = {x} | {f & x for f in dp}
        for f in dp:
            result = min(result, abs(f - target))
    return result


class Solution(object):
    def findAnagrams(self, s, p):

    result = []

    cnts = [0] * 26
    for c in p:
        cnts[ord(c) - ord("a")] += 1

    left, right = 0, 0
    while right < len(s):
        cnts[ord(s[right]) - ord("a")] -= 1
        while left <= right and cnts[ord(s[right]) - ord("a")] < 0:
            cnts[ord(s[left]) - ord("a")] += 1
            left += 1
        if right - left + 1 == len(p):
            result.append(left)
        right += 1

    return result


class Solution(object):
    def findDuplicates(self, nums):

    result = []
    for i in nums:
        if nums[abs(i) - 1] < 0:
            result.append(abs(i))
        else:
            nums[abs(i) - 1] *= -1
    return result


class Solution2(object):
    def findDuplicates(self, nums):

    result = []
    i = 0
    while i < len(nums):
        if nums[i] != nums[nums[i] - 1]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
        else:
            i += 1

    for i in xrange(len(nums)):
        if i != nums[i] - 1:
            result.append(nums[i])
    return result


from collections import Counter


class Solution3(object):
    def findDuplicates(self, nums):

    return [elem for elem, count in Counter(nums).items() if count == 2]


class Solution(object):
    def findGoodStrings(self, n, s1, s2, evil):

    MOD = 10 ** 9 + 7

    def getPrefix(pattern):
        prefix = [-1] * len(pattern)
        j = -1
        for i in xrange(1, len(pattern)):
            while j != -1 and pattern[j + 1] != pattern[i]:
                j = prefix[j]
            if pattern[j + 1] == pattern[i]:
                j += 1
            prefix[i] = j
        return prefix

    prefix = getPrefix(evil)
    dp = [
        [[[0] * len(evil) for _ in xrange(2)] for _ in xrange(2)] for _ in xrange(2)
    ]
    dp[0][0][0][0] = 1
    for i in xrange(n):
        dp[(i + 1) % 2] = [[[0] * len(evil)
                            for _ in xrange(2)] for _ in xrange(2)]
        for j in xrange(2):
            for k in xrange(2):
                min_c = "a" if j else s1[i]
                max_c = "z" if k else s2[i]
                for l in xrange(len(evil)):
                    if not dp[i % 2][j][k][l]:
                        continue
                    for c in xrange(
                        ord(min_c) - ord("a"), ord(max_c) - ord("a") + 1
                    ):
                        c = chr(c + ord("a"))
                        m = l - 1
                        while m != -1 and evil[m + 1] != c:
                            m = prefix[m]
                        if evil[m + 1] == c:
                            m += 1
                        if m + 1 == len(evil):
                            continue
                        dp[(i + 1) % 2][j or (s1[i] != c)][k or (s2[i] != c)][
                            m + 1
                        ] = (
                            dp[(i + 1) % 2][j or (s1[i] != c)][k or (s2[i] != c)][
                                m + 1
                            ]
                            + dp[i % 2][j][k][l]
                        ) % MOD
    result = 0
    for j in xrange(2):
        for k in xrange(2):
            for l in xrange(len(evil)):
                result = (result + dp[n % 2][j][k][l]) % MOD
    return result


class Solution(object):
    def findDisappearedNumbers(self, nums):

    for i in xrange(len(nums)):
        if nums[abs(nums[i]) - 1] > 0:
            nums[abs(nums[i]) - 1] *= -1

    result = []
    for i in xrange(len(nums)):
        if nums[i] > 0:
            result.append(i + 1)
        else:
            nums[i] *= -1
    return result

    def findDisappearedNumbers2(self, nums):

    return list(set(range(1, len(nums) + 1)) - set(nums))

    def findDisappearedNumbers3(self, nums):
    for i in range(len(nums)):
        index = abs(nums[i]) - 1
        nums[index] = -abs(nums[index])

    return [i + 1 for i in range(len(nums)) if nums[i] > 0]


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    self.val = val
    self.left = left
    self.right = right


class Solution(object):
    def getLonelyNodes(self, root):

    result = []
    stk = [root]
    while stk:
        node = stk.pop()
        if not node:
            continue
        if node.left and not node.right:
            result.append(node.left.val)
        elif node.right and not node.left:
            result.append(node.right.val)
        stk.append(node.right)
        stk.append(node.left)
    return result


class Solution2(object):
    def getLonelyNodes(self, root):

    def dfs(node, result):
        if not node:
            return
        if node.left and not node.right:
            result.append(node.left.val)
        elif node.right and not node.left:
            result.append(node.right.val)
        dfs(node.left, result)
        dfs(node.right, result)

    result = []
    dfs(root, result)
    return result


import collections


class Solution(object):
    def anagramMappings(self, A, B):

    lookup = collections.defaultdict(collections.deque)
    for i, n in enumerate(B):
        lookup[n].append(i)
    result = []
    for n in A:
        result.append(lookup[n].popleft())
    return result


class Solution(object):
    def findReplaceString(self, S, indexes, sources, targets):

    bucket = [None] * len(S)
    for i in xrange(len(indexes)):
        if all(
            indexes[i] + k < len(S) and S[indexes[i] + k] == sources[i][k]
            for k in xrange(len(sources[i]))
        ):
            bucket[indexes[i]] = (len(sources[i]), list(targets[i]))
    result = []
    i = 0
    while i < len(S):
        if bucket[i]:
            result.extend(bucket[i][1])
            i += bucket[i][0]
        else:
            result.append(S[i])
            i += 1
    return "".join(result)


class Solution2(object):
    def findReplaceString(self, S, indexes, sources, targets):

    for i, s, t in sorted(zip(indexes, sources, targets), reverse=True):
        if S[i: i + len(s)] == s:
            S = S[:i] + t + S[i + len(s):]

    return S


import itertools


class Solution(object):
    def findAndReplacePattern(self, words, pattern):

    def match(word):
        lookup = {}
        for x, y in itertools.izip(pattern, word):
            if lookup.setdefault(x, y) != y:
                return False
        return len(set(lookup.values())) == len(lookup.values())

    return filter(match, words)


class Solution(object):
    def findBottomLeftValue(self, root):

    def findBottomLeftValueHelper(root, curr_depth, max_depth, bottom_left_value):
        if not root:
            return max_depth, bottom_left_value
        if not root.left and not root.right and curr_depth + 1 > max_depth:
            return curr_depth + 1, root.val
        max_depth, bottom_left_value = findBottomLeftValueHelper(
            root.left, curr_depth + 1, max_depth, bottom_left_value
        )
        max_depth, bottom_left_value = findBottomLeftValueHelper(
            root.right, curr_depth + 1, max_depth, bottom_left_value
        )
        return max_depth, bottom_left_value

    result, max_depth = 0, 0
    return findBottomLeftValueHelper(root, 0, max_depth, result)[1]


class Solution2(object):
    def findBottomLeftValue(self, root):

    last_node, queue = None, [root]
    while queue:
        last_node = queue.pop(0)
        queue.extend([n for n in [last_node.right, last_node.left] if n])
    return last_node.value


class Solution(object):
    def findCenter(self, edges):

    return edges[0][edges[0][1] in edges[1]]


import collections


class Solution(object):
    def commonChars(self, A):

    result = collections.Counter(A[0])
    for a in A:
        result &= collections.Counter(a)
    return list(result.elements())


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.count = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[max(x_root, y_root)] = min(x_root, y_root)
    self.count -= 1
    return True


class Solution(object):
    def findCriticalAndPseudoCriticalEdges(self, n, edges):

    def MST(n, edges, unused=None, used=None):
        union_find = UnionFind(n)
        weight = 0
        if used is not None:
            u, v, w, _ = edges[used]
            if union_find.union_set(u, v):
                weight += w
        for i, (u, v, w, _) in enumerate(edges):
            if i == unused:
                continue
            if union_find.union_set(u, v):
                weight += w
        return weight if union_find.count == 1 else float("inf")

    for i, edge in enumerate(edges):
        edge.append(i)
    edges.sort(key=lambda x: x[2])
    mst = MST(n, edges)
    result = [[], []]
    for i, edge in enumerate(edges):
        if mst < MST(n, edges, unused=i):
            result[0].append(edge[3])
        elif mst == MST(n, edges, used=i):
            result[1].append(edge[3])
    return result


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    pass


class Solution(object):
    def findDistance(self, root, p, q):

    def iter_dfs(root, p, q):
        result = 0
        dist = [-1]
        stk = [(1, [root, dist])]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, ret = params
                if not node:
                    continue
                ret1, ret2 = [-1], [-1]
                stk.append((2, [node, ret1, ret2, ret]))
                stk.append((1, [node.right, ret2]))
                stk.append((1, [node.left, ret1]))
            elif step == 2:
                node, ret1, ret2, ret = params
                if node.val in (p, q):
                    if ret1[0] == ret2[0] == -1:
                        ret[0] = 0
                    else:
                        result = ret1[0] + 1 if ret1[0] != -1 else ret2[0] + 1
                elif ret1[0] != -1 and ret2[0] != -1:
                    result = ret1[0] + ret2[0] + 2
                elif ret1[0] != -1:
                    ret[0] = ret1[0] + 1
                elif ret2[0] != -1:
                    ret[0] = ret2[0] + 1
        return result

    return iter_dfs(root, p, q)


class Solution2(object):
    def findDistance(self, root, p, q):

    def dfs(node, p, q, result):
        if not node:
            return -1
        left = dfs(node.left, p, q, result)
        right = dfs(node.right, p, q, result)
        if node.val in (p, q):
            if left == right == -1:
                return 0
            result[0] = left + 1 if left != -1 else right + 1
        if left != -1 and right != -1:
            result[0] = left + right + 2
        elif left != -1:
            return left + 1
        elif right != -1:
            return right + 1
        return -1

    result = [0]
    dfs(root, p, q, result)
    return result[0]


import collections


class Solution(object):
    def findDuplicate(self, paths):

    files = collections.defaultdict(list)
    for path in paths:
        s = path.split(" ")
        for i in xrange(1, len(s)):
            file_name = s[0] + "/" + s[i][0: s[i].find("(")]
            file_content = s[i][s[i].find("(") + 1: s[i].find(")")]
            files[file_content].append(file_name)

    result = []
    for file_content, file_names in files.iteritems():
        if len(file_names) > 1:
            result.append(file_names)
    return result


import collections


class Solution(object):
    def findDuplicateSubtrees(self, root):

    def getid(root, lookup, trees):
        if root:
            node_id = lookup[
                root.val,
                getid(root.left, lookup, trees),
                getid(root.right, lookup, trees),
            ]
            trees[node_id].append(root)
            return node_id

    trees = collections.defaultdict(list)
    lookup = collections.defaultdict()
    lookup.default_factory = lookup.__len__
    getid(root, lookup, trees)
    return [roots[0] for roots in trees.values() if len(roots) > 1]


class Solution2(object):
    def findDuplicateSubtrees(self, root):

    def postOrderTraversal(node, lookup, result):
        if not node:
            return ""
        s = (
            "("
            + postOrderTraversal(node.left, lookup, result)
            + str(node.val)
            + postOrderTraversal(node.right, lookup, result)
            + ")"
        )
        if lookup[s] == 1:
            result.append(node)
        lookup[s] += 1
        return s

    lookup = collections.defaultdict(int)
    result = []
    postOrderTraversal(root, lookup, result)
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class FindElements(object):
    def __init__(self, root):

    def dfs(node, v, lookup):
        if not node:
            return
        node.val = v
        lookup.add(v)
        dfs(node.left, 2 * v + 1, lookup)
        dfs(node.right, 2 * v + 2, lookup)

    self.__lookup = set()
    dfs(root, 0, self.__lookup)

    def find(self, target):

    return target in self.__lookup


import collections


class Solution(object):
    def eventualSafeNodes(self, graph):

    WHITE, GRAY, BLACK = 0, 1, 2

    def dfs(graph, node, lookup):
        if lookup[node] != WHITE:
            return lookup[node] == BLACK
        lookup[node] = GRAY
        for child in graph[node]:
            if lookup[child] == BLACK:
                continue
            if lookup[child] == GRAY or not dfs(graph, child, lookup):
                return False
        lookup[node] = BLACK
        return True

    lookup = collections.defaultdict(int)
    return filter(lambda node: dfs(graph, node, lookup), xrange(len(graph)))


class MountainArray(object):
    def get(self, index):

    pass

    def length(self):

    pass


class Solution(object):
    def findInMountainArray(self, target, mountain_arr):

    def binarySearch(A, left, right, check):
        while left <= right:
            mid = left + (right - left) // 2
            if check(mid):
                right = mid - 1
            else:
                left = mid + 1
        return left

    peak = binarySearch(
        mountain_arr,
        0,
        mountain_arr.length() - 1,
        lambda x: mountain_arr.get(x) >= mountain_arr.get(x + 1),
    )
    left = binarySearch(
        mountain_arr, 0, peak, lambda x: mountain_arr.get(x) >= target
    )
    if left <= peak and mountain_arr.get(left) == target:
        return left
    right = binarySearch(
        mountain_arr,
        peak,
        mountain_arr.length() - 1,
        lambda x: mountain_arr.get(x) <= target,
    )
    if right <= mountain_arr.length() - 1 and mountain_arr.get(right) == target:
        return right
    return -1


import bisect


class Solution(object):
    def findClosestElements(self, arr, k, x):

    i = bisect.bisect_left(arr, x)
    left, right = i - 1, i
    while k:
        if right >= len(arr) or (
            left >= 0 and abs(arr[left] - x) <= abs(arr[right] - x)
        ):
            left -= 1
        else:
            right += 1
        k -= 1
    return arr[left + 1: right]


class Solution(object):
    def numKLenSubstrNoRepeats(self, S, K):

    result, i = 0, 0
    lookup = set()
    for j in xrange(len(S)):
        while S[j] in lookup:
            lookup.remove(S[i])
            i += 1
        lookup.add(S[j])
        result += j - i + 1 >= K
    return result


from heapq import heappush, heappop


class Solution(object):
    def kSmallestPairs(self, nums1, nums2, k):

    pairs = []
    if len(nums1) > len(nums2):
        tmp = self.kSmallestPairs(nums2, nums1, k)
        for pair in tmp:
            pairs.append([pair[1], pair[0]])
        return pairs

    min_heap = []

    def push(i, j):
        if i < len(nums1) and j < len(nums2):
            heappush(min_heap, [nums1[i] + nums2[j], i, j])

    push(0, 0)
    while min_heap and len(pairs) < k:
        _, i, j = heappop(min_heap)
        pairs.append([nums1[i], nums2[j]])
        push(i, j + 1)
        if j == 0:
            push(i + 1, 0)
    return pairs


from heapq import nsmallest
from itertools import product


class Solution2(object):
    def kSmallestPairs(self, nums1, nums2, k):

    return nsmallest(k, product(nums1, nums2), key=sum)


class Solution(object):
    def smallestDistancePair(self, nums, k):

    def possible(guess, nums, k):
        count, left = 0, 0
        for right, num in enumerate(nums):
            while num - nums[left] > guess:
                left += 1
            count += right - left
        return count >= k

    nums.sort()
    left, right = 0, nums[-1] - nums[0] + 1
    while left < right:
        mid = left + (right - left) / 2
        if possible(mid, nums, k):
            right = mid
        else:
            left = mid + 1
    return left


class Solution(object):
    def findKthBit(self, n, k):

    flip, l = 0, 2 ** n - 1
    while k > 1:
        if k == l // 2 + 1:
            flip ^= 1
            break
        if k > l // 2:
            k = l + 1 - k
            flip ^= 1
        l //= 2
    return str(flip)


import random


class Solution(object):
    def kthLargestValue(self, matrix, k):

    def nth_element(nums, n, compare=lambda a, b: a < b):
        def tri_partition(nums, left, right, target, compare):
            mid = left
            while mid <= right:
                if nums[mid] == target:
                    mid += 1
                elif compare(nums[mid], target):
                    nums[left], nums[mid] = nums[mid], nums[left]
                    left += 1
                    mid += 1
                else:
                    nums[mid], nums[right] = nums[right], nums[mid]
                    right -= 1
            return left, right

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            pivot_left, pivot_right = tri_partition(
                nums, left, right, nums[pivot_idx], compare
            )
            if pivot_left <= n <= pivot_right:
                return
            elif pivot_left > n:
                right = pivot_left - 1
            else:
                left = pivot_right + 1

    vals = []
    for r in xrange(len(matrix)):
        curr = 0
        for c in xrange(len(matrix[0])):
            curr = curr ^ matrix[r][c]
            if r == 0:
                matrix[r][c] = curr
            else:
                matrix[r][c] = curr ^ matrix[r - 1][c]
            vals.append(matrix[r][c])
    nth_element(vals, k - 1, compare=lambda a, b: a > b)
    return vals[k - 1]


class Solution(object):
    def largestValues(self, root):

    def largestValuesHelper(root, depth, result):
        if not root:
            return
        if depth == len(result):
            result.append(root.val)
        else:
            result[depth] = max(result[depth], root.val)
        largestValuesHelper(root.left, depth + 1, result)
        largestValuesHelper(root.right, depth + 1, result)

    result = []
    largestValuesHelper(root, 0, result)
    return result


class Solution2(object):
    def largestValues(self, root):

    result = []
    curr = [root]
    while any(curr):
        result.append(max(node.val for node in curr))
        curr = [
            child for node in curr for child in (node.left, node.right) if child
        ]
    return result


class Solution(object):
    def findLatestStep(self, arr, m):

    if m == len(arr):
        return m
    length = [0] * (len(arr) + 2)
    result = -1
    for i, x in enumerate(arr):
        left, right = length[x - 1], length[x + 1]
        if left == m or right == m:
            result = i
        length[x - left] = length[x + right] = left + right + 1
    return result


class Solution(object):
    def findLeaves(self, root):

    def findLeavesHelper(node, result):
        if not node:
            return -1
        level = 1 + max(
            findLeavesHelper(node.left, result),
            findLeavesHelper(node.right, result),
        )
        if len(result) < level + 1:
            result.append([])
        result[level].append(node.val)
        return level

    result = []
    findLeavesHelper(root, result)
    return result


class Solution(object):
    def longestAwesome(self, s):

    ALPHABET_SIZE = 10
    result, mask, lookup = 0, 0, [len(s)] * (2 ** ALPHABET_SIZE)
    lookup[0] = -1
    for i, ch in enumerate(s):
        mask ^= 2 ** (ord(ch) - ord("0"))
        if lookup[mask] == len(s):
            lookup[mask] = i
        result = max(result, i - lookup[mask])
        for d in xrange(ALPHABET_SIZE):
            result = max(result, i - lookup[mask ^ (2 ** d)])
    return result


import collections


class Solution(object):
    def findLucky(self, arr):

    count = collections.Counter(arr)
    result = -1
    for k, v in count.iteritems():
        if k == v:
            result = max(result, k)
    return result


from heapq import heappush, heappop


class MedianFinder(object):
    def __init__(self):

    self.__max_heap = []
    self.__min_heap = []

    def addNum(self, num):

    if not self.__max_heap or num > -self.__max_heap[0]:
        heappush(self.__min_heap, num)
        if len(self.__min_heap) > len(self.__max_heap) + 1:
            heappush(self.__max_heap, -heappop(self.__min_heap))
    else:
        heappush(self.__max_heap, -num)
        if len(self.__max_heap) > len(self.__min_heap):
            heappush(self.__min_heap, -heappop(self.__max_heap))

    def findMedian(self):

    return (
        (-self.__max_heap[0] + self.__min_heap[0]) / 2.0
        if len(self.__min_heap) == len(self.__max_heap)
        else self.__min_heap[0]
    )


class Solution(object):
    def findMin(self, nums):

    left, right = 0, len(nums) - 1
    while left < right:
        mid = left + (right - left) / 2

        if nums[mid] == nums[right]:
            right -= 1
        elif nums[mid] < nums[right]:
            right = mid
        else:
            left = mid + 1

    return nums[left]


class Solution2(object):
    def findMin(self, nums):

    left, right = 0, len(nums) - 1
    while left < right and nums[left] >= nums[right]:
        mid = left + (right - left) / 2

        if nums[mid] == nums[left]:
            left += 1
        elif nums[mid] < nums[left]:
            right = mid
        else:
            left = mid + 1

    return nums[left]


class Solution(object):
    def findMin(self, nums):

    left, right = 0, len(nums)
    target = nums[-1]

    while left < right:
        mid = left + (right - left) / 2

        if nums[mid] <= target:
            right = mid
        else:
            left = mid + 1

    return nums[left]


class Solution2(object):
    def findMin(self, nums):

    left, right = 0, len(nums) - 1
    while left < right and nums[left] >= nums[right]:
        mid = left + (right - left) / 2

        if nums[mid] < nums[left]:
            right = mid
        else:
            left = mid + 1

    return nums[left]


class Solution(object):
    def minimumTimeRequired(self, jobs, k):

    def backtracking(jobs, i, cap, counts):
        if i == len(jobs):
            return True
        for j in xrange(len(counts)):
            if counts[j] + jobs[i] <= cap:
                counts[j] += jobs[i]
                if backtracking(jobs, i + 1, cap, counts):
                    return True
                counts[j] -= jobs[i]
            if counts[j] == 0:
                break
        return False

    jobs.sort(reverse=True)
    left, right = max(jobs), sum(jobs)
    while left <= right:
        mid = left + (right - left) // 2
        if backtracking(jobs, 0, mid, [0] * k):
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution2(object):
    def minimumTimeRequired(self, jobs, k):

    def backtracking(jobs, i, counts, result):
        if i == len(jobs):
            result[0] = min(result[0], max(counts))
            return
        for j in xrange(len(counts)):
            if counts[j] + jobs[i] <= result[0]:
                counts[j] += jobs[i]
                backtracking(jobs, i + 1, counts, result)
                counts[j] -= jobs[i]
            if counts[j] == 0:
                break

    jobs.sort(reverse=False)
    result = [sum(jobs)]
    backtracking(jobs, 0, [0] * k, result)
    return result[0]


class Solution(object):
    def findMode(self, root):

    def inorder(root, prev, cnt, max_cnt, result):
        if not root:
            return prev, cnt, max_cnt

        prev, cnt, max_cnt = inorder(root.left, prev, cnt, max_cnt, result)
        if prev:
            if root.val == prev.val:
                cnt += 1
            else:
                cnt = 1
        if cnt > max_cnt:
            max_cnt = cnt
            del result[:]
            result.append(root.val)
        elif cnt == max_cnt:
            result.append(root.val)
        return inorder(root.right, root, cnt, max_cnt, result)

    if not root:
        return []
    result = []
    inorder(root, None, 1, 0, result)
    return result


class Solution(object):
    def sumZero(self, n):

    return [i for i in xrange(-(n // 2), n // 2 + 1) if not (i == 0 and n % 2 == 0)]


class Solution(object):
    def nearestValidPoint(self, x, y, points):

    smallest, idx = float("inf"), -1
    for i, (r, c) in enumerate(points):
        dx, dy = x - r, y - c
        if dx * dy == 0 and abs(dx) + abs(dy) < smallest:
            smallest = abs(dx) + abs(dy)
            idx = i
    return idx


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    pass


class Solution(object):
    def findNeartestRightNode(self, root, u):

    q = [root]
    while q:
        new_q = []
        for i, node in enumerate(q):
            if node == u:
                return q[i + 1] if i + 1 < len(q) else None
            if node.left:
                new_q.append(node.left)
            if node.right:
                new_q.append(node.right)
        q = new_q
    return None


import bisect


class Solution(object):
    def __init__(self):
    M = 10 ** 5
    self.__lookup = [0]
    i = 10
    while i < M:
        self.__lookup.append(i)
        i *= 10
    self.__lookup.append(i)

    def findNumbers(self, nums):

    def digit_count(n):
        return bisect.bisect_right(self.__lookup, n)

    return sum(digit_count(n) % 2 == 0 for n in nums)


class Solution2(object):
    def findNumbers(self, nums):

    def digit_count(n):
        result = 0
        while n:
            n //= 10
            result += 1
        return result

    return sum(digit_count(n) % 2 == 0 for n in nums)


class Solution3(object):
    def findNumbers(self, nums):

    return sum(len(str(n)) % 2 == 0 for n in nums)


class Solution(object):
    def findPeakElement(self, nums):

    left, right = 0, len(nums) - 1

    while left < right:
        mid = left + (right - left) / 2
        if nums[mid] > nums[mid + 1]:
            right = mid
        else:
            left = mid + 1

    return left


class Solution(object):
    def findPermutation(self, s):

    result = []
    for i in xrange(len(s) + 1):
        if i == len(s) or s[i] == "I":
            result += range(i + 1, len(result), -1)
    return result


class Solution(object):
    def pivotIndex(self, nums):

    total = sum(nums)
    left_sum = 0
    for i, num in enumerate(nums):
        if left_sum == (total - left_sum - num):
            return i
        left_sum += num
    return -1


class Solution(object):
    def findSolution(self, customfunction, z):

    result = []
    x, y = 1, 1
    while customfunction.f(x, y) < z:
        y += 1
    while y > 0:
        while y > 0 and customfunction.f(x, y) > z:
            y -= 1
        if y > 0 and customfunction.f(x, y) == z:
            result.append([x, y])
        x += 1
    return result


import bisect


class Solution(object):
    def findRightInterval(self, intervals):

    sorted_intervals = sorted(
        (interval.start, i) for i, interval in enumerate(intervals)
    )
    result = []
    for interval in intervals:
        idx = bisect.bisect_left(sorted_intervals, (interval.end,))
        result.append(
            sorted_intervals[idx][1] if idx < len(sorted_intervals) else -1
        )
    return result


class Node(object):
    def __init__(self, val=None, children=None):
    pass


class Solution(object):
    def findRoot(self, tree):

    root = 0
    for node in tree:
        root ^= id(node)
        for child in node.children:
            root ^= id(child)
    for node in tree:
        if id(node) == root:
            return node
    return None


class Solution2(object):
    def findRoot(self, tree):

    root = 0
    for node in tree:
        root ^= node.val
        for child in node.children:
            root ^= child.val
    for node in tree:
        if node.val == root:
            return node
    return None


class Solution3(object):
    def findRoot(self, tree):

    root = 0
    for node in tree:
        root += node.val - sum(child.val for child in node.children)
    for node in tree:
        if node.val == root:
            return node
    return None


import itertools
import heapq


class Solution(object):
    def busiestServers(self, k, arrival, load):

    count = [0] * k
    min_heap_of_endtimes = []
    min_heap_of_nodes_after_curr = []
    min_heap_of_nodes_before_curr = range(k)
    for i, (t, l) in enumerate(itertools.izip(arrival, load)):
        if i % k == 0:
            min_heap_of_nodes_before_curr, min_heap_of_nodes_after_curr = (
                [],
                min_heap_of_nodes_before_curr,
            )
        while min_heap_of_endtimes and min_heap_of_endtimes[0][0] <= t:
            _, free = heapq.heappop(min_heap_of_endtimes)
            if free < i % k:
                heapq.heappush(min_heap_of_nodes_before_curr, free)
            else:
                heapq.heappush(min_heap_of_nodes_after_curr, free)
        min_heap_of_candidates = (
            min_heap_of_nodes_after_curr
            if min_heap_of_nodes_after_curr
            else min_heap_of_nodes_before_curr
        )
        if not min_heap_of_candidates:
            continue
        node = heapq.heappop(min_heap_of_candidates)
        count[node] += 1
        heapq.heappush(min_heap_of_endtimes, (t + l, node))
    max_count = max(count)
    return [i for i in xrange(k) if count[i] == max_count]


import sortedcontainers
import itertools
import heapq


class Solution2(object):
    def busiestServers(self, k, arrival, load):

    count = [0] * k
    min_heap_of_endtimes = []
    availables = sortedcontainers.SortedList(xrange(k))
    for i, (t, l) in enumerate(itertools.izip(arrival, load)):
        while min_heap_of_endtimes and min_heap_of_endtimes[0][0] <= t:
            _, free = heapq.heappop(min_heap_of_endtimes)
            availables.add(free)
        if not availables:
            continue
        idx = availables.bisect_left(i % k) % len(availables)
        node = availables.pop(idx)
        count[node] += 1
        heapq.heappush(min_heap_of_endtimes, (t + l, node))
    max_count = max(count)
    return [i for i in xrange(k) if count[i] == max_count]


class Solution(object):
    def smallestCommonElement(self, mat):

    intersections = set(mat[0])
    for i in xrange(1, len(mat)):
        intersections &= set(mat[i])
        if not intersections:
            return -1
    return min(intersections)


import collections


class Solution2(object):
    def smallestCommonElement(self, mat):

    counter = collections.Counter()
    for row in mat:
        for c in row:
            counter[c] += 1
            if counter[c] == len(mat):
                return c
    return -1


import bisect


class Solution(object):
    def nextGreatestLetter(self, letters, target):

    i = bisect.bisect_right(letters, target)
    return letters[0] if i == len(letters) else letters[i]


class Solution(object):
    def findCelebrity(self, n):

    candidate = 0

    for i in xrange(1, n):
        if knows(candidate, i):
            candidate = i

    for i in xrange(n):
        candidate_knows_i = knows(candidate, i)
        i_knows_candidate = knows(i, candidate)
        if i != candidate and (candidate_knows_i or not i_knows_candidate):
            return -1
    return candidate


class Solution(object):
    def findTheCity(self, n, edges, distanceThreshold):

    dist = [[float("inf")] * n for _ in xrange(n)]
    for i, j, w in edges:
        dist[i][j] = dist[j][i] = w
    for i in xrange(n):
        dist[i][i] = 0
    for k in xrange(n):
        for i in xrange(n):
            for j in xrange(n):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    result = {
        sum(d <= distanceThreshold for d in dist[i]): i for i in xrange(n)}
    return result[min(result.iterkeys())]


class Solution(object):
    def nearestPalindromic(self, n):

    l = len(n)
    candidates = set((str(10 ** l + 1), str(10 ** (l - 1) - 1)))
    prefix = int(n[: (l + 1) / 2])
    for i in map(str, (prefix - 1, prefix, prefix + 1)):
        candidates.add(i + [i, i[:-1]][l % 2][::-1])
    candidates.discard(n)
    return min(candidates, key=lambda x: (abs(int(x) - int(n)), int(x)))


class Solution(object):
    def findDerangement(self, n):

    M = 1000000007
    mul, total = 1, 0
    for i in reversed(xrange(n + 1)):
        total = (total + M + (1 if i % 2 == 0 else -1) * mul) % M
        mul = (mul * i) % M
    return total


import operator
import collections
from functools import reduce


class Solution(object):
    def findTheDifference(self, s, t):

    return chr(
        reduce(operator.xor, map(ord, s), 0) ^ reduce(
            operator.xor, map(ord, t), 0)
    )

    def findTheDifference2(self, s, t):

    t = list(t)
    s = list(s)
    for i in s:
        t.remove(i)
    return t[0]

    def findTheDifference3(self, s, t):
    return chr(reduce(operator.xor, map(ord, s + t)))

    def findTheDifference4(self, s, t):
    return list((collections.Counter(t) - collections.Counter(s)))[0]

    def findTheDifference5(self, s, t):
    s, t = sorted(s), sorted(t)
    return t[-1] if s == t[:-1] else [x[1] for x in zip(s, t) if x[0] != x[1]][0]


import bisect


class Solution(object):
    def findTheDistanceValue(self, arr1, arr2, d):

    arr2.sort()
    result, i, j = 0, 0, 0
    for x in arr1:
        j = bisect.bisect_left(arr2, x)
        left = arr2[j - 1] if j - 1 >= 0 else float("-inf")
        right = arr2[j] if j < len(arr2) else float("inf")
        result += left + d < x < right - d
    return result


class Solution2(object):
    def findTheDistanceValue(self, arr1, arr2, d):

    arr1.sort(), arr2.sort()
    result, i, j = 0, 0, 0
    while i < len(arr1) and j < len(arr2):
        if arr1[i] - arr2[j] > d:
            j += 1
            continue
        result += arr2[j] - arr1[i] > d
        i += 1
    return result + len(arr1) - i


class Solution(object):
    def findDuplicate(self, nums):

    slow = nums[0]
    fast = nums[nums[0]]
    while slow != fast:
        slow = nums[slow]
        fast = nums[nums[fast]]

    fast = 0
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    return slow


class Solution2(object):
    def findDuplicate(self, nums):

    left, right = 1, len(nums) - 1

    while left <= right:
        mid = left + (right - left) / 2

        count = 0
        for num in nums:
            if num <= mid:
                count += 1
        if count > mid:
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution3(object):
    def findDuplicate(self, nums):

    duplicate = 0

    for num in nums:
        if nums[abs(num) - 1] > 0:
            nums[abs(num) - 1] *= -1
        else:
            duplicate = abs(num)
            break

    for num in nums:
        if nums[abs(num) - 1] < 0:
            nums[abs(num) - 1] *= -1
        else:
            break
    return duplicate


class Solution(object):
    def largestAltitude(self, gain):

    result = curr = 0
    for g in gain:
        curr += g
        result = max(result, curr)
    return result


class ArrayReader(object):
    def compareSub(self, l, r, x, y):
    pass

    def length(self):
    pass


class Solution(object):
    def getIndex(self, reader):

    left, right = 0, reader.length() - 1
    while left < right:
        mid = left + (right - left) // 2
        if (
            reader.compareSub(
                left, mid, mid if (right - left + 1) % 2 else mid + 1, right
            )
            >= 0
        ):
            right = mid
        else:
            left = mid + 1
    return left


import heapq


class Solution(object):
    def kthSmallest(self, mat, k):

    def kSmallestPairs(nums1, nums2, k):
        result, min_heap = [], []
        for c in xrange(min(len(nums1), k)):
            heapq.heappush(min_heap, (nums1[c] + nums2[0], 0))
            c += 1
        while len(result) != k and min_heap:
            total, c = heapq.heappop(min_heap)
            result.append(total)
            if c + 1 == len(nums2):
                continue
            heapq.heappush(min_heap, (total - nums2[c] + nums2[c + 1], c + 1))
        return result

    result = mat[0]
    for r in xrange(1, len(mat)):
        result = kSmallestPairs(result, mat[r], k)
    return result[k - 1]


class Solution2(object):
    def kthSmallest(self, mat, k):

    def countArraysHaveSumLessOrEqual(
        mat, k, r, target
    ):
        if target < 0:
            return 0
        if r == len(mat):
            return 1
        result = 0
        for c in xrange(len(mat[0])):
            cnt = countArraysHaveSumLessOrEqual(
                mat, k - result, r + 1, target - mat[r][c]
            )
            if not cnt:
                break
            result += cnt
            if result > k:
                break
        return result

    MAX_NUM = 5000
    left, right = len(mat), len(mat) * MAX_NUM
    while left <= right:
        mid = left + (right - left) // 2
        cnt = countArraysHaveSumLessOrEqual(mat, k, 0, mid)
        if cnt >= k:
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution(object):
    def findTheLongestSubstring(self, s):

    VOWELS = "aeiou"
    result, mask, lookup = 0, 0, [len(s)] * (2 ** len(VOWELS))
    lookup[0] = -1
    for i, c in enumerate(s):
        index = VOWELS.find(c)
        mask ^= (1 << index) if index >= 0 else 0
        if lookup[mask] == len(s):
            lookup[mask] = i
        result = max(result, i - lookup[mask])
    return result


class Solution(object):
    def findMinFibonacciNumbers(self, k):

    result, a, b = 0, 1, 1
    while b <= k:
        b, a = a + b, b
    while k:
        if a <= k:
            k -= a
            result += 1
        a, b = b - a, a
    return result


class Solution(object):
    def mostCompetitive(self, nums, k):

    stk = []
    for i, x in enumerate(nums):
        while stk and stk[-1] > x and len(stk) + (len(nums) - i) > k:
            stk.pop()
        if len(stk) < k:
            stk.append(x)
    return stk


class Solution(object):
    def shortestSuperstring(self, A):

    n = len(A)
    overlaps = [[0] * n for _ in xrange(n)]
    for i, x in enumerate(A):
        for j, y in enumerate(A):
            for l in reversed(xrange(min(len(x), len(y)))):
                if y[:l].startswith(x[len(x) - l:]):
                    overlaps[i][j] = l
                    break

    dp = [[0] * n for _ in xrange(1 << n)]
    prev = [[None] * n for _ in xrange(1 << n)]
    for mask in xrange(1, 1 << n):
        for bit in xrange(n):
            if ((mask >> bit) & 1) == 0:
                continue
            prev_mask = mask ^ (1 << bit)
            for i in xrange(n):
                if ((prev_mask >> i) & 1) == 0:
                    continue
                value = dp[prev_mask][i] + overlaps[i][bit]
                if value > dp[mask][bit]:
                    dp[mask][bit] = value
                    prev[mask][bit] = i

    bit = max(xrange(n), key=dp[-1].__getitem__)
    words = []
    mask = (1 << n) - 1
    while bit is not None:
        words.append(bit)
        mask, bit = mask ^ (1 << bit), prev[mask][bit]
    words.reverse()
    lookup = set(words)
    words.extend([i for i in xrange(n) if i not in lookup])

    result = [A[words[0]]]
    for i in xrange(1, len(words)):
        overlap = overlaps[words[i - 1]][words[i]]
        result.append(A[words[i]][overlap:])
    return "".join(result)


class Solution(object):
    def smallestDivisor(self, nums, threshold):

    def check(A, d, threshold):
        return sum((i - 1) // d + 1 for i in nums) <= threshold

    left, right = 1, max(nums)
    while left <= right:
        mid = left + (right - left) // 2
        if check(nums, mid, threshold):
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution(object):
    def findJudge(self, N, trust):

    degrees = [0] * N
    for i, j in trust:
        degrees[i - 1] -= 1
        degrees[j - 1] += 1
    for i in xrange(len(degrees)):
        if degrees[i] == N - 1:
            return i + 1
    return -1


class Solution(object):
    def getWinner(self, arr, k):

    result = arr[0]
    count = 0
    for i in xrange(1, len(arr)):
        if arr[i] > result:
            result = arr[i]
            count = 0
        count += 1
        if count == k:
            break
    return result


class Solution(object):
    def minSumOfLengths(self, arr, target):

    prefix, dp = {0: -1}, [0] * len(
        arr
    )
    result = min_len = float("inf")
    accu = 0
    for right in xrange(len(arr)):
        accu += arr[right]
        prefix[accu] = right
        if accu - target in prefix:
            left = prefix[accu - target]
            min_len = min(min_len, right - left)
            if left != -1:
                result = min(result, dp[left] + (right - left))
        dp[right] = min_len
    return result if result != float("inf") else -1


class Solution(object):
    def restoreMatrix(self, rowSum, colSum):

    matrix = [[0] * len(colSum) for _ in xrange(len(rowSum))]
    i = j = 0
    while i < len(matrix) and j < len(matrix[0]):
        matrix[i][j] = min(rowSum[i], colSum[j])
        rowSum[i] -= matrix[i][j]
        colSum[j] -= matrix[i][j]
        if not rowSum[i]:
            i += 1
        if not colSum[j]:
            j += 1
    return matrix


class Solution2(object):
    def restoreMatrix(self, rowSum, colSum):

    matrix = [[0] * len(colSum) for _ in xrange(len(rowSum))]
    for i in xrange(len(matrix)):
        for j in xrange(len(matrix[i])):
            matrix[i][j] = min(rowSum[i], colSum[j])
            rowSum[i] -= matrix[i][j]
            colSum[j] -= matrix[i][j]
    return matrix


class Solution(object):
    def tictactoe(self, moves):

    row, col = [[0] * 3 for _ in xrange(2)], [[0] * 3 for _ in xrange(2)]
    diag, anti_diag = [0] * 2, [0] * 2
    p = 0
    for r, c in moves:
        row[p][r] += 1
        col[p][c] += 1
        diag[p] += r == c
        anti_diag[p] += r + c == 2
        if 3 in (row[p][r], col[p][c], diag[p], anti_diag[p]):
            return "AB"[p]
        p ^= 1
    return "Draw" if len(moves) == 9 else "Pending"


import collections


class Solution(object):
    def countCharacters(self, words, chars):

    def check(word, chars, count):
        if len(word) > len(chars):
            return False
        curr_count = collections.Counter()
        for c in word:
            curr_count[c] += 1
            if c not in count or count[c] < curr_count[c]:
                return False
        return True

    count = collections.Counter(chars)
    return sum(len(word) for word in words if check(word, chars, count))


class Solution(object):
    def firstBadVersion(self, n):

    left, right = 1, n
    while left <= right:
        mid = left + (right - left) / 2
        if isBadVersion(mid):
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution(object):

    def firstMissingPositive(self, A):
    i = 0
    while i < len(A):
        if A[i] > 0 and A[i] - 1 < len(A) and A[i] != A[A[i] - 1]:
            A[A[i] - 1], A[i] = A[i], A[A[i] - 1]
        else:
            i += 1

    for i, integer in enumerate(A):
        if integer != i + 1:
            return i + 1
    return len(A) + 1


from collections import defaultdict


class Solution(object):
    def firstUniqChar(self, s):

    lookup = defaultdict(int)
    candidtates = set()
    for i, c in enumerate(s):
        if lookup[c]:
            candidtates.discard(lookup[c])
        else:
            lookup[c] = i + 1
            candidtates.add(i + 1)

    return min(candidtates) - 1 if candidtates else -1


import collections


class FirstUnique(object):
    def __init__(self, nums):

    self.__q = collections.OrderedDict()
    self.__dup = set()
    for num in nums:
        self.add(num)

    def showFirstUnique(self):

    if self.__q:
        return next(iter(self.__q))
    return -1

    def add(self, value):

    if value not in self.__dup and value not in self.__q:
        self.__q[value] = None
        return
    if value in self.__q:
        self.__q.pop(value)
        self.__dup.add(value)


class Solution(object):
    def fixedPoint(self, A):

    left, right = 0, len(A) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if A[mid] >= mid:
            right = mid - 1
        else:
            left = mid + 1
    return left if A[left] == left else -1


import threading


class FizzBuzz(object):
    def __init__(self, n):
    self.__n = n
    self.__curr = 0
    self.__cv = threading.Condition()

    def fizz(self, printFizz):

    for i in xrange(1, self.__n + 1):
        with self.__cv:
            while self.__curr % 4 != 0:
                self.__cv.wait()
            self.__curr += 1
            if i % 3 == 0 and i % 5 != 0:
                printFizz()
            self.__cv.notify_all()

    def buzz(self, printBuzz):

    for i in xrange(1, self.__n + 1):
        with self.__cv:
            while self.__curr % 4 != 1:
                self.__cv.wait()
            self.__curr += 1
            if i % 3 != 0 and i % 5 == 0:
                printBuzz()
            self.__cv.notify_all()

    def fizzbuzz(self, printFizzBuzz):

    for i in xrange(1, self.__n + 1):
        with self.__cv:
            while self.__curr % 4 != 2:
                self.__cv.wait()
            self.__curr += 1
            if i % 3 == 0 and i % 5 == 0:
                printFizzBuzz()
            self.__cv.notify_all()

    def number(self, printNumber):

    for i in xrange(1, self.__n + 1):
        with self.__cv:
            while self.__curr % 4 != 3:
                self.__cv.wait()
            self.__curr += 1
            if i % 3 != 0 and i % 5 != 0:
                printNumber(i)
            self.__cv.notify_all()


class Solution(object):
    def fizzBuzz(self, n):

    result = []

    for i in xrange(1, n + 1):
        if i % 15 == 0:
            result.append("FizzBuzz")
        elif i % 5 == 0:
            result.append("Buzz")
        elif i % 3 == 0:
            result.append("Fizz")
        else:
            result.append(str(i))

    return result

    def fizzBuzz2(self, n):

    l = [str(x) for x in range(n + 1)]
    l3 = range(0, n + 1, 3)
    l5 = range(0, n + 1, 5)
    for i in l3:
        l[i] = "Fizz"
    for i in l5:
        if l[i] == "Fizz":
            l[i] += "Buzz"
        else:
            l[i] = "Buzz"
    return l[1:]

    def fizzBuzz3(self, n):
    return [
        "Fizz" * (not i % 3) + "Buzz" * (not i % 5) or str(i)
        for i in range(1, n + 1)
    ]

    def fizzBuzz4(self, n):
    return [
        "FizzBuzz"[i % -3 & -4: i % -5 & 8 ^ 12] or repr(i)
        for i in range(1, n + 1)
    ]


from collections import deque


class Vector2D(object):
    def __init__(self, vec2d):

    self.stack = deque((len(v), iter(v)) for v in vec2d if v)

    def next(self):

    length, iterator = self.stack.popleft()
    if length > 1:
        self.stack.appendleft((length - 1, iterator))
    return next(iterator)

    def hasNext(self):

    return bool(self.stack)


class Node(object):
    def __init__(self, val, prev, next, child):
    self.val = val
    self.prev = prev
    self.next = next
    self.child = child


class Solution(object):
    def flatten(self, head):

    curr = head
    while curr:
        if curr.child:
            curr_next = curr.next
            curr.child.prev = curr
            curr.next = curr.child
            last_child = curr
            while last_child.next:
                last_child = last_child.next
            if curr_next:
                last_child.next = curr_next
                curr_next.prev = last_child
            curr.child = None
        curr = curr.next
    return head


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def flatten(self, root):
    self.flattenRecu(root, None)

    def flattenRecu(self, root, list_head):
    if root:
        list_head = self.flattenRecu(root.right, list_head)
        list_head = self.flattenRecu(root.left, list_head)
        root.right = list_head
        root.left = None
        return root
    else:
        return list_head


class Solution2(object):
    list_head = None

    def flatten(self, root):
    if root:
        self.flatten(root.right)
        self.flatten(root.left)
        root.right = self.list_head
        root.left = None
        self.list_head = root


class NestedIterator(object):
    def __init__(self, nestedList):

    self.__depth = [[nestedList, 0]]

    def next(self):

    nestedList, i = self.__depth[-1]
    self.__depth[-1][1] += 1
    return nestedList[i].getInteger()

    def hasNext(self):

    while self.__depth:
        nestedList, i = self.__depth[-1]
        if i == len(nestedList):
            self.__depth.pop()
        elif nestedList[i].isInteger():
            return True
        else:
            self.__depth[-1][1] += 1
            self.__depth.append([nestedList[i].getList(), 0])
    return False


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def flipMatchVoyage(self, root, voyage):

    def dfs(root, voyage, i, result):
        if not root:
            return True
        if root.val != voyage[i[0]]:
            return False
        i[0] += 1
        if root.left and root.left.val != voyage[i[0]]:
            result.append(root.val)
            return dfs(root.right, voyage, i, result) and dfs(
                root.left, voyage, i, result
            )
        return dfs(root.left, voyage, i, result) and dfs(
            root.right, voyage, i, result
        )

    result = []
    return result if dfs(root, voyage, [0], result) else [-1]


import collections


class Solution(object):
    def maxEqualRowsAfterFlips(self, matrix):

    count = collections.Counter(
        tuple(x ^ row[0] for x in row) for row in matrix)
    return max(count.itervalues())


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


import collections


class Solution(object):
    def flipEquiv(self, root1, root2):

    dq1, dq2 = collections.deque([root1]), collections.deque([root2])
    while dq1 and dq2:
        node1, node2 = dq1.pop(), dq2.pop()
        if not node1 and not node2:
            continue
        if not node1 or not node2 or node1.val != node2.val:
            return False
        if (not node1.left and not node2.right) or (
            node1.left and node2.right and node1.left.val == node2.right.val
        ):
            dq1.extend([node1.right, node1.left])
        else:
            dq1.extend([node1.left, node1.right])
        dq2.extend([node2.left, node2.right])
    return not dq1 and not dq2


class Solution2(object):
    def flipEquiv(self, root1, root2):

    stk1, stk2 = [root1], [root2]
    while stk1 and stk2:
        node1, node2 = stk1.pop(), stk2.pop()
        if not node1 and not node2:
            continue
        if not node1 or not node2 or node1.val != node2.val:
            return False
        if (not node1.left and not node2.right) or (
            node1.left and node2.right and node1.left.val == node2.right.val
        ):
            stk1.extend([node1.right, node1.left])
        else:
            stk1.extend([node1.left, node1.right])
        stk2.extend([node2.left, node2.right])
    return not stk1 and not stk2


class Solution3(object):
    def flipEquiv(self, root1, root2):

    if not root1 and not root2:
        return True
    if not root1 or not root2 or root1.val != root2.val:
        return False

    return (
        self.flipEquiv(root1.left, root2.left)
        and self.flipEquiv(root1.right, root2.right)
        or self.flipEquiv(root1.left, root2.right)
        and self.flipEquiv(root1.right, root2.left)
    )


import itertools
import re


class Solution(object):
    def canWin(self, s):
    g, g_final = [0], 0
    for p in itertools.imap(len, re.split("-+", s)):
        while len(g) <= p:

            g += (
                min(
                    set(xrange(p))
                    - {
                        x ^ y
                        for x, y in itertools.izip(
                            g[: len(g) / 2], g[-2: -len(g) / 2 - 2: -1]
                        )
                    }
                ),
            )
        g_final ^= g[p]
    return g_final > 0


class Solution2(object):
    def canWin(self, s):

    lookup = {}

    def canWinHelper(consecutives):
        consecutives = tuple(
            sorted(c for c in consecutives if c >= 2)
        )
        if consecutives not in lookup:
            lookup[consecutives] = any(
                not canWinHelper(
                    consecutives[:i] + (j, c - 2 - j) + consecutives[i + 1:]
                )
                for i, c in enumerate(consecutives)
                for j in xrange(c - 1)
            )
        return lookup[consecutives]

    return canWinHelper(map(len, re.findall(r"\+\++", s)))


class Solution3(object):
    def canWin(self, s):

    i, n = 0, len(s) - 1
    is_win = False
    while not is_win and i < n:
        if s[i] == "+":
            while not is_win and i < n and s[i + 1] == "+":

                is_win = not self.canWin(s[:i] + "--" + s[i + 2:])
                i += 1
        i += 1
    return is_win


class Solution(object):
    def generatePossibleNextMoves(self, s):

    res = []
    i, n = 0, len(s) - 1
    while i < n:
        if s[i] == "+":
            while i < n and s[i + 1] == "+":
                res.append(s[:i] + "--" + s[i + 2:])
                i += 1
        i += 1
    return res


class Solution2(object):
    def generatePossibleNextMoves(self, s):

    return [
        s[:i] + "--" + s[i + 2:]
        for i in xrange(len(s) - 1)
        if s[i: i + 2] == "++"
    ]


class Solution(object):
    def minFlipsMonoIncr(self, S):

    flip0, flip1 = 0, 0
    for c in S:
        flip0 += int(c == "1")
        flip1 = min(flip0, flip1 + int(c == "0"))
    return flip1


class Solution(object):
    def flipAndInvertImage(self, A):

    for row in A:
        for i in xrange((len(row) + 1) // 2):
            row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1
    return A


class Solution(object):
    def floodFill(self, image, sr, sc, newColor):

    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

    def dfs(image, r, c, newColor, color):
        if not (
            0 <= r < len(image) and 0 <= c < len(
                image[0]) and image[r][c] == color
        ):
            return

        image[r][c] = newColor
        for d in directions:
            dfs(image, r + d[0], c + d[1], newColor, color)

    color = image[sr][sc]
    if color == newColor:
        return image
    dfs(image, sr, sc, newColor, color)
    return image


class Solution(object):
    def gardenNoAdj(self, N, paths):

    result = [0] * N
    G = [[] for i in xrange(N)]
    for x, y in paths:
        G[x - 1].append(y - 1)
        G[y - 1].append(x - 1)
    for i in xrange(N):
        result[i] = ({1, 2, 3, 4} - {result[j] for j in G[i]}).pop()
    return result


class Solution(object):
    def canChoose(self, groups, nums):

    def getPrefix(pattern):
        prefix = [-1] * len(pattern)
        j = -1
        for i in xrange(1, len(pattern)):
            while j + 1 > 0 and pattern[j + 1] != pattern[i]:
                j = prefix[j]
            if pattern[j + 1] == pattern[i]:
                j += 1
            prefix[i] = j
        return prefix

    def KMP(text, pattern, start):
        prefix = getPrefix(pattern)
        j = -1
        for i in xrange(start, len(text)):
            while j + 1 > 0 and pattern[j + 1] != text[i]:
                j = prefix[j]
            if pattern[j + 1] == text[i]:
                j += 1
            if j + 1 == len(pattern):
                return i - j
        return -1

    pos = 0
    for group in groups:
        pos = KMP(nums, group, pos)
        if pos == -1:
            return False
        pos += len(group)
    return True


class Solution(object):
    def largestNumber(self, cost, target):

    dp = [0]
    for t in xrange(1, target + 1):
        dp.append(-1)
        for i, c in enumerate(cost):
            if t - c < 0 or dp[t - c] < 0:
                continue
            dp[t] = max(dp[t], dp[t - c] + 1)
    if dp[target] < 0:
        return "0"
    result = []
    for i in reversed(xrange(9)):
        while target >= cost[i] and dp[target] == dp[target - cost[i]] + 1:
            target -= cost[i]
            result.append(i + 1)
    return "".join(map(str, result))


class Solution2(object):
    def largestNumber(self, cost, target):

    def key(bag):
        return sum(bag), bag

    dp = [[0] * 9]
    for t in xrange(1, target + 1):
        dp.append([])
        for d, c in enumerate(cost):
            if t < c or not dp[t - c]:
                continue
            curr = dp[t - c][:]
            curr[~d] += 1
            if key(curr) > key(dp[t]):
                dp[-1] = curr
    if not dp[-1]:
        return "0"
    return "".join(str(9 - i) * c for i, c in enumerate(dp[-1]))


class Solution3(object):
    def largestNumber(self, cost, target):

    dp = [0]
    for t in xrange(1, target + 1):
        dp.append(-1)
        for i, c in enumerate(cost):
            if t - c < 0:
                continue
            dp[t] = max(dp[t], dp[t - c] * 10 + i + 1)
    return str(max(dp[t], 0))


class Solution(object):
    def sumFourDivisors(self, nums):

    result = 0
    for num in nums:
        facs, i = [], 1
        while i * i <= num:
            if num % i:
                i += 1
                continue
            facs.append(i)
            if i != num // i:
                facs.append(num // i)
                if len(facs) > 4:
                    break
            i += 1
        if len(facs) == 4:
            result += sum(facs)
    return result


import itertools


class Solution2(object):
    def sumFourDivisors(self, nums):

    def factorize(x):
        result = []
        d = 2
        while d * d <= x:
            e = 0
            while x % d == 0:
                x //= d
                e += 1
            if e:
                result.append([d, e])
            d += 1 if d == 2 else 2
        if x > 1:
            result.append([x, 1])
        return result

    result = 0
    for facs in itertools.imap(factorize, nums):
        if len(facs) == 1 and facs[0][1] == 3:
            p = facs[0][0]
            result += (p ** 4 - 1) // (p - 1)
        elif len(facs) == 2 and facs[0][1] == facs[1][1] == 1:
            p, q = facs[0][0], facs[1][0]
            result += (1 + p) * (1 + q)
    return result


import re


class Solution(object):
    def fractionAddition(self, expression):

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    ints = map(int, re.findall("[+-]?\d+", expression))
    A, B = 0, 1
    for i in xrange(0, len(ints), 2):
        a, b = ints[i], ints[i + 1]
        A = A * b + a * B
        B *= b
        g = gcd(A, B)
        A //= g
        B //= g
    return "%d/%d" % (A, B)


class Solution(object):
    def fractionToDecimal(self, numerator, denominator):

    result = ""
    if (numerator > 0 and denominator < 0) or (numerator < 0 and denominator > 0):
        result = "-"

    dvd, dvs = abs(numerator), abs(denominator)
    result += str(dvd / dvs)
    dvd %= dvs

    if dvd > 0:
        result += "."

    lookup = {}
    while dvd and dvd not in lookup:
        lookup[dvd] = len(result)
        dvd *= 10
        result += str(dvd / dvs)
        dvd %= dvs

    if dvd in lookup:
        result = result[: lookup[dvd]] + "(" + result[lookup[dvd]:] + ")"

    return result


import collections


class Solution(object):
    def findRotateSteps(self, ring, key):

    lookup = collections.defaultdict(list)
    for i in xrange(len(ring)):
        lookup[ring[i]].append(i)

    dp = [[0] * len(ring) for _ in xrange(2)]
    prev = [0]
    for i in xrange(1, len(key) + 1):
        dp[i % 2] = [float("inf")] * len(ring)
        for j in lookup[key[i - 1]]:
            for k in prev:
                dp[i % 2][j] = min(
                    dp[i % 2][j],
                    min(
                        (k + len(ring) - j) % len(ring),
                        (j + len(ring) - k) % len(ring),
                    )
                    + dp[(i - 1) % 2][k],
                )
        prev = lookup[key[i - 1]]
    return min(dp[len(key) % 2]) + len(key)


class Solution(object):
    def findCircleNum(self, M):

    class UnionFind(object):
        def __init__(self, n):
            self.set = range(n)
            self.count = n

        def find_set(self, x):
            if self.set[x] != x:
                self.set[x] = self.find_set(self.set[x])
            return self.set[x]

        def union_set(self, x, y):
            x_root, y_root = map(self.find_set, (x, y))
            if x_root != y_root:
                self.set[min(x_root, y_root)] = max(x_root, y_root)
                self.count -= 1

    circles = UnionFind(len(M))
    for i in xrange(len(M)):
        for j in xrange(len(M)):
            if M[i][j] and i != j:
                circles.union_set(i, j)
    return circles.count


import collections


class Solution(object):
    def numFriendRequests(self, ages):

    def request(a, b):
        return 0.5 * a + 7 < b <= a

    c = collections.Counter(ages)
    return sum(
        int(request(a, b)) * c[a] * (c[b] - int(a == b)) for a in c for b in c
    )


class Solution(object):
    def canCross(self, stones):

    if stones[1] != 1:
        return False

    last_jump_units = {s: set() for s in stones}
    last_jump_units[1].add(1)
    for s in stones[:-1]:
        for j in last_jump_units[s]:
            for k in (j - 1, j, j + 1):
                if k > 0 and s + k in last_jump_units:
                    last_jump_units[s + k].add(k)
    return bool(last_jump_units[stones[-1]])


import collections


class Solution(object):
    def frogPosition(self, n, edges, t, target):

    G = collections.defaultdict(list)
    for u, v in edges:
        G[u].append(v)
        G[v].append(u)

    stk = [(t, 1, 0, 1)]
    while stk:
        new_stk = []
        while stk:
            t, node, parent, choices = stk.pop()
            if not t or not (len(G[node]) - (parent != 0)):
                if node == target:
                    return 1.0 / choices
                continue
            for child in G[node]:
                if child == parent:
                    continue
                new_stk.append(
                    (t - 1, child, node, choices *
                     (len(G[node]) - (parent != 0)))
                )
        stk = new_stk
    return 0.0


class Solution2(object):
    def frogPosition(self, n, edges, t, target):

    G = collections.defaultdict(list)
    for u, v in edges:
        G[u].append(v)
        G[v].append(u)

    stk = [(t, 1, 0, 1)]
    while stk:
        t, node, parent, choices = stk.pop()
        if not t or not (len(G[node]) - (parent != 0)):
            if node == target:
                return 1.0 / choices
            continue
        for child in G[node]:
            if child == parent:
                continue
            stk.append(
                (t - 1, child, node, choices * (len(G[node]) - (parent != 0)))
            )
    return 0.0


class Solution3(object):
    def frogPosition(self, n, edges, t, target):

    def dfs(G, target, t, node, parent):
        if not t or not (len(G[node]) - (parent != 0)):
            return int(node == target)
        result = 0
        for child in G[node]:
            if child == parent:
                continue
            result = dfs(G, target, t - 1, child, node)
            if result:
                break
        return result * (len(G[node]) - (parent != 0))

    G = collections.defaultdict(list)
    for u, v in edges:
        G[u].append(v)
        G[v].append(u)
    choices = dfs(G, target, t, 1, 0)
    return 1.0 / choices if choices else 0.0


class Solution4(object):
    def frogPosition(self, n, edges, t, target):

    def dfs(G, target, t, node, parent):
        if not t or not (len(G[node]) - (parent != 0)):
            return float(node == target)
        for child in G[node]:
            if child == parent:
                continue
            result = dfs(G, target, t - 1, child, node)
            if result:
                break
        return result / (len(G[node]) - (parent != 0))

    G = collections.defaultdict(list)
    for u, v in edges:
        G[u].append(v)
        G[v].append(u)
    return dfs(G, target, t, 1, 0)


import collections


class Solution(object):
    def totalFruit(self, tree):

    count = collections.defaultdict(int)
    result, i = 0, 0
    for j, v in enumerate(tree):
        count[v] += 1
        while len(count) > 2:
            count[tree[i]] -= 1
            if count[tree[i]] == 0:
                del count[tree[i]]
            i += 1
        result = max(result, j - i + 1)
    return result


import heapq


class Solution(object):
    def furthestBuilding(self, heights, bricks, ladders):

    min_heap = []
    for i in xrange(len(heights) - 1):
        diff = heights[i + 1] - heights[i]
        if diff > 0:
            heapq.heappush(min_heap, diff)
        if len(min_heap) <= ladders:
            continue
        bricks -= heapq.heappop(min_heap)
        if bricks < 0:
            return i
    return len(heights) - 1


class Solution(object):
    def gameOfLife(self, board):

    m = len(board)
    n = len(board[0]) if m else 0
    for i in xrange(m):
        for j in xrange(n):
            count = 0

            for I in xrange(max(i - 1, 0), min(i + 2, m)):
                for J in xrange(max(j - 1, 0), min(j + 2, n)):
                    count += board[I][J] & 1

            if (count == 4 and board[i][j]) or count == 3:
                board[i][j] |= 2

    for i in xrange(m):
        for j in xrange(n):
            board[i][j] >>= 1


class Solution(object):

    def canCompleteCircuit(self, gas, cost):
    start, total_sum, current_sum = 0, 0, 0
    for i in xrange(len(gas)):
        diff = gas[i] - cost[i]
        current_sum += diff
        total_sum += diff
        if current_sum < 0:
            start = i + 1
            current_sum = 0
    if total_sum >= 0:
        return start

    return -1


class Solution(object):
    def generateAbbreviations(self, word):

    def generateAbbreviationsHelper(word, i, cur, res):
        if i == len(word):
            res.append("".join(cur))
            return
        cur.append(word[i])
        generateAbbreviationsHelper(word, i + 1, cur, res)
        cur.pop()
        if not cur or not cur[-1][-1].isdigit():
            for l in xrange(1, len(word) - i + 1):
                cur.append(str(l))
                generateAbbreviationsHelper(word, i + l, cur, res)
                cur.pop()

    res, cur = [], []
    generateAbbreviationsHelper(word, 0, cur, res)
    return res


class Solution(object):
    def generateTheString(self, n):

    result = ["a"] * (n - 1)
    result.append("a" if n % 2 else "b")
    return "".join(result)


class Solution(object):
    def generateParenthesis(self, n):

    result, curr = [], []
    stk = [(1, (n, n))]
    while stk:
        step, args = stk.pop()
        if step == 1:
            left, right = args
            if left == 0 and right == 0:
                result.append("".join(curr))
            if left < right:
                stk.append((3, tuple()))
                stk.append((1, (left, right - 1)))
                stk.append((2, (")")))
            if left > 0:
                stk.append((3, tuple()))
                stk.append((1, (left - 1, right)))
                stk.append((2, ("(")))
        elif step == 2:
            curr.append(args[0])
        elif step == 3:
            curr.pop()
    return result


class Solution2(object):
    def generateParenthesis(self, n):

    def generateParenthesisRecu(left, right, curr, result):
        if left == 0 and right == 0:
            result.append("".join(curr))
        if left > 0:
            curr.append("(")
            generateParenthesisRecu(left - 1, right, curr, result)
            curr.pop()
        if left < right:
            curr.append(")")
            generateParenthesisRecu(left, right - 1, curr, result)
            curr.pop()

    result = []
    generateParenthesisRecu(n, n, [], result)
    return result


import random
import math


class Solution(object):
    def __init__(self, radius, x_center, y_center):

    self.__radius = radius
    self.__x_center = x_center
    self.__y_center = y_center

    def randPoint(self):

    r = (self.__radius) * math.sqrt(random.uniform(0, 1))
    theta = (2 * math.pi) * random.uniform(0, 1)
    return (
        r * math.cos(theta) + self.__x_center,
        r * math.sin(theta) + self.__y_center,
    )


class Solution(object):
    def equalSubstring(self, s, t, maxCost):

    left = 0
    for right in xrange(len(s)):
        maxCost -= abs(ord(s[right]) - ord(t[right]))
        if maxCost < 0:
            maxCost += abs(ord(s[left]) - ord(t[left]))
            left += 1
    return (right + 1) - left


nums = [0, 1]
dp = [0, 1]


class Solution(object):
    def getMaximumGenerated(self, n):

    if n + 1 > len(dp):
        for i in xrange(len(nums), n + 1):
            if i % 2 == 0:
                nums.append(nums[i // 2])
            else:
                nums.append(nums[i // 2] + nums[i // 2 + 1])
            dp.append(max(dp[-1], nums[-1]))
    return dp[n]


class Solution2(object):
    def getMaximumGenerated(self, n):

    if n == 0:
        return 0
    nums = [0] * (n + 1)
    nums[1] = 1
    result = 1
    for i in xrange(2, n + 1):
        if i % 2 == 0:
            nums[i] = nums[i // 2]
        else:
            nums[i] = nums[i // 2] + nums[i // 2 + 1]
        result = max(result, nums[i])
    return result


class Solution(object):
    def maxSum(self, nums1, nums2):

    MOD = 10 ** 9 + 7
    i, j = 0, 0
    result, sum1, sum2 = (
        0,
        0,
        0,
    )
    while i != len(nums1) or j != len(nums2):
        if i != len(nums1) and (j == len(nums2) or nums1[i] < nums2[j]):
            sum1 += nums1[i]
            i += 1
        elif j != len(nums2) and (i == len(nums1) or nums1[i] > nums2[j]):
            sum2 += nums2[j]
            j += 1
        else:
            result = (result + (max(sum1, sum2) + nums1[i])) % MOD
            sum1, sum2 = 0, 0
            i += 1
            j += 1
    return (result + max(sum1, sum2)) % MOD


import collections


class Solution(object):
    def watchedVideosByFriends(self, watchedVideos, friends, id, level):

    curr_level, lookup = set([id]), set([id])
    for _ in xrange(level):
        curr_level = set(
            j for i in curr_level for j in friends[i] if j not in lookup
        )
        lookup |= curr_level
    count = collections.Counter(
        [v for i in curr_level for v in watchedVideos[i]])
    return sorted(count.keys(), key=lambda x: (count[x], x))


class Solution(object):
    def isIdealPermutation(self, A):

    return all(abs(v - i) <= 1 for i, v in enumerate(A))


class Solution(object):
    def interpret(self, command):

    result, i = [], 0
    while i < len(command):
        if command[i] == "G":
            result += ["G"]
            i += 1
        elif command[i] == "(" and command[i + 1] == ")":
            result += ["o"]
            i += 2
        else:
            result += ["al"]
            i += 4
    return "".join(result)


class Solution(object):
    def toGoatLatin(self, S):

    def convert(S):
        vowel = set("aeiouAEIOU")
        for i, word in enumerate(S.split(), 1):
            if word[0] not in vowel:
                word = word[1:] + word[:1]
            yield word + "ma" + "a" * i

    return " ".join(convert(S))


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.rank = [0] * n

    def find_set(self, x):
    stk = []
    while self.set[x] != x:
        stk.append(x)
        x = self.set[x]
    while stk:
        self.set[stk.pop()] = x
    return x

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    if self.rank[x_root] < self.rank[y_root]:
        self.set[x_root] = y_root
    elif self.rank[x_root] > self.rank[y_root]:
        self.set[y_root] = x_root
    else:
        self.set[y_root] = x_root
        self.rank[x_root] += 1
    return True


class Solution(object):
    def areConnected(self, n, threshold, queries):

    union_find = UnionFind(n)
    for i in xrange(threshold + 1, n + 1):

        for j in xrange(2 * i, n + 1, i):
            union_find.union_set(i - 1, j - 1)
    return [
        union_find.find_set(q[0] - 1) == union_find.find_set(q[1] - 1)
        for q in queries
    ]


import collections


class Solution(object):

    def validTree(self, n, edges):
    if len(edges) != n - 1:
        return False

    neighbors = collections.defaultdict(list)
    for u, v in edges:
        neighbors[u].append(v)
        neighbors[v].append(u)

    q = collections.deque([0])
    visited = set([0])
    while q:
        curr = q.popleft()
        for node in neighbors[curr]:
            if node not in visited:
                visited.add(node)
                q.append(node)

    return len(visited) == n


class Solution2(object):

    def validTree(self, n, edges):

    visited_from = [-1] * n
    neighbors = collections.defaultdict(list)
    for u, v in edges:
        neighbors[u].append(v)
        neighbors[v].append(u)

    q = collections.deque([0])
    visited = set([0])
    while q:
        i = q.popleft()
        for node in neighbors[i]:
            if node != visited_from[i]:
                if node in visited:
                    return False
                else:
                    visited.add(node)
                    visited_from[node] = i
                    q.append(node)
    return len(visited) == n


class Solution(object):
    def grayCode(self, n):

    result = [0]
    for i in xrange(n):
        for n in reversed(result):
            result.append(1 << i | n)
    return result


class Solution2(object):
    def grayCode(self, n):

    return [i >> 1 ^ i for i in xrange(1 << n)]


class Solution(object):
    def gcdOfStrings(self, str1, str2):

    def check(s, common):
        i = 0
        for c in s:
            if c != common[i]:
                return False
            i = (i + 1) % len(common)
        return True

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    if not str1 or not str2:
        return ""
    c = gcd(len(str1), len(str2))
    result = str1[:c]
    return result if check(str1, result) and check(str2, result) else ""


class Solution(object):
    def maxSumDivThree(self, nums):

    dp = [0, 0, 0]
    for num in nums:
        for i in [num + x for x in dp]:
            dp[i % 3] = max(dp[i % 3], i)
    return dp[0]


import collections


class Solution(object):
    def gridIllumination(self, N, lamps, queries):

    directions = [
        (0, -1),
        (0, 1),
        (-1, 0),
        (1, 0),
        (-1, -1),
        (1, -1),
        (1, -1),
        (1, 1),
    ]

    lookup = set()
    row = collections.defaultdict(int)
    col = collections.defaultdict(int)
    diag = collections.defaultdict(int)
    anti = collections.defaultdict(int)

    for r, c in lamps:
        lookup.add((r, c))
        row[r] += 1
        col[c] += 1
        diag[r - c] += 1
        anti[r + c] += 1

    result = []
    for r, c in queries:
        if row[r] or col[c] or diag[r - c] or anti[r + c]:
            result.append(1)
        else:
            result.append(0)
        for d in directions:
            nc, nr = r + d[0], c + d[1]
            if not (0 <= nr < N and 0 <= nc < N and (nr, nc) in lookup):
                continue
            lookup.remove((nr, nc))
            row[nr] -= 1
            col[nc] -= 1
            diag[nr - nc] -= 1
            anti[nr + nc] -= 1
    return result


import collections


class Solution(object):
    def groupAnagrams(self, strs):

    anagrams_map, result = collections.defaultdict(list), []
    for s in strs:
        sorted_str = ("").join(sorted(s))
        anagrams_map[sorted_str].append(s)
    for anagram in anagrams_map.values():
        anagram.sort()
        result.append(anagram)
    return result


import collections


class Solution(object):

    def groupStrings(self, strings):
    groups = collections.defaultdict(list)
    for s in strings:
        groups[self.hashStr(s)].append(s)

    result = []
    for key, val in groups.iteritems():
        result.append(sorted(val))

    return result

    def hashStr(self, s):
    base = ord(s[0])
    hashcode = ""
    for i in xrange(len(s)):
        if ord(s[i]) - base >= 0:
            hashcode += unichr(ord("a") + ord(s[i]) - base)
        else:
            hashcode += unichr(ord("a") + ord(s[i]) - base + 26)
    return hashcode


import collections


class Solution(object):
    def groupThePeople(self, groupSizes):

    groups, result = collections.defaultdict(list), []
    for i, size in enumerate(groupSizes):
        groups[size].append(i)
        if len(groups[size]) == size:
            result.append(groups.pop(size))
    return result


class Solution(object):
    def numSpecialEquivGroups(self, A):

    def count(word):
        result = [0] * 52
        for i, letter in enumerate(word):
            result[ord(letter) - ord("a") + 26 * (i % 2)] += 1
        return tuple(result)

    return len({count(word) for word in A})


class Solution(object):
    def maxSatisfied(self, customers, grumpy, X):

    result, max_extra, extra = 0, 0, 0
    for i in xrange(len(customers)):
        result += 0 if grumpy[i] else customers[i]
        extra += customers[i] if grumpy[i] else 0
        if i >= X:
            extra -= customers[i - X] if grumpy[i - X] else 0
        max_extra = max(max_extra, extra)
    return result + max_extra


class Solution(object):
    def getMoneyAmount(self, n):

    pay = [[0] * n for _ in xrange(n + 1)]
    for i in reversed(xrange(n)):
        for j in xrange(i + 1, n):
            pay[i][j] = min(
                k + 1 + max(pay[i][k - 1], pay[k + 1][j]) for k in xrange(i, j + 1)
            )
    return pay[0][n - 1]


class Solution(object):
    def guessNumber(self, n):

    left, right = 1, n
    while left <= right:
        mid = left + (right - left) / 2
        if guess(mid) <= 0:
            right = mid - 1
        else:
            left = mid + 1
    return left


class ArrayReader(object):
    def query(self, a, b, c, d):

    pass

    def length(self):

    pass


class Solution(object):
    def guessMajority(self, reader):

    count_a, count_b, idx_b = 1, 0, None
    value_0_1_2_3 = reader.query(0, 1, 2, 3)
    for i in reversed(xrange(4, reader.length())):
        value_0_1_2_i = reader.query(0, 1, 2, i)
        if value_0_1_2_i == value_0_1_2_3:
            count_a = count_a + 1
        else:
            count_b, idx_b = count_b + 1, i
    value_0_1_2_4 = value_0_1_2_i
    for i in xrange(3):
        value_a_b_3_4 = reader.query(*[v for v in [0, 1, 2, 3, 4] if v != i])
        if value_a_b_3_4 == value_0_1_2_4:
            count_a = count_a + 1
        else:
            count_b, idx_b = count_b + 1, i
    if count_a == count_b:
        return -1
    return 3 if count_a > count_b else idx_b


import collections
import itertools


class Solution(object):
    def findSecretWord(self, wordlist, master):

    possible = range(len(wordlist))
    n = 0
    while n < 6:
        count = [collections.Counter(w[i] for w in wordlist)
                 for i in xrange(6)]
        guess = max(
            possible,
            key=lambda x: sum(count[i][c] for i, c in enumerate(wordlist[x])),
        )
        n = master.guess(wordlist[guess])
        possible = [
            j
            for j in possible
            if sum(a == b for a, b in itertools.izip(wordlist[guess], wordlist[j]))
            == n
        ]


class Solution2(object):
    def findSecretWord(self, wordlist, master):

    def solve(H, possible):
        min_max_group, best_guess = possible, None
        for guess in possible:
            groups = [[] for _ in xrange(7)]
            for j in possible:
                if j != guess:
                    groups[H[guess][j]].append(j)
            max_group = max(groups, key=len)
            if len(max_group) < len(min_max_group):
                min_max_group, best_guess = max_group, guess
        return best_guess

    H = [
        [
            sum(a == b for a, b in itertools.izip(wordlist[i], wordlist[j]))
            for j in xrange(len(wordlist))
        ]
        for i in xrange(len(wordlist))
    ]
    possible = range(len(wordlist))
    n = 0
    while n < 6:
        guess = solve(H, possible)
        n = master.guess(wordlist[guess])
        possible = [j for j in possible if H[guess][j] == n]


class Solution3(object):
    def findSecretWord(self, wordlist, master):

    def solve(H, possible):
        min_max_group, best_guess = possible, None
        for guess in possible:
            groups = [[] for _ in xrange(7)]
            for j in possible:
                if j != guess:
                    groups[H[guess][j]].append(j)
            max_group = groups[0]
            if len(max_group) < len(min_max_group):
                min_max_group, best_guess = max_group, guess
        return best_guess

    H = [
        [
            sum(a == b for a, b in itertools.izip(wordlist[i], wordlist[j]))
            for j in xrange(len(wordlist))
        ]
        for i in xrange(len(wordlist))
    ]
    possible = range(len(wordlist))
    n = 0
    while n < 6:
        guess = solve(H, possible)
        n = master.guess(wordlist[guess])
        possible = [j for j in possible if H[guess][j] == n]


class Solution(object):
    def hIndex(self, citations):

    n = len(citations)
    left, right = 0, n - 1
    while left <= right:
        mid = (left + right) / 2
        if citations[mid] >= n - mid:
            right = mid - 1
        else:
            left = mid + 1
    return n - left


class Solution(object):
    def hIndex(self, citations):

    n = len(citations)
    count = [0] * (n + 1)
    for x in citations:

        if x >= n:
            count[n] += 1
        else:
            count[x] += 1

    h = 0
    for i in reversed(xrange(0, n + 1)):
        h += count[i]
        if h >= i:
            return i
    return h


class Solution2(object):
    def hIndex(self, citations):

    citations.sort(reverse=True)
    h = 0
    for x in citations:
        if x >= h + 1:
            h += 1
        else:
            break
    return h


class Solution3(object):
    def hIndex(self, citations):

    return sum(x >= i + 1 for i, x in enumerate(sorted(citations, reverse=True)))


class Solution(object):
    def hammingDistance(self, x, y):

    distance = 0
    z = x ^ y
    while z:
        distance += 1
        z &= z - 1
    return distance

    def hammingDistance2(self, x, y):

    return bin(x ^ y).count("1")


from collections import Counter
from heapq import heapify, heappop


class Solution(object):
    def isNStraightHand(self, hand, W):

    if len(hand) % W:
        return False

    counts = Counter(hand)
    min_heap = list(hand)
    heapify(min_heap)
    for _ in xrange(len(min_heap) // W):
        while counts[min_heap[0]] == 0:
            heappop(min_heap)
        start = heappop(min_heap)
        for _ in xrange(W):
            counts[start] -= 1
            if counts[start] < 0:
                return False
            start += 1
    return True


class Solution(object):
    def numberOfWays(self, num_people):

    MOD = 10 ** 9 + 7

    def inv(x, m):
        return pow(x, m - 2, m)

    def nCr(n, k, m):
        if n - k < k:
            return nCr(n, n - k, m)
        result = 1
        for i in xrange(1, k + 1):
            result = result * (n - k + i) * inv(i, m) % m
        return result

    n = num_people // 2
    return nCr(2 * n, n, MOD) * inv(n + 1, MOD) % MOD


class Solution2(object):
    def numberOfWays(self, num_people):

    MOD = 10 ** 9 + 7
    dp = [0] * (num_people // 2 + 1)
    dp[0] = 1
    for k in xrange(1, num_people // 2 + 1):
        for i in xrange(k):
            dp[k] = (dp[k] + dp[i] * dp[k - 1 - i]) % MOD
    return dp[num_people // 2]


class Solution(object):

    def isHappy(self, n):
    lookup = {}
    while n != 1 and n not in lookup:
        lookup[n] = True
        n = self.nextNumber(n)
    return n == 1

    def nextNumber(self, n):
    new = 0
    for char in str(n):
        new += int(char) ** 2
    return new


import bisect


class Solution(object):
    def findRadius(self, houses, heaters):

    heaters.sort()
    min_radius = 0
    for house in houses:
        equal_or_larger = bisect.bisect_left(heaters, house)
        curr_radius = float("inf")
        if equal_or_larger != len(heaters):
            curr_radius = heaters[equal_or_larger] - house
        if equal_or_larger != 0:
            smaller = equal_or_larger - 1
            curr_radius = min(curr_radius, house - heaters[smaller])
        min_radius = max(min_radius, curr_radius)
    return min_radius


import itertools


class Solution(object):
    def heightChecker(self, heights):

    return sum(i != j for i, j in itertools.izip(heights, sorted(heights)))


class Solution(object):
    def toHexspeak(self, num):

    lookup = {0: "O", 1: "I"}
    for i in xrange(6):
        lookup[10 + i] = chr(ord("A") + i)
    result = []
    n = int(num)
    while n:
        n, r = divmod(n, 16)
        if r not in lookup:
            return "ERROR"
        result.append(lookup[r])
    return "".join(reversed(result))


class Solution2(object):
    def toHexspeak(self, num):

    result = hex(int(num)).upper()[2:].replace("0", "O").replace("1", "I")
    return result if all(c in "ABCDEFOI" for c in result) else "ERROR"


import collections
import heapq


class Solution(object):
    def highFive(self, items):

    min_heaps = collections.defaultdict(list)
    for i, val in items:
        heapq.heappush(min_heaps[i], val)
        if len(min_heaps[i]) > 5:
            heapq.heappop(min_heaps[i])
    return [[i, sum(min_heaps[i]) // len(min_heaps[i])] for i in sorted(min_heaps)]


class Solution(object):

    def rob(self, nums):
    if len(nums) == 0:
        return 0

    if len(nums) == 1:
        return nums[0]

    return max(
        self.robRange(nums, 0, len(nums) -
                      1), self.robRange(nums, 1, len(nums))
    )

    def robRange(self, nums, start, end):
    num_i, num_i_1 = nums[start], 0
    for i in xrange(start + 1, end):
        num_i_1, num_i_2 = num_i, num_i_1
        num_i = max(nums[i] + num_i_2, num_i_1)

    return num_i


class Solution(object):
    def rob(self, root):

    def robHelper(root):
        if not root:
            return (0, 0)
        left, right = robHelper(root.left), robHelper(root.right)
        return (root.val + left[1] + right[1], max(left) + max(right))

    return max(robHelper(root))


class Solution(object):

    def rob(self, nums):

    last, now = 0, 0
    for i in nums:
        last, now = now, max(last + i, now)
    return now


class Solution(object):
    def maxNumberOfApples(self, arr):

    LIMIT = 5000
    arr.sort()
    result, total = 0, 0
    for x in arr:
        if total + x > LIMIT:
            break
        total += x
        result += 1
    return result


import collections


class Solution(object):
    def smallerNumbersThanCurrent(self, nums):

    count = collections.Counter(nums)
    for i in xrange(max(nums) + 1):
        count[i] += count[i - 1]
    return [count[i - 1] for i in nums]


import bisect


class Solution2(object):
    def smallerNumbersThanCurrent(self, nums):

    sorted_nums = sorted(nums)
    return [bisect.bisect_left(sorted_nums, i) for i in nums]


import collections


class AhoNode(object):
    def __init__(self):
    self.children = collections.defaultdict(AhoNode)
    self.indices = []
    self.suffix = None
    self.output = None


class AhoTrie(object):
    def step(self, letter):
    while self.__node and letter not in self.__node.children:
        self.__node = self.__node.suffix
    self.__node = self.__node.children[letter] if self.__node else self.__root
    return self.__get_ac_node_outputs(self.__node)

    def __init__(self, patterns):
    self.__root = self.__create_ac_trie(patterns)
    self.__node = self.__create_ac_suffix_and_output_links(self.__root)

    def __create_ac_trie(self, patterns):
    root = AhoNode()
    for i, pattern in enumerate(patterns):
        node = root
        for c in pattern:
            node = node.children[c]
        node.indices.append(i)
    return root

    def __create_ac_suffix_and_output_links(self, root):
    queue = collections.deque()
    for node in root.children.itervalues():
        queue.append(node)
        node.suffix = root

    while queue:
        node = queue.popleft()
        for c, child in node.children.iteritems():
            queue.append(child)
            suffix = node.suffix
            while suffix and c not in suffix.children:
                suffix = suffix.suffix
            child.suffix = suffix.children[c] if suffix else root
            child.output = (
                child.suffix if child.suffix.indices else child.suffix.output
            )

    return root

    def __get_ac_node_outputs(self, node):
    result = []
    for i in node.indices:
        result.append(i)
    output = node.output
    while output:
        for i in output.indices:
            result.append(i)
        output = output.output
    return result


class Solution(object):
    def entityParser(self, text):

    patterns = ["&quot;", "&apos;", "&amp;", "&gt;", "&lt;", "&frasl;"]
    chars = ['"', "'", "&", ">", "<", "/"]
    trie = AhoTrie(patterns)
    positions = []
    for i in xrange(len(text)):
        for j in trie.step(text[i]):
            positions.append([i - len(patterns[j]) + 1, j])
    result = []
    i, j = 0, 0
    while i != len(text):
        if j == len(positions) or i != positions[j][0]:
            result.append(text[i])
            i += 1
        else:
            result.append(chars[positions[j][1]])
            i += len(patterns[positions[j][1]])
            j += 1
    return "".join(result)


class Solution2(object):
    def entityParser(self, text):

    patterns = ["&quot;", "&apos;", "&amp;", "&gt;", "&lt;", "&frasl;"]
    chars = ['"', "'", "&", ">", "<", "/"]
    result = []
    i, j = 0, 0
    while i != len(text):
        if text[i] != "&":
            result.append(text[i])
            i += 1
        else:
            for j, pattern in enumerate(patterns):
                if pattern == text[i: i + len(pattern)]:
                    result.append(chars[j])
                    i += len(pattern)
                    break
            else:
                result.append(text[i])
                i += 1
    return "".join(result)


class Solution(object):
    def largestOverlap(self, A, B):

    count = [0] * (2 * len(A) - 1) ** 2
    for i, row in enumerate(A):
        for j, v in enumerate(row):
            if not v:
                continue
            for i2, row2 in enumerate(B):
                for j2, v2 in enumerate(row2):
                    if not v2:
                        continue
                    count[
                        (len(A) - 1 + i - i2) * (2 * len(A) - 1)
                        + len(A)
                        - 1
                        + j
                        - j2
                    ] += 1
    return max(count)


class Solution(object):
    def imageSmoother(self, M):

    def getGray(M, i, j):
        total, count = 0, 0.0
        for r in xrange(-1, 2):
            for c in xrange(-1, 2):
                ii, jj = i + r, j + c
                if 0 <= ii < len(M) and 0 <= jj < len(M[0]):
                    total += M[ii][jj]
                    count += 1.0
        return int(total / count)

    result = [[0 for _ in xrange(len(M[0]))] for _ in xrange(len(M))]
    for i in xrange(len(M)):
        for j in xrange(len(M[0])):
            result[i][j] = getGray(M, i, j)
    return result


import collections


class MagicDictionary(object):
    def __init__(self):

    def _trie(): return collections.defaultdict(_trie)
    self.trie = _trie()

    def buildDict(self, dictionary):

    for word in dictionary:
        reduce(dict.__getitem__, word, self.trie).setdefault("_end")

    def search(self, word):

    def find(word, curr, i, mistakeAllowed):
        if i == len(word):
            return "_end" in curr and not mistakeAllowed

        if word[i] not in curr:
            return (
                any(find(word, curr[c], i + 1, False)
                    for c in curr if c != "_end")
                if mistakeAllowed
                else False
            )

        if mistakeAllowed:
            return find(word, curr[word[i]], i + 1, True) or any(
                find(word, curr[c], i + 1, False)
                for c in curr
                if c not in ("_end", word[i])
            )
        return find(word, curr[word[i]], i + 1, False)

    return find(word, self.trie, 0, True)


class Queue(object):

    def __init__(self):
    self.A, self.B = [], []

    def push(self, x):
    self.A.append(x)

    def pop(self):
    self.peek()
    return self.B.pop()

    def peek(self):
    if not self.B:
        while self.A:
            self.B.append(self.A.pop())
    return self.B[-1]

    def empty(self):
    return not self.A and not self.B


import random


def rand7():
    return random.randint(1, 7)


class Solution(object):
    def __init__(self):
    self.__cache = []

    def rand10(self):

    def generate(cache):
        n = 32
        curr = sum((rand7() - 1) * (7 ** i) for i in xrange(n))
        rang = 7 ** n
        while curr < rang // 10 * 10:
            cache.append(curr % 10 + 1)
            curr /= 10
            rang /= 10

    while not self.__cache:
        generate(self.__cache)
    return self.__cache.pop()


class Solution2(object):
    def rand10(self):

    while True:
        x = (rand7() - 1) * 7 + (rand7() - 1)
        if x < 40:
            return x % 10 + 1


import collections


class Queue(object):
    def __init__(self):
    self.data = collections.deque()

    def push(self, x):
    self.data.append(x)

    def peek(self):
    return self.data[0]

    def pop(self):
    return self.data.popleft()

    def size(self):
    return len(self.data)

    def empty(self):
    return len(self.data) == 0


class Stack(object):

    def __init__(self):
    self.q_ = Queue()

    def push(self, x):
    self.q_.push(x)
    for _ in xrange(self.q_.size() - 1):
        self.q_.push(self.q_.pop())

    def pop(self):
    self.q_.pop()

    def top(self):
    return self.q_.peek()

    def empty(self):
    return self.q_.empty()


class Stack2(object):

    def __init__(self):
    self.q_ = Queue()
    self.top_ = None

    def push(self, x):
    self.q_.push(x)
    self.top_ = x

    def pop(self):
    for _ in xrange(self.q_.size() - 1):
        self.top_ = self.q_.pop()
        self.q_.push(self.top_)
    self.q_.pop()

    def top(self):
    return self.top_

    def empty(self):
    return self.q_.empty()


class Solution(object):
    def strStr(self, haystack, needle):

    if not needle:
        return 0

    return self.KMP(haystack, needle)

    def KMP(self, text, pattern):
    prefix = self.getPrefix(pattern)
    j = -1
    for i in xrange(len(text)):
        while j > -1 and pattern[j + 1] != text[i]:
            j = prefix[j]
        if pattern[j + 1] == text[i]:
            j += 1
        if j == len(pattern) - 1:
            return i - j
    return -1

    def getPrefix(self, pattern):
    prefix = [-1] * len(pattern)
    j = -1
    for i in xrange(1, len(pattern)):
        while j > -1 and pattern[j + 1] != pattern[i]:
            j = prefix[j]
        if pattern[j + 1] == pattern[i]:
            j += 1
        prefix[i] = j
    return prefix


class Solution2(object):
    def strStr(self, haystack, needle):

    for i in xrange(len(haystack) - len(needle) + 1):
        if haystack[i: i + len(needle)] == needle:
            return i
    return -1


class TrieNode(object):

    def __init__(self):
    self.is_string = False
    self.leaves = {}


class Trie(object):
    def __init__(self):
    self.root = TrieNode()

    def insert(self, word):
    cur = self.root
    for c in word:
        if not c in cur.leaves:
            cur.leaves[c] = TrieNode()
        cur = cur.leaves[c]
    cur.is_string = True

    def search(self, word):
    node = self.childSearch(word)
    if node:
        return node.is_string
    return False

    def startsWith(self, prefix):
    return self.childSearch(prefix) is not None

    def childSearch(self, word):
    cur = self.root
    for c in word:
        if c in cur.leaves:
            cur = cur.leaves[c]
        else:
            return None
    return cur


class Solution(object):
    def sortString(self, s):

    result, count = [], [0] * 26
    for c in s:
        count[ord(c) - ord("a")] += 1
    while len(result) != len(s):
        for c in xrange(len(count)):
            if not count[c]:
                continue
            result.append(chr(ord("a") + c))
            count[c] -= 1
        for c in reversed(xrange(len(count))):
            if not count[c]:
                continue
            result.append(chr(ord("a") + c))
            count[c] -= 1
    return "".join(result)


import collections


class Solution2(object):
    def sortString(self, s):

    result, count, desc = [], collections.Counter(s), False
    while count:
        for c in sorted(count.keys(), reverse=desc):
            result.append(c)
            count[c] -= 1
            if not count[c]:
                del count[c]
        desc = not desc
    return "".join(result)


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def increasingBST(self, root):

    def increasingBSTHelper(root, tail):
        if not root:
            return tail
        result = increasingBSTHelper(root.left, root)
        root.left = None
        root.right = increasingBSTHelper(root.right, tail)
        return result

    return increasingBSTHelper(root, None)


class Solution(object):
    def findSubsequences(self, nums):

    def findSubsequencesHelper(nums, pos, seq, result):
        if len(seq) >= 2:
            result.append(list(seq))
        lookup = set()
        for i in xrange(pos, len(nums)):
            if (not seq or nums[i] >= seq[-1]) and nums[i] not in lookup:
                lookup.add(nums[i])
                seq.append(nums[i])
                findSubsequencesHelper(nums, i + 1, seq, result)
                seq.pop()

    result, seq = [], []
    findSubsequencesHelper(nums, 0, seq, result)
    return result


import bisect


class Solution(object):
    def increasingTriplet(self, nums):

    min_num, a, b = float("inf"), float("inf"), float("inf")
    for c in nums:
        if min_num >= c:
            min_num = c
        elif b >= c:
            a, b = min_num, c
        else:
            return True
    return False


class Solution_Generalization(object):
    def increasingTriplet(self, nums):

    def increasingKUplet(nums, k):
        inc = [float("inf")] * (k - 1)
        for num in nums:
            i = bisect.bisect_left(inc, num)
            if i >= k - 1:
                return True
            inc[i] = num
        return k == 0

    return increasingKUplet(nums, 3)


import collections


class AhoNode(object):
    def __init__(self):
    self.children = collections.defaultdict(AhoNode)
    self.indices = []
    self.suffix = None
    self.output = None


class AhoTrie(object):
    def step(self, letter):
    while self.__node and letter not in self.__node.children:
        self.__node = self.__node.suffix
    self.__node = self.__node.children[letter] if self.__node else self.__root
    return self.__get_ac_node_outputs(self.__node)

    def __init__(self, patterns):
    self.__root = self.__create_ac_trie(patterns)
    self.__node = self.__create_ac_suffix_and_output_links(self.__root)

    def __create_ac_trie(self, patterns):
    root = AhoNode()
    for i, pattern in enumerate(patterns):
        node = root
        for c in pattern:
            node = node.children[c]
        node.indices.append(i)
    return root

    def __create_ac_suffix_and_output_links(self, root):
    queue = collections.deque()
    for node in root.children.itervalues():
        queue.append(node)
        node.suffix = root

    while queue:
        node = queue.popleft()
        for c, child in node.children.iteritems():
            queue.append(child)
            suffix = node.suffix
            while suffix and c not in suffix.children:
                suffix = suffix.suffix
            child.suffix = suffix.children[c] if suffix else root
            child.output = (
                child.suffix if child.suffix.indices else child.suffix.output
            )

    return root

    def __get_ac_node_outputs(self, node):
    result = []
    for i in node.indices:
        result.append(i)
    output = node.output
    while output:
        for i in output.indices:
            result.append(i)
        output = output.output
    return result


class Solution(object):
    def indexPairs(self, text, words):

    result = []
    reversed_words = [w[::-1] for w in words]
    trie = AhoTrie(reversed_words)
    for i in reversed(xrange(len(text))):
        for j in trie.step(text[i]):
            result.append([i, i + len(reversed_words[j]) - 1])
    result.reverse()
    return result


class Node(object):
    def __init__(self, val, left, right, parent):
    self.val = val
    self.left = left
    self.right = right
    self.parent = parent


class Solution(object):
    def inorderSuccessor(self, node):

    if not node:
        return None

    if node.right:
        node = node.right
        while node.left:
            node = node.left
        return node

    while node.parent and node.parent.right is node:
        node = node.parent
    return node.parent


class Solution(object):
    def inorderSuccessor(self, root, p):

    if p and p.right:
        p = p.right
        while p.left:
            p = p.left
        return p

    successor = None
    while root and root != p:
        if root.val > p.val:
            successor = root
            root = root.left
        else:
            root = root.right

    return successor


from random import randint
from collections import defaultdict


class RandomizedCollection(object):
    def __init__(self):

    self.__list = []
    self.__used = defaultdict(list)

    def insert(self, val):

    has = val in self.__used

    self.__list += ((val, len(self.__used[val])),)
    self.__used[val] += (len(self.__list) - 1,)

    return not has

    def remove(self, val):

    if val not in self.__used:
        return False

    self.__used[self.__list[-1][0]][self.__list[-1][1]] = self.__used[val][-1]
    self.__list[self.__used[val][-1]], self.__list[-1] = (
        self.__list[-1],
        self.__list[self.__used[val][-1]],
    )

    self.__used[val].pop()
    if not self.__used[val]:
        self.__used.pop(val)
    self.__list.pop()

    return True

    def getRandom(self):

    return self.__list[randint(0, len(self.__list) - 1)][0]


from random import randint


class RandomizedSet(object):
    def __init__(self):

    self.__set = []
    self.__used = {}

    def insert(self, val):

    if val in self.__used:
        return False

    self.__set += (val,)
    self.__used[val] = len(self.__set) - 1

    return True

    def remove(self, val):

    if val not in self.__used:
        return False

    self.__used[self.__set[-1]] = self.__used[val]
    self.__set[self.__used[val]], self.__set[-1] = (
        self.__set[-1],
        self.__set[self.__used[val]],
    )

    self.__used.pop(val)
    self.__set.pop()

    return True

    def getRandom(self):

    return self.__set[randint(0, len(self.__set) - 1)]


class Solution(object):
    def insert(self, intervals, newInterval):

    result = []
    i = 0
    while i < len(intervals) and newInterval[0] > intervals[i][1]:
        result += (intervals[i],)
        i += 1
    while i < len(intervals) and newInterval[1] >= intervals[i][0]:
        newInterval = [
            min(newInterval[0], intervals[i][0]),
            max(newInterval[1], intervals[i][1]),
        ]
        i += 1
    result.append(newInterval)
    result.extend(intervals[i:])
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def insertIntoBST(self, root, val):

    curr, parent = root, None
    while curr:
        parent = curr
        if val <= curr.val:
            curr = curr.left
        else:
            curr = curr.right
    if not parent:
        root = TreeNode(val)
    elif val <= parent.val:
        parent.left = TreeNode(val)
    else:
        parent.right = TreeNode(val)
    return root


class Solution2(object):
    def insertIntoBST(self, root, val):

    if not root:
        root = TreeNode(val)
    else:
        if val <= root.val:
            root.left = self.insertIntoBST(root.left, val)
        else:
            root.right = self.insertIntoBST(root.right, val)
    return root


class Node(object):
    def __init__(self, val, next):
    self.val = val
    self.next = next


class Solution(object):
    def insert(self, head, insertVal):

    def insertAfter(node, val):
        node.next = Node(val, node.next)

    if not head:
        node = Node(insertVal, None)
        node.next = node
        return node

    curr = head
    while True:
        if curr.val < curr.next.val:
            if curr.val <= insertVal and insertVal <= curr.next.val:
                insertAfter(curr, insertVal)
                break
        elif curr.val > curr.next.val:
            if curr.val <= insertVal or insertVal <= curr.next.val:
                insertAfter(curr, insertVal)
                break
        else:
            if curr.next == head:
                insertAfter(curr, insertVal)
                break
        curr = curr.next
    return head


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self:
        return "{} -> {}".format(self.val, repr(self.next))
    else:
        return "Nil"


class Solution(object):

    def insertionSortList(self, head):
    if head is None or self.isSorted(head):
        return head

    dummy = ListNode(-2147483648)
    dummy.next = head
    cur, sorted_tail = head.next, head
    while cur:
        prev = dummy
        while prev.next.val < cur.val:
            prev = prev.next
        if prev == sorted_tail:
            cur, sorted_tail = cur.next, cur
        else:
            cur.next, prev.next, sorted_tail.next = prev.next, cur, cur.next
            cur = sorted_tail.next

    return dummy.next

    def isSorted(self, head):
    while head and head.next:
        if head.val > head.next.val:
            return False
        head = head.next
    return True


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def sufficientSubset(self, root, limit):

    if not root:
        return None
    if not root.left and not root.right:
        return None if root.val < limit else root
    root.left = self.sufficientSubset(root.left, limit - root.val)
    root.right = self.sufficientSubset(root.right, limit - root.val)
    if not root.left and not root.right:
        return None
    return root


class Solution(object):
    def integerBreak(self, n):

    if n < 4:
        return n - 1

    res = 0
    if n % 3 == 0:
        res = 3 ** (n // 3)
    elif n % 3 == 2:
        res = 3 ** (n // 3) * 2
    else:
        res = 3 ** (n // 3 - 1) * 4
    return res


class Solution2(object):
    def integerBreak(self, n):

    if n < 4:
        return n - 1

    res = [0, 1, 2, 3]
    for i in xrange(4, n + 1):
        res[i % 4] = max(res[(i - 2) % 4] * 2, res[(i - 3) % 4] * 3)
    return res[n % 4]


class Solution(object):
    def integerReplacement(self, n):

    result = 0
    while n != 1:
        b = n & 3
        if n == 3:
            n -= 1
        elif b == 3:
            n += 1
        elif b == 1:
            n -= 1
        else:
            n /= 2
        result += 1

    return result


class Solution2(object):
    def integerReplacement(self, n):

    if n < 4:
        return [0, 0, 1, 2][n]
    if n % 4 in (0, 2):
        return self.integerReplacement(n / 2) + 1
    elif n % 4 == 1:
        return self.integerReplacement((n - 1) / 4) + 3
    else:
        return self.integerReplacement((n + 1) / 4) + 3


class Solution(object):
    def numberToWords(self, num):

    if num == 0:
        return "Zero"

    lookup = {
        0: "Zero",
        1: "One",
        2: "Two",
        3: "Three",
        4: "Four",
        5: "Five",
        6: "Six",
        7: "Seven",
        8: "Eight",
        9: "Nine",
        10: "Ten",
        11: "Eleven",
        12: "Twelve",
        13: "Thirteen",
        14: "Fourteen",
        15: "Fifteen",
        16: "Sixteen",
        17: "Seventeen",
        18: "Eighteen",
        19: "Nineteen",
        20: "Twenty",
        30: "Thirty",
        40: "Forty",
        50: "Fifty",
        60: "Sixty",
        70: "Seventy",
        80: "Eighty",
        90: "Ninety",
    }
    unit = ["", "Thousand", "Million", "Billion"]

    res, i = [], 0
    while num:
        cur = num % 1000
        if num % 1000:
            res.append(self.threeDigits(cur, lookup, unit[i]))
        num //= 1000
        i += 1
    return " ".join(res[::-1])

    def threeDigits(self, num, lookup, unit):
    res = []
    if num / 100:
        res = [lookup[num / 100] + " " + "Hundred"]
    if num % 100:
        res.append(self.twoDigits(num % 100, lookup))
    if unit != "":
        res.append(unit)
    return " ".join(res)

    def twoDigits(self, num, lookup):
    if num in lookup:
        return lookup[num]
    return lookup[(num / 10) * 10] + " " + lookup[num % 10]


class Solution(object):
    def intToRoman(self, num):

    numeral_map = {
        1: "I",
        4: "IV",
        5: "V",
        9: "IX",
        10: "X",
        40: "XL",
        50: "L",
        90: "XC",
        100: "C",
        400: "CD",
        500: "D",
        900: "CM",
        1000: "M",
    }
    keyset, result = sorted(numeral_map.keys()), []

    while num > 0:
        for key in reversed(keyset):
            while num / key > 0:
                num -= key
                result += numeral_map[key]

    return "".join(result)


class Solution(object):

    def isInterleave(self, s1, s2, s3):
    if len(s1) + len(s2) != len(s3):
        return False
    if len(s1) > len(s2):
        return self.isInterleave(s2, s1, s3)
    match = [False for i in xrange(len(s1) + 1)]
    match[0] = True
    for i in xrange(1, len(s1) + 1):
        match[i] = match[i - 1] and s1[i - 1] == s3[i - 1]
    for j in xrange(1, len(s2) + 1):
        match[0] = match[0] and s2[j - 1] == s3[j - 1]
        for i in xrange(1, len(s1) + 1):
            match[i] = (match[i - 1] and s1[i - 1] == s3[i + j - 1]) or (
                match[i] and s2[j - 1] == s3[i + j - 1]
            )
    return match[-1]


class Solution2(object):

    def isInterleave(self, s1, s2, s3):
    if len(s1) + len(s2) != len(s3):
        return False
    match = [[False for i in xrange(len(s2) + 1)] for j in xrange(len(s1) + 1)]
    match[0][0] = True
    for i in xrange(1, len(s1) + 1):
        match[i][0] = match[i - 1][0] and s1[i - 1] == s3[i - 1]
    for j in xrange(1, len(s2) + 1):
        match[0][j] = match[0][j - 1] and s2[j - 1] == s3[j - 1]
    for i in xrange(1, len(s1) + 1):
        for j in xrange(1, len(s2) + 1):
            match[i][j] = (match[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (
                match[i][j - 1] and s2[j - 1] == s3[i + j - 1]
            )
    return match[-1][-1]


class Solution3(object):

    def isInterleave(self, s1, s2, s3):
    self.match = {}
    if len(s1) + len(s2) != len(s3):
        return False
    return self.isInterleaveRecu(s1, s2, s3, 0, 0, 0)

    def isInterleaveRecu(self, s1, s2, s3, a, b, c):
    if repr([a, b]) in self.match.keys():
        return self.match[repr([a, b])]

    if c == len(s3):
        return True

    result = False
    if a < len(s1) and s1[a] == s3[c]:
        result = result or self.isInterleaveRecu(s1, s2, s3, a + 1, b, c + 1)
    if b < len(s2) and s2[b] == s3[c]:
        result = result or self.isInterleaveRecu(s1, s2, s3, a, b + 1, c + 1)

    self.match[repr([a, b])] = result

    return result


class Solution(object):
    def arraysIntersection(self, arr1, arr2, arr3):

    result = []
    i, j, k = 0, 0, 0
    while i != len(arr1) and j != len(arr2) and k != len(arr3):
        if arr1[i] == arr2[j] == arr3[k]:
            result.append(arr1[i])
            i += 1
            j += 1
            k += 1
        else:
            curr = max(arr1[i], arr2[j], arr3[k])
            while i != len(arr1) and arr1[i] < curr:
                i += 1
            while j != len(arr2) and arr2[j] < curr:
                j += 1
            while k != len(arr3) and arr3[k] < curr:
                k += 1
    return result


class Solution2(object):
    def arraysIntersection(self, arr1, arr2, arr3):

    intersect = reduce(set.intersection, map(set, [arr2, arr3]))
    return [x for x in arr1 if x in intersect]


import collections


class Solution(object):
    def intersect(self, nums1, nums2):

    if len(nums1) > len(nums2):
        return self.intersect(nums2, nums1)

    lookup = collections.defaultdict(int)
    for i in nums1:
        lookup[i] += 1

    res = []
    for i in nums2:
        if lookup[i] > 0:
            res += (i,)
            lookup[i] -= 1

    return res

    def intersect2(self, nums1, nums2):

    c = collections.Counter(nums1) & collections.Counter(nums2)
    intersect = []
    for i in c:
        intersect.extend([i] * c[i])
    return intersect


class Solution(object):
    def intersect(self, nums1, nums2):

    if len(nums1) > len(nums2):
        return self.intersect(nums2, nums1)

    def binary_search(compare, nums, left, right, target):
        while left < right:
            mid = left + (right - left) / 2
            if compare(nums[mid], target):
                right = mid
            else:
                left = mid + 1
        return left

    nums1.sort(), nums2.sort()

    res = []
    left = 0
    for i in nums1:
        left = binary_search(lambda x, y: x >= y, nums2, left, len(nums2), i)
        if left != len(nums2) and nums2[left] == i:
            res += (i,)
            left += 1

    return res


class Solution(object):
    def intersect(self, nums1, nums2):

    nums1.sort(), nums2.sort()

    res = []

    it1, it2 = 0, 0
    while it1 < len(nums1) and it2 < len(nums2):
        if nums1[it1] < nums2[it2]:
            it1 += 1
        elif nums1[it1] > nums2[it2]:
            it2 += 1
        else:
            res += (nums1[it1],)
            it1 += 1
            it2 += 1

    return res


class Solution(object):
    def intersect(self, nums1, nums2):

    nums1.sort(), nums2.sort()

    res = []

    it1, it2 = 0, 0
    while it1 < len(nums1) and it2 < len(nums2):
        if nums1[it1] < nums2[it2]:
            it1 += 1
        elif nums1[it1] > nums2[it2]:
            it2 += 1
        else:
            res += (nums1[it1],)
            it1 += 1
            it2 += 1

    return res


class Solution(object):
    def intersection(self, nums1, nums2):

    if len(nums1) > len(nums2):
        return self.intersection(nums2, nums1)

    lookup = set()
    for i in nums1:
        lookup.add(i)

    res = []
    for i in nums2:
        if i in lookup:
            res += (i,)
            lookup.discard(i)

    return res

    def intersection2(self, nums1, nums2):

    return list(set(nums1) & set(nums2))


class Solution2(object):
    def intersection(self, nums1, nums2):

    if len(nums1) > len(nums2):
        return self.intersection(nums2, nums1)

    def binary_search(compare, nums, left, right, target):
        while left < right:
            mid = left + (right - left) / 2
            if compare(nums[mid], target):
                right = mid
            else:
                left = mid + 1
        return left

    nums1.sort(), nums2.sort()

    res = []
    left = 0
    for i in nums1:
        left = binary_search(lambda x, y: x >= y, nums2, left, len(nums2), i)
        if left != len(nums2) and nums2[left] == i:
            res += (i,)
            left = binary_search(lambda x, y: x > y,
                                 nums2, left, len(nums2), i)

    return res


class Solution3(object):
    def intersection(self, nums1, nums2):

    nums1.sort(), nums2.sort()
    res = []

    it1, it2 = 0, 0
    while it1 < len(nums1) and it2 < len(nums2):
        if nums1[it1] < nums2[it2]:
            it1 += 1
        elif nums1[it1] > nums2[it2]:
            it2 += 1
        else:
            if not res or res[-1] != nums1[it1]:
                res += (nums1[it1],)
            it1 += 1
            it2 += 1

    return res


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):

    def getIntersectionNode(self, headA, headB):
    curA, curB = headA, headB
    while curA != curB:
        curA = curA.next if curA else headB
        curB = curB.next if curB else headA
    return curA


class Interval(object):
    def __init__(self, s=0, e=0):
    self.start = s
    self.end = e


class Solution(object):
    def intervalIntersection(self, A, B):

    result = []
    i, j = 0, 0
    while i < len(A) and j < len(B):
        left = max(A[i].start, B[j].start)
        right = min(A[i].end, B[j].end)
        if left <= right:
            result.append(Interval(left, right))
        if A[i].end < B[j].end:
            i += 1
        else:
            j += 1
    return result


import collections


class Solution:
    def invalidTransactions(self, transactions):
    AMOUNT, MINUTES = 1000, 60
    trans = map(
        lambda x: (x[0], int(x[1]), int(x[2]), x[3]),
        (transaction.split(",") for transaction in transactions),
    )
    trans.sort(key=lambda t: t[1])
    trans_indexes = collections.defaultdict(list)
    for i, t in enumerate(trans):
        trans_indexes[t[0]].append(i)
    result = []
    for name, indexes in trans_indexes.iteritems():
        left, right = 0, 0
        for i, t_index in enumerate(indexes):
            t = trans[t_index]
            if t[2] > AMOUNT:
                result.append("{},{},{},{}".format(*t))
                continue
            while (
                left +
                    1 < len(
                        indexes) and trans[indexes[left]][1] < t[1] - MINUTES
            ):
                left += 1
            while (
                right + 1 < len(indexes)
                and trans[indexes[right + 1]][1] <= t[1] + MINUTES
            ):
                right += 1
            for i in xrange(left, right + 1):
                if trans[indexes[i]][3] != t[3]:
                    result.append("{},{},{},{}".format(*t))
                    break
    return result


import collections


class Queue(object):
    def __init__(self):
    self.data = collections.deque()

    def push(self, x):
    self.data.append(x)

    def peek(self):
    return self.data[0]

    def pop(self):
    return self.data.popleft()

    def size(self):
    return len(self.data)

    def empty(self):
    return len(self.data) == 0


class Solution(object):

    def invertTree(self, root):
    if root is not None:
        nodes = Queue()
        nodes.push(root)
        while not nodes.empty():
            node = nodes.pop()
            node.left, node.right = node.right, node.left
            if node.left is not None:
                nodes.push(node.left)
            if node.right is not None:
                nodes.push(node.right)

    return root


class Solution2(object):

    def invertTree(self, root):
    if root is not None:
        nodes = []
        nodes.append(root)
        while nodes:
            node = nodes.pop()
            node.left, node.right = node.right, node.left
            if node.left is not None:
                nodes.append(node.left)
            if node.right is not None:
                nodes.append(node.right)

    return root


class Solution3(object):

    def invertTree(self, root):
    if root is not None:
        root.left, root.right = self.invertTree(root.right), self.invertTree(
            root.left
        )

    return root


class Solution(object):
    def ipToCIDR(self, ip, n):

    def ipToInt(ip):
        result = 0
        for i in ip.split("."):
            result = 256 * result + int(i)
        return result

    def intToIP(n):
        return ".".join(str((n >> i) % 256) for i in (24, 16, 8, 0))

    start = ipToInt(ip)
    result = []
    while n:
        mask = max(33 - (start & ~(start - 1)).bit_length(),
                   33 - n.bit_length())
        result.append(intToIP(start) + "/" + str(mask))
        start += 1 << (32 - mask)
        n -= 1 << (32 - mask)
    return result


import heapq


class Solution(object):
    def findMaximizedCapital(self, k, W, Profits, Capital):

    curr = []
    future = sorted(zip(Capital, Profits), reverse=True)
    for _ in xrange(k):
        while future and future[-1][0] <= W:
            heapq.heappush(curr, -future.pop()[1])
        if curr:
            W -= heapq.heappop(curr)
    return W


class Solution(object):
    def isBipartite(self, graph):

    color = {}
    for node in xrange(len(graph)):
        if node in color:
            continue
        stack = [node]
        color[node] = 0
        while stack:
            curr = stack.pop()
            for neighbor in graph[curr]:
                if neighbor not in color:
                    stack.append(neighbor)
                    color[neighbor] = color[curr] ^ 1
                elif color[neighbor] == color[curr]:
                    return False
    return True


class Solution(object):
    def isSubsequence(self, s, t):

    if not s:
        return True

    i = 0
    for c in t:
        if c == s[i]:
            i += 1
        if i == len(s):
            break
    return i == len(s)


import operator


class Solution(object):
    def islandPerimeter(self, grid):

    count, repeat = 0, 0

    for i in xrange(len(grid)):
        for j in xrange(len(grid[i])):
            if grid[i][j] == 1:
                count += 1
                if i != 0 and grid[i - 1][j] == 1:
                    repeat += 1
                if j != 0 and grid[i][j - 1] == 1:
                    repeat += 1

    return 4 * count - 2 * repeat

    def islandPerimeter2(self, grid):
    return sum(
        sum(map(operator.ne, [0] + row, row + [0]))
        for row in grid + map(list, zip(*grid))
    )


from itertools import izip


class Solution(object):
    def isIsomorphic(self, s, t):

    if len(s) != len(t):
        return False

    s2t, t2s = {}, {}
    for p, w in izip(s, t):
        if w not in s2t and p not in t2s:
            s2t[w] = p
            t2s[p] = w
        elif w not in s2t or s2t[w] != p:

            return False
    return True


class Solution2(object):
    def isIsomorphic(self, s, t):
    if len(s) != len(t):
        return False

    return self.halfIsom(s, t) and self.halfIsom(t, s)

    def halfIsom(self, s, t):
    lookup = {}
    for i in xrange(len(s)):
        if s[i] not in lookup:
            lookup[s[i]] = t[i]
        elif lookup[s[i]] != t[i]:
            return False
    return True


import itertools


class CombinationIterator(object):
    def __init__(self, characters, combinationLength):

    self.__it = itertools.combinations(characters, combinationLength)
    self.__curr = None
    self.__last = characters[-combinationLength:]

    def next(self):

    self.__curr = "".join(self.__it.next())
    return self.__curr

    def hasNext(self):

    return self.__curr != self.__last


import functools


class CombinationIterator2(object):
    def __init__(self, characters, combinationLength):

    self.__characters = characters
    self.__combinationLength = combinationLength
    self.__it = self.__iterative_backtracking()
    self.__curr = None
    self.__last = characters[-combinationLength:]

    def __iterative_backtracking(self):

    def conquer():
        if len(curr) == self.__combinationLength:
            return curr

    def prev_divide(c):
        curr.append(c)

    def divide(i):
        if len(curr) != self.__combinationLength:
            for j in reversed(
                xrange(
                    i,
                    len(self.__characters)
                    - (self.__combinationLength - len(curr) - 1),
                )
            ):
                stk.append(functools.partial(post_divide))
                stk.append(functools.partial(divide, j + 1))
                stk.append(functools.partial(
                    prev_divide, self.__characters[j]))
        stk.append(functools.partial(conquer))

    def post_divide():
        curr.pop()

    curr = []
    stk = [functools.partial(divide, 0)]
    while stk:
        result = stk.pop()()
        if result is not None:
            yield result

    def next(self):

    self.__curr = "".join(next(self.__it))
    return self.__curr

    def hasNext(self):

    return self.__curr != self.__last


class Solution(object):
    def numJewelsInStones(self, J, S):

    lookup = set(J)
    return sum(s in lookup for s in S)


class Solution(object):

    def jump(self, A):
    jump_count = 0
    reachable = 0
    curr_reachable = 0
    for i, length in enumerate(A):
        if i > reachable:
            return -1
        if i > curr_reachable:
            curr_reachable = reachable
            jump_count += 1
        reachable = max(reachable, i + length)
    return jump_count


import collections


class Solution(object):
    def canReach(self, arr, start):

    q, lookup = collections.deque([start]), set([start])
    while q:
        i = q.popleft()
        if not arr[i]:
            return True
        for j in [i - arr[i], i + arr[i]]:
            if 0 <= j < len(arr) and j not in lookup:
                lookup.add(j)
                q.append(j)
    return False


import collections


class Solution(object):
    def minJumps(self, arr):

    groups = collections.defaultdict(list)
    for i, x in enumerate(arr):
        groups[x].append(i)
    q = collections.deque([(0, 0)])
    lookup = set([0])
    while q:
        pos, step = q.popleft()
        if pos == len(arr) - 1:
            break
        neighbors = set(groups[arr[pos]] + [pos - 1, pos + 1])
        groups[arr[pos]] = []
        for p in neighbors:
            if p in lookup or not 0 <= p < len(arr):
                continue
            lookup.add(p)
            q.append((p, step + 1))
    return step


import collections
import itertools


class Solution(object):
    def maxJumps(self, arr, d):

    def dp(arr, d, i, left, right, lookup):
        if lookup[i]:
            return lookup[i]
        lookup[i] = 1
        for j in itertools.chain(left[i], right[i]):

            lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup) + 1)
        return lookup[i]

    left, decreasing_dq = [[] for _ in xrange(len(arr))], collections.deque()
    for i in xrange(len(arr)):
        if decreasing_dq and i - decreasing_dq[0] == d + 1:
            decreasing_dq.popleft()
        while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
            if left[i] and arr[left[i][-1]] != arr[decreasing_dq[-1]]:
                left[i] = []
            left[i].append(decreasing_dq.pop())
        decreasing_dq.append(i)
    right, decreasing_dq = [[] for _ in xrange(len(arr))], collections.deque()
    for i in reversed(xrange(len(arr))):
        if decreasing_dq and decreasing_dq[0] - i == d + 1:
            decreasing_dq.popleft()
        while decreasing_dq and arr[decreasing_dq[-1]] < arr[i]:
            if right[i] and arr[right[i][-1]] != arr[decreasing_dq[-1]]:
                right[i] = []
            right[i].append(decreasing_dq.pop())
        decreasing_dq.append(i)

    lookup = [0] * len(arr)
    return max(
        itertools.imap(
            lambda x: dp(arr, d, x, left, right, lookup), xrange(len(arr))
        )
    )


class Solution2(object):
    def maxJumps(self, arr, d):

    left, decreasing_stk = [[] for _ in xrange(len(arr))], []
    for i in xrange(len(arr)):
        while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
            if i - decreasing_stk[-1] <= d:
                if left[i] and arr[left[i][-1]] != arr[decreasing_stk[-1]]:
                    left[i] = []
                left[i].append(decreasing_stk[-1])
            decreasing_stk.pop()
        decreasing_stk.append(i)
    right, decreasing_stk = [[] for _ in xrange(len(arr))], []
    for i in reversed(xrange(len(arr))):
        while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
            if decreasing_stk[-1] - i <= d:
                if right[i] and arr[right[i][-1]] != arr[decreasing_stk[-1]]:
                    right[i] = []
                right[i].append(decreasing_stk[-1])
            decreasing_stk.pop()
        decreasing_stk.append(i)

    dp = [0] * len(arr)
    for a, i in sorted([a, i] for i, a in enumerate(arr)):
        dp[i] = 1
        for j in itertools.chain(left[i], right[i]):

            dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)


class SegmentTree(object):
    def __init__(
        self,
        N,
        build_fn=lambda x, y: [y] * (2 * x),
        query_fn=max,
        update_fn=lambda x, y: y,
        default_val=0,
    ):
    self.N = N
    self.H = (N - 1).bit_length()
    self.query_fn = query_fn
    self.update_fn = update_fn
    self.default_val = default_val
    self.tree = build_fn(N, default_val)
    self.lazy = [None] * N

    def __apply(self, x, val):
    self.tree[x] = self.update_fn(self.tree[x], val)
    if x < self.N:
        self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h):

    def pull(x):
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(
                self.tree[x * 2], self.tree[x * 2 + 1])
            if self.lazy[x] is not None:
                self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

    L += self.N
    R += self.N
    L0, R0 = L, R
    while L <= R:
        if L & 1:
            self.__apply(L, h)
            L += 1
        if R & 1 == 0:
            self.__apply(R, h)
            R -= 1
        L //= 2
        R //= 2
    pull(L0)
    pull(R0)

    def query(self, L, R):

    def push(x):
        n = 2 ** self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y * 2, self.lazy[y])
                self.__apply(y * 2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    result = self.default_val
    if L > R:
        return result

    L += self.N
    R += self.N
    push(L)
    push(R)
    while L <= R:
        if L & 1:
            result = self.query_fn(result, self.tree[L])
            L += 1
        if R & 1 == 0:
            result = self.query_fn(result, self.tree[R])
            R -= 1
        L //= 2
        R //= 2
    return result

    def __str__(self):
    showList = []
    for i in xrange(self.N):
        showList.append(self.query(i, i))
    return ",".join(map(str, showList))


class Solution3(object):
    def maxJumps(self, arr, d):

    left, decreasing_stk = range(len(arr)), []
    for i in xrange(len(arr)):
        while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
            if i - decreasing_stk[-1] <= d:
                left[i] = decreasing_stk[-1]
            decreasing_stk.pop()
        decreasing_stk.append(i)
    right, decreasing_stk = range(len(arr)), []
    for i in reversed(xrange(len(arr))):
        while decreasing_stk and arr[decreasing_stk[-1]] < arr[i]:
            if decreasing_stk[-1] - i <= d:
                right[i] = decreasing_stk[-1]
            decreasing_stk.pop()
        decreasing_stk.append(i)

    segment_tree = SegmentTree(len(arr))
    for _, i in sorted([x, i] for i, x in enumerate(arr)):
        segment_tree.update(i, i, segment_tree.query(left[i], right[i]) + 1)
    return segment_tree.query(0, len(arr) - 1)


import collections


class Solution(object):
    def maxResult(self, nums, k):

    score = 0
    dq = collections.deque()
    for i, num in enumerate(nums):
        if dq and dq[0][0] == i - k - 1:
            dq.popleft()
        score = num if not dq else dq[0][1] + num
        while dq and dq[-1][1] <= score:
            dq.pop()
        dq.append((i, score))
    return score


class Solution(object):

    def canJump(self, A):
    reachable = 0
    for i, length in enumerate(A):
        if i > reachable:
            break
        reachable = max(reachable, i + length)
    return reachable >= len(A) - 1


from random import randint


class Solution(object):
    def kClosest(self, points, K):

    def dist(point):
        return point[0] ** 2 + point[1] ** 2

    def kthElement(nums, k, compare):
        def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in xrange(left, right):
                if compare(nums[i], nums[right]):
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = randint(left, right)
            new_pivot_idx = PartitionAroundPivot(
                left, right, pivot_idx, nums, compare
            )
            if new_pivot_idx == k:
                return
            elif new_pivot_idx > k:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    kthElement(points, K - 1, lambda a, b: dist(a) < dist(b))
    return points[:K]


import heapq


class Solution2(object):
    def kClosest(self, points, K):

    def dist(point):
        return point[0] ** 2 + point[1] ** 2

    max_heap = []
    for point in points:
        heapq.heappush(max_heap, (-dist(point), point))
        if len(max_heap) > K:
            heapq.heappop(max_heap)
    return [heapq.heappop(max_heap)[1] for _ in xrange(len(max_heap))]


class Solution(object):
    def kConcatenationMaxSum(self, arr, k):

    def max_sub_k_array(arr, k):
        result, curr = float("-inf"), float("-inf")
        for _ in xrange(k):
            for x in arr:
                curr = max(curr + x, x)
                result = max(result, curr)
        return result

    MOD = 10 ** 9 + 7
    if k == 1:
        return max(max_sub_k_array(arr, 1), 0) % MOD
    return (max(max_sub_k_array(arr, 2), 0) + (k - 2) * max(sum(arr), 0)) % MOD


class Solution(object):
    def findPairs(self, nums, k):

    if k < 0:
        return 0
    result, lookup = set(), set()
    for num in nums:
        if num - k in lookup:
            result.add(num - k)
        if num + k in lookup:
            result.add(num)
        lookup.add(num)
    return len(result)


class Solution(object):
    def kEmptySlots(self, flowers, k):

    days = [0] * len(flowers)
    for i in xrange(len(flowers)):
        days[flowers[i] - 1] = i
    result = float("inf")
    i, left, right = 0, 0, k + 1
    while right < len(days):
        if days[i] < days[left] or days[i] <= days[right]:
            if i == right:
                result = min(result, max(days[left], days[right]))
            left, right = i, k + 1 + i
        i += 1
    return -1 if result == float("inf") else result + 1


class Solution(object):
    def kInversePairs(self, n, k):

    M = 1000000007
    dp = [[0] * (k + 1) for _ in xrange(2)]
    dp[0][0] = 1
    for i in xrange(1, n + 1):
        dp[i % 2] = [0] * (k + 1)
        dp[i % 2][0] = 1
        for j in xrange(1, k + 1):
            dp[i % 2][j] = (dp[i % 2][j - 1] + dp[(i - 1) % 2][j]) % M
            if j - i >= 0:
                dp[i % 2][j] = (dp[i % 2][j] - dp[(i - 1) % 2][j - i]) % M
    return dp[n % 2][k]


import collections


class Solution(object):
    def kSimilarity(self, A, B):

    def neighbors(s, B):
        for i, c in enumerate(s):
            if c != B[i]:
                break
        t = list(s)
        for j in xrange(i + 1, len(s)):
            if t[j] == B[i]:
                t[i], t[j] = t[j], t[i]
                yield "".join(t)
                t[j], t[i] = t[i], t[j]

    q = collections.deque([A])
    lookup = set()
    result = 0
    while q:
        for _ in xrange(len(q)):
            s = q.popleft()
            if s == B:
                return result
            for t in neighbors(s, B):
                if t not in lookup:
                    lookup.add(t)
                    q.append(t)
        result += 1


class Solution(object):
    def findKthNumber(self, n, k):

    result = 0

    cnts = [0] * 10
    for i in xrange(1, 10):
        cnts[i] = cnts[i - 1] * 10 + 1

    nums = []
    i = n
    while i:
        nums.append(i % 10)
        i /= 10

    total, target = n, 0
    i = len(nums) - 1
    while i >= 0 and k > 0:
        target = target * 10 + nums[i]
        start = int(i == len(nums) - 1)
        for j in xrange(start, 10):
            candidate = result * 10 + j
            if candidate < target:
                num = cnts[i + 1]
            elif candidate > target:
                num = cnts[i]
            else:
                num = total - cnts[i + 1] * (j - start) - cnts[i] * (9 - j)
            if k > num:
                k -= num
            else:
                result = candidate
                k -= 1
                total = num - 1
                break
        i -= 1

    return result


class Solution2(object):
    def findKthNumber(self, n, k):

    def count(n, prefix):
        result, number = 0, 1
        while prefix <= n:
            result += number
            prefix *= 10
            number *= 10
        result -= max(number / 10 - (n - prefix / 10 + 1), 0)
        return result

    def findKthNumberHelper(n, k, cur, index):
        if cur:
            index += 1
            if index == k:
                return (cur, index)

        i = int(cur == 0)
        while i <= 9:
            cur = cur * 10 + i
            cnt = count(n, cur)
            if k > cnt + index:
                index += cnt
            elif cur <= n:
                result = findKthNumberHelper(n, k, cur, index)
                if result[0]:
                    return result
            i += 1
            cur /= 10
        return (0, index)

    return findKthNumberHelper(n, k, 0, 0)[0]


class Solution(object):
    def kthSmallestPrimeFraction(self, A, K):

    def check(mid, A, K, result):
        tmp = [0] * 2
        count = 0
        j = 0
        for i in xrange(len(A)):
            while j < len(A):
                if i < j and A[i] < A[j] * mid:
                    if tmp[0] == 0 or tmp[0] * A[j] < tmp[1] * A[i]:
                        tmp[0] = A[i]
                        tmp[1] = A[j]
                    break
                j += 1
            count += len(A) - j
        if count == K:
            result[:] = tmp
        return count >= K

    result = []
    left, right = 0.0, 1.0
    while right - left > 1e-8:
        mid = left + (right - left) / 2.0
        if check(mid, A, K, result):
            right = mid
        else:
            left = mid
        if result:
            break
    return result


class Solution(object):
    def kthGrammar(self, N, K):

    def bitCount(n):
        result = 0
        while n:
            n &= n - 1
            result += 1
        return result

    return bitCount(K - 1) % 2


class Solution(object):
    def findWords(self, words):

    rows = [
        set(["q", "w", "e", "r", "t", "y", "u", "i", "o", "p"]),
        set(["a", "s", "d", "f", "g", "h", "j", "k", "l"]),
        set(["z", "x", "c", "v", "b", "n", "m"]),
    ]

    result = []
    for word in words:
        k = 0
        for i in xrange(len(rows)):
            if word[0].lower() in rows[i]:
                k = i
                break
        for c in word:
            if c.lower() not in rows[k]:
                break
        else:
            result.append(word)
    return result


class Solution2(object):
    def findWords(self, words):

    keyboard_rows = ["qwertyuiop", "asdfghjkl", "zxcvbnm"]
    single_row_words = []
    for word in words:
        for row in keyboard_rows:
            if all(letter in row for letter in word.lower()):
                single_row_words.append(word)
    return single_row_words


class Solution(object):
    def canVisitAllRooms(self, rooms):

    lookup = set([0])
    stack = [0]
    while stack:
        node = stack.pop()
        for nei in rooms[node]:
            if nei not in lookup:
                lookup.add(nei)
                if len(lookup) == len(rooms):
                    return True
                stack.append(nei)
    return len(lookup) == len(rooms)


class Solution(object):
    def kidsWithCandies(self, candies, extraCandies):

    max_num = max(candies)
    return [x + extraCandies >= max_num for x in candies]


import collections


class Solution(object):
    def killProcess(self, pid, ppid, kill):

    def killAll(pid, children, killed):
        killed.append(pid)
        for child in children[pid]:
            killAll(child, children, killed)

    result = []
    children = collections.defaultdict(set)
    for i in xrange(len(pid)):
        children[ppid[i]].add(pid[i])
    killAll(kill, children, result)
    return result


class Solution2(object):
    def killProcess(self, pid, ppid, kill):

    def killAll(pid, children, killed):
        killed.append(pid)
        for child in children[pid]:
            killAll(child, children, killed)

    result = []
    children = collections.defaultdict(set)
    for i in xrange(len(pid)):
        children[ppid[i]].add(pid[i])
    q = collections.deque()
    q.append(kill)
    while q:
        p = q.popleft()
        result.append(p)
        for child in children[p]:
            q.append(child)
    return result


import itertools


class Solution(object):
    def knightDialer(self, N):

    def matrix_expo(A, K):
        result = [[int(i == j) for j in xrange(len(A))]
                  for i in xrange(len(A))]
        while K:
            if K % 2:
                result = matrix_mult(result, A)
            A = matrix_mult(A, A)
            K /= 2
        return result

    def matrix_mult(A, B):
        ZB = zip(*B)
        return [
            [sum(a * b for a, b in itertools.izip(row, col)) % M for col in ZB]
            for row in A
        ]

    M = 10 ** 9 + 7
    T = [
        [0, 0, 0, 0, 1, 0, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
        [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
        [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],
        [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],
        [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
        [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 0, 1, 0, 0, 0, 0, 0],
    ]
    return sum(map(sum, matrix_expo(T, N - 1))) % M


class Solution2(object):
    def knightDialer(self, N):

    M = 10 ** 9 + 7
    moves = [
        [4, 6],
        [6, 8],
        [7, 9],
        [4, 8],
        [3, 9, 0],
        [],
        [1, 7, 0],
        [2, 6],
        [1, 3],
        [2, 4],
    ]

    dp = [[1 for _ in xrange(10)] for _ in xrange(2)]
    for i in xrange(N - 1):
        dp[(i + 1) % 2] = [0] * 10
        for j in xrange(10):
            for nei in moves[j]:
                dp[(i + 1) % 2][nei] += dp[i % 2][j]
                dp[(i + 1) % 2][nei] %= M
    return sum(dp[(N - 1) % 2]) % M


class Solution(object):
    def knightProbability(self, N, K, r, c):

    directions = [
        [1, 2],
        [1, -2],
        [2, 1],
        [2, -1],
        [-1, 2],
        [-1, -2],
        [-2, 1],
        [-2, -1],
    ]
    dp = [[[1 for _ in xrange(N)] for _ in xrange(N)] for _ in xrange(2)]
    for step in xrange(1, K + 1):
        for i in xrange(N):
            for j in xrange(N):
                dp[step % 2][i][j] = 0
                for direction in directions:
                    rr, cc = i + direction[0], j + direction[1]
                    if 0 <= cc < N and 0 <= rr < N:
                        dp[step % 2][i][j] += 0.125 * \
                            dp[(step - 1) % 2][rr][cc]

    return dp[K % 2][r][c]


class Solution(object):
    def minEatingSpeed(self, piles, H):

    def possible(piles, H, K):
        return sum((pile - 1) // K + 1 for pile in piles) <= H

    left, right = 1, max(piles)
    while left <= right:
        mid = left + (right - left) // 2
        if possible(piles, H, mid):
            right = mid - 1
        else:
            left = mid + 1
    return left


class TreeAncestor(object):
    def __init__(self, n, parent):

    par = [[p] if p != -1 else [] for p in parent]
    q = [par[i] for i, p in enumerate(parent) if p != -1]
    i = 0
    while q:
        new_q = []
        for p in q:
            if not (i < len(par[p[i]])):
                continue
            p.append(par[p[i]][i])
            new_q.append(p)
        q = new_q
        i += 1
    self.__parent = par

    def getKthAncestor(self, node, k):

    par, i, pow_i_of_2 = self.__parent, 0, 1
    while pow_i_of_2 <= k:
        if k & pow_i_of_2:
            if not (i < len(par[node])):
                return -1
            node = par[node][i]
        i += 1
        pow_i_of_2 *= 2
    return node


import heapq


class KthLargest(object):
    def __init__(self, k, nums):

    self.__k = k
    self.__min_heap = []
    for n in nums:
        self.add(n)

    def add(self, val):

    heapq.heappush(self.__min_heap, val)
    if len(self.__min_heap) > self.__k:
        heapq.heappop(self.__min_heap)
    return self.__min_heap[0]


from random import randint


class Solution(object):
    def findKthLargest(self, nums, k):

    def nth_element(nums, n, compare=lambda a, b: a < b):
        def tri_partition(nums, left, right, target, compare):
            mid = left
            while mid <= right:
                if nums[mid] == target:
                    mid += 1
                elif compare(nums[mid], target):
                    nums[left], nums[mid] = nums[mid], nums[left]
                    left += 1
                    mid += 1
                else:
                    nums[mid], nums[right] = nums[right], nums[mid]
                    right -= 1
            return left, right

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = randint(left, right)
            pivot_left, pivot_right = tri_partition(
                nums, left, right, nums[pivot_idx], compare
            )
            if pivot_left <= n <= pivot_right:
                return
            elif pivot_left > n:
                right = pivot_left - 1
            else:
                left = pivot_right + 1

    nth_element(nums, k - 1, compare=lambda a, b: a > b)
    return nums[k - 1]


class Solution2(object):

    def findKthLargest(self, nums, k):
    left, right = 0, len(nums) - 1
    while left <= right:
        pivot_idx = randint(left, right)
        new_pivot_idx = self.PartitionAroundPivot(left, right, pivot_idx, nums)
        if new_pivot_idx == k - 1:
            return nums[new_pivot_idx]
        elif new_pivot_idx > k - 1:
            right = new_pivot_idx - 1
        else:
            left = new_pivot_idx + 1

    def PartitionAroundPivot(self, left, right, pivot_idx, nums):
    pivot_value = nums[pivot_idx]
    new_pivot_idx = left
    nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
    for i in xrange(left, right):
        if nums[i] > pivot_value:
            nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
            new_pivot_idx += 1

    nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
    return new_pivot_idx


class Solution(object):
    def findKthPositive(self, arr, k):

    def check(arr, k, x):
        return arr[x] - (x + 1) < k

    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if not check(arr, k, mid):
            right = mid - 1
        else:
            left = mid + 1
    return (
        right + 1 + k
    )


class Solution(object):

    def kthSmallest(self, root, k):
    s, cur, rank = [], root, 0

    while s or cur:
        if cur:
            s.append(cur)
            cur = cur.left
        else:
            cur = s.pop()
            rank += 1
            if rank == k:
                return cur.val
            cur = cur.right

    return float("-inf")


from itertools import islice


class Solution2(object):
    def kthSmallest(self, root, k):

    def gen_inorder(root):
        if root:
            for n in gen_inorder(root.left):
                yield n

            yield root.val

            for n in gen_inorder(root.right):
                yield n

    return next(islice(gen_inorder(root), k - 1, k))


from heapq import heappush, heappop


class Solution(object):
    def kthSmallest(self, matrix, k):

    kth_smallest = 0
    min_heap = []

    def push(i, j):
        if len(matrix) > len(matrix[0]):
            if i < len(matrix[0]) and j < len(matrix):
                heappush(min_heap, [matrix[j][i], i, j])
        else:
            if i < len(matrix) and j < len(matrix[0]):
                heappush(min_heap, [matrix[i][j], i, j])

    push(0, 0)
    while min_heap and k > 0:
        kth_smallest, i, j = heappop(min_heap)
        push(i, j + 1)
        if j == 0:
            push(i + 1, 0)
        k -= 1

    return kth_smallest


class Solution(object):
    def kthSmallestPath(self, destination, k):

    def nCr(n, r):
        if n < r:
            return 0
        if n - r < r:
            return nCr(n, n - r)
        c = 1
        for k in xrange(1, r + 1):
            c *= n - k + 1
            c //= k
        return c

    r, c = destination
    result = []
    while r + c:
        count = nCr(r + (c - 1), r)
        if (
            k <= count
        ):
            c -= 1
            result.append("H")
        else:
            k -= count
            r -= 1
            result.append("V")
    return "".join(result)


class Solution(object):
    def findKthNumber(self, m, n, k):

    def count(target, m, n):
        return sum(min(target // i, n) for i in xrange(1, m + 1))

    left, right = 1, m * n
    while left <= right:
        mid = left + (right - left) / 2
        if count(mid, m, n) >= k:
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution(object):
    def largest1BorderedSquare(self, grid):

    top, left = [a[:] for a in grid], [a[:] for a in grid]
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            if not grid[i][j]:
                continue
            if i:
                top[i][j] = top[i - 1][j] + 1
            if j:
                left[i][j] = left[i][j - 1] + 1
    for l in reversed(xrange(1, min(len(grid), len(grid[0])) + 1)):
        for i in xrange(len(grid) - l + 1):
            for j in xrange(len(grid[0]) - l + 1):
                if (
                    min(
                        top[i + l - 1][j],
                        top[i + l - 1][j + l - 1],
                        left[i][j + l - 1],
                        left[i + l - 1][j + l - 1],
                    )
                    >= l
                ):
                    return l * l
    return 0


class Solution(object):
    def largestBSTSubtree(self, root):

    if root is None:
        return 0

    max_size = [1]

    def largestBSTSubtreeHelper(root):
        if root.left is None and root.right is None:
            return 1, root.val, root.val

        left_size, left_min, left_max = 0, root.val, root.val
        if root.left is not None:
            left_size, left_min, left_max = largestBSTSubtreeHelper(root.left)

        right_size, right_min, right_max = 0, root.val, root.val
        if root.right is not None:
            right_size, right_min, right_max = largestBSTSubtreeHelper(
                root.right)

        size = 0
        if (
            (root.left is None or left_size > 0)
            and (root.right is None or right_size > 0)
            and left_max <= root.val <= right_min
        ):
            size = 1 + left_size + right_size
            max_size[0] = max(max_size[0], size)

        return size, left_min, right_max

    largestBSTSubtreeHelper(root)
    return max_size[0]


import collections


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.size = [1] * n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    self.size[max(x_root, y_root)] += self.size[min(x_root, y_root)]
    return True


class Solution(object):
    def largestComponentSize(self, A):

    def primeFactors(i):
        result = []
        d = 2
        if i % d == 0:
            while i % d == 0:
                i //= d
            result.append(d)
        d = 3
        while d * d <= i:
            if i % d == 0:
                while i % d == 0:
                    i //= d
                result.append(d)
            d += 2
        if i > 2:
            result.append(i)
        return result

    union_find = UnionFind(len(A))
    nodesWithCommonFactor = collections.defaultdict(int)
    for i in xrange(len(A)):
        for factor in primeFactors(A[i]):
            if factor not in nodesWithCommonFactor:
                nodesWithCommonFactor[factor] = i
            union_find.union_set(nodesWithCommonFactor[factor], i)
    return max(union_find.size)


class Solution(object):
    def largestDivisibleSubset(self, nums):

    if not nums:
        return []

    nums.sort()
    dp = [1] * len(nums)
    prev = [-1] * len(nums)
    largest_idx = 0
    for i in xrange(len(nums)):
        for j in xrange(i):
            if nums[i] % nums[j] == 0:
                if dp[i] < dp[j] + 1:
                    dp[i] = dp[j] + 1
                    prev[i] = j
        if dp[largest_idx] < dp[i]:
            largest_idx = i

    result = []
    i = largest_idx
    while i != -1:
        result.append(nums[i])
        i = prev[i]
    return result[::-1]


import collections


class Solution(object):
    def largestMerge(self, word1, word2):

    q1 = collections.deque(word1)
    q2 = collections.deque(word2)
    result = []
    while q1 or q2:
        if q1 > q2:
            result.append(q1.popleft())
        else:
            result.append(q2.popleft())
    return "".join(result)


import collections


class Solution(object):
    def largestMultipleOfThree(self, digits):

    lookup = {
        0: [],
        1: [(1,), (4,), (7,), (2, 2), (5, 2), (5, 5), (8, 2), (8, 5), (8, 8)],
        2: [(2,), (5,), (8,), (1, 1), (4, 1), (4, 4), (7, 1), (7, 4), (7, 7)],
    }
    count = collections.Counter(digits)
    for deletes in lookup[sum(digits) % 3]:
        delete_count = collections.Counter(deletes)
        if all(count[k] >= v for k, v in delete_count.iteritems()):
            for k, v in delete_count.iteritems():
                count[k] -= v
            break
    result = "".join(str(d) * count[d] for d in reversed(xrange(10)))
    return "0" if result and result[0] == "0" else result


class Solution2(object):
    def largestMultipleOfThree(self, digits):

    def candidates_gen(r):
        if r == 0:
            return
        for i in xrange(10):
            yield [i]
        for i in xrange(10):
            for j in xrange(i + 1):
                yield [i, j]

    count, r = collections.Counter(digits), sum(digits) % 3
    for deletes in candidates_gen(r):
        delete_count = collections.Counter(deletes)
        if sum(deletes) % 3 == r and all(
            count[k] >= v for k, v in delete_count.iteritems()
        ):
            for k, v in delete_count.iteritems():
                count[k] -= v
            break
    result = "".join(str(d) * count[d] for d in reversed(xrange(10)))
    return "0" if result and result[0] == "0" else result


class Solution(object):
    def dominantIndex(self, nums):

    m = max(nums)
    if all(m >= 2 * x for x in nums if x != m):
        return nums.index(m)
    return -1


class Solution(object):

    def largestNumber(self, num):
    num = [str(x) for x in num]
    num.sort(cmp=lambda x, y: cmp(y + x, x + y))
    largest = "".join(num)
    return largest.lstrip("0") or "0"


class Solution_TLE(object):
    def largestPalindrome(self, n):

    if n == 1:
        return 9

    upper, lower = 10 ** n - 1, 10 ** (n - 1)
    for i in reversed(xrange(lower, upper + 1)):
        candidate = int(str(i) + str(i)[::-1])
        j = upper
        while j * j >= candidate:
            if candidate % j == 0:
                return candidate % 1337
            j -= 1
    return -1


class Solution(object):
    def largestPerimeter(self, A):

    A.sort()
    for i in reversed(xrange(len(A) - 2)):
        if A[i] + A[i + 1] > A[i + 2]:
            return A[i] + A[i + 1] + A[i + 2]
    return 0


class Solution(object):
    def orderOfLargestPlusSign(self, N, mines):

    lookup = {tuple(mine) for mine in mines}
    dp = [[0] * N for _ in xrange(N)]
    result = 0
    for i in xrange(N):
        l = 0
        for j in xrange(N):
            l = 0 if (i, j) in lookup else l + 1
            dp[i][j] = l
        l = 0
        for j in reversed(xrange(N)):
            l = 0 if (i, j) in lookup else l + 1
            dp[i][j] = min(dp[i][j], l)

    for j in xrange(N):
        l = 0
        for i in xrange(N):
            l = 0 if (i, j) in lookup else l + 1
            dp[i][j] = min(dp[i][j], l)
        l = 0
        for i in reversed(xrange(N)):
            l = 0 if (i, j) in lookup else l + 1
            dp[i][j] = min(dp[i][j], l)
            result = max(result, dp[i][j])
    return result


class Solution(object):
    def largestRectangleArea(self, heights):

    stk, result, i = [-1], 0, 0
    for i in xrange(len(heights) + 1):
        while stk[-1] != -1 and (
            i == len(heights) or heights[stk[-1]] >= heights[i]
        ):
            result = max(result, heights[stk.pop()] * ((i - 1) - stk[-1]))
        stk.append(i)
    return result


class Solution(object):
    def largestSubarray(self, nums, k):

    left, right, l = 0, 1, 0
    while right + k - 1 < len(nums) and right + l < len(nums):
        if nums[left + l] == nums[right + l]:
            l += 1
            continue
        if nums[left + l] > nums[right + l]:
            right += l + 1
        else:
            left = max(right, min(left + l + 1, len(nums) - k))
            right = left + 1
        l = 0
    return nums[left: left + k]


class Solution(object):
    def largestSubmatrix(self, matrix):

    for c in xrange(len(matrix[0])):
        h = 0
        for r in xrange(len(matrix)):
            h = h + 1 if matrix[r][c] == 1 else 0
            matrix[r][c] = h
    result = 0
    for row in matrix:
        row.sort()
        for c in xrange(len(row)):
            result = max(result, (len(row) - c) * row[c])
    return result


class Solution(object):
    def maxLengthBetweenEqualCharacters(self, s):

    result, lookup = -1, {}
    for i, c in enumerate(s):
        result = max(result, i - lookup.setdefault(c, i) - 1)
    return result


class Solution(object):
    def largestSumOfAverages(self, A, K):

    accum_sum = [A[0]]
    for i in xrange(1, len(A)):
        accum_sum.append(A[i] + accum_sum[-1])

    dp = [[0] * len(A) for _ in xrange(2)]
    for k in xrange(1, K + 1):
        for i in xrange(k - 1, len(A)):
            if k == 1:
                dp[k % 2][i] = float(accum_sum[i]) / (i + 1)
            else:
                for j in xrange(k - 2, i):
                    dp[k % 2][i] = max(
                        dp[k % 2][i],
                        dp[(k - 1) % 2][j]
                        + float(accum_sum[i] - accum_sum[j]) / (i - j),
                    )
    return dp[K % 2][-1]


import itertools


class Solution(object):
    def largestTimeFromDigits(self, A):

    result = ""
    for i in xrange(len(A)):
        A[i] *= -1
    A.sort()
    for h1, h2, m1, m2 in itertools.permutations(A):
        hours = -(10 * h1 + h2)
        mins = -(10 * m1 + m2)
        if 0 <= hours < 24 and 0 <= mins < 60:
            result = "{:02}:{:02}".format(hours, mins)
            break
    return result


class Solution(object):
    def largestTriangleArea(self, points):

    result = 0
    for i in xrange(len(points) - 2):
        for j in xrange(i + 1, len(points) - 1):
            for k in xrange(j + 1, len(points)):
                result = max(
                    result,
                    0.5
                    * abs(
                        points[i][0] * points[j][1]
                        + points[j][0] * points[k][1]
                        + points[k][0] * points[i][1]
                        - points[j][0] * points[i][1]
                        - points[k][0] * points[j][1]
                        - points[i][0] * points[k][1]
                    ),
                )
    return result


import collections


class Solution(object):
    def largestUniqueNumber(self, A):

    A.append(-1)
    return max(k for k, v in collections.Counter(A).items() if v == 1)


import collections


class Solution(object):
    def largestValsFromLabels(self, values, labels, num_wanted, use_limit):

    counts = collections.defaultdict(int)
    val_labs = zip(values, labels)
    val_labs.sort(reverse=True)
    result = 0
    for val, lab in val_labs:
        if counts[lab] >= use_limit:
            continue
        result += val
        counts[lab] += 1
        num_wanted -= 1
        if num_wanted == 0:
            break
    return result


class Solution(object):
    def getLastMoment(self, n, left, right):

    return max(max(left or [0]), n - min(right or [n]))


class Solution(object):
    def lastStoneWeightII(self, stones):

    dp = {0}
    for stone in stones:
        dp |= {stone + i for i in dp}
    S = sum(stones)
    return min(abs(i - (S - i)) for i in dp)


import heapq


class Solution(object):
    def lastStoneWeight(self, stones):

    max_heap = [-x for x in stones]
    heapq.heapify(max_heap)
    for i in xrange(len(stones) - 1):
        x, y = -heapq.heappop(max_heap), -heapq.heappop(max_heap)
        heapq.heappush(max_heap, -abs(x - y))
    return -max_heap[0]


class Solution(object):
    def lastSubstring(self, s):

    left, right, l = 0, 1, 0
    while right + l < len(s):
        if s[left + l] == s[right + l]:
            l += 1
            continue
        if s[left + l] > s[right + l]:
            right += l + 1
        else:
            left = max(right, left + l + 1)
            right = left + 1
        l = 0
    return s[left:]


import collections


class Solution2(object):
    def lastSubstring(self, s):

    count = collections.defaultdict(list)
    for i in xrange(len(s)):
        count[s[i]].append(i)

    max_c = max(count.iterkeys())
    starts = {}
    for i in count[max_c]:
        starts[i] = i + 1
    while len(starts) - 1 > 0:
        lookup = set()
        next_count = collections.defaultdict(list)
        for start, end in starts.iteritems():
            if end == len(s):
                lookup.add(start)
                continue
            next_count[s[end]].append(start)
            if end in starts:
                lookup.add(end)
        next_starts = {}
        max_c = max(next_count.iterkeys())
        for start in next_count[max_c]:
            if start not in lookup:
                next_starts[start] = starts[start] + 1
        starts = next_starts
    return s[next(starts.iterkeys()):]


class Solution(object):
    def maximumTime(self, time):

    result = list(time)
    for i, c in enumerate(time):
        if c != "?":
            continue
        if i == 0:
            result[i] = "2" if result[i + 1] in "?0123" else "1"
        elif i == 1:
            result[i] = "3" if result[0] == "2" else "9"
        elif i == 3:
            result[i] = "5"
        elif i == 4:
            result[i] = "9"
    return "".join(result)


import itertools


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def leafSimilar(self, root1, root2):

    def dfs(node):
        if not node:
            return
        if not node.left and not node.right:
            yield node.val
        for i in dfs(node.left):
            yield i
        for i in dfs(node.right):
            yield i

    return all(a == b for a, b in itertools.izip_longest(dfs(root1), dfs(root2)))


import collections


class Solution(object):
    def findLeastNumOfUniqueInts(self, arr, k):

    count = collections.Counter(arr)
    result, count_count = len(count), collections.Counter(count.itervalues())
    for c in xrange(1, len(arr) + 1):
        if k < c * count_count[c]:
            result -= k // c
            break
        k -= c * count_count[c]
        result -= count_count[c]
    return result


class Solution(object):
    def leastOpsExpressTarget(self, x, target):

    pos, neg, k = 0, 0, 0
    while target:
        target, r = divmod(target, x)
        if k:
            pos, neg = min(r * k + pos, (r + 1) * k + neg), min(
                (x - r) * k + pos, (x - r - 1) * k + neg
            )
        else:
            pos, neg = r * 2, (x - r) * 2
        k += 1
    return min(pos, k + neg) - 1


class BinaryMatrix(object):
    def get(self, row, col):
    pass

    def dimensions(self):
    pass


class Solution(object):
    def leftMostColumnWithOne(self, binaryMatrix):

    m, n = binaryMatrix.dimensions()
    r, c = 0, n - 1
    while r < m and c >= 0:
        if not binaryMatrix.get(r, c):
            r += 1
        else:
            c -= 1
    return c + 1 if c + 1 != n else -1


import collections


class Solution(object):
    def lemonadeChange(self, bills):

    coins = [20, 10, 5]
    counts = collections.defaultdict(int)
    for bill in bills:
        counts[bill] += 1
        change = bill - coins[-1]
        for coin in coins:
            if change == 0:
                break
            if change >= coin:
                count = min(counts[coin], change // coin)
                counts[coin] -= count
                change -= coin * count
        if change != 0:
            return False
    return True


class Solution2(object):
    def lemonadeChange(self, bills):

    five, ten = 0, 0
    for bill in bills:
        if bill == 5:
            five += 1
        elif bill == 10:
            if not five:
                return False
            five -= 1
            ten += 1
        else:
            if ten and five:
                ten -= 1
                five -= 1
            elif five >= 3:
                five -= 3
            else:
                return False
    return True


class Solution(object):

    def lengthOfLastWord(self, s):
    length = 0
    for i in reversed(s):
        if i == " ":
            if length:
                break
        else:
            length += 1
    return length


class Solution2(object):

    def lengthOfLastWord(self, s):
    return len(s.strip().split(" ")[-1])


class Solution(object):
    def lenLongestFibSubseq(self, A):

    lookup = set(A)
    result = 2
    for i in xrange(len(A)):
        for j in xrange(i + 1, len(A)):
            x, y, l = A[i], A[j], 2
            while x + y in lookup:
                x, y, l = y, x + y, l + 1
            result = max(result, l)
    return result if result > 2 else 0


class Solution(object):
    def letterCasePermutation(self, S):

    result = [[]]
    for c in S:
        if c.isalpha():
            for i in xrange(len(result)):
                result.append(result[i][:])
                result[i].append(c.lower())
                result[-1].append(c.upper())
        else:
            for s in result:
                s.append(c)
    return map("".join, result)


class Solution(object):
    def letterCombinations(self, digits):

    if not digits:
        return []

    lookup = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
    total = 1
    for digit in digits:
        total *= len(lookup[int(digit)])
    result = []
    for i in xrange(total):
        base, curr = total, []
        for digit in digits:
            choices = lookup[int(digit)]
            base //= len(choices)
            curr.append(choices[(i // base) % len(choices)])
        result.append("".join(curr))
    return result


class Solution2(object):
    def letterCombinations(self, digits):

    if not digits:
        return []

    result = [""]
    lookup = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
    for digit in reversed(digits):
        choices = lookup[int(digit)]
        m, n = len(choices), len(result)
        result.extend([result[i % n] for i in xrange(n, m * n)])
        for i in xrange(m * n):
            result[i] = choices[i // n] + result[i]
    return result


class Solution3(object):
    def letterCombinations(self, digits):

    lookup = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]

    def letterCombinationsRecu(result, digits, curr, n):
        if n == len(digits):
            result.append("".join(curr))
            return
        for choice in lookup[int(digits[n])]:
            curr.append(choice)
            letterCombinationsRecu(result, digits, curr, n + 1)
            curr.pop()

    if not digits:
        return []
    result = []
    letterCombinationsRecu(result, digits, [], 0)
    return result


import collections


class Solution(object):
    def numTilePossibilities(self, tiles):

    fact = [0.0] * (len(tiles) + 1)
    fact[0] = 1.0
    for i in xrange(1, len(tiles) + 1):
        fact[i] = fact[i - 1] * i
    count = collections.Counter(tiles)

    coeff = [0.0] * (len(tiles) + 1)
    coeff[0] = 1.0
    for i in count.itervalues():
        new_coeff = [0.0] * (len(tiles) + 1)
        for j in xrange(len(coeff)):
            for k in xrange(i + 1):
                if k + j >= len(new_coeff):
                    break
                new_coeff[j + k] += coeff[j] * 1.0 / fact[k]
        coeff = new_coeff

    result = 0
    for i in xrange(1, len(coeff)):
        result += int(round(coeff[i] * fact[i]))
    return result


class Solution2(object):
    def numTilePossibilities(self, tiles):

    def backtracking(counter):
        total = 0
        for k, v in counter.iteritems():
            if not v:
                continue
            counter[k] -= 1
            total += 1 + backtracking(counter)
            counter[k] += 1
        return total

    return backtracking(collections.Counter(tiles))


class Solution(object):
    def lexicalOrder(self, n):
    result = []

    i = 1
    while len(result) < n:
        k = 0
        while i * 10 ** k <= n:
            result.append(i * 10 ** k)
            k += 1

        num = result[-1] + 1
        while num <= n and num % 10:
            result.append(num)
            num += 1

        if not num % 10:
            num -= 1
        else:
            num /= 10

        while num % 10 == 9:
            num /= 10

        i = num + 1

    return result


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[max(x_root, y_root)] = min(x_root, y_root)
    return True


class Solution(object):
    def smallestEquivalentString(self, A, B, S):

    union_find = UnionFind(26)
    for i in xrange(len(A)):
        union_find.union_set(ord(A[i]) - ord("a"), ord(B[i]) - ord("a"))
    result = []
    for i in xrange(len(S)):
        parent = union_find.find_set(ord(S[i]) - ord("a"))
        result.append(chr(parent + ord("a")))
    return "".join(result)


class Solution(object):
    def findLexSmallestString(self, s, a, b):

    def less(s, i, j):
        for k in xrange(len(s)):
            if s[(k + i) % len(s)] != s[(k + j) % len(s)]:
                return s[(k + i) % len(s)] < s[(k + j) % len(s)]
        return False

    s = list(s)
    result = s[:]
    even = [False] * 10
    while not even[int(s[0])]:
        even[int(s[0])] = True
        odd = [False] * 10
        while not odd[int(s[1])]:
            odd[int(s[1])] = True
            best_rotate = 0
            lookup = [False] * len(s)
            i = b
            while not lookup[i]:
                lookup[i] = True
                if less(s, i, best_rotate):
                    best_rotate = i
                i = (i + b) % len(s)
            result = min(result, s[best_rotate:] + s[:best_rotate])
            for k in xrange(1, len(s), 2):
                s[k] = str((int(s[k]) + a) % 10)
        if b % 2:
            for k in xrange(0, len(s), 2):
                s[k] = str((int(s[k]) + a) % 10)
    return "".join(result)


import collections


class Solution2(object):
    def findLexSmallestString(self, s, a, b):

    q, lookup, result = collections.deque([s]), {s}, s
    while q:
        curr = q.popleft()
        if curr < result:
            result = curr
        add_a = list(curr)
        for i, c in enumerate(add_a):
            if i % 2:
                add_a[i] = str((int(c) + a) % 10)
        add_a = "".join(add_a)
        if add_a not in lookup:
            lookup.add(add_a)
            q.append(add_a)
        rotate_b = curr[b:] + curr[:b]
        if rotate_b not in lookup:
            lookup.add(rotate_b)
            q.append(rotate_b)
    return result


import collections


class LFUCache(object):
    def __init__(self, capacity):

    self.__capa = capacity
    self.__size = 0
    self.__min_freq = float("inf")
    self.__freq_to_nodes = collections.defaultdict(collections.OrderedDict)
    self.__key_to_freq = {}

    def get(self, key):

    if key not in self.__key_to_freq:
        return -1
    value = self.__freq_to_nodes[self.__key_to_freq[key]][key]
    self.__update(key, value)
    return value

    def put(self, key, value):

    if self.__capa <= 0:
        return

    if key not in self.__key_to_freq and self.__size == self.__capa:
        del self.__key_to_freq[
            self.__freq_to_nodes[self.__min_freq].popitem(last=False)[0]
        ]
        if not self.__freq_to_nodes[self.__min_freq]:
            del self.__freq_to_nodes[self.__min_freq]
        self.__size -= 1
    self.__update(key, value)

    def __update(self, key, value):
    freq = 0
    if key in self.__key_to_freq:
        freq = self.__key_to_freq[key]
        del self.__freq_to_nodes[freq][key]
        if not self.__freq_to_nodes[freq]:
            del self.__freq_to_nodes[freq]
            if self.__min_freq == freq:
                self.__min_freq += 1
        self.__size -= 1

    freq += 1
    self.__min_freq = min(self.__min_freq, freq)
    self.__key_to_freq[key] = freq
    self.__freq_to_nodes[freq][key] = value
    self.__size += 1


import collections


class ListNode(object):
    def __init__(self, key, value, freq):
    self.key = key
    self.val = value
    self.freq = freq
    self.next = None
    self.prev = None


class LinkedList(object):
    def __init__(self):
    self.head = None
    self.tail = None

    def append(self, node):
    node.next, node.prev = None, None
    if self.head is None:
        self.head = node
    else:
        self.tail.next = node
        node.prev = self.tail
    self.tail = node

    def delete(self, node):
    if node.prev:
        node.prev.next = node.next
    else:
        self.head = node.next
    if node.next:
        node.next.prev = node.prev
    else:
        self.tail = node.prev
    node.next, node.prev = None, None


class LFUCache2(object):
    def __init__(self, capacity):

    self.__capa = capacity
    self.__size = 0
    self.__min_freq = float("inf")
    self.__freq_to_nodes = collections.defaultdict(LinkedList)
    self.__key_to_node = {}

    def get(self, key):

    if key not in self.__key_to_node:
        return -1
    value = self.__key_to_node[key].val
    self.__update(key, value)
    return value

    def put(self, key, value):

    if self.__capa <= 0:
        return

    if key not in self.__key_to_node and self.__size == self.__capa:
        del self.__key_to_node[self.__freq_to_nodes[self.__min_freq].head.key]
        self.__freq_to_nodes[self.__min_freq].delete(
            self.__freq_to_nodes[self.__min_freq].head
        )
        if not self.__freq_to_nodes[self.__min_freq].head:
            del self.__freq_to_nodes[self.__min_freq]
        self.__size -= 1
    self.__update(key, value)

    def __update(self, key, value):
    freq = 0
    if key in self.__key_to_node:
        old_node = self.__key_to_node[key]
        freq = old_node.freq
        self.__freq_to_nodes[freq].delete(old_node)
        if not self.__freq_to_nodes[freq].head:
            del self.__freq_to_nodes[freq]
            if self.__min_freq == freq:
                self.__min_freq += 1
        self.__size -= 1

    freq += 1
    self.__min_freq = min(self.__min_freq, freq)
    self.__key_to_node[key] = ListNode(key, value, freq)
    self.__freq_to_nodes[freq].append(self.__key_to_node[key])
    self.__size += 1


class Solution(object):
    def licenseKeyFormatting(self, S, K):

    result = []
    for i in reversed(xrange(len(S))):
        if S[i] == "-":
            continue
        if len(result) % (K + 1) == K:
            result += "-"
        result += S[i].upper()
    return "".join(reversed(result))


import collections


class Solution(object):
    def isReflected(self, points):

    if not points:
        return True
    groups_by_y = collections.defaultdict(set)
    left, right = float("inf"), float("-inf")
    for p in points:
        groups_by_y[p[1]].add(p[0])
        left, right = min(left, p[0]), max(right, p[0])
    mid = left + right
    for group in groups_by_y.values():
        for x in group:
            if mid - x not in group:
                return False
    return True


class Solution2(object):
    def isReflected(self, points):

    if not points:
        return True
    points.sort()

    points[len(points) / 2:] = sorted(
        points[len(points) / 2:],
        lambda x, y: y[1] - x[1] if x[0] == y[0] else x[0] - y[0],
    )
    mid = points[0][0] + points[-1][0]
    left, right = 0, len(points) - 1
    while left <= right:
        if (mid != points[left][0] + points[right][0]) or (
            points[left][0] != points[right][0]
            and points[left][1] != points[right][1]
        ):
            return False
        left += 1
        right -= 1
    return True


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):
    def numComponents(self, head, G):

    lookup = set(G)
    dummy = ListNode(-1)
    dummy.next = head
    curr = dummy
    result = 0
    while curr and curr.next:
        if curr.val not in lookup and curr.next.val in lookup:
            result += 1
        curr = curr.next
    return result


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __str__(self):
    if self:
        return "{}".format(self.val)
    else:
        return None


class Solution(object):

    def detectCycle(self, head):
    fast, slow = head, head
    while fast and fast.next:
        fast, slow = fast.next.next, slow.next
        if fast is slow:
            fast = head
            while fast is not slow:
                fast, slow = fast.next, slow.next
            return fast
    return None


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):

    def hasCycle(self, head):
    fast, slow = head, head
    while fast and fast.next:
        fast, slow = fast.next.next, slow.next
        if fast is slow:
            return True
    return False


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def isSubPath(self, head, root):

    def getPrefix(head):
        pattern, prefix = [head.val], [-1]
        j = -1
        node = head.next
        while node:
            while j + 1 and pattern[j + 1] != node.val:
                j = prefix[j]
            if pattern[j + 1] == node.val:
                j += 1
            pattern.append(node.val)
            prefix.append(j)
            node = node.next
        return pattern, prefix

    def dfs(pattern, prefix, root, j):
        if not root:
            return False
        while j + 1 and pattern[j + 1] != root.val:
            j = prefix[j]
        if pattern[j + 1] == root.val:
            j += 1
        if j + 1 == len(pattern):
            return True
        return dfs(pattern, prefix, root.left, j) or dfs(
            pattern, prefix, root.right, j
        )

    if not head:
        return True
    pattern, prefix = getPrefix(head)
    return dfs(pattern, prefix, root, -1)


class Solution2(object):
    def isSubPath(self, head, root):

    def dfs(head, root):
        if not head:
            return True
        if not root:
            return False
        return root.val == head.val and (
            dfs(head.next, root.left) or dfs(head.next, root.right)
        )

    if not head:
        return True
    if not root:
        return False
    return (
        dfs(head, root)
        or self.isSubPath(head, root.left)
        or self.isSubPath(head, root.right)
    )


from random import randint


class Solution(object):
    def __init__(self, head):

    self.__head = head

    def getRandom(self):

    reservoir = -1
    curr, n = self.__head, 0
    while curr:
        reservoir = curr.val if randint(1, n + 1) == 1 else reservoir
        curr, n = curr.next, n + 1
    return reservoir


import collections


class Logger(object):
    def __init__(self):

    self.__dq = collections.deque()
    self.__printed = set()

    def shouldPrintMessage(self, timestamp, message):

    while self.__dq and self.__dq[0][0] <= timestamp - 10:
        self.__printed.remove(self.__dq.popleft()[1])
    if message in self.__printed:
        return False
    self.__dq.append((timestamp, message))
    self.__printed.add(message)
    return True


class Solution(object):
    def findLonelyPixel(self, picture):

    rows, cols = [0] * len(picture), [0] * len(picture[0])
    for i in xrange(len(picture)):
        for j in xrange(len(picture[0])):
            if picture[i][j] == "B":
                rows[i] += 1
                cols[j] += 1

    result = 0
    for i in xrange(len(picture)):
        if rows[i] == 1:
            for j in xrange(len(picture[0])):
                result += picture[i][j] == "B" and cols[j] == 1
    return result


class Solution2(object):
    def findLonelyPixel(self, picture):

    return sum(
        col.count("B") == 1 == picture[col.index("B")].count("B")
        for col in zip(*picture)
    )


import collections


class Solution(object):
    def findBlackPixel(self, picture, N):

    rows, cols = [0] * len(picture), [0] * len(picture[0])
    lookup = collections.defaultdict(int)
    for i in xrange(len(picture)):
        for j in xrange(len(picture[0])):
            if picture[i][j] == "B":
                rows[i] += 1
                cols[j] += 1
        lookup[tuple(picture[i])] += 1

    result = 0
    for i in xrange(len(picture)):
        if rows[i] == N and lookup[tuple(picture[i])] == N:
            for j in xrange(len(picture[0])):
                result += picture[i][j] == "B" and cols[j] == N
    return result


class Solution2(object):
    def findBlackPixel(self, picture, N):

    lookup = collections.Counter(map(tuple, picture))
    cols = [col.count("B") for col in zip(*picture)]
    return sum(
        N * zip(row, cols).count(("B", N))
        for row, cnt in lookup.iteritems()
        if cnt == N == row.count("B")
    )


class Solution(object):
    def isLongPressedName(self, name, typed):

    i = 0
    for j in xrange(len(typed)):
        if i < len(name) and name[i] == typed[j]:
            i += 1
        elif j == 0 or typed[j] != typed[j - 1]:
            return False
    return i == len(name)


class Solution(object):
    def lengthLongestPath(self, input):

    def split_iter(s, tok):
        start = 0
        for i in xrange(len(s)):
            if s[i] == tok:
                yield s[start:i]
                start = i + 1
        yield s[start:]

    max_len = 0
    path_len = {0: 0}
    for line in split_iter(input, "\n"):
        name = line.lstrip("\t")
        depth = len(line) - len(name)
        if "." in name:
            max_len = max(max_len, path_len[depth] + len(name))
        else:
            path_len[depth + 1] = path_len[depth] + len(name) + 1
    return max_len


import collections


class Solution(object):
    def longestArithSeqLength(self, A):

    dp = collections.defaultdict(int)
    for i in xrange(len(A) - 1):
        for j in xrange(i + 1, len(A)):
            v = A[j] - A[i]
            dp[v, j] = max(dp[v, j], dp[v, i] + 1)
    return max(dp.values()) + 1


import collections


class Solution(object):
    def longestSubsequence(self, arr, difference):

    result = 1
    lookup = collections.defaultdict(int)
    for i in xrange(len(arr)):
        lookup[arr[i]] = lookup[arr[i] - difference] + 1
        result = max(result, lookup[arr[i]])
    return result


class Solution(object):
    def longestDecomposition(self, text):

    def compare(text, l, s1, s2):
        for i in xrange(l):
            if text[s1 + i] != text[s2 + i]:
                return False
        return True

    MOD = 10 ** 9 + 7
    D = 26
    result = 0
    left, right, l, pow_D = 0, 0, 0, 1
    for i in xrange(len(text)):
        left = (D * left + (ord(text[i]) - ord("a"))) % MOD
        right = (pow_D * (ord(text[-1 - i]) - ord("a")) + right) % MOD
        l += 1
        pow_D = (pow_D * D) % MOD
        if left == right and compare(text, l, i - l + 1, len(text) - 1 - i):
            result += 1
            left, right, l, pow_D = 0, 0, 0, 1
    return result


class Solution(object):
    def longestCommonPrefix(self, strs):

    if not strs:
        return ""

    for i in xrange(len(strs[0])):
        for string in strs[1:]:
            if i >= len(string) or string[i] != strs[0][i]:
                return strs[0][:i]
    return strs[0]


class Solution2(object):
    def longestCommonPrefix(self, strs):

    prefix = ""

    for chars in zip(*strs):
        if all(c == chars[0] for c in chars):
            prefix += chars[0]
        else:
            return prefix

    return prefix


class Solution(object):
    def longestCommonSubsequence(self, text1, text2):

    if len(text1) < len(text2):
        return self.longestCommonSubsequence(text2, text1)

    dp = [[0 for _ in xrange(len(text2) + 1)] for _ in xrange(2)]
    for i in xrange(1, len(text1) + 1):
        for j in xrange(1, len(text2) + 1):
            dp[i % 2][j] = (
                dp[(i - 1) % 2][j - 1] + 1
                if text1[i - 1] == text2[j - 1]
                else max(dp[(i - 1) % 2][j], dp[i % 2][j - 1])
            )
    return dp[len(text1) % 2][len(text2)]


class Solution(object):

    def longestConsecutive(self, num):
    result, lengths = 1, {key: 0 for key in num}
    for i in num:
        if lengths[i] == 0:
            lengths[i] = 1
            left, right = lengths.get(i - 1, 0), lengths.get(i + 1, 0)
            length = 1 + left + right
            result, lengths[i - left], lengths[i + right] = (
                max(result, length),
                length,
                length,
            )
    return result


class Solution(object):
    def findLengthOfLCIS(self, nums):

    result, count = 0, 0
    for i in xrange(len(nums)):
        if i == 0 or nums[i - 1] < nums[i]:
            count += 1
            result = max(result, count)
        else:
            count = 1
    return result


import collections


class Solution(object):
    def longestSubarray(self, nums, limit):

    max_dq, min_dq = collections.deque(), collections.deque()
    left = 0
    for right, num in enumerate(nums):
        while max_dq and nums[max_dq[-1]] <= num:
            max_dq.pop()
        max_dq.append(right)
        while min_dq and nums[min_dq[-1]] >= num:
            min_dq.pop()
        min_dq.append(right)
        if nums[max_dq[0]] - nums[min_dq[0]] > limit:
            if max_dq[0] == left:
                max_dq.popleft()
            if min_dq[0] == left:
                min_dq.popleft()
            left += 1
    return len(nums) - left


import collections


class Solution2(object):
    def longestSubarray(self, nums, limit):

    max_dq, min_dq = collections.deque(), collections.deque()
    result, left = 0, 0
    for right, num in enumerate(nums):
        while max_dq and nums[max_dq[-1]] <= num:
            max_dq.pop()
        max_dq.append(right)
        while min_dq and nums[min_dq[-1]] >= num:
            min_dq.pop()
        min_dq.append(right)
        while (
            nums[max_dq[0]] - nums[min_dq[0]] > limit
        ):
            if max_dq[0] == left:
                max_dq.popleft()
            if min_dq[0] == left:
                min_dq.popleft()
            left += 1
        result = max(result, right - left + 1)
    return result


import collections


class Solution(object):
    def longestDupSubstring(self, S):

    M = 10 ** 9 + 7
    D = 26

    def check(S, L):
        p = pow(D, L, M)
        curr = reduce(lambda x, y: (D * x + ord(y) - ord("a")) % M, S[:L], 0)
        lookup = collections.defaultdict(list)
        lookup[curr].append(L - 1)
        for i in xrange(L, len(S)):
            curr = (
                (D * curr) % M
                + ord(S[i])
                - ord("a")
                - ((ord(S[i - L]) - ord("a")) * p) % M
            ) % M
            if curr in lookup:
                for j in lookup[
                    curr
                ]:
                    if S[j - L + 1: j + 1] == S[i - L + 1: i + 1]:
                        return i - L + 1
            lookup[curr].append(i)
        return 0

    left, right = 1, len(S) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if not check(S, mid):
            right = mid - 1
        else:
            left = mid + 1
    result = check(S, right)
    return S[result: result + right]


class Solution(object):
    def longestPrefix(self, s):

    def getPrefix(pattern):
        prefix = [-1] * len(pattern)
        j = -1
        for i in xrange(1, len(pattern)):
            while j != -1 and pattern[j + 1] != pattern[i]:
                j = prefix[j]
            if pattern[j + 1] == pattern[i]:
                j += 1
            prefix[i] = j
        return prefix

    return s[: getPrefix(s)[-1] + 1]


class Solution2(object):
    def longestPrefix(self, s):

    M = 10 ** 9 + 7
    D = 26

    def check(l, s):
        for i in xrange(l):
            if s[i] != s[len(s) - l + i]:
                return False
        return True

    result, prefix, suffix, power = 0, 0, 0, 1
    for i in xrange(len(s) - 1):
        prefix = (prefix * D + (ord(s[i]) - ord("a"))) % M
        suffix = (suffix + (ord(s[len(s) - (i + 1)]) - ord("a")) * power) % M
        power = (power * D) % M
        if prefix == suffix:

            result = i + 1
    return s[:result]


import heapq


class Solution(object):
    def longestDiverseString(self, a, b, c):

    max_heap = []
    if a:
        heapq.heappush(max_heap, (-a, "a"))
    if b:
        heapq.heappush(max_heap, (-b, "b"))
    if c:
        heapq.heappush(max_heap, (-c, "c"))
    result = []
    while max_heap:
        count1, c1 = heapq.heappop(max_heap)
        if len(result) >= 2 and result[-1] == result[-2] == c1:
            if not max_heap:
                return "".join(result)
            count2, c2 = heapq.heappop(max_heap)
            result.append(c2)
            count2 += 1
            if count2:
                heapq.heappush(max_heap, (count2, c2))
            heapq.heappush(max_heap, (count1, c1))
            continue
        result.append(c1)
        count1 += 1
        if count1 != 0:
            heapq.heappush(max_heap, (count1, c1))
    return "".join(result)


class Solution2(object):
    def longestDiverseString(self, a, b, c):

    choices = [[a, "a"], [b, "b"], [c, "c"]]
    result = []
    for _ in xrange(a + b + c):
        choices.sort(reverse=True)
        for i, (x, c) in enumerate(choices):
            if x and result[-2:] != [c, c]:
                result.append(c)
                choices[i][0] -= 1
                break
        else:
            break
    return "".join(result)


import collections


class Solution(object):
    def findLHS(self, nums):

    lookup = collections.defaultdict(int)
    result = 0
    for num in nums:
        lookup[num] += 1
        for diff in [-1, 1]:
            if (num + diff) in lookup:
                result = max(result, lookup[num] + lookup[num + diff])
    return result


class Solution(object):
    def longestIncreasingPath(self, matrix):

    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

    if not matrix:
        return 0

    in_degree = [[0] * len(matrix[0]) for _ in xrange(len(matrix))]
    for i in xrange(len(matrix)):
        for j in xrange(len(matrix[0])):
            for di, dj in directions:
                ni, nj = i + di, j + dj
                if not (
                    0 <= ni < len(matrix)
                    and 0 <= nj < len(matrix[0])
                    and matrix[ni][nj] > matrix[i][j]
                ):
                    continue
                in_degree[i][j] += 1
    q = []
    for i in xrange(len(matrix)):
        for j in xrange(len(matrix[0])):
            if not in_degree[i][j]:
                q.append((i, j))
    result = 0
    while q:
        new_q = []
        for i, j in q:
            for di, dj in directions:
                ni, nj = i + di, j + dj
                if not (
                    0 <= ni < len(matrix)
                    and 0 <= nj < len(matrix[0])
                    and matrix[i][j] > matrix[ni][nj]
                ):
                    continue
                in_degree[ni][nj] -= 1
                if not in_degree[ni][nj]:
                    new_q.append((ni, nj))
        q = new_q
        result += 1
    return result


class Solution2(object):
    def longestIncreasingPath(self, matrix):

    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

    def longestpath(matrix, i, j, max_lengths):
        if max_lengths[i][j]:
            return max_lengths[i][j]
        max_depth = 0
        for di, dj in directions:
            x, y = i + di, j + dj
            if (
                0 <= x < len(matrix)
                and 0 <= y < len(matrix[0])
                and matrix[x][y] < matrix[i][j]
            ):
                max_depth = max(max_depth, longestpath(
                    matrix, x, y, max_lengths))
        max_lengths[i][j] = max_depth + 1
        return max_lengths[i][j]

    if not matrix:
        return 0
    result = 0
    max_lengths = [[0 for _ in xrange(len(matrix[0]))]
                   for _ in xrange(len(matrix))]
    for i in xrange(len(matrix)):
        for j in xrange(len(matrix[0])):
            result = max(result, longestpath(matrix, i, j, max_lengths))
    return result


import bisect


class Solution(object):
    def lengthOfLIS(self, nums):

    LIS = []

    def insert(target):
        left = bisect.bisect_left(LIS, target)

        if left == len(LIS):
            LIS.append(target)
        else:
            LIS[left] = target

    for num in nums:
        insert(num)
    return len(LIS)


class Solution2(object):
    def lengthOfLIS(self, nums):

    LIS = []

    def insert(target):
        left, right = 0, len(LIS) - 1

        while left <= right:
            mid = left + (right - left) // 2
            if LIS[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1

        if left == len(LIS):
            LIS.append(target)
        else:
            LIS[left] = target

    for num in nums:
        insert(num)

    return len(LIS)


class SegmentTree(object):
    def __init__(
        self,
        N,
        build_fn=lambda x, y: [y] * (2 * x),
        query_fn=lambda x, y: y
        if x is None
        else max(x, y),
        update_fn=lambda x, y: y,
        default_val=0,
    ):
    self.N = N
    self.H = (N - 1).bit_length()
    self.query_fn = query_fn
    self.update_fn = update_fn
    self.default_val = default_val
    self.tree = build_fn(N, default_val)
    self.lazy = [None] * N

    def __apply(self, x, val):
    self.tree[x] = self.update_fn(self.tree[x], val)
    if x < self.N:
        self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h):

    def pull(x):
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(
                self.tree[x * 2], self.tree[x * 2 + 1])
            if self.lazy[x] is not None:
                self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

    L += self.N
    R += self.N
    L0, R0 = L, R
    while L <= R:
        if L & 1:
            self.__apply(L, h)
            L += 1
        if R & 1 == 0:
            self.__apply(R, h)
            R -= 1
        L //= 2
        R //= 2
    pull(L0)
    pull(R0)

    def query(self, L, R):

    def push(x):
        n = 2 ** self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y * 2, self.lazy[y])
                self.__apply(y * 2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    result = None
    if L > R:
        return result

    L += self.N
    R += self.N
    push(L)
    push(R)
    while L <= R:
        if L & 1:
            result = self.query_fn(result, self.tree[L])
            L += 1
        if R & 1 == 0:
            result = self.query_fn(result, self.tree[R])
            R -= 1
        L //= 2
        R //= 2
    return result

    def __str__(self):
    showList = []
    for i in xrange(self.N):
        showList.append(self.query(i, i))
    return ",".join(map(str, showList))


class Solution3(object):
    def lengthOfLIS(self, nums):

    sorted_nums = sorted(set(nums))
    lookup = {num: i for i, num in enumerate(sorted_nums)}
    segment_tree = SegmentTree(len(lookup))
    for num in nums:
        segment_tree.update(
            lookup[num],
            lookup[num],
            segment_tree.query(0, lookup[num] - 1) +
            1 if lookup[num] >= 1 else 1,
        )
    return segment_tree.query(0, len(lookup) - 1) if len(lookup) >= 1 else 0


class Solution4(object):
    def lengthOfLIS(self, nums):

    dp = []
    for i in xrange(len(nums)):
        dp.append(1)
        for j in xrange(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp) if dp else 0


class Solution(object):
    def longestLine(self, M):

    if not M:
        return 0
    result = 0
    dp = [[[0] * 4 for _ in xrange(len(M[0]))] for _ in xrange(2)]
    for i in xrange(len(M)):
        for j in xrange(len(M[0])):
            dp[i % 2][j][:] = [0] * 4
            if M[i][j] == 1:
                dp[i % 2][j][0] = dp[i % 2][j - 1][0] + 1 if j > 0 else 1
                dp[i % 2][j][1] = dp[(i - 1) % 2][j][1] + 1 if i > 0 else 1
                dp[i % 2][j][2] = (
                    dp[(i - 1) % 2][j - 1][2] + 1 if (i > 0 and j > 0) else 1
                )
                dp[i % 2][j][3] = (
                    dp[(i - 1) % 2][j + 1][3] + 1
                    if (i > 0 and j < len(M[0]) - 1)
                    else 1
                )
                result = max(result, max(dp[i % 2][j]))
    return result


class Solution(object):
    def longestMountain(self, A):

    result, up_len, down_len = 0, 0, 0
    for i in xrange(1, len(A)):
        if (down_len and A[i - 1] < A[i]) or A[i - 1] == A[i]:
            up_len, down_len = 0, 0
        up_len += A[i - 1] < A[i]
        down_len += A[i - 1] > A[i]
        if up_len and down_len:
            result = max(result, up_len + down_len + 1)
    return result


class Solution(object):
    def longestNiceSubstring(self, s):

    lookup = set(list(s))
    prev = -1
    result = ""
    for i in xrange(len(s) + 1):
        if not (i == len(s) or s[i] not in lookup or s[i].swapcase() not in lookup):
            continue
        if prev == -1 and i == len(s):
            return s
        tmp = self.longestNiceSubstring(s[prev + 1: i])
        if len(tmp) > len(result):
            result = tmp
        prev = i
    return result


import collections


class Solution(object):
    def longestPalindrome(self, s):

    odds = 0
    for k, v in collections.Counter(s).iteritems():
        odds += v & 1
    return len(s) - odds + int(odds > 0)

    def longestPalindrome2(self, s):

    odd = sum(map(lambda x: x & 1, collections.Counter(s).values()))
    return len(s) - odd + int(odd > 0)


class Solution(object):
    def longestPalindromeSubseq(self, s):

    dp = [[[0] * 26 for _ in xrange(len(s))] for _ in xrange(2)]
    for i in reversed(xrange(len(s))):
        for j in xrange(i + 1, len(s)):
            if i == j - 1:
                if s[j] == s[i]:
                    dp[i % 2][j][ord(s[i]) - ord("a")] = 2
            else:
                for k in xrange(26):
                    if s[j] == s[i] and ord(s[j]) - ord("a") != k:
                        dp[i % 2][j][ord(s[j]) - ord("a")] = max(
                            dp[i % 2][j][ord(s[j]) - ord("a")],
                            dp[(i + 1) % 2][j - 1][k] + 2,
                        )
                    dp[i % 2][j][k] = max(
                        dp[i % 2][j][k],
                        dp[i % 2][j - 1][k],
                        dp[(i + 1) % 2][j][k],
                        dp[(i + 1) % 2][j - 1][k],
                    )
    return max(dp[0][-1])


class Solution(object):
    def longestPalindromeSubseq(self, s):

    if s == s[::-1]:
        return len(s)

    dp = [[1] * len(s) for _ in xrange(2)]
    for i in reversed(xrange(len(s))):
        for j in xrange(i + 1, len(s)):
            if s[i] == s[j]:
                dp[i % 2][j] = 2 + dp[(i + 1) %
                                      2][j - 1] if i + 1 <= j - 1 else 2
            else:
                dp[i % 2][j] = max(dp[(i + 1) % 2][j], dp[i % 2][j - 1])
    return dp[0][-1]


class Solution(object):
    def longestPalindrome(self, s):

    def preProcess(s):
        if not s:
            return ["^", "$"]
        T = ["^"]
        for c in s:
            T += ["#", c]
        T += ["#", "$"]
        return T

    T = preProcess(s)
    P = [0] * len(T)
    center, right = 0, 0
    for i in xrange(1, len(T) - 1):
        i_mirror = 2 * center - i
        if right > i:
            P[i] = min(right - i, P[i_mirror])
        else:
            P[i] = 0

        while T[i + 1 + P[i]] == T[i - 1 - P[i]]:
            P[i] += 1

        if i + P[i] > right:
            center, right = i, i + P[i]

    max_i = 0
    for i in xrange(1, len(T) - 1):
        if P[i] > P[max_i]:
            max_i = i
    start = (max_i - 1 - P[max_i]) / 2
    return s[start: start + P[max_i]]


class Solution2(object):
    def longestPalindrome(self, s):

    def expand(s, left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return (right - left + 1) - 2

    left, right = -1, -2
    for i in xrange(len(s)):
        l = max(expand(s, i, i), expand(s, i, i + 1))
        if l > right - left + 1:
            right = i + l // 2
            left = right - l + 1
    return s[left: right + 1] if left >= 0 else ""


import collections


class Solution(object):
    def characterReplacement(self, s, k):

    result, max_count = 0, 0
    count = collections.Counter()
    for i in xrange(len(s)):
        count[s[i]] += 1
        max_count = max(max_count, count[s[i]])
        if result - max_count >= k:
            count[s[i - result]] -= 1
        else:
            result += 1
    return result


import collections


class Solution(object):
    def longestRepeatingSubstring(self, S):

    M = 10 ** 9 + 7
    D = 26

    def check(S, L):
        p = pow(D, L, M)
        curr = reduce(lambda x, y: (D * x + ord(y) - ord("a")) % M, S[:L], 0)
        lookup = collections.defaultdict(list)
        lookup[curr].append(L - 1)
        result = 0
        for i in xrange(L, len(S)):
            curr = (
                (D * curr) % M
                + ord(S[i])
                - ord("a")
                - ((ord(S[i - L]) - ord("a")) * p) % M
            ) % M
            if curr in lookup:
                for j in lookup[curr]:
                    if S[j - L + 1: j + 1] == S[i - L + 1: i + 1]:
                        if result == 0:
                            result = i
                        return result - L + 1
            lookup[curr].append(i)
        return result

    left, right = 0, len(S) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if not check(S, mid):
            right = mid - 1
        else:
            left = mid + 1
    return right


import collections


class Solution(object):
    def longestStrChain(self, words):

    words.sort(key=len)
    dp = collections.defaultdict(int)
    for w in words:
        for i in xrange(len(w)):
            dp[w] = max(dp[w], dp[w[:i] + w[i + 1:]] + 1)
    return max(dp.itervalues())


class Solution(object):
    def longestSubarray(self, nums):

    count, left = 0, 0
    for right in xrange(len(nums)):
        count += nums[right] == 0
        if count >= 2:
            count -= nums[left] == 0
            left += 1
    return (right - left + 1) - 1


class Solution2(object):
    def longestSubarray(self, nums):

    result, count, left = 0, 0, 0
    for right in xrange(len(nums)):
        count += nums[right] == 0
        while count >= 2:
            count -= nums[left] == 0
            left += 1
        result = max(result, right - left + 1)
    return result - 1


class Solution(object):
    def longestSubstring(self, s, k):

    def longestSubstringHelper(s, k, start, end):
        count = [0] * 26
        for i in xrange(start, end):
            count[ord(s[i]) - ord("a")] += 1
        max_len = 0
        i = start
        while i < end:
            while i < end and count[ord(s[i]) - ord("a")] < k:
                i += 1
            j = i
            while j < end and count[ord(s[j]) - ord("a")] >= k:
                j += 1

            if i == start and j == end:
                return end - start

            max_len = max(max_len, longestSubstringHelper(s, k, i, j))
            i = j
        return max_len

    return longestSubstringHelper(s, k, 0, len(s))


class Solution(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):

    longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in xrange(256)]
    for i, char in enumerate(s):
        if visited[ord(char)] == 0:
            distinct_count += 1
        visited[ord(char)] += 1
        while distinct_count > k:
            visited[ord(s[start])] -= 1
            if visited[ord(s[start])] == 0:
                distinct_count -= 1
            start += 1
        longest = max(longest, i - start + 1)
    return longest


from collections import Counter


class Solution2(object):
    def lengthOfLongestSubstringKDistinct(self, s, k):

    counter = Counter()
    left, max_length = 0, 0
    for right, char in enumerate(s):
        counter[char] += 1
        while len(counter) > k:
            counter[s[left]] -= 1
            if counter[s[left]] == 0:
                del counter[s[left]]
            left += 1
        max_length = max(max_length, right - left + 1)
    return max_length


class Solution(object):

    def lengthOfLongestSubstringTwoDistinct(self, s):
    longest, start, distinct_count, visited = 0, 0, 0, [0 for _ in xrange(256)]
    for i, char in enumerate(s):
        if visited[ord(char)] == 0:
            distinct_count += 1
        visited[ord(char)] += 1
        while distinct_count > 2:
            visited[ord(s[start])] -= 1
            if visited[ord(s[start])] == 0:
                distinct_count -= 1
            start += 1
        longest = max(longest, i - start + 1)
    return longest


from collections import Counter


class Solution2(object):
    def lengthOfLongestSubstringTwoDistinct(self, s):

    counter = Counter()
    left, max_length = 0, 0
    for right, char in enumerate(s):
        counter[char] += 1
        while len(counter) > 2:
            counter[s[left]] -= 1
            if counter[s[left]] == 0:
                del counter[s[left]]
            left += 1
        max_length = max(max_length, right - left + 1)
    return max_length


class Solution(object):
    def lengthOfLongestSubstring(self, s):

    result, left = 0, 0
    lookup = {}
    for right in xrange(len(s)):
        if s[right] in lookup:
            left = max(left, lookup[s[right]] + 1)
        lookup[s[right]] = right
        result = max(result, right - left + 1)
    return result


class Solution(object):
    def maxTurbulenceSize(self, A):

    result = 1
    start = 0
    for i in xrange(1, len(A)):
        if i == len(A) - 1 or cmp(A[i - 1], A[i]) * cmp(A[i], A[i + 1]) != -1:
            result = max(result, i - start + 1)
            start = i
    return result


class Solution(object):
    def findLUSlength(self, a, b):

    if a == b:
        return -1
    return max(len(a), len(b))


class Solution(object):
    def findLUSlength(self, strs):

    def isSubsequence(a, b):
        i = 0
        for j in xrange(len(b)):
            if i >= len(a):
                break
            if a[i] == b[j]:
                i += 1
        return i == len(a)

    strs.sort(key=len, reverse=True)
    for i in xrange(len(strs)):
        all_of = True
        for j in xrange(len(strs)):
            if len(strs[j]) < len(strs[i]):
                break
            if i != j and isSubsequence(strs[i], strs[j]):
                all_of = False
                break
        if all_of:
            return len(strs[i])
    return -1


class Solution(object):
    def longestUnivaluePath(self, root):

    result = [0]

    def dfs(node):
        if not node:
            return 0
        left, right = dfs(node.left), dfs(node.right)
        left = (left + 1) if node.left and node.left.val == node.val else 0
        right = (right + 1) if node.right and node.right.val == node.val else 0
        result[0] = max(result[0], left + right)
        return max(left, right)

    dfs(root)
    return result[0]


class Solution(object):
    def longestValidParentheses(self, s):

    def length(it, start, c):
        depth, longest = 0, 0
        for i in it:
            if s[i] == c:
                depth += 1
            else:
                depth -= 1
                if depth < 0:
                    start, depth = i, 0
                elif depth == 0:
                    longest = max(longest, abs(i - start))
        return longest

    return max(
        length(xrange(len(s)), -1, "("),
        length(reversed(xrange(len(s))), len(s), ")"),
    )


class Solution2(object):

    def longestValidParentheses(self, s):
    longest, last, indices = 0, -1, []
    for i in xrange(len(s)):
        if s[i] == "(":
            indices.append(i)
        elif not indices:
            last = i
        else:
            indices.pop()
            if not indices:
                longest = max(longest, i - last)
            else:
                longest = max(longest, i - indices[-1])
    return longest


class Solution(object):
    def longestWPI(self, hours):

    result, accu = 0, 0
    lookup = {}
    for i, h in enumerate(hours):
        accu = accu + 1 if h > 8 else accu - 1
        if accu > 0:
            result = i + 1
        elif accu - 1 in lookup:

            result = max(result, i - lookup[accu - 1])
        lookup.setdefault(accu, i)
    return result


class Solution(object):
    def findLongestWord(self, s, d):

    d.sort(key=lambda x: (-len(x), x))
    for word in d:
        i = 0
        for c in s:
            if i < len(word) and word[i] == c:
                i += 1
        if i == len(word):
            return word
    return ""


from collections import defaultdict
from operator import getitem


class Solution(object):
    def longestWord(self, words):

    def _trie(): return defaultdict(_trie)
    trie = _trie()
    for i, word in enumerate(words):
        reduce(getitem, word, trie)["_end"] = i

    stack = trie.values()
    result = ""
    while stack:
        curr = stack.pop()
        if "_end" in curr:
            word = words[curr["_end"]]
            if len(word) > len(result) or (
                len(word) == len(result) and word < result
            ):
                result = word
            stack += [curr[letter] for letter in curr if letter != "_end"]
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def longestZigZag(self, root):

    def dfs(node, result):
        if not node:
            return [-1, -1]
        left, right = dfs(node.left, result), dfs(node.right, result)
        result[0] = max(result[0], left[1] + 1, right[0] + 1)
        return [left[1] + 1, right[0] + 1]

    result = [0]
    dfs(root, result)
    return result[0]


class Solution(object):
    def loudAndRich(self, richer, quiet):

    def dfs(graph, quiet, node, result):
        if result[node] is None:
            result[node] = node
            for nei in graph[node]:
                smallest_person = dfs(graph, quiet, nei, result)
                if quiet[smallest_person] < quiet[result[node]]:
                    result[node] = smallest_person
        return result[node]

    graph = [[] for _ in xrange(len(quiet))]
    for u, v in richer:
        graph[v].append(u)
    result = [None] * len(quiet)
    return map(lambda x: dfs(graph, quiet, x, result), xrange(len(quiet)))


class Solution(object):

    def lowestCommonAncestor(self, root, p, q):
    s, b = sorted([p.val, q.val])
    while not s <= root.val <= b:

        root = root.left if s <= root.val else root.right

    return root


class TreeNode(object):
    def __init__(self, x):
    pass


class Solution(object):
    def lowestCommonAncestor(self, root, p, q):

    def iter_dfs(node, p, q):
        result = None
        stk = [(1, (node, [0]))]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, ret = params
                if not node:
                    continue
                ret1, ret2 = [0], [0]
                stk.append((2, (node, ret1, ret2, ret)))
                stk.append((1, (node.right, ret2)))
                stk.append((1, (node.left, ret1)))
            elif step == 2:
                node, ret1, ret2, ret = params
                curr = int(node == p or node == q)
                if curr + ret1[0] + ret2[0] == 2 and not result:
                    result = node
                ret[0] = curr + ret1[0] + ret2[0]
        return result

    return iter_dfs(root, p, q)


class Solution2(object):
    def lowestCommonAncestor(self, root, p, q):

    def dfs(node, p, q, result):
        if not node:
            return 0
        left = dfs(node.left, p, q, result)
        right = dfs(node.right, p, q, result)
        curr = int(node == p or node == q)
        if curr + left + right == 2 and not result[0]:
            result[0] = node
        return curr + left + right

    result = [0]
    dfs(root, p, q, result)
    return result[0]


class Node:
    def __init__(self, val):
    pass


class Solution(object):
    def lowestCommonAncestor(self, p, q):

    a, b = p, q
    while a != b:
        a = a.parent if a else q
        b = b.parent if b else p
    return a


class Solution2(object):
    def lowestCommonAncestor(self, p, q):

    def depth(node):
        d = 0
        while node:
            node = node.parent
            d += 1
        return d

    p_d, q_d = depth(p), depth(q)
    while p_d > q_d:
        p = p.parent
        p_d -= 1
    while p_d < q_d:
        q = q.parent
        q_d -= 1
    while p != q:
        p = p.parent
        q = q.parent
    return p


class TreeNode(object):
    def __init__(self, x):
    pass


class Solution(object):
    def lowestCommonAncestor(self, root, nodes):

    def iter_dfs(root, lookup):
        result = [0]
        stk = [(1, (root, result))]
        while stk:
            step, args = stk.pop()
            if step == 1:
                node, ret = args
                if not node or node in lookup:
                    ret[0] = node
                    continue
                ret1, ret2 = [None], [None]
                stk.append((2, (node, ret1, ret2, ret)))
                stk.append((1, (node.right, ret2)))
                stk.append((1, (node.left, ret1)))
            elif step == 2:
                node, ret1, ret2, ret = args
                if ret1[0] and ret2[0]:
                    ret[0] = node
                else:
                    ret[0] = ret1[0] or ret2[0]
        return result[0]

    return iter_dfs(root, set(nodes))


class Solution2(object):
    def lowestCommonAncestor(self, root, nodes):

    def dfs(node, lookup):
        if not node or node in lookup:
            return node
        left, right = dfs(node.left, lookup), dfs(node.right, lookup)
        if left and right:
            return node
        return left or right

    return dfs(root, set(nodes))


class Solution(object):

    def lowestCommonAncestor(self, root, p, q):
    if root in (None, p, q):
        return root

    left, right = [
        self.lowestCommonAncestor(child, p, q) for child in (root.left, root.right)
    ]

    return root if left and right else left or right


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def lcaDeepestLeaves(self, root):

    def lcaDeepestLeavesHelper(root):
        if not root:
            return 0, None
        d1, lca1 = lcaDeepestLeavesHelper(root.left)
        d2, lca2 = lcaDeepestLeavesHelper(root.right)
        if d1 > d2:
            return d1 + 1, lca1
        if d1 < d2:
            return d2 + 1, lca2
        return d1 + 1, root

    return lcaDeepestLeavesHelper(root)[1]


import collections


class LRUCache(object):
    def __init__(self, capacity):
    self.cache = collections.OrderedDict()
    self.capacity = capacity

    def get(self, key):
    if key not in self.cache:
        return -1
    val = self.cache[key]
    self.__update(key, val)
    return val

    def put(self, key, val):
    if key not in self.cache and len(self.cache) == self.capacity:
        self.cache.popitem(last=False)
    self.__update(key, val)

    def __update(self, key, val):
    if key in self.cache:
        del self.cache[key]
    self.cache[key] = val


class ListNode(object):
    def __init__(self, key, val):
    self.val = val
    self.key = key
    self.next = None
    self.prev = None


class LinkedList(object):
    def __init__(self):
    self.head = None
    self.tail = None

    def insert(self, node):
    node.next, node.prev = None, None
    if self.head is None:
        self.head = node
    else:
        self.tail.next = node
        node.prev = self.tail
    self.tail = node

    def delete(self, node):
    if node.prev:
        node.prev.next = node.next
    else:
        self.head = node.next
    if node.next:
        node.next.prev = node.prev
    else:
        self.tail = node.prev
    node.next, node.prev = None, None


class LRUCache2(object):
    def __init__(self, capacity):
    self.list = LinkedList()
    self.dict = {}
    self.capacity = capacity

    def get(self, key):
    if key not in self.dict:
        return -1
    val = self.dict[key].val
    self.__update(key, val)
    return val

    def put(self, key, val):
    if key not in self.dict and len(self.dict) == self.capacity:
        del self.dict[self.list.head.key]
        self.list.delete(self.list.head)
    self.__update(key, val)

    def __update(self, key, val):
    if key in self.dict:
        self.list.delete(self.dict[key])
    node = ListNode(key, val)
    self.list.insert(node)
    self.dict[key] = node


import itertools


class Solution(object):
    def luckyNumbers(self, matrix):

    rows = map(min, matrix)
    cols = map(max, itertools.izip(*matrix))
    return [
        cell
        for i, row in enumerate(matrix)
        for j, cell in enumerate(row)
        if rows[i] == cols[j]
    ]


import itertools


class Solution2(object):
    def luckyNumbers(self, matrix):

    return list(set(map(min, matrix)) & set(map(max, itertools.izip(*matrix))))


class Solution(object):
    def numMagicSquaresInside(self, grid):

    def magic(grid, r, c):
        expect = k * (k ** 2 + 1) // 2
        nums = set()
        min_num = float("inf")
        sum_diag, sum_anti = 0, 0
        for i in xrange(k):
            sum_diag += grid[r + i][c + i]
            sum_anti += grid[r + i][c + k - 1 - i]
            sum_r, sum_c = 0, 0
            for j in xrange(k):
                min_num = min(min_num, grid[r + i][c + j])
                nums.add(grid[r + i][c + j])
                sum_r += grid[r + i][c + j]
                sum_c += grid[r + j][c + i]
            if not (sum_r == sum_c == expect):
                return False
        return (
            sum_diag == sum_anti == expect and len(
                nums) == k ** 2 and min_num == 1
        )

    k = 3
    result = 0
    for r in xrange(len(grid) - k + 1):
        for c in xrange(len(grid[r]) - k + 1):
            if magic(grid, r, c):
                result += 1
    return result


import itertools


class Solution(object):
    def magicalString(self, n):

    def gen():
        for c in 1, 2, 2:
            yield c
        for i, c in enumerate(gen()):
            if i > 1:
                for _ in xrange(c):
                    yield i % 2 + 1

    return sum(c & 1 for c in itertools.islice(gen(), n))


class Solution(object):
    def maxDistance(self, position, m):

    def check(position, m, x):
        count, prev = 1, position[0]
        for i in xrange(1, len(position)):
            if position[i] - prev >= x:
                count += 1
                prev = position[i]
        return count >= m

    position.sort()
    left, right = 1, position[-1] - position[0]
    while left <= right:
        mid = left + (right - left) // 2
        if not check(position, m, mid):
            right = mid - 1
        else:
            left = mid + 1
    return right


import collections


class Solution(object):
    def majorityElement(self, nums):

    k, n, cnts = 3, len(nums), collections.defaultdict(int)

    for i in nums:
        cnts[i] += 1

        if len(cnts) == k:
            for j in cnts.keys():
                cnts[j] -= 1
                if cnts[j] == 0:
                    del cnts[j]

    for i in cnts.keys():
        cnts[i] = 0

    for i in nums:
        if i in cnts:
            cnts[i] += 1

    result = []
    for i in cnts.keys():
        if cnts[i] > n / k:
            result.append(i)

    return result

    def majorityElement2(self, nums):

    return [i[0] for i in collections.Counter(nums).items() if i[1] > len(nums) / 3]


import collections


class Solution(object):
    def majorityElement(self, nums):

    idx, cnt = 0, 1

    for i in xrange(1, len(nums)):
        if nums[idx] == nums[i]:
            cnt += 1
        else:
            cnt -= 1
            if cnt == 0:
                idx = i
                cnt = 1

    return nums[idx]

    def majorityElement2(self, nums):

    return sorted(
        collections.Counter(nums).items(), key=lambda a: a[1], reverse=True
    )[0][0]

    def majorityElement3(self, nums):

    return collections.Counter(nums).most_common(1)[0][0]


import collections
import bisect


class Solution(object):
    def makeArrayIncreasing(self, arr1, arr2):

    arr2 = sorted(set(arr2))
    dp = {0: -1}
    for val1 in arr1:
        next_dp = collections.defaultdict(lambda: float("inf"))
        for cost, val in dp.iteritems():
            if val < val1:
                next_dp[cost] = min(next_dp[cost], val1)
            k = bisect.bisect_right(arr2, val)
            if k == len(arr2):
                continue
            next_dp[cost + 1] = min(next_dp[cost + 1], arr2[k])
        dp = next_dp
        if not dp:
            return -1
    return min(dp.iterkeys())


class Solution(object):
    def minSubarray(self, nums, p):

    residue = sum(nums) % p
    if not residue:
        return 0
    result = len(nums)
    curr, lookup = 0, {0: -1}
    for i, num in enumerate(nums):
        curr = (curr + num) % p
        lookup[curr] = i
        if (curr - residue) % p in lookup:
            result = min(result, i - lookup[(curr - residue) % p])
    return result if result < len(nums) else -1


class Solution(object):
    def makeGood(self, s):

    stk = []
    for ch in s:
        counter_ch = ch.upper() if ch.islower() else ch.lower()
        if stk and stk[-1] == counter_ch:
            stk.pop()
        else:
            stk.append(ch)
    return "".join(stk)


import collections


class Solution(object):
    def minChanges(self, nums, k):

    def one_are_not_from_nums(nums, cnts):
        mxs = [cnts[i].most_common(1)[0][1] for i in xrange(k)]
        return len(nums) - (sum(mxs) - min(mxs))

    def all_are_from_nums(nums, cnts):
        dp = {0: 0}
        for cnt in cnts:
            new_dp = collections.defaultdict(int)
            for x in dp.iterkeys():
                for y in cnt.iterkeys():
                    new_dp[x ^ y] = max(new_dp[x ^ y], dp[x] + cnt[y])
            dp = new_dp
        return len(nums) - dp[0]

    cnts = [
        collections.Counter(nums[j] for j in xrange(i, len(nums), k))
        for i in xrange(k)
    ]
    return min(one_are_not_from_nums(nums, cnts), all_are_from_nums(nums, cnts))


import collections


class Solution(object):
    def canBeEqual(self, target, arr):

    return collections.Counter(target) == collections.Counter(arr)


class Solution2(object):
    def canBeEqual(self, target, arr):

    target.sort(), arr.sort()
    return target == arr


class Solution(object):
    def largestIsland(self, grid):

    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

    def dfs(r, c, index, grid):
        if not (0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == 1):
            return 0
        result = 1
        grid[r][c] = index
        for d in directions:
            result += dfs(r + d[0], c + d[1], index, grid)
        return result

    area = {}
    index = 2
    for r in xrange(len(grid)):
        for c in xrange(len(grid[r])):
            if grid[r][c] == 1:
                area[index] = dfs(r, c, index, grid)
                index += 1

    result = max(area.values() or [0])
    for r in xrange(len(grid)):
        for c in xrange(len(grid[r])):
            if grid[r][c] == 0:
                seen = set()
                for d in directions:
                    nr, nc = r + d[0], c + d[1]
                    if not (
                        0 <= nr < len(grid)
                        and 0 <= nc < len(grid[0])
                        and grid[nr][nc] > 1
                    ):
                        continue
                    seen.add(grid[nr][nc])
                result = max(result, 1 + sum(area[i] for i in seen))
    return result


import collections


class Solution(object):
    def getFolderNames(self, names):

    count = collections.Counter()
    result, lookup = [], set()
    for name in names:
        while True:
            name_with_suffix = (
                "{}({})".format(name, count[name]) if count[name] else name
            )
            count[name] += 1
            if name_with_suffix not in lookup:
                break
        result.append(name_with_suffix)
        lookup.add(name_with_suffix)
    return result


class Solution(object):
    def highestPeak(self, isWater):

    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    q = []
    for r, row in enumerate(isWater):
        for c, cell in enumerate(row):
            row[c] -= 1
            if not cell:
                continue
            q.append((r, c))
    while q:
        new_q = []
        for r, c in q:
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if not (
                    0 <= nr < len(isWater)
                    and 0 <= nc < len(isWater[0])
                    and isWater[nr][nc] == -1
                ):
                    continue
                isWater[nr][nc] = isWater[r][c] + 1
                q.append((nr, nc))
        q = new_q
    return isWater


class Solution2(object):
    def highestPeak(self, isWater):

    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    q, heights = [], [[-1] * len(isWater[0]) for _ in xrange(len(isWater))]
    for r, row in enumerate(isWater):
        for c, cell in enumerate(row):
            if not cell:
                continue
            heights[r][c] = 0
            q.append((r, c))
    while q:
        new_q = []
        for r, c in q:
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if not (
                    0 <= nr < len(isWater)
                    and 0 <= nc < len(isWater[0])
                    and heights[nr][nc] == -1
                ):
                    continue
                heights[nr][nc] = heights[r][c] + 1
                q.append((nr, nc))
        q = new_q
    return heights


import collections


class MapSum(object):
    def __init__(self):

    def _trie(): return collections.defaultdict(_trie)
    self.__root = _trie()

    def insert(self, key, val):

    curr = self.__root
    for c in key:
        curr = curr[c]
    delta = val
    if "_end" in curr:
        delta -= curr["_end"]

    curr = self.__root
    for c in key:
        curr = curr[c]
        if "_count" in curr:
            curr["_count"] += delta
        else:
            curr["_count"] = delta
    curr["_end"] = val

    def sum(self, prefix):

    curr = self.__root
    for c in prefix:
        if c not in curr:
            return 0
        curr = curr[c]
    return curr["_count"]


class Solution(object):
    def maskPII(self, S):

    if "@" in S:
        first, after = S.split("@")
        return "{}*****{}@{}".format(first[0], first[-1], after).lower()

    digits = filter(lambda x: x.isdigit(), S)
    local = "***-***-{}".format(digits[-4:])
    if len(digits) == 10:
        return local
    return "+{}-{}".format("*" * (len(digits) - 10), local)


class Solution(object):
    def makesquare(self, nums):

    total_len = sum(nums)
    if total_len % 4:
        return False

    side_len = total_len / 4
    fullset = (1 << len(nums)) - 1

    used_subsets = []
    valid_half_subsets = [0] * (1 << len(nums))

    for subset in xrange(fullset + 1):
        subset_total_len = 0
        for i in xrange(len(nums)):
            if subset & (1 << i):
                subset_total_len += nums[i]

        if subset_total_len == side_len:
            for used_subset in used_subsets:
                if (used_subset & subset) == 0:
                    valid_half_subset = used_subset | subset
                    valid_half_subsets[valid_half_subset] = True
                    if valid_half_subsets[fullset ^ valid_half_subset]:
                        return True
            used_subsets.append(subset)

    return False


class Solution(object):
    def matrixBlockSum(self, mat, K):

    m, n = len(mat), len(mat[0])
    accu = [[0 for _ in xrange(n + 1)] for _ in xrange(m + 1)]
    for i in xrange(m):
        for j in xrange(n):
            accu[i + 1][j + 1] = (
                accu[i + 1][j] + accu[i][j + 1] - accu[i][j] + mat[i][j]
            )
    result = [[0 for _ in xrange(n)] for _ in xrange(m)]
    for i in xrange(m):
        for j in xrange(n):
            r1, c1, r2, c2 = (
                max(i - K, 0),
                max(j - K, 0),
                min(i + K + 1, m),
                min(j + K + 1, n),
            )
            result[i][j] = accu[r2][c2] - \
                accu[r1][c2] - accu[r2][c1] + accu[r1][c1]
    return result


class Solution(object):
    def allCellsDistOrder(self, R, C, r0, c0):

    def append(R, C, r, c, result):
        if 0 <= r < R and 0 <= c < C:
            result.append([r, c])

    result = [[r0, c0]]
    for d in xrange(1, R + C):
        append(R, C, r0 - d, c0, result)
        for x in xrange(-d + 1, d):
            append(R, C, r0 + x, c0 + abs(x) - d, result)
            append(R, C, r0 + x, c0 + d - abs(x), result)
        append(R, C, r0 + d, c0, result)
    return result


class Solution(object):
    def diagonalSum(self, mat):

    return sum(mat[i][i] + mat[~i][i] for i in xrange(len(mat))) - (
        mat[len(mat) // 2][len(mat) // 2] if len(mat) % 2 == 1 else 0
    )


class Solution(object):
    def maxAreaOfIsland(self, grid):

    directions = [[-1, 0], [1, 0], [0, 1], [0, -1]]

    def dfs(i, j, grid, area):
        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] > 0):
            return False
        grid[i][j] *= -1
        area[0] += 1
        for d in directions:
            dfs(i + d[0], j + d[1], grid, area)
        return True

    result = 0
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            area = [0]
            if dfs(i, j, grid, area):
                result = max(result, area[0])
    return result


class Solution(object):
    def maxChunksToSorted(self, arr):

    result, increasing_stk = 0, []
    for num in arr:
        max_num = num if not increasing_stk else max(increasing_stk[-1], num)
        while increasing_stk and increasing_stk[-1] > num:
            increasing_stk.pop()
        increasing_stk.append(max_num)
    return len(increasing_stk)


class Solution2(object):
    def maxChunksToSorted(self, arr):

    def compare(i1, i2):
        return arr[i1] - arr[i2] if arr[i1] != arr[i2] else i1 - i2

    idxs = [i for i in xrange(len(arr))]
    result, max_i = 0, 0
    for i, v in enumerate(sorted(idxs, cmp=compare)):
        max_i = max(max_i, v)
        if max_i == i:
            result += 1
    return result


class Solution(object):
    def maxChunksToSorted(self, arr):

    result, max_i = 0, 0
    for i, v in enumerate(arr):
        max_i = max(max_i, v)
        if max_i == i:
            result += 1
    return result


class Solution2(object):
    def maxChunksToSorted(self, arr):

    result, increasing_stk = 0, []
    for num in arr:
        max_num = num if not increasing_stk else max(increasing_stk[-1], num)
        while increasing_stk and increasing_stk[-1] > num:
            increasing_stk.pop()
        increasing_stk.append(max_num)
    return len(increasing_stk)


class Solution(object):
    def findMaxConsecutiveOnes(self, nums):

    result, prev, curr = 0, 0, 0
    for n in nums:
        if n == 0:
            result = max(result, prev + curr + 1)
            prev, curr = curr, 0
        else:
            curr += 1
    return min(max(result, prev + curr + 1), len(nums))


class Solution(object):
    def longestOnes(self, A, K):

    result, i = 0, 0
    for j in xrange(len(A)):
        K -= int(A[j] == 0)
        while K < 0:
            K += int(A[i] == 0)
            i += 1
        result = max(result, j - i + 1)
    return result


class Solution(object):
    def findMaxConsecutiveOnes(self, nums):

    result, local_max = 0, 0
    for n in nums:
        local_max = local_max + 1 if n else 0
        result = max(result, local_max)
    return result


class Solution(object):
    def maxDiff(self, num):

    digits = str(num)
    for b in digits:
        if b < "9":
            break
    if digits[0] != "1":
        a = digits[0]
    else:
        for a in digits:
            if a > "1":
                break
    return int(digits.replace(b, "9")) - int(
        digits.replace(a, "1" if digits[0] != "1" else "0")
    )


class Solution(object):
    def maxDotProduct(self, nums1, nums2):

    if len(nums1) < len(nums2):
        return self.maxDotProduct(nums2, nums1)
    dp = [[0] * len(nums2) for i in xrange(2)]
    for i in xrange(len(nums1)):
        for j in xrange(len(nums2)):
            dp[i % 2][j] = nums1[i] * nums2[j]
            if i and j:
                dp[i % 2][j] += max(dp[(i - 1) % 2][j - 1], 0)
            if i:
                dp[i % 2][j] = max(dp[i % 2][j], dp[(i - 1) % 2][j])
            if j:
                dp[i % 2][j] = max(dp[i % 2][j], dp[i % 2][j - 1])
    return dp[(len(nums1) - 1) % 2][-1]


import itertools


class Solution(object):
    def maxIncreaseKeepingSkyline(self, grid):

    row_maxes = [max(row) for row in grid]
    col_maxes = [max(col) for col in itertools.izip(*grid)]

    return sum(
        min(row_maxes[r], col_maxes[c]) - val
        for r, row in enumerate(grid)
        for c, val in enumerate(row)
    )


import collections


class Solution(object):
    def maxOperations(self, nums, k):

    count = collections.Counter()
    result = 0
    for x in nums:
        if k - x in count and count[k - x]:
            count[k - x] -= 1
            result += 1
        else:
            count[x] += 1
    return result


import collections


class Point(object):
    def __init__(self, a=0, b=0):
    self.x = a
    self.y = b


class Solution(object):
    def maxPoints(self, points):

    max_points = 0
    for i, start in enumerate(points):
        slope_count, same = collections.defaultdict(int), 1
        for j in xrange(i + 1, len(points)):
            end = points[j]
            if start.x == end.x and start.y == end.y:
                same += 1
            else:
                slope = float("inf")
                if start.x - end.x != 0:
                    slope = (start.y - end.y) * 1.0 / (start.x - end.x)
                slope_count[slope] += 1

        current_max = same
        for slope in slope_count:
            current_max = max(current_max, slope_count[slope] + same)

        max_points = max(max_points, current_max)

    return max_points


import collections


class MaxStack(object):
    def __init__(self):

    self.__idx_to_val = collections.defaultdict(int)
    self.__val_to_idxs = collections.defaultdict(list)
    self.__top = None
    self.__max = None

    def push(self, x):

    idx = self.__val_to_idxs[self.__top][-1] + 1 if self.__val_to_idxs else 0
    self.__idx_to_val[idx] = x
    self.__val_to_idxs[x].append(idx)
    self.__top = x
    self.__max = max(self.__max, x)

    def pop(self):

    val = self.__top
    self.__remove(val)
    return val

    def top(self):

    return self.__top

    def peekMax(self):

    return self.__max

    def popMax(self):

    val = self.__max
    self.__remove(val)
    return val

    def __remove(self, val):
    idx = self.__val_to_idxs[val][-1]
    self.__val_to_idxs[val].pop()
    if not self.__val_to_idxs[val]:
        del self.__val_to_idxs[val]
    del self.__idx_to_val[idx]
    if val == self.__top:
        self.__top = (
            self.__idx_to_val[max(self.__idx_to_val.keys())]
            if self.__idx_to_val
            else None
        )
    if val == self.__max:
        self.__max = max(self.__val_to_idxs.keys()
                         ) if self.__val_to_idxs else None


from bisect import bisect_left, insort


class Solution(object):
    def maxSumSubmatrix(self, matrix, k):

    if not matrix:
        return 0

    m = min(len(matrix), len(matrix[0]))
    n = max(len(matrix), len(matrix[0]))
    result = float("-inf")

    for i in xrange(m):
        sums = [0] * n
        for j in xrange(i, m):
            for l in xrange(n):
                sums[l] += matrix[j][l] if m == len(matrix) else matrix[l][j]

            accu_sum_set, accu_sum = [0], 0
            for sum in sums:
                accu_sum += sum
                it = bisect_left(accu_sum_set, accu_sum - k)
                if it != len(accu_sum_set):
                    result = max(result, accu_sum - accu_sum_set[it])
                insort(accu_sum_set, accu_sum)

    return result


class Solution_TLE(object):
    def maxSumSubmatrix(self, matrix, k):

    class BST(object):
        def __init__(self, val):
            self.val = val
            self.left = None
            self.right = None

        def insert(self, val):
            curr = self
            while curr:
                if curr.val >= val:
                    if curr.left:
                        curr = curr.left
                    else:
                        curr.left = BST(val)
                        return
                else:
                    if curr.right:
                        curr = curr.right
                    else:
                        curr.right = BST(val)
                        return

        def lower_bound(self, val):
            result, curr = None, self
            while curr:
                if curr.val >= val:
                    result, curr = curr, curr.left
                else:
                    curr = curr.right
            return result

    if not matrix:
        return 0

    m = min(len(matrix), len(matrix[0]))
    n = max(len(matrix), len(matrix[0]))
    result = float("-inf")

    for i in xrange(m):
        sums = [0] * n
        for j in xrange(i, m):
            for l in xrange(n):
                sums[l] += matrix[j][l] if m == len(matrix) else matrix[l][j]

            accu_sum_set = BST(0)
            accu_sum = 0
            for sum in sums:
                accu_sum += sum
                node = accu_sum_set.lower_bound(accu_sum - k)
                if node:
                    result = max(result, accu_sum - node.val)
                accu_sum_set.insert(accu_sum)

    return result


import collections


class Solution(object):
    def findMaxValueOfEquation(self, points, k):

    result = float("-inf")
    dq = collections.deque()
    for i, (x, y) in enumerate(points):
        while dq and points[dq[0]][0] < x - k:
            dq.popleft()
        if dq:
            result = max(result, (points[dq[0]][1] - points[dq[0]][0]) + y + x)
        while dq and points[dq[-1]][1] - points[dq[-1]][0] <= y - x:
            dq.pop()
        dq.append(i)
    return result


class Solution(object):
    def maximalNetworkRank(self, n, roads):

    MAX_N = 100
    MAX_NUM = MAX_N - 1

    def counting_sort(
        arr, key=lambda x: x, reverse=False
    ):
        count = [0] * (MAX_NUM + 1)
        for x in arr:
            count[key(x)] += 1
        for i in xrange(1, len(count)):
            count[i] += count[i - 1]
        result = [0] * len(arr)
        if not reverse:
            for x in reversed(arr):
                count[key(x)] -= 1
                result[count[key(x)]] = x
        else:
            for x in arr:
                count[key(x)] -= 1
                result[count[key(x)]] = x
            result.reverse()
        return result

    degree = [0] * n
    adj = collections.defaultdict(set)
    for a, b in roads:
        degree[a] += 1
        degree[b] += 1
        adj[a].add(b)
        adj[b].add(a)
    sorted_idx = counting_sort(
        xrange(n), key=lambda x: degree[x], reverse=True)
    m = 2
    while m < n:
        if degree[sorted_idx[m]] != degree[sorted_idx[1]]:
            break
        m += 1
    result = (
        degree[sorted_idx[0]] + degree[sorted_idx[1]] - 1
    )
    for i in xrange(m - 1):
        for j in xrange(i + 1, m):
            if (
                degree[sorted_idx[i]]
                + degree[sorted_idx[j]]
                - int(sorted_idx[i] in adj and sorted_idx[j]
                      in adj[sorted_idx[i]])
                > result
            ):
                return (
                    degree[sorted_idx[i]]
                    + degree[sorted_idx[j]]
                    - int(
                        sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]
                    )
                )
    return result


import collections


class Solution2(object):
    def maximalNetworkRank(self, n, roads):

    degree = [0] * n
    adj = collections.defaultdict(set)
    for a, b in roads:
        degree[a] += 1
        degree[b] += 1
        adj[a].add(b)
        adj[b].add(a)
    sorted_idx = range(n)
    sorted_idx.sort(key=lambda x: -degree[x])
    m = 2
    while m < n:
        if degree[sorted_idx[m]] != degree[sorted_idx[1]]:
            break
        m += 1
    result = (
        degree[sorted_idx[0]] + degree[sorted_idx[1]] - 1
    )
    for i in xrange(m - 1):
        for j in xrange(i + 1, m):
            if (
                degree[sorted_idx[i]]
                + degree[sorted_idx[j]]
                - int(sorted_idx[i] in adj and sorted_idx[j]
                      in adj[sorted_idx[i]])
                > result
            ):
                return (
                    degree[sorted_idx[i]]
                    + degree[sorted_idx[j]]
                    - int(
                        sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]
                    )
                )
    return result


import collections


class Solution3(object):
    def maximalNetworkRank(self, n, roads):

    degree = [0] * n
    adj = collections.defaultdict(set)
    for a, b in roads:
        degree[a] += 1
        degree[b] += 1
        adj[a].add(b)
        adj[b].add(a)
    result = 0
    for i in xrange(n - 1):
        for j in xrange(i + 1, n):
            result = max(
                result, degree[i] + degree[j] - int(i in adj and j in adj[i])
            )
    return result


class Solution(object):
    def maximalRectangle(self, matrix):

    def largestRectangleArea(heights):
        stk, result, i = [-1], 0, 0
        for i in xrange(len(heights) + 1):
            while stk[-1] != -1 and (
                i == len(heights) or heights[stk[-1]] >= heights[i]
            ):
                result = max(result, heights[stk.pop()] * ((i - 1) - stk[-1]))
            stk.append(i)
        return result

    if not matrix:
        return 0
    result = 0
    heights = [0] * len(matrix[0])
    for i in xrange(len(matrix)):
        for j in xrange(len(matrix[0])):
            heights[j] = heights[j] + 1 if matrix[i][j] == "1" else 0
        result = max(result, largestRectangleArea(heights))
    return result


class Solution2(object):
    def maximalRectangle(self, matrix):

    if not matrix:
        return 0

    result = 0
    m = len(matrix)
    n = len(matrix[0])
    L = [0 for _ in xrange(n)]
    H = [0 for _ in xrange(n)]
    R = [n for _ in xrange(n)]

    for i in xrange(m):
        left = 0
        for j in xrange(n):
            if matrix[i][j] == "1":
                L[j] = max(L[j], left)
                H[j] += 1
            else:
                L[j] = 0
                H[j] = 0
                R[j] = n
                left = j + 1

        right = n
        for j in reversed(xrange(n)):
            if matrix[i][j] == "1":
                R[j] = min(R[j], right)
                result = max(result, H[j] * (R[j] - L[j]))
            else:
                right = j

    return result


class Solution(object):

    def maximalSquare(self, matrix):
    if not matrix:
        return 0

    m, n = len(matrix), len(matrix[0])
    size = [[0 for j in xrange(n)] for i in xrange(2)]
    max_size = 0

    for j in xrange(n):
        if matrix[0][j] == "1":
            size[0][j] = 1
        max_size = max(max_size, size[0][j])

    for i in xrange(1, m):
        if matrix[i][0] == "1":
            size[i % 2][0] = 1
        else:
            size[i % 2][0] = 0
        for j in xrange(1, n):
            if matrix[i][j] == "1":
                size[i % 2][j] = (
                    min(
                        size[i % 2][j - 1],
                        size[(i - 1) % 2][j],
                        size[(i - 1) % 2][j - 1],
                    )
                    + 1
                )
                max_size = max(max_size, size[i % 2][j])
            else:
                size[i % 2][j] = 0

    return max_size * max_size


class Solution2(object):

    def maximalSquare(self, matrix):
    if not matrix:
        return 0

    m, n = len(matrix), len(matrix[0])
    size = [[0 for j in xrange(n)] for i in xrange(m)]
    max_size = 0

    for j in xrange(n):
        if matrix[0][j] == "1":
            size[0][j] = 1
        max_size = max(max_size, size[0][j])

    for i in xrange(1, m):
        if matrix[i][0] == "1":
            size[i][0] = 1
        else:
            size[i][0] = 0
        for j in xrange(1, n):
            if matrix[i][j] == "1":
                size[i][j] = (
                    min(size[i][j - 1], size[i - 1][j], size[i - 1][j - 1]) + 1
                )
                max_size = max(max_size, size[i][j])
            else:
                size[i][j] = 0

    return max_size * max_size


class Solution3(object):

    def maximalSquare(self, matrix):
    if not matrix:
        return 0

    H, W = 0, 1

    table = [[[0, 0] for j in xrange(len(matrix[0]))]
             for i in xrange(len(matrix))]
    for i in reversed(xrange(len(matrix))):
        for j in reversed(xrange(len(matrix[i]))):

            if matrix[i][j] == "1":
                h, w = 1, 1
                if i + 1 < len(matrix):
                    h = table[i + 1][j][H] + 1
                if j + 1 < len(matrix[i]):
                    w = table[i][j + 1][W] + 1
                table[i][j] = [h, w]

    s = [[0 for j in xrange(len(matrix[0]))] for i in xrange(len(matrix))]
    max_square_area = 0
    for i in reversed(xrange(len(matrix))):
        for j in reversed(xrange(len(matrix[i]))):
            side = min(table[i][j][H], table[i][j][W])
            if matrix[i][j] == "1":

                if i + 1 < len(matrix) and j + 1 < len(matrix[i + 1]):
                    side = min(s[i + 1][j + 1] + 1, side)
                s[i][j] = side
                max_square_area = max(max_square_area, side * side)

    return max_square_area


class Solution(object):
    def maxDistToClosest(self, seats):

    prev, result = -1, 1
    for i in xrange(len(seats)):
        if seats[i]:
            if prev < 0:
                result = i
            else:
                result = max(result, (i - prev) // 2)
            prev = i
    return max(result, len(seats) - 1 - prev)


class Solution(object):
    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):

    def left(curr):
        return curr[-1] if len(curr) % n else 0

    def up(curr):
        return curr[-n] if len(curr) >= n else 0

    def count_total(curr, t, total):
        return (
            total
            - 30 * ((left(curr) == 1) + (up(curr) == 1))
            + 20 * ((left(curr) == 2) + (up(curr) == 2))
            + (120 - 30 * ((left(curr) != 0) + (up(curr) != 0))) * (t == 1)
            + (40 + 20 * ((left(curr) != 0) + (up(curr) != 0))) * (t == 2)
        )

    def iter_backtracking(i, e):
        result = 0
        curr = []
        stk = [(2, (i, e, 0))]
        while stk:
            step, params = stk.pop()
            if step == 2:
                i, e, total = params
                if len(curr) == m * n or (i == 0 and e == 0):
                    result = max(result, total)
                    continue
                if total + (i + e) * 120 < result:
                    continue
                if e > 0:
                    stk.append((3, tuple()))
                    stk.append((2, (i, e - 1, count_total(curr, 2, total))))
                    stk.append((1, (2,)))
                if i > 0:
                    stk.append((3, tuple()))
                    stk.append((2, (i - 1, e, count_total(curr, 1, total))))
                    stk.append((1, (1,)))
                if left(curr) or up(
                    curr
                ):
                    stk.append((3, tuple()))
                    stk.append((2, (i, e, total)))
                    stk.append((1, (0,)))
            elif step == 1:
                x = params[0]
                curr.append(x)
            elif step == 3:
                curr.pop()
        return result

    return iter_backtracking(introvertsCount, extrovertsCount)


class Solution2(object):
    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):

    def left(curr):
        return curr[-1] if len(curr) % n else 0

    def up(curr):
        return curr[-n] if len(curr) >= n else 0

    def count_total(curr, t, total):
        return (
            total
            - 30 * ((left(curr) == 1) + (up(curr) == 1))
            + 20 * ((left(curr) == 2) + (up(curr) == 2))
            + (120 - 30 * ((left(curr) != 0) + (up(curr) != 0))) * (t == 1)
            + (40 + 20 * ((left(curr) != 0) + (up(curr) != 0))) * (t == 2)
        )

    def backtracking(i, e, total, curr, result):
        if len(curr) == m * n or (i == 0 and e == 0):
            result[0] = max(result[0], total)
            return
        if total + (i + e) * 120 < result[0]:
            return
        if left(curr) or up(curr):
            curr.append(0)
            backtracking(i, e, total, curr, result)
            curr.pop()
        if i > 0:
            new_total = count_total(curr, 1, total)
            curr.append(1)
            backtracking(i - 1, e, new_total, curr, result)
            curr.pop()
        if e > 0:
            new_total = count_total(curr, 2, total)
            curr.append(2)
            backtracking(i, e - 1, new_total, curr, result)
            curr.pop()

    result = [0]
    backtracking(introvertsCount, extrovertsCount, 0, [], result)
    return result[0]


class Solution(object):
    def longestPalindrome(self, word1, word2):

    s = word1 + word2
    dp = [[0] * len(s) for _ in xrange(len(s))]
    result = 0
    for j in xrange(len(s)):
        dp[j][j] = 1
        for i in reversed(xrange(j)):
            if s[i] == s[j]:
                dp[i][j] = 2 if i + 1 == j else dp[i + 1][j - 1] + 2
                if i < len(word1) <= j:
                    result = max(result, dp[i][j])
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return result


class Solution2(object):
    def longestPalindrome(self, word1, word2):

    s = word1 + word2
    dp = [[0] * len(s) for _ in xrange(len(s))]
    for j in xrange(len(s)):
        dp[j][j] = 1
        for i in reversed(xrange(j)):
            if s[i] == s[j]:
                dp[i][j] = 2 if i + 1 == j else dp[i + 1][j - 1] + 2
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
    return max(
        [
            dp[i][j]
            for i in xrange(len(word1))
            for j in xrange(len(word1), len(s))
            if s[i] == s[j]
        ]
        or [0]
    )


import random


class Solution(object):
    def largestSumAfterKNegations(self, A, K):

    def kthElement(nums, k, compare):
        def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in xrange(left, right):
                if compare(nums[i], nums[right]):
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            new_pivot_idx = PartitionAroundPivot(
                left, right, pivot_idx, nums, compare
            )
            if new_pivot_idx == k:
                return
            elif new_pivot_idx > k:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    kthElement(A, K, lambda a, b: a < b)
    remain = K
    for i in xrange(K):
        if A[i] < 0:
            A[i] = -A[i]
            remain -= 1
    return sum(A) - ((remain) % 2) * min(A) * 2


class Solution2(object):
    def largestSumAfterKNegations(self, A, K):

    A.sort()
    remain = K
    for i in xrange(K):
        if A[i] >= 0:
            break
        A[i] = -A[i]
        remain -= 1
    return sum(A) - (remain % 2) * min(A) * 2


class Solution(object):
    def maximumBeauty(self, flowers):

    lookup = {}
    prefix = [0]
    result = float("-inf")
    for i, f in enumerate(flowers):
        prefix.append(prefix[-1] + f if f > 0 else prefix[-1])
        if not f in lookup:
            lookup[f] = i
            continue
        result = max(
            result,
            2 * f + prefix[i + 1] - prefix[lookup[f]]
            if f < 0
            else prefix[i + 1] - prefix[lookup[f]],
        )
    return result


class Solution(object):
    def maximum69Number(self, num):

    curr, base, change = num, 3, 0
    while curr:
        if curr % 10 == 6:
            change = base
        base *= 10
        curr //= 10
    return num + change


class Solution2(object):
    def maximum69Number(self, num):

    return int(str(num).replace("6", "9", 1))


class Solution(object):
    def maxAbsoluteSum(self, nums):

    curr = mx = mn = 0
    for num in nums:
        curr += num
        mx = max(mx, curr)
        mn = min(mn, curr)
    return mx - mn


class Solution(object):
    def maxArea(self, h, w, horizontalCuts, verticalCuts):

    def max_len(l, cuts):
        cuts.sort()
        l = max(cuts[0] - 0, l - cuts[-1])
        for i in xrange(1, len(cuts)):
            l = max(l, cuts[i] - cuts[i - 1])
        return l

    MOD = 10 ** 9 + 7
    return max_len(h, horizontalCuts) * max_len(w, verticalCuts) % MOD


import heapq


class Solution(object):
    def maxAverageRatio(self, classes, extraStudents):

    def profit(a, b):
        return float(a + 1) / (b + 1) - float(a) / b

    max_heap = [(-profit(a, b), a, b) for a, b in classes]
    heapq.heapify(max_heap)
    while extraStudents:
        v, a, b = heapq.heappop(max_heap)
        a, b = a + 1, b + 1
        heapq.heappush(max_heap, (-profit(a, b), a, b))
        extraStudents -= 1
    return sum(float(a) / b for v, a, b in max_heap) / len(classes)


class Solution(object):
    def findMaxAverage(self, nums, k):

    result = total = sum(nums[:k])
    for i in xrange(k, len(nums)):
        total += nums[i] - nums[i - k]
        result = max(result, total)
    return float(result) / k


class Solution(object):
    def findMaxAverage(self, nums, k):

    def getDelta(avg, nums, k):
        accu = [0.0] * (len(nums) + 1)
        minval_pos = None
        delta = 0.0
        for i in xrange(len(nums)):
            accu[i + 1] = nums[i] + accu[i] - avg
            if i >= (k - 1):
                if minval_pos == None or accu[i - k + 1] < accu[minval_pos]:
                    minval_pos = i - k + 1
                if accu[i + 1] - accu[minval_pos] >= 0:
                    delta = max(
                        delta,
                        (accu[i + 1] - accu[minval_pos]) /
                        (i + 1 - minval_pos),
                    )
        return delta

    left, delta = min(nums), float("inf")
    while delta > 1e-5:
        delta = getDelta(left, nums, k)
        left += delta
    return left


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def maximumAverageSubtree(self, root):

    def maximumAverageSubtreeHelper(root, result):
        if not root:
            return [0.0, 0]
        s1, n1 = maximumAverageSubtreeHelper(root.left, result)
        s2, n2 = maximumAverageSubtreeHelper(root.right, result)
        s = s1 + s2 + root.val
        n = n1 + n2 + 1
        result[0] = max(result[0], s / n)
        return [s, n]

    result = [0]
    maximumAverageSubtreeHelper(root, result)
    return result[0]


class Solution(object):
    def maximumBinaryString(self, binary):

    result = list(binary)
    zeros = ones = 0
    for i, c in enumerate(result):
        if c == "0":
            zeros += 1
        elif zeros == 0:
            ones += 1
        result[i] = "1"
    if ones != len(result):
        result[zeros + ones - 1] = "0"
    return "".join(result)


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def insertIntoMaxTree(self, root, val):

    if not root:
        return TreeNode(val)

    if val > root.val:
        node = TreeNode(val)
        node.left = root
        return node

    curr = root
    while curr.right and curr.right.val > val:
        curr = curr.right
    node = TreeNode(val)
    curr.right, node.left = node, curr.right
    return root


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def constructMaximumBinaryTree(self, nums):

    nodeStack = []
    for num in nums:
        node = TreeNode(num)
        while nodeStack and num > nodeStack[-1].val:
            node.left = nodeStack.pop()
        if nodeStack:
            nodeStack[-1].right = node
        nodeStack.append(node)
    return nodeStack[0]


import collections


class Solution(object):
    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):

    result = 0
    q = collections.deque(initialBoxes)
    while q:
        changed = False
        for _ in xrange(len(q)):
            box = q.popleft()
            if not status[box]:
                q.append(box)
                continue
            changed = True
            result += candies[box]
            for contained_key in keys[box]:
                status[contained_key] = 1
            for contained_box in containedBoxes[box]:
                q.append(contained_box)
        if not changed:
            break
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def maxDepth(self, root):
    if root is None:
        return 0
    else:
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1


class Node(object):
    def __init__(self, val, children):
    self.val = val
    self.children = children


class Solution(object):
    def maxDepth(self, root):

    if not root:
        return 0
    depth = 0
    for child in root.children:
        depth = max(depth, self.maxDepth(child))
    return 1 + depth


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def maxAncestorDiff(self, root):

    result = 0
    stack = [(root, 0, float("inf"))]
    while stack:
        node, mx, mn = stack.pop()
        if not node:
            continue
        result = max(result, mx - node.val, node.val - mn)
        mx = max(mx, node.val)
        mn = min(mn, node.val)
        stack.append((node.left, mx, mn))
        stack.append((node.right, mx, mn))
    return result


class Solution2(object):
    def maxAncestorDiff(self, root):

    def maxAncestorDiffHelper(node, mx, mn):
        if not node:
            return 0
        result = max(mx - node.val, node.val - mn)
        mx = max(mx, node.val)
        mn = min(mn, node.val)
        result = max(result, maxAncestorDiffHelper(node.left, mx, mn))
        result = max(result, maxAncestorDiffHelper(node.right, mx, mn))
        return result

    return maxAncestorDiffHelper(root, 0, float("inf"))


class Solution(object):
    def maxDistance(self, arrays):

    result, min_val, max_val = 0, arrays[0][0], arrays[0][-1]
    for i in xrange(1, len(arrays)):
        result = max(result, max(
            max_val - arrays[i][0], arrays[i][-1] - min_val))
        min_val = min(min_val, arrays[i][0])
        max_val = max(max_val, arrays[i][-1])
    return result


import collections


class Solution(object):
    def maxEqualFreq(self, nums):

    result = 0
    count = collections.Counter()
    freq = [0 for _ in xrange(len(nums) + 1)]
    for i, n in enumerate(nums, 1):
        freq[count[n]] -= 1
        freq[count[n] + 1] += 1
        count[n] += 1
        c = count[n]
        if freq[c] * c == i and i < len(nums):
            result = i + 1
        remain = i - freq[c] * c
        if freq[remain] == 1 and remain in [1, c + 1]:
            result = i
    return result


class Solution(object):
    def maximumUniqueSubarray(self, nums):

    lookup = {}
    prefix = [0] * (len(nums) + 1)
    result, left = 0, 0
    for right, num in enumerate(nums):
        prefix[right + 1] = prefix[right] + num
        if num in lookup:
            left = max(left, lookup[num] + 1)
        lookup[num] = right
        result = max(result, prefix[right + 1] - prefix[left])
    return result


import collections


class FontInfo(object):
    def getWidth(self, fontSize, ch):

    pass

    def getHeight(self, fontSize):

    pass


class Solution(object):
    def maxFont(self, text, w, h, fonts, fontInfo):

    def check(count, w, h, fonts, fontInfo, x):
        return (
            fontInfo.getHeight(fonts[x]) <= h
            and sum(
                cnt * fontInfo.getWidth(fonts[x], c) for c, cnt in count.iteritems()
            )
            <= w
        )

    count = collections.Counter(text)
    left, right = 0, len(fonts) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if not check(count, w, h, fonts, fontInfo, mid):
            right = mid - 1
        else:
            left = mid + 1
    return fonts[right] if right >= 0 else -1


import collections


class FreqStack(object):
    def __init__(self):
    self.__freq = collections.Counter()
    self.__group = collections.defaultdict(list)
    self.__maxfreq = 0

    def push(self, x):

    self.__freq[x] += 1
    if self.__freq[x] > self.__maxfreq:
        self.__maxfreq = self.__freq[x]
    self.__group[self.__freq[x]].append(x)

    def pop(self):

    x = self.__group[self.__maxfreq].pop()
    if not self.__group[self.__maxfreq]:
        self.__group.pop(self.__maxfreq)
        self.__maxfreq -= 1
    self.__freq[x] -= 1
    if not self.__freq[x]:
        self.__freq.pop(x)
    return x


class Solution(object):
    def maximumGap(self, nums):

    if len(nums) < 2:
        return 0

    max_val, min_val = max(nums), min(nums)
    gap = max(1, (max_val - min_val) / (len(nums) - 1))
    bucket_size = (max_val - min_val) / gap + 1
    bucket = [
        {"min": float("inf"), "max": float("-inf")} for _ in xrange(bucket_size)
    ]

    for n in nums:

        if n in (max_val, min_val):
            continue
        i = (n - min_val) / gap
        bucket[i]["min"] = min(bucket[i]["min"], n)
        bucket[i]["max"] = max(bucket[i]["max"], n)

    max_gap, pre_bucket_max = 0, min_val
    for i in xrange(bucket_size):

        if bucket[i]["min"] == float("inf") and bucket[i]["max"] == float("-inf"):
            continue
        max_gap = max(max_gap, bucket[i]["min"] - pre_bucket_max)
        pre_bucket_max = bucket[i]["max"]

    max_gap = max(max_gap, max_val - pre_bucket_max)

    return max_gap


class Solution2(object):
    def maximumGap(self, nums):

    if len(nums) < 2:
        return 0

    nums.sort()
    pre = nums[0]
    max_gap = float("-inf")

    for i in nums:
        max_gap = max(max_gap, i - pre)
        pre = i
    return max_gap


class Solution(object):
    def maxHeight(self, cuboids):

    for cuboid in cuboids:
        cuboid.sort()
    cuboids.append([0, 0, 0])
    cuboids.sort()
    dp = [0] * len(cuboids)
    for i in xrange(1, len(cuboids)):
        for j in xrange(i):
            if all(cuboids[j][k] <= cuboids[i][k] for k in xrange(3)):
                dp[i] = max(dp[i], dp[j] + cuboids[i][2])
    return max(dp)


power = [1]
log2 = {1: 0}
for i in xrange(1, 26):
    power.append(power[-1] << 1)
    log2[power[i]] = i


class Solution(object):
    def maxLength(self, arr):

    def bitset(s):
        result = 0
        for c in s:
            if result & power[ord(c) - ord("a")]:
                return 0
            result |= power[ord(c) - ord("a")]
        return result

    def number_of_one(n):
        result = 0
        while n:
            n &= n - 1
            result += 1
        return result

    dp = [0]
    for x in arr:
        x_set = bitset(x)
        if not x_set:
            continue
        curr_len = len(dp)
        for i in xrange(curr_len):
            if dp[i] & x_set:
                continue
            dp.append(dp[i] | x_set)
    return max(number_of_one(s_set) for s_set in dp)


class Solution2(object):
    def maxLength(self, arr):

    def bitset(s):
        result = 0
        for c in s:
            if result & power[ord(c) - ord("a")]:
                return 0
            result |= power[ord(c) - ord("a")]
        return result

    bitsets = [bitset(x) for x in arr]
    result = 0
    for i in xrange(power[len(arr)]):
        curr_bitset, curr_len = 0, 0
        while i:
            j = i & -i
            i ^= j
            j = log2[j]
            if not bitsets[j] or (curr_bitset & bitsets[j]):
                break
            curr_bitset |= bitsets[j]
            curr_len += len(arr[j])
        else:
            result = max(result, curr_len)
    return result


class Solution(object):
    def findLongestChain(self, pairs):

    pairs.sort(key=lambda x: x[1])
    cnt, i = 0, 0
    for j in xrange(len(pairs)):
        if j == 0 or pairs[i][1] < pairs[j][0]:
            cnt += 1
            i = j
    return cnt


import collections


class Solution(object):
    def findLength(self, A, B):

    if len(A) < len(B):
        return self.findLength(B, A)
    result = 0
    dp = [[0] * (len(B) + 1) for _ in xrange(2)]
    for i in xrange(len(A)):
        for j in xrange(len(B)):
            if A[i] == B[j]:
                dp[(i + 1) % 2][j + 1] = dp[i % 2][j] + 1
            else:
                dp[(i + 1) % 2][j + 1] = 0
        result = max(result, max(dp[(i + 1) % 2]))
    return result


class Solution2(object):
    def findLength(self, A, B):

    if len(A) > len(B):
        return self.findLength(B, A)
    M, p = 10 ** 9 + 7, 113
    p_inv = pow(p, M - 2, M)

    def check(guess):
        def rolling_hashes(source, length):
            if length == 0:
                yield 0, 0
                return

            val, power = 0, 1
            for i, x in enumerate(source):
                val = (val + x * power) % M
                if i < length - 1:
                    power = (power * p) % M
                else:
                    yield val, i - (length - 1)
                    val = (val - source[i - (length - 1)]) * p_inv % M

        hashes = collections.defaultdict(list)
        for hash_val, i in rolling_hashes(A, guess):
            hashes[hash_val].append(i)
        for hash_val, j in rolling_hashes(B, guess):
            if any(A[i: i + guess] == B[j: j + guess] for i in hashes[hash_val]):
                return True
        return False

    left, right = 0, min(len(A), len(B)) + 1
    while left < right:
        mid = left + (right - left) / 2
        if not check(mid):
            right = mid
        else:
            left = mid + 1
    return left - 1


class Solution3(object):
    def findLength(self, A, B):

    if len(A) > len(B):
        return self.findLength(B, A)

    def check(length):
        lookup = set(A[i: i + length] for i in xrange(len(A) - length + 1))
        return any(B[j: j + length] in lookup for j in xrange(len(B) - length + 1))

    A = "".join(map(chr, A))
    B = "".join(map(chr, B))
    left, right = 0, min(len(A), len(B)) + 1
    while left < right:
        mid = left + (right - left) / 2
        if not check(mid):
            right = mid
        else:
            left = mid + 1
    return left - 1


class Solution(object):
    def getMaxLen(self, nums):

    result, neg_cnt, last_zero_pos, first_valid_neg_pos = 0, 0, -1, -1
    for i in xrange(len(nums)):
        if nums[i] == 0:
            neg_cnt = 0
            last_zero_pos = i
            first_valid_neg_pos = -1
            continue
        if nums[i] < 0:
            if first_valid_neg_pos == -1:
                first_valid_neg_pos = i
            neg_cnt += 1
        result = max(
            result, i - (last_zero_pos if neg_cnt %
                         2 == 0 else first_valid_neg_pos)
        )
    return result


import collections


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def maxLevelSum(self, root):

    def dfs(node, i, level_sums):
        if not node:
            return
        if i == len(level_sums):
            level_sums.append(0)
        level_sums[i] += node.val
        dfs(node.left, i + 1, level_sums)
        dfs(node.right, i + 1, level_sums)

    level_sums = []
    dfs(root, 0, level_sums)
    return level_sums.index(max(level_sums)) + 1


class Solution2(object):
    def maxLevelSum(self, root):

    result, level, max_total = 0, 1, float("-inf")
    q = collections.deque([root])
    while q:
        total = 0
        for _ in xrange(len(q)):
            node = q.popleft()
            total += node.val
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        if total > max_total:
            result, max_total = level, total
        level += 1
    return result


class Solution(object):
    def maxDepth(self, s):

    result = curr = 0
    for c in s:
        if c == "(":
            curr += 1
            result = max(result, curr)
        elif c == ")":
            curr -= 1
    return result


class Solution(object):
    def maxDepthAfterSplit(self, seq):

    return [(i & 1) ^ (seq[i] == "(") for i, c in enumerate(seq)]


class Solution2(object):
    def maxDepthAfterSplit(self, seq):

    A, B = 0, 0
    result = [0] * len(seq)
    for i, c in enumerate(seq):
        point = 1 if c == "(" else -1
        if (point == 1 and A <= B) or (point == -1 and A >= B):
            A += point
        else:
            B += point
            result[i] = 1
    return result


class Solution(object):
    def maxProductPath(self, grid):

    MOD = 10 ** 9 + 7
    max_dp = [[0] * len(grid[0]) for _ in xrange(2)]
    min_dp = [[0] * len(grid[0]) for _ in xrange(2)]
    for i in xrange(len(grid)):
        for j in xrange(len(grid[i])):
            if i == 0 and j == 0:
                max_dp[i % 2][j] = min_dp[i % 2][j] = grid[i][j]
                continue
            curr_max = max(
                max_dp[(i - 1) % 2][j] if i > 0 else max_dp[i % 2][j - 1],
                max_dp[i % 2][j - 1] if j > 0 else max_dp[(i - 1) % 2][j],
            )
            curr_min = min(
                min_dp[(i - 1) % 2][j] if i > 0 else min_dp[i % 2][j - 1],
                min_dp[i % 2][j - 1] if j > 0 else min_dp[(i - 1) % 2][j],
            )
            if grid[i][j] < 0:
                curr_max, curr_min = curr_min, curr_max
            max_dp[i % 2][j] = curr_max * grid[i][j]
            min_dp[i % 2][j] = curr_min * grid[i][j]
    return (
        max_dp[(len(grid) - 1) % 2][-1] % MOD
        if max_dp[(len(grid) - 1) % 2][-1] >= 0
        else -1
    )


import itertools


class Solution(object):
    def maximumRequests(self, n, requests):

    for k in reversed(xrange(1, len(requests) + 1)):
        for c in itertools.combinations(xrange(len(requests)), k):
            change = [0] * n
            for i in c:
                change[requests[i][0]] -= 1
                change[requests[i][1]] += 1
            if all(c == 0 for c in change):
                return k
    return 0


class Solution2(object):
    def maximumRequests(self, n, requests):

    def evaluate(n, requests, mask):
        change = [0] * n
        base, count = 1, 0
        for i in xrange(len(requests)):
            if base & mask:
                change[requests[i][0]] -= 1
                change[requests[i][1]] += 1
                count += 1
            base <<= 1
        return count if all(c == 0 for c in change) else 0

    return max(evaluate(n, requests, i) for i in xrange(1 << len(requests)))


import collections


class Solution(object):
    def maxNumberOfBalloons(self, text):

    TARGET = "balloon"
    source_count = collections.Counter(text)
    target_count = collections.Counter(TARGET)
    return min(source_count[c] // target_count[c] for c in target_count.iterkeys())


import collections
import itertools


class Solution(object):
    def countBalls(self, lowLimit, highLimit):

    count = collections.Counter()
    for i in xrange(lowLimit, highLimit + 1):
        count[sum(itertools.imap(int, str(i)))] += 1
    return max(count.itervalues())


import itertools


class Solution(object):
    def maxCoins(self, piles):

    piles.sort()
    return sum(itertools.islice(piles, len(piles) // 3, len(piles), 2))


import math


class Solution(object):
    def numPoints(self, points, r):

    def count_points(points, r, i):
        angles = []
        for j in xrange(len(points)):
            if i == j:
                continue
            dx, dy = points[i][0] - points[j][0], points[i][1] - points[j][1]
            d = math.sqrt(dx ** 2 + dy ** 2)
            if d > 2 * r:
                continue
            delta, angle = math.acos(d / (2 * r)), math.atan2(dy, dx)
            angles.append((angle - delta, 0)
                          ), angles.append((angle + delta, 1))
        angles.sort()
        result, count = 1, 1
        for _, is_closed in angles:
            if not is_closed:
                count += 1
            else:
                count -= 1
            result = max(result, count)
        return result

    return max(count_points(points, r, i) for i in xrange(len(points)))


import heapq


class Solution(object):
    def eatenApples(self, apples, days):

    min_heap = []
    result = i = 0
    while i < len(apples) or min_heap:
        if i < len(apples) and apples[i] > 0:
            heapq.heappush(min_heap, [i + days[i], i])
        while min_heap and (min_heap[0][0] <= i or apples[min_heap[0][1]] == 0):
            heapq.heappop(min_heap)
        if min_heap:
            apples[min_heap[0][1]] -= 1
            result += 1
        i += 1
    return result


import bisect


class Solution(object):
    def maxValue(self, events, k):

    events.sort(key=lambda x: x[1])
    sorted_ends = [x[1] for x in events]
    dp = [[0] * (k + 1) for _ in xrange(len(events) + 1)]
    for i in xrange(1, len(events) + 1):
        prev_i_m_1 = bisect.bisect_left(sorted_ends, events[i - 1][0]) - 1
        for j in xrange(1, k + 1):
            dp[i][j] = max(
                dp[i - 1][j], dp[prev_i_m_1 + 1][j - 1] + events[i - 1][2]
            )
    return dp[-1][-1]


import bisect


class Solution2(object):
    def maxValue(self, events, k):

    events.sort()
    sorted_starts = [x[0] for x in events]
    dp = [[0] * (k + 1) for _ in xrange(len(events) + 1)]
    for i in reversed(xrange(len(events))):
        next_i = bisect.bisect_right(sorted_starts, events[i][1]) - 1
        for j in xrange(1, k + 1):
            dp[i][j] = max(dp[i + 1][j], dp[next_i + 1][j - 1] + events[i][2])
    return dp[0][-1]


import heapq


class Solution(object):
    def maxEvents(self, events):

    events.sort(reverse=True)
    min_heap = []
    result = 0
    for d in xrange(1, max(events, key=lambda x: x[1])[1] + 1):
        while events and events[-1][0] == d:
            heapq.heappush(min_heap, events.pop()[1])
        while min_heap and min_heap[0] == d - 1:
            heapq.heappop(min_heap)
        if not min_heap:
            continue
        heapq.heappop(min_heap)
        result += 1
    return result


class Solution(object):
    def maxNonOverlapping(self, nums, target):

    lookup = {0: -1}
    result, accu, right = 0, 0, -1
    for i, num in enumerate(nums):
        accu += num
        if accu - target in lookup and lookup[accu - target] >= right:
            right = i
            result += 1
        lookup[accu] = i
    return result


class Solution(object):
    def maxNumOfSubstrings(self, s):

    def find_right_from_left(s, first, last, left):
        right, i = last[ord(s[left]) - ord("a")], left
        while i <= right:
            if first[ord(s[i]) - ord("a")] < left:
                return -1
            right = max(right, last[ord(s[i]) - ord("a")])
            i += 1
        return right

    first, last = [float("inf")] * 26, [float("-inf")] * 26
    for i, c in enumerate(s):
        first[ord(c) - ord("a")] = min(first[ord(c) - ord("a")], i)
        last[ord(c) - ord("a")] = max(last[ord(c) - ord("a")], i)
    result = [""]
    right = float("inf")
    for left, c in enumerate(s):
        if left != first[ord(c) - ord("a")]:
            continue
        new_right = find_right_from_left(s, first, last, left)
        if new_right == -1:
            continue
        if left > right:
            result.append("")
        right = new_right
        result[-1] = s[left: right + 1]
    return result


class Solution2(object):
    def maxNumOfSubstrings(self, s):

    def find_right_from_left(s, first, last, left):
        right, i = last[ord(s[left]) - ord("a")], left
        while i <= right:
            if first[ord(s[i]) - ord("a")] < left:
                return -1
            right = max(right, last[ord(s[i]) - ord("a")])
            i += 1
        return right

    first, last = [float("inf")] * 26, [float("-inf")] * 26
    for i, c in enumerate(s):
        first[ord(c) - ord("a")] = min(first[ord(c) - ord("a")], i)
        last[ord(c) - ord("a")] = max(last[ord(c) - ord("a")], i)
    intervals = []
    for c in xrange(len(first)):
        if first[c] == float("inf"):
            continue
        left, right = first[c], find_right_from_left(s, first, last, first[c])
        if right != -1:
            intervals.append((right, left))
    intervals.sort()
    result, prev = [], -1
    for right, left in intervals:
        if left <= prev:
            continue
        result.append(s[left: right + 1])
        prev = right
    return result


import collections


class Solution(object):
    def maxFreq(self, s, maxLetters, minSize, maxSize):

    M, p = 10 ** 9 + 7, 113
    power, rolling_hash = pow(p, minSize - 1, M), 0

    left = 0
    lookup, count = collections.defaultdict(int), collections.defaultdict(int)
    for right in xrange(len(s)):
        count[s[right]] += 1
        if right - left + 1 > minSize:
            count[s[left]] -= 1
            rolling_hash = (rolling_hash - ord(s[left]) * power) % M
            if count[s[left]] == 0:
                count.pop(s[left])
            left += 1
        rolling_hash = (rolling_hash * p + ord(s[right])) % M
        if right - left + 1 == minSize and len(count) <= maxLetters:
            lookup[rolling_hash] += 1
    return max(lookup.values() or [0])


class Solution2(object):
    def maxFreq(self, s, maxLetters, minSize, maxSize):

    lookup = {}
    for right in xrange(minSize - 1, len(s)):
        word = s[right - minSize + 1: right + 1]
        if word in lookup:
            lookup[word] += 1
        elif len(collections.Counter(word)) <= maxLetters:
            lookup[word] = 1
    return max(lookup.values() or [0])


class Solution(object):
    def maximumNumberOfOnes(self, width, height, sideLength, maxOnes):

    if width < height:
        width, height = height, width

    R, r = divmod(height, sideLength)
    C, c = divmod(width, sideLength)
    assert R <= C
    area_counts = [
        (r * c, (R + 1) * (C + 1)),
        (r * (sideLength - c), (R + 1) * C),
        ((sideLength - r) * c, R * (C + 1)),
        ((sideLength - r) * (sideLength - c), R * C),
    ]
    result = 0
    for area, count in area_counts:
        area = min(maxOnes, area)
        result += count * area
        maxOnes -= area
        if not maxOnes:
            break
    return result


import math


class Solution(object):
    def visiblePoints(self, points, angle, location):

    arr, extra = [], 0
    for p in points:
        if p == location:
            extra += 1
            continue
        arr.append(math.atan2(p[1] - location[1], p[0] - location[0]))
    arr.sort()
    arr.extend([x + 2.0 * math.pi for x in arr])
    d = 2.0 * math.pi * (angle / 360.0)
    left = result = 0
    for right in xrange(len(arr)):
        while arr[right] - arr[left] > d:
            left += 1
        result = max(result, right - left + 1)
    return result + extra


class Solution(object):
    def maxVowels(self, s, k):

    VOWELS = set("aeiou")
    result = curr = 0
    for i, c in enumerate(s):
        curr += c in VOWELS
        if i >= k:
            curr -= s[i - k] in VOWELS
        result = max(result, curr)
    return result


class Solution(object):
    def maxAbsValExpr(self, arr1, arr2):

    result = 0
    for c1 in [1, -1]:
        for c2 in [1, -1]:
            min_prev = float("inf")
            for i in xrange(len(arr1)):
                curr = c1 * arr1[i] + c2 * arr2[i] + i
                result = max(result, curr - min_prev)
                min_prev = min(min_prev, curr)
    return result


class Solution2(object):
    def maxAbsValExpr(self, arr1, arr2):

    return max(
        max(c1 * arr1[i] + c2 * arr2[i] + i for i in xrange(len(arr1)))
        - min(c1 * arr1[i] + c2 * arr2[i] + i for i in xrange(len(arr1)))
        for c1 in [1, -1]
        for c2 in [1, -1]
    )


import itertools
import heapq


class Solution(object):
    def maxPerformance(self, n, speed, efficiency, k):

    MOD = 10 ** 9 + 7
    result, s_sum = 0, 0
    min_heap = []
    for e, s in sorted(itertools.izip(efficiency, speed), reverse=True):
        s_sum += s
        heapq.heappush(min_heap, s)
        if len(min_heap) > k:
            s_sum -= heapq.heappop(min_heap)
        result = max(result, s_sum * e)
    return result % MOD


class Solution(object):
    def maxScore(self, cardPoints, k):

    result, total, curr, left = float("inf"), 0, 0, 0
    for right, point in enumerate(cardPoints):
        total += point
        curr += point
        if right - left + 1 > len(cardPoints) - k:
            curr -= cardPoints[left]
            left += 1
        if right - left + 1 == len(cardPoints) - k:
            result = min(result, curr)
    return total - result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def maxProduct(self, root):

    MOD = 10 ** 9 + 7

    def dfs(root, total, result):
        if not root:
            return 0
        subtotal = (
            dfs(root.left, total, result)
            + dfs(root.right, total, result)
            + root.val
        )
        result[0] = max(result[0], subtotal * (total - subtotal))
        return subtotal

    result = [0]
    dfs(root, dfs(root, 0, result), result)
    return result[0] % MOD


class Solution(object):
    def maximumProduct(self, nums):

    min1, min2 = float("inf"), float("inf")
    max1, max2, max3 = float("-inf"), float("-inf"), float("-inf")

    for n in nums:
        if n <= min1:
            min2 = min1
            min1 = n
        elif n <= min2:
            min2 = n

        if n >= max1:
            max3 = max2
            max2 = max1
            max1 = n
        elif n >= max2:
            max3 = max2
            max2 = n
        elif n >= max3:
            max3 = n

    return max(min1 * min2 * max1, max1 * max2 * max3)


class Solution(object):
    def maxProduct(self, nums):

    m1 = m2 = 0
    for num in nums:
        if num > m1:
            m1, m2 = num, m1
        elif num > m2:
            m2 = num
    return (m1 - 1) * (m2 - 1)


class Solution(object):
    def maxProduct(self, words):

    def counting_sort(words):
        k = 1000
        buckets = [[] for _ in xrange(k)]
        for word in words:
            buckets[len(word)].append(word)
        res = []
        for i in reversed(xrange(k)):
            if buckets[i]:
                res += buckets[i]
        return res

    words = counting_sort(words)
    bits = [0] * len(words)
    for i, word in enumerate(words):
        for c in word:
            bits[i] |= 1 << (ord(c) - ord("a"))

    max_product = 0
    for i in xrange(len(words) - 1):
        if len(words[i]) ** 2 <= max_product:
            break
        for j in xrange(i + 1, len(words)):
            if len(words[i]) * len(words[j]) <= max_product:
                break
            if not (bits[i] & bits[j]):
                max_product = len(words[i]) * len(words[j])
    return max_product


class Solution2(object):
    def maxProduct(self, words):

    words.sort(key=lambda x: len(x), reverse=True)
    bits = [0] * len(words)
    for i, word in enumerate(words):
        for c in word:
            bits[i] |= 1 << (ord(c) - ord("a"))

    max_product = 0
    for i in xrange(len(words) - 1):
        if len(words[i]) ** 2 <= max_product:
            break
        for j in xrange(i + 1, len(words)):
            if len(words[i]) * len(words[j]) <= max_product:
                break
            if not (bits[i] & bits[j]):
                max_product = len(words[i]) * len(words[j])
    return max_product


class Solution(object):

    def maxProduct(self, A):
    global_max, local_max, local_min = float("-inf"), 1, 1
    for x in A:
        local_max, local_min = max(x, local_max * x, local_min * x), min(
            x, local_max * x, local_min * x
        )
        global_max = max(global_max, local_max)
    return global_max


class Solution2(object):

    def maxProduct(self, A):
    global_max, local_max, local_min = float("-inf"), 1, 1
    for x in A:
        local_max = max(1, local_max)
        if x > 0:
            local_max, local_min = local_max * x, local_min * x
        else:
            local_max, local_min = local_min * x, local_max * x
        global_max = max(global_max, local_max)
    return global_max


import itertools
import bisect


class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):

    jobs = sorted(itertools.izip(endTime, startTime, profit))
    dp = [(0, 0)]
    for e, s, p in jobs:
        i = bisect.bisect_right(dp, (s + 1, 0)) - 1
        if dp[i][1] + p > dp[-1][1]:
            dp.append((e, dp[i][1] + p))
    return dp[-1][1]


import heapq


class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):

    min_heap = zip(startTime, endTime, profit)
    heapq.heapify(min_heap)
    result = 0
    while min_heap:
        s, e, p = heapq.heappop(min_heap)
        if s < e:
            heapq.heappush(min_heap, (e, s, result + p))
        else:
            result = max(result, p)
    return result


class Solution(object):
    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):

    max_run = -1
    i = max_prof = prof = waiting = 0
    run = 1
    while i < len(customers) or waiting > 0:
        if i < len(customers):
            waiting += customers[i]
            i += 1
        boarding = min(waiting, 4)
        waiting -= boarding
        prof += boarding * boardingCost - runningCost
        if prof > max_prof:
            max_prof = prof
            max_run = run
        run += 1
    return max_run


class Solution(object):
    def maxRepeating(self, sequence, word):

    def getPrefix(pattern):
        prefix = [-1] * len(pattern)
        j = -1
        for i in xrange(1, len(pattern)):
            while j > -1 and pattern[j + 1] != pattern[i]:
                j = prefix[j]
            if pattern[j + 1] == pattern[i]:
                j += 1
            prefix[i] = j
        return prefix

    if len(sequence) < len(word):
        return 0

    prefix = getPrefix(word)
    result, count, j, prev = 0, 0, -1, -1
    for i in xrange(len(sequence)):
        while j > -1 and word[j + 1] != sequence[i]:
            j = prefix[j]
        if word[j + 1] == sequence[i]:
            j += 1
        if j + 1 == len(word):
            count = count + 1 if i - prev == len(word) else 1
            result = max(result, count)
            j, prev = -1, i
    return result


class Solution2(object):
    def maxRepeating(self, sequence, word):

    def getPrefix(pattern):
        prefix = [-1] * len(pattern)
        j = -1
        for i in xrange(1, len(pattern)):
            while j > -1 and pattern[j + 1] != pattern[i]:
                j = prefix[j]
            if pattern[j + 1] == pattern[i]:
                j += 1
            prefix[i] = j
        return prefix

    if len(sequence) < len(word):
        return 0

    new_word = word * (len(sequence) // len(word))
    prefix = getPrefix(new_word)
    result, j = 0, -1
    for i in xrange(len(sequence)):
        while j > -1 and new_word[j + 1] != sequence[i]:
            j = prefix[j]
        if new_word[j + 1] == sequence[i]:
            j += 1
        result = max(result, j + 1)
        if j + 1 == len(new_word):
            break
    return result // len(word)


class Solution(object):
    def maxScore(self, s):

    result, zeros, ones = 0, 0, 0
    for i in xrange(1, len(s) - 1):
        if s[i] == "0":
            zeros += 1
        else:
            ones += 1
        result = max(result, zeros - ones)
    return result + ones + (s[0] == "0") + (s[-1] == "1")


class Solution(object):
    def maximumScore(self, nums, multipliers):

    dp = [0] * (len(multipliers) + 1)
    for l, m in enumerate(
        reversed(multipliers), start=len(nums) - len(multipliers)
    ):
        dp = [
            max(m * nums[i] + dp[i + 1], m * nums[i + l] + dp[i])
            for i in xrange(len(dp) - 1)
        ]
    return dp[0]


class Solution(object):
    def maximumScore(self, a, b, c):

    return min((a + b + c) // 2, a + b + c - max(a, b, c))


class Solution(object):
    def maximumGain(self, s, x, y):

    def score(s, a, x):
        i = result = 0
        for j in xrange(len(s)):
            s[i] = s[j]
            i += 1
            if i >= 2 and s[i - 2: i] == a:
                i -= 2
                result += x
        s[:] = s[:i]
        return result

    s, a, b = list(s), list("ab"), list("ba")
    if x < y:
        x, y = y, x
        a, b = b, a
    return score(s, a, x) + score(s, b, y)


class Solution(object):
    def maximumScore(self, nums, k):

    result = curr = nums[k]
    left = right = k
    while left - 1 >= 0 or right + 1 < len(nums):

        if (nums[left - 1] if left - 1 >= 0 else 0) <= (
            nums[right + 1] if right + 1 < len(nums) else 0
        ):
            right += 1
        else:
            left -= 1
        curr = min(curr, nums[left], nums[right])
        result = max(result, curr * (right - left + 1))
    return result


import bisect


class Solution2(object):
    def maximumScore(self, nums, k):

    def score(nums, k):
        prefix = [nums[k]] * (k + 1)
        for i in reversed(xrange(k)):
            prefix[i] = min(prefix[i + 1], nums[i])
        result = right = nums[k]
        for j in xrange(k + 1, len(nums)):
            right = min(right, nums[j])
            i = bisect.bisect_left(prefix, right)
            if i >= 0:
                result = max(result, right * (j - i + 1))
        return result

    return max(score(nums, k), score(nums[::-1], len(nums) - 1 - k))


import collections


class Solution(object):
    def maxScoreWords(self, words, letters, score):

    def backtracking(
        words, word_scores, word_counts, curr, curr_score, letter_count, result
    ):
        result[0] = max(result[0], curr_score)
        for i in xrange(curr, len(words)):
            if any(letter_count[c] < word_counts[i][c] for c in word_counts[i]):
                continue
            backtracking(
                words,
                word_scores,
                word_counts,
                i + 1,
                curr_score + word_scores[i],
                letter_count - word_counts[i],
                result,
            )

    letter_count = collections.Counter(letters)
    word_counts = map(collections.Counter, words)
    word_scores = [
        sum(score[ord(c) - ord("a")] for c in words[i]) for i in xrange(len(words))
    ]
    result = [0]
    backtracking(words, word_scores, word_counts, 0, 0, letter_count, result)
    return result[0]


class Solution(object):
    def maxSideLength(self, mat, threshold):

    def check(dp, mid, threshold):
        for i in xrange(mid, len(dp)):
            for j in xrange(mid, len(dp[0])):
                if (
                    dp[i][j]
                    - dp[i - mid][j]
                    - dp[i][j - mid]
                    + dp[i - mid][j - mid]
                    <= threshold
                ):
                    return True
        return False

    dp = [[0 for _ in xrange(len(mat[0]) + 1)] for _ in xrange(len(mat) + 1)]
    for i in xrange(1, len(mat) + 1):
        for j in xrange(1, len(mat[0]) + 1):
            dp[i][j] = (
                dp[i - 1][j] + dp[i][j - 1] -
                dp[i - 1][j - 1] + mat[i - 1][j - 1]
            )

    left, right = 0, min(len(mat), len(mat[0]) + 1)
    while left <= right:
        mid = left + (right - left) // 2
        if not check(dp, mid, threshold):
            right = mid - 1
        else:
            left = mid + 1
    return right


class Solution(object):
    def maxSubArrayLen(self, nums, k):

    sums = {}
    cur_sum, max_len = 0, 0
    for i in xrange(len(nums)):
        cur_sum += nums[i]
        if cur_sum == k:
            max_len = i + 1
        elif cur_sum - k in sums:
            max_len = max(max_len, i - sums[cur_sum - k])
        if cur_sum not in sums:
            sums[cur_sum] = i
    return max_len


import collections


def bipartiteMatch(graph):

    matching = {}
    for u in graph:
    for v in graph[u]:
        if v not in matching:
            matching[v] = u
            break

    while 1:

    preds = {}
    unmatched = []
    pred = dict([(u, unmatched) for u in graph])
    for v in matching:
        del pred[matching[v]]
    layer = list(pred)

    while layer and not unmatched:
        newLayer = {}
        for u in layer:
            for v in graph[u]:
                if v not in preds:
                    newLayer.setdefault(v, []).append(u)
        layer = []
        for v in newLayer:
            preds[v] = newLayer[v]
            if v in matching:
                layer.append(matching[v])
                pred[matching[v]] = v
            else:
                unmatched.append(v)

    if not unmatched:
        unlayered = {}
        for u in graph:
            for v in graph[u]:
                if v not in preds:
                    unlayered[v] = None
        return (matching, list(pred), list(unlayered))

    def recurse(v):
        if v in preds:
            L = preds[v]
            del preds[v]
            for u in L:
                if u in pred:
                    pu = pred[u]
                    del pred[u]
                    if pu is unmatched or recurse(pu):
                        matching[v] = u
                        return 1
        return 0

    for v in unmatched:
        recurse(v)


class Solution(object):
    def maxStudents(self, seats):

    directions = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)]
    E, count = collections.defaultdict(list), 0
    for i in xrange(len(seats)):
        for j in xrange(len(seats[0])):
            if seats[i][j] != ".":
                continue
            count += 1
            if j % 2:
                continue
            for dx, dy in directions:
                ni, nj = i + dx, j + dy
                if (
                    0 <= ni < len(seats)
                    and 0 <= nj < len(seats[0])
                    and seats[ni][nj] == "."
                ):
                    E[i * len(seats[0]) + j].append(ni * len(seats[0]) + nj)
    return count - len(bipartiteMatch(E)[0])


class Solution2(object):
    def maxStudents(self, seats):

    directions = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)]

    def dfs(seats, e, lookup, matching):
        i, j = e
        for dx, dy in directions:
            ni, nj = i + dx, j + dy
            if (
                0 <= ni < len(seats)
                and 0 <= nj < len(seats[0])
                and seats[ni][nj] == "."
                and not lookup[ni][nj]
            ):
                lookup[ni][nj] = True
                if matching[ni][nj] == -1 or dfs(
                    seats, matching[ni][nj], lookup, matching
                ):
                    matching[ni][nj] = e
                    return True
        return False

    def Hungarian(seats):
        result = 0
        matching = [[-1] * len(seats[0]) for _ in xrange(len(seats))]
        for i in xrange(len(seats)):
            for j in xrange(0, len(seats[0]), 2):
                if seats[i][j] != ".":
                    continue
                lookup = [[False] * len(seats[0]) for _ in xrange(len(seats))]
                if dfs(seats, (i, j), lookup, matching):
                    result += 1
        return result

    count = 0
    for i in xrange(len(seats)):
        for j in xrange(len(seats[0])):
            if seats[i][j] == ".":
                count += 1
    return count - Hungarian(seats)


class Solution3(object):
    def maxStudents(self, seats):

    def popcount(n):
        result = 0
        while n:
            n &= n - 1
            result += 1
        return result

    dp = {0: 0}
    for row in seats:
        invalid_mask = sum(1 << c for c, v in enumerate(row) if v == "#")
        new_dp = {}
        for mask1, v1 in dp.iteritems():
            for mask2 in xrange(1 << len(seats[0])):
                if (
                    (mask2 & invalid_mask)
                    or (mask2 & (mask1 << 1))
                    or (mask2 & (mask1 >> 1))
                    or (mask2 & (mask2 << 1))
                    or (mask2 & (mask2 >> 1))
                ):
                    continue
                new_dp[mask2] = max(new_dp.get(mask2, 0), v1 + popcount(mask2))
        dp = new_dp
    return max(dp.itervalues()) if dp else 0


class Solution(object):
    def maxSumAfterOperation(self, nums):

    prev_with_square = prev_without_square = 0
    result = 0
    for num in nums:
        without_square = max(num, num + prev_without_square)
        with_square = max(
            num * num, num * num + prev_without_square, num + prev_with_square
        )
        result = max(result, with_square)
        prev_with_square, prev_without_square = with_square, without_square
    return result


class Solution(object):
    def maximumSum(self, arr):

    result, prev, curr = float("-inf"), float("-inf"), float("-inf")
    for x in arr:
        curr = max(prev, curr + x, x)
        result = max(result, curr)
        prev = max(prev + x, x)
    return result


class Solution(object):
    def maxSubArray(self, nums):

    result, curr = float("-inf"), float("-inf")
    for x in nums:
        curr = max(curr + x, x)
        result = max(result, curr)
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def maxSumBST(self, root):

    result = 0
    stk = [[root, None, []]]
    while stk:
        node, tmp, ret = stk.pop()
        if tmp:
            lvalid, lsum, lmin, lmax = tmp[0]
            rvalid, rsum, rmin, rmax = tmp[1]
            if lvalid and rvalid and lmax < node.val < rmin:
                total = lsum + node.val + rsum
                result = max(result, total)
                ret[:] = [True, total, min(
                    lmin, node.val), max(node.val, rmax)]
                continue
            ret[:] = [False, 0, 0, 0]
            continue
        if not node:
            ret[:] = [True, 0, float("inf"), float("-inf")]
            continue
        new_tmp = [[], []]
        stk.append([node, new_tmp, ret])
        stk.append([node.right, None, new_tmp[1]])
        stk.append([node.left, None, new_tmp[0]])
    return result


class Solution2(object):
    def maxSumBST(self, root):

    def dfs(node, result):
        if not node:
            return True, 0, float("inf"), float("-inf")
        lvalid, lsum, lmin, lmax = dfs(node.left, result)
        rvalid, rsum, rmin, rmax = dfs(node.right, result)
        if lvalid and rvalid and lmax < node.val < rmin:
            total = lsum + node.val + rsum
            result[0] = max(result[0], total)
            return True, total, min(lmin, node.val), max(node.val, rmax)
        return False, 0, 0, 0

    result = [0]
    dfs(root, result)
    return result[0]


class Solution(object):
    def maxSubarraySumCircular(self, A):

    total, max_sum, cur_max, min_sum, cur_min = 0, - \
        float("inf"), 0, float("inf"), 0
    for a in A:
        cur_max = max(cur_max + a, a)
        max_sum = max(max_sum, cur_max)
        cur_min = min(cur_min + a, a)
        min_sum = min(min_sum, cur_min)
        total += a
    return max(max_sum, total - min_sum) if max_sum >= 0 else max_sum


import itertools


class Solution(object):
    def maxSumRangeQuery(self, nums, requests):

    def addmod(a, b, mod):
        a %= mod
        b %= mod
        if mod - a <= b:
            b -= mod
        return a + b

    def mulmod(a, b, mod):
        a %= mod
        b %= mod
        if a < b:
            a, b = b, a
        result = 0
        while b > 0:
            if b % 2 == 1:
                result = addmod(result, a, mod)
            a = addmod(a, a, mod)
            b //= 2
        return result

    MOD = 10 ** 9 + 7

    count = [0] * len(nums)
    for start, end in requests:
        count[start] += 1
        if end + 1 < len(count):
            count[end + 1] -= 1
    for i in xrange(1, len(count)):
        count[i] += count[i - 1]
    nums.sort()
    count.sort()
    result = 0
    for i, (num, c) in enumerate(itertools.izip(nums, count)):

        result = (result + num * c) % MOD
    return result


class Solution(object):
    def maxSumOfThreeSubarrays(self, nums, k):

    n = len(nums)
    accu = [0]
    for num in nums:
        accu.append(accu[-1] + num)

    left_pos = [0] * n
    total = accu[k] - accu[0]
    for i in xrange(k, n):
        if accu[i + 1] - accu[i + 1 - k] > total:
            left_pos[i] = i + 1 - k
            total = accu[i + 1] - accu[i + 1 - k]
        else:
            left_pos[i] = left_pos[i - 1]

    right_pos = [n - k] * n
    total = accu[n] - accu[n - k]
    for i in reversed(xrange(n - k)):
        if accu[i + k] - accu[i] > total:
            right_pos[i] = i
            total = accu[i + k] - accu[i]
        else:
            right_pos[i] = right_pos[i + 1]

    result, max_sum = [], 0
    for i in xrange(k, n - 2 * k + 1):
        left, right = left_pos[i - 1], right_pos[i + k]
        total = (
            (accu[i + k] - accu[i])
            + (accu[left + k] - accu[left])
            + (accu[right + k] - accu[right])
        )
        if total > max_sum:
            max_sum = total
            result = [left, i, right]
    return result


class Solution(object):
    def maxSumTwoNoOverlap(self, A, L, M):

    for i in xrange(1, len(A)):
        A[i] += A[i - 1]
    result, L_max, M_max = A[L + M - 1], A[L - 1], A[M - 1]
    for i in xrange(L + M, len(A)):
        L_max = max(L_max, A[i - M] - A[i - L - M])
        M_max = max(M_max, A[i - L] - A[i - L - M])
        result = max(result, L_max + A[i] - A[i - M], M_max + A[i] - A[i - L])
    return result


class Solution(object):
    def maximumSwap(self, num):

    digits = list(str(num))
    left, right = 0, 0
    max_idx = len(digits) - 1
    for i in reversed(xrange(len(digits))):
        if digits[i] > digits[max_idx]:
            max_idx = i
        elif digits[max_idx] > digits[i]:
            left, right = i, max_idx
    digits[left], digits[right] = digits[right], digits[left]
    return int("".join(digits))


class Solution(object):
    def maximumUnits(self, boxTypes, truckSize):

    boxTypes.sort(key=lambda x: x[1], reverse=True)
    result = 0
    for box, units in boxTypes:
        if truckSize > box:
            truckSize -= box
            result += box * units
        else:
            result += truckSize * units
            break
    return result


class Solution(object):
    def maxVacationDays(self, flights, days):

    if not days or not flights:
        return 0
    dp = [[0] * len(days) for _ in xrange(2)]
    for week in reversed(xrange(len(days[0]))):
        for cur_city in xrange(len(days)):
            dp[week % 2][cur_city] = (
                days[cur_city][week] + dp[(week + 1) % 2][cur_city]
            )
            for dest_city in xrange(len(days)):
                if flights[cur_city][dest_city] == 1:
                    dp[week % 2][cur_city] = max(
                        dp[week % 2][cur_city],
                        days[dest_city][week] + dp[(week + 1) % 2][dest_city],
                    )
    return dp[0][0]


class Solution(object):
    def widthOfBinaryTree(self, root):

    def dfs(node, i, depth, leftmosts):
        if not node:
            return 0
        if depth >= len(leftmosts):
            leftmosts.append(i)
        return max(
            i - leftmosts[depth] + 1,
            dfs(node.left, i * 2, depth + 1, leftmosts),
            dfs(node.right, i * 2 + 1, depth + 1, leftmosts),
        )

    leftmosts = []
    return dfs(root, 1, 0, leftmosts)


class Solution(object):
    def maxWidthRamp(self, A):

    result = 0
    s = []
    for i in A:
        if not s or A[s[-1]] > A[i]:
            s.append(i)
    for j in reversed(xrange(len(A))):
        while s and A[s[-1]] <= A[j]:
            result = max(result, j - s.pop())
    return result


class Solution(object):
    def findMaximumXOR(self, nums):

    result = 0

    for i in reversed(xrange(32)):
        result <<= 1
        prefixes = set()
        for n in nums:
            prefixes.add(n >> i)
        for p in prefixes:
            if (result | 1) ^ p in prefixes:
                result += 1
                break

    return result


class Trie(object):
    def __init__(self):
    self.__root = {}

    def insert(self, num):
    node = self.__root
    for i in reversed(xrange(32)):
        curr = (num >> i) & 1
        if curr not in node:
            node[curr] = {}
        node = node[curr]

    def query(self, num):
    if not self.__root:
        return -1
    node, result = self.__root, 0
    for i in reversed(xrange(32)):
        curr = (num >> i) & 1
        if 1 ^ curr in node:
            node = node[1 ^ curr]
            result |= 1 << i
        else:
            node = node[curr]
    return result


class Solution(object):
    def maximizeXor(self, nums, queries):

    nums.sort()
    queries = sorted(enumerate(queries), key=lambda x: x[1][1])
    trie = Trie()
    result = [-1] * len(queries)
    j = 0
    for i, (x, m) in queries:
        while j < len(nums) and nums[j] <= m:
            trie.insert(nums[j])
            j += 1
        result[i] = trie.query(x)
    return result


import random


class Solution(object):
    def trimMean(self, arr):

    P = 20

    def nth_element(nums, n, left=0, compare=lambda a, b: a < b):
        def tri_partition(nums, left, right, target, compare):
            mid = left
            while mid <= right:
                if nums[mid] == target:
                    mid += 1
                elif compare(nums[mid], target):
                    nums[left], nums[mid] = nums[mid], nums[left]
                    left += 1
                    mid += 1
                else:
                    nums[mid], nums[right] = nums[right], nums[mid]
                    right -= 1
            return left, right

        right = len(nums) - 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            pivot_left, pivot_right = tri_partition(
                nums, left, right, nums[pivot_idx], compare
            )
            if pivot_left <= n <= pivot_right:
                return
            elif pivot_left > n:
                right = pivot_left - 1
            else:
                left = pivot_right + 1

    k = len(arr) // P
    nth_element(arr, k - 1)
    nth_element(arr, len(arr) - k, left=k)
    return float(sum(arr[i] for i in xrange(k, len(arr) - k))) / (len(arr) - 2 * k)


class Solution(object):
    def findMedianSortedArrays(self, nums1, nums2):

    len1, len2 = len(nums1), len(nums2)
    if (len1 + len2) % 2 == 1:
        return self.getKth(nums1, nums2, (len1 + len2) / 2 + 1)
    else:
        return (
            self.getKth(nums1, nums2, (len1 + len2) / 2)
            + self.getKth(nums1, nums2, (len1 + len2) / 2 + 1)
        ) * 0.5

    def getKth(self, A, B, k):
    m, n = len(A), len(B)
    if m > n:
        return self.getKth(B, A, k)

    left, right = 0, m
    while left < right:
        mid = left + (right - left) / 2
        if 0 <= k - 1 - mid < n and A[mid] >= B[k - 1 - mid]:
            right = mid
        else:
            left = mid + 1

    Ai_minus_1 = A[left - 1] if left - 1 >= 0 else float("-inf")
    Bj = B[k - 1 - left] if k - 1 - left >= 0 else float("-inf")

    return max(Ai_minus_1, Bj)


class Solution_Generic(object):
    def findMedianSortedArrays(self, nums1, nums2):

    array = [nums1, nums2]
    total = sum(len(nums) for nums in array)
    if total % 2 == 1:
        return self.getKth(array, total // 2 + 1)
    else:
        return (
            self.getKth(array, total // 2) + self.getKth(array, total // 2 + 1)
        ) * 0.5

    def getKth(self, arrays, k):

    def binary_search(array, left, right, target, check):
        while left <= right:
            mid = left + (right - left) // 2
            if check(array, mid, target):
                right = mid - 1
            else:
                left = mid + 1
        return left

    def check(arrays, num, target):
        res = 0
        for array in arrays:
            if array:
                res += binary_search(
                    array, 0, len(array) -
                    1, num, lambda array, x, y: array[x] > y
                )
        return res >= target

    left, right = float("inf"), float("-inf")
    for array in arrays:
        if array:
            left = min(left, array[0])
            right = max(right, array[-1])
    return binary_search(arrays, left, right, k, check)


class Solution_3(object):
    def findMedianSortedArrays(self, A, B):

    if A is None and B is None:
        return -1.0
    lenA = len(A)
    lenB = len(B)
    lenn = lenA + lenB

    indexA, indexB, indexC = 0, 0, 0
    C = [False for i in xrange(lenn)]
    while indexA < lenA and indexB < lenB:
        if A[indexA] < B[indexB]:
            C[indexC] = A[indexA]
            indexC += 1
            indexA += 1
        else:
            C[indexC] = B[indexB]
            indexC += 1
            indexB += 1

    while indexA < lenA:
        C[indexC] = A[indexA]
        indexC += 1
        indexA += 1

    while indexB < lenB:
        C[indexC] = B[indexB]
        indexC += 1
        indexB += 1

    indexM1 = (lenn - 1) / 2
    indexM2 = lenn / 2

    if lenn % 2 == 0:
        return (C[indexM1] + C[indexM2]) / 2.0
    else:
        return C[indexM2] / 1.0


class Solution(object):

    def minMeetingRooms(self, intervals):
    result, curr = 0, 0
    line = [x for i, j in intervals for x in [[i, 1], [j, -1]]]
    line.sort()
    for _, num in line:
        curr += num
        result = max(result, curr)
    return result


class Solution2(object):

    def minMeetingRooms(self, intervals):
    starts, ends = [], []
    for start, end in intervals:
        starts.append(start)
        ends.append(end)

    starts.sort()
    ends.sort()

    s, e = 0, 0
    min_rooms, cnt_rooms = 0, 0
    while s < len(starts):
        if starts[s] < ends[e]:
            cnt_rooms += 1

            min_rooms = max(min_rooms, cnt_rooms)
            s += 1
        else:
            cnt_rooms -= 1
            e += 1

    return min_rooms


from heapq import heappush, heappop


class Solution3(object):
    def minMeetingRooms(self, intervals):

    if not intervals:
        return 0

    intervals.sort(key=lambda x: x[0])
    free_rooms = []

    heappush(free_rooms, intervals[0][1])
    for interval in intervals[1:]:
        if free_rooms[0] <= interval[0]:
            heappop(free_rooms)

        heappush(free_rooms, interval[1])

    return len(free_rooms)


class Solution(object):
    def canAttendMeetings(self, intervals):

    intervals.sort(key=lambda x: x[0])

    for i in xrange(1, len(intervals)):
        if intervals[i][0] < intervals[i - 1][1]:
            return False
    return True


import heapq


class Solution(object):
    def minAvailableDuration(self, slots1, slots2, duration):

    min_heap = list(
        filter(lambda slot: slot[1] - slot[0] >= duration, slots1 + slots2)
    )
    heapq.heapify(min_heap)
    while len(min_heap) > 1:
        left = heapq.heappop(min_heap)
        right = min_heap[0]
        if left[1] - right[0] >= duration:
            return [right[0], right[0] + duration]
    return []


class Solution2(object):
    def minAvailableDuration(self, slots1, slots2, duration):

    slots1.sort(key=lambda x: x[0])
    slots2.sort(key=lambda x: x[0])
    i, j = 0, 0
    while i < len(slots1) and j < len(slots2):
        left = max(slots1[i][0], slots2[j][0])
        right = min(slots1[i][1], slots2[j][1])
        if left + duration <= right:
            return [left, left + duration]
        if slots1[i][1] < slots2[j][1]:
            i += 1
        else:
            j += 1
    return []


class ListNode(object):
    def __init__(self, val=0, next=None):
    pass


class Solution(object):
    def mergeInBetween(self, list1, a, b, list2):

    prev_first, last = None, list1
    for i in xrange(b):
        if i == a - 1:
            prev_first = last
        last = last.next
    prev_first.next = list2
    while list2.next:
        list2 = list2.next
    list2.next = last.next
    last.next = None
    return list1


class Solution(object):
    def merge(self, intervals):

    intervals.sort()
    result = []
    for interval in intervals:
        if not result or interval[0] > result[-1][1]:
            result.append(interval)
        else:
            result[-1][1] = max(result[-1][1], interval[1])
    return result


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self:
        return "{} -> {}".format(self.val, self.next)


class Solution(object):
    def mergeKLists(self, lists):

    def mergeTwoLists(l1, l2):
        curr = dummy = ListNode(0)
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next

    if not lists:
        return None
    left, right = 0, len(lists) - 1
    while right > 0:
        lists[left] = mergeTwoLists(lists[left], lists[right])
        left += 1
        right -= 1
        if left >= right:
            left = 0
    return lists[0]


class Solution2(object):

    def mergeKLists(self, lists):

    def mergeTwoLists(l1, l2):
        curr = dummy = ListNode(0)
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next

    def mergeKListsHelper(lists, begin, end):
        if begin > end:
            return None
        if begin == end:
            return lists[begin]
        return mergeTwoLists(
            mergeKListsHelper(lists, begin, (begin + end) / 2),
            mergeKListsHelper(lists, (begin + end) / 2 + 1, end),
        )

    return mergeKListsHelper(lists, 0, len(lists) - 1)


import heapq


class Solution3(object):

    def mergeKLists(self, lists):
    dummy = ListNode(0)
    current = dummy

    heap = []
    for sorted_list in lists:
        if sorted_list:
            heapq.heappush(heap, (sorted_list.val, sorted_list))

    while heap:
        smallest = heapq.heappop(heap)[1]
        current.next = smallest
        current = current.next
        if smallest.next:
            heapq.heappush(heap, (smallest.next.val, smallest.next))

    return dummy.next


class Solution(object):

    def merge(self, A, m, B, n):
    last, i, j = m + n - 1, m - 1, n - 1

    while i >= 0 and j >= 0:
        if A[i] > B[j]:
            A[last] = A[i]
            last, i = last - 1, i - 1
        else:
            A[last] = B[j]
            last, j = last - 1, j - 1

    while j >= 0:
        A[last] = B[j]
        last, j = last - 1, j - 1


class Solution(object):
    def mergeAlternately(self, word1, word2):

    result = []
    i = 0
    while i < len(word1) or i < len(word2):
        if i < len(word1):
            result.append(word1[i])
        if i < len(word2):
            result.append(word2[i])
        i += 1
    return "".join(result)


class Solution(object):
    def mergeTrees(self, t1, t2):

    if t1 is None:
        return t2
    if t2 is None:
        return t1
    t1.val += t2.val
    t1.left = self.mergeTrees(t1.left, t2.left)
    t1.right = self.mergeTrees(t1.right, t2.right)
    return t1


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self:
        return "{} -> {}".format(self.val, self.next)


class Solution(object):
    def mergeTwoLists(self, l1, l2):

    curr = dummy = ListNode(0)
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):
    def middleNode(self, head):

    slow, fast = head, head
    while fast and fast.next:
        slow, fast = slow.next, fast.next.next
    return slow


class Solution(object):
    def minCostClimbingStairs(self, cost):

    dp = [0] * 3
    for i in reversed(xrange(len(cost))):
        dp[i % 3] = cost[i] + min(dp[(i + 1) % 3], dp[(i + 2) % 3])
    return min(dp[0], dp[1])


class Solution(object):
    def minCostConnectPoints(self, points):

    result, u = 0, 0
    dist = [float("inf")] * len(points)
    lookup = set()
    for _ in xrange(len(points) - 1):
        x0, y0 = points[u]
        lookup.add(u)
        for v, (x, y) in enumerate(points):
            if v in lookup:
                continue
            dist[v] = min(dist[v], abs(x - x0) + abs(y - y0))
        val, u = min((val, v) for v, val in enumerate(dist))
        dist[u] = float("inf")
        result += val
    return result


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.rank = [0] * n

    def find_set(self, x):
    stk = []
    while self.set[x] != x:
        stk.append(x)
        x = self.set[x]
    while stk:
        self.set[stk.pop()] = x
    return x

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    if self.rank[x_root] < self.rank[y_root]:
        self.set[x_root] = y_root
    elif self.rank[x_root] > self.rank[y_root]:
        self.set[y_root] = x_root
    else:
        self.set[y_root] = x_root
        self.rank[x_root] += 1
    return True


class Solution2(object):
    def minCostConnectPoints(self, points):

    edges = []
    for u in xrange(len(points)):
        for v in xrange(u + 1, len(points)):
            edges.append(
                (
                    u,
                    v,
                    abs(points[v][0] - points[u][0])
                    + abs(points[v][1] - points[u][1]),
                )
            )
    edges.sort(key=lambda x: x[2])
    result = 0
    union_find = UnionFind(len(points))
    for u, v, val in edges:
        if union_find.union_set(u, v):
            result += val
    return result


class MinStack(object):
    def __init__(self):
    self.min = None
    self.stack = []

    def push(self, x):
    if not self.stack:
        self.stack.append(0)
        self.min = x
    else:
        self.stack.append(x - self.min)
        if x < self.min:
            self.min = x

    def pop(self):
    x = self.stack.pop()
    if x < 0:
        self.min = self.min - x

    def top(self):
    x = self.stack[-1]
    if x > 0:
        return x + self.min
    else:
        return self.min

    def getMin(self):
    return self.min


class MinStack2(object):
    def __init__(self):
    self.stack, self.minStack = [], []

    def push(self, x):
    self.stack.append(x)
    if len(self.minStack):
        if x < self.minStack[-1][0]:
            self.minStack.append([x, 1])
        elif x == self.minStack[-1][0]:
            self.minStack[-1][1] += 1
    else:
        self.minStack.append([x, 1])

    def pop(self):
    x = self.stack.pop()
    if x == self.minStack[-1][0]:
        self.minStack[-1][1] -= 1
        if self.minStack[-1][1] == 0:
            self.minStack.pop()

    def top(self):
    return self.stack[-1]

    def getMin(self):
    return self.minStack[-1][0]


class MinStack3(object):
    def __init__(self):
    self.stack = []

    def push(self, x):
    if self.stack:
        current_min = min(x, self.stack[-1][0])
        self.stack.append((current_min, x))
    else:
        self.stack.append((x, x))

    def pop(self):
    return self.stack.pop()[1]

    def top(self):
    return self.stack[-1][1]

    def getMin(self):
    return self.stack[-1][0]


import collections


class Solution(object):
    def updateBoard(self, board, click):

    q = collections.deque([click])
    while q:
        row, col = q.popleft()
        if board[row][col] == "M":
            board[row][col] = "X"
        else:
            count = 0
            for i in xrange(-1, 2):
                for j in xrange(-1, 2):
                    if i == 0 and j == 0:
                        continue
                    r, c = row + i, col + j
                    if not (0 <= r < len(board)) or not (0 <= c < len(board[r])):
                        continue
                    if board[r][c] == "M" or board[r][c] == "X":
                        count += 1

            if count:
                board[row][col] = chr(count + ord("0"))
            else:
                board[row][col] = "B"
                for i in xrange(-1, 2):
                    for j in xrange(-1, 2):
                        if i == 0 and j == 0:
                            continue
                        r, c = row + i, col + j
                        if not (0 <= r < len(board)) or not (
                            0 <= c < len(board[r])
                        ):
                            continue
                        if board[r][c] == "E":
                            q.append((r, c))
                            board[r][c] = " "

    return board


class Solution2(object):
    def updateBoard(self, board, click):

    row, col = click[0], click[1]
    if board[row][col] == "M":
        board[row][col] = "X"
    else:
        count = 0
        for i in xrange(-1, 2):
            for j in xrange(-1, 2):
                if i == 0 and j == 0:
                    continue
                r, c = row + i, col + j
                if not (0 <= r < len(board)) or not (0 <= c < len(board[r])):
                    continue
                if board[r][c] == "M" or board[r][c] == "X":
                    count += 1

        if count:
            board[row][col] = chr(count + ord("0"))
        else:
            board[row][col] = "B"
            for i in xrange(-1, 2):
                for j in xrange(-1, 2):
                    if i == 0 and j == 0:
                        continue
                    r, c = row + i, col + j
                    if not (0 <= r < len(board)) or not (0 <= c < len(board[r])):
                        continue
                    if board[r][c] == "E":
                        self.updateBoard(board, (r, c))

    return board


class NestedInteger(object):
    def __init__(self, value=None):

    def isInteger(self):

    def add(self, elem):

    def setInteger(self, value):

    def getInteger(self):

    def getList(self):


class Solution(object):
    def deserialize(self, s):
    if not s:
        return NestedInteger()

    if s[0] != "[":
        return NestedInteger(int(s))

    stk = []

    i = 0
    for j in xrange(len(s)):
        if s[j] == "[":
            stk += (NestedInteger(),)
            i = j + 1
        elif s[j] in ",]":
            if s[j - 1].isdigit():
                stk[-1].add(NestedInteger(int(s[i:j])))
            if s[j] == "]" and len(stk) > 1:
                cur = stk[-1]
                stk.pop()
                stk[-1].add(cur)
            i = j + 1

    return stk[-1]


import heapq


class Solution(object):
    def minimumDeviation(self, nums):

    max_heap = [-num * 2 if num % 2 else -num for num in nums]
    heapq.heapify(max_heap)
    min_elem = -max(max_heap)
    result = float("inf")
    while len(max_heap) == len(nums):
        num = -heapq.heappop(max_heap)
        result = min(result, num - min_elem)
        if not num % 2:
            min_elem = min(min_elem, num // 2)
            heapq.heappush(max_heap, -num // 2)
    return result


class Solution(object):
    def minimumHammingDistance(self, source, target, allowedSwaps):

    def iter_flood_fill(adj, node, lookup, idxs):
        stk = [node]
        while stk:
            node = stk.pop()
            if node in lookup:
                continue
            lookup.add(node)
            idxs.append(node)
            for child in adj[node]:
                stk.append(child)

    adj = [set() for i in xrange(len(source))]
    for i, j in allowedSwaps:
        adj[i].add(j)
        adj[j].add(i)
    result = 0
    lookup = set()
    for i in xrange(len(source)):
        if i in lookup:
            continue
        idxs = []
        iter_flood_fill(adj, i, lookup, idxs)
        source_cnt = collections.Counter([source[i] for i in idxs])
        target_cnt = collections.Counter([target[i] for i in idxs])
        diff = source_cnt - target_cnt
        result += sum(diff.itervalues())
    return result


import collections


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.rank = [0] * n

    def find_set(self, x):
    stk = []
    while self.set[x] != x:
        stk.append(x)
        x = self.set[x]
    while stk:
        self.set[stk.pop()] = x
    return x

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    if self.rank[x_root] < self.rank[y_root]:
        self.set[x_root] = y_root
    elif self.rank[x_root] > self.rank[y_root]:
        self.set[y_root] = x_root
    else:
        self.set[y_root] = x_root
        self.rank[x_root] += 1
    return True


class Solution2(object):
    def minimumHammingDistance(self, source, target, allowedSwaps):

    uf = UnionFind(len(source))
    for x, y in allowedSwaps:
        uf.union_set(x, y)
    groups = collections.defaultdict(set)
    for i in xrange(len(source)):
        groups[uf.find_set(i)].add(i)
    result = 0
    for idxs in groups.itervalues():
        source_cnt = collections.Counter([source[i] for i in idxs])
        target_cnt = collections.Counter([target[i] for i in idxs])
        diff = source_cnt - target_cnt
        result += sum(diff.itervalues())
    return result


import collections


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    return True


class Solution(object):
    def minMalwareSpread(self, graph, initial):

    initial_set = set(initial)
    clean = [i for i in xrange(len(graph)) if i not in initial_set]
    union_find = UnionFind(len(graph))
    for i in xrange(len(clean)):
        for j in xrange(i + 1, len(clean)):
            if graph[clean[i]][clean[j]] == 1:
                union_find.union_set(clean[i], clean[j])
    union_size = collections.Counter(
        union_find.find_set(i) for i in xrange(len(graph))
    )

    shared_union = collections.defaultdict(set)
    for i in initial:
        for j in clean:
            if graph[i][j] == 1:
                x = union_find.find_set(j)
                shared_union[x].add(i)

    result, total = float("inf"), float("-inf")
    for i in initial:
        lookup = set()
        curr = 0
        for j in clean:
            if graph[i][j] == 1:
                x = union_find.find_set(j)
                if len(shared_union[x]) == 1 and x not in lookup:
                    curr += union_size[x]
                    lookup.add(x)
        if curr > total or (curr == total and i < result):
            total = curr
            result = i
    return result


import collections


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    return True


class Solution(object):
    def minMalwareSpread(self, graph, initial):

    union_find = UnionFind(len(graph))
    for i in xrange(len(graph)):
        for j in xrange(i + 1, len(graph)):
            if graph[i][j] == 1:
                union_find.union_set(i, j)
    union_size = collections.Counter(
        union_find.find_set(i) for i in xrange(len(graph))
    )
    malware_count = collections.Counter(
        union_find.find_set(i) for i in initial)
    return min(
        initial,
        key=lambda x: [
            malware_count[union_find.find_set(x)] > 1,
            -union_size[union_find.find_set(x)],
            x,
        ],
    )


class Solution(object):
    def minmaxGasDist(self, stations, K):

    def possible(stations, K, guess):
        return (
            sum(
                int((stations[i + 1] - stations[i]) / guess)
                for i in xrange(len(stations) - 1)
            )
            <= K
        )

    left, right = 0, 10 ** 8
    while right - left > 1e-6:
        mid = left + (right - left) / 2.0
        if possible(mid):
            right = mid
        else:
            left = mid
    return left


import math
import random


class Solution(object):
    def minimizeError(self, prices, target):

    def kthElement(nums, k, compare=lambda a, b: a < b):
        def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in xrange(left, right):
                if compare(nums[i], nums[right]):
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            new_pivot_idx = PartitionAroundPivot(
                left, right, pivot_idx, nums, compare
            )
            if new_pivot_idx == k:
                return
            elif new_pivot_idx > k:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    errors = []
    lower, upper = 0, 0
    for i, p in enumerate(map(float, prices)):
        lower += int(math.floor(p))
        upper += int(math.ceil(p))
        if p != math.floor(p):
            errors.append(p - math.floor(p))
    if not lower <= target <= upper:
        return "-1"

    lower_round_count = upper - target
    kthElement(errors, lower_round_count)
    result = 0.0
    for i in xrange(len(errors)):
        if i < lower_round_count:
            result += errors[i]
        else:
            result += 1.0 - errors[i]
    return "{:.3f}".format(result)


class Solution(object):
    def getMinimumDifference(self, root):

    def inorderTraversal(root, prev, result):
        if not root:
            return (result, prev)

        result, prev = inorderTraversal(root.left, prev, result)
        if prev:
            result = min(result, root.val - prev.val)
        return inorderTraversal(root.right, root, result)

    return inorderTraversal(root, None, float("inf"))[0]


class Solution(object):
    def minimumAbsDifference(self, arr):

    result = []
    min_diff = float("inf")
    arr.sort()
    for i in xrange(len(arr) - 1):
        diff = arr[i + 1] - arr[i]
        if diff < min_diff:
            min_diff = diff
            result = [[arr[i], arr[i + 1]]]
        elif diff == min_diff:
            result.append([arr[i], arr[i + 1]])
    return result


class Solution(object):
    def minAddToMakeValid(self, S):

    add, bal, = (
        0,
        0,
    )
    for c in S:
        bal += 1 if c == "(" else -1
        if bal == -1:
            add += 1
            bal += 1
    return add + bal


class Solution(object):
    def minMoves(self, nums, k):

    def moves(i, j):
        return prefix[j + 1] - prefix[i]

    idxs = [i for i, x in enumerate(nums) if x]
    prefix = [0] * (len(idxs) + 1)
    for i in xrange(len(idxs)):
        prefix[i + 1] = prefix[i] + idxs[i]
    result = float("inf")
    for i in xrange(len(idxs) - k + 1):
        result = min(
            result, -moves(i, i + k // 2 - 1) +
            moves(i + (k + 1) // 2, i + k - 1)
        )
    result -= (k // 2) * (
        (k + 1) // 2
    )
    return result


import collections
import itertools


class Solution(object):
    def minAreaFreeRect(self, points):

    points.sort()
    points = [complex(*z) for z in points]
    lookup = collections.defaultdict(list)
    for P, Q in itertools.combinations(points, 2):
        lookup[P - Q].append((P + Q) / 2)

    result = float("inf")
    for A, candidates in lookup.iteritems():
        for P, Q in itertools.combinations(candidates, 2):
            if A.real * (P - Q).real + A.imag * (P - Q).imag == 0.0:
                result = min(result, abs(A) * abs(P - Q))
    return result if result < float("inf") else 0.0


import collections


class Solution(object):
    def minAreaRect(self, points):

    nx = len(set(x for x, y in points))
    ny = len(set(y for x, y in points))

    p = collections.defaultdict(list)
    if nx > ny:
        for x, y in points:
            p[x].append(y)
    else:
        for x, y in points:
            p[y].append(x)

    lookup = {}
    result = float("inf")
    for x in sorted(p):
        p[x].sort()
        for j in xrange(len(p[x])):
            for i in xrange(j):
                y1, y2 = p[x][i], p[x][j]
                if (y1, y2) in lookup:
                    result = min(result, (x - lookup[y1, y2]) * (y2 - y1))
                lookup[y1, y2] = x
    return result if result != float("inf") else 0


class Solution2(object):
    def minAreaRect(self, points):

    lookup = set()
    result = float("inf")
    for x1, y1 in points:
        for x2, y2 in lookup:
            if (x1, y2) in lookup and (x2, y1) in lookup:
                result = min(result, abs(x1 - x2) * abs(y1 - y2))
        lookup.add((x1, y1))
    return result if result != float("inf") else 0


class Solution(object):
    def minimumDeleteSum(self, s1, s2):

    dp = [[0] * (len(s2) + 1) for _ in xrange(2)]
    for j in xrange(len(s2)):
        dp[0][j + 1] = dp[0][j] + ord(s2[j])

    for i in xrange(len(s1)):
        dp[(i + 1) % 2][0] = dp[i % 2][0] + ord(s1[i])
        for j in xrange(len(s2)):
            if s1[i] == s2[j]:
                dp[(i + 1) % 2][j + 1] = dp[i % 2][j]
            else:
                dp[(i + 1) % 2][j + 1] = min(
                    dp[i % 2][j + 1] +
                    ord(s1[i]), dp[(i + 1) % 2][j] + ord(s2[j])
                )

    return dp[len(s1) % 2][-1]


class Solution2(object):
    def minimumDeleteSum(self, s1, s2):

    dp = [[0] * (len(s2) + 1) for _ in xrange(len(s1) + 1)]
    for i in xrange(len(s1)):
        dp[i + 1][0] = dp[i][0] + ord(s1[i])
    for j in xrange(len(s2)):
        dp[0][j + 1] = dp[0][j] + ord(s2[j])

    for i in xrange(len(s1)):
        for j in xrange(len(s2)):
            if s1[i] == s2[j]:
                dp[i + 1][j + 1] = dp[i][j]
            else:
                dp[i + 1][j + 1] = min(
                    dp[i][j + 1] + ord(s1[i]), dp[i + 1][j] + ord(s2[j])
                )

    return dp[-1][-1]


class Solution(object):
    def minOperations(self, s):

    cnt = sum(int(c) == i % 2 for i, c in enumerate(s))
    return min(cnt, len(s) - cnt)


class Solution(object):
    def mincostTickets(self, days, costs):

    durations = [1, 7, 30]
    W = durations[-1]
    dp = [float("inf") for i in xrange(W)]
    dp[0] = 0
    last_buy_days = [0, 0, 0]
    for i in xrange(1, len(days) + 1):
        dp[i % W] = float("inf")
        for j in xrange(len(durations)):
            while (
                i - 1 < len(days)
                and days[i - 1] > days[last_buy_days[j]] + durations[j] - 1
            ):
                last_buy_days[j] += 1
            dp[i % W] = min(dp[i % W], dp[last_buy_days[j] % W] + costs[j])
    return dp[len(days) % W]


import heapq


class Solution(object):
    def connectSticks(self, sticks):

    heapq.heapify(sticks)
    result = 0
    while len(sticks) > 1:
        x, y = heapq.heappop(sticks), heapq.heappop(sticks)
        result += x + y
        heapq.heappush(sticks, x + y)
    return result


class Solution(object):
    def connectTwoGroups(self, cost):

    total = 2 ** len(cost[0])
    dp = [[float("inf")] * total for _ in xrange(2)]
    dp[0][0] = 0
    for i in xrange(len(cost)):
        dp[(i + 1) % 2] = [float("inf")] * total
        for mask in xrange(total):
            base = 1
            for j in xrange(len(cost[0])):
                dp[i % 2][mask | base] = min(
                    dp[i % 2][mask | base], cost[i][j] + dp[i % 2][mask]
                )
                dp[(i + 1) % 2][mask | base] = min(
                    dp[(i + 1) % 2][mask | base], cost[i][j] + dp[i % 2][mask]
                )
                base <<= 1
    return dp[len(cost) % 2][-1]


class Solution(object):
    def minCost(self, n, cuts):

    sorted_cuts = sorted(cuts + [0, n])
    dp = [[0] * len(sorted_cuts) for _ in xrange(len(sorted_cuts))]
    for l in xrange(2, len(sorted_cuts)):
        for i in xrange(len(sorted_cuts) - l):
            dp[i][i + l] = (
                min(dp[i][j] + dp[j][i + l] for j in xrange(i + 1, i + l))
                + sorted_cuts[i + l]
                - sorted_cuts[i]
            )
    return dp[0][len(sorted_cuts) - 1]


import itertools
import heapq


class Solution(object):
    def mincostToHireWorkers(self, quality, wage, K):

    result, qsum = float("inf"), 0
    max_heap = []
    for r, q in sorted([float(w) / q, q] for w, q in itertools.izip(wage, quality)):
        qsum += q
        heapq.heappush(max_heap, -q)
        if len(max_heap) > K:
            qsum -= -heapq.heappop(max_heap)
        if len(max_heap) == K:
            result = min(result, qsum * r)
    return result


import collections


class Solution(object):
    def minCost(self, grid):

    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    def a_star(grid, b, t):
        R, C = len(grid), len(grid[0])
        f, dh = 0, 1
        closer, detour = [b], []
        lookup = set()
        while closer or detour:
            if not closer:
                f += dh
                closer, detour = detour, closer
            b = closer.pop()
            if b == t:
                return f
            if b in lookup:
                continue
            lookup.add(b)
            for nd, (dr, dc) in enumerate(directions, 1):
                nb = (b[0] + dr, b[1] + dc)
                if not (0 <= nb[0] < R and 0 <= nb[1] < C and nb not in lookup):
                    continue
                (closer if nd == grid[b[0]][b[1]] else detour).append(nb)
        return -1

    return a_star(grid, (0, 0), (len(grid) - 1, len(grid[0]) - 1))


class Solution2(object):
    def minCost(self, grid):

    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    R, C = len(grid), len(grid[0])
    b, t = (0, 0), (R - 1, C - 1)
    dq = collections.deque([(b, 0)])
    lookup = {b: 0}
    while dq:
        b, d = dq.popleft()
        if b == t:
            return d
        if lookup[b] < d:
            continue
        for nd, (dr, dc) in enumerate(directions, 1):
            nb = (b[0] + dr, b[1] + dc)
            cost = 1 if nd != grid[b[0]][b[1]] else 0
            if not (
                0 <= nb[0] < R
                and 0 <= nb[1] < C
                and (nb not in lookup or lookup[nb] > d + cost)
            ):
                continue
            lookup[nb] = d + cost
            if not cost:
                dq.appendleft((nb, d))
            else:
                dq.append((nb, d + cost))
    return -1


class Solution(object):
    def mergeStones(self, stones, K):

    if (len(stones) - 1) % (K - 1):
        return -1
    prefix = [0]
    for x in stones:
        prefix.append(prefix[-1] + x)
    dp = [[0] * len(stones) for _ in xrange(len(stones))]
    for l in xrange(K - 1, len(stones)):
        for i in xrange(len(stones) - l):
            dp[i][i + l] = min(
                dp[i][j] + dp[j + 1][i + l] for j in xrange(i, i + l, K - 1)
            )
            if l % (K - 1) == 0:
                dp[i][i + l] += prefix[i + l + 1] - prefix[i]
    return dp[0][len(stones) - 1]


class Solution(object):
    def mctFromLeafValues(self, arr):

    result = 0
    stk = [float("inf")]
    for x in arr:
        while stk[-1] <= x:
            result += stk.pop() * min(stk[-1], x)
        stk.append(x)
    while len(stk) > 2:
        result += stk.pop() * stk[-1]
    return result


class Solution(object):
    def minTrioDegree(self, n, edges):

    adj = [set() for _ in xrange(n + 1)]
    degree = [0] * (n + 1)
    for u, v in edges:
        adj[min(u, v)].add(max(u, v))
        degree[u] += 1
        degree[v] += 1
    result = float("inf")
    for u in xrange(1, n + 1):
        for v in adj[u]:
            for w in adj[u]:
                if v < w and w in adj[v]:
                    result = min(result, degree[u] + degree[v] + degree[w] - 6)
    return result if result != float("inf") else -1


class Solution(object):
    def minCost(self, s, cost):

    result = accu = max_cost = 0
    for i in xrange(len(s)):
        if i and s[i] != s[i - 1]:
            result += accu - max_cost
            accu = max_cost = 0
        accu += cost[i]
        max_cost = max(max_cost, cost[i])
    result += accu - max_cost
    return result


import collections
import string


class Solution(object):
    def minDeletions(self, s):

    count = collections.Counter(s)
    result = 0
    lookup = set()
    for c in string.ascii_lowercase:
        for i in reversed(xrange(1, count[c] + 1)):
            if i not in lookup:
                lookup.add(i)
                break
            result += 1
    return result


class Solution(object):
    def minimumDeletions(self, s):

    result = b_cnt = 0
    for c in s:
        if c == "b":
            b_cnt += 1
        elif b_cnt:
            b_cnt -= 1
            result += 1
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def minDepth(self, root):
    if root is None:
        return 0

    if root.left and root.right:
        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1
    else:
        return max(self.minDepth(root.left), self.minDepth(root.right)) + 1


import random


class Solution(object):
    def minDifference(self, nums):

    def nth_element(nums, left, n, right, compare=lambda a, b: a < b):
        def partition_around_pivot(left, right, pivot_idx, nums, compare):
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in xrange(left, right):
                if compare(nums[i], nums[right]):
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        while left <= right:
            pivot_idx = random.randint(left, right)
            new_pivot_idx = partition_around_pivot(
                left, right, pivot_idx, nums, compare
            )
            if new_pivot_idx == n:
                return
            elif new_pivot_idx > n:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    k = 4
    if len(nums) <= k:
        return 0
    nth_element(nums, 0, k, len(nums) - 1)
    nums[:k] = sorted(nums[:k])
    nth_element(nums, k, max(k, len(nums) - k), len(nums) - 1)
    nums[-k:] = sorted(nums[-k:])
    return min(nums[-k + i] - nums[i] for i in xrange(k))


class Solution(object):
    def minDifficulty(self, jobDifficulty, d):

    if len(jobDifficulty) < d:
        return -1

    dp = [[float("inf")] * len(jobDifficulty) for _ in xrange(d)]
    dp[0][0] = jobDifficulty[0]
    for i in xrange(1, len(jobDifficulty)):
        dp[0][i] = max(dp[0][i - 1], jobDifficulty[i])
    for i in xrange(1, d):
        for j in xrange(i, len(jobDifficulty)):
            curr_max = jobDifficulty[j]
            for k in reversed(xrange(i, j + 1)):
                curr_max = max(curr_max, jobDifficulty[k])
                dp[i][j] = min(dp[i][j], dp[i - 1][k - 1] + curr_max)
    return dp[d - 1][len(jobDifficulty) - 1]


class Solution(object):
    def minDiffInBST(self, root):

    def dfs(node):
        if not node:
            return
        dfs(node.left)
        self.result = min(self.result, node.val - self.prev)
        self.prev = node.val
        dfs(node.right)

    self.prev = float("-inf")
    self.result = float("inf")
    dfs(root)
    return self.result


class Solution(object):
    def minimumDistance(self, word):

    def distance(a, b):
        return abs(a // 6 - b // 6) + abs(a % 6 - b % 6)

    dp = [0] * 26
    for i in xrange(len(word) - 1):
        b, c = ord(word[i]) - ord("A"), ord(word[i + 1]) - ord("A")
        dp[b] = max(dp[a] - distance(a, c) + distance(b, c)
                    for a in xrange(26))
    return sum(
        distance(ord(word[i]) - ord("A"), ord(word[i + 1]) - ord("A"))
        for i in xrange(len(word) - 1)
    ) - max(dp)


class Solution2(object):
    def minimumDistance(self, word):

    def distance(a, b):
        if -1 in [a, b]:
            return 0
        return abs(a // 6 - b // 6) + abs(a % 6 - b % 6)

    dp = {(-1, -1): 0}
    for c in word:
        c = ord(c) - ord("A")
        new_dp = {}
        for a, b in dp:
            new_dp[c, b] = min(
                new_dp.get((c, b), float("inf")), dp[a, b] + distance(a, c)
            )
            new_dp[a, c] = min(
                new_dp.get((a, c), float("inf")), dp[a, b] + distance(b, c)
            )
        dp = new_dp
    return min(dp.itervalues())


import itertools


class Solution(object):
    def minDominoRotations(self, A, B):

    intersect = reduce(set.__and__, [set(d) for d in itertools.izip(A, B)])
    if not intersect:
        return -1
    x = intersect.pop()
    return min(len(A) - A.count(x), len(B) - B.count(x))


class Solution(object):
    def minElements(self, nums, limit, goal):

    return (abs(sum(nums) - goal) + (limit - 1)) // limit


class Solution(object):
    def smallestFactorization(self, a):

    if a < 2:
        return a
    result, mul = 0, 1
    for i in reversed(xrange(2, 10)):
        while a % i == 0:
            a /= i
            result = mul * i + result
            mul *= 10
    return result if a == 1 and result < 2 ** 31 else 0


import heapq


class Solution(object):
    def minFallingPathSum(self, arr):

    for i in xrange(1, len(arr)):
        smallest_two = heapq.nsmallest(2, arr[i - 1])
        for j in xrange(len(arr[0])):
            arr[i][j] += (
                smallest_two[1]
                if arr[i - 1][j] == smallest_two[0]
                else smallest_two[0]
            )
    return min(arr[-1])


class Solution(object):
    def minFallingPathSum(self, A):

    for i in xrange(1, len(A)):
        for j in xrange(len(A[i])):
            A[i][j] += min(A[i - 1][max(j - 1, 0): j + 2])
    return min(A[-1])


class Solution(object):
    def minFlips(self, a, b, c):

    def number_of_1_bits(n):
        result = 0
        while n:
            n &= n - 1
            result += 1
        return result

    return number_of_1_bits((a | b) ^ c) + number_of_1_bits(a & b & ~c)


class Solution2(object):
    def minFlips(self, a, b, c):

    result = 0
    for i in xrange(31):
        a_i, b_i, c_i = map(lambda x: x & 1, [a, b, c])
        if (a_i | b_i) != c_i:
            result += 2 if a_i == b_i == 1 else 1
        a, b, c = a >> 1, b >> 1, c >> 1
    return result


from collections import deque


class Solution(object):
    def minMutation(self, start, end, bank):

    lookup = {}
    for b in bank:
        lookup[b] = False

    q = deque([(start, 0)])
    while q:
        cur, level = q.popleft()
        if cur == end:
            return level

        for i in xrange(len(cur)):
            for c in ["A", "T", "C", "G"]:
                if cur[i] == c:
                    continue

                next_str = cur[:i] + c + cur[i + 1:]
                if next_str in lookup and lookup[next_str] == False:
                    q.append((next_str, level + 1))
                    lookup[next_str] = True

    return -1


import collections


class Solution(object):
    def findMinHeightTrees(self, n, edges):

    if n == 1:
        return [0]

    neighbors = collections.defaultdict(set)
    for u, v in edges:
        neighbors[u].add(v)
        neighbors[v].add(u)

    pre_level, unvisited = [], set()
    for i in xrange(n):
        if len(neighbors[i]) == 1:
            pre_level.append(i)
        unvisited.add(i)

    while len(unvisited) > 2:
        cur_level = []
        for u in pre_level:
            unvisited.remove(u)
            for v in neighbors[u]:
                if v in unvisited:
                    neighbors[v].remove(u)
                    if len(neighbors[v]) == 1:
                        cur_level.append(v)
        pre_level = cur_level

    return list(unvisited)


import itertools


class Solution(object):
    def minimumIncompatibility(self, nums, k):

    inf = (len(nums) - 1) * (len(nums) // k) + 1

    def backtracking(nums, d, lookup):
        if not nums:
            return 0
        if nums not in lookup:
            ret = inf
            for new_nums in itertools.combinations(nums, d):
                new_nums_set = set(new_nums)
                if len(new_nums_set) < d:
                    continue
                left = []
                for num in nums:
                    if num in new_nums_set:
                        new_nums_set.remove(num)
                        continue
                    left.append(num)
                ret = min(
                    ret,
                    max(new_nums)
                    - min(new_nums)
                    + backtracking(tuple(left), d, lookup),
                )
            lookup[nums] = ret
        return lookup[nums]

    result = backtracking(tuple(nums), len(nums) // k, {})
    return result if result != inf else -1


class Solution_TLE(object):
    def minimumIncompatibility(self, nums, k):

    inf = (len(nums) - 1) * (len(nums) // k) + 1
    POW = [1]
    for i in xrange(len(nums)):
        POW.append(POW[-1] << 1)

    def popcount(n):
        result = 0
        while n:
            n &= n - 1
            result += 1
        return result

    def find_candidates(nums, k):
        total = POW[len(nums)] - 1
        m = len(nums) // k
        result = [inf] * (total + 1)
        for mask in xrange(total + 1):
            if popcount(mask) != m:
                continue
            lookup = 0
            mx, mn = 0, inf
            for i in xrange(len(nums)):
                if mask & POW[i] == 0:
                    continue
                if lookup & POW[nums[i]]:
                    break
                lookup |= POW[nums[i]]
                mx = max(mx, nums[i])
                mn = min(mn, nums[i])
            else:
                result[mask] = mx - mn
        return result

    candidates = find_candidates(nums, k)
    m = len(nums) // k
    total = POW[len(nums)] - 1
    dp = [inf] * (total + 1)
    dp[0] = 0
    for mask in xrange(total + 1):
        if popcount(mask) % m != 0:
            continue

        submask = mask
        while submask:
            dp[mask] = min(dp[mask], dp[mask - submask] + candidates[submask])
            submask = (submask - 1) & mask
    return dp[-1] if dp[-1] != inf else -1


import collections
import sortedcontainers


class Solution_Wrong_Greedy_SortedList(object):
    def minimumIncompatibility(self, nums, k):

    def greedy(nums, k, is_reversed):
        count = collections.Counter(nums)
        if max(count.itervalues()) > k:
            return -1
        ordered_set = sortedcontainers.SortedList(count.iterkeys())
        freq_to_nodes = collections.defaultdict(collections.OrderedDict)
        for x in ordered_set:
            freq_to_nodes[count[x]][x] = count[x]
        stks = [[] for _ in xrange(k)]
        curr = 0
        while ordered_set:
            if (
                len(stks) - curr in freq_to_nodes
            ):
                for x in freq_to_nodes[
                    len(stks) - curr
                ].iterkeys():
                    for i in xrange(curr, len(stks)):
                        stks[i].append(x)
                    count.pop(x)
                    ordered_set.remove(x)
                freq_to_nodes.pop(len(stks) - curr)

            to_remove = []
            direction = (lambda x: x) if not is_reversed else reversed
            for x in direction(ordered_set):
                stks[curr].append(x)
                freq_to_nodes[count[x]].pop(x)
                if not freq_to_nodes[count[x]]:
                    freq_to_nodes.pop(count[x])
                count[x] -= 1
                if not count[x]:
                    count.pop(x)
                    to_remove.append(x)
                else:
                    freq_to_nodes[count[x]][x] = count[x]
                if len(stks[curr]) == len(nums) // k:
                    curr += 1
                    break
            for x in to_remove:
                ordered_set.remove(x)
        return sum([max(stk) - min(stk) for stk in stks])

    return min(
        greedy(nums, k, False), greedy(nums, k, True)
    )


import collections
from random import randint, seed


class SkipNode(object):
    def __init__(self, level=0, val=None):
    self.val = val
    self.nexts = [None] * level
    self.prevs = [None] * level


class SkipList(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2
    MAX_LEVEL = 32

    def __init__(self, end=float("inf"), can_duplicated=False, cmp=lambda x, y: x < y):
    seed(0)
    self.__head = SkipNode()
    self.__len = 0
    self.__can_duplicated = can_duplicated
    self.__cmp = cmp
    self.add(end)
    self.__end = self.find(end)

    def begin(self):
    return self.__head.nexts[0]

    def end(self):
    return self.__end

    def lower_bound(self, target):
    return self.__lower_bound(target, self.__find_prev_nodes(target))

    def find(self, target):
    return self.__find(target, self.__find_prev_nodes(target))

    def add(self, val):
    if not self.__can_duplicated and self.find(val):
        return self.find(val), False
    node = SkipNode(self.__random_level(), val)
    if len(self.__head.nexts) < len(node.nexts):
        self.__head.nexts.extend(
            [None] * (len(node.nexts) - len(self.__head.nexts))
        )
    prevs = self.__find_prev_nodes(val)
    for i in xrange(len(node.nexts)):
        node.nexts[i] = prevs[i].nexts[i]
        if prevs[i].nexts[i]:
            prevs[i].nexts[i].prevs[i] = node
        prevs[i].nexts[i] = node
        node.prevs[i] = prevs[i]
    self.__len += 1
    return node if self.__can_duplicated else (node, True)

    def remove(self, it):
    prevs = it.prevs
    curr = self.__find(it.val, prevs)
    if not curr:
        return self.__end
    self.__len -= 1
    for i in reversed(xrange(len(curr.nexts))):
        prevs[i].nexts[i] = curr.nexts[i]
        if curr.nexts[i]:
            curr.nexts[i].prevs[i] = prevs[i]
        if not self.__head.nexts[i]:
            self.__head.nexts.pop()
    return curr.nexts[0]

    def __lower_bound(self, val, prevs):
    if prevs:
        candidate = prevs[0].nexts[0]
        if candidate:
            return candidate
    return None

    def __find(self, val, prevs):
    candidate = self.__lower_bound(val, prevs)
    if candidate and candidate.val == val:
        return candidate
    return None

    def __find_prev_nodes(self, val):
    prevs = [None] * len(self.__head.nexts)
    curr = self.__head
    for i in reversed(xrange(len(self.__head.nexts))):
        while curr.nexts[i] and self.__cmp(curr.nexts[i].val, val):
            curr = curr.nexts[i]
        prevs[i] = curr
    return prevs

    def __random_level(self):
    level = 1
    while (
        randint(1, SkipList.P_DENOMINATOR) <= SkipList.P_NUMERATOR
        and level < SkipList.MAX_LEVEL
    ):
        level += 1
    return level

    def __iter__(self):
    it = self.begin()
    while it != self.end():
        yield it.val
        it = it.nexts[0]

    def __len__(self):
    return self.__len - 1

    def __str__(self):
    result = []
    for i in reversed(xrange(len(self.__head.nexts))):
        result.append([])
        curr = self.__head.nexts[i]
        while curr:
            result[-1].append(str(curr.val))
            curr = curr.nexts[i]
    return "\n".join(map(lambda x: "->".join(x), result))


class Solution_Wrong_Greedy_SkipList(object):
    def minimumIncompatibility(self, nums, k):

    def greedy(nums, k, is_reversed):
        count = collections.Counter(nums)
        if max(count.itervalues()) > k:
            return -1
        ordered_set = (
            SkipList()
            if not is_reversed
            else SkipList(end=float("-inf"), cmp=lambda x, y: x > y)
        )
        freq_to_nodes = collections.defaultdict(collections.OrderedDict)
        for x in sorted(count.keys(), reverse=is_reversed):
            ordered_set.add(x)
            freq_to_nodes[count[x]][x] = count[x]
        stks = [[] for _ in xrange(k)]
        curr = 0
        while ordered_set:
            if (
                len(stks) - curr in freq_to_nodes
            ):
                for x in freq_to_nodes[
                    len(stks) - curr
                ].iterkeys():
                    for i in xrange(curr, len(stks)):
                        stks[i].append(x)
                    count.pop(x)
                    ordered_set.remove(ordered_set.find(x))
                freq_to_nodes.pop(len(stks) - curr)

            it = ordered_set.begin()
            while it != ordered_set.end():
                x = it.val
                stks[curr].append(x)
                freq_to_nodes[count[x]].pop(x)
                if not freq_to_nodes[count[x]]:
                    freq_to_nodes.pop(count[x])
                count[x] -= 1
                if not count[x]:
                    count.pop(x)
                    it = ordered_set.remove(it)
                else:
                    freq_to_nodes[count[x]][x] = count[x]
                    it = it.nexts[0]
                if len(stks[curr]) == len(nums) // k:
                    curr += 1
                    break
        return sum([max(stk) - min(stk) for stk in stks])

    return min(
        greedy(nums, k, False), greedy(nums, k, True)
    )


import collections


class Solution_Wrong_Greedy(object):
    def minimumIncompatibility(self, nums, k):

    def greedy(nums, k, is_reversed):
        count = collections.Counter(nums)
        if max(count.itervalues()) > k:
            return -1
        sorted_keys = sorted(count.keys(), reverse=is_reversed)
        stks = [[] for _ in xrange(k)]
        curr, remain = 0, len(nums)
        while (
            remain
        ):
            for (
                x
            ) in (
                sorted_keys
            ):
                if count[x] != len(stks) - curr:
                    continue
                for i in xrange(curr, len(stks)):
                    stks[i].append(x)
                remain -= count[x]
                count[x] = 0

            for x in sorted_keys:
                if not count[x]:
                    continue
                stks[curr].append(x)
                remain -= 1
                count[x] -= 1
                if len(stks[curr]) == len(nums) // k:
                    curr += 1
                    break
        return sum([max(stk) - min(stk) for stk in stks])

    return min(
        greedy(nums, k, False), greedy(nums, k, True)
    )


class Solution(object):
    def minIncrementForUnique(self, A):

    A.sort()
    A.append(float("inf"))
    result, duplicate = 0, 0
    for i in xrange(1, len(A)):
        if A[i - 1] == A[i]:
            duplicate += 1
            result -= A[i]
        else:
            move = min(duplicate, A[i] - A[i - 1] - 1)
            duplicate -= move
            result += move * A[i - 1] + move * (move + 1) // 2
    return result


class Solution(object):
    def findRestaurant(self, list1, list2):

    lookup = {}
    for i, s in enumerate(list1):
        lookup[s] = i

    result = []
    min_sum = float("inf")
    for j, s in enumerate(list2):
        if j > min_sum:
            break
        if s in lookup:
            if j + lookup[s] < min_sum:
                result = [s]
                min_sum = j + lookup[s]
            elif j + lookup[s] == min_sum:
                result.append(s)
    return result


class Solution(object):
    def minimumEffort(self, tasks):

    tasks.sort(key=lambda x: x[1] - x[0])
    result = 0

    for (
        a,
        m,
    ) in (
        tasks
    ):
        result = max(result + a, m)
    return result


class Solution2(object):
    def minimumEffort(self, tasks):

    tasks.sort(key=lambda x: x[0] - x[1])
    result = curr = 0
    for (
        a,
        m,
    ) in (
        tasks
    ):
        result += max(m - curr, 0)
        curr = max(curr, m) - a
    return result


class Solution(object):
    def minInsertions(self, s):

    def longestCommonSubsequence(text1, text2):
        if len(text1) < len(text2):
            return self.longestCommonSubsequence(text2, text1)
        dp = [[0 for _ in xrange(len(text2) + 1)] for _ in xrange(2)]
        for i in xrange(1, len(text1) + 1):
            for j in xrange(1, len(text2) + 1):
                dp[i % 2][j] = (
                    dp[(i - 1) % 2][j - 1] + 1
                    if text1[i - 1] == text2[j - 1]
                    else max(dp[(i - 1) % 2][j], dp[i % 2][j - 1])
                )
        return dp[len(text1) % 2][len(text2)]

    return len(s) - longestCommonSubsequence(s, s[::-1])


class Solution(object):
    def minInsertions(self, s):

    add, bal = 0, 0
    for c in s:
        if c == "(":
            if bal > 0 and bal % 2:
                add += 1
                bal -= 1
            bal += 2
        else:
            bal -= 1
            if bal < 0:
                add += 1
                bal += 2
    return add + bal


class Solution(object):
    def minimumJumps(self, forbidden, a, b, x):

    max_f = max(forbidden)
    max_val = (
        x + b if a >= b else max(x, max_f) + a + (b + a)
    )
    lookup = set()
    for pos in forbidden:
        lookup.add((pos, True))
        lookup.add((pos, False))
    result = 0
    q = [(0, True)]
    lookup.add((0, True))
    while q:
        new_q = []
        for pos, can_back in q:
            if pos == x:
                return result
            if pos + a <= max_val and (pos + a, True) not in lookup:
                lookup.add((pos + a, True))
                new_q.append((pos + a, True))
            if not can_back:
                continue
            if pos - b >= 0 and (pos - b, False) not in lookup:
                lookup.add((pos - b, False))
                new_q.append((pos - b, False))
        q = new_q
        result += 1
    return -1


class Solution(object):
    def minKnightMoves(self, x, y):

    x, y = abs(x), abs(y)
    if x < y:
        x, y = y, x
    lookup = {(0, 0): 0, (1, 0): 3, (2, 2): 4}
    if (x, y) in lookup:
        return lookup[(x, y)]
    k = x - y
    if y > k:

        return k - 2 * ((k - y) // 3)

    return k - 2 * ((k - y) // 4)


class Solution2(object):
    def __init__(self):
    self.__lookup = {(0, 0): 0, (1, 1): 2, (1, 0): 3}

    def minKnightMoves(self, x, y):

    def dp(x, y):
        x, y = abs(x), abs(y)
        if x < y:
            x, y = y, x
        if (
            x,
            y,
        ) not in self.__lookup:
            self.__lookup[(x, y)] = min(dp(x - 1, y - 2), dp(x - 2, y - 1)) + 1
        return self.__lookup[(x, y)]

    return dp(x, y)


class Solution(object):
    def minimumLength(self, s):

    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            break
        c = s[left]
        while left <= right:
            if s[left] != c:
                break
            left += 1
        while left <= right:
            if s[right] != c:
                break
            right -= 1
    return right - left + 1


class Solution(object):
    def minimumSize(self, nums, maxOperations):

    def check(nums, maxOperations, x):
        return sum((num + x - 1) // x - 1 for num in nums) <= maxOperations

    left, right = 1, max(nums)
    while left <= right:
        mid = left + (right - left) // 2
        if check(nums, maxOperations, mid):
            right = mid - 1
        else:
            left = mid + 1
    return left


from random import randint


class Solution(object):
    def minMoves2(self, nums):

    def kthElement(nums, k):
        def PartitionAroundPivot(left, right, pivot_idx, nums):
            pivot_value = nums[pivot_idx]
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in xrange(left, right):
                if nums[i] > pivot_value:
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = randint(left, right)
            new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)
            if new_pivot_idx == k:
                return nums[new_pivot_idx]
            elif new_pivot_idx > k:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    median = kthElement(nums, len(nums) // 2)
    return sum(abs(num - median) for num in nums)

    def minMoves22(self, nums):

    median = sorted(nums)[len(nums) / 2]
    return sum(abs(num - median) for num in nums)


class Solution(object):
    def minMoves(self, nums):

    return sum(nums) - len(nums) * min(nums)


class Solution(object):
    def minMoves(self, nums, limit):

    diff = [0] * (2 * (limit + 1))
    for i in xrange(len(nums) // 2):
        left, right = nums[i], nums[-1 - i]
        diff[
            min(left, right) + 1
        ] -= 1
        diff[
            left + right
        ] -= 1
        diff[
            left + right + 1
        ] += 1
        diff[
            max(left, right) + limit + 1
        ] += 1
    result = count = len(nums)
    for total in xrange(2, 2 * limit + 1):
        count += diff[total]
        result = min(result, count)
    return result


class Solution(object):
    def minPushBox(self, grid):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def dot(a, b):
        return a[0] * b[0] + a[1] * b[1]

    def can_reach(grid, b, p, t):
        closer, detour = [p], []
        lookup = set([b])
        while closer or detour:
            if not closer:
                closer, detour = detour, closer
            p = closer.pop()
            if p == t:
                return True
            if p in lookup:
                continue
            lookup.add(p)
            for dx, dy in directions:
                np = (p[0] + dx, p[1] + dy)
                if not (
                    0 <= np[0] < len(grid)
                    and 0 <= np[1] < len(grid[0])
                    and grid[np[0]][np[1]] != "#"
                    and np not in lookup
                ):
                    continue
                (
                    closer
                    if dot((dx, dy), (t[0] - p[0], t[1] - p[1])) > 0
                    else detour
                ).append(np)
        return False

    def g(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def a_star(grid, b, p, t):
        f, dh = g(b, t), 2
        closer, detour = [(b, p)], []
        lookup = set()
        while closer or detour:
            if not closer:
                f += dh
                closer, detour = detour, closer
            b, p = closer.pop()
            if b == t:
                return f
            if (b, p) in lookup:
                continue
            lookup.add((b, p))
            for dx, dy in directions:
                nb, np = (b[0] + dx, b[1] + dy), (b[0] - dx, b[1] - dy)
                if not (
                    0 <= nb[0] < len(grid)
                    and 0 <= nb[1] < len(grid[0])
                    and 0 <= np[0] < len(grid)
                    and 0 <= np[1] < len(grid[0])
                    and grid[nb[0]][nb[1]] != "#"
                    and grid[np[0]][np[1]] != "#"
                    and (nb, b) not in lookup
                    and can_reach(grid, b, p, np)
                ):
                    continue
                (
                    closer
                    if dot((dx, dy), (t[0] - b[0], t[1] - b[1])) > 0
                    else detour
                ).append((nb, b))
        return -1

    b, p, t = None, None, None
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            if grid[i][j] == "B":
                b = (i, j)
            elif grid[i][j] == "S":
                p = (i, j)
            elif grid[i][j] == "T":
                t = (i, j)
    return a_star(grid, b, p, t)


class Solution(object):
    def minimumMoves(self, grid):

    level, q, lookup = 0, [(0, 0, False)], set()
    while q:
        next_q = []
        for r, c, is_vertical in q:
            if (r, c, is_vertical) in lookup:
                continue
            if (r, c, is_vertical) == (len(grid) - 1, len(grid) - 2, False):
                return level
            lookup.add((r, c, is_vertical))
            if not is_vertical:
                if c + 2 != len(grid[0]) and grid[r][c + 2] == 0:
                    next_q.append((r, c + 1, is_vertical))
                if (
                    r + 1 != len(grid)
                    and grid[r + 1][c] == 0
                    and grid[r + 1][c + 1] == 0
                ):
                    next_q.append((r + 1, c, is_vertical))
                    next_q.append((r, c, not is_vertical))
            else:
                if r + 2 != len(grid) and grid[r + 2][c] == 0:
                    next_q.append((r + 1, c, is_vertical))
                if (
                    c + 1 != len(grid)
                    and grid[r][c + 1] == 0
                    and grid[r + 1][c + 1] == 0
                ):
                    next_q.append((r, c + 1, is_vertical))
                    next_q.append((r, c, not is_vertical))
        q = next_q
        level += 1
    return -1


class Solution(object):
    def findMinArrowShots(self, points):

    if not points:
        return 0

    points.sort()

    result = 0
    i = 0
    while i < len(points):
        j = i + 1
        right_bound = points[i][1]
        while j < len(points) and points[j][0] <= right_bound:
            right_bound = min(right_bound, points[j][1])
            j += 1
        result += 1
        i = j
    return result


class Solution(object):
    def minDays(self, grid):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def floodfill(grid, i, j, lookup):
        stk = [(i, j)]
        lookup[i][j] = 1
        while stk:
            i, j = stk.pop()
            for di, dj in directions:
                ni, nj = i + di, j + dj
                if not (
                    0 <= ni < len(grid)
                    and 0 <= nj < len(grid[0])
                    and grid[ni][nj]
                    and not lookup[ni][nj]
                ):
                    continue
                lookup[ni][nj] = 1
                stk.append((ni, nj))

    def count_islands(grid):
        lookup = [[0] * len(grid[0]) for _ in xrange(len(grid))]
        island_cnt = 0
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if grid[i][j] == 0 or lookup[i][j]:
                    continue
                island_cnt += 1
                floodfill(grid, i, j, lookup)
        return island_cnt

    if count_islands(grid) != 1:
        return 0
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            if grid[i][j] == 0:
                continue
            grid[i][j] = 0
            island_cnt = count_islands(grid)
            grid[i][j] = 1
            if island_cnt != 1:
                return 1
    return 2


class Solution(object):
    def minDays(self, n):

    def memoization(lookup, i):
        if i <= 1:
            return i
        if i not in lookup:
            lookup[i] = 1 + min(
                i % 2 + memoization(lookup, i // 2),
                i % 3 + memoization(lookup, i // 3),
            )
        return lookup[i]

    lookup = {}
    return memoization(lookup, n)


class Solution2(object):
    def minDays(self, n):
    result = 0
    q, lookup = [n], set([n])
    while q:
        new_q = []
        for i in q:
            if not i:
                return result
            if i - 1 not in lookup:
                lookup.add(i - 1)
                new_q.append(i - 1)
            if i % 2 == 0 and i // 2 not in lookup:
                lookup.add(i // 2)
                new_q.append(i // 2)
            if i % 3 == 0 and i // 3 not in lookup:
                lookup.add(i // 3)
                new_q.append(i // 3)
        result += 1
        q = new_q
    return result


class Solution(object):
    def minDays(self, bloomDay, m, k):

    def check(bloomDay, m, k, x):
        result = count = 0
        for d in bloomDay:
            count = count + 1 if d <= x else 0
            if count == k:
                count = 0
                result += 1
                if result == m:
                    break
        return result >= m

    if m * k > len(bloomDay):
        return -1
    left, right = 1, max(bloomDay)
    while left <= right:
        mid = left + (right - left) // 2
        if check(bloomDay, m, k, mid):
            right = mid - 1
        else:
            left = mid + 1
    return left


import collections


class Solution(object):
    def minFlips(self, mat):

    directions = [(0, 0), (0, 1), (1, 0), (0, -1), (-1, 0)]
    start = sum(
        val << r * len(mat[0]) + c
        for r, row in enumerate(mat)
        for c, val in enumerate(row)
    )
    q = collections.deque([(start, 0)])
    lookup = {start}
    while q:
        state, step = q.popleft()
        if not state:
            return step
        for r in xrange(len(mat)):
            for c in xrange(len(mat[0])):
                new_state = state
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(mat) and 0 <= nc < len(mat[0]):
                        new_state ^= 1 << nr * len(mat[0]) + nc
                if new_state in lookup:
                    continue
                lookup.add(new_state)
                q.append((new_state, step + 1))
    return -1


class Solution(object):
    def minNumberOfFrogs(self, croakOfFrogs):

    S = "croak"
    lookup = [0] * len(S)
    result = 0
    for c in croakOfFrogs:
        i = S.find(c)
        lookup[i] += 1
        if lookup[i - 1]:
            lookup[i - 1] -= 1
        elif i == 0:
            result += 1
        else:
            return -1
    return result if result == lookup[-1] else -1


class Solution(object):
    def minNumberOperations(self, target):

    return target[0] + sum(
        max(target[i] - target[i - 1], 0) for i in xrange(1, len(target))
    )


import itertools


class Solution2(object):
    def minNumberOperations(self, target):

    return sum(max(b - a, 0) for b, a in itertools.izip(target, [0] + target))


class Solution(object):
    def minKBitFlips(self, A, K):

    result, curr = 0, 0
    for i in xrange(len(A)):
        if i >= K:
            curr -= A[i - K] // 2
        if curr & 1 ^ A[i] == 0:
            if i + K > len(A):
                return -1
            A[i] += 2
            curr, result = curr + 1, result + 1
    return result


class Solution(object):
    def minOperations(self, boxes):

    result = [0] * len(boxes)
    for direction in (lambda x: x, reversed):
        cnt = accu = 0
        for i in direction(xrange(len(boxes))):
            result[i] += accu
            if boxes[i] == "1":
                cnt += 1
            accu += cnt
    return result


import collections


class Solution(object):
    def minimumTeachings(self, n, languages, friendships):

    language_sets = map(set, languages)
    candidates = set(
        i - 1
        for u, v in friendships
        if not language_sets[u - 1] & language_sets[v - 1]
        for i in [u, v]
    )
    count = collections.Counter()
    for i in candidates:
        count += collections.Counter(languages[i])
    return len(candidates) - max(count.values() + [0])


import heapq


class Solution(object):
    def minRefuelStops(self, target, startFuel, stations):

    max_heap = []
    stations.append((target, float("inf")))

    result = prev = 0
    for location, capacity in stations:
        startFuel -= location - prev
        while max_heap and startFuel < 0:
            startFuel += -heapq.heappop(max_heap)
            result += 1
        if startFuel < 0:
            return -1
        heapq.heappush(max_heap, -capacity)
        prev = location

    return result


import bisect


class Solution(object):
    def minimumMountainRemovals(self, nums):

    left_lis_len = [0] * len(nums)
    lis = []
    for i in xrange(len(nums) - 1):
        j = bisect.bisect_left(lis, nums[i])
        if j == len(lis):
            lis.append(nums[i])
        else:
            lis[j] = nums[i]
        left_lis_len[i] = j
    max_len = 0
    lis = []
    for i in reversed(xrange(1, len(nums))):
        j = bisect.bisect_left(lis, nums[i])
        if j == len(lis):
            lis.append(nums[i])
        else:
            lis[j] = nums[i]
        if i < len(nums) - 1:
            max_len = max(max_len, left_lis_len[i] + j)
    return len(nums) - (1 + max_len)


import collections


class Solution(object):
    def minSteps(self, s, t):

    diff = collections.Counter(s) - collections.Counter(t)
    return sum(diff.itervalues())


class Solution(object):
    def minTaps(self, n, ranges):

    def jump_game(A):
        jump_count, reachable, curr_reachable = 0, 0, 0
        for i, length in enumerate(A):
            if i > reachable:
                return -1
            if i > curr_reachable:
                curr_reachable = reachable
                jump_count += 1
            reachable = max(reachable, i + length)
        return jump_count

    max_range = [0] * (n + 1)
    for i, r in enumerate(ranges):
        left, right = max(i - r, 0), min(i + r, n)
        max_range[left] = max(max_range[left], right - left)
    return jump_game(max_range)


class Solution(object):
    def findSmallestSetOfVertices(self, n, edges):

    result = []
    lookup = set()
    for u, v in edges:
        lookup.add(v)
    for i in xrange(n):
        if i not in lookup:
            result.append(i)
    return result


class Solution(object):
    def minOperations(self, nums):

    def popcount(n):
        result = 0
        while n:
            n &= n - 1
            result += 1
        return result

    result, max_len = 0, 0
    for num in nums:
        result += popcount(num)
        max_len = max(max_len, num.bit_length())
    return result + max_len - 1


class Solution(object):
    def minimumOneBitOperations(self, n):

    def gray_to_binary(n):
        result = 0
        while n:
            result ^= n
            n >>= 1
        return result

    return gray_to_binary(n)


class Solution2(object):
    def minimumOneBitOperations(self, n):

    result = 0
    while n:
        result = -result - (n ^ (n - 1))
        n &= n - 1
    return abs(result)


import bisect


class Solution(object):
    def minOperations(self, target, arr):

    lookup = {x: i for i, x in enumerate(target)}
    lis = []
    for x in arr:
        if x not in lookup:
            continue
        i = bisect.bisect_left(lis, lookup[x])
        if i == len(lis):
            lis.append(lookup[x])
        else:
            lis[i] = lookup[x]
    return len(target) - len(lis)


class SegmentTree(object):
    def __init__(
        self,
        N,
        build_fn=lambda x, y: [y] * (2 * x),
        query_fn=lambda x, y: y
        if x is None
        else max(x, y),
        update_fn=lambda x, y: y,
        default_val=0,
    ):
    self.N = N
    self.H = (N - 1).bit_length()
    self.query_fn = query_fn
    self.update_fn = update_fn
    self.default_val = default_val
    self.tree = build_fn(N, default_val)
    self.lazy = [None] * N

    def __apply(self, x, val):
    self.tree[x] = self.update_fn(self.tree[x], val)
    if x < self.N:
        self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h):

    def pull(x):
        while x > 1:
            x //= 2
            self.tree[x] = self.query_fn(
                self.tree[x * 2], self.tree[x * 2 + 1])
            if self.lazy[x] is not None:
                self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

    L += self.N
    R += self.N
    L0, R0 = L, R
    while L <= R:
        if L & 1:
            self.__apply(L, h)
            L += 1
        if R & 1 == 0:
            self.__apply(R, h)
            R -= 1
        L //= 2
        R //= 2
    pull(L0)
    pull(R0)

    def query(self, L, R):

    def push(x):
        n = 2 ** self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y * 2, self.lazy[y])
                self.__apply(y * 2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    result = None
    if L > R:
        return result

    L += self.N
    R += self.N
    push(L)
    push(R)
    while L <= R:
        if L & 1:
            result = self.query_fn(result, self.tree[L])
            L += 1
        if R & 1 == 0:
            result = self.query_fn(result, self.tree[R])
            R -= 1
        L //= 2
        R //= 2
    return result

    def __str__(self):
    showList = []
    for i in xrange(self.N):
        showList.append(self.query(i, i))
    return ",".join(map(str, showList))


class Solution2(object):
    def minOperations(self, target, arr):

    lookup = {x: i for i, x in enumerate(target)}
    st = SegmentTree(len(lookup))
    for x in arr:
        if x not in lookup:
            continue
        st.update(
            lookup[x],
            lookup[x],
            st.query(0, lookup[x] - 1) + 1 if lookup[x] >= 1 else 1,
        )
    return len(target) - (st.query(0, len(lookup) - 1) if len(lookup) >= 1 else 0)


class Solution(object):
    def minOperations(self, n):

    return (n // 2) * ((n + 1) // 2)


class Solution(object):
    def minOperations(self, nums, x):

    target = sum(nums) - x
    result = -1
    curr = left = 0
    for right in xrange(len(nums)):
        curr += nums[right]
        while left < len(nums) and curr > target:
            curr -= nums[left]
            left += 1
        if curr == target:
            result = max(result, right - left + 1)
    return len(nums) - result if result != -1 else -1


class Solution(object):

    def minPathSum(self, grid):
    sum = list(grid[0])
    for j in xrange(1, len(grid[0])):
        sum[j] = sum[j - 1] + grid[0][j]

    for i in xrange(1, len(grid)):
        sum[0] += grid[i][0]
        for j in xrange(1, len(grid[0])):
            sum[j] = min(sum[j - 1], sum[j]) + grid[i][j]

    return sum[-1]


import collections


class BIT(object):
    def __init__(self, n):
    self.__bit = [0] * n

    def add(self, i, val):
    while i < len(self.__bit):
        self.__bit[i] += val
        i += i & -i

    def sum(self, i):
    result = 0
    while i > 0:
        result += self.__bit[i]
        i -= i & -i
    return result


class Solution(object):
    def minInteger(self, num, k):

    lookup = collections.defaultdict(list)
    bit = BIT(len(num) + 1)
    for i in reversed(xrange(len(num))):
        bit.add(i + 1, 1)
        lookup[int(num[i])].append(i + 1)
    result = []
    for _ in xrange(len(num)):
        for d in xrange(10):
            if lookup[d] and bit.sum(lookup[d][-1] - 1) <= k:
                k -= bit.sum(lookup[d][-1] - 1)
                bit.add(lookup[d].pop(), -1)
                result.append(d)
                break
    return "".join(map(str, result))


class Solution(object):
    def minRemoveToMakeValid(self, s):

    result = list(s)
    count = 0
    for i, v in enumerate(result):
        if v == "(":
            count += 1
        elif v == ")":
            if count:
                count -= 1
            else:
                result[i] = ""
    if count:
        for i in reversed(xrange(len(result))):
            if result[i] == "(":
                result[i] = ""
                count -= 1
                if not count:
                    break
    return "".join(result)


class Solution(object):
    def minScoreTriangulation(self, A):

    dp = [[0 for _ in xrange(len(A))] for _ in xrange(len(A))]
    for p in xrange(3, len(A) + 1):
        for i in xrange(len(A) - p + 1):
            j = i + p - 1
            dp[i][j] = float("inf")
            for k in xrange(i + 1, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k]
                               [j] + A[i] * A[j] * A[k])
    return dp[0][-1]


class Solution(object):

    def minSubArrayLen(self, s, nums):
    start = 0
    sum = 0
    min_size = float("inf")
    for i in xrange(len(nums)):
        sum += nums[i]
        while sum >= s:
            min_size = min(min_size, i - start + 1)
            sum -= nums[start]
            start += 1

    return min_size if min_size != float("inf") else 0


class Solution2(object):

    def minSubArrayLen(self, s, nums):
    min_size = float("inf")
    sum_from_start = [n for n in nums]
    for i in xrange(len(sum_from_start) - 1):
        sum_from_start[i + 1] += sum_from_start[i]
    for i in xrange(len(sum_from_start)):
        end = self.binarySearch(
            lambda x, y: x <= y,
            sum_from_start,
            i,
            len(sum_from_start),
            sum_from_start[i] - nums[i] + s,
        )
        if end < len(sum_from_start):
            min_size = min(min_size, end - i + 1)

    return min_size if min_size != float("inf") else 0

    def binarySearch(self, compare, A, start, end, target):
    while start < end:
        mid = start + (end - start) / 2
        if compare(target, A[mid]):
            end = mid
        else:
            start = mid + 1
    return start


class Solution(object):
    def minSubsequence(self, nums):

    result, total, curr = [], sum(nums), 0
    nums.sort(reverse=True)
    for i, x in enumerate(nums):
        curr += x
        if curr > total - curr:
            break
    return nums[: i + 1]


import itertools


class Solution(object):
    def minSwaps(self, grid):

    result = 0
    for target in reversed(xrange(1, len(grid))):
        row_idx = len(grid) - 1 - target
        while row_idx < len(grid):
            row = grid[row_idx]
            if not sum(itertools.islice(row, len(row) - target, len(row))):
                break
            row_idx += 1
        else:
            return -1
        while row_idx != len(grid) - 1 - target:
            grid[row_idx], grid[row_idx - 1] = grid[row_idx - 1], grid[row_idx]
            result += 1
            row_idx -= 1
    return result


class Solution(object):
    def minSwaps(self, data):

    total_count = sum(data)
    result, count, left = 0, 0, 0
    for i in xrange(len(data)):
        count += data[i]
        if i - left + 1 > total_count:
            count -= data[left]
            left += 1
        result = max(result, count)
    return total_count - result


class Solution(object):
    def minSwap(self, A, B):

    dp_no_swap, dp_swap = [0] * 2, [1] * 2
    for i in xrange(1, len(A)):
        dp_no_swap[i % 2], dp_swap[i % 2] = float("inf"), float("inf")
        if A[i - 1] < A[i] and B[i - 1] < B[i]:
            dp_no_swap[i % 2] = min(dp_no_swap[i % 2], dp_no_swap[(i - 1) % 2])
            dp_swap[i % 2] = min(dp_swap[i % 2], dp_swap[(i - 1) % 2] + 1)
        if A[i - 1] < B[i] and B[i - 1] < A[i]:
            dp_no_swap[i % 2] = min(dp_no_swap[i % 2], dp_swap[(i - 1) % 2])
            dp_swap[i % 2] = min(dp_swap[i % 2], dp_no_swap[(i - 1) % 2] + 1)
    return min(dp_no_swap[(len(A) - 1) % 2], dp_swap[(len(A) - 1) % 2])


class Solution(object):
    def minimumSwap(self, s1, s2):

    x1, y1 = 0, 0
    for i in xrange(len(s1)):
        if s1[i] == s2[i]:
            continue
        x1 += int(s1[i] == "x")
        y1 += int(s1[i] == "y")
    if x1 % 2 != y1 % 2:
        return -1

    return (x1 // 2 + y1 // 2) + (x1 % 2 + y1 % 2)


class Solution(object):
    def findMinDifference(self, timePoints):

    minutes = map(lambda x: int(x[:2]) * 60 + int(x[3:]), timePoints)
    minutes.sort()
    return min(
        (y - x) % (24 * 60) for x, y in zip(minutes, minutes[1:] + minutes[:1])
    )


import heapq


class Solution(object):
    def minBuildTime(self, blocks, split):

    heapq.heapify(blocks)
    while len(blocks) != 1:
        x, y = heapq.heappop(blocks), heapq.heappop(blocks)
        heapq.heappush(blocks, y + split)
    return heapq.heappop(blocks)


import collections


class Solution(object):
    def minTime(self, n, edges, hasApple):

    graph = collections.defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    result = [0, 0]
    s = [(1, (-1, 0, result))]
    while s:
        step, params = s.pop()
        if step == 1:
            par, node, ret = params
            ret[:] = [0, int(hasApple[node])]
            for nei in reversed(graph[node]):
                if nei == par:
                    continue
                new_ret = [0, 0]
                s.append((2, (new_ret, ret)))
                s.append((1, (node, nei, new_ret)))
        else:
            new_ret, ret = params
            ret[0] += new_ret[0] + new_ret[1]
            ret[1] |= bool(new_ret[0] + new_ret[1])
    return 2 * result[0]


class Solution_Recu(object):
    def minTime(self, n, edges, hasApple):

    def dfs(graph, par, node, hasApple):
        result, extra = 0, int(hasApple[node])
        for nei in graph[node]:
            if nei == par:
                continue
            count, found = dfs(graph, node, nei, hasApple)
            result += count + found
            extra |= bool(count + found)
        return result, extra

    graph = collections.defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    return 2 * dfs(graph, -1, 0, hasApple)[0]


class Solution2(object):
    def minTime(self, n, edges, hasApple):

    graph = collections.defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    result = [0]
    s = [(1, (-1, 0, result))]
    while s:
        step, params = s.pop()
        if step == 1:
            par, node, ret = params
            tmp = [int(hasApple[node])]
            s.append((3, (tmp, ret)))
            for nei in reversed(graph[node]):
                if nei == par:
                    continue
                new_ret = [0]
                s.append((2, (new_ret, tmp, ret)))
                s.append((1, (node, nei, new_ret)))
        elif step == 2:
            new_ret, tmp, ret = params
            ret[0] += new_ret[0]
            tmp[0] |= bool(new_ret[0])
        else:
            tmp, ret = params
            ret[0] += tmp[0]
    return 2 * max(result[0] - 1, 0)


class Solution2_Recu(object):
    def minTime(self, n, edges, hasApple):

    def dfs(graph, par, node, has_subtree):
        result, extra = 0, int(hasApple[node])
        for nei in graph[node]:
            if nei == par:
                continue
            count = dfs(graph, node, nei, hasApple)
            result += count
            extra |= bool(count)
        return result + extra

    graph = collections.defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
    return 2 * max(dfs(graph, -1, 0, hasApple) - 1, 0)


class Solution(object):
    def minTimeToVisitAllPoints(self, points):

    return sum(
        max(
            abs(points[i + 1][0] - points[i][0]),
            abs(points[i + 1][1] - points[i][1]),
        )
        for i in xrange(len(points) - 1)
    )


class Solution(object):
    def minAbbreviation(self, target, dictionary):

    def bits_to_abbr_len(targets, bits):
        total = 0
        pre = 0
        for i in xrange(len(target)):
            if bits & 1:
                if i - pre > 0:
                    total += len(str(i - pre))
                pre = i + 1
                total += 1
            elif i == len(target) - 1:
                total += len(str(i - pre + 1))
            bits >>= 1
        return total

    def bits_to_abbr(targets, bits):
        abbr = []
        pre = 0
        for i in xrange(len(target)):
            if bits & 1:
                if i - pre > 0:
                    abbr.append(str(i - pre))
                pre = i + 1
                abbr.append(target[i])
            elif i == len(target) - 1:
                abbr.append(str(i - pre + 1))
            bits >>= 1
        return "".join(abbr)

    diffs = []
    for word in dictionary:
        if len(word) != len(target):
            continue
        diffs.append(sum(2 ** i for i, c in enumerate(word) if target[i] != c))

    if not diffs:
        return str(len(target))

    result = 2 ** len(target) - 1
    for mask in xrange(2 ** len(target)):
        if all(d & mask for d in diffs) and bits_to_abbr_len(
            target, mask
        ) < bits_to_abbr_len(target, result):
            result = mask
    return bits_to_abbr(target, result)


class Solution2(object):
    def minAbbreviation(self, target, dictionary):

    def bits_to_abbr(targets, bits):
        abbr = []
        pre = 0
        for i in xrange(len(target)):
            if bits & 1:
                if i - pre > 0:
                    abbr.append(str(i - pre))
                pre = i + 1
                abbr.append(target[i])
            elif i == len(target) - 1:
                abbr.append(str(i - pre + 1))
            bits >>= 1
        return "".join(abbr)

    diffs = []
    for word in dictionary:
        if len(word) != len(target):
            continue
        diffs.append(sum(2 ** i for i, c in enumerate(word) if target[i] != c))

    if not diffs:
        return str(len(target))

    result = target
    for mask in xrange(2 ** len(target)):
        abbr = bits_to_abbr(target, mask)
        if all(d & mask for d in diffs) and len(abbr) < len(result):
            result = abbr
    return result


class Solution(object):
    def minStartValue(self, nums):

    min_prefix, prefix = 0, 0
    for num in nums:
        prefix += num
        min_prefix = min(min_prefix, prefix)
    return 1 - min_prefix


class Solution(object):
    def minWindow(self, S, T):

    lookup = [[None for _ in xrange(26)] for _ in xrange(len(S) + 1)]
    find_char_next_pos = [None] * 26
    for i in reversed(xrange(len(S))):
        find_char_next_pos[ord(S[i]) - ord("a")] = i + 1
        lookup[i] = list(find_char_next_pos)

    min_i, min_len = None, float("inf")
    for i in xrange(len(S)):
        if S[i] != T[0]:
            continue
        start = i
        for c in T:
            start = lookup[start][ord(c) - ord("a")]
            if start == None:
                break
        else:
            if start - i < min_len:
                min_i, min_len = i, start - i
    return S[min_i: min_i + min_len] if min_i is not None else ""


class Solution2(object):
    def minWindow(self, S, T):

    dp = [[None for _ in xrange(len(S))] for _ in xrange(2)]
    for j, c in enumerate(S):
        if c == T[0]:
            dp[0][j] = j

    for i in xrange(1, len(T)):
        prev = None
        dp[i % 2] = [None] * len(S)
        for j, c in enumerate(S):
            if prev is not None and c == T[i]:
                dp[i % 2][j] = prev
            if dp[(i - 1) % 2][j] is not None:
                prev = dp[(i - 1) % 2][j]

    start, end = 0, len(S)
    for j, i in enumerate(dp[(len(T) - 1) % 2]):
        if i >= 0 and j - i < end - start:
            start, end = i, j
    return S[start: end + 1] if end < len(S) else ""


import collections


class Solution(object):
    def minWindow(self, s, t):

    count, remain = collections.Counter(t), len(t)
    i, left, right = 0, -1, -1
    for j, c in enumerate(s):
        remain -= count[c] > 0
        count[c] -= 1
        if remain:
            continue
        while count[s[i]] < 0:
            count[s[i]] += 1
            i += 1
        if right == -1 or j - i + 1 < right - left + 1:
            left, right = i, j
    return s[left: right + 1]


class Solution2(object):
    def minWindow(self, s, t):

    current_count = [0 for i in xrange(52)]
    expected_count = [0 for i in xrange(52)]

    for char in t:
        expected_count[ord(char) - ord("a")] += 1

    i, count, start, min_width, min_start = 0, 0, 0, float("inf"), 0
    while i < len(s):
        current_count[ord(s[i]) - ord("a")] += 1
        if (
            current_count[ord(s[i]) - ord("a")]
            <= expected_count[ord(s[i]) - ord("a")]
        ):
            count += 1

        if count == len(t):
            while (
                expected_count[ord(s[start]) - ord("a")] == 0
                or current_count[ord(s[start]) - ord("a")]
                > expected_count[ord(s[start]) - ord("a")]
            ):
                current_count[ord(s[start]) - ord("a")] -= 1
                start += 1

            if min_width > i - start + 1:
                min_width = i - start + 1
                min_start = start
        i += 1

    if min_width == float("inf"):
        return ""

    return s[min_start: min_start + min_width]


class Solution(object):
    def mirrorReflection(self, p, q):

    return 2 if (p & -p) > (q & -q) else 0 if (p & -p) < (q & -q) else 1


class Solution2(object):
    def mirrorReflection(self, p, q):

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    lcm = p * q // gcd(p, q)

    if lcm // p % 2 == 1:
        if lcm // q % 2 == 1:
            return 1
        return 2
    return 0


class Solution(object):
    def missingElement(self, nums, k):

    def missing_count(nums, x):
        return (nums[x] - nums[0] + 1) - (x - 0 + 1)

    def check(nums, k, x):
        return k > missing_count(nums, x)

    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if not check(nums, k, mid):
            right = mid - 1
        else:
            left = mid + 1
    assert check(nums, k, right)
    return nums[right] + (k - missing_count(nums, right))


class Solution(object):
    def missingNumber(self, arr):

    def check(arr, d, x):
        return arr[x] != arr[0] + d * x

    d = (arr[-1] - arr[0]) // len(arr)
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if check(arr, d, mid):
            right = mid - 1
        else:
            left = mid + 1
    return arr[0] + d * left


class Solution2(object):
    def missingNumber(self, arr):

    return (min(arr) + max(arr)) * (len(arr) + 1) // 2 - sum(arr)


import operator


class Solution(object):
    def missingNumber(self, nums):

    return reduce(operator.xor, nums, reduce(operator.xor, xrange(len(nums) + 1)))


class Solution2(object):
    def missingNumber(self, nums):
    return sum(xrange(len(nums) + 1)) - sum(nums)


class Solution(object):
    def findMissingRanges(self, nums, lower, upper):

    def getRange(lower, upper):
        if lower == upper:
            return "{}".format(lower)
        else:
            return "{}->{}".format(lower, upper)

    ranges = []
    pre = lower - 1

    for i in xrange(len(nums) + 1):
        if i == len(nums):
            cur = upper + 1
        else:
            cur = nums[i]
        if cur - pre >= 2:
            ranges.append(getRange(pre + 1, cur - 1))

        pre = cur

    return ranges


class Solution(object):
    def monotoneIncreasingDigits(self, N):

    nums = map(int, list(str(N)))
    leftmost_inverted_idx = len(nums)
    for i in reversed(xrange(1, len(nums))):
        if nums[i - 1] > nums[i]:
            leftmost_inverted_idx = i
            nums[i - 1] -= 1
    for i in xrange(leftmost_inverted_idx, len(nums)):
        nums[i] = 9
    return int("".join(map(str, nums)))


class Solution(object):
    def isMonotonic(self, A):

    inc, dec = False, False
    for i in xrange(len(A) - 1):
        if A[i] < A[i + 1]:
            inc = True
        elif A[i] > A[i + 1]:
            dec = True
    return not inc or not dec


import collections


class Solution(object):
    def mostCommonWord(self, paragraph, banned):

    lookup = set(banned)
    counts = collections.Counter(
        word.strip("!?',.") for word in paragraph.lower().split()
    )

    result = ""
    for word in counts:
        if (not result or counts[word] > counts[result]) and word not in lookup:
            result = word
    return result


import collections


class Solution(object):
    def findFrequentTreeSum(self, root):

    def countSubtreeSumHelper(root, counts):
        if not root:
            return 0
        total = (
            root.val
            + countSubtreeSumHelper(root.left, counts)
            + countSubtreeSumHelper(root.right, counts)
        )
        counts[total] += 1
        return total

    counts = collections.defaultdict(int)
    countSubtreeSumHelper(root, counts)
    max_count = max(counts.values()) if counts else 0
    return [total for total, count in counts.iteritems() if count == max_count]


class Solution(object):
    def maxProfitAssignment(self, difficulty, profit, worker):

    jobs = zip(difficulty, profit)
    jobs.sort()
    worker.sort()
    result, i, max_profit = 0, 0, 0
    for ability in worker:
        while i < len(jobs) and jobs[i][0] <= ability:
            max_profit = max(max_profit, jobs[i][1])
            i += 1
        result += max_profit
    return result


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    return True


class Solution(object):
    def removeStones(self, stones):

    MAX_ROW = 10000
    union_find = UnionFind(2 * MAX_ROW)
    for r, c in stones:
        union_find.union_set(r, c + MAX_ROW)
    return len(stones) - len({union_find.find_set(r) for r, _ in stones})


class Solution(object):
    def mostVisited(self, n, rounds):

    return range(rounds[0], rounds[-1] + 1) or range(1, rounds[-1] + 1) + range(
        rounds[0], n + 1
    )


class Node(object):
    def __init__(self, val=None, children=None):
    self.val = val
    self.children = children if children is not None else []


class Solution(object):
    def moveSubTree(self, root, p, q):

    def iter_find_parents(node, parent, p, q, is_ancestor, lookup):
        stk = [(1, [node, None, False])]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, parent, is_ancestor = params
                if node in (p, q):
                    lookup[node] = parent
                    if len(lookup) == 2:
                        return is_ancestor
                stk.append((2, [node, is_ancestor, reversed(node.children)]))
            else:
                node, is_ancestor, it = params
                child = next(it, None)
                if not child:
                    continue
                stk.append((2, [node, is_ancestor, it]))
                stk.append((1, [child, node, is_ancestor or node == p]))
        assert False
        return False

    lookup = {}
    is_ancestor = iter_find_parents(root, None, p, q, False, lookup)
    if p in lookup and lookup[p] == q:
        return root
    q.children.append(p)
    if not is_ancestor:
        lookup[p].children.remove(p)
    else:
        lookup[q].children.remove(q)
        if p == root:
            root = q
        else:
            lookup[p].children[lookup[p].children.index(p)] = q
    return root


class Solution_Recu(object):
    def moveSubTree(self, root, p, q):

    def find_parents(node, parent, p, q, is_ancestor, lookup):
        if node in (p, q):
            lookup[node] = parent
            if len(lookup) == 2:
                return True, is_ancestor
        for child in node.children:
            found, new_is_ancestor = find_parents(
                child, node, p, q, is_ancestor or node == p, lookup
            )
            if found:
                return True, new_is_ancestor
        return False, False

    lookup = {}
    is_ancestor = find_parents(root, None, p, q, False, lookup)[1]
    if p in lookup and lookup[p] == q:
        return root
    q.children.append(p)
    if not is_ancestor:
        lookup[p].children.remove(p)
    else:
        lookup[q].children.remove(q)
        if p == root:
            root = q
        else:
            lookup[p].children[lookup[p].children.index(p)] = q
    return root


class Solution2(object):
    def moveSubTree(self, root, p, q):

    def iter_find_parents(node, parent, p, q, lookup):
        stk = [(1, [node, None])]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, parent = params
                if node in (p, q):
                    lookup[node] = parent
                    if len(lookup) == 2:
                        return
                stk.append((2, [node, reversed(node.children)]))
            else:
                node, it = params
                child = next(it, None)
                if not child:
                    continue
                stk.append((2, [node, it]))
                stk.append((1, [child, node]))

    def iter_is_ancestor(node, q):
        stk = [(1, [node])]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node = params[0]
                stk.append((2, [reversed(node.children)]))
            else:
                it = params[0]
                child = next(it, None)
                if not child:
                    continue
                if child == q:
                    return True
                stk.append((2, [it]))
                stk.append((1, [child]))
        return False

    lookup = {}
    iter_find_parents(root, None, p, q, lookup)
    if p in lookup and lookup[p] == q:
        return root
    q.children.append(p)
    if not iter_is_ancestor(p, q):
        lookup[p].children.remove(p)
    else:
        lookup[q].children.remove(q)
        if p == root:
            root = q
        else:
            lookup[p].children[lookup[p].children.index(p)] = q
    return root


class Solution2_Recu(object):
    def moveSubTree(self, root, p, q):

    def find_parents(node, parent, p, q, lookup):
        if node in (p, q):
            lookup[node] = parent
            if len(lookup) == 2:
                return True
        for child in node.children:
            if find_parents(child, node, p, q, lookup):
                return True
        return False

    def is_ancestor(node, q):
        for child in node.children:
            if node == q or is_ancestor(child, q):
                return True
        return False

    lookup = {}
    find_parents(root, None, p, q, lookup)
    if p in lookup and lookup[p] == q:
        return root
    q.children.append(p)
    if not is_ancestor(p, q):
        lookup[p].children.remove(p)
    else:
        lookup[q].children.remove(q)
        if p == root:
            root = q
        else:
            lookup[p].children[lookup[p].children.index(p)] = q
    return root


class Solution(object):
    def moveZeroes(self, nums):

    pos = 0
    for i in xrange(len(nums)):
        if nums[i]:
            nums[i], nums[pos] = nums[pos], nums[i]
            pos += 1

    def moveZeroes2(self, nums):

    nums.sort(cmp=lambda a, b: 0 if b else -1)


class Solution2(object):
    def moveZeroes(self, nums):

    pos = 0
    for i in xrange(len(nums)):
        if nums[i]:
            nums[pos] = nums[i]
            pos += 1

    for i in xrange(pos, len(nums)):
        nums[i] = 0


from collections import deque


class MovingAverage(object):
    def __init__(self, size):

    self.__size = size
    self.__sum = 0
    self.__q = deque()

    def next(self, val):

    if len(self.__q) == self.__size:
        self.__sum -= self.__q.popleft()
    self.__sum += val
    self.__q.append(val)
    return 1.0 * self.__sum / len(self.__q)


class Solution(object):
    def numMovesStonesII(self, stones):

    stones.sort()
    left, min_moves = 0, float("inf")
    max_moves = max(stones[-1] - stones[1], stones[-2] - stones[0]) - (
        len(stones) - 2
    )
    for right in xrange(len(stones)):
        while stones[right] - stones[left] + 1 > len(
            stones
        ):
            left += 1
        if (
            len(stones) - (right - left + 1) == 1
            and stones[right] - stones[left] + 1 == len(stones) - 1
        ):
            min_moves = min(min_moves, 2)
        else:
            min_moves = min(
                min_moves, len(stones) - (right - left + 1)
            )
    return [min_moves, max_moves]


class Solution(object):
    def numMovesStones(self, a, b, c):

    s = [a, b, c]
    s.sort()
    if s[0] + 1 == s[1] and s[1] + 1 == s[2]:
        return [0, 0]
    return [1 if s[0] + 2 >= s[1] or s[1] + 2 >= s[2] else 2, s[2] - s[0] - 2]


class Solution2(object):
    def numMovesStones(self, a, b, c):

    stones = [a, b, c]
    stones.sort()
    left, min_moves = 0, float("inf")
    max_moves = (stones[-1] - stones[0]) - (len(stones) - 1)
    for right in xrange(len(stones)):
        while stones[right] - stones[left] + 1 > len(
            stones
        ):
            left += 1
        min_moves = min(
            min_moves, len(stones) - (right - left + 1)
        )
    return [min_moves, max_moves]


class Solution(object):
    def multiply(self, num1, num2):

    result = [0] * (len(num1) + len(num2))
    for i in reversed(xrange(len(num1))):
        for j in reversed(xrange(len(num2))):
            result[i + j + 1] += int(num1[i]) * int(num2[j])
            result[i + j] += result[i + j + 1] // 10
            result[i + j + 1] %= 10
    for i in xrange(len(result)):
        if result[i]:
            break
    return "".join(map(lambda x: str(x), result[i:]))


class Solution2(object):
    def multiply(self, num1, num2):

    num1, num2 = num1[::-1], num2[::-1]
    result = [0] * (len(num1) + len(num2))
    for i in xrange(len(num1)):
        for j in xrange(len(num2)):
            result[i + j] += int(num1[i]) * int(num2[j])
            result[i + j + 1] += result[i + j] // 10
            result[i + j] %= 10
    for i in reversed(xrange(len(result))):
        if result[i]:
            break
    return "".join(map(str, result[i::-1]))


class Solution3(object):
    def multiply(self, num1, num2):

    return str(int(num1) * int(num2))


class Node(object):
    def __init__(self, start, end):
    self.__start = start
    self.__end = end
    self.__left = None
    self.__right = None

    def insert(self, node):
    if node.__start >= self.__end:
        if not self.__right:
            self.__right = node
            return True
        return self.__right.insert(node)
    elif node.__end <= self.__start:
        if not self.__left:
            self.__left = node
            return True
        return self.__left.insert(node)
    else:
        return False


class MyCalendar(object):
    def __init__(self):
    self.__root = None

    def book(self, start, end):

    if self.__root is None:
        self.__root = Node(start, end)
        return True
    return self.root.insert(Node(start, end))


class MyCalendar2(object):
    def __init__(self):
    self.__calendar = []

    def book(self, start, end):

    for i, j in self.__calendar:
        if start < j and end > i:
            return False
    self.__calendar.append((start, end))
    return True


class MyCalendarTwo(object):
    def __init__(self):
    self.__overlaps = []
    self.__calendar = []

    def book(self, start, end):

    for i, j in self.__overlaps:
        if start < j and end > i:
            return False
    for i, j in self.__calendar:
        if start < j and end > i:
            self.__overlaps.append((max(start, i), min(end, j)))
    self.__calendar.append((start, end))
    return True


import bisect


class MyCalendarThree(object):
    def __init__(self):
    self.__books = [[-1, 0]]
    self.__count = 0

    def book(self, start, end):

    i = bisect.bisect_right(self.__books, [start, float("inf")])
    if self.__books[i - 1][0] == start:
        i -= 1
    else:
        self.__books.insert(i, [start, self.__books[i - 1][1]])
    j = bisect.bisect_right(self.__books, [end, float("inf")])
    if self.__books[j - 1][0] == end:
        j -= 1
    else:
        self.__books.insert(j, [end, self.__books[j - 1][1]])
    for k in xrange(i, j):
        self.__books[k][1] += 1
        self.__count = max(self.__count, self.__books[k][1])
    return self.__count


class MyCalendarThree2(object):
    def __init__(self):
    self.__books = []

    def book(self, start, end):

    i = bisect.bisect_left(self.__books, (start, 1))
    if i < len(self.__books) and self.__books[i][0] == start:
        self.__books[i] = (self.__books[i][0], self.__books[i][1] + 1)
    else:
        self.__books.insert(i, (start, 1))

    j = bisect.bisect_left(self.__books, (end, 1))
    if j < len(self.__books) and self.__books[j][0] == end:
        self.__books[j] = (self.__books[j][0], self.__books[j][1] - 1)
    else:
        self.__books.insert(j, (end, -1))

    result, cnt = 0, 0
    for book in self.__books:
        cnt += book[1]
        result = max(result, cnt)
    return result


class Node(object):
    def __init__(self, val, children):
    self.val = val
    self.children = children


class Solution(object):
    def levelOrder(self, root):

    if not root:
        return []
    result, q = [], [root]
    while q:
        result.append([node.val for node in q])
        q = [child for node in q for child in node.children if child]
    return result


class Node(object):
    def __init__(self, val, children):
    self.val = val
    self.children = children


class Solution(object):
    def postorder(self, root):

    if not root:
        return []
    result, stack = [], [root]
    while stack:
        node = stack.pop()
        result.append(node.val)
        for child in node.children:
            if child:
                stack.append(child)
    return result[::-1]


class Solution2(object):
    def postorder(self, root):

    def dfs(root, result):
        for child in root.children:
            if child:
                dfs(child, result)
        result.append(root.val)

    result = []
    if root:
        dfs(root, result)
    return result


class Node(object):
    def __init__(self, val, children):
    self.val = val
    self.children = children


class Solution(object):
    def preorder(self, root):

    if not root:
        return []
    result, stack = [], [root]
    while stack:
        node = stack.pop()
        result.append(node.val)
        for child in reversed(node.children):
            if child:
                stack.append(child)
    return result


class Solution2(object):
    def preorder(self, root):

    def dfs(root, result):
        result.append(root.val)
        for child in root.children:
            if child:
                dfs(child, result)

    result = []
    if root:
        dfs(root, result)
    return result


from functools import reduce


class Solution(object):

    def totalNQueens(self, n):
    self.cols = [False] * n
    self.main_diag = [False] * (2 * n)
    self.anti_diag = [False] * (2 * n)
    return self.totalNQueensRecu([], 0, n)

    def totalNQueensRecu(self, solution, row, n):
    if row == n:
        return 1
    result = 0
    for i in xrange(n):
        if (
            not self.cols[i]
            and not self.main_diag[row + i]
            and not self.anti_diag[row - i + n]
        ):
            self.cols[i] = self.main_diag[row + i] = self.anti_diag[
                row - i + n
            ] = True
            result += self.totalNQueensRecu(solution + [i], row + 1, n)
            self.cols[i] = self.main_diag[row + i] = self.anti_diag[
                row - i + n
            ] = False
    return result


class Solution2(object):

    def totalNQueens(self, n):
    return self.totalNQueensRecu([], 0, n)

    def totalNQueensRecu(self, solution, row, n):
    if row == n:
        return 1
    result = 0
    for i in xrange(n):
        if i not in solution and reduce(
            lambda acc, j: abs(row - j) != abs(i - solution[j]) and acc,
            xrange(len(solution)),
            True,
        ):
            result += self.totalNQueensRecu(solution + [i], row + 1, n)
    return result


class Solution(object):
    def solveNQueens(self, n):

    def dfs(curr, cols, main_diag, anti_diag, result):
        row, n = len(curr), len(cols)
        if row == n:
            result.append(
                map(lambda x: "." * x + "Q" + "." * (n - x - 1), curr))
            return
        for i in xrange(n):
            if cols[i] or main_diag[row + i] or anti_diag[row - i + n]:
                continue
            cols[i] = main_diag[row + i] = anti_diag[row - i + n] = True
            curr.append(i)
            dfs(curr, cols, main_diag, anti_diag, result)
            curr.pop()
            cols[i] = main_diag[row + i] = anti_diag[row - i + n] = False

    result = []
    cols, main_diag, anti_diag = [False] * \
        n, [False] * (2 * n), [False] * (2 * n)
    dfs([], cols, main_diag, anti_diag, result)
    return result


class Solution2(object):
    def solveNQueens(self, n):

    def dfs(col_per_row, xy_diff, xy_sum):
        cur_row = len(col_per_row)
        if cur_row == n:
            ress.append(col_per_row)
        for col in range(n):
            if (
                col not in col_per_row
                and cur_row - col not in xy_diff
                and cur_row + col not in xy_sum
            ):
                dfs(
                    col_per_row + [col],
                    xy_diff + [cur_row - col],
                    xy_sum + [cur_row + col],
                )

    ress = []
    dfs([], [], [])
    return [["." * i + "Q" + "." * (n - i - 1) for i in res] for res in ress]


class Solution(object):
    def repeatedNTimes(self, A):

    for i in xrange(2, len(A)):
        if A[i - 1] == A[i] or A[i - 2] == A[i]:
            return A[i]
    return A[0]


import itertools


class Solution(object):
    def tribonacci(self, n):

    def matrix_expo(A, K):
        result = [[int(i == j) for j in xrange(len(A))]
                  for i in xrange(len(A))]
        while K:
            if K % 2:
                result = matrix_mult(result, A)
            A = matrix_mult(A, A)
            K /= 2
        return result

    def matrix_mult(A, B):
        ZB = zip(*B)
        return [
            [sum(a * b for a, b in itertools.izip(row, col)) for col in ZB]
            for row in A
        ]

    T = [[1, 1, 0], [1, 0, 1], [1, 0, 0]]
    return matrix_mult([[1, 0, 0]], matrix_expo(T, n))[0][
        1
    ]


class Solution2(object):
    def tribonacci(self, n):

    a, b, c = 0, 1, 1
    for _ in xrange(n):
        a, b, c = b, c, a + b + c
    return a


class Solution(object):
    def depthSumInverse(self, nestedList):

    def depthSumInverseHelper(list, depth, result):
        if len(result) < depth + 1:
            result.append(0)
        if list.isInteger():
            result[depth] += list.getInteger()
        else:
            for l in list.getList():
                depthSumInverseHelper(l, depth + 1, result)

    result = []
    for list in nestedList:
        depthSumInverseHelper(list, 0, result)

    sum = 0
    for i in reversed(xrange(len(result))):
        sum += result[i] * (len(result) - i)
    return sum


class Solution(object):
    def depthSum(self, nestedList):

    def depthSumHelper(nestedList, depth):
        res = 0
        for l in nestedList:
            if l.isInteger():
                res += l.getInteger() * depth
            else:
                res += depthSumHelper(l.getList(), depth + 1)
        return res

    return depthSumHelper(nestedList, 1)


import collections
import heapq


class Solution(object):
    def networkDelayTime(self, times, N, K):

    adj = [[] for _ in xrange(N)]
    for u, v, w in times:
        adj[u - 1].append((v - 1, w))

    result = 0
    lookup = set()
    best = collections.defaultdict(lambda: float("inf"))
    min_heap = [(0, K - 1)]
    while min_heap and len(lookup) != N:
        result, u = heapq.heappop(min_heap)
        lookup.add(u)
        if best[u] < result:
            continue
        for v, w in adj[u]:
            if v in lookup:
                continue
            if result + w < best[v]:
                best[v] = result + w
                heapq.heappush(min_heap, (result + w, v))
    return result if len(lookup) == N else -1


class Solution(object):
    def nextClosestTime(self, time):

    h, m = time.split(":")
    curr = int(h) * 60 + int(m)
    result = None
    for i in xrange(curr + 1, curr + 1441):
        t = i % 1440
        h, m = t // 60, t % 60
        result = "%02d:%02d" % (h, m)
        if set(result) <= set(time):
            break
    return result


class Solution(object):
    def nextGreaterElement(self, findNums, nums):

    stk, lookup = [], {}
    for num in nums:
        while stk and num > stk[-1]:
            lookup[stk.pop()] = num
        stk.append(num)
    while stk:
        lookup[stk.pop()] = -1
    return map(lambda x: lookup[x], findNums)


class Solution(object):
    def nextGreaterElements(self, nums):

    result, stk = [0] * len(nums), []
    for i in reversed(xrange(2 * len(nums))):
        while stk and stk[-1] <= nums[i % len(nums)]:
            stk.pop()
        result[i % len(nums)] = stk[-1] if stk else -1
        stk.append(nums[i % len(nums)])
    return result


class Solution(object):
    def nextGreaterElement(self, n):

    digits = map(int, list(str(n)))
    k, l = -1, 0
    for i in xrange(len(digits) - 1):
        if digits[i] < digits[i + 1]:
            k = i

    if k == -1:
        digits.reverse()
        return -1

    for i in xrange(k + 1, len(digits)):
        if digits[i] > digits[k]:
            l = i

    digits[k], digits[l] = digits[l], digits[k]
    digits[k + 1:] = digits[:k:-1]
    result = int("".join(map(str, digits)))
    return -1 if result >= 0x7FFFFFFF else result


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):
    def nextLargerNodes(self, head):

    result, stk = [], []
    while head:
        while stk and stk[-1][1] < head.val:
            result[stk.pop()[0]] = head.val
        stk.append([len(result), head.val])
        result.append(0)
        head = head.next
    return result


class Solution(object):
    def nextPermutation(self, nums):

    k, l = -1, 0
    for i in reversed(xrange(len(nums) - 1)):
        if nums[i] < nums[i + 1]:
            k = i
            break
    else:
        nums.reverse()
        return

    for i in reversed(xrange(k + 1, len(nums))):
        if nums[i] > nums[k]:
            l = i
            break
    nums[k], nums[l] = nums[l], nums[k]
    nums[k + 1:] = nums[:k:-1]


class Solution2(object):
    def nextPermutation(self, nums):

    k, l = -1, 0
    for i in xrange(len(nums) - 1):
        if nums[i] < nums[i + 1]:
            k = i

    if k == -1:
        nums.reverse()
        return

    for i in xrange(k + 1, len(nums)):
        if nums[i] > nums[k]:
            l = i
    nums[k], nums[l] = nums[l], nums[k]
    nums[k + 1:] = nums[:k:-1]


class Solution(object):
    def canWinNim(self, n):

    return n % 4 != 0


class Solution(object):
    def checkPossibility(self, nums):

    modified, prev = False, nums[0]
    for i in xrange(1, len(nums)):
        if prev > nums[i]:
            if modified:
                return False
            if i - 2 < 0 or nums[i - 2] <= nums[i]:
                prev = nums[i]

            modified = True
        else:
            prev = nums[i]
    return True


class Solution(object):
    def findIntegers(self, num):

    dp = [0] * 32
    dp[0], dp[1] = 1, 2
    for i in xrange(2, len(dp)):
        dp[i] = dp[i - 1] + dp[i - 2]
    result, prev_bit = 0, 0
    for i in reversed(xrange(31)):
        if (num & (1 << i)) != 0:
            result += dp[i]
            if prev_bit == 1:
                result -= 1
                break
            prev_bit = 1
        else:
            prev_bit = 0
    return result + 1


class Solution(object):
    def eraseOverlapIntervals(self, intervals):

    intervals.sort(key=lambda interval: interval.start)
    result, prev = 0, 0
    for i in xrange(1, len(intervals)):
        if intervals[i].start < intervals[prev].end:
            if intervals[i].end < intervals[prev].end:
                prev = i
            result += 1
        else:
            prev = i
    return result


class Solution(object):
    def findNthDigit(self, n):

    digit_len = 1
    while n > digit_len * 9 * (10 ** (digit_len - 1)):
        n -= digit_len * 9 * (10 ** (digit_len - 1))
        digit_len += 1

    num = 10 ** (digit_len - 1) + (n - 1) / digit_len

    nth_digit = num / (10 ** ((digit_len - 1) - ((n - 1) % digit_len)))
    nth_digit %= 10

    return nth_digit


class Solution(object):
    def nthMagicalNumber(self, N, A, B):

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    def check(A, B, N, lcm, target):
        return target // A + target // B - target // lcm >= N

    lcm = A * B // gcd(A, B)
    left, right = min(A, B), max(A, B) * N
    while left <= right:
        mid = left + (right - left) // 2
        if check(A, B, N, lcm, mid):
            right = mid - 1
        else:
            left = mid + 1
    return left % (10 ** 9 + 7)


class Solution(object):
    def findComplement(self, num):

    return 2 ** (len(bin(num)) - 2) - 1 - num


class Solution2(object):
    def findComplement(self, num):
    i = 1
    while i <= num:
        i <<= 1
    return (i - 1) ^ num


class Solution3(object):
    def findComplement(self, num):
    bits = "{0:b}".format(num)
    complement_bits = "".join("1" if bit == "0" else "0" for bit in bits)
    return int(complement_bits, 2)


class Solution(object):

    def hammingWeight(self, n):
    n = (n & 0x55555555) + ((n >> 1) & 0x55555555)
    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)
    n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)
    n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)
    n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)
    return n


class Solution2(object):
    def __init__(self):
    self.__popcount_tab = [
        0,
        1,
        1,
        2,
        1,
        2,
        2,
        3,
        1,
        2,
        2,
        3,
        2,
        3,
        3,
        4,
        1,
        2,
        2,
        3,
        2,
        3,
        3,
        4,
        2,
        3,
        3,
        4,
        3,
        4,
        4,
        5,
        1,
        2,
        2,
        3,
        2,
        3,
        3,
        4,
        2,
        3,
        3,
        4,
        3,
        4,
        4,
        5,
        2,
        3,
        3,
        4,
        3,
        4,
        4,
        5,
        3,
        4,
        4,
        5,
        4,
        5,
        5,
        6,
        1,
        2,
        2,
        3,
        2,
        3,
        3,
        4,
        2,
        3,
        3,
        4,
        3,
        4,
        4,
        5,
        2,
        3,
        3,
        4,
        3,
        4,
        4,
        5,
        3,
        4,
        4,
        5,
        4,
        5,
        5,
        6,
        2,
        3,
        3,
        4,
        3,
        4,
        4,
        5,
        3,
        4,
        4,
        5,
        4,
        5,
        5,
        6,
        3,
        4,
        4,
        5,
        4,
        5,
        5,
        6,
        4,
        5,
        5,
        6,
        5,
        6,
        6,
        7,
        1,
        2,
        2,
        3,
        2,
        3,
        3,
        4,
        2,
        3,
        3,
        4,
        3,
        4,
        4,
        5,
        2,
        3,
        3,
        4,
        3,
        4,
        4,
        5,
        3,
        4,
        4,
        5,
        4,
        5,
        5,
        6,
        2,
        3,
        3,
        4,
        3,
        4,
        4,
        5,
        3,
        4,
        4,
        5,
        4,
        5,
        5,
        6,
        3,
        4,
        4,
        5,
        4,
        5,
        5,
        6,
        4,
        5,
        5,
        6,
        5,
        6,
        6,
        7,
        2,
        3,
        3,
        4,
        3,
        4,
        4,
        5,
        3,
        4,
        4,
        5,
        4,
        5,
        5,
        6,
        3,
        4,
        4,
        5,
        4,
        5,
        5,
        6,
        4,
        5,
        5,
        6,
        5,
        6,
        6,
        7,
        3,
        4,
        4,
        5,
        4,
        5,
        5,
        6,
        4,
        5,
        5,
        6,
        5,
        6,
        6,
        7,
        4,
        5,
        5,
        6,
        5,
        6,
        6,
        7,
        5,
        6,
        6,
        7,
        6,
        7,
        7,
        8,
    ]

    def hammingWeight(self, n):
    result = 0
    while n:
        result += self.__popcount_tab[n & 0xFF]
        n >>= 8
    return result


class Solution3(object):

    def hammingWeight(self, n):
    result = 0
    while n:
        n &= n - 1
        result += 1
    return result


import collections
import re


class Solution(object):
    def countOfAtoms(self, formula):

    parse = re.findall(r"([A-Z][a-z]*)(\d*)|(\()|(\))(\d*)", formula)
    stk = [collections.Counter()]
    for name, m1, left_open, right_open, m2 in parse:
        if name:
            stk[-1][name] += int(m1 or 1)
        if left_open:
            stk.append(collections.Counter())
        if right_open:
            top = stk.pop()
            for k, v in top.iteritems():
                stk[-1][k] += v * int(m2 or 1)

    return "".join(
        name + (str(stk[-1][name]) if stk[-1][name] > 1 else "")
        for name in sorted(stk[-1])
    )


import collections


class Solution(object):
    def numberOfBoomerangs(self, points):

    result = 0

    for i in xrange(len(points)):
        group = collections.defaultdict(int)
        for j in xrange(len(points)):
            if j == i:
                continue
            dx, dy = points[i][0] - points[j][0], points[i][1] - points[j][1]
            group[dx ** 2 + dy ** 2] += 1

        for _, v in group.iteritems():
            if v > 1:
                result += v * (v - 1)

    return result

    def numberOfBoomerangs2(self, points):

    cnt = 0
    for a, i in enumerate(points):
        dis_list = []
        for b, k in enumerate(points[:a] + points[a + 1:]):
            dis_list.append((k[0] - i[0]) ** 2 + (k[1] - i[1]) ** 2)
        for z in collections.Counter(dis_list).values():
            if z > 1:
                cnt += z * (z - 1)
    return cnt


class Solution(object):
    def numOfBurgers(self, tomatoSlices, cheeseSlices):

    return (
        [tomatoSlices // 2 - cheeseSlices, 2 * cheeseSlices - tomatoSlices // 2]
        if tomatoSlices % 2 == 0
        and 2 * cheeseSlices <= tomatoSlices <= 4 * cheeseSlices
        else []
    )


class Solution(object):
    def closedIsland(self, grid):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def fill(grid, i, j):
        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 0):
            return False
        grid[i][j] = 1
        for dx, dy in directions:
            fill(grid, i + dx, j + dy)
        return True

    for j in xrange(len(grid[0])):
        fill(grid, 0, j)
        fill(grid, len(grid) - 1, j)
    for i in xrange(1, len(grid)):
        fill(grid, i, 0)
        fill(grid, i, len(grid[0]) - 1)
    result = 0
    for i in xrange(1, len(grid) - 1):
        for j in xrange(1, len(grid[0]) - 1):
            if fill(grid, i, j):
                result += 1
    return result


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.count = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root != y_root:
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.count -= 1


class Solution(object):
    def countComponents(self, n, edges):

    union_find = UnionFind(n)
    for i, j in edges:
        union_find.union_set(i, j)
    return union_find.count


class Solution(object):
    def countCornerRectangles(self, grid):

    rows = [[c for c, val in enumerate(row) if val] for row in grid]
    result = 0
    for i in xrange(len(rows)):
        lookup = set(rows[i])
        for j in xrange(i):
            count = sum(1 for c in rows[j] if c in lookup)
            result += count * (count - 1) / 2
    return result


class Solution(object):
    def __init__(self):

    def dayOfMonth(M):
        return 28 if (M == 2) else 31 - (M - 1) % 7 % 2

    self.__lookup = [0] * 12
    for M in xrange(1, len(self.__lookup)):
        self.__lookup[M] += self.__lookup[M - 1] + dayOfMonth(M)

    def daysBetweenDates(self, date1, date2):

    def num_days(date):
        Y, M, D = map(int, date.split("-"))
        leap = (
            1
            if M > 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0))
            else 0
        )
        return (
            (Y - 1) * 365
            + ((Y - 1) // 4 - (Y - 1) // 100 + (Y - 1) // 400)
            + self.__lookup[M - 1]
            + D
            + leap
        )

    return abs(num_days(date1) - num_days(date2))


import datetime


class Solution2(object):
    def daysBetweenDates(self, date1, date2):
    delta = datetime.datetime.strptime(date1, "%Y-%m-%d")
    delta -= datetime.datetime.strptime(date2, "%Y-%m-%d")
    return abs(delta.days)


class Solution(object):
    def numberOfDays(self, Y, M):

    leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
    return 28 + leap if (M == 2) else 31 - (M - 1) % 7 % 2


class Solution(object):
    def numRollsToTarget(self, d, f, target):

    MOD = 10 ** 9 + 7
    dp = [[0 for _ in xrange(target + 1)] for _ in xrange(2)]
    dp[0][0] = 1
    for i in xrange(1, d + 1):
        dp[i % 2] = [0 for _ in xrange(target + 1)]
        for k in xrange(1, f + 1):
            for j in xrange(k, target + 1):
                dp[i % 2][j] = (dp[i % 2][j] + dp[(i - 1) % 2][j - k]) % MOD
    return dp[d % 2][target] % MOD


class Solution(object):
    def countDigitOne(self, n):

    DIGIT = 1
    is_zero = int(DIGIT == 0)
    result = is_zero
    base = 1
    while n >= base:
        result += (n // (10 * base) - is_zero) * base + min(
            base, max(n % (10 * base) - DIGIT * base + 1, 0)
        )
        base *= 10
    return result


class Solution(object):
    def numDistinctIslands2(self, grid):

    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

    def dfs(i, j, grid, island):
        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] > 0):
            return False
        grid[i][j] *= -1
        island.append((i, j))
        for d in directions:
            dfs(i + d[0], j + d[1], grid, island)
        return True

    def normalize(island):
        shapes = [[] for _ in xrange(8)]
        for x, y in island:
            rotations_and_reflections = [
                [x, y],
                [x, -y],
                [-x, y],
                [-x, -y],
                [y, x],
                [y, -x],
                [-y, x],
                [-y, -x],
            ]
            for i in xrange(len(rotations_and_reflections)):
                shapes[i].append(rotations_and_reflections[i])
        for shape in shapes:
            shape.sort()
            origin = list(shape[0])
            for p in shape:
                p[0] -= origin[0]
                p[1] -= origin[1]
        return min(shapes)

    islands = set()
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            island = []
            if dfs(i, j, grid, island):
                islands.add(str(normalize(island)))
    return len(islands)


class Solution(object):
    def numDistinctIslands(self, grid):

    directions = {"l": [-1, 0], "r": [1, 0], "u": [0, 1], "d": [0, -1]}

    def dfs(i, j, grid, island):
        if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] > 0):
            return False
        grid[i][j] *= -1
        for k, v in directions.iteritems():
            island.append(k)
            dfs(i + v[0], j + v[1], grid, island)
        return True

    islands = set()
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            island = []
            if dfs(i, j, grid, island):
                islands.add("".join(island))
    return len(islands)


import collections


class Solution(object):
    def distinctSubarraysWithAtMostKOddIntegers(self, A, K):

    def countDistinct(A, left, right, trie):
        result = 0
        for i in reversed(xrange(left, right + 1)):
            if A[i] not in trie:
                result += 1
            trie = trie[A[i]]
        return result

    def _trie(): return collections.defaultdict(_trie)
    trie = _trie()
    result, left, count = 0, 0, 0
    for right in xrange(len(A)):
        count += A[right] % 2
        while count > K:
            count -= A[left] % 2
            left += 1
        result += countDistinct(A, left, right, trie)
    return result


class Solution2(object):
    def distinctSubarraysWithAtMostKOddIntegers(self, A, K):

    def countDistinct(A, left, right, trie):
        result = 0
        for i in xrange(left, right + 1):
            if A[i] not in trie:
                result += 1
            trie = trie[A[i]]
        return result

    def _trie(): return collections.defaultdict(_trie)
    trie = _trie()
    result = 0
    for left in xrange(len(A)):
        count = 0
        for right in xrange(left, len(A)):
            count += A[right] % 2
            if count > K:
                right -= 1
                break
        result += countDistinct(A, left, right, trie)
    return result


class Solution(object):
    def countDistinct(self, s):

    count = 0
    trie = {}
    for i in xrange(len(s)):
        curr = trie
        for j in xrange(i, len(s)):
            if s[j] not in curr:
                count += 1
                curr[s[j]] = {}
            curr = curr[s[j]]
    return count


class Solution(object):
    def numEnclaves(self, A):

    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

    def dfs(A, i, j):
        if not (0 <= i < len(A) and 0 <= j < len(A[0]) and A[i][j]):
            return
        A[i][j] = 0
        for d in directions:
            dfs(A, i + d[0], j + d[1])

    for i in xrange(len(A)):
        dfs(A, i, 0)
        dfs(A, i, len(A[0]) - 1)
    for j in xrange(1, len(A[0]) - 1):
        dfs(A, 0, j)
        dfs(A, len(A) - 1, j)
    return sum(sum(row) for row in A)


import collections


class Solution(object):
    def numEquivDominoPairs(self, dominoes):

    counter = collections.Counter((min(x), max(x)) for x in dominoes)
    return sum(v * (v - 1) // 2 for v in counter.itervalues())


import collections


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    self.val = val
    self.left = left
    self.right = right


class Solution(object):
    def countPairs(self, root, distance):

    def iter_dfs(distance, root):
        result = 0
        stk = [(1, (root, [collections.Counter()]))]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, ret = params
                if not node:
                    continue
                if not node.left and not node.right:
                    ret[0][0] = 1
                    continue
                left, right = [collections.Counter()], [collections.Counter()]
                stk.append((2, (left, right, ret)))
                stk.append((1, (node.right, right)))
                stk.append((1, (node.left, left)))
            else:
                left, right, ret = params
                for left_d, left_c in left[0].iteritems():
                    for right_d, right_c in right[0].iteritems():
                        if left_d + right_d + 2 <= distance:
                            result += left_c * right_c
                ret[0] = collections.Counter(
                    {k + 1: v for k, v in (left[0] + right[0]).iteritems()}
                )
        return result

    return iter_dfs(distance, root)


import collections


class Solution2(object):
    def countPairs(self, root, distance):

    def dfs(distance, node):
        if not node:
            return 0, collections.Counter()
        if not node.left and not node.right:
            return 0, collections.Counter([0])
        left, right = dfs(distance, node.left), dfs(distance, node.right)
        result = left[0] + right[0]
        for left_d, left_c in left[1].iteritems():
            for right_d, right_c in right[1].iteritems():
                if left_d + right_d + 2 <= distance:
                    result += left_c * right_c
        return result, collections.Counter(
            {k + 1: v for k, v in (left[1] + right[1]).iteritems()}
        )

    return dfs(distance, root)[0]


import collections


class Solution(object):
    def numIdenticalPairs(self, nums):

    return sum(c * (c - 1) // 2 for c in collections.Counter(nums).itervalues())


import collections


class Solution(object):
    def numSplits(self, s):

    left_count, right_count = collections.Counter(), collections.Counter(s)
    result = 0
    for c in s:
        left_count[c] += 1
        right_count[c] -= 1
        if not right_count[c]:
            del right_count[c]
        if len(left_count) == len(right_count):
            result += 1
    return result


class Solution(object):
    def numIslands2(self, m, n, positions):

    def node_id(node, n):
        return node[0] * n + node[1]

    def find_set(x):
        if set[x] != x:
            set[x] = find_set(set[x])
        return set[x]

    def union_set(x, y):
        x_root, y_root = find_set(x), find_set(y)
        set[min(x_root, y_root)] = max(x_root, y_root)

    numbers = []
    number = 0
    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
    set = {}
    for position in positions:
        node = (position[0], position[1])
        set[node_id(node, n)] = node_id(node, n)
        number += 1

        for d in directions:
            neighbor = (position[0] + d[0], position[1] + d[1])
            if (
                0 <= neighbor[0] < m
                and 0 <= neighbor[1] < n
                and node_id(neighbor, n) in set
            ):
                if find_set(node_id(node, n)) != find_set(node_id(neighbor, n)):

                    union_set(node_id(node, n), node_id(neighbor, n))
                    number -= 1
        numbers.append(number)

    return numbers


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.count = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root != y_root:
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.count -= 1


class Solution(object):
    def numIslands(self, grid):

    def index(n, i, j):
        return i * n + j

    if not grid:
        return 0

    zero_count = 0
    union_find = UnionFind(len(grid) * len(grid[0]))
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            if grid[i][j] == "1":
                if i and grid[i - 1][j] == "1":
                    union_find.union_set(
                        index(len(grid[0]), i - 1,
                              j), index(len(grid[0]), i, j)
                    )
                if j and grid[i][j - 1] == "1":
                    union_find.union_set(
                        index(len(grid[0]), i, j -
                              1), index(len(grid[0]), i, j)
                    )
            else:
                zero_count += 1
    return union_find.count - zero_count


class Solution2(object):
    def numIslands(self, grid):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def dfs(grid, i, j):
        if grid[i][j] == "0":
            return False
        grid[i][j] = "0"
        stk = [(i, j)]
        while stk:
            r, c = stk.pop()
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if not (
                    0 <= nr < len(grid)
                    and 0 <= nc < len(grid[0])
                    and grid[nr][nc] == "1"
                ):
                    continue
                grid[nr][nc] = "0"
                stk.append((nr, nc))
        return True

    count = 0
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            if dfs(grid, i, j):
                count += 1
    return count


import collections


class Solution3(object):
    def numIslands(self, grid):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def bfs(grid, i, j):
        if grid[i][j] == "0":
            return False
        grid[i][j] = "0"
        q = collections.deque([(i, j)])
        while q:
            r, c = q.popleft()
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if not (
                    0 <= nr < len(grid)
                    and 0 <= nc < len(grid[0])
                    and grid[nr][nc] == "1"
                ):
                    continue
                grid[nr][nc] = "0"
                q.append((nr, nc))
        return True

    count = 0
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            if bfs(grid, i, j):
                count += 1
    return count


class Solution(object):
    def numberOfLines(self, widths, S):

    result = [1, 0]
    for c in S:
        w = widths[ord(c) - ord("a")]
        result[1] += w
        if result[1] > 100:
            result[0] += 1
            result[1] = w
    return result


class Solution(object):
    def findNumberOfLIS(self, nums):

    result, max_len = 0, 0
    dp = [[1, 1] for _ in xrange(len(nums))]
    for i in xrange(len(nums)):
        for j in xrange(i):
            if nums[i] > nums[j]:
                if dp[i][0] == dp[j][0] + 1:
                    dp[i][1] += dp[j][1]
                elif dp[i][0] < dp[j][0] + 1:
                    dp[i] = [dp[j][0] + 1, dp[j][1]]
        if max_len == dp[i][0]:
            result += dp[i][1]
        elif max_len < dp[i][0]:
            max_len = dp[i][0]
            result = dp[i][1]
    return result


import collections


class Solution(object):
    def numMatchingSubseq(self, S, words):

    waiting = collections.defaultdict(list)
    for word in words:
        it = iter(word)
        waiting[next(it, None)].append(it)
    for c in S:
        for it in waiting.pop(c, ()):
            waiting[next(it, None)].append(it)
    return len(waiting[None])


class Solution(object):
    def numMusicPlaylists(self, N, L, K):

    M = 10 ** 9 + 7
    dp = [[0 for _ in xrange(1 + L)] for _ in xrange(2)]
    dp[0][0] = dp[1][1] = 1
    for n in xrange(1, N + 1):
        dp[n % 2][n] = (dp[(n - 1) % 2][n - 1] * n) % M
        for l in xrange(n + 1, L + 1):
            dp[n % 2][l] = (
                (dp[n % 2][l - 1] * max(n - K, 0)) % M
                + (dp[(n - 1) % 2][l - 1] * n) % M
            ) % M
    return dp[N % 2][L]


class Solution(object):
    def countSubTrees(self, n, edges, labels):

    def iter_dfs(labels, adj, node, parent, result):
        stk = [(1, (node, parent, [0] * 26))]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, parent, ret = params
                stk.append((4, (node, ret)))
                stk.append((2, (node, parent, reversed(adj[node]), ret)))
            elif step == 2:
                node, parent, it, ret = params
                child = next(it, None)
                if not child or child == parent:
                    continue
                ret2 = [0] * 26
                stk.append((2, (node, parent, it, ret)))
                stk.append((3, (ret2, ret)))
                stk.append((1, (child, node, ret2)))
            elif step == 3:
                ret2, ret = params
                for k in xrange(len(ret2)):
                    ret[k] += ret2[k]
            else:
                node, ret = params
                ret[ord(labels[node]) - ord("a")] += 1
                result[node] += ret[ord(labels[node]) - ord("a")]

    adj = [[] for _ in xrange(n)]
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)
    result = [0] * n
    iter_dfs(labels, adj, 0, -1, result)
    return result


import collections


class Solution2(object):
    def countSubTrees(self, n, edges, labels):

    def dfs(labels, adj, node, parent, result):
        count = [0] * 26
        for child in adj[node]:
            if child == parent:
                continue
            new_count = dfs(labels, adj, child, node, result)
            for k in xrange(len(new_count)):
                count[k] += new_count[k]
        count[ord(labels[node]) - ord("a")] += 1
        result[node] = count[ord(labels[node]) - ord("a")]
        return count

    adj = [[] for _ in xrange(n)]
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)
    result = [0] * n
    dfs(labels, adj, 0, -1, result)
    return result


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.count = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[max(x_root, y_root)] = min(x_root, y_root)
    self.count -= 1
    return True


class Solution(object):
    def makeConnected(self, n, connections):

    if len(connections) < n - 1:
        return -1
    union_find = UnionFind(n)
    for i, j in connections:
        union_find.union_set(i, j)
    return union_find.count - 1


import collections


class Solution2(object):
    def makeConnected(self, n, connections):

    def dfs(i, lookup):
        if i in lookup:
            return 0
        lookup.add(i)
        if i in G:
            for j in G[i]:
                dfs(j, lookup)
        return 1

    if len(connections) < n - 1:
        return -1
    G = collections.defaultdict(list)
    for i, j in connections:
        G[i].append(j)
        G[j].append(i)
    lookup = set()
    return sum(dfs(i, lookup) for i in xrange(n)) - 1


class Solution(object):
    def pathsWithMaxScore(self, board):

    MOD = 10 ** 9 + 7
    directions = [[1, 0], [0, 1], [1, 1]]
    dp = [[[0, 0] for r in xrange(len(board[0]) + 1)] for r in xrange(2)]
    dp[(len(board) - 1) % 2][len(board[0]) - 1] = [0, 1]
    for r in reversed(xrange(len(board))):
        for c in reversed(xrange(len(board[0]))):
            if board[r][c] in "XS":
                continue
            dp[r % 2][c] = [0, 0]
            for dr, dc in directions:
                if dp[r % 2][c][0] < dp[(r + dr) % 2][c + dc][0]:
                    dp[r % 2][c] = dp[(r + dr) % 2][c + dc][:]
                elif dp[r % 2][c][0] == dp[(r + dr) % 2][c + dc][0]:
                    dp[r % 2][c][1] = (
                        dp[r % 2][c][1] + dp[(r + dr) % 2][c + dc][1]
                    ) % MOD
            if dp[r % 2][c][1] and board[r][c] != "E":
                dp[r % 2][c][0] += int(board[r][c])
    return dp[0][0]


import collections


class RecentCounter(object):
    def __init__(self):
    self.__q = collections.deque()

    def ping(self, t):

    self.__q.append(t)
    while self.__q[0] < t - 3000:
        self.__q.popleft()
    return len(self.__q)


class Solution(object):
    def countGoodRectangles(self, rectangles):

    result = mx = 0
    for l, w in rectangles:
        side = min(l, w)
        if side > mx:
            result, mx = 1, side
        elif side == mx:
            result += 1
    return result


import heapq


class Solution(object):
    def countRestrictedPaths(self, n, edges):

    MOD = 10 ** 9 + 7
    adj = [[] for _ in xrange(n)]
    for u, v, w in edges:
        adj[u - 1].append((v - 1, w))
        adj[v - 1].append((u - 1, w))
    dist = [float("inf")] * n
    dp = [0] * n
    dist[n - 1] = 0
    dp[n - 1] = 1
    min_heap = [(0, n - 1)]
    while min_heap:
        w, u = heapq.heappop(min_heap)
        if w > dist[u]:
            continue
        for v, d in adj[u]:
            if w + d < dist[v]:
                dist[v] = w + d
                heapq.heappush(min_heap, (dist[v], v))
            elif w > dist[v]:
                dp[u] = (dp[u] + dp[v]) % MOD
        if u == 0:
            break
    return dp[0]


class Solution(object):
    def countSegments(self, s):

    result = int(len(s) and s[-1] != " ")
    for i in xrange(1, len(s)):
        if s[i] == " " and s[i - 1] != " ":
            result += 1
    return result

    def countSegments2(self, s):

    return len([i for i in s.strip().split(" ") if i])


MOD = 10 ** 9 + 7
MAX_N = 1000
fact = [0] * (2 * MAX_N - 1 + 1)
inv = [0] * (2 * MAX_N - 1 + 1)
inv_fact = [0] * (2 * MAX_N - 1 + 1)
fact[0] = inv_fact[0] = fact[1] = inv_fact[1] = inv[1] = 1
for i in xrange(2, len(fact)):
    fact[i] = fact[i - 1] * i % MOD
    inv[i] = (
        inv[MOD % i] * (MOD - MOD // i) % MOD
    )
    inv_fact[i] = inv_fact[i - 1] * inv[i] % MOD


class Solution(object):
    def numberOfSets(self, n, k):

    def nCr(n, k, mod):
        return (fact[n] * inv_fact[n - k] % mod) * inv_fact[k] % mod

    return nCr(n + k - 1, 2 * k, MOD)


class Solution2(object):
    def numberOfSets(self, n, k):

    MOD = 10 ** 9 + 7

    def nCr(n, r):
        if n - r < r:
            return nCr(n, n - r)
        c = 1
        for k in xrange(1, r + 1):
            c *= n - k + 1
            c //= k
        return c

    return nCr(n + k - 1, 2 * k) % MOD


class Sea(object):
    def hasShips(self, topRight, bottomLeft):

    pass


class Point(object):
    def __init__(self, x, y):
    self.x = x
    self.y = y


class Solution(object):
    def countShips(self, sea, topRight, bottomLeft):

    result = 0
    if (
        topRight.x >= bottomLeft.x
        and topRight.y >= bottomLeft.y
        and sea.hasShips(topRight, bottomLeft)
    ):
        if (topRight.x, topRight.y) == (bottomLeft.x, bottomLeft.y):
            return 1
        mid_x, mid_y = (topRight.x + bottomLeft.x) // 2, (
            topRight.y + bottomLeft.y
        ) // 2
        result += self.countShips(sea, topRight, Point(mid_x + 1, mid_y + 1))
        result += self.countShips(
            sea, Point(mid_x, topRight.y), Point(bottomLeft.x, mid_y + 1)
        )
        result += self.countShips(
            sea, Point(topRight.x, mid_y), Point(mid_x + 1, bottomLeft.y)
        )
        result += self.countShips(sea, Point(mid_x, mid_y), bottomLeft)
    return result


import collections


class Solution(object):
    def numSquarefulPerms(self, A):

    def dfs(candidate, x, left, count, result):
        count[x] -= 1
        if left == 0:
            result[0] += 1
        for y in candidate[x]:
            if count[y]:
                dfs(candidate, y, left - 1, count, result)
        count[x] += 1

    count = collections.Counter(A)
    candidate = {
        i: {j for j in count if int((i + j) ** 0.5) ** 2 == i + j} for i in count
    }

    result = [0]
    for x in count:
        dfs(candidate, x, len(A) - 1, count, result)
    return result[0]


class Solution(object):
    def numSteps(self, s):

    result, carry = 0, 0
    for i in reversed(xrange(1, len(s))):
        if int(s[i]) + carry == 1:
            carry = 1
            result += 2
        else:
            result += 1
    return result + carry


class Solution(object):
    def numberOfSteps(self, num):

    result = 0
    while num:
        result += 2 if num % 2 else 1
        num //= 2
    return max(result - 1, 0)


import itertools


class Solution(object):
    def busyStudent(self, startTime, endTime, queryTime):

    return sum(s <= queryTime <= e for s, e in itertools.izip(startTime, endTime))


import collections


class Solution(object):
    def countStudents(self, students, sandwiches):

    count = collections.Counter(students)
    for i, s in enumerate(sandwiches):
        if not count[s]:
            break
        count[s] -= 1
    else:
        i = len(sandwiches)
    return len(sandwiches) - i


import itertools


class Solution(object):
    def numOfSubarrays(self, arr, k, threshold):

    result, curr = 0, sum(itertools.islice(arr, 0, k - 1))
    for i in xrange(k - 1, len(arr)):
        curr += arr[i] - (arr[i - k] if i - k >= 0 else 0)
        result += int(curr >= threshold * k)
    return result


class Solution2(object):
    def numOfSubarrays(self, arr, k, threshold):

    accu = [0]
    for x in arr:
        accu.append(accu[-1] + x)
    result = 0
    for i in xrange(len(accu) - k):
        if accu[i + k] - accu[i] >= threshold * k:
            result += 1
    return result


class Solution(object):
    def numOfSubarrays(self, arr):

    MOD = 10 ** 9 + 7
    result, accu = 0, 0
    dp = [1, 0]
    for x in arr:
        accu ^= x & 1
        dp[accu] += 1
        result = (result + dp[accu ^ 1]) % MOD
    return result


class Solution(object):
    def numSubarrayBoundedMax(self, A, L, R):

    def count(A, bound):
        result, curr = 0, 0
        for i in A:
            curr = curr + 1 if i <= bound else 0
            result += curr
        return result

    return count(A, R) - count(A, L - 1)


import collections


class Solution(object):
    def numSubmatrixSumTarget(self, matrix, target):

    if len(matrix) > len(matrix[0]):
        return self.numSubmatrixSumTarget(map(list, zip(*matrix)), target)

    for i in xrange(len(matrix)):
        for j in xrange(len(matrix[i]) - 1):
            matrix[i][j + 1] += matrix[i][j]

    result = 0
    for i in xrange(len(matrix)):
        prefix_sum = [0] * len(matrix[i])
        for j in xrange(i, len(matrix)):
            lookup = collections.defaultdict(int)
            lookup[0] = 1
            for k in xrange(len(matrix[j])):
                prefix_sum[k] += matrix[j][k]
                if prefix_sum[k] - target in lookup:
                    result += lookup[prefix_sum[k] - target]
                lookup[prefix_sum[k]] += 1
    return result


class Solution(object):
    def numSubseq(self, nums, target):

    MOD = 10 ** 9 + 7
    nums.sort()
    result = 0
    left, right = 0, len(nums) - 1
    while left <= right:
        if nums[left] + nums[right] > target:
            right -= 1
        else:
            result = (result + pow(2, right - left, MOD)) % MOD
            left += 1
    return result


class Solution(object):
    def numberOfSubstrings(self, s):

    result, left = 0, [-1] * 3
    for right, c in enumerate(s):
        left[ord(c) - ord("a")] = right
        result += min(left) + 1
    return result


class Solution2(object):
    def numberOfSubstrings(self, s):

    result, left, count = 0, 0, [0] * 3
    for right, c in enumerate(s):
        count[ord(s[right]) - ord("a")] += 1
        while all(count):
            count[ord(s[left]) - ord("a")] -= 1
            left += 1
        result += left
    return result


class Solution3(object):
    def numberOfSubstrings(self, s):

    result, right, count = 0, 0, [0] * 3
    for left, c in enumerate(s):
        while right < len(s) and not all(count):
            count[ord(s[right]) - ord("a")] += 1
            right += 1
        if all(count):
            result += (len(s) - 1) - (right - 1) + 1
        count[ord(c) - ord("a")] -= 1
    return result


class Solution(object):
    def numSub(self, s):

    MOD = 10 ** 9 + 7
    result, count = 0, 0
    for c in s:
        count = count + 1 if c == "1" else 0
        result = (result + count) % MOD
    return result


class Solution(object):
    def validSubarrays(self, nums):

    result = 0
    s = []
    for num in nums:
        while s and s[-1] > num:
            s.pop()
        s.append(num)
        result += len(s)
    return result


class Solution(object):
    def findNumOfValidWords(self, words, puzzles):

    L = 7

    def search(node, puzzle, start, first, met_first):
        result = 0
        if "_end" in node and met_first:
            result += node["_end"]
        for i in xrange(start, len(puzzle)):
            if puzzle[i] not in node:
                continue
            result += search(
                node[puzzle[i]],
                puzzle,
                i + 1,
                first,
                met_first or (puzzle[i] == first),
            )
        return result

    def _trie(): return collections.defaultdict(_trie)
    trie = _trie()
    for word in words:
        count = set(word)
        if len(count) > L:
            continue
        word = sorted(count)
        end = reduce(dict.__getitem__, word, trie)
        end["_end"] = end["_end"] + 1 if "_end" in end else 1
    result = []
    for puzzle in puzzles:
        first = puzzle[0]
        result.append(search(trie, sorted(puzzle), 0, first, False))
    return result


import collections


class Solution2(object):
    def findNumOfValidWords(self, words, puzzles):

    L = 7
    lookup = collections.defaultdict(list)
    for i in xrange(len(puzzles)):
        bits = []
        base = 1 << (ord(puzzles[i][0]) - ord("a"))
        for j in xrange(1, L):
            bits.append(ord(puzzles[i][j]) - ord("a"))
        for k in xrange(2 ** len(bits)):
            bitset = base
            for j in xrange(len(bits)):
                if k & (1 << j):
                    bitset |= 1 << bits[j]
            lookup[bitset].append(i)
    result = [0] * len(puzzles)
    for word in words:
        bitset = 0
        for c in word:
            bitset |= 1 << (ord(c) - ord("a"))
        if bitset not in lookup:
            continue
        for i in lookup[bitset]:
            result[i] += 1
    return result


class Solution(object):
    def ways(self, pizza, k):

    MOD = 10 ** 9 + 7
    prefix = [[0] * len(pizza[0]) for _ in xrange(len(pizza))]
    for j in reversed(xrange(len(pizza[0]))):
        accu = 0
        for i in reversed(xrange(len(pizza))):
            accu += int(pizza[i][j] == "A")
            prefix[i][j] = (
                prefix[i][j + 1] if (j + 1 < len(pizza[0])) else 0
            ) + accu
    dp = [[[0] * k for _ in xrange(len(pizza[0]))] for _ in xrange(len(pizza))]
    for i in reversed(xrange(len(pizza))):
        for j in reversed(xrange(len(pizza[0]))):
            dp[i][j][0] = 1
            for m in xrange(1, k):
                for n in xrange(i + 1, len(pizza)):
                    if prefix[i][j] == prefix[n][j]:
                        continue
                    if prefix[n][j] == 0:
                        break
                    dp[i][j][m] = (dp[i][j][m] + dp[n][j][m - 1]) % MOD
                for n in xrange(j + 1, len(pizza[0])):
                    if prefix[i][j] == prefix[i][n]:
                        continue
                    if prefix[i][n] == 0:
                        break
                    dp[i][j][m] = (dp[i][j][m] + dp[i][n][m - 1]) % MOD
    return dp[0][0][k - 1]


import collections


class Solution(object):
    def numWays(self, words, target):

    MOD = 10 ** 9 + 7
    dp = [0] * (len(target) + 1)
    dp[0] = 1
    for i in xrange(len(words[0])):
        count = collections.Counter(w[i] for w in words)
        for j in reversed(xrange(len(target))):
            dp[j + 1] += dp[j] * count[target[j]] % MOD
    return dp[-1] % MOD


import collections


class Solution2(object):
    def numWays(self, words, target):

    MOD = 10 ** 9 + 7

    dp = [[0] * (len(target) + 1) for _ in xrange(2)]
    for i in xrange(len(dp)):
        dp[i][0] = 1
    for i in xrange(len(words[0])):
        count = collections.Counter(w[i] for w in words)
        for j in reversed(xrange(len(target))):
            dp[(i + 1) % 2][j + 1] = (
                dp[i % 2][j + 1] + dp[i % 2][j] * count[target[j]] % MOD
            )
    return dp[(len(words[0])) % 2][-1] % MOD


import itertools


class Solution(object):
    def numOfWays(self, n):

    def matrix_expo(A, K):
        result = [[int(i == j) for j in xrange(len(A))]
                  for i in xrange(len(A))]
        while K:
            if K % 2:
                result = matrix_mult(result, A)
            A = matrix_mult(A, A)
            K /= 2
        return result

    def matrix_mult(A, B):
        ZB = zip(*B)
        return [
            [
                sum(a * b % MOD for a, b in itertools.izip(row, col)) % MOD
                for col in ZB
            ]
            for row in A
        ]

    MOD = 10 ** 9 + 7
    T = [[3, 2], [2, 2]]
    return (
        sum(matrix_mult([[6, 6]], matrix_expo(T, n - 1))[0]) % MOD
    )


class Solution2(object):
    def numOfWays(self, n):

    MOD = 10 ** 9 + 7
    aba, abc = 6, 6
    for _ in xrange(n - 1):
        aba, abc = (3 * aba % MOD + 2 * abc % MOD) % MOD, (
            2 * abc % MOD + 2 * aba % MOD
        ) % MOD
    return (aba + abc) % MOD


import collections


class Solution(object):
    def checkWays(self, pairs):

    adj = collections.defaultdict(set)
    for x, y in pairs:
        adj[x].add(y)
        adj[y].add(x)
    n, mul = len(adj), False
    lookup = set()
    for node in sorted(adj.iterkeys(), key=lambda i: len(adj[i]), reverse=True):
        lookup.add(node)
        parent = 0
        for x in adj[node]:
            if x not in lookup:
                continue
            if parent == 0 or len(adj[x]) < len(adj[parent]):
                parent = x
        if parent:
            if any(True for x in adj[node] if x != parent and x not in adj[parent]):
                return 0
            mul |= len(adj[parent]) == len(adj[node])
        elif len(adj[node]) != n - 1:
            return 0
    return 1 + mul


MAX_N = 1000
MOD = 10 ** 9 + 7
dp = [[0] * MAX_N for _ in xrange(MAX_N)]
for i in xrange(len(dp)):
    dp[i][0] = 1
    for j in xrange(1, i + 1):
    dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD


class Solution(object):
    def numOfWays(self, nums):

    def iter_dfs(nums):
        result = [0]
        stk = [[1, [nums, result]]]
        while stk:
            step, params = stk.pop()
            if step == 1:
                nums, ret = params
                if len(nums) <= 2:
                    ret[0] = 1
                    continue
                left = [v for v in nums if v < nums[0]]
                right = [v for v in nums if v > nums[0]]
                ret[0] = dp[len(left) + len(right)][len(left)]
                ret1, ret2 = [0], [0]
                stk.append([2, [ret1, ret2, ret]])
                stk.append([1, [right, ret2]])
                stk.append([1, [left, ret1]])
            elif step == 2:
                ret1, ret2, ret = params
                ret[0] = ret[0] * ret1[0] % MOD
                ret[0] = ret[0] * ret2[0] % MOD
        return result[0]

    return (iter_dfs(nums) - 1) % MOD


class Solution(object):
    def numOfWays(self, nums):

    def dfs(nums):
        if len(nums) <= 2:
            return 1
        left = [v for v in nums if v < nums[0]]
        right = [v for v in nums if v > nums[0]]
        result = dp[len(left) + len(right)][len(left)]
        result = result * dfs(left) % MOD
        result = result * dfs(right) % MOD
        return result

    return (dfs(nums) - 1) % MOD


class Solution(object):
    def numWays(self, s):

    MOD = 10 ** 9 + 7

    ones = s.count("1")
    if ones % 3:
        return 0
    ones //= 3
    if ones == 0:
        return (len(s) - 1) * (len(s) - 2) // 2 % MOD
    count = left = right = 0
    for c in s:
        if c == "1":
            count += 1
        if count == ones:
            left += 1
        elif count == 2 * ones:
            right += 1
    return left * right % MOD


class Solution(object):
    def numWays(self, steps, arrLen):

    MOD = int(1e9 + 7)
    l = min(1 + steps // 2, arrLen)
    dp = [0] * (l + 2)
    dp[1] = 1
    while steps > 0:
        steps -= 1
        new_dp = [0] * (l + 2)
        for i in xrange(1, l + 1):
            new_dp[i] = (dp[i] + dp[i - 1] + dp[i + 1]) % MOD
        dp = new_dp
    return dp[1]


class Solution(object):
    def numberWays(self, hats):

    MOD = 10 ** 9 + 7
    HAT_SIZE = 40
    hat_to_people = [[] for _ in xrange(HAT_SIZE)]
    for i in xrange(len(hats)):
        for h in hats[i]:
            hat_to_people[h - 1].append(i)
    dp = [0] * (1 << len(hats))
    dp[0] = 1
    for people in hat_to_people:
        for mask in reversed(xrange(len(dp))):
            for p in people:
                if mask & (1 << p):
                    continue
                dp[mask | (1 << p)] += dp[mask]
                dp[mask | (1 << p)] %= MOD
    return dp[-1]


import collections


class Solution(object):
    def numTriplets(self, nums1, nums2):

    def two_product(nums, i):
        count = 0
        lookup = collections.defaultdict(int)
        for num in nums:
            if i % num:
                continue
            count += lookup[i // num]
            lookup[num] += 1
        return count

    result = 0
    for num in nums1:
        result += two_product(nums2, num ** 2)
    for num in nums2:
        result += two_product(nums1, num ** 2)
    return result


class Solution(object):
    def atMostNGivenDigitSet(self, D, N):

    str_N = str(N)
    set_D = set(D)
    result = sum(len(D) ** i for i in xrange(1, len(str_N)))
    i = 0
    while i < len(str_N):
        result += sum(c < str_N[i]
                      for c in D) * (len(D) ** (len(str_N) - i - 1))
        if str_N[i] not in set_D:
            break
        i += 1
    return result + int(i == len(str_N))


class Solution(object):
    def numDupDigitsAtMostN(self, N):

    def P(m, n):
        result = 1
        while n > 0:
            result *= m - n + 1
            n -= 1
        return result

    digits = map(int, str(N + 1))
    result = 0

    for i in xrange(1, len(digits)):
        result += P(9, 1) * P(9, i - 1)

    prefix_set = set()
    for i, x in enumerate(digits):
        for y in xrange(1 if i == 0 else 0, x):
            if y in prefix_set:
                continue
            result += P(9 - i, len(digits) - i - 1)
        if x in prefix_set:
            break
        prefix_set.add(x)
    return N - result


class Solution(object):
    def numsSameConsecDiff(self, N, K):

    curr = range(10)
    for i in xrange(N - 1):
        curr = [
            x * 10 + y
            for x in curr
            for y in set([x % 10 + K, x % 10 - K])
            if x and 0 <= y < 10
        ]
    return curr


class Solution(object):
    def findOcurrences(self, text, first, second):

    result = []
    first += " "
    second += " "
    third = []
    i, j, k = 0, 0, 0
    while k < len(text):
        c = text[k]
        k += 1
        if i != len(first):
            if c == first[i]:
                i += 1
            else:
                i = 0
            continue
        if j != len(second):
            if c == second[j]:
                j += 1
            else:
                k -= j + 1
                i, j = 0, 0
            continue
        if c != " ":
            third.append(c)
            continue
        k -= len(second) + len(third) + 1
        i, j = 0, 0
        result.append("".join(third))
        third = []
    if third:
        result.append("".join(third))
    return result


class Solution(object):
    def oddEvenJumps(self, A):

    def findNext(idx):
        result = [None] * len(idx)
        stack = []
        for i in idx:
            while stack and stack[-1] < i:
                result[stack.pop()] = i
            stack.append(i)
        return result

    idx = sorted(range(len(A)), key=lambda i: A[i])
    next_higher = findNext(idx)
    idx.sort(key=lambda i: -A[i])
    next_lower = findNext(idx)

    odd, even = [False] * len(A), [False] * len(A)
    odd[-1], even[-1] = True, True
    for i in reversed(xrange(len(A) - 1)):
        if next_higher[i]:
            odd[i] = even[next_higher[i]]
        if next_lower[i]:
            even[i] = odd[next_lower[i]]
    return sum(odd)


class Solution(object):
    def oddEvenList(self, head):

    if head:
        odd_tail, cur = head, head.next
        while cur and cur.next:
            even_head = odd_tail.next
            odd_tail.next = cur.next
            odd_tail = odd_tail.next
            cur.next = odd_tail.next
            odd_tail.next = even_head
            cur = cur.next
    return head


class Solution(object):
    def isOneEditDistance(self, s, t):

    m, n = len(s), len(t)
    if m > n:
        return self.isOneEditDistance(t, s)
    if n - m > 1:
        return False

    i, shift = 0, n - m
    while i < m and s[i] == t[i]:
        i += 1
    if shift == 0:
        i += 1
    while i < m and s[i] == t[i + shift]:
        i += 1

    return i == m


class Solution(object):
    def findMaxForm(self, strs, m, n):

    dp = [[0 for _ in xrange(n + 1)] for _ in xrange(m + 1)]
    for s in strs:
        zero_count, one_count = 0, 0
        for c in s:
            if c == "0":
                zero_count += 1
            elif c == "1":
                one_count += 1

        for i in reversed(xrange(zero_count, m + 1)):
            for j in reversed(xrange(one_count, n + 1)):
                dp[i][j] = max(dp[i][j], dp[i - zero_count][j - one_count] + 1)
    return dp[m][n]


import collections
import itertools
import bisect


class TopVotedCandidate(object):
    def __init__(self, persons, times):

    lead = -1
    self.__lookup, count = [], collections.defaultdict(int)
    for t, p in itertools.izip(times, persons):
        count[p] += 1
        if count[p] >= count[lead]:
            lead = p
            self.__lookup.append((t, lead))

    def q(self, t):

    return self.__lookup[bisect.bisect(self.__lookup, (t, float("inf"))) - 1][1]


import collections
import random
import bisect


class MajorityChecker(object):
    def __init__(self, arr):

    Q, ERROR_RATE = 10000, 0.001
    self.__K = int(Q / ERROR_RATE).bit_length()
    self.__arr = arr
    self.__inv_idx = collections.defaultdict(list)
    for i, x in enumerate(self.__arr):
        self.__inv_idx[x].append(i)

    def query(self, left, right, threshold):

    def count(inv_idx, m, left, right):
        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(
            inv_idx[m], left
        )

    for _ in xrange(self.__K):
        m = self.__arr[random.randint(left, right)]
        if count(self.__inv_idx, m, left, right) >= threshold:
            return m
    return -1


import collections
import bisect


class MajorityChecker2(object):
    def __init__(self, arr):

    self.__arr = arr
    self.__inv_idx = collections.defaultdict(list)
    for i, x in enumerate(self.__arr):
        self.__inv_idx[x].append(i)
    self.__bound = int(round((len(arr) ** 0.5)))
    self.__majorities = [
        i for i, group in self.__inv_idx.iteritems() if len(group) >= self.__bound
    ]

    def query(self, left, right, threshold):

    def count(inv_idx, m, left, right):
        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(
            inv_idx[m], left
        )

    def boyer_moore_majority_vote(nums, left, right):
        m, cnt = nums[left], 1
        for i in xrange(left + 1, right + 1):
            if m == nums[i]:
                cnt += 1
            else:
                cnt -= 1
                if cnt == 0:
                    m = nums[i]
                    cnt = 1
        return m

    if right - left + 1 < self.__bound:
        m = boyer_moore_majority_vote(self.__arr, left, right)
        if count(self.__inv_idx, m, left, right) >= threshold:
            return m
    else:
        for m in self.__majorities:
            if count(self.__inv_idx, m, left, right) >= threshold:
                return m
    return -1


import functools


class SegmentTreeRecu(object):
    def __init__(self, nums, count):

    N = len(nums)
    self.__original_length = N
    self.__tree_length = 2 ** (N.bit_length() + (N & (N - 1) != 0)) - 1
    self.__tree = [-1 for _ in range(self.__tree_length)]
    self.__count = count
    self.__constructTree(nums, 0, self.__original_length - 1, 0)

    def query(self, i, j):
    return self.__queryRange(i, j, 0, self.__original_length - 1, 0)

    def __constructTree(self, nums, left, right, idx):
    if left > right:
        return
    if left == right:
        self.__tree[idx] = nums[left]
        return
    mid = left + (right - left) // 2
    self.__constructTree(nums, left, mid, idx * 2 + 1)
    self.__constructTree(nums, mid + 1, right, idx * 2 + 2)
    if (
        self.__tree[idx * 2 + 1] != -1
        and self.__count(self.__tree[idx * 2 + 1], left, right) * 2
        > right - left + 1
    ):
        self.__tree[idx] = self.__tree[idx * 2 + 1]
    elif (
        self.__tree[idx * 2 + 2] != -1
        and self.__count(self.__tree[idx * 2 + 2], left, right) * 2
        > right - left + 1
    ):
        self.__tree[idx] = self.__tree[idx * 2 + 2]

    def __queryRange(self, range_left, range_right, left, right, idx):
    if left > right:
        return (-1, -1)
    if right < range_left or left > range_right:
        return (-1, -1)
    if range_left <= left and right <= range_right:
        if self.__tree[idx] != -1:
            c = self.__count(self.__tree[idx], range_left, range_right)
            if c * 2 > range_right - range_left + 1:
                return (self.__tree[idx], c)
    else:
        mid = left + (right - left) // 2
        result = self.__queryRange(
            range_left, range_right, left, mid, idx * 2 + 1)
        if result[0] != -1:
            return result
        result = self.__queryRange(
            range_left, range_right, mid + 1, right, idx * 2 + 2
        )
        if result[0] != -1:
            return result
    return (-1, -1)


class MajorityChecker3(object):
    def __init__(self, arr):

    def count(inv_idx, m, left, right):
        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(
            inv_idx[m], left
        )

    self.__arr = arr
    self.__inv_idx = collections.defaultdict(list)
    for i, x in enumerate(self.__arr):
        self.__inv_idx[x].append(i)
    self.__segment_tree = SegmentTreeRecu(
        arr, functools.partial(count, self.__inv_idx)
    )

    def query(self, left, right, threshold):

    result = self.__segment_tree.query(left, right)
    if result[1] >= threshold:
        return result[0]
    return -1


import collections
import bisect


class MajorityChecker4(object):
    def __init__(self, arr):

    self.__arr = arr
    self.__inv_idx = collections.defaultdict(list)
    for i, x in enumerate(self.__arr):
        self.__inv_idx[x].append(i)
    self.__bucket_size = int(round((len(arr) ** 0.5)))
    self.__bucket_majorities = []
    for left in xrange(0, len(self.__arr), self.__bucket_size):
        right = min(left + self.__bucket_size - 1, len(self.__arr) - 1)
        self.__bucket_majorities.append(
            self.__boyer_moore_majority_vote(self.__arr, left, right)
        )

    def query(self, left, right, threshold):

    def count(inv_idx, m, left, right):
        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(
            inv_idx[m], left
        )

    l, r = left // self.__bucket_size, right // self.__bucket_size
    if l == r:
        m = self.__boyer_moore_majority_vote(self.__arr, left, right)
        if count(self.__inv_idx, m, left, right) >= threshold:
            return m
        return -1
    else:
        m = self.__boyer_moore_majority_vote(
            self.__arr, left, (l + 1) * self.__bucket_size - 1
        )
        if count(self.__inv_idx, m, left, right) >= threshold:
            return m
        m = self.__boyer_moore_majority_vote(
            self.__arr, r * self.__bucket_size, right
        )
        if count(self.__inv_idx, m, left, right) >= threshold:
            return m
        for i in xrange(l + 1, r):
            if (
                count(self.__inv_idx, self.__bucket_majorities[i], left, right)
                >= threshold
            ):
                return self.__bucket_majorities[i]
        return -1

    def __boyer_moore_majority_vote(self, nums, left, right):
    m, cnt = nums[left], 1
    for i in xrange(left + 1, right + 1):
        if m == nums[i]:
            cnt += 1
        else:
            cnt -= 1
            if cnt == 0:
                m = nums[i]
                cnt = 1
    return m


class StockSpanner(object):
    def __init__(self):
    self.__s = []

    def next(self, price):

    result = 1
    while self.__s and self.__s[-1][0] <= price:
        result += self.__s.pop()[1]
    self.__s.append([price, result])
    return result


class Solution(object):
    def openLock(self, deadends, target):

    dead = set(deadends)
    q = ["0000"]
    lookup = {"0000"}
    depth = 0
    while q:
        next_q = []
        for node in q:
            if node == target:
                return depth
            if node in dead:
                continue
            for i in xrange(4):
                n = int(node[i])
                for d in (-1, 1):
                    nn = (n + d) % 10
                    neighbor = node[:i] + str(nn) + node[i + 1:]
                    if neighbor not in lookup:
                        lookup.add(neighbor)
                        next_q.append(neighbor)
        q = next_q
        depth += 1
    return -1


import collections


class Solution(object):
    def minTransfers(self, transactions):

    accounts = collections.defaultdict(int)
    for transaction in transactions:
        accounts[transaction[0]] += transaction[2]
        accounts[transaction[1]] -= transaction[2]

    debts = [account for account in accounts.values() if account]

    dp = [0] * (2 ** len(debts))
    sums = [0] * (2 ** len(debts))
    for i in xrange(len(dp)):
        for j in xrange(len(debts)):
            if (i & (1 << j)) == 0:
                nxt = i | (1 << j)
                sums[nxt] = sums[i] + debts[j]
                if sums[nxt] == 0:
                    dp[nxt] = max(dp[nxt], dp[i] + 1)
                else:
                    dp[nxt] = max(dp[nxt], dp[i])
    return len(debts) - dp[-1]


class Solution(object):
    def optimalDivision(self, nums):

    if len(nums) == 1:
        return str(nums[0])
    if len(nums) == 2:
        return str(nums[0]) + "/" + str(nums[1])
    result = [str(nums[0]) + "/(" + str(nums[1])]
    for i in xrange(2, len(nums)):
        result += "/" + str(nums[i])
    result += ")"
    return "".join(result)


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.count = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[max(x_root, y_root)] = min(x_root, y_root)
    self.count -= 1
    return True


class Solution(object):
    def minCostToSupplyWater(self, n, wells, pipes):

    w = [[c, 0, i] for i, c in enumerate(wells, 1)]
    p = [[c, i, j] for i, j, c in pipes]
    result = 0
    union_find = UnionFind(n + 1)
    for c, x, y in sorted(w + p):
        if not union_find.union_set(x, y):
            continue
        result += c
        if union_find.count == 1:
            break
    return result


class Solution(object):
    def orderlyQueue(self, S, K):

    if K == 1:
        return min(S[i:] + S[:i] for i in xrange(len(S)))
    return "".join(sorted(S))


class Solution(object):
    def findPaths(self, m, n, N, x, y):

    M = 1000000000 + 7
    dp = [[[0 for _ in xrange(n)] for _ in xrange(m)] for _ in xrange(2)]
    for moves in xrange(N):
        for i in xrange(m):
            for j in xrange(n):
                dp[(moves + 1) % 2][i][j] = (
                    (
                        (1 if (i == 0) else dp[moves % 2][i - 1][j])
                        + (1 if (i == m - 1) else dp[moves % 2][i + 1][j])
                    )
                    % M
                    + (
                        (1 if (j == 0) else dp[moves % 2][i][j - 1])
                        + (1 if (j == n - 1) else dp[moves % 2][i][j + 1])
                    )
                    % M
                ) % M
    return dp[N % 2][x][y]


class Solution(object):
    def findContestMatch(self, n):

    matches = map(str, range(1, n + 1))
    while len(matches) / 2:
        matches = [
            "({},{})".format(matches[i], matches[-i - 1])
            for i in xrange(len(matches) / 2)
        ]
    return matches[0]


class Solution(object):
    def pacificAtlantic(self, matrix):

    PACIFIC, ATLANTIC = 1, 2

    def pacificAtlanticHelper(matrix, x, y, prev_height, prev_val, visited, res):
        if (
            (not 0 <= x < len(matrix))
            or (not 0 <= y < len(matrix[0]))
            or matrix[x][y] < prev_height
            or (visited[x][y] | prev_val) == visited[x][y]
        ):
            return

        visited[x][y] |= prev_val
        if visited[x][y] == (PACIFIC | ATLANTIC):
            res.append((x, y))

        for d in [(0, -1), (0, 1), (-1, 0), (1, 0)]:
            pacificAtlanticHelper(
                matrix,
                x + d[0],
                y + d[1],
                matrix[x][y],
                visited[x][y],
                visited,
                res,
            )

    if not matrix:
        return []

    res = []
    m, n = len(matrix), len(matrix[0])
    visited = [[0 for _ in xrange(n)] for _ in xrange(m)]

    for i in xrange(m):
        pacificAtlanticHelper(matrix, i, 0, float(
            "-inf"), PACIFIC, visited, res)
        pacificAtlanticHelper(
            matrix, i, n - 1, float("-inf"), ATLANTIC, visited, res
        )
    for j in xrange(n):
        pacificAtlanticHelper(matrix, 0, j, float(
            "-inf"), PACIFIC, visited, res)
        pacificAtlanticHelper(
            matrix, m - 1, j, float("-inf"), ATLANTIC, visited, res
        )

    return res


class Solution(object):
    def numWays(self, n, k):

    if n == 0:
        return 0
    elif n == 1:
        return k
    ways = [0] * 3
    ways[0] = k
    ways[1] = (k - 1) * ways[0] + k
    for i in xrange(2, n):
        ways[i % 3] = (k - 1) * (ways[(i - 1) % 3] + ways[(i - 2) % 3])
    return ways[(n - 1) % 3]


class Solution2(object):
    def numWays(self, n, k):

    if n == 0:
        return 0
    elif n == 1:
        return k
    ways = [0] * n
    ways[0] = k
    ways[1] = (k - 1) * ways[0] + k
    for i in xrange(2, n):
        ways[i] = (k - 1) * (ways[i - 1] + ways[i - 2])
    return ways[n - 1]


class Solution2(object):
    def minCostII(self, costs):

    return min(reduce(self.combine, costs)) if costs else 0

    def combine(self, tmp, house):
    smallest, k, i = min(tmp), len(tmp), tmp.index(min(tmp))
    tmp, tmp[i] = [smallest] * k, min(tmp[:i] + tmp[i + 1:])
    return map(sum, zip(tmp, house))


class Solution2(object):
    def minCostII(self, costs):

    if not costs:
        return 0

    n = len(costs)
    k = len(costs[0])
    min_cost = [costs[0], [0] * k]
    for i in xrange(1, n):
        smallest, second_smallest = float("inf"), float("inf")
        for j in xrange(k):
            if min_cost[(i - 1) % 2][j] < smallest:
                smallest, second_smallest = min_cost[(i - 1) % 2][j], smallest
            elif min_cost[(i - 1) % 2][j] < second_smallest:
                second_smallest = min_cost[(i - 1) % 2][j]
        for j in xrange(k):
            min_j = (
                smallest
                if min_cost[(i - 1) % 2][j] != smallest
                else second_smallest
            )
            min_cost[i % 2][j] = costs[i][j] + min_j

    return min(min_cost[(n - 1) % 2])


class Solution(object):
    def minCost(self, houses, cost, m, n, target):

    dp = [
        [[float("inf") for _ in xrange(n)] for _ in xrange(target)]
        for _ in xrange(2)
    ]
    for i in xrange(m):
        dp[i % 2] = [[float("inf") for _ in xrange(n)] for _ in xrange(target)]
        for j in xrange(min(target, i + 1)):
            for k in xrange(n):
                if houses[i] and houses[i] - 1 != k:
                    continue
                same = dp[(i - 1) % 2][j][k] if i - 1 >= 0 else 0
                diff = (
                    (
                        min(
                            [
                                dp[(i - 1) % 2][j - 1][nk]
                                for nk in xrange(n)
                                if nk != k
                            ]
                            or [float("inf")]
                        )
                        if j - 1 >= 0
                        else float("inf")
                    )
                    if i - 1 >= 0
                    else 0
                )
                paint = cost[i][k] if not houses[i] else 0
                dp[i % 2][j][k] = min(same, diff) + paint
    result = min(dp[(m - 1) % 2][-1])
    return result if result != float("inf") else -1


class Solution2(object):
    def minCost(self, houses, cost, m, n, target):

    dp = {(0, 0): 0}
    for i, p in enumerate(houses):
        new_dp = {}
        for nk in xrange(1, n + 1) if not p else [p]:
            for j, k in dp:
                nj = j + (k != nk)
                if nj > target:
                    continue
                new_dp[nj, nk] = min(
                    new_dp.get((nj, nk), float("inf")),
                    dp[j, k] + (cost[i][nk - 1] if nk != p else 0),
                )
        dp = new_dp
    return min([dp[j, k] for j, k in dp if j == target] or [-1])


class Solution(object):
    def minCost(self, costs):

    if not costs:
        return 0

    min_cost = [costs[0], [0, 0, 0]]

    n = len(costs)
    for i in xrange(1, n):
        min_cost[i % 2][0] = costs[i][0] + min(
            min_cost[(i - 1) % 2][1], min_cost[(i - 1) % 2][2]
        )
        min_cost[i % 2][1] = costs[i][1] + min(
            min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][2]
        )
        min_cost[i % 2][2] = costs[i][2] + min(
            min_cost[(i - 1) % 2][0], min_cost[(i - 1) % 2][1]
        )

    return min(min_cost[(n - 1) % 2])


class Solution2(object):
    def minCost(self, costs):

    if not costs:
        return 0

    n = len(costs)
    for i in xrange(1, n):
        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])
        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])
        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])

    return min(costs[n - 1])


import collections


class Solution(object):
    def numPairsDivisibleBy60(self, time):

    result = 0
    count = collections.Counter()
    for t in time:
        result += count[-t % 60]
        count[t % 60] += 1
    return result


class Solution(object):

    def isPalindrome(self, head):
    reverse, fast = None, head

    while fast and fast.next:
        fast = fast.next.next
        head.next, reverse, head = reverse, head, head.next

    tail = head.next if fast else head

    is_palindrome = True
    while reverse:
        is_palindrome = is_palindrome and reverse.val == tail.val
        reverse.next, head, reverse = head, reverse, reverse.next
        tail = tail.next

    return is_palindrome


class Solution(object):

    def isPalindrome(self, x):
    if x < 0:
        return False
    copy, reverse = x, 0

    while copy:
        reverse *= 10
        reverse += copy % 10
        copy //= 10

    return x == reverse


import collections


class Solution(object):
    def palindromePairs(self, words):

    res = []
    lookup = {}
    for i, word in enumerate(words):
        lookup[word] = i

    for i in xrange(len(words)):
        for j in xrange(len(words[i]) + 1):
            prefix = words[i][j:]
            suffix = words[i][:j]
            if (
                prefix == prefix[::-1]
                and suffix[::-1] in lookup
                and lookup[suffix[::-1]] != i
            ):
                res.append([i, lookup[suffix[::-1]]])
            if (
                j > 0
                and suffix == suffix[::-1]
                and prefix[::-1] in lookup
                and lookup[prefix[::-1]] != i
            ):
                res.append([lookup[prefix[::-1]], i])
    return res


class Solution_TLE(object):
    def palindromePairs(self, words):

    def manacher(s, P):
        def preProcess(s):
            if not s:
                return ["^", "$"]
            T = ["^"]
            for c in s:
                T += ["#", c]
            T += ["#", "$"]
            return T

        T = preProcess(s)
        center, right = 0, 0
        for i in xrange(1, len(T) - 1):
            i_mirror = 2 * center - i
            if right > i:
                P[i] = min(right - i, P[i_mirror])
            else:
                P[i] = 0
            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:
                P[i] += 1
            if i + P[i] > right:
                center, right = i, i + P[i]

    prefix, suffix = collections.defaultdict(
        list), collections.defaultdict(list)
    for i, word in enumerate(words):
        P = [0] * (2 * len(word) + 3)
        manacher(word, P)
        for j in xrange(len(P)):
            if j - P[j] == 1:
                prefix[word[(j + P[j]) / 2:]].append(i)
            if j + P[j] == len(P) - 2:
                suffix[word[: (j - P[j]) / 2]].append(i)
    res = []
    for i, word in enumerate(words):
        for j in prefix[word[::-1]]:
            if j != i:
                res.append([i, j])
        for j in suffix[word[::-1]]:
            if len(word) != len(words[j]):
                res.append([j, i])
    return res


class TrieNode(object):
    def __init__(self):
    self.word_idx = -1
    self.leaves = {}

    def insert(self, word, i):
    cur = self
    for c in word:
        if not c in cur.leaves:
            cur.leaves[c] = TrieNode()
        cur = cur.leaves[c]
    cur.word_idx = i

    def find(self, s, idx, res):
    cur = self
    for i in reversed(xrange(len(s))):
        if s[i] in cur.leaves:
            cur = cur.leaves[s[i]]
            if cur.word_idx not in (-1, idx) and self.is_palindrome(s, i - 1):
                res.append([cur.word_idx, idx])
        else:
            break

    def is_palindrome(self, s, j):
    i = 0
    while i <= j:
        if s[i] != s[j]:
            return False
        i += 1
        j -= 1
    return True


class Solution_MLE(object):
    def palindromePairs(self, words):

    res = []
    trie = TrieNode()
    for i in xrange(len(words)):
        trie.insert(words[i], i)

    for i in xrange(len(words)):
        trie.find(words[i], i, res)

    return res


class Solution(object):

    def minCut(self, s):
    lookup = [[False for j in xrange(len(s))] for i in xrange(len(s))]
    mincut = [len(s) - 1 - i for i in xrange(len(s) + 1)]

    for i in reversed(xrange(len(s))):
        for j in xrange(i, len(s)):
            if s[i] == s[j] and (j - i < 2 or lookup[i + 1][j - 1]):
                lookup[i][j] = True
                mincut[i] = min(mincut[i], mincut[j + 1] + 1)

    return mincut[0]


class Solution(object):
    def palindromePartition(self, s, k):

    dp1 = [[0] * len(s) for _ in xrange(len(s))]
    for l in xrange(1, len(s) + 1):
        for i in xrange(len(s) - l + 1):
            j = i + l - 1
            if i == j - 1:
                dp1[i][j] = 0 if s[i] == s[j] else 1
            elif i != j:
                dp1[i][j] = (
                    dp1[i + 1][j - 1] if s[i] == s[j] else dp1[i + 1][j - 1] + 1
                )

    dp2 = [[float("inf")] * len(s) for _ in xrange(2)]
    dp2[1] = dp1[0][:]
    for d in xrange(2, k + 1):
        dp2[d % 2] = [float("inf")] * len(s)
        for i in xrange(d - 1, len(s)):
            for j in xrange(d - 2, i):
                dp2[d % 2][i] = min(
                    dp2[d % 2][i], dp2[(d - 1) % 2][j] + dp1[j + 1][i]
                )
    return dp2[k % 2][len(s) - 1]


class Solution(object):
    def checkPartitioning(self, s):

    def manacher(s):
        s = "^#" + "#".join(s) + "#$"
        P = [0] * len(s)
        C, R = 0, 0
        for i in xrange(1, len(s) - 1):
            i_mirror = 2 * C - i
            if R > i:
                P[i] = min(R - i, P[i_mirror])
            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:
                P[i] += 1
            if i + P[i] > R:
                C, R = i, i + P[i]
        return P

    P = manacher(s)
    prefix, suffix = [], []
    for i in xrange(2, len(P) - 2):
        if i - 1 - P[i] == 0:
            prefix.append(i)
        if i + 1 + P[i] == len(P) - 1:
            suffix.append(i)
    for i in prefix:
        for j in suffix:
            left, right = i + 1 + P[i], j - 1 - P[j]
            if left > right:
                continue
            mid = left + (right - left) // 2
            if P[mid] >= mid - left:
                return True
    return False


class Solution2(object):
    def checkPartitioning(self, s):

    dp = [[False] * len(s) for _ in xrange(len(s))]
    for i in reversed(xrange(len(s))):
        for j in xrange(i, len(s)):
            if s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1]):
                dp[i][j] = True
    for i in xrange(1, len(s) - 1):
        if not dp[0][i - 1]:
            continue
        for j in xrange(i + 1, len(s)):
            if not dp[j][-1]:
                continue
            if dp[i][j - 1]:
                return True
    return False


class Solution(object):

    def partition(self, s):
    n = len(s)

    is_palindrome = [[0 for j in xrange(n)] for i in xrange(n)]
    for i in reversed(xrange(0, n)):
        for j in xrange(i, n):
            is_palindrome[i][j] = s[i] == s[j] and (
                (j - i < 2) or is_palindrome[i + 1][j - 1]
            )

    sub_partition = [[] for i in xrange(n)]
    for i in reversed(xrange(n)):
        for j in xrange(i, n):
            if is_palindrome[i][j]:
                if j + 1 < n:
                    for p in sub_partition[j + 1]:
                        sub_partition[i].append([s[i: j + 1]] + p)
                else:
                    sub_partition[i].append([s[i: j + 1]])

    return sub_partition[0]


class Solution2(object):

    def partition(self, s):
    result = []
    self.partitionRecu(result, [], s, 0)
    return result

    def partitionRecu(self, result, cur, s, i):
    if i == len(s):
        result.append(list(cur))
    else:
        for j in xrange(i, len(s)):
            if self.isPalindrome(s[i: j + 1]):
                cur.append(s[i: j + 1])
                self.partitionRecu(result, cur, s, j + 1)
                cur.pop()

    def isPalindrome(self, s):
    for i in xrange(len(s) / 2):
        if s[i] != s[-(i + 1)]:
            return False
    return True


import collections
import itertools


class Solution(object):
    def generatePalindromes(self, s):

    cnt = collections.Counter(s)
    mid = "".join(k for k, v in cnt.iteritems() if v % 2)
    chars = "".join(k * (v / 2) for k, v in cnt.iteritems())
    return self.permuteUnique(mid, chars) if len(mid) < 2 else []

    def permuteUnique(self, mid, nums):
    result = []
    used = [False] * len(nums)
    self.permuteUniqueRecu(mid, result, used, [], nums)
    return result

    def permuteUniqueRecu(self, mid, result, used, cur, nums):
    if len(cur) == len(nums):
        half_palindrome = "".join(cur)
        result.append(half_palindrome + mid + half_palindrome[::-1])
        return
    for i in xrange(len(nums)):
        if not used[i] and not (i > 0 and nums[i - 1] == nums[i] and used[i - 1]):
            used[i] = True
            cur.append(nums[i])
            self.permuteUniqueRecu(mid, result, used, cur, nums)
            cur.pop()
            used[i] = False


class Solution2(object):
    def generatePalindromes(self, s):

    cnt = collections.Counter(s)
    mid = tuple(k for k, v in cnt.iteritems() if v % 2)
    chars = "".join(k * (v / 2) for k, v in cnt.iteritems())
    return (
        [
            "".join(half_palindrome + mid + half_palindrome[::-1])
            for half_palindrome in set(itertools.permutations(chars))
        ]
        if len(mid) < 2
        else []
    )


import collections


class Solution(object):
    def canPermutePalindrome(self, s):

    return sum(v % 2 for v in collections.Counter(s).values()) < 2


class Solution(object):
    def minimumMoves(self, arr):

    dp = [[0 for _ in xrange(len(arr) + 1)] for _ in xrange(len(arr) + 1)]
    for l in xrange(1, len(arr) + 1):
        for i in xrange(len(arr) - l + 1):
            j = i + l - 1
            if l == 1:
                dp[i][j] = 1
            else:
                dp[i][j] = 1 + dp[i + 1][j]
                if arr[i] == arr[i + 1]:
                    dp[i][j] = min(dp[i][j], 1 + dp[i + 2][j])
                for k in xrange(i + 2, j + 1):
                    if arr[i] == arr[k]:
                        dp[i][j] = min(dp[i][j], dp[i + 1]
                                       [k - 1] + dp[k + 1][j])
    return dp[0][len(arr) - 1]


class Solution(object):
    def countSubstrings(self, s):

    def manacher(s):
        s = "^#" + "#".join(s) + "#$"
        P = [0] * len(s)
        C, R = 0, 0
        for i in xrange(1, len(s) - 1):
            i_mirror = 2 * C - i
            if R > i:
                P[i] = min(R - i, P[i_mirror])
            while s[i + 1 + P[i]] == s[i - 1 - P[i]]:
                P[i] += 1
            if i + P[i] > R:
                C, R = i, i + P[i]
        return P

    return sum((max_len + 1) // 2 for max_len in manacher(s))


class BIT(object):
    def __init__(self, n):
    self.__bit = [0] * (n + 1)

    def add(self, i, val):
    i += 1
    while i < len(self.__bit):
        self.__bit[i] += val
        i += i & -i

    def query(self, i):
    i += 1
    ret = 0
    while i > 0:
        ret += self.__bit[i]
        i -= i & -i
    return ret


class Solution(object):
    def pancakeSort(self, arr):

    bit = BIT(len(arr))
    result = []
    for i in xrange(len(arr)):
        n = bit.query((arr[i] - 1) - 1)
        bit.add(arr[i] - 1, 1)
        if n == i:
            continue
        if n == 0:
            if i > 1:
                result.append(i)
            result.append(i + 1)
        else:
            if n > 1:
                result.append(n)
            result.append(i)
            result.append(i + 1)
            result.append(n + 1)
    return result


class Solution2(object):
    def pancakeSort(self, arr):

    def smallerMergeSort(idxs, start, end, counts):
        if (
            end - start <= 0
        ):
            return 0

        mid = start + (end - start) // 2
        smallerMergeSort(idxs, start, mid, counts)
        smallerMergeSort(idxs, mid + 1, end, counts)
        r = start
        tmp = []
        for i in xrange(mid + 1, end + 1):

            while r <= mid and idxs[r][0] < idxs[i][0]:
                tmp.append(idxs[r])
                r += 1
            if r <= mid:
                tmp.append(idxs[i])
            counts[idxs[i][1]] += r - start
        while r <= mid:
            tmp.append(idxs[r])
            r += 1

        idxs[start: start + len(tmp)] = tmp

    idxs = []
    smaller_counts = [0] * len(arr)
    for i, x in enumerate(arr):
        idxs.append((x, i))
    smallerMergeSort(idxs, 0, len(idxs) - 1, smaller_counts)
    result = []
    for i, n in enumerate(smaller_counts):
        if n == i:
            continue
        if n == 0:
            if i > 1:
                result.append(i)
            result.append(i + 1)
        else:
            if n > 1:
                result.append(n)
            result.append(i)
            result.append(i + 1)
            result.append(n + 1)
    return result


class Solution3(object):
    def pancakeSort(self, A):

    def reverse(l, begin, end):
        for i in xrange((end - begin) // 2):
            l[begin + i], l[end - 1 - i] = l[end - 1 - i], l[begin + i]

    result = []
    for n in reversed(xrange(1, len(A) + 1)):
        i = A.index(n)
        reverse(A, 0, i + 1)
        result.append(i + 1)
        reverse(A, 0, n)
        result.append(n)
    return result


import itertools


class Solution(object):
    def minNumberOfSemesters(self, n, dependencies, k):

    reqs = [0] * n
    for u, v in dependencies:
        reqs[v - 1] |= 1 << (u - 1)
    dp = [n] * (1 << n)
    dp[0] = 0
    for mask in xrange(1 << n):
        candidates = []
        for v in xrange(n):
            if (mask & (1 << v)) == 0 and (mask & reqs[v]) == reqs[v]:
                candidates.append(v)
        for choice in itertools.combinations(candidates, min(len(candidates), k)):
            new_mask = mask
            for v in choice:
                new_mask |= 1 << v
            dp[new_mask] = min(dp[new_mask], dp[mask] + 1)
    return dp[-1]


import collections
import heapq


class Solution_WA(object):
    def minNumberOfSemesters(self, n, dependencies, k):

    def dfs(graph, i, depths):
        if depths[i] == -1:
            depths[i] = (
                max(dfs(graph, child, depths) for child in graph[i]) + 1
                if i in graph
                else 1
            )
        return depths[i]

    degrees = [0] * n
    graph = collections.defaultdict(list)
    for u, v in dependencies:
        graph[u - 1].append(v - 1)
        degrees[v - 1] += 1
    depths = [-1] * n
    for i in xrange(n):
        dfs(graph, i, depths)
    max_heap = []
    for i in xrange(n):
        if not degrees[i]:
            heapq.heappush(max_heap, (-depths[i], i))
    result = 0
    while max_heap:
        new_q = []
        for _ in xrange(min(len(max_heap), k)):
            _, node = heapq.heappop(max_heap)
            if node not in graph:
                continue
            for child in graph[node]:
                degrees[child] -= 1
                if not degrees[child]:
                    new_q.append(child)
        result += 1
        for node in new_q:
            heapq.heappush(max_heap, (-depths[node], node))
    return result


import collections


class Solution(object):
    def minimumSemesters(self, N, relations):

    g = collections.defaultdict(list)
    in_degree = [0] * N
    for x, y in relations:
        g[x - 1].append(y - 1)
        in_degree[y - 1] += 1
    q = collections.deque([(1, i) for i in xrange(N) if not in_degree[i]])

    result = 0
    count = N
    while q:
        level, u = q.popleft()
        count -= 1
        result = level
        for v in g[u]:
            in_degree[v] -= 1
            if not in_degree[v]:
                q.append((level + 1, v))
    return result if count == 0 else -1


class Solution(object):
    def evaluate(self, expression):

    def getval(lookup, x):
        return lookup.get(x, x)

    def evaluate(tokens, lookup):
        if tokens[0] in ("add", "mult"):
            a, b = map(int, map(lambda x: getval(lookup, x), tokens[1:]))
            return str(a + b if tokens[0] == "add" else a * b)
        for i in xrange(1, len(tokens) - 1, 2):
            if tokens[i + 1]:
                lookup[tokens[i]] = getval(lookup, tokens[i + 1])
        return getval(lookup, tokens[-1])

    tokens, lookup, stk = [""], {}, []
    for c in expression:
        if c == "(":
            if tokens[0] == "let":
                evaluate(tokens, lookup)
            stk.append((tokens, dict(lookup)))
            tokens = [""]
        elif c == " ":
            tokens.append("")
        elif c == ")":
            val = evaluate(tokens, lookup)
            tokens, lookup = stk.pop()
            tokens[-1] += val
        else:
            tokens[-1] += c
    return int(tokens[0])


class Solution(object):
    def parseBoolExpr(self, expression):

    def parse(expression, i):
        if expression[i[0]] not in "&|!":
            result = expression[i[0]] == "t"
            i[0] += 1
            return result
        op = expression[i[0]]
        i[0] += 2
        stk = []
        while expression[i[0]] != ")":
            if expression[i[0]] == ",":
                i[0] += 1
                continue
            stk.append(parse(expression, i))
        i[0] += 1
        if op == "&":
            return all(stk)
        if op == "|":
            return any(stk)
        return not stk[0]

    return parse(expression, [0])


class Solution(object):
    def maxSumAfterPartitioning(self, A, K):

    W = K + 1
    dp = [0] * W
    for i in xrange(len(A)):
        curr_max = 0

        for k in xrange(1, min(K, i + 1) + 1):
            curr_max = max(curr_max, A[i - k + 1])
            dp[i % W] = max(
                dp[i % W], (dp[(i - k) % W] if i >= k else 0) + curr_max * k
            )
    return dp[(len(A) - 1) % W]


class Solution(object):
    def partitionDisjoint(self, A):

    B = A[:]
    for i in reversed(xrange(len(A) - 1)):
        B[i] = min(B[i], B[i + 1])
    p_max = 0
    for i in xrange(1, len(A)):
        p_max = max(p_max, A[i - 1])
        if p_max <= B[i]:
            return i


class Solution(object):
    def canThreePartsEqualSum(self, A):

    total = sum(A)
    if total % 3 != 0:
        return False
    parts, curr = 0, 0
    for x in A:
        curr += x
        if curr == total // 3:
            parts += 1
            curr = 0
    return parts >= 3


class Solution(object):
    def canPartition(self, nums):

    s = sum(nums)
    if s % 2:
        return False

    dp = [False] * (s / 2 + 1)
    dp[0] = True
    for num in nums:
        for i in reversed(xrange(1, len(dp))):
            if num <= i:
                dp[i] = dp[i] or dp[i - num]
    return dp[-1]


class Solution(object):
    def partitionLabels(self, S):

    lookup = {c: i for i, c in enumerate(S)}
    first, last = 0, 0
    result = []
    for i, c in enumerate(S):
        last = max(last, lookup[c])
        if i == last:
            result.append(i - first + 1)
            first = i + 1
    return result


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self:
        return "{} -> {}".format(self.val, repr(self.next))


class Solution(object):

    def partition(self, head, x):
    dummySmaller, dummyGreater = ListNode(-1), ListNode(-1)
    smaller, greater = dummySmaller, dummyGreater

    while head:
        if head.val < x:
            smaller.next = head
            smaller = smaller.next
        else:
            greater.next = head
            greater = greater.next
        head = head.next

    smaller.next = dummyGreater.next
    greater.next = None

    return dummySmaller.next


class Solution(object):
    def canPartitionKSubsets(self, nums, k):

    def dfs(nums, target, used, todo, lookup):
        if lookup[used] is None:
            targ = (todo - 1) % target + 1
            lookup[used] = any(
                dfs(nums, target, used | (1 << i), todo - num, lookup)
                for i, num in enumerate(nums)
                if ((used >> i) & 1) == 0 and num <= targ
            )
        return lookup[used]

    total = sum(nums)
    if total % k or max(nums) > total // k:
        return False
    lookup = [None] * (1 << len(nums))
    lookup[-1] = True
    return dfs(nums, total // k, 0, total, lookup)


class Solution2(object):
    def canPartitionKSubsets(self, nums, k):

    def dfs(nums, target, i, subset_sums):
        if i == len(nums):
            return True
        for k in xrange(len(subset_sums)):
            if subset_sums[k] + nums[i] > target:
                continue
            subset_sums[k] += nums[i]
            if dfs(nums, target, i + 1, subset_sums):
                return True
            subset_sums[k] -= nums[i]
            if not subset_sums[k]:
                break
        return False

    total = sum(nums)
    if total % k != 0 or max(nums) > total // k:
        return False
    nums.sort(reverse=True)
    subset_sums = [0] * k
    return dfs(nums, total // k, 0, subset_sums)


class Solution(object):
    def minPartitions(self, n):

    return int(max(n))


class Solution(object):

    def getRow(self, rowIndex):
    result = [0] * (rowIndex + 1)
    for i in xrange(rowIndex + 1):
        old = result[0] = 1
        for j in xrange(1, i + 1):
            old, result[j] = result[j], old + result[j]
    return result

    def getRow2(self, rowIndex):

    row = [1]
    for _ in range(rowIndex):
        row = [x + y for x, y in zip([0] + row, row + [0])]
    return row

    def getRow3(self, rowIndex):

    if rowIndex == 0:
        return [1]
    res = [1, 1]

    def add(nums):
        res = nums[:1]
        for i, j in enumerate(nums):
            if i < len(nums) - 1:
                res += [nums[i] + nums[i + 1]]
        res += nums[:1]
        return res

    while res[1] < rowIndex:
        res = add(res)
    return res


class Solution2(object):

    def getRow(self, rowIndex):
    result = [1]
    for i in range(1, rowIndex + 1):
        result = [1] + [result[j - 1] + result[j] for j in xrange(1, i)] + [1]
    return result


class Solution(object):

    def generate(self, numRows):
    result = []
    for i in xrange(numRows):
        result.append([])
        for j in xrange(i + 1):
            if j in (0, i):
                result[i].append(1)
            else:
                result[i].append(result[i - 1][j - 1] + result[i - 1][j])
    return result

    def generate2(self, numRows):
    if not numRows:
        return []
    res = [[1]]
    for i in range(1, numRows):
        res += [map(lambda x, y: x + y, res[-1] + [0], [0] + res[-1])]
    return res[:numRows]

    def generate3(self, numRows):

    if numRows == 0:
        return []
    if numRows == 1:
        return [[1]]
    res = [[1], [1, 1]]

    def add(nums):
        res = nums[:1]
        for i, j in enumerate(nums):
            if i < len(nums) - 1:
                res += [nums[i] + nums[i + 1]]
        res += nums[:1]
        return res

    while len(res) < numRows:
        res.extend([add(res[-1])])
    return res


class Solution(object):
    def minPatches(self, nums, n):

    patch, miss, i = 0, 1, 0
    while miss <= n:
        if i < len(nums) and nums[i] <= miss:
            miss += nums[i]
            i += 1
        else:
            miss += miss
            patch += 1

    return patch


class Solution(object):
    def isPathCrossing(self, path):

    x = y = 0
    lookup = {(0, 0)}
    for c in path:
        if c == "E":
            x += 1
        elif c == "W":
            x -= 1
        elif c == "N":
            y += 1
        elif c == "S":
            y -= 1
        if (x, y) in lookup:
            return True
        lookup.add((x, y))
    return False


class Solution(object):
    def pathInZigZagTree(self, label):

    count = 2 ** label.bit_length()
    result = []
    while label >= 1:
        result.append(label)
        label = ((count // 2) + ((count - 1) - label)) // 2
        count //= 2
    result.reverse()
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def pathSum(self, root, sum):
    return self.pathSumRecu([], [], root, sum)

    def pathSumRecu(self, result, cur, root, sum):
    if root is None:
        return result

    if root.left is None and root.right is None and root.val == sum:
        result.append(cur + [root.val])
        return result

    cur.append(root.val)
    self.pathSumRecu(result, cur, root.left, sum - root.val)
    self.pathSumRecu(result, cur, root.right, sum - root.val)
    cur.pop()
    return result


import collections


class Solution(object):
    def pathSum(self, root, sum):

    def pathSumHelper(root, curr, sum, lookup):
        if root is None:
            return 0
        curr += root.val
        result = lookup[curr - sum] if curr - sum in lookup else 0
        lookup[curr] += 1
        result += pathSumHelper(root.left, curr, sum, lookup) + pathSumHelper(
            root.right, curr, sum, lookup
        )
        lookup[curr] -= 1
        if lookup[curr] == 0:
            del lookup[curr]
        return result

    lookup = collections.defaultdict(int)
    lookup[0] = 1
    return pathSumHelper(root, 0, sum, lookup)


class Solution2(object):
    def pathSum(self, root, sum):

    def pathSumHelper(root, prev, sum):
        if root is None:
            return 0

        curr = prev + root.val
        return (
            int(curr == sum)
            + pathSumHelper(root.left, curr, sum)
            + pathSumHelper(root.right, curr, sum)
        )

    if root is None:
        return 0

    return (
        pathSumHelper(root, 0, sum)
        + self.pathSum(root.left, sum)
        + self.pathSum(root.right, sum)
    )


import collections


class Solution(object):
    def pathSum(self, nums):

    class Node(object):
        def __init__(self, num):
            self.level = num / 100 - 1
            self.i = (num % 100) / 10 - 1
            self.val = num % 10
            self.leaf = True

        def isParent(self, other):
            return self.level == other.level - 1 and self.i == other.i / 2

    if not nums:
        return 0
    result = 0
    q = collections.deque()
    dummy = Node(10)
    parent = dummy
    for num in nums:
        child = Node(num)
        while not parent.isParent(child):
            result += parent.val if parent.leaf else 0
            parent = q.popleft()
        parent.leaf = False
        child.val += parent.val
        q.append(child)
    while q:
        result += q.pop().val
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def hasPathSum(self, root, sum):
    if root is None:
        return False

    if root.left is None and root.right is None and root.val == sum:
        return True

    return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(
        root.right, sum - root.val
    )


class Solution(object):
    def getMaximumGold(self, grid):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def backtracking(grid, i, j):
        result = 0
        grid[i][j] *= -1
        for dx, dy in directions:
            ni, nj = i + dx, j + dy
            if not (
                0 <= ni < len(grid) and 0 <= nj < len(
                    grid[0]) and grid[ni][nj] > 0
            ):
                continue
            result = max(result, backtracking(grid, ni, nj))
        grid[i][j] *= -1
        return grid[i][j] + result

    result = 0
    for i in xrange(len(grid)):
        for j in xrange(len(grid[0])):
            if grid[i][j]:
                result = max(result, backtracking(grid, i, j))
    return result


class Solution(object):
    def maximumMinimumPath(self, A):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def check(A, val, r, c, lookup):
        if r == len(A) - 1 and c == len(A[0]) - 1:
            return True
        lookup.add((r, c))
        for d in directions:
            nr, nc = r + d[0], c + d[1]
            if (
                0 <= nr < len(A)
                and 0 <= nc < len(A[0])
                and (nr, nc) not in lookup
                and A[nr][nc] >= val
                and check(A, val, nr, nc, lookup)
            ):
                return True
        return False

    vals, ceil = [], min(A[0][0], A[-1][-1])
    for i in xrange(len(A)):
        for j in xrange(len(A[0])):
            if A[i][j] <= ceil:
                vals.append(A[i][j])
    vals = list(set(vals))
    vals.sort()
    left, right = 0, len(vals) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if not check(A, vals[mid], 0, 0, set()):
            right = mid - 1
        else:
            left = mid + 1
    return vals[right]


import heapq


class Solution2(object):
    def maximumMinimumPath(self, A):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    max_heap = [(-A[0][0], 0, 0)]
    lookup = set([(0, 0)])
    while max_heap:
        i, r, c = heapq.heappop(max_heap)
        if r == len(A) - 1 and c == len(A[0]) - 1:
            return -i
        for d in directions:
            nr, nc = r + d[0], c + d[1]
            if 0 <= nr < len(A) and 0 <= nc < len(A[0]) and (nr, nc) not in lookup:
                heapq.heappush(max_heap, (-min(-i, A[nr][nc]), nr, nc))
                lookup.add((nr, nc))
    return -1


import collections
import itertools
import heapq


class Solution(object):
    def maxProbability(self, n, edges, succProb, start, end):

    adj = collections.defaultdict(list)
    for (u, v), p in itertools.izip(edges, succProb):
        adj[u].append((v, p))
        adj[v].append((u, p))
    max_heap = [(-1.0, start)]
    result, lookup = collections.defaultdict(float), set()
    result[start] = 1.0
    while max_heap and len(lookup) != len(adj):
        curr, u = heapq.heappop(max_heap)
        if u in lookup:
            continue
        lookup.add(u)
        for v, w in adj[u]:
            if v in lookup:
                continue
            if v in result and result[v] >= -curr * w:
                continue
            result[v] = -curr * w
            heapq.heappush(max_heap, (-result[v], v))
    return result[end]


import heapq


class Solution(object):
    def minimumEffortPath(self, heights):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    dst = (len(heights) - 1, len(heights[0]) - 1)
    dist = [[float("inf")] * len(heights[0]) for _ in xrange(len(heights))]
    min_heap = [(0, 0, 0)]
    lookup = [[False] * len(heights[0]) for _ in xrange(len(heights))]
    while min_heap:
        d, r, c = heapq.heappop(min_heap)
        if lookup[r][c]:
            continue
        lookup[r][c] = True
        if (r, c) == dst:
            return d
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if not (
                0 <= nr < len(heights)
                and 0 <= nc < len(heights[0])
                and not lookup[nr][nc]
            ):
                continue
            nd = max(d, abs(heights[nr][nc] - heights[r][c]))
            if nd < dist[nr][nc]:
                dist[nr][nc] = nd
                heapq.heappush(min_heap, (nd, nr, nc))
    return -1


import collections


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.rank = [0] * n

    def find_set(self, x):
    stk = []
    while self.set[x] != x:
        stk.append(x)
        x = self.set[x]
    while stk:
        self.set[stk.pop()] = x
    return x

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    if self.rank[x_root] < self.rank[y_root]:
        self.set[x_root] = y_root
    elif self.rank[x_root] > self.rank[y_root]:
        self.set[y_root] = x_root
    else:
        self.set[y_root] = x_root
        self.rank[x_root] += 1
    return True


class Solution2(object):
    def minimumEffortPath(self, heights):

    def index(n, i, j):
        return i * n + j

    diffs = []
    for i in xrange(len(heights)):
        for j in xrange(len(heights[0])):
            if i > 0:
                diffs.append(
                    (
                        abs(heights[i][j] - heights[i - 1][j]),
                        index(len(heights[0]), i - 1, j),
                        index(len(heights[0]), i, j),
                    )
                )
            if j > 0:
                diffs.append(
                    (
                        abs(heights[i][j] - heights[i][j - 1]),
                        index(len(heights[0]), i, j - 1),
                        index(len(heights[0]), i, j),
                    )
                )
    diffs.sort()
    union_find = UnionFind(len(heights) * len(heights[0]))
    for d, i, j in diffs:
        if union_find.union_set(i, j):
            if union_find.find_set(
                index(len(heights[0]), 0, 0)
            ) == union_find.find_set(
                index(len(heights[0]), len(heights) - 1, len(heights[0]) - 1)
            ):
                return d
    return 0


class Solution3(object):
    def minimumEffortPath(self, heights):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def check(heights, x):
        lookup = [[False] * len(heights[0]) for _ in xrange(len(heights))]
        left, right = {(0, 0)}, {(len(heights) - 1, len(heights[0]) - 1)}
        while left:
            for r, c in left:
                lookup[r][c] = True
            new_left = set()
            for r, c in left:
                if (r, c) in right:
                    return True
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if not (
                        0 <= nr < len(heights)
                        and 0 <= nc < len(heights[0])
                        and abs(heights[nr][nc] - heights[r][c]) <= x
                        and not lookup[nr][nc]
                    ):
                        continue
                    new_left.add((nr, nc))
            left = new_left
            if len(left) > len(right):
                left, right = right, left
        return False

    left, right = 0, 10 ** 6
    while left <= right:
        mid = left + (right - left) // 2
        if check(heights, mid):
            right = mid - 1
        else:
            left = mid + 1
    return left


import collections


class Solution4(object):
    def minimumEffortPath(self, heights):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def check(heights, x):
        lookup = [[False] * len(heights[0]) for _ in xrange(len(heights))]
        q = collections.deque([(0, 0)])
        while q:
            r, c = q.popleft()
            if (r, c) == (len(heights) - 1, len(heights[0]) - 1):
                return True
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if not (
                    0 <= nr < len(heights)
                    and 0 <= nc < len(heights[0])
                    and abs(heights[nr][nc] - heights[r][c]) <= x
                    and not lookup[nr][nc]
                ):
                    continue
                lookup[nr][nc] = True
                q.append((nr, nc))
        return False

    left, right = 0, 10 ** 6
    while left <= right:
        mid = left + (right - left) // 2
        if check(heights, mid):
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution5(object):
    def minimumEffortPath(self, heights):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def check(heights, x):
        lookup = [[False] * len(heights[0]) for _ in xrange(len(heights))]
        stk = [(0, 0)]
        while stk:
            r, c = stk.pop()
            if (r, c) == (len(heights) - 1, len(heights[0]) - 1):
                return True
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if not (
                    0 <= nr < len(heights)
                    and 0 <= nc < len(heights[0])
                    and abs(heights[nr][nc] - heights[r][c]) <= x
                    and not lookup[nr][nc]
                ):
                    continue
                lookup[nr][nc] = True
                stk.append((nr, nc))
        return False

    left, right = 0, 10 ** 6
    while left <= right:
        mid = left + (right - left) // 2
        if check(heights, mid):
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution(object):
    def peakIndexInMountainArray(self, arr):

    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] > arr[mid + 1]:
            right = mid - 1
        else:
            left = mid + 1
    return left


class PeekingIterator(object):
    def __init__(self, iterator):

    self.iterator = iterator
    self.val_ = None
    self.has_next_ = iterator.hasNext()
    self.has_peeked_ = False

    def peek(self):

    if not self.has_peeked_:
        self.has_peeked_ = True
        self.val_ = self.iterator.next()
    return self.val_

    def next(self):

    self.val_ = self.peek()
    self.has_peeked_ = False
    self.has_next_ = self.iterator.hasNext()
    return self.val_

    def hasNext(self):

    return self.has_next_


class Solution(object):
    def peopleIndexes(self, favoriteCompanies):

    lookup, comps = {}, []
    for cs in favoriteCompanies:
        comps.append(set())
        for c in cs:
            if c not in lookup:
                lookup[c] = len(lookup)
            comps[-1].add(lookup[c])
    return [
        i
        for i, c1 in enumerate(comps)
        if not any(
            i != j and len(c1) < len(c2) and c1 < c2 for j, c2 in enumerate(comps)
        )
    ]


class UnionFind(object):
    def __init__(self, data):
    self.data = [set(d) for d in data]
    self.set = range(len(data))

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return
    if (
        len(self.data[x_root]) > len(self.data[y_root])
        and self.data[x_root] > self.data[y_root]
    ):
        self.set[y_root] = x_root
    elif (
        len(self.data[x_root]) < len(self.data[y_root])
        and self.data[x_root] < self.data[y_root]
    ):
        self.set[x_root] = y_root


class Solution2(object):
    def peopleIndexes(self, favoriteCompanies):

    lookup, comps = {}, []
    for cs in favoriteCompanies:
        comps.append(set())
        for c in cs:
            if c not in lookup:
                lookup[c] = len(lookup)
            comps[-1].add(lookup[c])
    union_find = UnionFind(comps)
    for i in xrange(len(comps)):
        for j in xrange(len(comps)):
            if j == i:
                continue
            union_find.union_set(i, j)
    return [x for i, x in enumerate(union_find.set) if x == i]


class Solution(object):
    def checkPerfectNumber(self, num):

    if num <= 0:
        return False

    sqrt_num = int(num ** 0.5)
    total = sum(i + num // i for i in xrange(1, sqrt_num + 1) if num % i == 0)
    if sqrt_num ** 2 == num:
        total -= sqrt_num
    return total - num == num


from collections import defaultdict


class Solution(object):
    def isRectangleCover(self, rectangles):

    left = min(rec[0] for rec in rectangles)
    bottom = min(rec[1] for rec in rectangles)
    right = max(rec[2] for rec in rectangles)
    top = max(rec[3] for rec in rectangles)

    points = defaultdict(int)
    for l, b, r, t in rectangles:
        for p, q in zip(((l, b), (r, b), (l, t), (r, t)), (1, 2, 4, 8)):
            if points[p] & q:
                return False
            points[p] |= q

    for px, py in points:
        if left < px < right or bottom < py < top:
            if points[(px, py)] not in (3, 5, 10, 12, 15):
                return False

    return True


class Solution(object):
    _num = [0]

    def numSquares(self, n):

    num = self._num
    while len(num) <= n:
        num += (min(num[-i * i]
                for i in xrange(1, int(len(num) ** 0.5 + 1))) + 1,)
    return num[n]


class Solution(object):
    def stringShift(self, s, shift):

    left_shifts = 0
    for direction, amount in shift:
        if not direction:
            left_shifts += amount
        else:
            left_shifts -= amount
    left_shifts %= len(s)
    return s[left_shifts:] + s[:left_shifts]


import collections


class Solution(object):
    def checkInclusion(self, s1, s2):

    counts = collections.Counter(s1)
    l = len(s1)
    for i in xrange(len(s2)):
        if counts[s2[i]] > 0:
            l -= 1
        counts[s2[i]] -= 1
        if l == 0:
            return True
        start = i + 1 - len(s1)
        if start >= 0:
            counts[s2[start]] += 1
            if counts[s2[start]] > 0:
                l += 1
    return False


import math


class Solution(object):
    def getPermutation(self, n, k):

    seq, k, fact = "", k - 1, math.factorial(n - 1)
    perm = [i for i in xrange(1, n + 1)]
    for i in reversed(xrange(n)):
        curr = perm[k / fact]
        seq += str(curr)
        perm.remove(curr)
        if i > 0:
            k %= fact
            fact /= i
    return seq


class Solution(object):
    def permuteUnique(self, nums):

    nums.sort()
    result = []
    used = [False] * len(nums)
    self.permuteUniqueRecu(result, used, [], nums)
    return result

    def permuteUniqueRecu(self, result, used, cur, nums):
    if len(cur) == len(nums):
        result.append(cur + [])
        return
    for i in xrange(len(nums)):
        if used[i] or (i > 0 and nums[i - 1] == nums[i] and not used[i - 1]):
            continue
        used[i] = True
        cur.append(nums[i])
        self.permuteUniqueRecu(result, used, cur, nums)
        cur.pop()
        used[i] = False


class Solution2(object):

    def permuteUnique(self, nums):
    solutions = [[]]

    for num in nums:
        next = []
        for solution in solutions:
            for i in xrange(len(solution) + 1):
                candidate = solution[:i] + [num] + solution[i:]
                if candidate not in next:
                    next.append(candidate)

        solutions = next

    return solutions


class Solution(object):

    def permute(self, num):
    result = []
    used = [False] * len(num)
    self.permuteRecu(result, used, [], num)
    return result

    def permuteRecu(self, result, used, cur, num):
    if len(cur) == len(num):
        result.append(cur[:])
        return
    for i in xrange(len(num)):
        if not used[i]:
            used[i] = True
            cur.append(num[i])
            self.permuteRecu(result, used, cur, num)
            cur.pop()
            used[i] = False


class Solution2(object):
    def permute(self, nums):

    res = []
    self.dfs(nums, [], res)
    return res

    def dfs(self, nums, path, res):
    if not nums:
        res.append(path)

    for i in xrange(len(nums)):

        self.dfs(nums[:i] + nums[i + 1:], path + [nums[i]], res)


class Solution(object):
    def maxSizeSlices(self, slices):

    def maxSizeSlicesLinear(slices, start, end):
        dp = [[0] * (len(slices) // 3 + 1) for _ in xrange(2)]
        for i in xrange(start, end):
            for j in reversed(
                xrange(1, min(((i - start + 1) - 1) //
                       2 + 1, len(slices) // 3) + 1)
            ):
                dp[i % 2][j] = max(
                    dp[(i - 1) % 2][j], dp[(i - 2) % 2][j - 1] + slices[i]
                )
        return dp[(end - 1) % 2][len(slices) // 3]

    return max(
        maxSizeSlicesLinear(slices, 0, len(slices) - 1),
        maxSizeSlicesLinear(slices, 1, len(slices)),
    )


class Solution2(object):
    def maxSizeSlices(self, slices):

    def maxSizeSlicesLinear(slices, start, end):
        dp = [[0] * (len(slices) // 3 + 1) for _ in xrange(3)]
        for i in xrange(start, end):
            for j in xrange(
                1, min(((i - start + 1) - 1) // 2 + 1, len(slices) // 3) + 1
            ):
                dp[i % 3][j] = max(
                    dp[(i - 1) % 3][j], dp[(i - 2) % 3][j - 1] + slices[i]
                )
        return dp[(end - 1) % 3][len(slices) // 3]

    return max(
        maxSizeSlicesLinear(slices, 0, len(slices) - 1),
        maxSizeSlicesLinear(slices, 1, len(slices)),
    )


class Solution(object):
    def minCostToMoveChips(self, chips):

    count = [0] * 2
    for p in chips:
        count[p % 2] += 1
    return min(count)


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):
    def plusOne(self, head):

    if not head:
        return None

    dummy = ListNode(0)
    dummy.next = head

    left, right = dummy, head
    while right.next:
        if right.val != 9:
            left = right
        right = right.next

    if right.val != 9:
        right.val += 1
    else:
        left.val += 1
        right = left.next
        while right:
            right.val = 0
            right = right.next

    return dummy if dummy.val else dummy.next


class Solution2(object):
    def plusOne(self, head):

    def reverseList(head):
        dummy = ListNode(0)
        curr = head
        while curr:
            dummy.next, curr.next, curr = curr, dummy.next, curr.next
        return dummy.next

    rev_head = reverseList(head)
    curr, carry = rev_head, 1
    while curr and carry:
        curr.val += carry
        carry = curr.val / 10
        curr.val %= 10
        if carry and curr.next is None:
            curr.next = ListNode(0)
        curr = curr.next

    return reverseList(rev_head)


class Solution(object):
    def plusOne(self, digits):

    for i in reversed(xrange(len(digits))):
        if digits[i] == 9:
            digits[i] = 0
        else:
            digits[i] += 1
            return digits
    digits[0] = 1
    digits.append(0)
    return digits


class Solution2(object):
    def plusOne(self, digits):

    result = digits[::-1]
    carry = 1
    for i in xrange(len(result)):
        result[i] += carry
        carry, result[i] = divmod(result[i], 10)
    if carry:
        result.append(carry)
    return result[::-1]


import math


class Solution(object):
    def poorPigs(self, buckets, minutesToDie, minutesToTest):

    return int(
        math.ceil(math.log(buckets) /
                  math.log(minutesToTest / minutesToDie + 1))
    )


class Node(object):
    def __init__(self, val=0, left=None, right=None, next=None):
    self.val = val
    self.left = left
    self.right = right
    self.next = next


class Solution(object):

    def connect(self, root):
    head = root
    pre = Node(0)
    cur = pre
    while root:
        while root:
            if root.left:
                cur.next = root.left
                cur = cur.next
            if root.right:
                cur.next = root.right
                cur = cur.next
            root = root.next
        root, cur = pre.next, pre
        cur.next = None
    return head


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None
    self.next = None

    def __repr__(self):
    if self is None:
        return "Nil"
    else:
        return "{} -> {}".format(self.val, repr(self.next))


class Solution(object):

    def connect(self, root):
    head = root
    while head:
        cur = head
        while cur and cur.left:
            cur.left.next = cur.right
            if cur.next:
                cur.right.next = cur.next.left
            cur = cur.next
        head = head.left


class Solution2(object):

    def connect(self, root):
    if root is None:
        return
    if root.left:
        root.left.next = root.right
    if root.right and root.next:
        root.right.next = root.next.left
    self.connect(root.left)
    self.connect(root.right)


class Solution(object):
    def largeGroupPositions(self, S):

    result = []
    i = 0
    for j in xrange(len(S)):
        if j == len(S) - 1 or S[j] != S[j + 1]:
            if j - i + 1 >= 3:
                result.append([i, j])
            i = j + 1
    return result


import collections


class Solution(object):
    def possibleBipartition(self, N, dislikes):

    adj = [[] for _ in xrange(N)]
    for u, v in dislikes:
        adj[u - 1].append(v - 1)
        adj[v - 1].append(u - 1)

    color = [0] * N
    color[0] = 1
    q = collections.deque([0])
    while q:
        cur = q.popleft()
        for nei in adj[cur]:
            if color[nei] == color[cur]:
                return False
            elif color[nei] == -color[cur]:
                continue
            color[nei] = -color[cur]
            q.append(nei)
    return True


class Solution(object):
    def pourWater(self, heights, V, K):

    for _ in xrange(V):
        best = K
        for d in (-1, 1):
            i = K
            while 0 <= i + d < len(heights) and heights[i + d] <= heights[i]:
                if heights[i + d] < heights[i]:
                    best = i + d
                i += d
            if best != K:
                break
        heights[best] += 1
    return heights


class Solution(object):
    def isPowerOfFour(self, num):

    return (
        num > 0
        and (num & (num - 1)) == 0
        and ((num & 0b01010101010101010101010101010101) == num)
    )


class Solution2(object):
    def isPowerOfFour(self, num):

    while num and not (num & 0b11):
        num >>= 2
    return num == 1


class Solution3(object):
    def isPowerOfFour(self, num):

    num = bin(num)
    return (
        True
        if num[2:].startswith("1")
        and len(num[2:]) == num.count("0")
        and num.count("0") % 2
        and "-" not in num
        else False
    )


import math


class Solution(object):
    def __init__(self):
    self.__max_log3 = int(math.log(0x7FFFFFFF) / math.log(3))
    self.__max_pow3 = 3 ** self.__max_log3

    def isPowerOfThree(self, n):

    return n > 0 and self.__max_pow3 % n == 0


class Solution2(object):
    def isPowerOfThree(self, n):
    return n > 0 and (math.log10(n) / math.log10(3)).is_integer()


class Solution(object):

    def isPowerOfTwo(self, n):
    return n > 0 and (n & (n - 1)) == 0


class Solution2(object):

    def isPowerOfTwo(self, n):
    return n > 0 and (n & ~-n) == 0


import math


class Solution(object):
    def powerfulIntegers(self, x, y, bound):

    result = set()
    log_x = int(math.floor(math.log(bound) / math.log(x))) + 1 if x != 1 else 1
    log_y = int(math.floor(math.log(bound) / math.log(y))) + 1 if y != 1 else 1
    pow_x = 1
    for i in xrange(log_x):
        pow_y = 1
        for j in xrange(log_y):
            val = pow_x + pow_y
            if val <= bound:
                result.add(val)
            pow_y *= y
        pow_x *= x
    return list(result)


class Solution(object):
    def myPow(self, x, n):

    result = 1
    abs_n = abs(n)
    while abs_n:
        if abs_n & 1:
            result *= x
        abs_n >>= 1
        x *= x

    return 1 / result if n < 0 else result


class Solution2(object):
    def myPow(self, x, n):

    if n < 0 and n != -n:
        return 1.0 / self.myPow(x, -n)
    if n == 0:
        return 1
    v = self.myPow(x, n / 2)
    if n % 2 == 0:
        return v * v
    else:
        return v * v * x


class Solution(object):
    def PredictTheWinner(self, nums):

    if len(nums) % 2 == 0 or len(nums) == 1:
        return True

    dp = [0] * len(nums)
    for i in reversed(xrange(len(nums))):
        dp[i] = nums[i]
        for j in xrange(i + 1, len(nums)):
            dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1])

    return dp[-1] >= 0


import collections


class WordFilter(object):
    def __init__(self, words):

    def _trie(): return collections.defaultdict(_trie)
    self.__trie = _trie()

    for weight, word in enumerate(words):
        word += "#"
        for i in xrange(len(word)):
            cur = self.__trie
            cur["_weight"] = weight
            for j in xrange(i, 2 * len(word) - 1):
                cur = cur[word[j % len(word)]]
                cur["_weight"] = weight

    def f(self, prefix, suffix):

    cur = self.__trie
    for letter in suffix + "#" + prefix:
        if letter not in cur:
            return -1
        cur = cur[letter]
    return cur["_weight"]


class Trie(object):
    def __init__(self):
    def _trie(): return collections.defaultdict(_trie)
    self.__trie = _trie()

    def insert(self, word, i):

    def add_word(cur, i):
        if "_words" not in cur:
            cur["_words"] = []
        cur["_words"].append(i)

    cur = self.__trie
    add_word(cur, i)
    for c in word:
        cur = cur[c]
        add_word(cur, i)

    def find(self, word):
    cur = self.__trie
    for c in word:
        if c not in cur:
            return []
        cur = cur[c]
    return cur["_words"]


class WordFilter2(object):
    def __init__(self, words):

    self.__prefix_trie = Trie()
    self.__suffix_trie = Trie()
    for i in reversed(xrange(len(words))):
        self.__prefix_trie.insert(words[i], i)
        self.__suffix_trie.insert(words[i][::-1], i)

    def f(self, prefix, suffix):

    prefix_match = self.__prefix_trie.find(prefix)
    suffix_match = self.__suffix_trie.find(suffix[::-1])
    i, j = 0, 0
    while i != len(prefix_match) and j != len(suffix_match):
        if prefix_match[i] == suffix_match[j]:
            return prefix_match[i]
        elif prefix_match[i] > suffix_match[j]:
            i += 1
        else:
            j += 1
    return -1


class Solution(object):
    def preimageSizeFZF(self, K):

    def count_of_factorial_primes(n, p):
        cnt = 0
        while n > 0:
            cnt += n // p
            n //= p
        return cnt

    p = 5
    left, right = 0, p * K
    while left <= right:
        mid = left + (right - left) // 2
        if count_of_factorial_primes(mid, p) >= K:
            right = mid - 1
        else:
            left = mid + 1
    return p if count_of_factorial_primes(left, p) == K else 0


class Solution(object):
    def prevPermOpt1(self, A):

    for left in reversed(xrange(len(A) - 1)):
        if A[left] > A[left + 1]:
            break
    else:
        return A
    right = len(A) - 1
    while A[left] <= A[right]:
        right -= 1
    while A[right - 1] == A[right]:
        right -= 1
    A[left], A[right] = A[right], A[left]
    return A


class Solution(object):
    def numPrimeArrangements(self, n):

    def count_primes(n):
        if n <= 1:
            return 0
        is_prime = [True] * ((n + 1) // 2)
        cnt = len(is_prime)
        for i in xrange(3, n + 1, 2):
            if i * i > n:
                break
            if not is_prime[i // 2]:
                continue
            for j in xrange(i * i, n + 1, 2 * i):
                if not is_prime[j // 2]:
                    continue
                cnt -= 1
                is_prime[j // 2] = False
        return cnt

    def factorial(n):
        result = 1
        for i in xrange(2, n + 1):
            result = (result * i) % MOD
        return result

    MOD = 10 ** 9 + 7
    cnt = count_primes(n)
    return factorial(cnt) * factorial(n - cnt) % MOD


class Solution(object):
    def countPrimeSetBits(self, L, R):

    def bitCount(n):
        result = 0
        while n:
            n &= n - 1
            result += 1
        return result

    primes = {2, 3, 5, 7, 11, 13, 17, 19}
    return sum(bitCount(i) in primes for i in xrange(L, R + 1))


class Solution(object):
    def primePalindrome(self, N):

    def is_prime(n):
        if n < 2 or n % 2 == 0:
            return n == 2
        return all(n % d for d in xrange(3, int(n ** 0.5) + 1, 2))

    if 8 <= N <= 11:
        return 11
    for i in xrange(10 ** (len(str(N)) // 2), 10 ** 5):
        j = int(str(i) + str(i)[-2::-1])
        if j >= N and is_prime(j):
            return j


class Solution(object):
    def printTree(self, root):

    def getWidth(root):
        if not root:
            return 0
        return 2 * max(getWidth(root.left), getWidth(root.right)) + 1

    def getHeight(root):
        if not root:
            return 0
        return max(getHeight(root.left), getHeight(root.right)) + 1

    def preorderTraversal(root, level, left, right, result):
        if not root:
            return
        mid = left + (right - left) / 2
        result[level][mid] = str(root.val)
        preorderTraversal(root.left, level + 1, left, mid - 1, result)
        preorderTraversal(root.right, level + 1, mid + 1, right, result)

    h, w = getHeight(root), getWidth(root)
    result = [[""] * w for _ in xrange(h)]
    preorderTraversal(root, 0, 0, w - 1, result)
    return result


import threading


class FooBar(object):
    def __init__(self, n):
    self.__n = n
    self.__curr = False
    self.__cv = threading.Condition()

    def foo(self, printFoo):

    for i in xrange(self.__n):
        with self.__cv:
            while self.__curr != False:
                self.__cv.wait()
            self.__curr = not self.__curr

            printFoo()
            self.__cv.notify()

    def bar(self, printBar):

    for i in xrange(self.__n):
        with self.__cv:
            while self.__curr != True:
                self.__cv.wait()
            self.__curr = not self.__curr

            printBar()
            self.__cv.notify()


import math


class Solution(object):
    def printLinkedListInReverse(self, head):

    def print_nodes(head, count):
        nodes = []
        while head and len(nodes) != count:
            nodes.append(head)
            head = head.getNext()
        for node in reversed(nodes):
            node.printValue()

    count = 0
    curr = head
    while curr:
        curr = curr.getNext()
        count += 1
    bucket_count = int(math.ceil(count ** 0.5))

    buckets = []
    count = 0
    curr = head
    while curr:
        if count % bucket_count == 0:
            buckets.append(curr)
        curr = curr.getNext()
        count += 1
    for node in reversed(buckets):
        print_nodes(node, bucket_count)


class Solution2(object):
    def printLinkedListInReverse(self, head):

    nodes = []
    while head:
        nodes.append(head)
        head = head.getNext()
    for node in reversed(nodes):
        node.printValue()


class Solution3(object):
    def printLinkedListInReverse(self, head):

    tail = None
    while head != tail:
        curr = head
        while curr.getNext() != tail:
            curr = curr.getNext()
        curr.printValue()
        tail = curr


import threading


class Foo(object):
    def __init__(self):
    self.__cv = threading.Condition()
    self.__has_first = False
    self.__has_second = False

    def first(self, printFirst):

    with self.__cv:

        printFirst()
        self.__has_first = True
        self.__cv.notifyAll()

    def second(self, printSecond):

    with self.__cv:
        while not self.__has_first:
            self.__cv.wait()

        printSecond()
        self.__has_second = True
        self.__cv.notifyAll()

    def third(self, printThird):

    with self.__cv:
        while not self.__has_second:
            self.__cv.wait()

        printThird()
        self.__cv.notifyAll()


import itertools


class Solution(object):
    def printVertically(self, s):

    return [
        "".join(c).rstrip()
        for c in itertools.izip_longest(*s.split(), fillvalue=" ")
    ]


import threading


class ZeroEvenOdd(object):
    def __init__(self, n):
    self.__n = n
    self.__curr = 0
    self.__cv = threading.Condition()

    def zero(self, printNumber):

    for i in xrange(self.__n):
        with self.__cv:
            while self.__curr % 2 != 0:
                self.__cv.wait()
            self.__curr += 1
            printNumber(0)
            self.__cv.notifyAll()

    def even(self, printNumber):

    for i in xrange(2, self.__n + 1, 2):
        with self.__cv:
            while self.__curr % 4 != 3:
                self.__cv.wait()
            self.__curr += 1
            printNumber(i)
            self.__cv.notifyAll()

    def odd(self, printNumber):

    for i in xrange(1, self.__n + 1, 2):
        with self.__cv:
            while self.__curr % 4 != 1:
                self.__cv.wait()
            self.__curr += 1
            printNumber(i)
            self.__cv.notifyAll()


class Solution(object):
    def prisonAfterNDays(self, cells, N):

    N -= max(N - 1, 0) // 14 * 14
    for i in xrange(N):
        cells = [0] + [cells[i - 1] ^ cells[i + 1]
                       ^ 1 for i in xrange(1, 7)] + [0]
    return cells


class Solution2(object):
    def prisonAfterNDays(self, cells, N):

    cells = tuple(cells)
    lookup = {}
    while N:
        lookup[cells] = N
        N -= 1
        cells = tuple(
            [0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in xrange(1, 7)] + [0]
        )
        if cells in lookup:
            assert lookup[cells] - N in (1, 7, 14)
            N %= lookup[cells] - N
            break

    while N:
        N -= 1
        cells = tuple(
            [0] + [cells[i - 1] ^ cells[i + 1] ^ 1 for i in xrange(1, 7)] + [0]
        )
    return list(cells)


import collections


class Solution(object):
    def getProbability(self, balls):

    def nCrs(n):
        c = 1
        for k in xrange(n + 1):
            yield c
            c *= n - (k + 1) + 1
            c //= k + 1

    def nCr(n, r):
        if n - r < r:
            return nCr(n, n - r)
        c = 1
        for k in xrange(1, r + 1):
            c *= n - k + 1
            c //= k
        return c

    dp = collections.defaultdict(int)
    dp[
        0, 0
    ] = 1
    for n in balls:
        new_dp = collections.defaultdict(int)
        for (ndiff, cdiff), count in dp.iteritems():
            for k, new_count in enumerate(nCrs(n)):
                new_ndiff = ndiff + (k - (n - k))
                new_cdiff = (
                    cdiff - 1 if k == 0 else (cdiff + 1 if k == n else cdiff)
                )
                new_dp[new_ndiff, new_cdiff] += count * new_count
        dp = new_dp
    total = sum(balls)
    return float(dp[0, 0]) / nCr(total, total // 2)


class Solution(object):

    def productExceptSelf(self, nums):
    if not nums:
        return []

    left_product = [1 for _ in xrange(len(nums))]
    for i in xrange(1, len(nums)):
        left_product[i] = left_product[i - 1] * nums[i - 1]

    right_product = 1
    for i in xrange(len(nums) - 2, -1, -1):
        right_product *= nums[i + 1]
        left_product[i] = left_product[i] * right_product

    return left_product


class ProductOfNumbers(object):
    def __init__(self):
    self.__accu = [1]

    def add(self, num):

    if not num:
        self.__accu = [1]
        return
    self.__accu.append(self.__accu[-1] * num)

    def getProduct(self, k):

    if len(self.__accu) <= k:
        return 0
    return self.__accu[-1] // self.__accu[-1 - k]


import itertools


class Solution(object):
    def profitableSchemes(self, G, P, group, profit):

    dp = [[0 for _ in xrange(G + 1)] for _ in xrange(P + 1)]
    dp[0][0] = 1
    for p, g in itertools.izip(profit, group):
        for i in reversed(xrange(P + 1)):
            for j in reversed(xrange(G - g + 1)):
                dp[min(i + p, P)][j + g] += dp[i][j]
    return sum(dp[P]) % (10 ** 9 + 7)


class Solution(object):
    def projectionArea(self, grid):

    result = 0
    for i in xrange(len(grid)):
        max_row, max_col = 0, 0
        for j in xrange(len(grid)):
            if grid[i][j]:
                result += 1
            max_row = max(max_row, grid[i][j])
            max_col = max(max_col, grid[j][i])
        result += max_row + max_col
    return result


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
    self.val = val
    self.left = left
    self.right = right


class Solution(object):
    def pseudoPalindromicPaths(self, root):

    result = 0
    stk = [(root, 0)]
    while stk:
        node, count = stk.pop()
        if not node:
            continue
        count ^= 1 << (node.val - 1)
        result += int(node.left == node.right and count & (count - 1) == 0)
        stk.append((node.right, count))
        stk.append((node.left, count))
    return result


class Solution2(object):
    def pseudoPalindromicPaths(self, root):

    def dfs(node, count):
        if not root:
            return 0
        count ^= 1 << (node.val - 1)
        return (
            int(node.left == node.right and count & (count - 1) == 0)
            + dfs(node.left, count)
            + dfs(node.right, count)
        )

    return dfs(root, 0)


class Solution(object):
    def pushDominoes(self, dominoes):

    force = [0] * len(dominoes)

    f = 0
    for i in xrange(len(dominoes)):
        if dominoes[i] == "R":
            f = len(dominoes)
        elif dominoes[i] == "L":
            f = 0
        else:
            f = max(f - 1, 0)
        force[i] += f

    f = 0
    for i in reversed(xrange(len(dominoes))):
        if dominoes[i] == "L":
            f = len(dominoes)
        elif dominoes[i] == "R":
            f = 0
        else:
            f = max(f - 1, 0)
        force[i] -= f

    return "".join("." if f == 0 else "R" if f > 0 else "L" for f in force)


class Solution(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):

    boxes.sort(reverse=True)
    result = 0
    for h in boxes:
        if h > warehouse[result]:
            continue
        result += 1
        if result == len(warehouse):
            break
    return result


class Solution2(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):

    boxes.sort()
    for i in xrange(1, len(warehouse)):
        warehouse[i] = min(warehouse[i], warehouse[i - 1])
    result, curr = 0, 0
    for h in reversed(warehouse):
        if boxes[curr] > h:
            continue
        result += 1
        curr += 1
        if curr == len(boxes):
            break
    return result


class Solution(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):

    boxes.sort(reverse=True)
    left, right = 0, len(warehouse) - 1
    for h in boxes:
        if h <= warehouse[left]:
            left += 1
        elif h <= warehouse[right]:
            right -= 1
        if left > right:
            break
    return left + (len(warehouse) - 1 - right)


class Solution(object):
    def pyramidTransition(self, bottom, allowed):

    def pyramidTransitionHelper(bottom, edges, lookup):
        def dfs(bottom, edges, new_bottom, idx, lookup):
            if idx == len(bottom) - 1:
                return pyramidTransitionHelper("".join(new_bottom), edges, lookup)
            for i in edges[ord(bottom[idx]) - ord("A")][
                ord(bottom[idx + 1]) - ord("A")
            ]:
                new_bottom[idx] = chr(i + ord("A"))
                if dfs(bottom, edges, new_bottom, idx + 1, lookup):
                    return True
            return False

        if len(bottom) == 1:
            return True
        if bottom in lookup:
            return False
        lookup.add(bottom)
        for i in xrange(len(bottom) - 1):
            if not edges[ord(bottom[i]) - ord("A")][ord(bottom[i + 1]) - ord("A")]:
                return False
        new_bottom = ["A"] * (len(bottom) - 1)
        return dfs(bottom, edges, new_bottom, 0, lookup)

    edges = [[[] for _ in xrange(7)] for _ in xrange(7)]
    for s in allowed:
        edges[ord(s[0]) - ord("A")][ord(s[1]) - ord("A")].append(
            ord(s[2]) - ord("A")
        )
    return pyramidTransitionHelper(bottom, edges, set())


class Node(object):
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
    self.val = val
    self.isLeaf = isLeaf
    self.topLeft = topLeft
    self.topRight = topRight
    self.bottomLeft = bottomLeft
    self.bottomRight = bottomRight


class Solution(object):
    def intersect(self, quadTree1, quadTree2):

    if quadTree1.isLeaf:
        return quadTree1 if quadTree1.val else quadTree2
    elif quadTree2.isLeaf:
        return quadTree2 if quadTree2.val else quadTree1
    topLeftNode = self.intersect(quadTree1.topLeft, quadTree2.topLeft)
    topRightNode = self.intersect(quadTree1.topRight, quadTree2.topRight)
    bottomLeftNode = self.intersect(quadTree1.bottomLeft, quadTree2.bottomLeft)
    bottomRightNode = self.intersect(
        quadTree1.bottomRight, quadTree2.bottomRight)
    if (
        topLeftNode.isLeaf
        and topRightNode.isLeaf
        and bottomLeftNode.isLeaf
        and bottomRightNode.isLeaf
        and topLeftNode.val
        == topRightNode.val
        == bottomLeftNode.val
        == bottomRightNode.val
    ):
        return Node(topLeftNode.val, True, None, None, None, None)
    return Node(
        True, False, topLeftNode, topRightNode, bottomLeftNode, bottomRightNode
    )


class Solution(object):
    def queensAttacktheKing(self, queens, king):

    dirctions = [
        (-1, 0),
        (0, 1),
        (1, 0),
        (0, -1),
        (-1, 1),
        (1, 1),
        (1, -1),
        (-1, -1),
    ]
    result = []
    lookup = {(i, j) for i, j in queens}
    for dx, dy in dirctions:
        for i in xrange(1, 8):
            x, y = king[0] + dx * i, king[1] + dy * i
            if (x, y) in lookup:
                result.append([x, y])
                break
    return result


class BIT(object):
    def __init__(self, n):
    self.__bit = [0] * n

    def add(self, i, val):
    while i < len(self.__bit):
        self.__bit[i] += val
        i += i & -i

    def sum(self, i):
    result = 0
    while i > 0:
        result += self.__bit[i]
        i -= i & -i
    return result


class Solution(object):
    def processQueries(self, queries, m):

    bit = BIT(2 * m + 1)
    lookup = {}
    for i in xrange(1, m + 1):
        bit.add(m + i, 1)
        lookup[i] = m + i
    result, curr = [], m
    for q in queries:
        i = lookup.pop(q)
        result.append(bit.sum(i - 1))
        bit.add(i, -1)
        lookup[q] = curr
        bit.add(curr, 1)
        curr -= 1
    return result


class Solution(object):
    def reconstructQueue(self, people):

    people.sort(key=lambda h_k: (-h_k[0], h_k[1]))

    blocks = [[]]
    for p in people:
        index = p[1]

        for i, block in enumerate(blocks):
            if index <= len(block):
                break
            index -= len(block)
        block.insert(index, p)

        if len(block) * len(block) > len(people):
            blocks.insert(i + 1, block[len(block) / 2:])
            del block[len(block) / 2:]

    return [p for block in blocks for p in block]


class Solution2(object):
    def reconstructQueue(self, people):

    people.sort(key=lambda h_k1: (-h_k1[0], h_k1[1]))
    result = []
    for p in people:
        result.insert(p[1], p)
    return result


import collections


class Solution(object):
    def numRabbits(self, answers):

    count = collections.Counter(answers)
    return sum(
        (((k + 1) + v - 1) // (k + 1)) * (k + 1) for k, v in count.iteritems()
    )


class Solution(object):
    def racecar(self, target):
    dp = [0] * (target + 1)
    for i in xrange(1, target + 1):

        k = i.bit_length()

        if i == 2 ** k - 1:
            dp[i] = k
            continue

        dp[i] = k + 1 + dp[2 ** k - 1 - i]

        for j in xrange(k - 1):
            dp[i] = min(dp[i], k + j + 1 + dp[i - 2 ** (k - 1) + 2 ** j])

    return dp[-1]


import random


class Solution(object):
    def __init__(self, n_rows, n_cols):

    self.__n_rows = n_rows
    self.__n_cols = n_cols
    self.__n = n_rows * n_cols
    self.__lookup = {}

    def flip(self):

    self.__n -= 1
    target = random.randint(0, self.__n)
    x = self.__lookup.get(target, target)
    self.__lookup[target] = self.__lookup.get(self.__n, self.__n)
    return divmod(x, self.__n_cols)

    def reset(self):

    self.__n = self.__n_rows * self.__n_cols
    self.__lookup = {}


from random import randint


class Solution(object):
    def __init__(self, nums):

    self.__nums = nums

    def pick(self, target):

    reservoir = -1
    n = 0
    for i in xrange(len(self.__nums)):
        if self.__nums[i] != target:
            continue
        reservoir = i if randint(1, n + 1) == 1 else reservoir
        n += 1
    return reservoir


import random


class Solution(object):
    def __init__(self, N, blacklist):

    self.__n = N - len(blacklist)
    self.__lookup = {}
    white = iter(set(range(self.__n, N)) - set(blacklist))
    for black in blacklist:
        if black < self.__n:
            self.__lookup[black] = next(white)

    def pick(self):

    index = random.randint(0, self.__n - 1)
    return self.__lookup[index] if index in self.__lookup else index


import random


class Solution2(object):
    def __init__(self, N, blacklist):

    self.__n = N - len(blacklist)
    blacklist.sort()
    self.__blacklist = blacklist

    def pick(self):

    index = random.randint(0, self.__n - 1)
    left, right = 0, len(self.__blacklist) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if index + mid < self.__blacklist[mid]:
            right = mid - 1
        else:
            left = mid + 1
    return index + left


import random
import bisect


class Solution(object):
    def __init__(self, w):

    self.__prefix_sum = list(w)
    for i in xrange(1, len(w)):
        self.__prefix_sum[i] += self.__prefix_sum[i - 1]

    def pickIndex(self):

    target = random.randint(0, self.__prefix_sum[-1] - 1)
    return bisect.bisect_right(self.__prefix_sum, target)


import random
import bisect


class Solution(object):
    def __init__(self, rects):

    self.__rects = list(rects)
    self.__prefix_sum = map(lambda x: (
        x[2] - x[0] + 1) * (x[3] - x[1] + 1), rects)
    for i in xrange(1, len(self.__prefix_sum)):
        self.__prefix_sum[i] += self.__prefix_sum[i - 1]

    def pick(self):

    target = random.randint(0, self.__prefix_sum[-1] - 1)
    left = bisect.bisect_right(self.__prefix_sum, target)
    rect = self.__rects[left]
    width, height = rect[2] - rect[0] + 1, rect[3] - rect[1] + 1
    base = self.__prefix_sum[left] - width * height
    return [rect[0] + (target - base) % width, rect[1] + (target - base) // width]


class Solution(object):
    def maxCount(self, m, n, ops):

    for op in ops:
        m = min(m, op[0])
        n = min(n, op[1])
    return m * n


class Solution(object):
    def getModifiedArray(self, length, updates):

    result = [0] * length
    for update in updates:
        result[update[0]] += update[2]
        if update[1] + 1 < length:
            result[update[1] + 1] -= update[2]

    for i in xrange(1, length):
        result[i] += result[i - 1]

    return result


import bisect


class RangeModule(object):
    def __init__(self):
    self.__intervals = []

    def addRange(self, left, right):

    tmp = []
    i = 0
    for interval in self.__intervals:
        if right < interval[0]:
            tmp.append((left, right))
            break
        elif interval[1] < left:
            tmp.append(interval)
        else:
            left = min(left, interval[0])
            right = max(right, interval[1])
        i += 1
    if i == len(self.__intervals):
        tmp.append((left, right))
    while i < len(self.__intervals):
        tmp.append(self.__intervals[i])
        i += 1
    self.__intervals = tmp

    def queryRange(self, left, right):

    i = bisect.bisect_left(self.__intervals, (left, float("inf")))
    if i:
        i -= 1
    return (
        bool(self.__intervals)
        and self.__intervals[i][0] <= left
        and right <= self.__intervals[i][1]
    )

    def removeRange(self, left, right):

    tmp = []
    for interval in self.__intervals:
        if interval[1] <= left or interval[0] >= right:
            tmp.append(interval)
        else:
            if interval[0] < left:
                tmp.append((interval[0], left))
            if right < interval[1]:
                tmp.append((right, interval[1]))
    self.__intervals = tmp


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def rangeSumBST(self, root, L, R):

    result = 0
    s = [root]
    while s:
        node = s.pop()
        if node:
            if L <= node.val <= R:
                result += node.val
            if L < node.val:
                s.append(node.left)
            if node.val < R:
                s.append(node.right)
    return result


class Solution(object):
    def rangeSum(self, nums, n, left, right):

    def countUntil(nums, target):
        result, curr, left = 0, 0, 0
        for right in xrange(len(nums)):
            curr += nums[right]
            while curr > target:
                curr -= nums[left]
                left += 1
            result += right - left + 1
        return result

    def sumUntil(nums, prefix, target):
        result, curr, total, left = 0, 0, 0, 0
        for right in xrange(len(nums)):
            curr += nums[right]
            total += nums[right] * (right - left + 1)
            while curr > target:
                curr -= nums[left]
                total -= prefix[right + 1] - prefix[(left - 1) + 1]
                left += 1
            result += total
        return result

    def sumLessOrEqualTo(prefix, nums, left, right, count):
        while left <= right:
            mid = left + (right - left) // 2
            if countUntil(nums, mid) - count >= 0:
                right = mid - 1
            else:
                left = mid + 1
        return sumUntil(nums, prefix, left) - left * (
            countUntil(nums, left) - count
        )

    MOD = 10 ** 9 + 7
    prefix = [0] * (len(nums) + 1)
    for i in xrange(len(nums)):
        prefix[i + 1] = prefix[i] + nums[i]
    m, M = min(nums), sum(nums)
    return (
        sumLessOrEqualTo(prefix, nums, m, M, right)
        - sumLessOrEqualTo(prefix, nums, m, M, left - 1)
    ) % MOD


import heapq


class Solution2(object):
    def rangeSum(self, nums, n, left, right):

    MOD = 10 ** 9 + 7
    min_heap = []
    for i, num in enumerate(nums, 1):
        heapq.heappush(min_heap, (num, i))
    result = 0
    for i in xrange(1, right + 1):
        total, j = heapq.heappop(min_heap)
        if i >= left:
            result = (result + total) % MOD
        if j + 1 <= n:
            heapq.heappush(min_heap, (total + nums[j], j + 1))
    return result


class NumMatrix(object):
    def __init__(self, matrix):

    if not matrix:
        return

    m, n = len(matrix), len(matrix[0])
    self.__sums = [[0 for _ in xrange(n + 1)] for _ in xrange(m + 1)]
    for i in xrange(1, m + 1):
        for j in xrange(1, n + 1):
            self.__sums[i][j] = (
                self.__sums[i][j - 1]
                + self.__sums[i - 1][j]
                - self.__sums[i - 1][j - 1]
                + matrix[i - 1][j - 1]
            )

    def sumRegion(self, row1, col1, row2, col2):

    return (
        self.__sums[row2 + 1][col2 + 1]
        - self.__sums[row2 + 1][col1]
        - self.__sums[row1][col2 + 1]
        + self.__sums[row1][col1]
    )


class NumMatrix(object):
    def __init__(self, matrix):

    if not matrix:
        return
    self.__matrix = matrix
    self.__bit = [
        [0] * (len(self.__matrix[0]) + 1) for _ in xrange(len(self.__matrix) + 1)
    ]
    for i in xrange(1, len(self.__bit)):
        for j in xrange(1, len(self.__bit[0])):
            self.__bit[i][j] = (
                matrix[i - 1][j - 1]
                + self.__bit[i - 1][j]
                + self.__bit[i][j - 1]
                - self.__bit[i - 1][j - 1]
            )
    for i in reversed(xrange(1, len(self.__bit))):
        for j in reversed(xrange(1, len(self.__bit[0]))):
            last_i, last_j = i - (i & -i), j - (j & -j)
            self.__bit[i][j] = (
                self.__bit[i][j]
                - self.__bit[i][last_j]
                - self.__bit[last_i][j]
                + self.__bit[last_i][last_j]
            )

    def update(self, row, col, val):

    if val - self.__matrix[row][col]:
        self.__add(row, col, val - self.__matrix[row][col])
        self.__matrix[row][col] = val

    def sumRegion(self, row1, col1, row2, col2):

    return (
        self.__sum(row2, col2)
        - self.__sum(row2, col1 - 1)
        - self.__sum(row1 - 1, col2)
        + self.__sum(row1 - 1, col1 - 1)
    )

    def __sum(self, row, col):
    row += 1
    col += 1
    ret = 0
    i = row
    while i > 0:
        j = col
        while j > 0:
            ret += self.__bit[i][j]
            j -= j & -j
        i -= i & -i
    return ret

    def __add(self, row, col, val):
    row += 1
    col += 1
    i = row
    while i <= len(self.__matrix):
        j = col
        while j <= len(self.__matrix[0]):
            self.__bit[i][j] += val
            j += j & -j
        i += i & -i


class NumArray(object):
    def __init__(self, nums):

    self.accu = [0]
    for num in nums:
        self.accu.append(self.accu[-1] + num),

    def sumRange(self, i, j):

    return self.accu[j + 1] - self.accu[i]


class NumArray(object):
    def __init__(self, nums):

    if not nums:
        return
    self.__nums = nums
    self.__bit = [0] * (len(self.__nums) + 1)
    for i in xrange(1, len(self.__bit)):
        self.__bit[i] = nums[i - 1] + self.__bit[i - 1]

    for i in reversed(xrange(1, len(self.__bit))):
        last_i = i - (i & -i)
        self.__bit[i] -= self.__bit[last_i]

    def update(self, i, val):

    if val - self.__nums[i]:
        self.__add(i, val - self.__nums[i])
        self.__nums[i] = val

    def sumRange(self, i, j):

    return self.__sum(j) - self.__sum(i - 1)

    def __sum(self, i):
    i += 1
    ret = 0
    while i > 0:
        ret += self.__bit[i]
        i -= i & -i
    return ret

    def __add(self, i, val):
    i += 1
    while i <= len(self.__nums):
        self.__bit[i] += val
        i += i & -i


class NumArray2(object):
    def __init__(
        self, nums, query_fn=lambda x, y: x + y, update_fn=lambda x, y: y, default_val=0
    ):

    N = len(nums)
    self.__original_length = N
    self.__tree_length = 2 ** (N.bit_length() + (N & (N - 1) != 0)) - 1
    self.__query_fn = query_fn
    self.__update_fn = update_fn
    self.__default_val = default_val
    self.__tree = [default_val for _ in range(self.__tree_length)]
    self.__lazy = [None for _ in range(self.__tree_length)]
    self.__constructTree(nums, 0, self.__original_length - 1, 0)

    def update(self, i, val):
    self.__updateTree(val, i, i, 0, self.__original_length - 1, 0)

    def sumRange(self, i, j):
    return self.__queryRange(i, j, 0, self.__original_length - 1, 0)

    def __constructTree(self, nums, left, right, idx):
    if left > right:
        return
    if left == right:
        self.__tree[idx] = self.__update_fn(self.__tree[idx], nums[left])
        return
    mid = left + (right - left) // 2
    self.__constructTree(nums, left, mid, idx * 2 + 1)
    self.__constructTree(nums, mid + 1, right, idx * 2 + 2)
    self.__tree[idx] = self.__query_fn(
        self.__tree[idx * 2 + 1], self.__tree[idx * 2 + 2]
    )

    def __apply(self, left, right, idx, val):
    self.__tree[idx] = self.__update_fn(self.__tree[idx], val)
    if left != right:
        self.__lazy[idx * 2 +
                    1] = self.__update_fn(self.__lazy[idx * 2 + 1], val)
        self.__lazy[idx * 2 +
                    2] = self.__update_fn(self.__lazy[idx * 2 + 2], val)

    def __updateTree(self, val, range_left, range_right, left, right, idx):
    if left > right:
        return
    if self.__lazy[idx] is not None:
        self.__apply(left, right, idx, self.__lazy[idx])
        self.__lazy[idx] = None
    if range_left > right or range_right < left:
        return
    if range_left <= left and right <= range_right:
        self.__apply(left, right, idx, val)
        return
    mid = left + (right - left) // 2
    self.__updateTree(val, range_left, range_right, left, mid, idx * 2 + 1)
    self.__updateTree(val, range_left, range_right,
                      mid + 1, right, idx * 2 + 2)
    self.__tree[idx] = self.__query_fn(
        self.__tree[idx * 2 + 1], self.__tree[idx * 2 + 2]
    )

    def __queryRange(self, range_left, range_right, left, right, idx):
    if left > right:
        return self.__default_val
    if self.__lazy[idx] is not None:
        self.__apply(left, right, idx, self.__lazy[idx])
        self.__lazy[idx] = None
    if right < range_left or left > range_right:
        return self.__default_val
    if range_left <= left and right <= range_right:
        return self.__tree[idx]
    mid = left + (right - left) // 2
    return self.__query_fn(
        self.__queryRange(range_left, range_right, left, mid, idx * 2 + 1),
        self.__queryRange(range_left, range_right,
                          mid + 1, right, idx * 2 + 2),
    )


class Solution(object):
    def rankTeams(self, votes):

    count = {v: [0] * len(votes[0]) + [v] for v in votes[0]}
    for vote in votes:
        for i, v in enumerate(vote):
            count[v][i] -= 1
    return "".join(sorted(votes[0], key=count.__getitem__))


import collections


class UnionFind(object):
    def __init__(self, n, cb):
    self.set = range(n)
    self.rank = [0] * n
    self.cb = cb

    def find_set(self, x):
    stk = []
    while self.set[x] != x:
        stk.append(x)
        x = self.set[x]
    while stk:
        self.set[stk.pop()] = x
    return x

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    if self.rank[x_root] < self.rank[y_root]:
        self.set[x_root] = y_root
        self.cb(y_root, x_root, y_root)
    elif self.rank[x_root] > self.rank[y_root]:
        self.set[y_root] = x_root
        self.cb(x_root, x_root, y_root)
    else:
        self.set[y_root] = x_root
        self.rank[x_root] += 1
        self.cb(x_root, x_root, y_root)
    return True


class Solution(object):
    def matrixRankTransform(self, matrix):

    def cb(x, y, z):
        new_rank[x] = max(new_rank[y], new_rank[z])

    lookup = collections.defaultdict(list)
    for i in xrange(len(matrix)):
        for j in xrange(len(matrix[0])):
            lookup[matrix[i][j]].append([i, j])
    rank = [0] * (len(matrix) + len(matrix[0]))
    for x in sorted(lookup):
        new_rank = rank[:]
        union_find = UnionFind(len(matrix) + len(matrix[0]), cb)
        for i, j in lookup[x]:
            union_find.union_set(i, j + len(matrix))
        for i, j in lookup[x]:
            matrix[i][j] = rank[i] = rank[j + len(matrix)] = (
                new_rank[union_find.find_set(i)] + 1
            )
    return matrix


class Solution(object):
    def arrayRankTransform(self, arr):

    return map({x: i + 1 for i, x in enumerate(sorted(set(arr)))}.get, arr)


class Solution(object):
    def canConstruct(self, ransomNote, magazine):

    counts = [0] * 26
    letters = 0

    for c in ransomNote:
        if counts[ord(c) - ord("a")] == 0:
            letters += 1
        counts[ord(c) - ord("a")] += 1

    for c in magazine:
        counts[ord(c) - ord("a")] -= 1
        if counts[ord(c) - ord("a")] == 0:
            letters -= 1
            if letters == 0:
                break

    return letters == 0


import collections


class Solution2(object):
    def canConstruct(self, ransomNote, magazine):

    return not collections.Counter(ransomNote) - collections.Counter(magazine)


import math


class Solution(object):
    def reachNumber(self, target):

    target = abs(target)
    k = int(math.ceil((-1 + math.sqrt(1 + 8 * target)) / 2))
    target -= k * (k + 1) / 2
    return k if target % 2 == 0 else k + 1 + k % 2


class Solution2(object):
    def reachNumber(self, target):

    target = abs(target)
    k = 0
    while target > 0:
        k += 1
        target -= k
    return k if target % 2 == 0 else k + 1 + k % 2


import collections
import heapq


class Solution(object):
    def reachableNodes(self, edges, M, N):

    adj = [[] for _ in xrange(N)]
    for u, v, w in edges:
        adj[u].append((v, w))
        adj[v].append((u, w))

    min_heap = [(0, 0)]
    best = collections.defaultdict(lambda: float("inf"))
    best[0] = 0
    count = collections.defaultdict(lambda: collections.defaultdict(int))
    result = 0
    while min_heap:
        curr_total, u = heapq.heappop(min_heap)
        if best[u] < curr_total:
            continue
        result += 1
        for v, w in adj[u]:
            count[u][v] = min(w, M - curr_total)
            next_total = curr_total + w + 1
            if next_total <= M and next_total < best[v]:
                best[v] = next_total
                heapq.heappush(
                    min_heap, (next_total, v)
                )

    for u, v, w in edges:
        result += min(w, count[u][v] + count[v][u])
    return result


class Solution(object):
    def reachingPoints(self, sx, sy, tx, ty):

    while tx >= sx and ty >= sy:
        if tx < ty:
            sx, sy = sy, sx
            tx, ty = ty, tx
        if ty > sy:
            tx %= ty
        else:
            return (tx - sx) % ty == 0

    return False


def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
    buf[i] = file_content[i]
    i += 1

    if len(file_content) > 4:
    file_content = file_content[4:]
    else:
    file_content = ""
    return i


class Solution(object):
    def __init__(self):
    self.__buf4 = [""] * 4
    self.__i4 = 0
    self.__n4 = 0

    def read(self, buf, n):

    i = 0
    while i < n:
        if self.__i4 < self.__n4:
            buf[i] = self.__buf4[self.__i4]
            i += 1
            self.__i4 += 1
        else:
            self.__n4 = read4(self.__buf4)
            if self.__n4:
                self.__i4 = 0
            else:
                break

    return i


def read4(buf):
    global file_content
    i = 0
    while i < len(file_content) and i < 4:
    buf[i] = file_content[i]
    i += 1

    if len(file_content) > 4:
    file_content = file_content[4:]
    else:
    file_content = ""
    return i


class Solution(object):
    def read(self, buf, n):

    read_bytes = 0
    buffer = [""] * 4
    for i in xrange((n + 4 - 1) // 4):
        size = min(read4(buffer), n - read_bytes)
        buf[read_bytes: read_bytes + size] = buffer[:size]
        read_bytes += size
    return read_bytes


class Solution(object):
    def reorderSpaces(self, text):

    text = list(text)

    space_count, word_count = 0, 0
    for i, c in enumerate(text):
        if c == " ":
            space_count += 1
        elif i == 0 or text[i - 1] == " ":
            word_count += 1

    left, i = 0, 0
    while i < len(text):
        has_word = False
        while i < len(text) and text[i] != " ":
            text[left], text[i] = text[i], text[left]
            left += 1
            i += 1
            has_word = True
        if has_word:
            left += 1
        i += 1

    equal_count = space_count // (word_count - 1) if word_count - 1 > 0 else 0
    extra_count = (
        space_count % (word_count - 1) if word_count - 1 > 0 else space_count
    )
    right, i = len(text) - 1 - extra_count, len(text) - 1
    while i >= 0:
        has_word = False
        while i >= 0 and text[i] != " ":
            text[right], text[i] = text[i], text[right]
            right -= 1
            i -= 1
            has_word = True
        if has_word:
            right -= equal_count
        i -= 1
    return "".join(text)


class Solution(object):
    def rearrangeString(self, str, k):

    cnts = [0] * 26
    for c in str:
        cnts[ord(c) - ord("a")] += 1

    sorted_cnts = []
    for i in xrange(26):
        sorted_cnts.append((cnts[i], chr(i + ord("a"))))
    sorted_cnts.sort(reverse=True)

    max_cnt = sorted_cnts[0][0]
    blocks = [[] for _ in xrange(max_cnt)]
    i = 0
    for cnt in sorted_cnts:
        for _ in xrange(cnt[0]):
            blocks[i].append(cnt[1])
            i = (i + 1) % max(cnt[0], max_cnt - 1)

    for i in xrange(max_cnt - 1):
        if len(blocks[i]) < k:
            return ""

    return "".join(map(lambda x: "".join(x), blocks))


from collections import Counter
from heapq import heappush, heappop


class Solution2(object):
    def rearrangeString(self, s, k):

    if k <= 1:
        return s

    cnts = Counter(s)
    heap = []
    for c, cnt in cnts.iteritems():
        heappush(heap, [-cnt, c])

    result = []
    while heap:
        used_cnt_chars = []
        for _ in xrange(min(k, len(s) - len(result))):
            if not heap:
                return ""
            cnt_char = heappop(heap)
            result.append(cnt_char[1])
            cnt_char[0] += 1
            if cnt_char[0] < 0:
                used_cnt_chars.append(cnt_char)
        for cnt_char in used_cnt_chars:
            heappush(heap, cnt_char)

    return "".join(result)


class Solution(object):
    def arrangeWords(self, text):

    result = text.split()
    result[0] = result[0].lower()
    result.sort(key=len)
    result[0] = result[0].title()
    return " ".join(result)


class Solution(object):
    def reconstructMatrix(self, upper, lower, colsum):

    upper_matrix, lower_matrix = [0] * len(colsum), [0] * len(colsum)
    for i in xrange(len(colsum)):
        upper_matrix[i] = int(upper > 0 and colsum[i] != 0)
        lower_matrix[i] = colsum[i] - upper_matrix[i]
        upper -= upper_matrix[i]
        lower -= lower_matrix[i]
    return [upper_matrix, lower_matrix] if upper == lower == 0 else []


import collections


class Solution(object):
    def findItinerary(self, tickets):

    def route_helper(origin, ticket_cnt, graph, ans):
        if ticket_cnt == 0:
            return True

        for i, (dest, valid) in enumerate(graph[origin]):
            if valid:
                graph[origin][i][1] = False
                ans.append(dest)
                if route_helper(dest, ticket_cnt - 1, graph, ans):
                    return ans
                ans.pop()
                graph[origin][i][1] = True
        return False

    graph = collections.defaultdict(list)
    for ticket in tickets:
        graph[ticket[0]].append([ticket[1], True])
    for k in graph.keys():
        graph[k].sort()

    origin = "JFK"
    ans = [origin]
    route_helper(origin, len(tickets), graph, ans)
    return ans


from collections import Counter


class Solution(object):
    def originalDigits(self, s):

    cnts = [
        Counter(_)
        for _ in [
            "zero",
            "one",
            "two",
            "three",
            "four",
            "five",
            "six",
            "seven",
            "eight",
            "nine",
        ]
    ]

    order = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]

    unique_chars = ["z", "o", "w", "t", "u", "f", "x", "s", "g", "n"]

    cnt = Counter(list(s))
    res = []
    for i in order:
        while cnt[unique_chars[i]] > 0:
            cnt -= cnts[i]
            res.append(i)
    res.sort()

    return "".join(map(str, res))


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def recoverFromPreorder(self, S):

    i = 0
    stack = []
    while i < len(S):
        level = 0
        while i < len(S) and S[i] == "-":
            level += 1
            i += 1
        while len(stack) > level:
            stack.pop()
        val = []
        while i < len(S) and S[i] != "-":
            val.append(S[i])
            i += 1
        node = TreeNode(int("".join(val)))
        if stack:
            if stack[-1].left is None:
                stack[-1].left = node
            else:
                stack[-1].right = node
        stack.append(node)
    return stack[0]


class Solution2(object):
    def recoverFromPreorder(self, S):

    def recoverFromPreorderHelper(S, level, i):
        j = i[0]
        while j < len(S) and S[j] == "-":
            j += 1
        if level != j - i[0]:
            return None
        i[0] = j
        while j < len(S) and S[j] != "-":
            j += 1
        node = TreeNode(int(S[i[0]: j]))
        i[0] = j
        node.left = recoverFromPreorderHelper(S, level + 1, i)
        node.right = recoverFromPreorderHelper(S, level + 1, i)
        return node

    return recoverFromPreorderHelper(S, 0, [0])


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None

    def __repr__(self):
    if self:
        serial = []
        queue = [self]

        while queue:
            cur = queue[0]

            if cur:
                serial.append(cur.val)
                queue.append(cur.left)
                queue.append(cur.right)
            else:
                serial.append("#")

            queue = queue[1:]

        while serial[-1] == "#":
            serial.pop()

        return repr(serial)

    else:
        return None


class Solution(object):

    def recoverTree(self, root):
    return self.MorrisTraversal(root)

    def MorrisTraversal(self, root):
    if root is None:
        return
    broken = [None, None]
    pre, cur = None, root

    while cur:
        if cur.left is None:
            self.detectBroken(broken, pre, cur)
            pre = cur
            cur = cur.right
        else:
            node = cur.left
            while node.right and node.right != cur:
                node = node.right

            if node.right is None:
                node.right = cur
                cur = cur.left
            else:
                self.detectBroken(broken, pre, cur)
                node.right = None
                pre = cur
                cur = cur.right

    broken[0].val, broken[1].val = broken[1].val, broken[0].val

    return root

    def detectBroken(self, broken, pre, cur):
    if pre and pre.val > cur.val:
        if broken[0] is None:
            broken[0] = pre
        broken[1] = cur


class SegmentTreeNode(object):
    def __init__(self, start, end):
    self.start, self.end = start, end
    self.total = self.count = 0
    self._left = self._right = None

    def mid(self):
    return (self.start + self.end) // 2

    def left(self):
    self._left = self._left or SegmentTreeNode(self.start, self.mid())
    return self._left

    def right(self):
    self._right = self._right or SegmentTreeNode(self.mid(), self.end)
    return self._right

    def update(self, X, i, j, val):
    if i >= j:
        return 0
    if self.start == i and self.end == j:
        self.count += val
    else:
        self.left().update(X, i, min(self.mid(), j), val)
        self.right().update(X, max(self.mid(), i), j, val)
    if self.count > 0:
        self.total = X[self.end] - X[self.start]
    else:
        self.total = self.left().total + self.right().total
    return self.total


class Solution(object):
    def rectangleArea(self, rectangles):

    OPEN, CLOSE = 1, -1
    events = []
    X = set()
    for x1, y1, x2, y2 in rectangles:
        events.append((y1, OPEN, x1, x2))
        events.append((y2, CLOSE, x1, x2))
        X.add(x1)
        X.add(x2)
    events.sort()
    X = sorted(X)
    Xi = {x: i for i, x in enumerate(X)}

    st = SegmentTreeNode(0, len(X) - 1)
    result = 0
    cur_x_sum = 0
    cur_y = events[0][0]
    for y, typ, x1, x2 in events:
        result += cur_x_sum * (y - cur_y)
        cur_x_sum = st.update(X, Xi[x1], Xi[x2], typ)
        cur_y = y
    return result % (10 ** 9 + 7)


class Solution(object):

    def computeArea(self, A, B, C, D, E, F, G, H):
    return (
        (D - B) * (C - A)
        + (G - E) * (H - F)
        - max(0, (min(C, G) - max(A, E))) * max(0, (min(D, H) - max(B, F)))
    )


class Solution(object):
    def isRectangleOverlap(self, rec1, rec2):

    def intersect(p_left, p_right, q_left, q_right):
        return max(p_left, q_left) < min(p_right, q_right)

    return intersect(rec1[0], rec1[2], rec2[0], rec2[2]) and intersect(
        rec1[1], rec1[3], rec2[1], rec2[3]
    )


import collections


class Solution(object):
    def minSetSize(self, arr):

    counting_sort = [0] * len(arr)
    count = collections.Counter(arr)
    for c in count.itervalues():
        counting_sort[c - 1] += 1
    result, total = 0, 0
    for c in reversed(xrange(len(arr))):
        if not counting_sort[c]:
            continue
        count = min(
            counting_sort[c], ((len(arr) + 1) // 2 - total - 1) // (c + 1) + 1
        )
        result += count
        total += count * (c + 1)
        if total >= (len(arr) + 1) // 2:
            break
    return result


class Solution(object):
    def maxSatisfaction(self, satisfaction):

    satisfaction.sort(reverse=True)
    result, curr = 0, 0
    for x in satisfaction:
        curr += x
        if curr <= 0:
            break
        result += curr
    return result


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    return True


class Solution(object):
    def findRedundantDirectedConnection(self, edges):

    cand1, cand2 = [], []
    parent = {}
    for edge in edges:
        if edge[1] not in parent:
            parent[edge[1]] = edge[0]
        else:
            cand1 = [parent[edge[1]], edge[1]]
            cand2 = edge

    union_find = UnionFind(len(edges) + 1)
    for edge in edges:
        if edge == cand2:
            continue
        if not union_find.union_set(*edge):
            return cand1 if cand2 else edge
    return cand2


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    return True


class Solution(object):
    def findRedundantConnection(self, edges):

    union_find = UnionFind(len(edges) + 1)
    for edge in edges:
        if not union_find.union_set(*edge):
            return edge
    return []


class Solution(object):
    def reformatDate(self, date):

    lookup = {
        "Jan": 1,
        "Feb": 2,
        "Mar": 3,
        "Apr": 4,
        "May": 5,
        "Jun": 6,
        "Jul": 7,
        "Aug": 8,
        "Sep": 9,
        "Oct": 10,
        "Nov": 11,
        "Dec": 12,
    }
    return "{:04d}-{:02d}-{:02d}".format(
        int(date[-4:]), lookup[date[-8:-5]], int(date[: date.index(" ") - 2])
    )


class Solution(object):
    def reformatNumber(self, number):

    number = list(number)
    src_len = 0
    for c in number:
        if c.isdigit():
            number[src_len] = c
            src_len += 1
    dst_len = src_len + (src_len - 1) // 3
    if dst_len > len(number):
        number.extend([0] * (dst_len - len(number)))
    while dst_len < len(number):
        number.pop()
    curr = dst_len - 1
    for l, i in enumerate(reversed(xrange(src_len)), (3 - src_len % 3) % 3):
        if l and l % 3 == 0:
            number[curr] = "-"
            curr -= 1
        number[curr] = number[i]
        curr -= 1
    if dst_len >= 3 and number[dst_len - 2] == "-":
        number[dst_len - 3], number[dst_len - 2] = (
            number[dst_len - 2],
            number[dst_len - 3],
        )
    return "".join(number)


import collections


class Solution(object):
    def reformat(self, s):

    def char_gen(start, end, count):
        for c in xrange(ord(start), ord(end) + 1):
            c = chr(c)
            for i in xrange(count[c]):
                yield c
        yield ""

    count = collections.defaultdict(int)
    alpha_cnt = 0
    for c in s:
        count[c] += 1
        if c.isalpha():
            alpha_cnt += 1
    if abs(len(s) - 2 * alpha_cnt) > 1:
        return ""

    result = []
    it1, it2 = char_gen("a", "z", count), char_gen("0", "9", count)
    if alpha_cnt < len(s) - alpha_cnt:
        it1, it2 = it2, it1
    while len(result) < len(s):
        result.append(next(it1))
        result.append(next(it2))
    return "".join(result)


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.count = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root != y_root:
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.count -= 1


class Solution(object):
    def regionsBySlashes(self, grid):

    def index(n, i, j, k):
        return (i * n + j) * 4 + k

    union_find = UnionFind(len(grid) ** 2 * 4)
    N, E, S, W = range(4)
    for i in xrange(len(grid)):
        for j in xrange(len(grid)):
            if i:
                union_find.union_set(
                    index(len(grid), i - 1, j, S), index(len(grid), i, j, N)
                )
            if j:
                union_find.union_set(
                    index(len(grid), i, j - 1, E), index(len(grid), i, j, W)
                )
            if grid[i][j] != "/":
                union_find.union_set(
                    index(len(grid), i, j, N), index(len(grid), i, j, E)
                )
                union_find.union_set(
                    index(len(grid), i, j, S), index(len(grid), i, j, W)
                )
            if grid[i][j] != "\\":
                union_find.union_set(
                    index(len(grid), i, j, W), index(len(grid), i, j, N)
                )
                union_find.union_set(
                    index(len(grid), i, j, E), index(len(grid), i, j, S)
                )
    return union_find.count


class Solution(object):

    def isMatch(self, s, p):
    k = 3
    result = [[False for j in xrange(len(p) + 1)] for i in xrange(k)]

    result[0][0] = True
    for i in xrange(2, len(p) + 1):
        if p[i - 1] == "*":
            result[0][i] = result[0][i - 2]

    for i in xrange(1, len(s) + 1):
        if i > 1:
            result[0][0] = False
        for j in xrange(1, len(p) + 1):
            if p[j - 1] != "*":
                result[i % k][j] = result[(i - 1) % k][j - 1] and (
                    s[i - 1] == p[j - 1] or p[j - 1] == "."
                )
            else:
                result[i % k][j] = result[i % k][j - 2] or (
                    result[(i - 1) % k][j]
                    and (s[i - 1] == p[j - 2] or p[j - 2] == ".")
                )

    return result[len(s) % k][len(p)]


class Solution2(object):

    def isMatch(self, s, p):
    result = [[False for j in xrange(len(p) + 1)] for i in xrange(len(s) + 1)]

    result[0][0] = True
    for i in xrange(2, len(p) + 1):
        if p[i - 1] == "*":
            result[0][i] = result[0][i - 2]

    for i in xrange(1, len(s) + 1):
        for j in xrange(1, len(p) + 1):
            if p[j - 1] != "*":
                result[i][j] = result[i - 1][j - 1] and (
                    s[i - 1] == p[j - 1] or p[j - 1] == "."
                )
            else:
                result[i][j] = result[i][j - 2] or (
                    result[i - 1][j] and (s[i - 1] ==
                                          p[j - 2] or p[j - 2] == ".")
                )

    return result[len(s)][len(p)]


class Solution3(object):

    def isMatch(self, s, p):
    p_ptr, s_ptr, last_s_ptr, last_p_ptr = 0, 0, -1, -1
    last_ptr = []
    while s_ptr < len(s):
        if (
            p_ptr < len(p)
            and (p_ptr == len(p) - 1 or p[p_ptr + 1] != "*")
            and (s_ptr < len(s) and (p[p_ptr] == s[s_ptr] or p[p_ptr] == "."))
        ):
            s_ptr += 1
            p_ptr += 1
        elif p_ptr < len(p) - 1 and (p_ptr != len(p) - 1 and p[p_ptr + 1] == "*"):
            p_ptr += 2
            last_ptr.append([s_ptr, p_ptr])
        elif last_ptr:
            [last_s_ptr, last_p_ptr] = last_ptr.pop()
            while (
                last_ptr
                and p[last_p_ptr - 2] != s[last_s_ptr]
                and p[last_p_ptr - 2] != "."
            ):
                [last_s_ptr, last_p_ptr] = last_ptr.pop()

            if p[last_p_ptr - 2] == s[last_s_ptr] or p[last_p_ptr - 2] == ".":
                last_s_ptr += 1
                s_ptr = last_s_ptr
                p_ptr = last_p_ptr
                last_ptr.append([s_ptr, p_ptr])
            else:
                return False
        else:
            return False

    while p_ptr < len(p) - 1 and p[p_ptr] == "." and p[p_ptr + 1] == "*":
        p_ptr += 2

    return p_ptr == len(p)


class Solution4(object):

    def isMatch(self, s, p):
    if not p:
        return not s

    if len(p) == 1 or p[1] != "*":
        if len(s) > 0 and (p[0] == s[0] or p[0] == "."):
            return self.isMatch(s[1:], p[1:])
        else:
            return False
    else:
        while len(s) > 0 and (p[0] == s[0] or p[0] == "."):
            if self.isMatch(s, p[2:]):
                return True
            s = s[1:]
        return self.isMatch(s, p[2:])


class Solution(object):
    def findRelativeRanks(self, nums):

    sorted_nums = sorted(nums)[::-1]
    ranks = ["Gold Medal", "Silver Medal", "Bronze Medal"] + map(
        str, range(4, len(nums) + 1)
    )
    return map(dict(zip(sorted_nums, ranks)).get, nums)


class Solution(object):
    def relativeSortArray(self, arr1, arr2):

    lookup = {v: i for i, v in enumerate(arr2)}
    return sorted(arr1, key=lambda i: lookup.get(i, len(arr2) + i))


class Solution(object):
    def newInteger(self, n):

    result, base = 0, 1
    while n > 0:
        result += (n % 9) * base
        n /= 9
        base *= 10
    return result


class Solution(object):
    def removeDuplicates(self, s, k):

    stk = [["^", 0]]
    for c in s:
        if stk[-1][0] == c:
            stk[-1][1] += 1
            if stk[-1][1] == k:
                stk.pop()
        else:
            stk.append([c, 1])
    return "".join(c * k for c, k in stk)


class Solution(object):
    def removeDuplicates(self, S):

    result = []
    for c in S:
        if result and result[-1] == c:
            result.pop()
        else:
            result.append(c)
    return "".join(result)


class Solution(object):
    def removeBoxes(self, boxes):

    def dfs(boxes, l, r, k, lookup):
        if l > r:
            return 0
        if lookup[l][r][k]:
            return lookup[l][r][k]

        ll, kk = l, k
        while l < r and boxes[l + 1] == boxes[l]:
            l += 1
            k += 1
        result = dfs(boxes, l + 1, r, 0, lookup) + (k + 1) ** 2
        for i in xrange(l + 1, r + 1):
            if boxes[i] == boxes[l]:
                result = max(
                    result,
                    dfs(boxes, l + 1, i - 1, 0, lookup)
                    + dfs(boxes, i, r, k + 1, lookup),
                )
        lookup[ll][r][kk] = result
        return result

    lookup = [
        [[0] * len(boxes) for _ in xrange(len(boxes))] for _ in xrange(len(boxes))
    ]
    return dfs(boxes, 0, len(boxes) - 1, 0, lookup)


class Solution(object):
    def removeComments(self, source):

    in_block = False
    result, newline = [], []
    for line in source:
        i = 0
        while i < len(line):
            if not in_block and i + 1 < len(line) and line[i: i + 2] == "/*":
                in_block = True
                i += 1
            elif in_block and i + 1 < len(line) and line[i: i + 2] == "*/":
                in_block = False
                i += 1
            elif not in_block and i + 1 < len(line) and line[i: i + 2] == "//":
                break
            elif not in_block:
                newline.append(line[i])
            i += 1
        if newline and not in_block:
            result.append("".join(newline))
            newline = []
    return result


class Solution(object):
    def removeCoveredIntervals(self, intervals):

    intervals.sort(key=lambda x: [x[0], -x[1]])
    result, max_right = 0, 0
    for left, right in intervals:
        result += int(right > max_right)
        max_right = max(max_right, right)
    return result


from collections import Counter


class Solution(object):
    def removeDuplicateLetters(self, s):

    remaining = Counter(s)

    in_stack, stk = set(), []
    for c in s:
        if c not in in_stack:
            while stk and stk[-1] > c and remaining[stk[-1]]:
                in_stack.remove(stk.pop())
            stk += c
            in_stack.add(c)
        remaining[c] -= 1
    return "".join(stk)


class Solution(object):

    def removeDuplicates(self, A):
    if not A:
        return 0

    last, i, same = 0, 1, False
    while i < len(A):
        if A[last] != A[i] or not same:
            same = A[last] == A[i]
            last += 1
            A[last] = A[i]
        i += 1

    return last + 1


class Solution(object):

    def removeDuplicates(self, A):
    if not A:
        return 0

    last = 0
    for i in xrange(len(A)):
        if A[last] != A[i]:
            last += 1
            A[last] = A[i]
    return last + 1


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self is None:
        return "Nil"
    else:
        return "{} -> {}".format(self.val, repr(self.next))


class Solution(object):
    def deleteDuplicates(self, head):

    dummy = ListNode(0)
    pre, cur = dummy, head
    while cur:
        if cur.next and cur.next.val == cur.val:
            val = cur.val
            while cur and cur.val == val:
                cur = cur.next
            pre.next = cur
        else:
            pre.next = cur
            pre = cur
            cur = cur.next
    return dummy.next


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):
    def deleteDuplicates(self, head):

    cur = head
    while cur:
        runner = cur.next
        while runner and runner.val == cur.val:
            runner = runner.next
        cur.next = runner
        cur = runner
    return head

    def deleteDuplicates2(self, head):

    if not head:
        return head
    if head.next:
        if head.val == head.next.val:
            head = self.deleteDuplicates2(head.next)
        else:
            head.next = self.deleteDuplicates2(head.next)
    return head


class Solution(object):

    def removeElement(self, A, elem):
    i, last = 0, len(A) - 1
    while i <= last:
        if A[i] == elem:
            A[i], A[last] = A[last], A[i]
            last -= 1
        else:
            i += 1
    return last + 1


class Solution(object):
    def removeInterval(self, intervals, toBeRemoved):

    A, B = toBeRemoved
    return [
        [x, y]
        for a, b in intervals
        for x, y in ((a, min(A, b)), (max(a, B), b))
        if x < y
    ]


class Solution(object):
    def removeInvalidParentheses(self, s):

    def findMinRemove(s):
        left_removed, right_removed = 0, 0
        for c in s:
            if c == "(":
                left_removed += 1
            elif c == ")":
                if not left_removed:
                    right_removed += 1
                else:
                    left_removed -= 1
        return (left_removed, right_removed)

    def isValid(s):
        sum = 0
        for c in s:
            if c == "(":
                sum += 1
            elif c == ")":
                sum -= 1
            if sum < 0:
                return False
        return sum == 0

    def removeInvalidParenthesesHelper(start, left_removed, right_removed):
        if left_removed == 0 and right_removed == 0:
            tmp = ""
            for i, c in enumerate(s):
                if i not in removed:
                    tmp += c
            if isValid(tmp):
                res.append(tmp)
            return

        for i in xrange(start, len(s)):
            if right_removed == 0 and left_removed > 0 and s[i] == "(":
                if i == start or s[i] != s[i - 1]:
                    removed[i] = True
                    removeInvalidParenthesesHelper(
                        i + 1, left_removed - 1, right_removed
                    )
                    del removed[i]
            elif right_removed > 0 and s[i] == ")":
                if i == start or s[i] != s[i - 1]:
                    removed[i] = True
                    removeInvalidParenthesesHelper(
                        i + 1, left_removed, right_removed - 1
                    )
                    del removed[i]

    res, removed = [], {}
    (left_removed, right_removed) = findMinRemove(s)
    removeInvalidParenthesesHelper(0, left_removed, right_removed)
    return res


class Solution(object):
    def removeKdigits(self, num, k):

    result = []
    for d in num:
        while k and result and result[-1] > d:
            result.pop()
            k -= 1
        result.append(d)
    return "".join(result).lstrip("0")[: -k or None] or "0"


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):

    def removeElements(self, head, val):
    dummy = ListNode(float("-inf"))
    dummy.next = head
    prev, curr = dummy, dummy.next

    while curr:
        if curr.val == val:
            prev.next = curr.next
        else:
            prev = curr

        curr = curr.next

    return dummy.next


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.count = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[max(x_root, y_root)] = min(x_root, y_root)
    self.count -= 1
    return True


class Solution(object):
    def maxNumEdgesToRemove(self, n, edges):

    result = 0
    union_find_a, union_find_b = UnionFind(n), UnionFind(n)
    for t, i, j in edges:
        if t != 3:
            continue
        a = union_find_a.union_set(i - 1, j - 1)
        b = union_find_b.union_set(i - 1, j - 1)
        if not a and not b:
            result += 1
    for t, i, j in edges:
        if t == 1:
            if not union_find_a.union_set(i - 1, j - 1):
                result += 1
        elif t == 2:
            if not union_find_b.union_set(i - 1, j - 1):
                result += 1
    return result if union_find_a.count == union_find_b.count == 1 else -1


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self is None:
        return "Nil"
    else:
        return "{} -> {}".format(self.val, repr(self.next))


class Solution(object):

    def removeNthFromEnd(self, head, n):
    dummy = ListNode(-1)
    dummy.next = head
    slow, fast = dummy, dummy

    for i in xrange(n):
        fast = fast.next

    while fast.next:
        slow, fast = slow.next, fast.next

    slow.next = slow.next.next

    return dummy.next


class Solution(object):
    def removeOuterParentheses(self, S):

    deep = 1
    result, cnt = [], 0
    for c in S:
        if c == "(" and cnt >= deep:
            result.append(c)
        if c == ")" and cnt > deep:
            result.append(c)
        cnt += 1 if c == "(" else -1
    return "".join(result)


class Solution(object):
    def removePalindromeSub(self, s):

    def is_palindrome(s):
        for i in xrange(len(s) // 2):
            if s[i] != s[-1 - i]:
                return False
        return True

    return 2 - is_palindrome(s) - (s == "")


import collections
import itertools


class Solution(object):
    def removeSubfolders(self, folder):

    def dfs(curr, path, result):
        if "_end" in curr:
            result.append("/" + "/".join(path))
            return
        for c in curr:
            if c == "_end":
                continue
            path.append(c)
            dfs(curr[c], path, result)
            path.pop()

    def _trie(): return collections.defaultdict(_trie)
    trie = _trie()
    for f in folder:
        f_list = f.split("/")
        reduce(
            dict.__getitem__, itertools.islice(f_list, 1, len(f_list)), trie
        ).setdefault("_end")
    result = []
    dfs(trie, [], result)
    return result


class Solution(object):
    def removeVowels(self, S):

    lookup = set("aeiou")
    return "".join(c for c in S if c not in lookup)


import collections


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None


class Solution(object):
    def removeZeroSumSublists(self, head):

    curr = dummy = ListNode(0)
    dummy.next = head
    prefix = 0
    lookup = collections.OrderedDict()
    while curr:
        prefix += curr.val
        node = lookup.get(prefix, curr)
        while prefix in lookup:
            lookup.popitem()
        lookup[prefix] = node
        node.next = curr.next
        curr = curr.next
    return dummy.next


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self:
        return "{} -> {}".format(self.val, repr(self.next))


class Solution(object):

    def reorderList(self, head):
    if head == None or head.next == None:
        return head

    fast, slow, prev = head, head, None
    while fast != None and fast.next != None:
        fast, slow, prev = fast.next.next, slow.next, slow
    current, prev.next, prev = slow, None, None

    while current != None:
        current.next, prev, current = prev, current, current.next

    l1, l2 = head, prev
    dummy = ListNode(0)
    current = dummy

    while l1 != None and l2 != None:
        current.next, current, l1 = l1, l1, l1.next
        current.next, current, l2 = l2, l2, l2.next

    return dummy.next


class Solution(object):
    def reorderLogFiles(self, logs):

    def f(log):
        i, content = log.split(" ", 1)
        return (0, content, i) if content[0].isalpha() else (1,)

    logs.sort(key=f)
    return logs


import collections


class Solution(object):
    def minReorder(self, n, connections):

    lookup, graph = set(), collections.defaultdict(list)
    for u, v in connections:
        lookup.add(u * n + v)
        graph[v].append(u)
        graph[u].append(v)
    result = 0
    stk = [(-1, 0)]
    while stk:
        parent, u = stk.pop()
        result += parent * n + u in lookup
        for v in reversed(graph[u]):
            if v == parent:
                continue
            stk.append((u, v))
    return result


import collections


class Solution2(object):
    def minReorder(self, n, connections):

    def dfs(n, lookup, graph, parent, u):
        result = parent * n + u in lookup
        for v in graph[u]:
            if v == parent:
                continue
            result += dfs(n, lookup, graph, u, v)
        return result

    lookup, graph = set(), collections.defaultdict(list)
    for u, v in connections:
        lookup.add(u * n + v)
        graph[v].append(u)
        graph[u].append(v)
    return dfs(n, lookup, graph, -1, 0)


import collections


class Solution(object):
    def reorderedPowerOf2(self, N):

    count = collections.Counter(str(N))
    return any(count == collections.Counter(str(1 << i)) for i in xrange(31))


import collections
import heapq


class Solution(object):
    def reorganizeString(self, S):

    counts = collections.Counter(S)
    if any(v > (len(S) + 1) / 2 for k, v in counts.iteritems()):
        return ""

    result = []
    max_heap = []
    for k, v in counts.iteritems():
        heapq.heappush(max_heap, (-v, k))
    while len(max_heap) > 1:
        count1, c1 = heapq.heappop(max_heap)
        count2, c2 = heapq.heappop(max_heap)
        if not result or c1 != result[-1]:
            result.extend([c1, c2])
            if count1 + 1:
                heapq.heappush(max_heap, (count1 + 1, c1))
            if count2 + 1:
                heapq.heappush(max_heap, (count2 + 1, c2))
    return "".join(result) + (max_heap[0][1] if max_heap else "")


import collections


class Solution(object):
    def findRepeatedDnaSequences(self, s):

    dict, rolling_hash, res = {}, 0, []

    for i in xrange(len(s)):
        rolling_hash = ((rolling_hash << 3) & 0x3FFFFFFF) | (ord(s[i]) & 7)
        if rolling_hash not in dict:
            dict[rolling_hash] = True
        elif dict[rolling_hash]:
            res.append(s[i - 9: i + 1])
            dict[rolling_hash] = False
    return res

    def findRepeatedDnaSequences2(self, s):

    l, r = [], []
    if len(s) < 10:
        return []
    for i in range(len(s) - 9):
        l.extend([s[i: i + 10]])
    return [k for k, v in collections.Counter(l).items() if v > 1]


class Solution(object):
    def repeatedStringMatch(self, A, B):

    def check(index):
        return all(A[(i + index) % len(A)] == c for i, c in enumerate(B))

    M, p = 10 ** 9 + 7, 113
    p_inv = pow(p, M - 2, M)
    q = (len(B) + len(A) - 1) // len(A)

    b_hash, power = 0, 1
    for c in B:
        b_hash += power * ord(c)
        b_hash %= M
        power = (power * p) % M

    a_hash, power = 0, 1
    for i in xrange(len(B)):
        a_hash += power * ord(A[i % len(A)])
        a_hash %= M
        power = (power * p) % M

    if a_hash == b_hash and check(0):
        return q

    power = (power * p_inv) % M
    for i in xrange(len(B), (q + 1) * len(A)):
        a_hash = (a_hash - ord(A[(i - len(B)) % len(A)])) * p_inv
        a_hash += power * ord(A[i % len(A)])
        a_hash %= M
        if a_hash == b_hash and check(i - len(B) + 1):
            return q if i < q * len(A) else q + 1

    return -1


class Solution(object):
    def repeatedSubstringPattern(self, str):

    def getPrefix(pattern):
        prefix = [-1] * len(pattern)
        j = -1
        for i in xrange(1, len(pattern)):
            while j > -1 and pattern[j + 1] != pattern[i]:
                j = prefix[j]
            if pattern[j + 1] == pattern[i]:
                j += 1
            prefix[i] = j
        return prefix

    prefix = getPrefix(str)
    return prefix[-1] != -1 and (prefix[-1] + 1) % (len(str) - prefix[-1] - 1) == 0

    def repeatedSubstringPattern2(self, str):

    if not str:
        return False

    ss = (str + str)[1:-1]
    return ss.find(str) != -1


class Solution(object):
    def modifyString(self, s):

    s = list(s)
    for i in xrange(len(s)):
        if s[i] != "?":
            continue
        for c in ("a", "b", "c"):
            if (i == 0 or s[i - 1] != c) and (i == len(s) - 1 or c != s[i + 1]):
                break
        s[i] = c
    return "".join(s)


class Solution(object):
    def replaceElements(self, arr):

    curr_max = -1
    for i in reversed(xrange(len(arr))):
        arr[i], curr_max = curr_max, max(curr_max, arr[i])
    return arr


import collections


class Solution(object):
    def balancedString(self, s):

    count = collections.Counter(s)
    result = len(s)
    left = 0
    for right in xrange(len(s)):
        count[s[right]] -= 1
        while left < len(s) and all(v <= len(s) // 4 for v in count.itervalues()):
            result = min(result, right - left + 1)
            count[s[left]] += 1
            left += 1
    return result


import collections


class Solution(object):
    def replaceWords(self, dictionary, sentence):

    def _trie(): return collections.defaultdict(_trie)
    trie = _trie()
    for word in dictionary:
        reduce(dict.__getitem__, word, trie).setdefault("_end")

    def replace(word):
        curr = trie
        for i, c in enumerate(word):
            if c not in curr:
                break
            curr = curr[c]
            if "_end" in curr:
                return word[: i + 1]
        return word

    return " ".join(map(replace, sentence.split()))


class Solution(object):
    def matrixReshape(self, nums, r, c):

    if not nums or r * c != len(nums) * len(nums[0]):
        return nums

    result = [[0 for _ in xrange(c)] for _ in xrange(r)]
    count = 0
    for i in xrange(len(nums)):
        for j in xrange(len(nums[0])):
            result[count / c][count % c] = nums[i][j]
            count += 1
    return result


class Solution(object):

    def restoreIpAddresses(self, s):
    result = []
    self.restoreIpAddressesRecur(result, s, 0, "", 0)
    return result

    def restoreIpAddressesRecur(self, result, s, start, current, dots):

    if (4 - dots) * 3 < len(s) - start or (4 - dots) > len(s) - start:
        return

    if start == len(s) and dots == 4:
        result.append(current[:-1])
    else:
        for i in xrange(start, start + 3):
            if len(s) > i and self.isValid(s[start: i + 1]):
                current += s[start: i + 1] + "."
                self.restoreIpAddressesRecur(
                    result, s, i + 1, current, dots + 1)
                current = current[: -(i - start + 2)]

    def isValid(self, s):
    if len(s) == 0 or (s[0] == "0" and s != "0"):
        return False
    return int(s) < 256


import collections


class Solution(object):
    def restoreArray(self, adjacentPairs):

    adj = collections.defaultdict(list)
    for u, v in adjacentPairs:
        adj[u].append(v)
        adj[v].append(u)
    result = next([x, adj[x][0]] for x in adj if len(adj[x]) == 1)
    while len(result) != len(adjacentPairs) + 1:
        result.append(adj[result[-1]][adj[result[-1]][0] == result[-2]])
    return result


class Solution(object):
    def numberOfArrays(self, s, k):

    MOD = 10 ** 9 + 7
    klen = len(str(k))
    dp = [0] * (klen + 1)
    dp[len(s) % len(dp)] = 1
    for i in reversed(xrange(len(s))):
        dp[i % len(dp)] = 0
        if s[i] == "0":
            continue
        curr = 0
        for j in xrange(i, min(i + klen, len(s))):
            curr = 10 * curr + int(s[j])
            if curr > k:
                break
            dp[i % len(dp)] = (dp[i % len(dp)] + dp[(j + 1) % len(dp)]) % MOD
    return dp[0]


import collections


class Solution(object):
    def deckRevealedIncreasing(self, deck):

    d = collections.deque()
    deck.sort(reverse=True)
    for i in deck:
        if d:
            d.appendleft(d.pop())
        d.appendleft(i)
    return list(d)


class Solution(object):

    def reverseBits(self, n):
    n = (n >> 16) | (n << 16)
    n = ((n & 0xFF00FF00) >> 8) | ((n & 0x00FF00FF) << 8)
    n = ((n & 0xF0F0F0F0) >> 4) | ((n & 0x0F0F0F0F) << 4)
    n = ((n & 0xCCCCCCCC) >> 2) | ((n & 0x33333333) << 2)
    n = ((n & 0xAAAAAAAA) >> 1) | ((n & 0x55555555) << 1)
    return n


class Solution2(object):

    def reverseBits(self, n):
    result = 0
    for i in xrange(32):
        result <<= 1
        result |= n & 1
        n >>= 1
    return result


class Solution(object):
    def reverse(self, x):

    if x < 0:
        return -self.reverse(-x)

    result = 0
    while x:
        result = result * 10 + x % 10
        x //= 10
    return result if result <= 0x7FFFFFFF else 0

    def reverse2(self, x):

    if x < 0:
        x = int(str(x)[::-1][-1] + str(x)[::-1][:-1])
    else:
        x = int(str(x)[::-1])
    x = 0 if abs(x) > 0x7FFFFFFF else x
    return x

    def reverse3(self, x):

    s = cmp(x, 0)
    r = int(repr(s * x)[::-1])
    return s * r * (r < 2 ** 31)


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self:
        return "{} -> {}".format(self.val, repr(self.next))


class Solution(object):

    def reverseBetween(self, head, m, n):
    diff, dummy, cur = n - m + 1, ListNode(-1), head
    dummy.next = head

    last_unswapped = dummy
    while cur and m > 1:
        cur, last_unswapped, m = cur.next, cur, m - 1

    prev, first_swapped = last_unswapped, cur
    while cur and diff > 0:
        cur.next, prev, cur, diff = prev, cur, cur.next, diff - 1

    last_unswapped.next, first_swapped.next = prev, cur

    return dummy.next


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self:
        return "{} -> {}".format(self.val, repr(self.next))


class Solution(object):

    def reverseList(self, head):
    dummy = ListNode(float("-inf"))
    while head:
        dummy.next, head.next, head = head, dummy.next, head.next
    return dummy.next


class Solution2(object):

    def reverseList(self, head):
    [begin, end] = self.reverseListRecu(head)
    return begin

    def reverseListRecu(self, head):
    if not head:
        return [None, None]

    [begin, end] = self.reverseListRecu(head.next)

    if end:
        end.next = head
        head.next = None
        return [begin, head]
    else:
        return [head, head]


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self:
        return "{} -> {}".format(self.val, repr(self.next))


class Solution(object):

    def reverseKGroup(self, head, k):
    dummy = ListNode(-1)
    dummy.next = head

    cur, cur_dummy = head, dummy
    length = 0

    while cur:
        next_cur = cur.next
        length = (length + 1) % k

        if length == 0:
            next_dummy = cur_dummy.next
            self.reverse(cur_dummy, cur.next)
            cur_dummy = next_dummy

        cur = next_cur

    return dummy.next

    def reverse(self, begin, end):
    first = begin.next
    cur = first.next

    while cur != end:
        first.next = cur.next
        cur.next = begin.next
        begin.next = cur
        cur = first.next


class Solution(object):
    def reverseOnlyLetters(self, S):

    def getNext(S):
        for i in reversed(xrange(len(S))):
            if S[i].isalpha():
                yield S[i]

    result = []
    letter = getNext(S)
    for i in xrange(len(S)):
        if S[i].isalpha():
            result.append(letter.next())
        else:
            result.append(S[i])
    return "".join(result)


class Solution(object):
    def reversePairs(self, nums):

    def merge(nums, start, mid, end):
        r = mid + 1
        tmp = []
        for i in xrange(start, mid + 1):
            while r <= end and nums[i] > nums[r]:
                tmp.append(nums[r])
                r += 1
            tmp.append(nums[i])
        nums[start: start + len(tmp)] = tmp

    def countAndMergeSort(nums, start, end):
        if end - start <= 0:
            return 0

        mid = start + (end - start) / 2
        count = countAndMergeSort(nums, start, mid) + countAndMergeSort(
            nums, mid + 1, end
        )
        r = mid + 1
        for i in xrange(start, mid + 1):
            while r <= end and nums[i] > nums[r] * 2:
                r += 1
            count += r - (mid + 1)
        merge(nums, start, mid, end)
        return count

    return countAndMergeSort(nums, 0, len(nums) - 1)


class Solution(object):
    def reverseStr(self, s, k):

    s = list(s)
    for i in xrange(0, len(s), 2 * k):
        s[i: i + k] = reversed(s[i: i + k])
    return "".join(s)


class Solution(object):
    def reverseString(self, s):

    string = list(s)
    i, j = 0, len(string) - 1
    while i < j:
        string[i], string[j] = string[j], string[i]
        i += 1
        j -= 1
    return "".join(string)


class Solution2(object):
    def reverseString(self, s):

    return s[::-1]


class Solution(object):
    def maxValueAfterReverse(self, nums):

    result, add, max_pair, min_pair = 0, 0, float("-inf"), float("inf")
    for i in xrange(1, len(nums)):
        result += abs(nums[i - 1] - nums[i])
        add = max(
            add,
            abs(nums[0] - nums[i]) - abs(nums[i - 1] - nums[i]),
            abs(nums[-1] - nums[i - 1]) - abs(nums[i - 1] - nums[i]),
        )
        min_pair = min(min_pair, max(nums[i - 1], nums[i]))
        max_pair = max(max_pair, min(nums[i - 1], nums[i]))
    return result + max(add, (max_pair - min_pair) * 2)


class Solution(object):
    def reverseParentheses(self, s):

    stk, lookup = [], {}
    for i, c in enumerate(s):
        if c == "(":
            stk.append(i)
        elif c == ")":
            j = stk.pop()
            lookup[i], lookup[j] = j, i
    result = []
    i, d = 0, 1
    while i < len(s):
        if i in lookup:
            i = lookup[i]
            d *= -1
        else:
            result.append(s[i])
        i += d
    return "".join(result)


class Solution2(object):
    def reverseParentheses(self, s):

    stk = [[]]
    for c in s:
        if c == "(":
            stk.append([])
        elif c == ")":
            end = stk.pop()
            end.reverse()
            stk[-1].extend(end)
        else:
            stk[-1].append(c)
    return "".join(stk.pop())


class Solution(object):
    def reverseVowels(self, s):

    vowels = "aeiou"
    string = list(s)
    i, j = 0, len(s) - 1
    while i < j:
        if string[i].lower() not in vowels:
            i += 1
        elif string[j].lower() not in vowels:
            j -= 1
        else:
            string[i], string[j] = string[j], string[i]
            i += 1
            j -= 1
    return "".join(string)


class Solution(object):
    def reverseWords(self, s):

    def reverse(s, begin, end):
        for i in xrange((end - begin) / 2):
            s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i]

    reverse(s, 0, len(s))
    i = 0
    for j in xrange(len(s) + 1):
        if j == len(s) or s[j] == " ":
            reverse(s, i, j)
            i = j + 1


class Solution(object):
    def reverseWords(self, s):

    def reverse(s, begin, end):
        for i in xrange((end - begin) // 2):
            s[begin + i], s[end - 1 - i] = s[end - 1 - i], s[begin + i]

    s, i = list(s), 0
    for j in xrange(len(s) + 1):
        if j == len(s) or s[j] == " ":
            reverse(s, i, j)
            i = j + 1
    return "".join(s)


class Solution2(object):
    def reverseWords(self, s):
    reversed_words = [word[::-1] for word in s.split(" ")]
    return " ".join(reversed_words)


class Solution(object):

    def reverseWords(self, s):
    return " ".join(reversed(s.split()))


import itertools


class Solution(object):
    def maximumWealth(self, accounts):

    return max(itertools.imap(sum, accounts))


class RLEIterator(object):
    def __init__(self, A):

    self.__A = A
    self.__i = 0
    self.__cnt = 0

    def next(self, n):

    while self.__i < len(self.__A):
        if n > self.__A[self.__i] - self.__cnt:
            n -= self.__A[self.__i] - self.__cnt
            self.__cnt = 0
            self.__i += 2
        else:
            self.__cnt += n
            return self.__A[self.__i + 1]
    return -1


class Solution(object):
    def isRobotBounded(self, instructions):

    directions = [[1, 0], [0, -1], [-1, 0], [0, 1]]
    x, y, i = 0, 0, 0
    for instruction in instructions:
        if instruction == "R":
            i = (i + 1) % 4
        elif instruction == "L":
            i = (i - 1) % 4
        else:
            x += directions[i][0]
            y += directions[i][1]
    return (x == 0 and y == 0) or i > 0


import collections


class Solution(object):
    def judgeCircle(self, moves):

    count = collections.Counter(moves)
    return count["L"] == count["R"] and count["U"] == count["D"]


class Solution(object):
    def judgeCircle(self, moves):

    v, h = 0, 0
    for move in moves:
        if move == "U":
            v += 1
        elif move == "D":
            v -= 1
        elif move == "R":
            h += 1
        elif move == "L":
            h -= 1
    return v == 0 and h == 0


class Solution(object):
    def cleanRoom(self, robot):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def goBack(robot):
        robot.turnLeft()
        robot.turnLeft()
        robot.move()
        robot.turnRight()
        robot.turnRight()

    def dfs(pos, robot, d, lookup):
        robot.clean()
        for _ in directions:
            new_pos = (pos[0] + directions[d][0], pos[1] + directions[d][1])
            if new_pos not in lookup:
                lookup.add(new_pos)
                if robot.move():
                    dfs(new_pos, robot, d, lookup)
                    goBack(robot)
            robot.turnRight()
            d = (d + 1) % len(directions)

    dfs((0, 0), robot, 0, set())


class Solution(object):

    def romanToInt(self, s):
    numeral_map = {"I": 1, "V": 5, "X": 10,
                   "L": 50, "C": 100, "D": 500, "M": 1000}
    decimal = 0
    for i in xrange(len(s)):
        if i > 0 and numeral_map[s[i]] > numeral_map[s[i - 1]]:
            decimal += numeral_map[s[i]] - 2 * numeral_map[s[i - 1]]
        else:
            decimal += numeral_map[s[i]]
    return decimal


class Solution(object):

    def rotate(self, nums, k):

    def reverse(nums, start, end):
        while start < end:
            nums[start], nums[end - 1] = nums[end - 1], nums[start]
            start += 1
            end -= 1

    k %= len(nums)
    reverse(nums, 0, len(nums))
    reverse(nums, 0, k)
    reverse(nums, k, len(nums))


from fractions import gcd


class Solution2(object):

    def rotate(self, nums, k):

    def apply_cycle_permutation(k, offset, cycle_len, nums):
        tmp = nums[offset]
        for i in xrange(1, cycle_len):
            nums[(offset + i * k) % len(nums)], tmp = (
                tmp,
                nums[(offset + i * k) % len(nums)],
            )
        nums[offset] = tmp

    k %= len(nums)
    num_cycles = gcd(len(nums), k)
    cycle_len = len(nums) / num_cycles
    for i in xrange(num_cycles):
        apply_cycle_permutation(k, i, cycle_len, nums)


class Solution3(object):

    def rotate(self, nums, k):
    count = 0
    start = 0
    while count < len(nums):
        curr = start
        prev = nums[curr]
        while True:
            idx = (curr + k) % len(nums)
            nums[idx], prev = prev, nums[idx]
            curr = idx
            count += 1
            if start == curr:
                break
        start += 1


class Solution4(object):

    def rotate(self, nums, k):

    nums[:] = nums[len(nums) - k:] + nums[: len(nums) - k]


class Solution5(object):

    def rotate(self, nums, k):
    while k > 0:
        nums.insert(0, nums.pop())
        k -= 1


class Solution(object):
    def maxRotateFunction(self, A):

    s = sum(A)
    fi = 0
    for i in xrange(len(A)):
        fi += i * A[i]

    result = fi
    for i in xrange(1, len(A) + 1):
        fi += s - len(A) * A[-i]
        result = max(result, fi)
    return result


class Solution(object):

    def rotate(self, matrix):
    n = len(matrix)

    for i in xrange(n):
        for j in xrange(n - i):
            matrix[i][j], matrix[n - 1 - j][n - 1 - i] = (
                matrix[n - 1 - j][n - 1 - i],
                matrix[i][j],
            )

    for i in xrange(n / 2):
        for j in xrange(n):
            matrix[i][j], matrix[n - 1 -
                                 i][j] = matrix[n - 1 - i][j], matrix[i][j]

    return matrix


class Solution2(object):

    def rotate(self, matrix):
    return [list(reversed(x)) for x in zip(*matrix)]


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self:
        return "{} -> {}".format(self.val, repr(self.next))


class Solution(object):
    def rotateRight(self, head, k):

    if not head or not head.next:
        return head

    n, cur = 1, head
    while cur.next:
        cur = cur.next
        n += 1
    cur.next = head

    cur, tail = head, cur
    for _ in xrange(n - k % n):
        tail = cur
        cur = cur.next
    tail.next = None

    return cur


class Solution(object):
    def rotateString(self, A, B):

    def check(index):
        return all(A[(i + index) % len(A)] == c for i, c in enumerate(B))

    if len(A) != len(B):
        return False

    M, p = 10 ** 9 + 7, 113
    p_inv = pow(p, M - 2, M)

    b_hash, power = 0, 1
    for c in B:
        b_hash += power * ord(c)
        b_hash %= M
        power = (power * p) % M

    a_hash, power = 0, 1
    for i in xrange(len(B)):
        a_hash += power * ord(A[i % len(A)])
        a_hash %= M
        power = (power * p) % M

    if a_hash == b_hash and check(0):
        return True

    power = (power * p_inv) % M
    for i in xrange(len(B), 2 * len(A)):
        a_hash = (a_hash - ord(A[(i - len(B)) % len(A)])) * p_inv
        a_hash += power * ord(A[i % len(A)])
        a_hash %= M
        if a_hash == b_hash and check(i - len(B) + 1):
            return True

    return False


class Solution2(object):
    def rotateString(self, A, B):

    def strStr(haystack, needle):
        def KMP(text, pattern):
            prefix = getPrefix(pattern)
            j = -1
            for i in xrange(len(text)):
                while j > -1 and pattern[j + 1] != text[i]:
                    j = prefix[j]
                if pattern[j + 1] == text[i]:
                    j += 1
                if j == len(pattern) - 1:
                    return i - j
            return -1

        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in xrange(1, len(pattern)):
                while j > -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j + 1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if not needle:
            return 0
        return KMP(haystack, needle)

    if len(A) != len(B):
        return False
    return strStr(A * 2, B) != -1


class Solution3(object):
    def rotateString(self, A, B):

    return len(A) == len(B) and B in A * 2


class Solution(object):
    def rotatedDigits(self, N):

    A = map(int, str(N))
    invalid, diff = set([3, 4, 7]), set([2, 5, 6, 9])

    def dp(A, i, is_prefix_equal, is_good, lookup):
        if i == len(A):
            return int(is_good)
        if (i, is_prefix_equal, is_good) not in lookup:
            result = 0
            for d in xrange(A[i] + 1 if is_prefix_equal else 10):
                if d in invalid:
                    continue
                result += dp(
                    A,
                    i + 1,
                    is_prefix_equal and d == A[i],
                    is_good or d in diff,
                    lookup,
                )
            lookup[i, is_prefix_equal, is_good] = result
        return lookup[i, is_prefix_equal, is_good]

    lookup = {}
    return dp(A, 0, True, False, lookup)


class Solution2(object):
    def rotatedDigits(self, N):

    INVALID, SAME, DIFF = 0, 1, 2
    same, diff = [0, 1, 8], [2, 5, 6, 9]
    dp = [0] * (N + 1)
    dp[0] = SAME
    for i in xrange(N // 10 + 1):
        if dp[i] != INVALID:
            for j in same:
                if i * 10 + j <= N:
                    dp[i * 10 + j] = max(SAME, dp[i])
            for j in diff:
                if i * 10 + j <= N:
                    dp[i * 10 + j] = DIFF
    return dp.count(DIFF)


class Solution3(object):
    def rotatedDigits(self, N):

    invalid, diff = set(["3", "4", "7"]), set(["2", "5", "6", "9"])
    result = 0
    for i in xrange(N + 1):
        lookup = set(list(str(i)))
        if invalid & lookup:
            continue
        if diff & lookup:
            result += 1
    return result


import collections


class Solution(object):
    def orangesRotting(self, grid):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    count = 0
    q = collections.deque()
    for r, row in enumerate(grid):
        for c, val in enumerate(row):
            if val == 2:
                q.append((r, c, 0))
            elif val == 1:
                count += 1

    result = 0
    while q:
        r, c, result = q.popleft()
        for d in directions:
            nr, nc = r + d[0], c + d[1]
            if not (0 <= nr < len(grid) and 0 <= nc < len(grid[r])):
                continue
            if grid[nr][nc] == 1:
                count -= 1
                grid[nr][nc] = 2
                q.append((nr, nc, result + 1))
    return result if count == 0 else -1


class Solution(object):
    def runningSum(self, nums):

    for i in xrange(len(nums) - 1):
        nums[i + 1] += nums[i]
    return nums


class Solution(object):
    def maxEnvelopes(self, envelopes):

    def insert(target):
        left, right = 0, len(result) - 1
        while left <= right:
            mid = left + (right - left) / 2
            if result[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1
        if left == len(result):
            result.append(target)
        else:
            result[left] = target

    result = []

    envelopes.sort(lambda x, y: y[1] - x[1] if x[0] == y[0] else x[0] - y[0])
    for envelope in envelopes:
        insert(envelope[1])

    return len(result)


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def isSameTree(self, p, q):
    if p is None and q is None:
        return True

    if p is not None and q is not None:
        return (
            p.val == q.val
            and self.isSameTree(p.left, q.left)
            and self.isSameTree(p.right, q.right)
        )

    return False


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    return True


class Solution(object):
    def equationsPossible(self, equations):

    union_find = UnionFind(26)
    for eqn in equations:
        x = ord(eqn[0]) - ord("a")
        y = ord(eqn[3]) - ord("a")
        if eqn[1] == "=":
            union_find.union_set(x, y)
    for eqn in equations:
        x = ord(eqn[0]) - ord("a")
        y = ord(eqn[3]) - ord("a")
        if eqn[1] == "!":
            if union_find.find_set(x) == union_find.find_set(y):
                return False
    return True


class Solution2(object):
    def equationsPossible(self, equations):

    graph = [[] for _ in xrange(26)]

    for eqn in equations:
        x = ord(eqn[0]) - ord("a")
        y = ord(eqn[3]) - ord("a")
        if eqn[1] == "!":
            if x == y:
                return False
        else:
            graph[x].append(y)
            graph[y].append(x)

    color = [None] * 26
    c = 0
    for i in xrange(26):
        if color[i] is not None:
            continue
        c += 1
        stack = [i]
        while stack:
            node = stack.pop()
            for nei in graph[node]:
                if color[nei] is not None:
                    continue
                color[nei] = c
                stack.append(nei)

    for eqn in equations:
        if eqn[1] != "!":
            continue
        x = ord(eqn[0]) - ord("a")
        y = ord(eqn[3]) - ord("a")
        if color[x] is not None and color[x] == color[y]:
            return False
    return True


class Solution(object):
    def matrixScore(self, A):

    R, C = len(A), len(A[0])
    result = 0
    for c in xrange(C):
        col = 0
        for r in xrange(R):
            col += A[r][c] ^ A[r][0]
        result += max(col, R - col) * 2 ** (C - 1 - c)
    return result


class Solution(object):
    def scoreOfParentheses(self, S):

    result, depth = 0, 0
    for i in xrange(len(S)):
        if S[i] == "(":
            depth += 1
        else:
            depth -= 1
            if S[i - 1] == "(":
                result += 2 ** depth
    return result


class Solution2(object):
    def scoreOfParentheses(self, S):

    stack = [0]
    for c in S:
        if c == "(":
            stack.append(0)
        else:
            last = stack.pop()
            stack[-1] += max(1, 2 * last)
    return stack[0]


class Solution(object):

    def isScramble(self, s1, s2):
    if not s1 or not s2 or len(s1) != len(s2):
        return False
    if s1 == s2:
        return True
    result = [
        [[False for j in xrange(len(s2))] for i in xrange(len(s1))]
        for n in xrange(len(s1) + 1)
    ]
    for i in xrange(len(s1)):
        for j in xrange(len(s2)):
            if s1[i] == s2[j]:
                result[1][i][j] = True

    for n in xrange(2, len(s1) + 1):
        for i in xrange(len(s1) - n + 1):
            for j in xrange(len(s2) - n + 1):
                for k in xrange(1, n):
                    if (
                        result[k][i][j]
                        and result[n - k][i + k][j + k]
                        or result[k][i][j + n - k]
                        and result[n - k][i + k][j]
                    ):
                        result[n][i][j] = True
                        break

    return result[n][0][0]


class Solution(object):

    def searchMatrix(self, matrix, target):
    m = len(matrix)
    if m == 0:
        return False

    n = len(matrix[0])
    if n == 0:
        return False

    i, j = 0, n - 1
    while i < m and j >= 0:
        if matrix[i][j] == target:
            return True
        elif matrix[i][j] > target:
            j -= 1
        else:
            i += 1

    return False


class Solution(object):
    def searchMatrix(self, matrix, target):

    if not matrix:
        return False

    m, n = len(matrix), len(matrix[0])
    left, right = 0, m * n
    while left < right:
        mid = left + (right - left) / 2
        if matrix[mid / n][mid % n] >= target:
            right = mid
        else:
            left = mid + 1

    return left < m * n and matrix[left / n][left % n] == target


class Solution(object):
    def searchRange(self, nums, target):

    left = self.binarySearch(lambda x, y: x >= y, nums, target)
    if left >= len(nums) or nums[left] != target:
        return [-1, -1]

    right = self.binarySearch(lambda x, y: x > y, nums, target)
    return [left, right - 1]

    def binarySearch(self, compare, nums, target):
    left, right = 0, len(nums)
    while left < right:
        mid = left + (right - left) / 2
        if compare(nums[mid], target):
            right = mid
        else:
            left = mid + 1
    return left

    def binarySearch2(self, compare, nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) / 2
        if compare(nums[mid], target):
            right = mid - 1
        else:
            left = mid + 1
    return left

    def binarySearch3(self, compare, nums, target):
    left, right = -1, len(nums)
    while left + 1 < right:
        mid = left + (right - left) / 2
        if compare(nums[mid], target):
            right = mid
        else:
            left = mid
    return left if left != -1 and compare(nums[left], target) else right


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def searchBST(self, root, val):

    while root and val != root.val:
        if val < root.val:
            root = root.left
        else:
            root = root.right
    return root


class Solution(object):
    def search(self, reader, target):

    left, right = 0, 19999
    while left <= right:
        mid = left + (right - left) // 2
        response = reader.get(mid)
        if response > target:
            right = mid - 1
        elif response < target:
            left = mid + 1
        else:
            return mid
    return -1


class Solution(object):
    def search(self, nums, target):

    left, right = 0, len(nums) - 1

    while left <= right:
        mid = left + (right - left) / 2

        if nums[mid] == target:
            return True
        elif nums[mid] == nums[left]:
            left += 1
        elif (nums[mid] > nums[left] and nums[left] <= target < nums[mid]) or (
            nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])
        ):
            right = mid - 1
        else:
            left = mid + 1

    return False


class Solution(object):
    def search(self, nums, target):

    left, right = 0, len(nums) - 1

    while left <= right:
        mid = left + (right - left) / 2

        if nums[mid] == target:
            return mid
        elif (nums[mid] >= nums[left] and nums[left] <= target < nums[mid]) or (
            nums[mid] < nums[left] and not (nums[mid] < target <= nums[right])
        ):
            right = mid - 1
        else:
            left = mid + 1

    return -1


class Solution(object):
    def searchInsert(self, nums, target):

    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) / 2
        if nums[mid] >= target:
            right = mid - 1
        else:
            left = mid + 1

    return left


import collections


class TrieNode(object):
    def __init__(self):
    self.__TOP_COUNT = 3
    self.leaves = collections.defaultdict(TrieNode)
    self.infos = []

    def insert(self, words, i):
    curr = self
    for c in words[i]:
        curr = curr.leaves[c]
        curr.add_info(words, i)

    def add_info(self, words, i):
    self.infos.append(i)
    self.infos.sort(key=lambda x: words[x])
    if len(self.infos) > self.__TOP_COUNT:
        self.infos.pop()


class Solution(object):
    def suggestedProducts(self, products, searchWord):

    trie = TrieNode()
    for i in xrange(len(products)):
        trie.insert(products, i)
    result = [[] for _ in xrange(len(searchWord))]
    for i, c in enumerate(searchWord):
        if c not in trie.leaves:
            break
        trie = trie.leaves[c]
        result[i] = map(lambda x: products[x], trie.infos)
    return result


class TrieNode2(object):
    def __init__(self):
    self.__TOP_COUNT = 3
    self.leaves = collections.defaultdict(TrieNode2)
    self.infos = []

    def insert(self, words, i):
    curr = self
    for c in words[i]:
        curr = curr.leaves[c]
        curr.add_info(i)

    def add_info(self, i):
    if len(self.infos) == self.__TOP_COUNT:
        return
    self.infos.append(i)


class Solution2(object):
    def suggestedProducts(self, products, searchWord):

    products.sort()
    trie = TrieNode2()
    for i in xrange(len(products)):
        trie.insert(products, i)
    result = [[] for _ in xrange(len(searchWord))]
    for i, c in enumerate(searchWord):
        if c not in trie.leaves:
            break
        trie = trie.leaves[c]
        result[i] = map(lambda x: products[x], trie.infos)
    return result


import bisect


class Solution3(object):
    def suggestedProducts(self, products, searchWord):

    products.sort()
    result = []
    prefix = ""
    for i, c in enumerate(searchWord):
        prefix += c
        start = bisect.bisect_left(products, prefix)
        new_products = []
        for j in xrange(start, len(products)):
            if not (i < len(products[j]) and products[j][i] == c):
                break
            new_products.append(products[j])
        products = new_products
        result.append(products[:3])
    return result


import heapq


class Solution(object):
    def findSecondMinimumValue(self, root):

    def findSecondMinimumValueHelper(root, max_heap, lookup):
        if not root:
            return
        if root.val not in lookup:
            heapq.heappush(max_heap, -root.val)
            lookup.add(root.val)
            if len(max_heap) > 2:
                lookup.remove(-heapq.heappop(max_heap))
        findSecondMinimumValueHelper(root.left, max_heap, lookup)
        findSecondMinimumValueHelper(root.right, max_heap, lookup)

    max_heap, lookup = [], set()
    findSecondMinimumValueHelper(root, max_heap, lookup)
    if len(max_heap) < 2:
        return -1
    return -max_heap[0]


class Solution(object):
    def isSelfCrossing(self, x):

    if len(x) >= 5 and x[3] == x[1] and x[4] + x[0] >= x[2]:

        return True

    for i in xrange(3, len(x)):
        if x[i] >= x[i - 2] and x[i - 3] >= x[i - 1]:

            return True
        elif (
            i >= 5
            and x[i - 4] <= x[i - 2]
            and x[i] + x[i - 4] >= x[i - 2]
            and x[i - 1] <= x[i - 3]
            and x[i - 5] + x[i - 1] >= x[i - 3]
        ):

            return True
    return False


class Solution(object):
    def selfDividingNumbers(self, left, right):

    def isDividingNumber(num):
        n = num
        while n > 0:
            n, r = divmod(n, 10)
            if r == 0 or (num % r) != 0:
                return False
        return True

    return [num for num in xrange(left, right + 1) if isDividingNumber(num)]


import itertools


class Solution2(object):
    def selfDividingNumbers(self, left, right):

    return [
        num
        for num in xrange(left, right + 1)
        if not any(
            itertools.imap(lambda x: int(x) == 0 or num %
                           int(x) != 0, str(num))
        )
    ]


class Solution(object):
    def maxProfit(self, inventory, orders):

    MOD = 10 ** 9 + 7

    def check(inventory, orders, x):
        return count(inventory, x) > orders

    def count(inventory, x):
        return sum(count - x + 1 for count in inventory if count >= x)

    left, right = 1, max(inventory)
    while left <= right:
        mid = left + (right - left) // 2
        if not check(inventory, orders, mid):
            right = mid - 1
        else:
            left = mid + 1

    return (
        sum(
            (left + cnt) * (cnt - left + 1) // 2 for cnt in inventory if cnt >= left
        )
        + (left - 1) * (orders - count(inventory, left))
    ) % MOD


class Solution(object):
    def wordsTyping(self, sentence, rows, cols):

    def words_fit(sentence, start, cols):
        if len(sentence[start]) > cols:
            return 0

        s, count = len(sentence[start]), 1
        i = (start + 1) % len(sentence)
        while s + 1 + len(sentence[i]) <= cols:
            s += 1 + len(sentence[i])
            count += 1
            i = (i + 1) % len(sentence)
        return count

    wc = [0] * len(sentence)
    for i in xrange(len(sentence)):
        wc[i] = words_fit(sentence, i, cols)

    words, start = 0, 0
    for i in xrange(rows):
        words += wc[start]
        start = (start + wc[start]) % len(sentence)
    return words / len(sentence)


import itertools


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    return True


class Solution(object):
    def areSentencesSimilarTwo(self, words1, words2, pairs):

    if len(words1) != len(words2):
        return False

    lookup = {}
    union_find = UnionFind(2 * len(pairs))
    for pair in pairs:
        for p in pair:
            if p not in lookup:
                lookup[p] = len(lookup)
        union_find.union_set(lookup[pair[0]], lookup[pair[1]])

    return all(
        w1 == w2
        or w1 in lookup
        and w2 in lookup
        and union_find.find_set(lookup[w1]) == union_find.find_set(lookup[w2])
        for w1, w2 in itertools.izip(words1, words2)
    )


import itertools


class Solution(object):
    def areSentencesSimilar(self, words1, words2, pairs):

    if len(words1) != len(words2):
        return False
    lookup = set(map(tuple, pairs))
    return all(
        w1 == w2 or (w1, w2) in lookup or (w2, w1) in lookup
        for w1, w2 in itertools.izip(words1, words2)
    )


import collections


class Solution(object):
    def sequenceReconstruction(self, org, seqs):

    if not seqs:
        return False
    pos = [0] * (len(org) + 1)
    for i in xrange(len(org)):
        pos[org[i]] = i

    is_matched = [False] * (len(org) + 1)
    cnt_to_match = len(org) - 1
    for seq in seqs:
        for i in xrange(len(seq)):
            if not 0 < seq[i] <= len(org):
                return False
            if i == 0:
                continue
            if pos[seq[i - 1]] >= pos[seq[i]]:
                return False
            if (
                is_matched[seq[i - 1]] == False
                and pos[seq[i - 1]] + 1 == pos[seq[i]]
            ):
                is_matched[seq[i - 1]] = True
                cnt_to_match -= 1

    return cnt_to_match == 0


class Solution2(object):
    def sequenceReconstruction(self, org, seqs):

    graph = collections.defaultdict(set)
    indegree = collections.defaultdict(int)
    integer_set = set()
    for seq in seqs:
        for i in seq:
            integer_set.add(i)
        if len(seq) == 1:
            if seq[0] not in indegree:
                indegree[seq[0]] = 0
            continue
        for i in xrange(len(seq) - 1):
            if seq[i] not in indegree:
                indegree[seq[i]] = 0
            if seq[i + 1] not in graph[seq[i]]:
                graph[seq[i]].add(seq[i + 1])
                indegree[seq[i + 1]] += 1

    cnt_of_zero_indegree = 0
    res = []
    q = []
    for i in indegree:
        if indegree[i] == 0:
            cnt_of_zero_indegree += 1
            if cnt_of_zero_indegree > 1:
                return False
            q.append(i)

    while q:
        i = q.pop()
        res.append(i)
        cnt_of_zero_indegree = 0
        for j in graph[i]:
            indegree[j] -= 1
            if indegree[j] == 0:
                cnt_of_zero_indegree += 1
                if cnt_of_zero_indegree > 1:
                    return False
                q.append(j)
    return res == org and len(org) == len(integer_set)


import collections


class Solution(object):
    def sequentialDigits(self, low, high):

    result = []
    q = collections.deque(range(1, 9))
    while q:
        num = q.popleft()
        if num > high:
            continue
        if low <= num:
            result.append(num)
        if num % 10 + 1 < 10:
            q.append(num * 10 + num % 10 + 1)
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Codec(object):
    def serialize(self, root):

    def serializeHelper(node):
        if not node:
            vals.append("#")
            return
        vals.append(str(node.val))
        serializeHelper(node.left)
        serializeHelper(node.right)

    vals = []
    serializeHelper(root)
    return " ".join(vals)

    def deserialize(self, data):

    def deserializeHelper():
        val = next(vals)
        if val == "#":
            return None
        node = TreeNode(int(val))
        node.left = deserializeHelper()
        node.right = deserializeHelper()
        return node

    def isplit(source, sep):
        sepsize = len(sep)
        start = 0
        while True:
            idx = source.find(sep, start)
            if idx == -1:
                yield source[start:]
                return
            yield source[start:idx]
            start = idx + sepsize

    vals = iter(isplit(data, " "))
    return deserializeHelper()


class Codec2(object):
    def serialize(self, root):

    def gen_preorder(node):
        if not node:
            yield "#"
        else:
            yield str(node.val)
            for n in gen_preorder(node.left):
                yield n
            for n in gen_preorder(node.right):
                yield n

    return " ".join(gen_preorder(root))

    def deserialize(self, data):

    def builder(chunk_iter):
        val = next(chunk_iter)
        if val == "#":
            return None
        node = TreeNode(int(val))
        node.left = builder(chunk_iter)
        node.right = builder(chunk_iter)
        return node

    chunk_iter = iter(data.split())
    return builder(chunk_iter)


import collections


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Codec(object):
    def serialize(self, root):

    def serializeHelper(node, vals):
        if node:
            vals.append(node.val)
            serializeHelper(node.left, vals)
            serializeHelper(node.right, vals)

    vals = []
    serializeHelper(root, vals)

    return " ".join(map(str, vals))

    def deserialize(self, data):

    def deserializeHelper(minVal, maxVal, vals):
        if not vals:
            return None

        if minVal < vals[0] < maxVal:
            val = vals.popleft()
            node = TreeNode(val)
            node.left = deserializeHelper(minVal, val, vals)
            node.right = deserializeHelper(val, maxVal, vals)
            return node
        else:
            return None

    vals = collections.deque([int(val) for val in data.split()])

    return deserializeHelper(float("-inf"), float("inf"), vals)


class Node(object):
    def __init__(self, val, children):
    self.val = val
    self.children = children


class Codec(object):
    def serialize(self, root):

    def dfs(node, vals):
        if not node:
            return
        vals.append(str(node.val))
        for child in node.children:
            dfs(child, vals)
        vals.append("#")

    vals = []
    dfs(root, vals)
    return " ".join(vals)

    def deserialize(self, data):

    def isplit(source, sep):
        sepsize = len(sep)
        start = 0
        while True:
            idx = source.find(sep, start)
            if idx == -1:
                yield source[start:]
                return
            yield source[start:idx]
            start = idx + sepsize

    def dfs(vals):
        val = next(vals)
        if val == "#":
            return None
        root = Node(int(val), [])
        child = dfs(vals)
        while child:
            root.children.append(child)
            child = dfs(vals)
        return root

    if not data:
        return None

    return dfs(iter(isplit(data, " ")))


class Solution(object):
    def intersectionSizeTwo(self, intervals):

    intervals.sort(key=lambda s_e: (s_e[0], -s_e[1]))
    cnts = [2] * len(intervals)
    result = 0
    while intervals:
        (start, _), cnt = intervals.pop(), cnts.pop()
        for s in xrange(start, start + cnt):
            for i in xrange(len(intervals)):
                if cnts[i] and s <= intervals[i][1]:
                    cnts[i] -= 1
        result += cnt
    return result


from functools import reduce


class Solution(object):

    def setZeroes(self, matrix):
    first_col = reduce(
        lambda acc, i: acc or matrix[i][0] == 0, xrange(len(matrix)), False
    )
    first_row = reduce(
        lambda acc, j: acc or matrix[0][j] == 0, xrange(len(matrix[0])), False
    )

    for i in xrange(1, len(matrix)):
        for j in xrange(1, len(matrix[0])):
            if matrix[i][j] == 0:
                matrix[i][0], matrix[0][j] = 0, 0

    for i in xrange(1, len(matrix)):
        for j in xrange(1, len(matrix[0])):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0

    if first_col:
        for i in xrange(len(matrix)):
            matrix[i][0] = 0

    if first_row:
        for j in xrange(len(matrix[0])):
            matrix[0][j] = 0


class Solution(object):
    def findErrorNums(self, nums):

    x_xor_y = 0
    for i in xrange(len(nums)):
        x_xor_y ^= nums[i] ^ (i + 1)
    bit = x_xor_y & ~(x_xor_y - 1)
    result = [0] * 2
    for i, num in enumerate(nums):
        result[bool(num & bit)] ^= num
        result[bool((i + 1) & bit)] ^= i + 1
    if result[0] not in nums:
        result[0], result[1] = result[1], result[0]
    return result


class Solution2(object):
    def findErrorNums(self, nums):

    result = [0] * 2
    for i in nums:
        if nums[abs(i) - 1] < 0:
            result[0] = abs(i)
        else:
            nums[abs(i) - 1] *= -1
    for i in xrange(len(nums)):
        if nums[i] > 0:
            result[1] = i + 1
        else:
            nums[i] *= -1
    return result


class Solution3(object):
    def findErrorNums(self, nums):

    N = len(nums)
    x_minus_y = sum(nums) - N * (N + 1) // 2
    x_plus_y = (
        sum(x * x for x in nums) - N * (N + 1) * (2 * N + 1) / 6
    ) // x_minus_y
    return (x_plus_y + x_minus_y) // 2, (x_plus_y - x_minus_y) // 2


class Solution(object):
    def shiftGrid(self, grid, k):

    def rotate(grids, k):
        def reverse(grid, start, end):
            while start < end:
                start_r, start_c = divmod(start, len(grid[0]))
                end_r, end_c = divmod(end - 1, len(grid[0]))
                grid[start_r][start_c], grid[end_r][end_c] = (
                    grid[end_r][end_c],
                    grid[start_r][start_c],
                )
                start += 1
                end -= 1

        k %= len(grid) * len(grid[0])
        reverse(grid, 0, len(grid) * len(grid[0]))
        reverse(grid, 0, k)
        reverse(grid, k, len(grid) * len(grid[0]))

    rotate(grid, k)
    return grid


class Solution(object):
    def shiftingLetters(self, S, shifts):

    result = []
    times = sum(shifts) % 26
    for i, c in enumerate(S):
        index = ord(c) - ord("a")
        result.append(chr(ord("a") + (index + times) % 26))
        times = (times - shifts[i]) % 26
    return "".join(result)


class Solution(object):
    def shoppingOffers(self, price, special, needs):

    def shoppingOffersHelper(price, special, needs, i):
        if i == len(special):
            return sum(map(lambda x, y: x * y, price, needs))
        result = shoppingOffersHelper(price, special, needs, i + 1)
        for j in xrange(len(needs)):
            needs[j] -= special[i][j]
        if all(need >= 0 for need in needs):
            result = min(
                result,
                special[i][-1] +
                shoppingOffersHelper(price, special, needs, i),
            )
        for j in xrange(len(needs)):
            needs[j] += special[i][j]
        return result

    return shoppingOffersHelper(price, special, needs, 0)


import collections
import functools


class Solution(object):
    def minimumLengthEncoding(self, words):

    words = list(set(words))
    def _trie(): return collections.defaultdict(_trie)
    trie = _trie()

    nodes = [functools.reduce(dict.__getitem__, word[::-1], trie)
             for word in words]

    return sum(len(word) + 1 for i, word in enumerate(words) if len(nodes[i]) == 0)


import collections


class Solution(object):
    def shortestBridge(self, A):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def get_islands(A):
        islands = []
        done = set()
        for r, row in enumerate(A):
            for c, val in enumerate(row):
                if val == 0 or (r, c) in done:
                    continue
                s = [(r, c)]
                lookup = set(s)
                while s:
                    node = s.pop()
                    for d in directions:
                        nei = node[0] + d[0], node[1] + d[1]
                        if (
                            not (0 <= nei[0] < len(A)
                                 and 0 <= nei[1] < len(A[0]))
                            or nei in lookup
                            or A[nei[0]][nei[1]] == 0
                        ):
                            continue
                        s.append(nei)
                        lookup.add(nei)
                done |= lookup
                islands.append(lookup)
                if len(islands) == 2:
                    break
        return islands

    lookup, target = get_islands(A)
    q = collections.deque([(node, 0) for node in lookup])
    while q:
        node, dis = q.popleft()
        if node in target:
            return dis - 1
        for d in directions:
            nei = node[0] + d[0], node[1] + d[1]
            if (
                not (0 <= nei[0] < len(A) and 0 <= nei[1] < len(A[0]))
                or nei in lookup
            ):
                continue
            q.append((nei, dis + 1))
            lookup.add(nei)


class Solution(object):
    def shortestCommonSupersequence(self, str1, str2):

    dp = [[0 for _ in xrange(len(str2) + 1)] for _ in xrange(2)]
    bt = [[None for _ in xrange(len(str2) + 1)] for _ in xrange(len(str1) + 1)]
    for i, c in enumerate(str1):
        bt[i + 1][0] = (i, 0, c)
    for j, c in enumerate(str2):
        bt[0][j + 1] = (0, j, c)
    for i in xrange(len(str1)):
        for j in xrange(len(str2)):
            if dp[i % 2][j + 1] > dp[(i + 1) % 2][j]:
                dp[(i + 1) % 2][j + 1] = dp[i % 2][j + 1]
                bt[i + 1][j + 1] = (i, j + 1, str1[i])
            else:
                dp[(i + 1) % 2][j + 1] = dp[(i + 1) % 2][j]
                bt[i + 1][j + 1] = (i + 1, j, str2[j])
            if str1[i] != str2[j]:
                continue
            if dp[i % 2][j] + 1 > dp[(i + 1) % 2][j + 1]:
                dp[(i + 1) % 2][j + 1] = dp[i % 2][j] + 1
                bt[i + 1][j + 1] = (i, j, str1[i])

    i, j = len(str1), len(str2)
    result = []
    while i != 0 or j != 0:
        i, j, c = bt[i][j]
        result.append(c)
    result.reverse()
    return "".join(result)


import collections


class Solution(object):
    def shortestCompletingWord(self, licensePlate, words):

    def contains(counter1, w2):
        c2 = collections.Counter(w2.lower())
        c2.subtract(counter1)
        return all(map(lambda x: x >= 0, c2.values()))

    result = None
    counter = collections.Counter(c.lower()
                                  for c in licensePlate if c.isalpha())
    for word in words:
        if (result is None or (len(word) < len(result))) and contains(
            counter, word
        ):
            result = word
    return result


class Solution(object):
    def shortestDistance(self, grid):

    def bfs(grid, dists, cnts, x, y):
        dist, m, n = 0, len(grid), len(grid[0])
        visited = [[False for _ in xrange(n)] for _ in xrange(m)]

        pre_level = [(x, y)]
        visited[x][y] = True
        while pre_level:
            dist += 1
            cur_level = []
            for i, j in pre_level:
                for dir in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    I, J = i + dir[0], j + dir[1]
                    if (
                        0 <= I < m
                        and 0 <= J < n
                        and grid[I][J] == 0
                        and not visited[I][J]
                    ):
                        cnts[I][J] += 1
                        dists[I][J] += dist
                        cur_level.append((I, J))
                        visited[I][J] = True

            pre_level = cur_level

    m, n, cnt = len(grid), len(grid[0]), 0
    dists = [[0 for _ in xrange(n)] for _ in xrange(m)]
    cnts = [[0 for _ in xrange(n)] for _ in xrange(m)]
    for i in xrange(m):
        for j in xrange(n):
            if grid[i][j] == 1:
                cnt += 1
                bfs(grid, dists, cnts, i, j)

    shortest = float("inf")
    for i in xrange(m):
        for j in xrange(n):
            if dists[i][j] < shortest and cnts[i][j] == cnt:
                shortest = dists[i][j]

    return shortest if shortest != float("inf") else -1


import itertools


class Solution(object):
    def shortestToChar(self, S, C):

    result = [len(S)] * len(S)
    prev = -len(S)
    for i in itertools.chain(xrange(len(S)), reversed(xrange(len(S)))):
        if S[i] == C:
            prev = i
        result[i] = min(result[i], abs(i - prev))
    return result


class Solution(object):
    def shortestDistanceColor(self, colors, queries):

    dp = [[-1 for _ in xrange(len(colors))] for _ in xrange(3)]
    dp[colors[0] - 1][0] = 0
    for i in xrange(1, len(colors)):
        for color in xrange(3):
            dp[color][i] = dp[color][i - 1]
        dp[colors[i] - 1][i] = i

    dp[colors[len(colors) - 1] - 1][len(colors) - 1] = len(colors) - 1
    for i in reversed(xrange(len(colors) - 1)):
        for color in xrange(3):
            if dp[color][i + 1] == -1:
                continue
            if dp[color][i] == -1 or abs(dp[color][i + 1] - i) < abs(
                dp[color][i] - i
            ):
                dp[color][i] = dp[color][i + 1]
        dp[colors[i] - 1][i] = i

    return [
        abs(dp[color - 1][i] - i) if dp[color - 1][i] != -1 else -1
        for i, color in queries
    ]


class Solution(object):
    def shortestPalindrome(self, s):

    def getPrefix(pattern):
        prefix = [-1] * len(pattern)
        j = -1
        for i in xrange(1, len(pattern)):
            while j > -1 and pattern[j + 1] != pattern[i]:
                j = prefix[j]
            if pattern[j + 1] == pattern[i]:
                j += 1
            prefix[i] = j
        return prefix

    if not s:
        return s

    A = s + "#" + s[::-1]
    return s[getPrefix(A)[-1] + 1:][::-1] + s


class Solution2(object):
    def shortestPalindrome(self, s):

    def getPrefix(pattern):
        prefix = [-1] * len(pattern)
        j = -1
        for i in xrange(1, len(pattern)):
            while j > -1 and pattern[j + 1] != pattern[i]:
                j = prefix[j]
            if pattern[j + 1] == pattern[i]:
                j += 1
            prefix[i] = j
        return prefix

    if not s:
        return s

    A = s + s[::-1]
    prefix = getPrefix(A)
    i = prefix[-1]
    while i >= len(s):
        i = prefix[i]
    return s[i + 1:][::-1] + s


class Solution3(object):
    def shortestPalindrome(self, s):

    def preProcess(s):
        if not s:
            return ["^", "$"]
        string = ["^"]
        for c in s:
            string += ["#", c]
        string += ["#", "$"]
        return string

    string = preProcess(s)
    palindrome = [0] * len(string)
    center, right = 0, 0
    for i in xrange(1, len(string) - 1):
        i_mirror = 2 * center - i
        if right > i:
            palindrome[i] = min(right - i, palindrome[i_mirror])
        else:
            palindrome[i] = 0

        while string[i + 1 + palindrome[i]] == string[i - 1 - palindrome[i]]:
            palindrome[i] += 1

        if i + palindrome[i] > right:
            center, right = i, i + palindrome[i]

    max_len = 0
    for i in xrange(1, len(string) - 1):
        if i - palindrome[i] == 1:
            max_len = palindrome[i]
    return s[len(s) - 1: max_len - 1: -1] + s


class Solution(object):
    def shortestPath(self, grid, k):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def dot(a, b):
        return a[0] * b[0] + a[1] * b[1]

    def g(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def a_star(grid, b, t, k):
        f, dh = g(b, t), 2
        closer, detour = [(b, k)], []
        lookup = {}
        while closer or detour:
            if not closer:
                f += dh
                closer, detour = detour, closer
            b, k = closer.pop()
            if b == t:
                return f
            if b in lookup and lookup[b] >= k:
                continue
            lookup[b] = k
            for dx, dy in directions:
                nb = (b[0] + dx, b[1] + dy)
                if not (
                    0 <= nb[0] < len(grid)
                    and 0 <= nb[1] < len(grid[0])
                    and (grid[nb[0]][nb[1]] == 0 or k > 0)
                    and (nb not in lookup or lookup[nb] < k)
                ):
                    continue
                (
                    closer
                    if dot((dx, dy), (t[0] - b[0], t[1] - b[1])) > 0
                    else detour
                ).append((nb, k - int(grid[nb[0]][nb[1]] == 1)))
        return -1

    return a_star(grid, (0, 0), (len(grid) - 1, len(grid[0]) - 1), k)


class GridMaster(object):
    def canMove(self, direction):
    pass

    def move(self, direction):
    pass

    def isTarget(self):
    pass


import collections


class Solution(object):
    def findShortestPath(self, master):

    directions = {"L": (0, -1), "R": (0, 1), "U": (-1, 0), "D": (1, 0)}
    rollback = {"L": "R", "R": "L", "U": "D", "D": "U"}

    def dfs(pos, target, master, lookup, adj):
        if target[0] is None and master.isTarget():
            target[0] = pos
        lookup.add(pos)
        for d, (di, dj) in directions.iteritems():
            if not master.canMove(d):
                continue
            nei = (pos[0] + di, pos[1] + dj)
            adj[pos].add(nei)
            adj[nei].add(pos)
            if nei in lookup:
                continue
            master.move(d)
            dfs(nei, target, master, lookup, adj)
            master.move(rollback[d])

    def bi_bfs(start, target, adj):
        lookup = set()
        left, right = set([start]), set([target])
        steps = 0
        while left:
            for pos in left:
                lookup.add(pos)
            new_left = set()
            for pos in left:
                if pos in right:
                    return steps
                for nei in adj[pos]:
                    if nei in lookup:
                        continue
                    new_left.add(nei)
            left = new_left
            steps += 1
            if len(left) > len(right):
                left, right = right, left
        return -1

    start = (0, 0)
    target = [None]
    adj = collections.defaultdict(set)
    dfs(start, target, master, set(), adj)
    if not target[0]:
        return -1
    return bi_bfs(start, target[0], adj)


class Solution2(object):
    def findShortestPath(self, master):

    directions = {"L": (0, -1), "R": (0, 1), "U": (-1, 0), "D": (1, 0)}
    rollback = {"L": "R", "R": "L", "U": "D", "D": "U"}

    def dfs(pos, target, master, lookup, adj):
        if target[0] is None and master.isTarget():
            target[0] = pos
        lookup.add(pos)
        for d, (di, dj) in directions.iteritems():
            if not master.canMove(d):
                continue
            nei = (pos[0] + di, pos[1] + dj)
            adj[pos].add(nei)
            adj[nei].add(pos)
            if nei in lookup:
                continue
            master.move(d)
            dfs(nei, target, master, lookup, adj)
            master.move(rollback[d])

    def bfs(start, target, adj):
        q = [start]
        lookup = set(q)
        steps = 0
        while q:
            new_q = []
            for pos in q:
                if pos == target:
                    return steps
                for nei in adj[pos]:
                    if nei in lookup:
                        continue
                    lookup.add(nei)
                    new_q.append(nei)
            q = new_q
            steps += 1
        return -1

    start = (0, 0)
    target = [None]
    adj = collections.defaultdict(set)
    dfs(start, target, master, set(), adj)
    if not target[0]:
        return -1
    return bfs(start, target[0], adj)


import collections


class Solution(object):
    def shortestPathBinaryMatrix(self, grid):

    directions = [
        (-1, -1),
        (-1, 0),
        (-1, 1),
        (0, -1),
        (0, 1),
        (1, -1),
        (1, 0),
        (1, 1),
    ]
    result = 0
    q = collections.deque([(0, 0)])
    while q:
        result += 1
        next_depth = collections.deque()
        while q:
            i, j = q.popleft()
            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and not grid[i][j]:
                grid[i][j] = 1
                if i == len(grid) - 1 and j == len(grid) - 1:
                    return result
                for d in directions:
                    next_depth.append((i + d[0], j + d[1]))
        q = next_depth
    return -1


import collections
import heapq


class Solution(object):
    def shortestPathAllKeys(self, grid):

    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

    def bfs(grid, source, locations):
        r, c = locations[source]
        lookup = [[False] * (len(grid[0])) for _ in xrange(len(grid))]
        lookup[r][c] = True
        q = collections.deque([(r, c, 0)])
        dist = {}
        while q:
            r, c, d = q.popleft()
            if source != grid[r][c] != ".":
                dist[grid[r][c]] = d
                continue
            for direction in directions:
                cr, cc = r + direction[0], c + direction[1]
                if not ((0 <= cr < len(grid)) and (0 <= cc < len(grid[cr]))):
                    continue
                if grid[cr][cc] != "#" and not lookup[cr][cc]:
                    lookup[cr][cc] = True
                    q.append((cr, cc, d + 1))
        return dist

    locations = {
        place: (r, c)
        for r, row in enumerate(grid)
        for c, place in enumerate(row)
        if place not in ".#"
    }
    dists = {place: bfs(grid, place, locations) for place in locations}

    min_heap = [(0, "@", 0)]
    best = collections.defaultdict(
        lambda: collections.defaultdict(lambda: float("inf"))
    )
    best["@"][0] = 0
    target_state = 2 ** sum(place.islower() for place in locations) - 1
    while min_heap:
        cur_d, place, state = heapq.heappop(min_heap)
        if best[place][state] < cur_d:
            continue
        if state == target_state:
            return cur_d
        for dest, d in dists[place].iteritems():
            next_state = state
            if dest.islower():
                next_state |= 1 << (ord(dest) - ord("a"))
            elif dest.isupper():
                if not (state & (1 << (ord(dest) - ord("A")))):
                    continue
            if cur_d + d < best[dest][next_state]:
                best[dest][next_state] = cur_d + d
                heapq.heappush(min_heap, (cur_d + d, dest, next_state))
    return -1


class Solution(object):
    def getFood(self, grid):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    q = []
    for r in xrange(len(grid)):
        for c in xrange(len(grid[0])):
            if grid[r][c] == "*":
                q.append((r, c))
                break

    result = 0
    while q:
        result += 1
        new_q = []
        for r, c in q:
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if not (
                    0 <= nr < len(grid)
                    and 0 <= nc < len(grid[0])
                    and grid[nr][nc] != "X"
                ):
                    continue
                if grid[nr][nc] == "#":
                    return result
                grid[nr][nc] = "X"
                new_q.append((nr, nc))
        q = new_q
    return -1


import collections


class Solution(object):
    def shortestPathLength(self, graph):

    dp = [[float("inf")] * (len(graph)) for _ in xrange(1 << len(graph))]
    q = collections.deque()
    for i in xrange(len(graph)):
        dp[1 << i][i] = 0
        q.append((1 << i, i))
    while q:
        state, node = q.popleft()
        steps = dp[state][node]
        for nei in graph[node]:
            new_state = state | (1 << nei)
            if dp[new_state][nei] == float("inf"):
                dp[new_state][nei] = steps + 1
                q.append((new_state, nei))
    return min(dp[-1])


import collections


class Solution(object):
    def shortestAlternatingPaths(self, n, red_edges, blue_edges):

    neighbors = [[set() for _ in xrange(2)] for _ in xrange(n)]
    for i, j in red_edges:
        neighbors[i][0].add(j)
    for i, j in blue_edges:
        neighbors[i][1].add(j)
    INF = max(2 * n - 3, 0) + 1
    dist = [[INF, INF] for i in xrange(n)]
    dist[0] = [0, 0]
    q = collections.deque([(0, 0), (0, 1)])
    while q:
        i, c = q.popleft()
        for j in neighbors[i][c]:
            if dist[j][c] != INF:
                continue
            dist[j][c] = dist[i][1 ^ c] + 1
            q.append((j, 1 ^ c))
    return [x if x != INF else -1 for x in map(min, dist)]


class Solution(object):
    def findLengthOfShortestSubarray(self, arr):

    j = -1
    for j in reversed(xrange(1, len(arr))):
        if arr[j - 1] > arr[j]:
            break
    else:
        return 0
    result = j
    for i in xrange(j):
        if i and arr[i] < arr[i - 1]:
            break
        while j < len(arr) and arr[i] > arr[j]:
            j += 1
        result = min(result, (j - i + 1) - 2)
    return result


class Solution2(object):
    def findLengthOfShortestSubarray(self, arr):

    result = 0
    for i in xrange(1, len(arr)):
        if arr[i - 1] <= arr[i]:
            continue
        j = len(arr) - 1
        while (
            j > i
            and (j == len(arr) - 1 or arr[j] <= arr[j + 1])
            and arr[i - 1] <= arr[j]
        ):
            j -= 1
        result = j - i + 1
        break
    for j in reversed(xrange(len(arr) - 1)):
        if arr[j] <= arr[j + 1]:
            continue
        i = 0
        while i < j and (i == 0 or arr[i - 1] <= arr[i]) and arr[i] <= arr[j + 1]:
            i += 1
        result = min(result, j - i + 1)
        break
    return result


import collections


class Solution(object):
    def shortestSubarray(self, A, K):

    accumulated_sum = [0] * (len(A) + 1)
    for i in xrange(len(A)):
        accumulated_sum[i + 1] = accumulated_sum[i] + A[i]

    result = float("inf")
    mono_increasing_q = collections.deque()
    for i, curr in enumerate(accumulated_sum):
        while mono_increasing_q and curr <= accumulated_sum[mono_increasing_q[-1]]:
            mono_increasing_q.pop()
        while (
            mono_increasing_q and curr -
                accumulated_sum[mono_increasing_q[0]] >= K
        ):
            result = min(result, i - mono_increasing_q.popleft())
        mono_increasing_q.append(i)
    return result if result != float("inf") else -1


class Solution(object):
    def findUnsortedSubarray(self, nums):

    n = len(nums)
    left, right = -1, -2
    min_from_right, max_from_left = nums[-1], nums[0]
    for i in xrange(1, n):
        max_from_left = max(max_from_left, nums[i])
        min_from_right = min(min_from_right, nums[n - 1 - i])
        if nums[i] < max_from_left:
            right = i
        if nums[n - 1 - i] > min_from_right:
            left = n - 1 - i


class Solution2(object):
    def findUnsortedSubarray(self, nums):

    a = sorted(nums)
    left, right = 0, len(nums) - 1
    while nums[left] == a[left] or nums[right] == a[right]:
        if right - left <= 1:
            return 0
        if nums[left] == a[left]:
            left += 1
        if nums[right] == a[right]:
            right -= 1
    return right - left + 1


class Solution(object):
    def shortestWay(self, source, target):

    lookup = [[None for _ in xrange(26)] for _ in xrange(len(source) + 1)]
    find_char_next_pos = [None] * 26
    for i in reversed(xrange(len(source))):
        find_char_next_pos[ord(source[i]) - ord("a")] = i + 1
        lookup[i] = list(find_char_next_pos)

    result, start = 1, 0
    for c in target:
        start = lookup[start][ord(c) - ord("a")]
        if start != None:
            continue
        result += 1
        start = lookup[0][ord(c) - ord("a")]
        if start == None:
            return -1
    return result


import collections


class WordDistance(object):

    def __init__(self, words):
    self.wordIndex = collections.defaultdict(list)
    for i in xrange(len(words)):
        self.wordIndex[words[i]].append(i)

    def shortest(self, word1, word2):
    indexes1 = self.wordIndex[word1]
    indexes2 = self.wordIndex[word2]

    i, j, dist = 0, 0, float("inf")
    while i < len(indexes1) and j < len(indexes2):
        dist = min(dist, abs(indexes1[i] - indexes2[j]))
        if indexes1[i] < indexes2[j]:
            i += 1
        else:
            j += 1

    return dist


class Solution(object):

    def shortestWordDistance(self, words, word1, word2):
    dist = float("inf")
    is_same = word1 == word2
    i, index1, index2 = 0, None, None
    while i < len(words):
        if words[i] == word1:
            if is_same and index1 is not None:
                dist = min(dist, abs(index1 - i))
            index1 = i
        elif words[i] == word2:
            index2 = i

        if index1 is not None and index2 is not None:
            dist = min(dist, abs(index1 - index2))
        i += 1

    return dist


class Solution(object):

    def shortestDistance(self, words, word1, word2):
    dist = float("inf")
    i, index1, index2 = 0, None, None
    while i < len(words):
        if words[i] == word1:
            index1 = i
        elif words[i] == word2:
            index2 = i

        if index1 is not None and index2 is not None:
            dist = min(dist, abs(index1 - index2))
        i += 1

    return dist


import random


class Solution(object):
    def __init__(self, nums):

    self.__nums = nums

    def reset(self):

    return self.__nums

    def shuffle(self):

    nums = list(self.__nums)
    for i in xrange(len(nums)):
        j = random.randint(i, len(nums) - 1)
        nums[i], nums[j] = nums[j], nums[i]
    return nums


class Solution(object):
    def restoreString(self, s, indices):

    result = list(s)
    for i, c in enumerate(result):
        if indices[i] == i:
            continue
        move, j = c, indices[i]
        while j != i:
            result[j], move = move, result[j]
            indices[j], j = j, indices[j]
        result[i] = move
    return "".join(result)


import itertools


class Solution2(object):
    def restoreString(self, s, indices):

    result = [""] * len(s)
    for i, c in itertools.izip(indices, s):
        result[i] = c
    return "".join(result)


class Solution(object):
    def shuffle(self, nums, n):

    def dest(i, n):
        return 2 * i if i < n else 2 * (i - n) + 1

    for i in xrange(len(nums)):
        if nums[i] < 0:
            continue
        j = i
        while True:
            j = dest(j, n)
            nums[i], nums[j] = nums[j], nums[i]
            nums[j] = -nums[j]
            if i == j:
                break
    for i in xrange(len(nums)):
        nums[i] = -nums[i]
    return nums


class Solution(object):
    def similarRGB(self, color):

    def rounding(color):
        q, r = divmod(int(color, 16), 17)
        if r > 8:
            q += 1
        return "{:02x}".format(17 * q)

    return "#" + rounding(color[1:3]) + rounding(color[3:5]) + rounding(color[5:7])


import collections
import itertools


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.__size = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    self.__size -= 1
    return True

    def size(self):
    return self.__size


class Solution(object):
    def numSimilarGroups(self, A):

    def isSimilar(a, b):
        diff = 0
        for x, y in itertools.izip(a, b):
            if x != y:
                diff += 1
                if diff > 2:
                    return False
        return diff == 2

    N, L = len(A), len(A[0])
    union_find = UnionFind(N)
    if N < L * L:
        for (i1, word1), (i2, word2) in itertools.combinations(enumerate(A), 2):
            if isSimilar(word1, word2):
                union_find.union_set(i1, i2)
    else:
        buckets = collections.defaultdict(list)
        lookup = set()
        for i in xrange(len(A)):
            word = list(A[i])
            if A[i] not in lookup:
                buckets[A[i]].append(i)
                lookup.add(A[i])
            for j1, j2 in itertools.combinations(xrange(L), 2):
                word[j1], word[j2] = word[j2], word[j1]
                buckets["".join(word)].append(i)
                word[j1], word[j2] = word[j2], word[j1]
        for word in A:
            for i1, i2 in itertools.combinations(buckets[word], 2):
                union_find.union_set(i1, i2)
    return union_find.size()


import fractions


class Solution(object):
    def simplifiedFractions(self, n):

    lookup = set()
    for b in xrange(1, n + 1):
        for a in xrange(1, b):
            g = fractions.gcd(a, b)
            lookup.add((a // g, b // g))
    return map(lambda x: "{}/{}".format(*x), lookup)


class Solution(object):

    def simplifyPath(self, path):
    stack, tokens = [], path.split("/")
    for token in tokens:
        if token == ".." and stack:
            stack.pop()
        elif token != ".." and token != "." and token:
            stack.append(token)
    return "/" + "/".join(stack)


class Solution(object):
    def singleNonDuplicate(self, nums):

    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) / 2
        if not (
            mid % 2 == 0 and mid + 1 < len(nums) and nums[mid] == nums[mid + 1]
        ) and not (mid % 2 == 1 and nums[mid] == nums[mid - 1]):
            right = mid - 1
        else:
            left = mid + 1
    return nums[left]


import collections


class Solution(object):

    def singleNumber(self, A):
    one, two = 0, 0
    for x in A:
        one, two = (~x & one) | (x & ~one & ~two), (~x & two) | (x & one)
    return one


class Solution2(object):

    def singleNumber(self, A):
    one, two, carry = 0, 0, 0
    for x in A:
        two |= one & x
        one ^= x
        carry = one & two
        one &= ~carry
        two &= ~carry
    return one


class Solution3(object):
    def singleNumber(self, nums):

    return (
        collections.Counter(list(set(nums)) * 3) - collections.Counter(nums)
    ).keys()[0]


class Solution4(object):
    def singleNumber(self, nums):

    return (sum(set(nums)) * 3 - sum(nums)) / 2


class SolutionEX(object):

    def singleNumber(self, A):
    one, two, three = 0, 0, 0
    for x in A:
        one, two, three = (
            (~x & one) | (x & ~one & ~two & ~three),
            (~x & two) | (x & one),
            (~x & three) | (x & two),
        )
    return two


import operator
import collections


class Solution(object):

    def singleNumber(self, nums):
    x_xor_y = reduce(operator.xor, nums)
    bit = x_xor_y & -x_xor_y
    result = [0, 0]
    for i in nums:
        result[bool(i & bit)] ^= i
    return result


class Solution2(object):

    def singleNumber(self, nums):
    x_xor_y = 0
    for i in nums:
        x_xor_y ^= i

    bit = x_xor_y & ~(x_xor_y - 1)

    x = 0
    for i in nums:
        if i & bit:
            x ^= i

    return [x, x ^ x_xor_y]


class Solution3(object):
    def singleNumber(self, nums):

    return [
        x[0]
        for x in sorted(
            collections.Counter(nums).items(), key=lambda i: i[1], reverse=False
        )[:2]
    ]


import operator
from functools import reduce


class Solution(object):

    def singleNumber(self, A):
    return reduce(operator.xor, A)


class Solution(object):
    def calculateTime(self, keyboard, word):

    lookup = {c: i for i, c in enumerate(keyboard)}
    result, prev = 0, 0
    for c in word:
        result += abs(lookup[c] - prev)
        prev = lookup[c]
    return result


import heapq
import itertools


class Solution(object):
    def slidingPuzzle(self, board):

    def dot(p1, p2):
        return p1[0] * p2[0] + p1[1] * p2[1]

    def heuristic_estimate(board, R, C, expected):
        result = 0
        for i in xrange(R):
            for j in xrange(C):
                val = board[C * i + j]
                if val == 0:
                    continue
                r, c = expected[val]
                result += abs(r - i) + abs(c - j)
        return result

    R, C = len(board), len(board[0])
    begin = tuple(itertools.chain(*board))
    end = tuple(range(1, R * C) + [0])
    expected = {
        (C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)
    }

    min_steps = heuristic_estimate(begin, R, C, expected)
    closer, detour = [(begin.index(0), begin)], []
    lookup = set()
    while True:
        if not closer:
            if not detour:
                return -1
            min_steps += 2
            closer, detour = detour, closer
        zero, board = closer.pop()
        if board == end:
            return min_steps
        if board not in lookup:
            lookup.add(board)
            r, c = divmod(zero, C)
            for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                i, j = r + direction[0], c + direction[1]
                if 0 <= i < R and 0 <= j < C:
                    new_zero = i * C + j
                    tmp = list(board)
                    tmp[zero], tmp[new_zero] = tmp[new_zero], tmp[zero]
                    new_board = tuple(tmp)
                    r2, c2 = expected[board[new_zero]]
                    r1, c1 = divmod(zero, C)
                    r0, c0 = divmod(new_zero, C)
                    is_closer = dot((r1 - r0, c1 - c0), (r2 - r0, c2 - c0)) > 0
                    (closer if is_closer else detour).append(
                        (new_zero, new_board))
    return min_steps


class Solution2(object):
    def slidingPuzzle(self, board):

    def heuristic_estimate(board, R, C, expected):
        result = 0
        for i in xrange(R):
            for j in xrange(C):
                val = board[C * i + j]
                if val == 0:
                    continue
                r, c = expected[val]
                result += abs(r - i) + abs(c - j)
        return result

    R, C = len(board), len(board[0])
    begin = tuple(itertools.chain(*board))
    end = tuple(range(1, R * C) + [0])
    end_wrong = tuple(range(1, R * C - 2) + [R * C - 1, R * C - 2, 0])
    expected = {
        (C * i + j + 1) % (R * C): (i, j) for i in xrange(R) for j in xrange(C)
    }

    min_heap = [(0, 0, begin.index(0), begin)]
    lookup = {begin: 0}
    while min_heap:
        f, g, zero, board = heapq.heappop(min_heap)
        if board == end:
            return g
        if board == end_wrong:
            return -1
        if f > lookup[board]:
            continue

        r, c = divmod(zero, C)
        for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):
            i, j = r + direction[0], c + direction[1]
            if 0 <= i < R and 0 <= j < C:
                new_zero = C * i + j
                tmp = list(board)
                tmp[zero], tmp[new_zero] = tmp[new_zero], tmp[zero]
                new_board = tuple(tmp)
                f = g + 1 + heuristic_estimate(new_board, R, C, expected)
                if f < lookup.get(new_board, float("inf")):
                    lookup[new_board] = f
                    heapq.heappush(min_heap, (f, g + 1, new_zero, new_board))
    return -1


from collections import deque


class Solution(object):
    def maxSlidingWindow(self, nums, k):

    result, dq = [], deque()
    for i in xrange(len(nums)):
        if dq and i - dq[0] == k:
            dq.popleft()
        while dq and nums[dq[-1]] <= nums[i]:
            dq.pop()
        dq.append(i)
        if i >= k - 1:
            result.append(nums[dq[0]])
    return result


import collections


class Solution(object):
    def slowestKey(self, releaseTimes, keysPressed):

    result, lookup = "a", collections.Counter()
    for i, c in enumerate(keysPressed):
        lookup[c] = max(
            lookup[c], releaseTimes[i] - (releaseTimes[i - 1] if i > 0 else 0)
        )
        if lookup[c] > lookup[result] or lookup[c] == lookup[result] and c > result:
            result = c
    return result


class Solution(object):
    def findSmallestRegion(self, regions, region1, region2):

    parents = {
        region[i]: region[0] for region in regions for i in xrange(1, len(region))
    }
    lookup = {region1}
    while region1 in parents:
        region1 = parents[region1]
        lookup.add(region1)
    while region2 not in lookup:
        region2 = parents[region2]
    return region2


import math


class Solution(object):
    def smallestGoodBase(self, n):

    num = int(n)
    max_len = int(math.log(num, 2))
    for l in xrange(max_len, 1, -1):
        b = int(num ** (l ** -1))
        if (b ** (l + 1) - 1) // (b - 1) == num:
            return str(b)
    return str(num - 1)


class Solution(object):
    def smallestRepunitDivByK(self, K):

    if K % 2 == 0 or K % 5 == 0:
        return -1

    result = 0
    for N in xrange(1, K + 1):
        result = (result * 10 + 1) % K
        if not result:
            return N
    assert False
    return -1


class Solution(object):
    def smallestRangeI(self, A, K):

    return max(0, max(A) - min(A) - 2 * K)


class Solution(object):
    def smallestRangeII(self, A, K):

    A.sort()
    result = A[-1] - A[0]
    for i in xrange(len(A) - 1):
        result = min(result, max(A[-1] - K, A[i] +
                     K) - min(A[0] + K, A[i + 1] - K))
    return result


import heapq


class Solution(object):
    def smallestRange(self, nums):

    left, right = float("inf"), float("-inf")
    min_heap = []
    for row in nums:
        left = min(left, row[0])
        right = max(right, row[0])
        it = iter(row)
        heapq.heappush(min_heap, (next(it, None), it))

    result = (left, right)
    while min_heap:
        (val, it) = heapq.heappop(min_heap)
        val = next(it, None)
        if val is None:
            break
        heapq.heappush(min_heap, (val, it))
        left, right = min_heap[0][0], max(right, val)
        if right - left < result[1] - result[0]:
            result = (left, right)
    return result


import bisect
import itertools


class Solution(object):
    def minArea(self, image, x, y):

    def binarySearch(left, right, find, image, has_one):
        while left <= right:
            mid = left + (right - left) / 2
            if find(image, has_one, mid):
                right = mid - 1
            else:
                left = mid + 1
        return left

    searchColumns = (
        lambda image, has_one, mid: any(
            [int(row[mid]) for row in image]) == has_one
    )
    left = binarySearch(0, y - 1, searchColumns, image, True)
    right = binarySearch(y + 1, len(image[0]) - 1, searchColumns, image, False)

    searchRows = (
        lambda image, has_one, mid: any(
            itertools.imap(int, image[mid])) == has_one
    )
    top = binarySearch(0, x - 1, searchRows, image, True)
    bottom = binarySearch(x + 1, len(image) - 1, searchRows, image, False)

    return (right - left) * (bottom - top)


class Solution(object):
    def bestRotation(self, A):

    N = len(A)
    change = [1] * N
    for i in xrange(N):
        change[(i - A[i] + 1) % N] -= 1
    for i in xrange(1, N):
        change[i] += change[i - 1]
    return change.index(max(change))


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def smallestFromLeaf(self, root):

    def dfs(node, candidate, result):
        if not node:
            return

        candidate.append(chr(ord("a") + node.val))
        if not node.left and not node.right:
            result[0] = min(result[0], "".join(reversed(candidate)))
        dfs(node.left, candidate, result)
        dfs(node.right, candidate, result)
        candidate.pop()

    result = ["~"]
    dfs(root, [], result)
    return result[0]


class Solution(object):
    def getSmallestString(self, n, k):

    MAX_DIFF = ord("z") - ord("a")

    k -= n
    result = ["a"] * n
    for i in reversed(xrange(n)):
        tmp = min(k, MAX_DIFF)
        result[i] = chr(ord("a") + tmp)
        k -= tmp
        if k == 0:
            break
    return "".join(result)


import collections


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[max(x_root, y_root)] = min(x_root, y_root)
    return True


class Solution(object):
    def smallestStringWithSwaps(self, s, pairs):

    union_find = UnionFind(len(s))
    for x, y in pairs:
        union_find.union_set(x, y)
    components = collections.defaultdict(list)
    for i in xrange(len(s)):
        components[union_find.find_set(i)].append(s[i])
    for i in components.iterkeys():
        components[i].sort(reverse=True)
    result = []
    for i in xrange(len(s)):
        result.append(components[union_find.find_set(i)].pop())
    return "".join(result)


import itertools


class Solution2(object):
    def smallestStringWithSwaps(self, s, pairs):

    def dfs(i, adj, lookup, component):
        lookup.add(i)
        component.append(i)
        for j in adj[i]:
            if j in lookup:
                continue
            dfs(j, adj, lookup, component)

    adj = collections.defaultdict(list)
    for i, j in pairs:
        adj[i].append(j)
        adj[j].append(i)
    lookup = set()
    result = list(s)
    for i in xrange(len(s)):
        if i in lookup:
            continue
        component = []
        dfs(i, adj, lookup, component)
        component.sort()
        chars = sorted(result[k] for k in component)
        for comp, char in itertools.izip(component, chars):
            result[comp] = char
    return "".join(result)


import collections


class Solution(object):
    def smallestSubsequence(self, text):

    count = collections.Counter(text)

    lookup, stk = set(), []
    for c in text:
        if c not in lookup:
            while stk and stk[-1] > c and count[stk[-1]]:
                lookup.remove(stk.pop())
            stk += c
            lookup.add(c)
        count[c] -= 1
    return "".join(stk)


import collections


class Solution(object):
    def subtreeWithAllDeepest(self, root):

    Result = collections.namedtuple("Result", ("node", "depth"))

    def dfs(node):
        if not node:
            return Result(None, 0)
        left, right = dfs(node.left), dfs(node.right)
        if left.depth > right.depth:
            return Result(left.node, left.depth + 1)
        if left.depth < right.depth:
            return Result(right.node, right.depth + 1)
        return Result(node, left.depth + 1)

    return dfs(root).node


class Solution(object):
    def smallestSufficientTeam(self, req_skills, people):

    lookup = {v: i for i, v in enumerate(req_skills)}
    dp = {0: []}
    for i, p in enumerate(people):
        his_skill_set = 0
        for skill in p:
            if skill in lookup:
                his_skill_set |= 1 << lookup[skill]
        for skill_set, people in dp.items():
            with_him = skill_set | his_skill_set
            if with_him == skill_set:
                continue
            if with_him not in dp or len(dp[with_him]) > len(people) + 1:
                dp[with_him] = people + [i]
    return dp[(1 << len(req_skills)) - 1]


import collections


class Solution(object):
    def snakesAndLadders(self, board):

    def coordinate(n, s):
        a, b = divmod(s - 1, n)
        r = n - 1 - a
        c = b if r % 2 != n % 2 else n - 1 - b
        return r, c

    n = len(board)
    lookup = {1: 0}
    q = collections.deque([1])
    while q:
        s = q.popleft()
        if s == n * n:
            return lookup[s]
        for s2 in xrange(s + 1, min(s + 6, n * n) + 1):
            r, c = coordinate(n, s2)
            if board[r][c] != -1:
                s2 = board[r][c]
            if s2 not in lookup:
                lookup[s2] = lookup[s] + 1
                q.append(s2)
    return -1


import collections
import bisect


class SnapshotArray(object):
    def __init__(self, length):

    self.__A = collections.defaultdict(lambda: [[0, 0]])
    self.__snap_id = 0

    def set(self, index, val):

    if self.__A[index][-1][0] == self.__snap_id:
        self.__A[index][-1][1] = val
    else:
        self.__A[index].append([self.__snap_id, val])

    def snap(self):

    self.__snap_id += 1
    return self.__snap_id - 1

    def get(self, index, snap_id):

    i = bisect.bisect_left(self.__A[index], [snap_id + 1, float("-inf")]) - 1
    return self.__A[index][i][1]


import re


class Solution(object):
    def solveEquation(self, equation):

    a, b, side = 0, 0, 1
    for eq, sign, num, isx in re.findall("(=)|([-+]?)(\d*)(x?)", equation):
        if eq:
            side = -1
        elif isx:
            a += side * int(sign + "1") * int(num or 1)
        elif num:
            b -= side * int(sign + num)
    return "x=%d" % (b / a) if a else "No solution" if b else "Infinite solutions"


class Solution(object):
    def sortArray(self, nums):

    def mergeSort(start, end, nums):
        if end - start <= 1:
            return
        mid = start + (end - start) // 2
        mergeSort(start, mid, nums)
        mergeSort(mid, end, nums)
        right = mid
        tmp = []
        for left in xrange(start, mid):
            while right < end and nums[right] < nums[left]:
                tmp.append(nums[right])
                right += 1
            tmp.append(nums[left])
        nums[start: start + len(tmp)] = tmp

    mergeSort(0, len(nums), nums)
    return nums


import random


class Solution2(object):
    def sortArray(self, nums):

    def kthElement(nums, left, k, right, compare):
        def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in xrange(left, right):
                if compare(nums[i], nums[right]):
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        right -= 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            new_pivot_idx = PartitionAroundPivot(
                left, right, pivot_idx, nums, compare
            )
            if new_pivot_idx == k:
                return
            elif new_pivot_idx > k:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    def quickSort(start, end, nums):
        if end - start <= 1:
            return
        mid = start + (end - start) / 2
        kthElement(nums, start, mid, end, lambda a, b: a < b)
        quickSort(start, mid, nums)
        quickSort(mid, end, nums)

    quickSort(0, len(nums), nums)
    return nums


import collections


class Solution(object):
    def frequencySort(self, nums):

    count = collections.Counter(nums)
    return sorted(nums, key=lambda x: (count[x], -x))


class Solution(object):
    def sortArrayByParityII(self, A):

    j = 1
    for i in xrange(0, len(A), 2):
        if A[i] % 2:
            while A[j] % 2:
                j += 2
            A[i], A[j] = A[j], A[i]
    return A


class Solution(object):
    def sortArrayByParity(self, A):

    i = 0
    for j in xrange(len(A)):
        if A[j] % 2 == 0:
            A[i], A[j] = A[j], A[i]
            i += 1
    return A


import collections


class Solution(object):
    def frequencySort(self, s):

    freq = collections.defaultdict(int)
    for c in s:
        freq[c] += 1

    counts = [""] * (len(s) + 1)
    for c in freq:
        counts[freq[c]] += c

    result = ""
    for count in reversed(xrange(len(counts) - 1)):
        for c in counts[count]:
            result += c * count

    return result


class Solution(object):
    def sortColors(self, nums):

    def triPartition(nums, target):
        i, left, right = 0, 0, len(nums) - 1
        while i <= right:
            if nums[i] > target:
                nums[i], nums[right] = nums[right], nums[i]
                right -= 1
            else:
                if nums[i] < target:
                    nums[left], nums[i] = nums[i], nums[left]
                    left += 1
                i += 1

    triPartition(nums, 1)


import collections


class Solution(object):
    def sortFeatures(self, features, responses):

    features_set = set(features)
    order = {word: i for i, word in enumerate(features)}
    freq = collections.defaultdict(int)
    for r in responses:
        for word in set(r.split(" ")):
            if word in features_set:
                freq[word] += 1
    features.sort(key=lambda x: (-freq[x], order[x]))
    return features


class Solution(object):
    def sortByBits(self, arr):

    def popcount(n):
        result = 0
        while n:
            n &= n - 1
            result += 1
        return result

    arr.sort(key=lambda x: (popcount(x), x))
    return arr


import random


class Solution(object):
    dp = {}

    def getKth(self, lo, hi, k):

    def nth_element(nums, n, compare=lambda a, b: a < b):
        def partition_around_pivot(left, right, pivot_idx, nums, compare):
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in xrange(left, right):
                if compare(nums[i], nums[right]):
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            new_pivot_idx = partition_around_pivot(
                left, right, pivot_idx, nums, compare
            )
            if new_pivot_idx == n:
                return
            elif new_pivot_idx > n:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    def power_value(x):
        y, result = x, 0
        while x > 1 and x not in Solution.dp:
            result += 1
            if x % 2:
                x = 3 * x + 1
            else:
                x //= 2
        Solution.dp[y] = result + (Solution.dp[x] if x > 1 else 0)
        return Solution.dp[y], y

    arr = map(power_value, range(lo, hi + 1))
    nth_element(arr, k - 1)
    return arr[k - 1][1]


class Solution2(object):
    dp = {}

    def getKth(self, lo, hi, k):

    def power_value(x):
        y, result = x, 0
        while x > 1 and x not in Solution2.dp:
            result += 1
            if x % 2:
                x = 3 * x + 1
            else:
                x //= 2
        Solution2.dp[y] = result + (Solution2.dp[x] if x > 1 else 0)
        return Solution2.dp[y], y

    return sorted(range(lo, hi + 1), key=power_value)[k - 1]


import collections


class Topo(object):
    def __init__(self):
    self.__nodes = set()
    self.__in_degree = collections.defaultdict(set)
    self.__out_degree = collections.defaultdict(set)

    def add_node(self, node):
    self.__nodes.add(node)

    def add_edge(self, src, dst):
    self.add_node(src), self.add_node(dst)
    self.__in_degree[dst].add(src)
    self.__out_degree[src].add(dst)

    def sort(self):
    q = collections.deque()
    result = []
    for node in self.__nodes:
        if node not in self.__in_degree:
            q.append(node)
    while q:
        node = q.popleft()
        result.append(node)
        for nei in self.__out_degree[node]:
            self.__in_degree[nei].remove(node)
            if not self.__in_degree[nei]:
                self.__in_degree.pop(nei)
                q.append(nei)
    if len(result) < len(self.__nodes):
        return
    return result


class Solution(object):
    def sortItems(self, n, m, group, beforeItems):

    for i in xrange(n):
        if group[i] == -1:
            group[i] = m
            m += 1
    global_group = Topo()
    for i in xrange(m):
        global_group.add_node(i)
    local_groups = collections.defaultdict(Topo)
    for i in xrange(n):
        local_groups[group[i]].add_node(i)
    for i in xrange(n):
        for j in beforeItems[i]:
            if group[i] == group[j]:
                local_groups[group[i]].add_edge(j, i)
            else:
                global_group.add_edge(group[j], group[i])
    result = []
    global_order = global_group.sort()
    if global_order is None:
        return []
    for i in global_order:
        local_order = local_groups[i].sort()
        if local_order is None:
            return []
        for x in local_order:
            result.append(x)
    return result


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self:
        return "{} -> {}".format(self.val, repr(self.next))


class Solution(object):

    def sortList(self, head):
    if head == None or head.next == None:
        return head

    fast, slow, prev = head, head, None
    while fast != None and fast.next != None:
        prev, fast, slow = slow, fast.next.next, slow.next
    prev.next = None

    sorted_l1 = self.sortList(head)
    sorted_l2 = self.sortList(slow)

    return self.mergeTwoLists(sorted_l1, sorted_l2)

    def mergeTwoLists(self, l1, l2):
    dummy = ListNode(0)

    cur = dummy
    while l1 != None and l2 != None:
        if l1.val <= l2.val:
            cur.next, cur, l1 = l1, l1, l1.next
        else:
            cur.next, cur, l2 = l2, l2, l2.next

    if l1 != None:
        cur.next = l1
    if l2 != None:
        cur.next = l2

    return dummy.next


import collections


class Solution(object):
    def diagonalSort(self, mat):

    lookup = collections.defaultdict(list)
    for i in xrange(len(mat)):
        for j in xrange(len(mat[0])):
            lookup[i - j].append(mat[i][j])
    for v in lookup.itervalues():
        v.sort()
    for i in reversed(xrange(len(mat))):
        for j in reversed(xrange(len(mat[0]))):
            mat[i][j] = lookup[i - j].pop()
    return mat


class Solution(object):
    def sortTransformedArray(self, nums, a, b, c):

    def f(x, a, b, c): return a * x * x + b * x + c

    result = []
    if not nums:
        return result

    left, right = 0, len(nums) - 1
    d = -1 if a > 0 else 1
    while left <= right:
        if d * f(nums[left], a, b, c) < d * f(nums[right], a, b, c):
            result.append(f(nums[left], a, b, c))
            left += 1
        else:
            result.append(f(nums[right], a, b, c))
            right -= 1

    return result[::d]


class Solution(object):
    def soupServings(self, N):

    def dp(a, b, lookup):
        if (a, b) in lookup:
            return lookup[a, b]
        if a <= 0 and b <= 0:
            return 0.5
        if a <= 0:
            return 1.0
        if b <= 0:
            return 0.0
        lookup[a, b] = 0.25 * (
            dp(a - 4, b, lookup)
            + dp(a - 3, b - 1, lookup)
            + dp(a - 2, b - 2, lookup)
            + dp(a - 1, b - 3, lookup)
        )
        return lookup[a, b]

    if N >= 4800:
        return 1.0
    lookup = {}
    N = (N + 24) // 25
    return dp(N, N, lookup)


class Solution(object):
    def multiply(self, A, B):

    m, n, l = len(A), len(A[0]), len(B[0])
    res = [[0 for _ in xrange(l)] for _ in xrange(m)]
    for i in xrange(m):
        for k in xrange(n):
            if A[i][k]:
                for j in xrange(l):
                    res[i][j] += A[i][k] * B[k][j]
    return res


class Solution(object):
    def specialArray(self, nums):

    MAX_NUM = 1000
    count = [0] * (MAX_NUM + 1)
    for num in nums:
        count[num] += 1
    n = len(nums)
    for i in xrange(len(count)):
        if i == n:
            return i
        n -= count[i]
    return -1


class Solution2(object):
    def specialArray(self, nums):

    MAX_NUM = 1000

    def inplace_counting_sort(nums, reverse=False):
        count = [0] * (MAX_NUM + 1)
        for num in nums:
            count[num] += 1
        for i in xrange(1, len(count)):
            count[i] += count[i - 1]
        for i in reversed(xrange(len(nums))):
            if nums[i] < 0:
                continue
            while i != count[nums[i]] - 1:
                count[nums[i]] -= 1
                nums[count[nums[i]]], nums[i] = ~nums[i], nums[count[nums[i]]]
            count[nums[i]] -= 1
            nums[i] = ~nums[i]
        for i in xrange(len(nums)):
            nums[i] = ~nums[i]
        if reverse:
            nums.reverse()

    inplace_counting_sort(nums, reverse=True)
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] <= mid:
            right = mid - 1
        else:
            left = mid + 1
    return -1 if left < len(nums) and nums[left] == left else left


class Solution3(object):
    def specialArray(self, nums):

    MAX_NUM = 1000

    def counting_sort(nums, reverse=False):
        count = [0] * (MAX_NUM + 1)
        for num in nums:
            count[num] += 1
        for i in xrange(1, len(count)):
            count[i] += count[i - 1]
        result = [0] * len(nums)
        if not reverse:
            for num in reversed(nums):
                count[num] -= 1
                result[count[num]] = num
        else:
            for num in nums:
                count[num] -= 1
                result[count[num]] = num
            result.reverse()
        return result

    nums = counting_sort(nums, reverse=True)
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] <= mid:
            right = mid - 1
        else:
            left = mid + 1
    return -1 if left < len(nums) and nums[left] == left else left


class Solution4(object):
    def specialArray(self, nums):

    nums.sort(reverse=True)
    for i in xrange(len(nums)):
        if nums[i] <= i:
            break
    else:
        i += 1
    return -1 if i < len(nums) and nums[i] == i else i


class Solution(object):
    def makeLargestSpecial(self, S):

    result = []
    anchor = count = 0
    for i, v in enumerate(S):
        count += 1 if v == "1" else -1
        if count == 0:
            result.append("1{}0".format(
                self.makeLargestSpecial(S[anchor + 1: i])))
            anchor = i + 1
    result.sort(reverse=True)
    return "".join(result)


class Solution(object):
    def numSpecial(self, mat):

    rows, cols = [0] * len(mat), [0] * len(mat[0])
    for i in xrange(len(rows)):
        for j in xrange(len(cols)):
            if mat[i][j]:
                rows[i] += 1
                cols[j] += 1
    result = 0
    for i in xrange(len(rows)):
        for j in xrange(len(cols)):
            if mat[i][j] == rows[i] == cols[j] == 1:
                result += 1
    return result


class Solution(object):

    def generateMatrix(self, n):
    matrix = [[0 for _ in xrange(n)] for _ in xrange(n)]

    left, right, top, bottom, num = 0, n - 1, 0, n - 1, 1

    while left <= right and top <= bottom:
        for j in xrange(left, right + 1):
            matrix[top][j] = num
            num += 1
        for i in xrange(top + 1, bottom):
            matrix[i][right] = num
            num += 1
        for j in reversed(xrange(left, right + 1)):
            if top < bottom:
                matrix[bottom][j] = num
                num += 1
        for i in reversed(xrange(top + 1, bottom)):
            if left < right:
                matrix[i][left] = num
                num += 1
        left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1

    return matrix


class Solution(object):
    def spiralMatrixIII(self, R, C, r0, c0):

    r, c = r0, c0
    result = [[r, c]]
    x, y, n, i = 0, 1, 0, 0
    while len(result) < R * C:
        r, c, i = r + x, c + y, i + 1
        if 0 <= r < R and 0 <= c < C:
            result.append([r, c])
        if i == n // 2 + 1:
            x, y, n, i = y, -x, n + 1, 0
    return result


class Solution(object):

    def spiralOrder(self, matrix):
    result = []
    if matrix == []:
        return result

    left, right, top, bottom = 0, len(matrix[0]) - 1, 0, len(matrix) - 1

    while left <= right and top <= bottom:
        for j in xrange(left, right + 1):
            result.append(matrix[top][j])
        for i in xrange(top + 1, bottom):
            result.append(matrix[i][right])
        for j in reversed(xrange(left, right + 1)):
            if top < bottom:
                result.append(matrix[bottom][j])
        for i in reversed(xrange(top + 1, bottom)):
            if left < right:
                result.append(matrix[i][left])
        left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1

    return result


class Solution(object):
    def balancedStringSplit(self, s):

    result, count = 0, 0
    for c in s:
        count += 1 if c == "L" else -1
        if count == 0:
            result += 1
    return result


class Solution(object):
    def maxUniqueSplit(self, s):

    def popcount(n):
        count = 0
        while n:
            n &= n - 1
            count += 1
        return count

    result = 1
    total = 2 ** (len(s) - 1)
    mask = 0
    while mask < total:
        if popcount(mask) < result:
            mask += 1
            continue
        lookup, curr, base = set(), [], total // 2
        for i in xrange(len(s)):
            curr.append(s[i])
            if (mask & base) or base == 0:
                if "".join(curr) in lookup:
                    mask = (
                        (mask | (base - 1)) + 1 if base else mask + 1
                    )
                    break
                lookup.add("".join(curr))
                curr = []
            base >>= 1
        else:
            result = max(result, len(lookup))
            mask += 1
    return result


class Solution(object):
    def isPossible(self, nums):

    pre, cur = float("-inf"), 0
    cnt1, cnt2, cnt3 = 0, 0, 0
    i = 0
    while i < len(nums):
        cnt = 0
        cur = nums[i]
        while i < len(nums) and cur == nums[i]:
            cnt += 1
            i += 1

        if cur != pre + 1:
            if cnt1 != 0 or cnt2 != 0:
                return False
            cnt1, cnt2, cnt3 = cnt, 0, 0
        else:
            if cnt < cnt1 + cnt2:
                return False
            cnt1, cnt2, cnt3 = (
                max(0, cnt - (cnt1 + cnt2 + cnt3)),
                cnt1,
                cnt2 + min(cnt3, cnt - (cnt1 + cnt2)),
            )
        pre = cur
    return cnt1 == 0 and cnt2 == 0


class Solution(object):
    def splitIntoFibonacci(self, S):

    def startswith(S, k, x):
        y = 0
        for i in xrange(k, len(S)):
            y = 10 * y + int(S[i])
            if y == x:
                return i - k + 1
            elif y > x:
                break
        return 0

    MAX_INT = 2 ** 31 - 1
    a = 0
    for i in xrange(len(S) - 2):
        a = 10 * a + int(S[i])
        b = 0
        for j in xrange(i + 1, len(S) - 1):
            b = 10 * b + int(S[j])
            fib = [a, b]
            k = j + 1
            while k < len(S):
                if fib[-2] > MAX_INT - fib[-1]:
                    break
                c = fib[-2] + fib[-1]
                length = startswith(S, k, c)
                if length == 0:
                    break
                fib.append(c)
                k += length
            else:
                return fib
            if b == 0:
                break
        if a == 0:
            break
    return []


class Solution(object):
    def splitArray(self, nums, m):

    def check(nums, m, s):
        cnt, curr_sum = 1, 0
        for num in nums:
            curr_sum += num
            if curr_sum > s:
                curr_sum = num
                cnt += 1
        return cnt <= m

    left, right = max(nums), sum(nums)
    while left <= right:
        mid = left + (right - left) // 2
        if check(nums, m, mid):
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution(object):
    def splitArray(self, nums):

    if len(nums) < 7:
        return False

    accumulated_sum = [0] * len(nums)
    accumulated_sum[0] = nums[0]
    for i in xrange(1, len(nums)):
        accumulated_sum[i] = accumulated_sum[i - 1] + nums[i]
    for j in xrange(3, len(nums) - 3):
        lookup = set()
        for i in xrange(1, j - 1):
            if (
                accumulated_sum[i - 1]
                == accumulated_sum[j - 1] - accumulated_sum[i]
            ):
                lookup.add(accumulated_sum[i - 1])
        for k in xrange(j + 2, len(nums) - 1):
            if (
                accumulated_sum[-1] - accumulated_sum[k]
                == accumulated_sum[k - 1] - accumulated_sum[j]
                and accumulated_sum[k - 1] - accumulated_sum[j] in lookup
            ):
                return True
    return False


class Solution(object):
    def splitArraySameAverage(self, A):

    def possible(total, n):
        for i in xrange(1, n // 2 + 1):
            if total * i % n == 0:
                return True
        return False

    n, s = len(A), sum(A)
    if not possible(n, s):
        return False

    sums = [set() for _ in xrange(n // 2 + 1)]
    sums[0].add(0)
    for num in A:
        for i in reversed(xrange(1, n // 2 + 1)):
            for prev in sums[i - 1]:
                sums[i].add(prev + num)
    for i in xrange(1, n // 2 + 1):
        if s * i % n == 0 and s * i // n in sums[i]:
            return True
    return False


class Solution(object):
    def splitBST(self, root, V):

    if not root:
        return None, None
    elif root.val <= V:
        result = self.splitBST(root.right, V)
        root.right = result[0]
        return root, result[1]
    else:
        result = self.splitBST(root.left, V)
        root.left = result[1]
        return result[0], root


class Solution(object):
    def splitLoopedString(self, strs):

    tmp = []
    for s in strs:
        tmp += max(s, s[::-1])
    s = "".join(tmp)

    result, st = "a", 0
    for i in xrange(len(strs)):
        body = "".join([s[st + len(strs[i]):], s[0:st]])
        for p in strs[i], strs[i][::-1]:
            for j in xrange(len(strs[i])):
                if p[j] >= result[0]:
                    result = max(result, "".join([p[j:], body, p[:j]]))
        st += len(strs[i])
    return result


class Solution(object):
    def splitListToParts(self, root, k):

    n = 0
    curr = root
    while curr:
        curr = curr.next
        n += 1
    width, remainder = divmod(n, k)

    result = []
    curr = root
    for i in xrange(k):
        head = curr
        for j in xrange(width - 1 + int(i < remainder)):
            if curr:
                curr = curr.next
        if curr:
            curr.next, curr = None, curr.next
        result.append(head)
    return result


class Solution(object):
    def checkPalindromeFormation(self, a, b):

    def is_palindrome(s, i, j):
        while i < j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True

    def check(a, b):
        i, j = 0, len(b) - 1
        while i < j:
            if a[i] != b[j]:
                return is_palindrome(a, i, j) or is_palindrome(b, i, j)
            i += 1
            j -= 1
        return True

    return check(a, b) or check(b, a)


class Solution(object):
    def mySqrt(self, x):

    if x < 2:
        return x

    left, right = 1, x // 2
    while left <= right:
        mid = left + (right - left) // 2
        if mid > x / mid:
            right = mid - 1
        else:
            left = mid + 1

    return left - 1


import bisect


class Solution(object):
    def sortedSquares(self, A):

    right = bisect.bisect_left(A, 0)
    left = right - 1
    result = []
    while 0 <= left or right < len(A):
        if right == len(A) or (0 <= left and A[left] ** 2 < A[right] ** 2):
            result.append(A[left] ** 2)
            left -= 1
        else:
            result.append(A[right] ** 2)
            right += 1
    return result


class Solution(object):
    def minDistance(self, height, width, tree, squirrel, nuts):

    def distance(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    result = 0
    d = float("inf")
    for nut in nuts:
        result += distance(nut, tree) * 2
        d = min(d, distance(nut, squirrel) - distance(nut, tree))
    return result + d


import collections


class Solution(object):
    def movesToStamp(self, stamp, target):
    M, N = len(stamp), len(target)

    q = collections.deque()
    lookup = [False] * N
    result = []
    A = []
    for i in xrange(N - M + 1):
        made, todo = set(), set()
        for j, c in enumerate(stamp):
            if c == target[i + j]:
                made.add(i + j)
            else:
                todo.add(i + j)
        A.append((made, todo))
        if todo:
            continue
        result.append(i)
        for m in made:
            if lookup[m]:
                continue
            q.append(m)
            lookup[m] = True

    while q:
        i = q.popleft()
        for j in xrange(max(0, i - M + 1), min(N - M, i) + 1):
            made, todo = A[j]
            if i not in todo:
                continue
            todo.discard(i)
            if todo:
                continue
            result.append(j)
            for m in made:
                if lookup[m]:
                    continue
                q.append(m)
                lookup[m] = True
    return result[::-1] if all(lookup) else []


import bisect


class Solution(object):
    def sampleStats(self, count):

    n = sum(count)
    mi = next(i for i in xrange(len(count)) if count[i]) * 1.0
    ma = next(i for i in reversed(xrange(len(count))) if count[i]) * 1.0
    mean = sum(i * v for i, v in enumerate(count)) * 1.0 / n
    mode = count.index(max(count)) * 1.0
    for i in xrange(1, len(count)):
        count[i] += count[i - 1]
    median1 = bisect.bisect_left(count, (n + 1) // 2)
    median2 = bisect.bisect_left(count, (n + 2) // 2)
    median = (median1 + median2) / 2.0
    return [mi, ma, mean, median, mode]


import bisect


MAX_HIGH = int(2e9)
result = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for i in xrange(1, MAX_HIGH):
    if result[-1] >= MAX_HIGH:
    break
    d1 = result[i] % 10 - 1
    if d1 >= 0:
    result.append(result[i] * 10 + d1)
    d2 = result[i] % 10 + 1
    if d2 <= 9:
    result.append(result[i] * 10 + d2)
result.append(float("inf"))


class Solution(object):
    def countSteppingNumbers(self, low, high):

    lit = bisect.bisect_left(result, low)
    rit = bisect.bisect_right(result, high)
    return result[lit:rit]


class Solution2(object):
    def countSteppingNumbers(self, low, high):

    result = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    for i in xrange(1, high):
        if result[-1] >= high:
            break
        d1 = result[i] % 10 - 1
        if d1 >= 0:
            result.append(result[i] * 10 + d1)
        d2 = result[i] % 10 + 1
        if d2 <= 9:
            result.append(result[i] * 10 + d2)
    result.append(float("inf"))
    lit = bisect.bisect_left(result, low)
    rit = bisect.bisect_right(result, high)
    return result[lit:rit]


import collections


class Solution(object):
    def minStickers(self, stickers, target):

    def minStickersHelper(sticker_counts, target, dp):
        if "".join(target) in dp:
            return dp["".join(target)]
        target_count = collections.Counter(target)
        result = float("inf")
        for sticker_count in sticker_counts:
            if sticker_count[target[0]] == 0:
                continue
            new_target = []
            for k in target_count.keys():
                if target_count[k] > sticker_count[k]:
                    new_target += [k] * (target_count[k] - sticker_count[k])
            if len(new_target) != len(target):
                num = minStickersHelper(sticker_counts, new_target, dp)
                if num != -1:
                    result = min(result, 1 + num)
        dp["".join(target)] = -1 if result == float("inf") else result
        return dp["".join(target)]

    sticker_counts = map(collections.Counter, stickers)
    dp = {"": 0}
    return minStickersHelper(sticker_counts, target, dp)


class Solution(object):
    def stoneGameII(self, piles):

    def dp(piles, lookup, i, m):
        if i + 2 * m >= len(piles):
            return piles[i]
        if (i, m) not in lookup:
            lookup[i, m] = piles[i] - min(
                dp(piles, lookup, i + x, max(m, x)) for x in xrange(1, 2 * m + 1)
            )
        return lookup[i, m]

    for i in reversed(xrange(len(piles) - 1)):
        piles[i] += piles[i + 1]
    return dp(piles, {}, 0, 1)


class Solution(object):
    def stoneGameIII(self, stoneValue):

    dp = [float("-inf")] * 3
    dp[len(stoneValue) % 3] = 0
    for i in reversed(xrange(len(stoneValue))):
        max_dp, curr = float("-inf"), 0
        for j in xrange(min(3, len(stoneValue) - i)):
            curr += stoneValue[i + j]
            max_dp = max(max_dp, curr - dp[(i + j + 1) % 3])
        dp[i % 3] = max_dp
    return ["Tie", "Alice", "Bob"][cmp(dp[0], 0)]


class Solution(object):
    def winnerSquareGame(self, n):

    dp = [False] * (n + 1)
    for i in xrange(1, n + 1):
        j = 1
        while j * j <= i:
            if not dp[i - j * j]:
                dp[i] = True
                break
            j += 1
    return dp[-1]


class Solution(object):
    def stoneGameV(self, stoneValue):

    n = len(stoneValue)
    prefix = [0]
    for v in stoneValue:
        prefix.append(prefix[-1] + v)

    mid = range(n)

    dp = [[0] * n for _ in xrange(n)]
    for i in xrange(n):
        dp[i][i] = stoneValue[i]

    max_score = 0
    for l in xrange(2, n + 1):
        for i in xrange(n - l + 1):
            j = i + l - 1
            while prefix[mid[i]] - prefix[i] < prefix[j + 1] - prefix[mid[i]]:
                mid[i] += 1
            p = mid[i]
            max_score = 0
            if prefix[p] - prefix[i] == prefix[j + 1] - prefix[p]:
                max_score = max(dp[i][p - 1], dp[j][p])
            else:
                if i <= p - 2:
                    max_score = max(max_score, dp[i][p - 2])
                if p <= j:
                    max_score = max(max_score, dp[j][p])
            dp[i][j] = max(
                dp[i][j - 1], (prefix[j + 1] - prefix[i]) + max_score)
            dp[j][i] = max(
                dp[j][i + 1], (prefix[j + 1] - prefix[i]) + max_score)
    return max_score


class Solution2(object):
    def stoneGameV(self, stoneValue):

    n = len(stoneValue)
    prefix = [0]
    for v in stoneValue:
        prefix.append(prefix[-1] + v)

    mid = [[0] * n for _ in xrange(n)]
    for l in xrange(1, n + 1):
        for i in xrange(n - l + 1):
            j = i + l - 1
            p = i if l == 1 else mid[i][j - 1]
            while prefix[p] - prefix[i] < prefix[j + 1] - prefix[p]:
                p += 1
            mid[i][j] = p

    rmq = [[0] * n for _ in xrange(n)]
    for i in xrange(n):
        rmq[i][i] = stoneValue[i]

    dp = [[0] * n for _ in xrange(n)]
    for l in xrange(2, n + 1):
        for i in xrange(n - l + 1):
            j = i + l - 1
            p = mid[i][j]
            max_score = 0
            if prefix[p] - prefix[i] == prefix[j + 1] - prefix[p]:
                max_score = max(rmq[i][p - 1], rmq[j][p])
            else:
                if i <= p - 2:
                    max_score = max(max_score, rmq[i][p - 2])
                if p <= j:
                    max_score = max(max_score, rmq[j][p])
            dp[i][j] = max_score
            rmq[i][j] = max(
                rmq[i][j - 1], (prefix[j + 1] - prefix[i]) + max_score)
            rmq[j][i] = max(
                rmq[j][i + 1], (prefix[j + 1] - prefix[i]) + max_score)
    return dp[0][n - 1]


class Solution(object):
    def stoneGameVI(self, aliceValues, bobValues):

    sorted_vals = sorted(
        ((a, b) for a, b in zip(aliceValues, bobValues)), key=sum, reverse=True
    )
    return cmp(
        sum(a for a, _ in sorted_vals[::2]), sum(
            b for _, b in sorted_vals[1::2])
    )


class Solution(object):
    def stoneGameVII(self, stones):

    def score(i, j):
        return prefix[j + 1] - prefix[i]

    prefix = [0]
    for stone in stones:
        prefix.append(prefix[-1] + stone)
    dp = [[0 for _ in xrange(len(stones))] for _ in xrange(2)]
    for i in reversed(xrange(len(stones))):
        for j in xrange(i + 1, len(stones)):
            dp[i % 2][j] = max(
                score(i + 1, j) - dp[(i + 1) % 2][j],
                score(i, j - 1) - dp[i % 2][j - 1],
            )
    return dp[0][-1]


class Solution(object):
    def stoneGame(self, piles):

    if len(piles) % 2 == 0 or len(piles) == 1:
        return True

    dp = [0] * len(piles)
    for i in reversed(xrange(len(piles))):
        dp[i] = piles[i]
        for j in xrange(i + 1, len(piles)):
            dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])
    return dp[-1] >= 0


import collections


class Solution(object):
    def isPrintable(self, targetGrid):

    VISITING, VISITED = range(2)

    def has_cycle(adj, color, lookup):
        stk = [(1, color)]
        while stk:
            step, color = stk.pop()
            if step == 1:
                lookup[color] = VISITING
                stk.append((2, color))
                for new_color in adj[color]:
                    if new_color in lookup:
                        if lookup[new_color] == VISITED:
                            continue
                        return True
                    stk.append((1, new_color))
            elif step == 2:
                lookup[color] = VISITED
        return False

    boxes = collections.defaultdict(
        lambda: [len(targetGrid), len(targetGrid[0]), -1, -1]
    )
    for r, row in enumerate(targetGrid):
        for c, color in enumerate(row):
            boxes[color][0] = min(boxes[color][0], r)
            boxes[color][1] = min(boxes[color][1], c)
            boxes[color][2] = max(boxes[color][2], r)
            boxes[color][3] = max(boxes[color][3], c)
    adj = collections.defaultdict(set)
    for color, (min_r, min_c, max_r, max_c) in boxes.iteritems():
        for r in xrange(min_r, max_r + 1):
            for c in xrange(min_c, max_c + 1):
                if targetGrid[r][c] != color:
                    adj[color].add(targetGrid[r][c])

    lookup = {}
    return all(
        color in lookup or not has_cycle(adj, color, lookup)
        for color in boxes.iterkeys()
    )


class Solution2(object):
    def isPrintable(self, targetGrid):

    VISITING, VISITED = range(2)

    def has_cycle(adj, color, lookup):
        lookup[color] = VISITING
        for new_color in adj[color]:
            if (
                new_color not in lookup and has_cycle(adj, new_color, lookup)
            ) or lookup[new_color] == VISITING:
                return True
        lookup[color] = VISITED
        return False

    MAX_COLOR = 60
    adj = collections.defaultdict(set)
    for color in xrange(1, MAX_COLOR + 1):
        min_r = len(targetGrid)
        min_c = len(targetGrid[0])
        max_r = -1
        max_c = -1
        for r in xrange(len(targetGrid)):
            for c in xrange(len(targetGrid[r])):
                if targetGrid[r][c] == color:
                    min_r = min(min_r, r)
                    min_c = min(min_c, c)
                    max_r = max(max_r, r)
                    max_c = max(max_c, c)
        for r in xrange(min_r, max_r + 1):
            for c in xrange(min_c, max_c + 1):
                if targetGrid[r][c] != color:
                    adj[color].add(targetGrid[r][c])

    lookup = {}
    return all(
        color in lookup or not has_cycle(adj, color, lookup)
        for color in xrange(1, MAX_COLOR + 1)
    )


class Solution(object):
    def strangePrinter(self, s):

    def dp(s, i, j, lookup):
        if i > j:
            return 0
        if (i, j) not in lookup:
            lookup[(i, j)] = dp(s, i, j - 1, lookup) + 1
            for k in xrange(i, j):
                if s[k] == s[j]:
                    lookup[(i, j)] = min(
                        lookup[(i, j)],
                        dp(s, i, k, lookup) + dp(s, k + 1, j - 1, lookup),
                    )
        return lookup[(i, j)]

    lookup = {}
    return dp(s, 0, len(s) - 1, lookup)


import collections


class AhoNode(object):
    def __init__(self):
    self.children = collections.defaultdict(AhoNode)
    self.indices = []
    self.suffix = None
    self.output = None


class AhoTrie(object):
    def step(self, letter):
    while self.__node and letter not in self.__node.children:
        self.__node = self.__node.suffix
    self.__node = self.__node.children[letter] if self.__node else self.__root
    return self.__get_ac_node_outputs(self.__node)

    def __init__(self, patterns):
    self.__root = self.__create_ac_trie(patterns)
    self.__node = self.__create_ac_suffix_and_output_links(self.__root)

    def __create_ac_trie(self, patterns):
    root = AhoNode()
    for i, pattern in enumerate(patterns):
        node = root
        for c in pattern:
            node = node.children[c]
        node.indices.append(i)
    return root

    def __create_ac_suffix_and_output_links(self, root):
    queue = collections.deque()
    for node in root.children.itervalues():
        queue.append(node)
        node.suffix = root

    while queue:
        node = queue.popleft()
        for c, child in node.children.iteritems():
            queue.append(child)
            suffix = node.suffix
            while suffix and c not in suffix.children:
                suffix = suffix.suffix
            child.suffix = suffix.children[c] if suffix else root
            child.output = (
                child.suffix if child.suffix.indices else child.suffix.output
            )

    return root

    def __get_ac_node_outputs(
        self, node
    ):

    result = []
    for i in node.indices:
        result.append(i)

    output = node.output
    while output:
        for i in output.indices:
            result.append(i)

        output = output.output
    return result


class StreamChecker(object):
    def __init__(self, words):

    self.__trie = AhoTrie(words)

    def query(self, letter):

    return len(self.__trie.step(letter)) > 0


import collections


class AhoNode(object):
    def __init__(self):
    self.children = collections.defaultdict(AhoNode)
    self.suffix = None
    self.outputs = []


class AhoTrie(object):
    def step(self, letter):
    while self.__node and letter not in self.__node.children:
        self.__node = self.__node.suffix
    self.__node = self.__node.children[letter] if self.__node else self.__root
    return (
        self.__node.outputs
    )

    def __init__(self, patterns):
    self.__root = self.__create_ac_trie(patterns)
    self.__node = self.__create_ac_suffix_and_output_links(self.__root)

    def __create_ac_trie(self, patterns):
    root = AhoNode()
    for i, pattern in enumerate(patterns):
        node = root
        for c in pattern:
            node = node.children[c]
        node.outputs.append(i)
    return root

    def __create_ac_suffix_and_output_links(
        self, root
    ):
    queue = collections.deque()
    for node in root.children.itervalues():
        queue.append(node)
        node.suffix = root

    while queue:
        node = queue.popleft()
        for c, child in node.children.iteritems():
            queue.append(child)
            suffix = node.suffix
            while suffix and c not in suffix.children:
                suffix = suffix.suffix
            child.suffix = suffix.children[c] if suffix else root
            child.outputs += child.suffix.outputs

    return root


class StreamChecker(object):
    def __init__(self, words):

    self.__trie = AhoTrie(words)

    def query(self, letter):

    return len(self.__trie.step(letter)) > 0


class Solution(object):
    def getLengthOfOptimalCompression(self, s, k):

    def length(cnt):
        l = 2 if cnt >= 2 else 1
        while cnt >= 10:
            l += 1
            cnt //= 10
        return l

    dp = [[len(s)] * (k + 1) for _ in xrange(len(s) + 1)]
    dp[0][0] = 0
    for i in xrange(1, len(s) + 1):
        for j in xrange(k + 1):
            if i - 1 >= 0 and j - 1 >= 0:
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
            keep = delete = 0
            for m in xrange(i, len(s) + 1):
                if s[i - 1] == s[m - 1]:
                    keep += 1
                else:
                    delete += 1
                if j + delete <= k:
                    dp[m][j + delete] = min(
                        dp[m][j + delete], dp[i - 1][j] + length(keep)
                    )
    return dp[len(s)][k]


class Solution(object):
    def compress(self, chars):

    anchor, write = 0, 0
    for read, c in enumerate(chars):
        if read + 1 == len(chars) or chars[read + 1] != c:
            chars[write] = chars[anchor]
            write += 1
            if read > anchor:
                n, left = read - anchor + 1, write
                while n > 0:
                    chars[write] = chr(n % 10 + ord("0"))
                    write += 1
                    n /= 10
                right = write - 1
                while left < right:
                    chars[left], chars[right] = chars[right], chars[left]
                    left += 1
                    right -= 1
            anchor = read + 1
    return write


import collections


class AhoNode(object):
    def __init__(self):
    self.children = collections.defaultdict(AhoNode)
    self.indices = []
    self.suffix = None
    self.output = None


class AhoTrie(object):
    def step(self, letter):
    while self.__node and letter not in self.__node.children:
        self.__node = self.__node.suffix
    self.__node = self.__node.children[letter] if self.__node else self.__root
    return self.__get_ac_node_outputs(self.__node)

    def reset(self):
    self.__node = self.__root

    def __init__(self, patterns):
    self.__root = self.__create_ac_trie(patterns)
    self.__node = self.__create_ac_suffix_and_output_links(self.__root)

    def __create_ac_trie(self, patterns):
    root = AhoNode()
    for i, pattern in enumerate(patterns):
        node = root
        for c in pattern:
            node = node.children[c]
        node.indices.append(i)
    return root

    def __create_ac_suffix_and_output_links(self, root):
    queue = collections.deque()
    for node in root.children.itervalues():
        queue.append(node)
        node.suffix = root

    while queue:
        node = queue.popleft()
        for c, child in node.children.iteritems():
            queue.append(child)
            suffix = node.suffix
            while suffix and c not in suffix.children:
                suffix = suffix.suffix
            child.suffix = suffix.children[c] if suffix else root
            child.output = (
                child.suffix if child.suffix.indices else child.suffix.output
            )

    return root

    def __get_ac_node_outputs(self, node):
    result = []
    for i in node.indices:
        result.append(i)
    output = node.output
    while output:
        for i in output.indices:
            result.append(i)
        output = output.output
    return result


class Solution(object):
    def stringMatching(self, words):

    trie = AhoTrie(words)
    lookup = set()
    for i in xrange(len(words)):
        trie.reset()
        for c in words[i]:
            for j in trie.step(c):
                if j != i:
                    lookup.add(j)
    return [words[i] for i in lookup]


class Solution2(object):
    def stringMatching(self, words):

    def getPrefix(pattern):
        prefix = [-1] * len(pattern)
        j = -1
        for i in xrange(1, len(pattern)):
            while j != -1 and pattern[j + 1] != pattern[i]:
                j = prefix[j]
            if pattern[j + 1] == pattern[i]:
                j += 1
            prefix[i] = j
        return prefix

    def kmp(text, pattern, prefix):
        if not pattern:
            return 0
        if len(text) < len(pattern):
            return -1
        j = -1
        for i in xrange(len(text)):
            while j != -1 and pattern[j + 1] != text[i]:
                j = prefix[j]
            if pattern[j + 1] == text[i]:
                j += 1
            if j + 1 == len(pattern):
                return i - j
        return -1

    result = []
    for i, pattern in enumerate(words):
        prefix = getPrefix(pattern)
        for j, text in enumerate(words):
            if i != j and kmp(text, pattern, prefix) != -1:
                result.append(pattern)
                break
    return result


class Solution3(object):
    def stringMatching(self, words):

    result = []
    for i, pattern in enumerate(words):
        for j, text in enumerate(words):
            if i != j and pattern in text:
                result.append(pattern)
                break
    return result


class Solution(object):
    def myAtoi(self, str):

    INT_MAX = 2147483647
    INT_MIN = -2147483648
    result = 0

    if not str:
        return result

    i = 0
    while i < len(str) and str[i].isspace():
        i += 1

    if len(str) == i:
        return result

    sign = 1
    if str[i] == "+":
        i += 1
    elif str[i] == "-":
        sign = -1
        i += 1

    while i < len(str) and "0" <= str[i] <= "9":
        if result > (INT_MAX - int(str[i])) / 10:
            return INT_MAX if sign > 0 else INT_MIN
        result = result * 10 + int(str[i])
        i += 1

    return sign * result


import itertools


class Solution(object):
    def canConvert(self, str1, str2):

    if str1 == str2:
        return True
    lookup = {}
    for i, j in itertools.izip(str1, str2):
        if lookup.setdefault(i, j) != j:
            return False
    return len(set(str2)) < 26


class Solution(object):
    def strWithout3a3b(self, A, B):

    result = []
    put_A = None
    while A or B:
        if len(result) >= 2 and result[-1] == result[-2]:
            put_A = result[-1] == "b"
        else:
            put_A = A >= B

        if put_A:
            A -= 1
            result.append("a")
        else:
            B -= 1
            result.append("b")
    return "".join(result)


import collections


class Solution(object):
    def differByOne(self, dict):

    MOD, P = 10 ** 9 + 7, 113

    hashes = [0] * len(dict)
    for i, word in enumerate(dict):
        for c in word:
            hashes[i] = (P * hashes[i] + (ord(c) - ord("a"))) % MOD

    base = 1
    for p in reversed(xrange(len(dict[0]))):
        lookup = collections.defaultdict(list)
        for i, word in enumerate(dict):
            new_hash = (hashes[i] - base * (ord(word[p]) - ord("a"))) % MOD
            if new_hash in lookup:
                for j in lookup[new_hash]:
                    if dict[j][:p] + dict[j][p + 1:] == word[:p] + word[p + 1:]:
                        return True
            lookup[new_hash].append(i)
        base = P * base % MOD
    return False


class Solution(object):
    def findStrobogrammatic(self, n):

    lookup = {"0": "0", "1": "1", "6": "9", "8": "8", "9": "6"}
    result = ["0", "1", "8"] if n % 2 else [""]
    for i in xrange(n % 2, n, 2):
        result = [
            a + num + b
            for a, b in lookup.iteritems()
            if i != n - 2 or a != "0"
            for num in result
        ]
    return result


class Solution2(object):
    def findStrobogrammatic(self, n):

    lookup = {"0": "0", "1": "1", "6": "9", "8": "8", "9": "6"}

    def findStrobogrammaticRecu(n, k):
        if k == 0:
            return [""]
        elif k == 1:
            return ["0", "1", "8"]
        result = []
        for num in findStrobogrammaticRecu(n, k - 2):
            for key, val in lookup.iteritems():
                if n != k or key != "0":
                    result.append(key + num + val)
        return result

    return findStrobogrammaticRecu(n, n)


class Solution(object):
    lookup = {"0": "0", "1": "1", "6": "9", "8": "8", "9": "6"}
    cache = {}

    def strobogrammaticInRange(self, low, high):
    count = (
        self.countStrobogrammaticUntil(high, False)
        - self.countStrobogrammaticUntil(low, False)
        + self.isStrobogrammatic(low)
    )
    return count if count >= 0 else 0

    def countStrobogrammaticUntil(self, num, can_start_with_0):
    if can_start_with_0 and num in self.cache:
        return self.cache[num]

    count = 0
    if len(num) == 1:
        for c in ["0", "1", "8"]:
            if num[0] >= c:
                count += 1
        self.cache[num] = count
        return count

    for key, val in self.lookup.iteritems():
        if can_start_with_0 or key != "0":
            if num[0] > key:
                if len(num) == 2:
                    count += 1
                else:
                    count += self.countStrobogrammaticUntil(
                        "9" * (len(num) - 2), True
                    )
            elif num[0] == key:
                if len(num) == 2:
                    if num[-1] >= val:
                        count += 1
                else:
                    if num[-1] >= val:
                        count += self.countStrobogrammaticUntil(
                            self.getMid(num), True
                        )
                    elif self.getMid(num) != "0" * (
                        len(num) - 2
                    ):
                        count += self.countStrobogrammaticUntil(
                            self.getMid(num), True
                        ) - self.isStrobogrammatic(self.getMid(num))

    if not can_start_with_0:
        for i in xrange(len(num) - 1, 0, -1):
            count += self.countStrobogrammaticByLength(i)
    else:
        self.cache[num] = count

    return count

    def getMid(self, num):
    return num[1: len(num) - 1]

    def countStrobogrammaticByLength(self, n):
    if n == 1:
        return 3
    elif n == 2:
        return 4
    elif n == 3:
        return 4 * 3
    else:
        return 5 * self.countStrobogrammaticByLength(n - 2)

    def isStrobogrammatic(self, num):
    n = len(num)
    for i in xrange((n + 1) / 2):
        if (
            num[n - 1 - i] not in self.lookup
            or num[i] != self.lookup[num[n - 1 - i]]
        ):
            return False
    return True


class Solution(object):
    lookup = {"0": "0", "1": "1", "6": "9", "8": "8", "9": "6"}

    def isStrobogrammatic(self, num):
    n = len(num)
    for i in xrange((n + 1) / 2):
        if (
            num[n - 1 - i] not in self.lookup
            or num[i] != self.lookup[num[n - 1 - i]]
        ):
            return False
    return True


class Solution(object):
    def strongPasswordChecker(self, s):

    missing_type_cnt = 3
    if any("a" <= c <= "z" for c in s):
        missing_type_cnt -= 1
    if any("A" <= c <= "Z" for c in s):
        missing_type_cnt -= 1
    if any(c.isdigit() for c in s):
        missing_type_cnt -= 1

    total_change_cnt = 0
    one_change_cnt, two_change_cnt, three_change_cnt = 0, 0, 0
    i = 2
    while i < len(s):
        if s[i] == s[i - 1] == s[i - 2]:
            length = 2
            while i < len(s) and s[i] == s[i - 1]:
                length += 1
                i += 1

            total_change_cnt += length / 3
            if length % 3 == 0:
                one_change_cnt += 1
            elif length % 3 == 1:
                two_change_cnt += 1
            else:
                three_change_cnt += 1
        else:
            i += 1

    if len(s) < 6:
        return max(missing_type_cnt, 6 - len(s))
    elif len(s) <= 20:
        return max(missing_type_cnt, total_change_cnt)
    else:
        delete_cnt = len(s) - 20

        total_change_cnt -= min(delete_cnt, one_change_cnt * 1) / 1
        total_change_cnt -= (
            min(max(delete_cnt - one_change_cnt, 0), two_change_cnt * 2) / 2
        )
        total_change_cnt -= (
            min(
                max(delete_cnt - one_change_cnt - 2 * two_change_cnt, 0),
                three_change_cnt * 3,
            )
            / 3
        )

        return delete_cnt + max(missing_type_cnt, total_change_cnt)


class Solution(object):
    def checkRecord(self, s):

    count_A = 0
    for i in xrange(len(s)):
        if s[i] == "A":
            count_A += 1
            if count_A == 2:
                return False
        if i < len(s) - 2 and s[i] == s[i + 1] == s[i + 2] == "L":
            return False
    return True


class Solution(object):
    def checkRecord(self, n):

    M = 1000000007
    a0l0, a0l1, a0l2, a1l0, a1l1, a1l2 = 1, 0, 0, 0, 0, 0
    for i in xrange(n + 1):
        a0l2, a0l1, a0l0 = a0l1, a0l0, (a0l0 + a0l1 + a0l2) % M
        a1l2, a1l1, a1l0 = a1l1, a1l0, (a0l0 + a1l0 + a1l1 + a1l2) % M
    return a1l0


class Solution(object):
    def numSubarrayProductLessThanK(self, nums, k):

    if k <= 1:
        return 0
    result, start, prod = 0, 0, 1
    for i, num in enumerate(nums):
        prod *= num
        while prod >= k:
            prod /= nums[start]
            start += 1
        result += i - start + 1
    return result


import collections


class Solution(object):
    def subarraySum(self, nums, k):

    result = 0
    accumulated_sum = 0
    lookup = collections.defaultdict(int)
    lookup[0] += 1
    for num in nums:
        accumulated_sum += num
        result += lookup[accumulated_sum - k]
        lookup[accumulated_sum] += 1
    return result


import collections


class Solution(object):
    def subarraysDivByK(self, A, K):

    count = collections.defaultdict(int)
    count[0] = 1
    result, prefix = 0, 0
    for a in A:
        prefix = (prefix + a) % K
        result += count[prefix]
        count[prefix] += 1
    return result


import collections


class Solution(object):
    def subarraysWithKDistinct(self, A, K):

    def atMostK(A, K):
        count = collections.defaultdict(int)
        result, left = 0, 0
        for right in xrange(len(A)):
            count[A[right]] += 1
            while len(count) > K:
                count[A[left]] -= 1
                if count[A[left]] == 0:
                    count.pop(A[left])
                left += 1
            result += right - left + 1
        return result

    return atMostK(A, K) - atMostK(A, K - 1)


class Window(object):
    def __init__(self):
    self.__count = collections.defaultdict(int)

    def add(self, x):
    self.__count[x] += 1

    def remove(self, x):
    self.__count[x] -= 1
    if self.__count[x] == 0:
        self.__count.pop(x)

    def size(self):
    return len(self.__count)


class Solution2(object):
    def subarraysWithKDistinct(self, A, K):

    window1, window2 = Window(), Window()
    result, left1, left2 = 0, 0, 0
    for i in A:
        window1.add(i)
        while window1.size() > K:
            window1.remove(A[left1])
            left1 += 1
        window2.add(i)
        while window2.size() >= K:
            window2.remove(A[left2])
            left2 += 1
        result += left2 - left1
    return result


import collections


class Solution(object):
    def subdomainVisits(self, cpdomains):

    result = collections.defaultdict(int)
    for domain in cpdomains:
        count, domain = domain.split()
        count = int(count)
        frags = domain.split(".")
        curr = []
        for i in reversed(xrange(len(frags))):
            curr.append(frags[i])
            result[".".join(reversed(curr))] += count

    return ["{} {}".format(count, domain) for domain, count in result.iteritems()]


class SubrectangleQueries(object):
    def __init__(self, rectangle):

    self.__rectangle = rectangle
    self.__updates = []

    def updateSubrectangle(self, row1, col1, row2, col2, newValue):

    self.__updates.append((row1, col1, row2, col2, newValue))

    def getValue(self, row, col):

    for (row1, col1, row2, col2, newValue) in reversed(self.__updates):
        if row1 <= row <= row2 and col1 <= col <= col2:
            return newValue
    return self.__rectangle[row][col]


class SubrectangleQueries2(object):
    def __init__(self, rectangle):

    self.__rectangle = rectangle

    def updateSubrectangle(self, row1, col1, row2, col2, newValue):

    for r in xrange(row1, row2 + 1):
        for c in xrange(col1, col2 + 1):
            self.__rectangle[r][c] = newValue

    def getValue(self, row, col):

    return self.__rectangle[row][col]


class Solution(object):
    def subsetsWithDup(self, nums):

    nums.sort()
    result = [[]]
    previous_size = 0
    for i in xrange(len(nums)):
        size = len(result)
        for j in xrange(size):

            if i == 0 or nums[i] != nums[i - 1] or j >= previous_size:
                result.append(list(result[j]))
                result[-1].append(nums[i])
        previous_size = size
    return result


class Solution2(object):
    def subsetsWithDup(self, nums):

    result = []
    i, count = 0, 1 << len(nums)
    nums.sort()

    while i < count:
        cur = []
        for j in xrange(len(nums)):
            if i & 1 << j:
                cur.append(nums[j])
        if cur not in result:
            result.append(cur)
        i += 1

    return result


class Solution3(object):
    def subsetsWithDup(self, nums):

    result = []
    self.subsetsWithDupRecu(result, [], sorted(nums))
    return result

    def subsetsWithDupRecu(self, result, cur, nums):
    if not nums:
        if cur not in result:
            result.append(cur)
    else:
        self.subsetsWithDupRecu(result, cur, nums[1:])
        self.subsetsWithDupRecu(result, cur + [nums[0]], nums[1:])


class Solution(object):
    def subsets(self, nums):

    nums.sort()
    result = [[]]
    for i in xrange(len(nums)):
        size = len(result)
        for j in xrange(size):
            result.append(list(result[j]))
            result[-1].append(nums[i])
    return result


class Solution2(object):
    def subsets(self, nums):

    result = []
    i, count = 0, 1 << len(nums)
    nums.sort()

    while i < count:
        cur = []
        for j in xrange(len(nums)):
            if i & 1 << j:
                cur.append(nums[j])
        result.append(cur)
        i += 1

    return result


class Solution3(object):
    def subsets(self, nums):

    return self.subsetsRecu([], sorted(nums))

    def subsetsRecu(self, cur, nums):
    if not nums:
        return [cur]

    return self.subsetsRecu(cur, nums[1:]) + self.subsetsRecu(
        cur + [nums[0]], nums[1:]
    )


import collections


class Solution(object):
    def findSubstring(self, s, words):

    if not words:
        return []

    result, m, n, k = [], len(s), len(words), len(words[0])
    if m < n * k:
        return result

    lookup = collections.defaultdict(int)
    for i in words:
        lookup[i] += 1

    for i in xrange(k):
        left, count = i, 0
        tmp = collections.defaultdict(int)
        for j in xrange(i, m - k + 1, k):
            s1 = s[j: j + k]
            if s1 in lookup:
                tmp[s1] += 1
                count += 1
                while tmp[s1] > lookup[s1]:
                    tmp[s[left: left + k]] -= 1
                    count -= 1
                    left += k
                if count == n:
                    result.append(left)
            else:
                tmp = collections.defaultdict(int)
                count = 0
                left = j + k
    return result


class Solution2(object):
    def findSubstring(self, s, words):

    result, m, n, k = [], len(s), len(words), len(words[0])
    if m < n * k:
        return result

    lookup = collections.defaultdict(int)
    for i in words:
        lookup[i] += 1

    for i in xrange(m + 1 - k * n):
        cur, j = collections.defaultdict(int), 0
        while j < n:
            word = s[i + j * k: i + j * k + k]
            if word not in lookup:
                break
            cur[word] += 1
            if cur[word] > lookup[word]:
                break
            j += 1
        if j == n:
            result.append(i)

    return result


class Solution(object):
    def subtractProductAndSum(self, n):

    product, total = 1, 0
    while n:
        n, r = divmod(n, 10)
        product *= r
        total += r
    return product - total


import operator


class Solution2(object):
    def subtractProductAndSum(self, n):

    A = map(int, str(n))
    return reduce(operator.mul, A) - sum(A)


class Solution(object):
    def isSubtree(self, s, t):

    def isSame(x, y):
        if not x and not y:
            return True
        if not x or not y:
            return False
        return (
            x.val == y.val and isSame(
                x.left, y.left) and isSame(x.right, y.right)
        )

    def preOrderTraverse(s, t):
        return s != None and (
            isSame(s, t)
            or preOrderTraverse(s.left, t)
            or preOrderTraverse(s.right, t)
        )

    return preOrderTraverse(s, t)


class Solution(object):

    def solveSudoku(self, board):

    def isValid(board, x, y):
        for i in xrange(9):
            if i != x and board[i][y] == board[x][y]:
                return False
        for j in xrange(9):
            if j != y and board[x][j] == board[x][y]:
                return False
        i = 3 * (x / 3)
        while i < 3 * (x / 3 + 1):
            j = 3 * (y / 3)
            while j < 3 * (y / 3 + 1):
                if (i != x or j != y) and board[i][j] == board[x][y]:
                    return False
                j += 1
            i += 1
        return True

    def solver(board):
        for i in xrange(len(board)):
            for j in xrange(len(board[0])):
                if board[i][j] == ".":
                    for k in xrange(9):
                        board[i][j] = chr(ord("1") + k)
                        if isValid(board, i, j) and solver(board):
                            return True
                        board[i][j] = "."
                    return False
        return True

    solver(board)


class Solution(object):
    def getSumAbsoluteDifferences(self, nums):

    prefix, suffix = 0, sum(nums)
    result = []
    for i, num in enumerate(nums):
        suffix -= num
        result.append((i * num - prefix) +
                      (suffix - ((len(nums) - 1) - i) * num))
        prefix += num
    return result


class Solution(object):
    def sumOddLengthSubarrays(self, arr):

    def ceil_divide(a, b):
        return (a + (b - 1)) // b

    return sum(
        x * ceil_divide((i - 0 + 1) * ((len(arr) - 1) - i + 1), 2)
        for i, x in enumerate(arr)
    )


class Solution(object):
    def beautySum(self, s):

    result = 0
    for i in xrange(len(s)):
        lookup = [0] * 26
        for j in xrange(i, len(s)):
            lookup[ord(s[j]) - ord("a")] += 1
            result += max(lookup) - min(x for x in lookup if x)
    return result


class Solution(object):
    def sumOfDigits(self, A):

    total = sum([int(c) for c in str(min(A))])
    return 1 if total % 2 == 0 else 0


import collections


class Solution(object):
    def sumOfDistancesInTree(self, N, edges):

    def dfs(graph, node, parent, count, result):
        for nei in graph[node]:
            if nei != parent:
                dfs(graph, nei, node, count, result)
                count[node] += count[nei]
                result[node] += result[nei] + count[nei]

    def dfs2(graph, node, parent, count, result):
        for nei in graph[node]:
            if nei != parent:
                result[nei] = result[node] - \
                    count[nei] + len(count) - count[nei]
                dfs2(graph, nei, node, count, result)

    graph = collections.defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    count = [1] * N
    result = [0] * N

    dfs(graph, 0, None, count, result)
    dfs2(graph, 0, None, count, result)
    return result


class Solution(object):
    def sumEvenAfterQueries(self, A, queries):

    total = sum(v for v in A if v % 2 == 0)

    result = []
    for v, i in queries:
        if A[i] % 2 == 0:
            total -= A[i]
        A[i] += v
        if A[i] % 2 == 0:
            total += A[i]
        result.append(total)
    return result


class Solution(object):
    def sumOfLeftLeaves(self, root):

    def sumOfLeftLeavesHelper(root, is_left):
        if not root:
            return 0
        if not root.left and not root.right:
            return root.val if is_left else 0
        return sumOfLeftLeavesHelper(root.left, True) + sumOfLeftLeavesHelper(
            root.right, False
        )

    return sumOfLeftLeavesHelper(root, False)


class Solution(object):
    def findBestValue(self, arr, target):

    arr.sort(reverse=True)
    max_arr = arr[0]
    while arr and arr[-1] * len(arr) <= target:
        target -= arr.pop()

    return max_arr if not arr else (2 * target + len(arr) - 1) // (2 * len(arr))


class Solution2(object):
    def findBestValue(self, arr, target):

    arr.sort(reverse=True)
    max_arr = arr[0]
    while arr and arr[-1] * len(arr) <= target:
        target -= arr.pop()
    if not arr:
        return max_arr
    x = (target - 1) // len(arr)
    return x if target - x * len(arr) <= (x + 1) * len(arr) - target else x + 1


class Solution3(object):
    def findBestValue(self, arr, target):

    def total(arr, v):
        result = 0
        for x in arr:
            result += min(v, x)
        return result

    def check(arr, v, target):
        return total(arr, v) >= target

    left, right = 1, max(arr)
    while left <= right:
        mid = left + (right - left) // 2
        if check(arr, mid, target):
            right = mid - 1
        else:
            left = mid + 1
    return (
        left - 1
        if target - total(arr, left - 1) <= total(arr, left) - target
        else left
    )


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def sumEvenGrandparent(self, root):

    def sumEvenGrandparentHelper(root, p, gp):
        return (
            sumEvenGrandparentHelper(root.left, root.val, p)
            + sumEvenGrandparentHelper(root.right, root.val, p)
            + (root.val if gp is not None and gp % 2 == 0 else 0)
            if root
            else 0
        )

    return sumEvenGrandparentHelper(root, None, None)


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def sumRootToLeaf(self, root):

    M = 10 ** 9 + 7

    def sumRootToLeafHelper(root, val):
        if not root:
            return 0
        val = (val * 2 + root.val) % M
        if not root.left and not root.right:
            return val
        return (
            sumRootToLeafHelper(root.left, val)
            + sumRootToLeafHelper(root.right, val)
        ) % M

    return sumRootToLeafHelper(root, 0)


class Solution(object):
    def solve(self, nums, queries):

    MOD = 10 ** 9 + 7

    prefix = {}
    result = []
    for x, y in queries:
        if y * y > len(nums):
            total = 0
            for i in xrange(x, len(nums), y):
                total += nums[i]
                total %= MOD
            result.append(total)
        else:
            begin = x % y
            if (begin, y) not in prefix:
                prefix[(begin, y)] = [0]
                for i in xrange(begin, len(nums), y):
                    prefix[(begin, y)].append(
                        (prefix[(begin, y)][-1] + nums[i]) % MOD
                    )
            result.append(
                (prefix[(begin, y)][-1] - prefix[(begin, y)][x // y]) % MOD
            )
    return result


import math


class Solution(object):
    def judgeSquareSum(self, c):

    for a in xrange(int(math.sqrt(c)) + 1):
        b = int(math.sqrt(c - a ** 2))
        if a ** 2 + b ** 2 == c:
            return True
    return False


import itertools


class Solution(object):
    def sumSubarrayMins(self, A):

    M = 10 ** 9 + 7

    left, s1 = [0] * len(A), []
    for i in xrange(len(A)):
        count = 1
        while s1 and s1[-1][0] > A[i]:
            count += s1.pop()[1]
        left[i] = count
        s1.append([A[i], count])

    right, s2 = [0] * len(A), []
    for i in reversed(xrange(len(A))):
        count = 1
        while s2 and s2[-1][0] >= A[i]:
            count += s2.pop()[1]
        right[i] = count
        s2.append([A[i], count])

    return sum(a * l * r for a, l, r in itertools.izip(A, left, right)) % M


class Solution(object):
    def sumSubseqWidths(self, A):

    M = 10 ** 9 + 7

    result, c = 0, 1
    A.sort()
    for i in xrange(len(A)):
        result = (result + (A[i] - A[len(A) - 1 - i]) * c % M) % M
        c = (c << 1) % M
    return result


class Solution(object):
    def getSum(self, a, b):

    bit_length = 32
    neg_bit, mask = (1 << bit_length) >> 1, ~(~0 << bit_length)

    a = (a | ~mask) if (a & neg_bit) else (a & mask)
    b = (b | ~mask) if (b & neg_bit) else (b & mask)

    while b:
        carry = a & b
        a ^= b
        a = (a | ~mask) if (a & neg_bit) else (a & mask)
        b = carry << 1
        b = (b | ~mask) if (b & neg_bit) else (b & mask)

    return a

    def getSum2(self, a, b):

    MAX = 0x7FFFFFFF

    MIN = 0x80000000

    mask = 0xFFFFFFFF
    while b:

        a, b = (a ^ b) & mask, ((a & b) << 1) & mask

    return a if a <= MAX else ~(a ^ mask)

    def minus(self, a, b):
    b = self.getSum(~b, 1)
    return self.getSum(a, b)

    def multiply(self, a, b):
    isNeg = (a > 0) ^ (b > 0)
    x = a if a > 0 else self.getSum(~a, 1)
    y = b if b > 0 else self.getSum(~b, 1)
    ans = 0
    while y & 0x01:
        ans = self.getSum(ans, x)
        y >>= 1
        x <<= 1
    return self.getSum(~ans, 1) if isNeg else ans

    def divide(self, a, b):
    isNeg = (a > 0) ^ (b > 0)
    x = a if a > 0 else self.getSum(~a, 1)
    y = b if b > 0 else self.getSum(~b, 1)
    ans = 0
    for i in range(31, -1, -1):
        if (x >> i) >= y:
            x = self.minus(x, y << i)
            ans = self.getSum(ans, 1 << i)
    return self.getSum(~ans, 1) if isNeg else ans


import collections


class Solution(object):
    def sumOfUnique(self, nums):

    return sum(x for x, c in collections.Counter(nums).iteritems() if c == 1)


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def sumNumbers(self, root):
    return self.sumNumbersRecu(root, 0)

    def sumNumbersRecu(self, root, num):
    if root is None:
        return 0

    if root.left is None and root.right is None:
        return num * 10 + root.val

    return self.sumNumbersRecu(
        root.left, num * 10 + root.val
    ) + self.sumNumbersRecu(root.right, num * 10 + root.val)


import itertools
import re


class Solution(object):

    def summaryRanges(self, nums):
    ranges = []
    if not nums:
        return ranges

    start, end = nums[0], nums[0]
    for i in xrange(1, len(nums) + 1):
        if i < len(nums) and nums[i] == end + 1:
            end = nums[i]
        else:
            interval = str(start)
            if start != end:
                interval += "->" + str(end)
            ranges.append(interval)
            if i < len(nums):
                start = end = nums[i]

    return ranges


class Solution2(object):

    def summaryRanges(self, nums):
    return [
        re.sub("->.*>", "->", "->".join(repr(n) for _, n in g))
        for _, g in itertools.groupby(enumerate(nums), lambda i_n: i_n[1] - i_n[0])
    ]


class Solution(object):
    def superEggDrop(self, K, N):

    def check(n, K, N):

        total, c = 0, 1
        for k in xrange(1, K + 1):
            c *= n - k + 1
            c //= k
            total += c
            if total >= N:
                return True
        return False

    left, right = 1, N
    while left <= right:
        mid = left + (right - left) // 2
        if check(mid, K, N):
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution(object):
    def superpalindromesInRange(self, L, R):

    def is_palindrome(k):
        return str(k) == str(k)[::-1]

    K = int((10 ** ((len(R) + 1) * 0.25)))
    l, r = int(L), int(R)

    result = 0

    for k in xrange(K):
        s = str(k)
        t = s + s[-2::-1]
        v = int(t) ** 2
        if v > r:
            break
        if v >= l and is_palindrome(v):
            result += 1

    for k in xrange(K):
        s = str(k)
        t = s + s[::-1]
        v = int(t) ** 2
        if v > r:
            break
        if v >= l and is_palindrome(v):
            result += 1

    return result


class Solution(object):
    def superPow(self, a, b):

    def myPow(a, n, b):
        result = 1
        x = a % b
        while n:
            if n & 1:
                result = result * x % b
            n >>= 1
            x = x * x % b
        return result % b

    result = 1
    for digit in b:
        result = myPow(result, 10, 1337) * myPow(a, digit, 1337) % 1337
    return result


import heapq


class Solution(object):
    def nthSuperUglyNumber(self, n, primes):

    heap, uglies, idx, ugly_by_last_prime = [], [
        0] * n, [0] * len(primes), [0] * n
    uglies[0] = 1

    for k, p in enumerate(primes):
        heapq.heappush(heap, (p, k))

    for i in xrange(1, n):
        uglies[i], k = heapq.heappop(heap)
        ugly_by_last_prime[i] = k
        idx[k] += 1
        while ugly_by_last_prime[idx[k]] > k:
            idx[k] += 1
        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))

    return uglies[-1]


class Solution2(object):
    def nthSuperUglyNumber(self, n, primes):

    uglies, idx, heap, ugly_set = [0] * n, [0] * len(primes), [], set([1])
    uglies[0] = 1

    for k, p in enumerate(primes):
        heapq.heappush(heap, (p, k))
        ugly_set.add(p)

    for i in xrange(1, n):
        uglies[i], k = heapq.heappop(heap)
        while (primes[k] * uglies[idx[k]]) in ugly_set:
            idx[k] += 1
        heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))
        ugly_set.add(primes[k] * uglies[idx[k]])

    return uglies[-1]


class Solution3(object):
    def nthSuperUglyNumber(self, n, primes):

    uglies, idx, heap = [1], [0] * len(primes), []
    for k, p in enumerate(primes):
        heapq.heappush(heap, (p, k))

    for i in xrange(1, n):
        min_val, k = heap[0]
        uglies += [min_val]

        while heap[0][0] == min_val:
            min_val, k = heapq.heappop(heap)
            idx[k] += 1
            heapq.heappush(heap, (primes[k] * uglies[idx[k]], k))

    return uglies[-1]


class Solution4(object):
    def nthSuperUglyNumber(self, n, primes):

    uglies = [0] * n
    uglies[0] = 1
    ugly_by_prime = list(primes)
    idx = [0] * len(primes)

    for i in xrange(1, n):
        uglies[i] = min(ugly_by_prime)
        for k in xrange(len(primes)):
            if uglies[i] == ugly_by_prime[k]:
                idx[k] += 1
                ugly_by_prime[k] = primes[k] * uglies[idx[k]]

    return uglies[-1]


class Solution5(object):
    def nthSuperUglyNumber(self, n, primes):

    ugly_number = 0

    heap = []
    heapq.heappush(heap, 1)
    for p in primes:
        heapq.heappush(heap, p)
    for _ in xrange(n):
        ugly_number = heapq.heappop(heap)
        for i in xrange(len(primes)):
            if ugly_number % primes[i] == 0:
                for j in xrange(i + 1):
                    heapq.heappush(heap, ugly_number * primes[j])
                break

    return ugly_number


class Solution(object):
    def findMinMoves(self, machines):

    total = sum(machines)
    if total % len(machines):
        return -1

    result, target, curr = 0, total / len(machines), 0
    for n in machines:
        curr += n - target
        result = max(result, max(n - target, abs(curr)))
    return result


class Solution(object):
    def surfaceArea(self, grid):

    result = 0
    for i in xrange(len(grid)):
        for j in xrange(len(grid)):
            if grid[i][j]:
                result += 2 + grid[i][j] * 4
            if i:
                result -= min(grid[i][j], grid[i - 1][j]) * 2
            if j:
                result -= min(grid[i][j], grid[i][j - 1]) * 2
    return result


import collections


class Solution(object):
    def solve(self, board):

    if not board:
        return

    q = collections.deque()

    for i in xrange(len(board)):
        if board[i][0] == "O":
            board[i][0] = "V"
            q.append((i, 0))
        if board[i][len(board[0]) - 1] == "O":
            board[i][len(board[0]) - 1] = "V"
            q.append((i, len(board[0]) - 1))

    for j in xrange(1, len(board[0]) - 1):
        if board[0][j] == "O":
            board[0][j] = "V"
            q.append((0, j))
        if board[len(board) - 1][j] == "O":
            board[len(board) - 1][j] = "V"
            q.append((len(board) - 1, j))

    while q:
        i, j = q.popleft()
        for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
            if (
                0 <= x < len(board)
                and 0 <= y < len(board[0])
                and board[x][y] == "O"
            ):
                board[x][y] = "V"
                q.append((x, y))

    for i in xrange(len(board)):
        for j in xrange(len(board[0])):
            if board[i][j] != "V":
                board[i][j] = "X"
            else:
                board[i][j] = "O"


class Solution(object):
    def canTransform(self, start, end):

    if start.count("X") != end.count("X"):
        return False
    i, j = 0, 0
    while i < len(start) and j < len(end):
        while i < len(start) and start[i] == "X":
            i += 1
        while j < len(end) and end[j] == "X":
            j += 1
        if (i < len(start)) != (j < len(end)):
            return False
        elif i < len(start) and j < len(end):
            if (
                start[i] != end[j]
                or (start[i] == "L" and i < j)
                or (start[i] == "R" and i > j)
            ):
                return False
        i += 1
        j += 1
    return True


import collections


class Solution(object):
    def maxRepOpt1(self, text):

    K = 1
    result = 0
    total_count, count = collections.Counter(), collections.Counter()
    left, max_count = 0, 0
    for i in xrange(len(text)):
        total_count[text[i]] += 1
        count[text[i]] += 1
        max_count = max(max_count, count[text[i]])
        if i - left + 1 - max_count > K:
            count[text[left]] -= 1
            left += 1
        result = max(result, min(i - left + 1, total_count[text[i]]))
    return result


import itertools


class Solution2(object):
    def maxRepOpt1(self, text):

    A = [[c, len(list(group))] for c, group in itertools.groupby(text)]
    total_count = collections.Counter(text)
    result = max(min(l + 1, total_count[c]) for c, l in A)
    for i in xrange(1, len(A) - 1):
        if A[i - 1][0] == A[i + 1][0] and A[i][1] == 1:
            result = max(
                result, min(A[i - 1][1] + 1 + A[i + 1]
                            [1], total_count[A[i + 1][0]])
            )
    return result


class ListNode(object):
    def __init__(self, x):
    self.val = x
    self.next = None

    def __repr__(self):
    if self:
        return "{} -> {}".format(self.val, self.next)


class Solution(object):

    def swapPairs(self, head):
    dummy = ListNode(0)
    dummy.next = head
    current = dummy
    while current.next and current.next.next:
        next_one, next_two, next_three = (
            current.next,
            current.next.next,
            current.next.next.next,
        )
        current.next = next_two
        next_two.next = next_one
        next_one.next = next_three
        current = next_one
    return dummy.next


class ListNode(object):
    def __init__(self, val=0, next=None):
    pass


class Solution(object):
    def swapNodes(self, head, k):

    left, right, curr = None, None, head
    while curr:
        k -= 1
        if right:
            right = right.next
        if k == 0:
            left = curr
            right = head
        curr = curr.next
    left.val, right.val = right.val, left.val
    return head


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[min(x_root, y_root)] = max(x_root, y_root)
    return True


class Solution(object):
    def swimInWater(self, grid):

    n = len(grid)
    positions = [None] * (n ** 2)
    for i in xrange(n):
        for j in xrange(n):
            positions[grid[i][j]] = (i, j)
    directions = ((-1, 0), (1, 0), (0, -1), (0, 1))

    union_find = UnionFind(n ** 2)
    for elevation in xrange(n ** 2):
        i, j = positions[elevation]
        for direction in directions:
            x, y = i + direction[0], j + direction[1]
            if 0 <= x < n and 0 <= y < n and grid[x][y] <= elevation:
                union_find.union_set(i * n + j, x * n + y)
                if union_find.find_set(0) == union_find.find_set(n ** 2 - 1):
                    return elevation
    return n ** 2 - 1


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def isSymmetric(self, root):
    if root is None:
        return True
    stack = []
    stack.append(root.left)
    stack.append(root.right)

    while stack:
        p, q = stack.pop(), stack.pop()

        if p is None and q is None:
            continue

        if p is None or q is None or p.val != q.val:
            return False

        stack.append(p.left)
        stack.append(q.right)

        stack.append(p.right)
        stack.append(q.left)

    return True


class Solution2(object):

    def isSymmetric(self, root):
    if root is None:
        return True

    return self.isSymmetricRecu(root.left, root.right)

    def isSymmetricRecu(self, left, right):
    if left is None and right is None:
        return True
    if left is None or right is None or left.val != right.val:
        return False
    return self.isSymmetricRecu(left.left, right.right) and self.isSymmetricRecu(
        left.right, right.left
    )


import collections
import itertools


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.count = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[max(x_root, y_root)] = min(x_root, y_root)
    return True


class Solution(object):
    def generateSentences(self, synonyms, text):

    def assign_id(x, lookup, inv_lookup):
        if x in lookup:
            return
        lookup[x] = len(lookup)
        inv_lookup[lookup[x]] = x

    lookup, inv_lookup = {}, {}
    for u, v in synonyms:
        assign_id(u, lookup, inv_lookup), assign_id(v, lookup, inv_lookup)
    union_find = UnionFind(len(lookup))
    for u, v in synonyms:
        union_find.union_set(lookup[u], lookup[v])
    groups = collections.defaultdict(list)
    for i in xrange(len(union_find.set)):
        groups[union_find.find_set(i)].append(i)
    result = []
    for w in text.split(" "):
        if w not in lookup:
            result.append([w])
            continue
        result.append(
            sorted(
                map(lambda x: inv_lookup[x],
                    groups[union_find.find_set(lookup[w])])
            )
        )
    return [" ".join(sentense) for sentense in itertools.product(*result)]


class Solution(object):
    def isValid(self, code):

    def validText(s, i):
        j = i
        i = s.find("<", i)
        return i != j, i

    def validCData(s, i):
        if s.find("<![CDATA[", i) != i:
            return False, i
        j = s.find("]]>", i)
        if j == -1:
            return False, i
        return True, j + 3

    def parseTagName(s, i):
        if s[i] != "<":
            return "", i
        j = s.find(">", i)
        if j == -1 or not (1 <= (j - 1 - i) <= 9):
            return "", i
        tag = s[i + 1: j]
        for c in tag:
            if not (ord("A") <= ord(c) <= ord("Z")):
                return "", i
        return tag, j + 1

    def parseContent(s, i):
        while i < len(s):
            result, i = validText(s, i)
            if result:
                continue
            result, i = validCData(s, i)
            if result:
                continue
            result, i = validTag(s, i)
            if result:
                continue
            break
        return i

    def validTag(s, i):
        tag, j = parseTagName(s, i)
        if not tag:
            return False, i
        j = parseContent(s, j)
        k = j + len(tag) + 2
        if k >= len(s) or s[j: k + 1] != "</" + tag + ">":
            return False, i
        return True, k + 1

    result, i = validTag(code, 0)
    return result and i == len(code)


import collections


class Solution(object):
    def tallestBillboard(self, rods):

    def dp(A):
        lookup = collections.defaultdict(int)
        lookup[0] = 0
        for x in A:
            for d, y in lookup.items():
                lookup[d + x] = max(lookup[d + x], y)
                lookup[abs(d - x)] = max(lookup[abs(d - x)], y + min(d, x))
        return lookup

    left, right = dp(rods[: len(rods) // 2]), dp(rods[len(rods) // 2:])
    return max(left[d] + right[d] + d for d in left if d in right)


import collections


class Solution(object):
    def findTargetSumWays(self, nums, S):

    def subsetSum(nums, S):
        dp = collections.defaultdict(int)
        dp[0] = 1
        for n in nums:
            for i in reversed(xrange(n, S + 1)):
                if i - n in dp:
                    dp[i] += dp[i - n]
        return dp[S]

    total = sum(nums)
    if total < S or (S + total) % 2:
        return 0
    P = (S + total) // 2
    return subsetSum(nums, P)


from collections import Counter


class Solution(object):
    def leastInterval(self, tasks, n):

    counter = Counter(tasks)
    _, max_count = counter.most_common(1)[0]

    result = (max_count - 1) * (n + 1)
    for count in counter.values():
        if count == max_count:
            result += 1
    return max(result, len(tasks))


class Solution(object):
    def findPoisonedDuration(self, timeSeries, duration):

    result = duration * len(timeSeries)
    for i in xrange(1, len(timeSeries)):
        result -= max(0, duration - (timeSeries[i] - timeSeries[i - 1]))
    return result


class Solution(object):
    def parseTernary(self, expression):

    if not expression:
        return ""

    stack = []
    for c in expression[::-1]:
        if stack and stack[-1] == "?":
            stack.pop()
            first = stack.pop()
            stack.pop()
            second = stack.pop()

            if c == "T":
                stack.append(first)
            else:
                stack.append(second)
        else:
            stack.append(c)

    return str(stack[-1])


class Solution(object):
    def fullJustify(self, words, maxWidth):

    def addSpaces(i, spaceCnt, maxWidth, is_last):
        if i < spaceCnt:

            return (
                1
                if is_last
                else (maxWidth // spaceCnt) + int(i < maxWidth % spaceCnt)
            )
        return 0

    def connect(words, maxWidth, begin, end, length, is_last):
        s = []
        n = end - begin
        for i in xrange(n):
            s += (words[begin + i],)
            s += (" " * addSpaces(i, n - 1, maxWidth - length, is_last),)

        line = "".join(s)
        if len(line) < maxWidth:
            line += " " * (maxWidth - len(line))
        return line

    res = []
    begin, length = 0, 0
    for i in xrange(len(words)):
        if length + len(words[i]) + (i - begin) > maxWidth:
            res += (connect(words, maxWidth, begin, i, length, False),)
            begin, length = i, 0
        length += len(words[i])

    res += (connect(words, maxWidth, begin, len(words), length, True),)
    return res


import threading


class DiningPhilosophers(object):
    def __init__(self):
    self._l = [threading.Lock() for _ in xrange(5)]

    def wantsToEat(
        self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork
    ):

    left, right = philosopher, (philosopher + 4) % 5
    first, second = left, right
    if philosopher % 2 == 0:
        first, second = left, right
    else:
        first, second = right, left

    with self._l[first]:
        with self._l[second]:
            pickLeftFork()
            pickRightFork()
            eat()
            putLeftFork()
            putRightFork()


class UnionFind(object):
    def __init__(self, n):
    self.set = range(n)
    self.count = n

    def find_set(self, x):
    if self.set[x] != x:
        self.set[x] = self.find_set(self.set[x])
    return self.set[x]

    def union_set(self, x, y):
    x_root, y_root = map(self.find_set, (x, y))
    if x_root == y_root:
        return False
    self.set[max(x_root, y_root)] = min(x_root, y_root)
    self.count -= 1
    return True


class Solution(object):
    def earliestAcq(self, logs, N):

    logs.sort()
    union_find = UnionFind(N)
    for t, a, b in logs:
        union_find.union_set(a, b)
        if union_find.count == 1:
            return t
    return -1


class Solution(object):
    def getStrongest(self, arr, k):

    arr.sort()
    m = arr[(len(arr) - 1) // 2]
    result = []
    left, right = 0, len(arr) - 1
    while len(result) < k:
        if m - arr[left] > arr[right] - m:
            result.append(arr[left])
            left += 1
        else:
            result.append(arr[right])
            right -= 1
    return result


class Solution2(object):
    def getStrongest(self, arr, k):

    arr.sort()
    m = arr[(len(arr) - 1) // 2]
    arr.sort(key=lambda x: (-abs(x - m), -x))
    return arr[:k]


import random


class Solution_TLE(object):
    def getStrongest(self, arr, k):

    def nth_element(nums, n, compare=lambda a, b: a < b):
        def partition_around_pivot(left, right, pivot_idx, nums, compare):
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in xrange(left, right):
                if compare(nums[i], nums[right]):
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            new_pivot_idx = partition_around_pivot(
                left, right, pivot_idx, nums, compare
            )
            if new_pivot_idx == n:
                return
            elif new_pivot_idx > n:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    nth_element(arr, (len(arr) - 1) // 2)
    m = arr[(len(arr) - 1) // 2]
    nth_element(
        arr,
        k,
        lambda a, b: abs(a - m) > abs(b - m) if abs(a -
                                                    m) != abs(b - m) else a > b,
    )
    return arr[:k]


class Solution(object):
    def getHappyString(self, n, k):

    base = 2 ** (n - 1)
    if k > 3 * base:
        return ""
    result = [chr(ord("a") + (k - 1) // base)]
    while base > 1:
        k -= (k - 1) // base * base
        base //= 2
        result.append(
            ("a" if result[-1] != "a" else "b")
            if (k - 1) // base == 0
            else ("c" if result[-1] != "c" else "b")
        )
    return "".join(result)


class Solution(object):
    def kWeakestRows(self, mat, k):

    result, lookup = [], set()
    for j in xrange(len(mat[0])):
        for i in xrange(len(mat)):
            if mat[i][j] or i in lookup:
                continue
            lookup.add(i)
            result.append(i)
            if len(result) == k:
                return result
    for i in xrange(len(mat)):
        if i in lookup:
            continue
        lookup.add(i)
        result.append(i)
        if len(result) == k:
            break
    return result


import collections


class Solution2(object):
    def kWeakestRows(self, mat, k):

    lookup = collections.OrderedDict()
    for j in xrange(len(mat[0])):
        for i in xrange(len(mat)):
            if mat[i][j] or i in lookup:
                continue
            lookup[i] = True
            if len(lookup) == k:
                return lookup.keys()
    for i in xrange(len(mat)):
        if i in lookup:
            continue
        lookup[i] = True
        if len(lookup) == k:
            break
    return lookup.keys()


import random


class Solution3(object):
    def kWeakestRows(self, mat, k):

    def nth_element(nums, n, compare=lambda a, b: a < b):
        def partition_around_pivot(left, right, pivot_idx, nums, compare):
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in xrange(left, right):
                if compare(nums[i], nums[right]):
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            new_pivot_idx = partition_around_pivot(
                left, right, pivot_idx, nums, compare
            )
            if new_pivot_idx == n:
                return
            elif new_pivot_idx > n:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    nums = [(sum(mat[i]), i) for i in xrange(len(mat))]
    nth_element(nums, k)
    return map(lambda x: x[1], sorted(nums[:k]))


class Solution(object):
    def kthFactor(self, n, k):

    def kth_factor(n, k=0):
        mid = None
        i = 1
        while i * i <= n:
            if not n % i:
                mid = i
                k -= 1
                if not k:
                    break
            i += 1
        return mid, -k

    mid, count = kth_factor(n)
    total = 2 * count - (mid * mid == n)
    if k > total:
        return -1
    result = kth_factor(n, k if k <= count else total - (k - 1))[0]
    return result if k <= count else n // result


class Solution2(object):
    def kthFactor(self, n, k):

    result = []
    i = 1
    while i * i <= n:
        if not n % i:
            if i * i != n:
                result.append(i)
            k -= 1
            if not k:
                return i
        i += 1
    return -1 if k > len(result) else n // result[-k]


import heapq


class Solution(object):
    def shortestDistance(self, maze, start, destination):

    start, destination = tuple(start), tuple(destination)

    def neighbors(maze, node):
        for dir in [(-1, 0), (0, 1), (0, -1), (1, 0)]:
            cur_node, dist = list(node), 0
            while (
                0 <= cur_node[0] + dir[0] < len(maze)
                and 0 <= cur_node[1] + dir[1] < len(maze[0])
                and not maze[cur_node[0] + dir[0]][cur_node[1] + dir[1]]
            ):
                cur_node[0] += dir[0]
                cur_node[1] += dir[1]
                dist += 1
            yield dist, tuple(cur_node)

    heap = [(0, start)]
    visited = set()
    while heap:
        dist, node = heapq.heappop(heap)
        if node in visited:
            continue
        if node == destination:
            return dist
        visited.add(node)
        for neighbor_dist, neighbor in neighbors(maze, node):
            heapq.heappush(heap, (dist + neighbor_dist, neighbor))

    return -1


import heapq


class Solution(object):
    def findShortestWay(self, maze, ball, hole):

    ball, hole = tuple(ball), tuple(hole)
    dirs = {"u": (-1, 0), "r": (0, 1), "l": (0, -1), "d": (1, 0)}

    def neighbors(maze, node):
        for dir, vec in dirs.iteritems():
            cur_node, dist = list(node), 0
            while (
                0 <= cur_node[0] + vec[0] < len(maze)
                and 0 <= cur_node[1] + vec[1] < len(maze[0])
                and not maze[cur_node[0] + vec[0]][cur_node[1] + vec[1]]
            ):
                cur_node[0] += vec[0]
                cur_node[1] += vec[1]
                dist += 1
                if tuple(cur_node) == hole:
                    break
            yield tuple(cur_node), dir, dist

    heap = [(0, "", ball)]
    visited = set()
    while heap:
        dist, path, node = heapq.heappop(heap)
        if node in visited:
            continue
        if node == hole:
            return path
        visited.add(node)
        for neighbor, dir, neighbor_dist in neighbors(maze, node):
            heapq.heappush(heap, (dist + neighbor_dist, path + dir, neighbor))

    return "impossible"


import collections


class Solution(object):
    def hasPath(self, maze, start, destination):

    def neighbors(maze, node):
        for i, j in [(-1, 0), (0, 1), (0, -1), (1, 0)]:
            x, y = node
            while (
                0 <= x + i < len(maze)
                and 0 <= y + j < len(maze[0])
                and not maze[x + i][y + j]
            ):
                x += i
                y += j
            yield x, y

    start, destination = tuple(start), tuple(destination)
    queue = collections.deque([start])
    visited = set()
    while queue:
        node = queue.popleft()
        if node in visited:
            continue
        if node == destination:
            return True
        visited.add(node)
        for neighbor in neighbors(maze, node):
            queue.append(neighbor)

    return False


class Solution(object):
    def mostSimilar(self, n, roads, names, targetPath):

    adj = [[] for _ in xrange(n)]
    for u, v in roads:
        adj[u].append(v)
        adj[v].append(u)

    dp = [[0] * n for _ in xrange(len(targetPath) + 1)]
    for i in xrange(1, len(targetPath) + 1):
        for v in xrange(n):
            dp[i][v] = (names[v] != targetPath[i - 1]) + min(
                dp[i - 1][u] for u in adj[v]
            )

    path = [dp[-1].index(min(dp[-1]))]
    for i in reversed(xrange(2, len(targetPath) + 1)):
        for u in adj[path[-1]]:
            if (
                dp[i - 1][u] + (names[path[-1]] != targetPath[i - 1])
                == dp[i][path[-1]]
            ):
                path.append(u)
                break
    return path[::-1]


start, end, height = 0, 1, 2


class Solution(object):

    def getSkyline(self, buildings):
    intervals = self.ComputeSkylineInInterval(buildings, 0, len(buildings))

    res = []
    last_end = -1
    for interval in intervals:
        if last_end != -1 and last_end < interval[start]:
            res.append([last_end, 0])
        res.append([interval[start], interval[height]])
        last_end = interval[end]
    if last_end != -1:
        res.append([last_end, 0])

    return res

    def ComputeSkylineInInterval(self, buildings, left_endpoint, right_endpoint):
    if right_endpoint - left_endpoint <= 1:
        return buildings[left_endpoint:right_endpoint]
    mid = left_endpoint + ((right_endpoint - left_endpoint) / 2)
    left_skyline = self.ComputeSkylineInInterval(buildings, left_endpoint, mid)
    right_skyline = self.ComputeSkylineInInterval(
        buildings, mid, right_endpoint)
    return self.MergeSkylines(left_skyline, right_skyline)

    def MergeSkylines(self, left_skyline, right_skyline):
    i, j = 0, 0
    merged = []

    while i < len(left_skyline) and j < len(right_skyline):
        if left_skyline[i][end] < right_skyline[j][start]:
            merged.append(left_skyline[i])
            i += 1
        elif right_skyline[j][end] < left_skyline[i][start]:
            merged.append(right_skyline[j])
            j += 1
        elif left_skyline[i][start] <= right_skyline[j][start]:
            i, j = self.MergeIntersectSkylines(
                merged, left_skyline[i], i, right_skyline[j], j
            )
        else:
            j, i = self.MergeIntersectSkylines(
                merged, right_skyline[j], j, left_skyline[i], i
            )

    merged += left_skyline[i:]
    merged += right_skyline[j:]
    return merged

    def MergeIntersectSkylines(self, merged, a, a_idx, b, b_idx):
    if a[end] <= b[end]:
        if a[height] > b[height]:
            if b[end] != a[end]:
                b[start] = a[end]
                merged.append(a)
                a_idx += 1
            else:
                b_idx += 1
        elif a[height] == b[height]:
            b[start] = a[start]
            a_idx += 1
        else:
            if a[start] != b[start]:
                merged.append([a[start], b[start], a[height]])
            a_idx += 1
    else:
        if a[height] >= b[height]:
            b_idx += 1
        else:

            if a[start] != b[start]:
                merged.append([a[start], b[start], a[height]])
            a[start] = b[end]
            merged.append(b)
            b_idx += 1
    return a_idx, b_idx


class Solution(object):
    def thirdMax(self, nums):

    count = 0
    top = [float("-inf")] * 3
    for num in nums:
        if num > top[0]:
            top[0], top[1], top[2] = num, top[0], top[1]
            count += 1
        elif num != top[0] and num > top[1]:
            top[1], top[2] = num, top[1]
            count += 1
        elif num != top[0] and num != top[1] and num >= top[2]:
            top[2] = num
            count += 1

    if count < 3:
        return top[0]

    return top[2]


class Solution(object):
    def thousandSeparator(self, n):

    result = []
    s = str(n)
    for i, c in enumerate(str(n)):
        if i and (len(s) - i) % 3 == 0:
            result.append(".")
        result.append(c)
    return "".join(result)


class Solution(object):
    def threeConsecutiveOdds(self, arr):

    count = 0
    for x in arr:
        count = count + 1 if x % 2 else 0
        if count == 3:
            return True
    return False


class Solution(object):
    def threeEqualParts(self, A):

    total = sum(A)
    if total % 3 != 0:
        return [-1, -1]
    if total == 0:
        return [0, len(A) - 1]

    count = total // 3
    nums = [0] * 3
    c = 0
    for i in xrange(len(A)):
        if A[i] == 1:
            if c % count == 0:
                nums[c // count] = i
            c += 1

    while nums[2] != len(A):
        if not A[nums[0]] == A[nums[1]] == A[nums[2]]:
            return [-1, -1]
        nums[0] += 1
        nums[1] += 1
        nums[2] += 1
    return [nums[0] - 1, nums[1]]


import collections


class ThroneInheritance(object):
    def __init__(self, kingName):

    self.__king = kingName
    self.__family_tree = collections.defaultdict(list)
    self.__dead = set()

    def birth(self, parentName, childName):

    self.__family_tree[parentName].append(childName)

    def death(self, name):

    self.__dead.add(name)

    def getInheritanceOrder(self):

    result = []
    stk = [self.__king]
    while stk:
        node = stk.pop()
        if node not in self.__dead:
            result.append(node)
        if node not in self.__family_tree:
            continue
        for child in reversed(self.__family_tree[node]):
            stk.append(child)
    return result


class Solution(object):
    def tilingRectangle(self, n, m):

    def find_next(board):
        for i in xrange(len(board)):
            for j in xrange(len(board[0])):
                if not board[i][j]:
                    return i, j
        return -1, -1

    def find_max_length(board, i, j):
        max_length = 1
        while i + max_length - 1 < len(board) and j + max_length - 1 < len(
            board[0]
        ):
            for r in xrange(i, i + max_length - 1):
                if board[r][j + max_length - 1]:
                    return max_length - 1
            for c in xrange(j, j + max_length):
                if board[i + max_length - 1][c]:
                    return max_length - 1
            max_length += 1
        return max_length - 1

    def fill(board, i, j, length, val):
        for r in xrange(i, i + length):
            for c in xrange(j, j + length):
                board[r][c] = val

    def backtracking(board, count, result):
        if count >= result[0]:
            return
        i, j = find_next(board)
        if (i, j) == (-1, -1):
            result[0] = min(result[0], count)
            return
        max_length = find_max_length(board, i, j)
        for k in reversed(xrange(1, max_length + 1)):
            fill(board, i, j, k, 1)
            backtracking(board, count + 1, result)
            fill(board, i, j, k, 0)

    if m > n:
        return self.tilingRectangle(m, n)
    board = [[0] * m for _ in xrange(n)]
    result = [float("inf")]
    backtracking(board, 0, result)
    return result[0]


import collections
import bisect


class TimeMap(object):
    def __init__(self):

    self.lookup = collections.defaultdict(list)

    def set(self, key, value, timestamp):

    self.lookup[key].append((timestamp, value))

    def get(self, key, timestamp):

    A = self.lookup.get(key, None)
    if A is None:
        return ""
    i = bisect.bisect_right(A, (timestamp + 1, 0))
    return A[i - 1][1] if i else ""


import collections


class Solution(object):
    def numOfMinutes(self, n, headID, manager, informTime):

    children = collections.defaultdict(list)
    for child, parent in enumerate(manager):
        if parent != -1:
            children[parent].append(child)

    result = 0
    stk = [(headID, 0)]
    while stk:
        node, curr = stk.pop()
        curr += informTime[node]
        result = max(result, curr)
        if node not in children:
            continue
        for c in children[node]:
            stk.append((c, curr))
    return result


class Solution2(object):
    def numOfMinutes(self, n, headID, manager, informTime):

    def dfs(informTime, children, node):
        return (
            max(dfs(informTime, children, c) for c in children[node])
            if node in children
            else 0
        ) + informTime[node]

    children = collections.defaultdict(list)
    for child, parent in enumerate(manager):
        if parent != -1:
            children[parent].append(child)
    return dfs(informTime, children, headID)


class Solution(object):
    def toLowerCase(self, str):

    return "".join(
        [chr(ord("a") + ord(c) - ord("A"))
         if "A" <= c <= "Z" else c for c in str]
    )


class Solution(object):
    def isToeplitzMatrix(self, matrix):

    return all(
        i == 0 or j == 0 or matrix[i - 1][j - 1] == val
        for i, row in enumerate(matrix)
        for j, val in enumerate(row)
    )


class Solution2(object):
    def isToeplitzMatrix(self, matrix):

    for row_index, row in enumerate(matrix):
        for digit_index, digit in enumerate(row):
            if not row_index or not digit_index:
                continue
            if matrix[row_index - 1][digit_index - 1] != digit:
                return False
    return True


import collections


class Solution(object):
    def topKFrequent(self, nums, k):

    counts = collections.Counter(nums)
    buckets = [[] for _ in xrange(len(nums) + 1)]
    for i, count in counts.iteritems():
        buckets[count].append(i)

    result = []
    for i in reversed(xrange(len(buckets))):
        for j in xrange(len(buckets[i])):
            result.append(buckets[i][j])
            if len(result) == k:
                return result
    return result


from random import randint


class Solution2(object):
    def topKFrequent(self, nums, k):

    counts = collections.Counter(nums)
    p = []
    for key, val in counts.iteritems():
        p.append((-val, key))
    self.kthElement(p, k - 1)

    result = []
    for i in xrange(k):
        result.append(p[i][1])
    return result

    def kthElement(self, nums, k):

    def PartitionAroundPivot(left, right, pivot_idx, nums):
        pivot_value = nums[pivot_idx]
        new_pivot_idx = left
        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
        for i in xrange(left, right):
            if nums[i] < pivot_value:
                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                new_pivot_idx += 1

        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
        return new_pivot_idx

    left, right = 0, len(nums) - 1
    while left <= right:
        pivot_idx = randint(left, right)
        new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)
        if new_pivot_idx == k:
            return
        elif new_pivot_idx > k:
            right = new_pivot_idx - 1
        else:
            left = new_pivot_idx + 1


class Solution3(object):
    def topKFrequent(self, nums, k):

    return [key for key, _ in collections.Counter(nums).most_common(k)]


import collections
import heapq
from random import randint


class Solution(object):
    def topKFrequent(self, words, k):

    counts = collections.Counter(words)
    p = []
    for key, val in counts.iteritems():
        p.append((-val, key))
    self.kthElement(p, k - 1)

    result = []
    sorted_p = sorted(p[:k])
    for i in xrange(k):
        result.append(sorted_p[i][1])
    return result

    def kthElement(self, nums, k):

    def PartitionAroundPivot(left, right, pivot_idx, nums):
        pivot_value = nums[pivot_idx]
        new_pivot_idx = left
        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
        for i in xrange(left, right):
            if nums[i] < pivot_value:
                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                new_pivot_idx += 1

        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
        return new_pivot_idx

    left, right = 0, len(nums) - 1
    while left <= right:
        pivot_idx = randint(left, right)
        new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums)
        if new_pivot_idx == k:
            return
        elif new_pivot_idx > k:
            right = new_pivot_idx - 1
        else:
            left = new_pivot_idx + 1


class Solution2(object):
    def topKFrequent(self, words, k):

    class MinHeapObj(object):
        def __init__(self, val):
            self.val = val

        def __lt__(self, other):
            return (
                self.val[1] > other.val[1]
                if self.val[0] == other.val[0]
                else self.val < other.val
            )

        def __eq__(self, other):
            return self.val == other.val

        def __str__(self):
            return str(self.val)

    counts = collections.Counter(words)
    min_heap = []
    for word, count in counts.iteritems():
        heapq.heappush(min_heap, MinHeapObj((count, word)))
        if len(min_heap) == k + 1:
            heapq.heappop(min_heap)
    result = []
    while min_heap:
        result.append(heapq.heappop(min_heap).val[1])
    return result[::-1]


class Solution3(object):
    def topKFrequent(self, words, k):

    counts = collections.Counter(words)
    buckets = [[] for _ in xrange(len(words) + 1)]
    for word, count in counts.iteritems():
        buckets[count].append(word)
    pairs = []
    for i in reversed(xrange(len(words))):
        for word in buckets[i]:
            pairs.append((-i, word))
        if len(pairs) >= k:
            break
    pairs.sort()
    return [pair[1] for pair in pairs[:k]]


from collections import Counter


class Solution4(object):
    def topKFrequent(self, words, k):

    counter = Counter(words)
    candidates = counter.keys()
    candidates.sort(key=lambda w: (-counter[w], w))
    return candidates[:k]


class Solution(object):
    def probabilityOfHeads(self, prob, target):

    dp = [0.0] * (target + 1)
    dp[0] = 1.0
    for p in prob:
        for i in reversed(xrange(target + 1)):
            dp[i] = (dp[i - 1] if i >= 1 else 0.0) * p + dp[i] * (1 - p)
    return dp[target]


class Solution(object):
    def totalHammingDistance(self, nums):

    result = 0
    for i in xrange(32):
        counts = [0] * 2
        for num in nums:
            counts[(num >> i) & 1] += 1
        result += counts[0] * counts[1]
    return result


import threading


class TrafficLight(object):
    def __init__(self):
    self.__l = threading.Lock()
    self.__light = 1

    def carArrived(self, carId, roadId, direction, turnGreen, crossCar):

    with self.__l:
        if self.__light != roadId:
            self.__light = roadId
            turnGreen()
        crossCar()


import collections
import itertools


class Solution(object):
    def movesToChessboard(self, board):

    N = len(board)
    result = 0
    for count in (
        collections.Counter(map(tuple, board)),
        collections.Counter(itertools.izip(*board)),
    ):
        if len(count) != 2 or sorted(count.values()) != [N / 2, (N + 1) / 2]:
            return -1

        seq1, seq2 = count
        if any(x == y for x, y in itertools.izip(seq1, seq2)):
            return -1
        begins = [int(seq1.count(1) * 2 > N)] if N % 2 else [0, 1]
        result += (
            min(
                sum(int(i % 2 != v) for i, v in enumerate(seq1, begin))
                for begin in begins
            )
            / 2
        )
    return result


class Solution(object):
    def transpose(self, A):

    result = [[None] * len(A) for _ in xrange(len(A[0]))]
    for r, row in enumerate(A):
        for c, val in enumerate(row):
            result[c][r] = val
    return result


class Solution2(object):
    def transpose(self, A):

    return zip(*A)


from heapq import heappush, heappop


class Solution(object):
    def trapRainWater(self, heightMap):

    m = len(heightMap)
    if not m:
        return 0
    n = len(heightMap[0])
    if not n:
        return 0

    is_visited = [[False for i in xrange(n)] for j in xrange(m)]

    heap = []
    for i in xrange(m):
        heappush(heap, [heightMap[i][0], i, 0])
        is_visited[i][0] = True
        heappush(heap, [heightMap[i][n - 1], i, n - 1])
        is_visited[i][n - 1] = True
    for j in xrange(1, n - 1):
        heappush(heap, [heightMap[0][j], 0, j])
        is_visited[0][j] = True
        heappush(heap, [heightMap[m - 1][j], m - 1, j])
        is_visited[m - 1][j] = True

    trap = 0
    while heap:
        height, i, j = heappop(heap)
        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            x, y = i + dx, j + dy
            if 0 <= x < m and 0 <= y < n and not is_visited[x][y]:
                trap += max(0, height - heightMap[x][y])
                heappush(heap, [max(height, heightMap[x][y]), x, y])
                is_visited[x][y] = True

    return trap


class Solution(object):
    def trap(self, height):

    result, left, right, level = 0, 0, len(height) - 1, 0
    while left < right:
        if height[left] < height[right]:
            lower = height[left]
            left += 1
        else:
            lower = height[right]
            right -= 1
        level = max(level, lower)
        result += level - lower
    return result


class Solution2(object):

    def trap(self, A):
    result = 0
    top = 0
    for i in xrange(len(A)):
        if A[top] < A[i]:
            top = i

    second_top = 0
    for i in xrange(top):
        if A[second_top] < A[i]:
            second_top = i
        result += A[second_top] - A[i]

    second_top = len(A) - 1
    for i in reversed(xrange(top, len(A))):
        if A[second_top] < A[i]:
            second_top = i
        result += A[second_top] - A[i]

    return result


class Solution3(object):

    def trap(self, A):
    result = 0
    stack = []

    for i in xrange(len(A)):
        mid_height = 0
        while stack:
            [pos, height] = stack.pop()
            result += (min(height, A[i]) - mid_height) * (i - pos - 1)
            mid_height = height

            if A[i] < height:
                stack.append([pos, height])
                break
        stack.append([i, A[i]])

    return result


import collections


class Solution(object):
    def treeDiameter(self, edges):

    graph, length = collections.defaultdict(set), 0
    for u, v in edges:
        graph[u].add(v)
        graph[v].add(u)
    curr_level = {
        (None, u) for u, neighbors in graph.iteritems() if len(neighbors) == 1
    }
    while curr_level:
        curr_level = {
            (u, v) for prev, u in curr_level for v in graph[u] if v != prev
        }
        length += 1
    return max(length - 1, 0)


import collections
import fractions


class Solution(object):
    def getCoprimes(self, nums, edges):

    def iter_dfs(nums, adj):
        result = [-1] * len(nums)
        path = collections.defaultdict(list)
        stk = [(1, (-1, 0, 0))]
        while stk:
            step, params = stk.pop()
            if step == 1:
                prev, node, depth = params
                stk.append((4, (node,)))
                stk.append((3, (prev, node, depth)))
                stk.append((2, (node,)))
            elif step == 2:
                node = params[0]
                max_d = -1
                for x in path.iterkeys():
                    if fractions.gcd(nums[node], x) != 1:
                        continue
                    if path[x][-1][1] > max_d:
                        max_d = path[x][-1][1]
                        result[node] = path[x][-1][0]
            elif step == 3:
                prev, node, depth = params
                path[nums[node]].append((node, depth))
                for nei in adj[node]:
                    if nei == prev:
                        continue
                    stk.append((1, (node, nei, depth + 1)))
            elif step == 4:
                node = params[0]
                path[nums[node]].pop()
                if not path[nums[node]]:
                    path.pop(nums[node])
        return result

    adj = collections.defaultdict(list)
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)
    return iter_dfs(nums, adj)


import collections
import fractions


class Solution2(object):
    def getCoprimes(self, nums, edges):

    def dfs(nums, adj, prev, node, depth, path, result):
        max_d = -1
        for x in path.iterkeys():
            if fractions.gcd(nums[node], x) != 1:
                continue
            if path[x][-1][1] > max_d:
                max_d = path[x][-1][1]
                result[node] = path[x][-1][0]
        path[nums[node]].append((node, depth))
        for nei in adj[node]:
            if nei == prev:
                continue
            dfs(nums, adj, node, nei, depth + 1, path, result)
        path[nums[node]].pop()
        if not path[nums[node]]:
            path.pop(nums[node])

    adj = collections.defaultdict(list)
    for u, v in edges:
        adj[u].append(v)
        adj[v].append(u)
    result = [-1] * len(nums)
    path = collections.defaultdict(list)
    dfs(nums, adj, -1, 0, 0, path, result)
    return result


from functools import reduce


class Solution(object):

    def minimumTotal(self, triangle):
    if not triangle:
        return 0

    cur = triangle[0] + [float("inf")]
    for i in xrange(1, len(triangle)):
        next = []
        next.append(triangle[i][0] + cur[0])
        for j in xrange(1, i + 1):
            next.append(triangle[i][j] + min(cur[j - 1], cur[j]))
        cur = next + [float("inf")]

    return reduce(min, cur)


class Solution(object):
    def trimBST(self, root, L, R):

    if not root:
        return None
    if root.val < L:
        return self.trimBST(root.right, L, R)
    if root.val > R:
        return self.trimBST(root.left, L, R)
    root.left, root.right = self.trimBST(root.left, L, R), self.trimBST(
        root.right, L, R
    )
    return root


import collections


class Solution(object):
    def countTriplets(self, A):

    def FWT(A, v):
        B = A[:]
        d = 1
        while d < len(B):
            for i in xrange(0, len(B), d << 1):
                for j in xrange(d):
                    B[i + j] += B[i + j + d] * v
            d <<= 1
        return B

    k = 3
    n, max_A = 1, max(A)
    while n <= max_A:
        n *= 2
    count = collections.Counter(A)
    B = [count[i] for i in xrange(n)]
    C = FWT(map(lambda x: x ** k, FWT(B, 1)), -1)
    return C[0]


import collections


class Solution2(object):
    def countTriplets(self, A):

    count = collections.defaultdict(int)
    for i in xrange(len(A)):
        for j in xrange(len(A)):
            count[A[i] & A[j]] += 1
    result = 0
    for k in xrange(len(A)):
        for v in count:
            if A[k] & v == 0:
                result += count[v]
    return result


import collections


class Solution(object):
    def tupleSameProduct(self, nums):

    result = 0
    count = collections.Counter()
    for i in xrange(len(nums)):
        for j in xrange(i + 1, len(nums)):
            result += count[nums[i] * nums[j]]
            count[nums[i] * nums[j]] += 1
    return 8 * result


import collections
import random


class SkipNode(object):
    def __init__(self, level=0, val=None):
    self.val = val
    self.nexts = [None] * level
    self.prevs = [None] * level


class SkipList(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2
    MAX_LEVEL = 32

    def __init__(self, end=float("inf"), can_duplicated=False):
    random.seed(0)
    self.__head = SkipNode()
    self.__len = 0
    self.__can_duplicated = can_duplicated
    self.add(end)

    def lower_bound(self, target):
    return self.__lower_bound(target, self.__find_prev_nodes(target))

    def find(self, target):
    return self.__find(target, self.__find_prev_nodes(target))

    def add(self, val):
    if not self.__can_duplicated and self.find(val):
        return False
    node = SkipNode(self.__random_level(), val)
    if len(self.__head.nexts) < len(node.nexts):
        self.__head.nexts.extend(
            [None] * (len(node.nexts) - len(self.__head.nexts))
        )
    prevs = self.__find_prev_nodes(val)
    for i in xrange(len(node.nexts)):
        node.nexts[i] = prevs[i].nexts[i]
        if prevs[i].nexts[i]:
            prevs[i].nexts[i].prevs[i] = node
        prevs[i].nexts[i] = node
        node.prevs[i] = prevs[i]
    self.__len += 1
    return True

    def remove(self, val):
    prevs = self.__find_prev_nodes(val)
    curr = self.__find(val, prevs)
    if not curr:
        return False
    self.__len -= 1
    for i in reversed(xrange(len(curr.nexts))):
        prevs[i].nexts[i] = curr.nexts[i]
        if curr.nexts[i]:
            curr.nexts[i].prevs[i] = prevs[i]
        if not self.__head.nexts[i]:
            self.__head.nexts.pop()
    return True

    def __lower_bound(self, val, prevs):
    if prevs:
        candidate = prevs[0].nexts[0]
        if candidate:
            return candidate
    return None

    def __find(self, val, prevs):
    candidate = self.__lower_bound(val, prevs)
    if candidate and candidate.val == val:
        return candidate
    return None

    def __find_prev_nodes(self, val):
    prevs = [None] * len(self.__head.nexts)
    curr = self.__head
    for i in reversed(xrange(len(self.__head.nexts))):
        while curr.nexts[i] and curr.nexts[i].val < val:
            curr = curr.nexts[i]
        prevs[i] = curr
    return prevs

    def __random_level(self):
    level = 1
    while (
        random.randint(1, SkipList.P_DENOMINATOR) <= SkipList.P_NUMERATOR
        and level < SkipList.MAX_LEVEL
    ):
        level += 1
    return level

    def __len__(self):
    return self.__len - 1

    def __str__(self):
    result = []
    for i in reversed(xrange(len(self.__head.nexts))):
        result.append([])
        curr = self.__head.nexts[i]
        while curr:
            result[-1].append(str(curr.val))
            curr = curr.nexts[i]
    return "\n".join(map(lambda x: "->".join(x), result))


class TweetCounts(object):
    def __init__(self):
    self.__records = collections.defaultdict(
        lambda: SkipList(can_duplicated=True))
    self.__lookup = {"minute": 60, "hour": 3600, "day": 86400}

    def recordTweet(self, tweetName, time):

    self.__records[tweetName].add(time)

    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):

    delta = self.__lookup[freq]
    result = [0] * ((endTime - startTime) // delta + 1)
    it = self.__records[tweetName].lower_bound(startTime)
    while it is not None and it.val <= endTime:
        result[(it.val - startTime) // delta] += 1
        it = it.nexts[0]
    return result


import bisect


class TweetCounts2(object):
    def __init__(self):
    self.__records = collections.defaultdict(list)
    self.__lookup = {"minute": 60, "hour": 3600, "day": 86400}

    def recordTweet(self, tweetName, time):

    bisect.insort(self.__records[tweetName], time)

    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):

    delta = self.__lookup[freq]
    i = startTime
    result = []
    while i <= endTime:
        j = min(i + delta, endTime + 1)
        result.append(
            bisect.bisect_left(self.__records[tweetName], j)
            - bisect.bisect_left(self.__records[tweetName], i)
        )
        i += delta
    return result


class TweetCounts3(object):
    def __init__(self):
    self.__records = collections.defaultdict(list)
    self.__lookup = {"minute": 60, "hour": 3600, "day": 86400}

    def recordTweet(self, tweetName, time):

    self.__records[tweetName].append(time)

    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):

    delta = self.__lookup[freq]
    result = [0] * ((endTime - startTime) // delta + 1)
    for t in self.__records[tweetName]:
        if startTime <= t <= endTime:
            result[(t - startTime) // delta] += 1
    return result


import random


class Solution(object):
    def twoCitySchedCost(self, costs):

    def kthElement(nums, k, compare):
        def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
            new_pivot_idx = left
            nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
            for i in xrange(left, right):
                if compare(nums[i], nums[right]):
                    nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                    new_pivot_idx += 1

            nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
            return new_pivot_idx

        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = random.randint(left, right)
            new_pivot_idx = PartitionAroundPivot(
                left, right, pivot_idx, nums, compare
            )
            if new_pivot_idx == k:
                return
            elif new_pivot_idx > k:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    kthElement(costs, len(costs) // 2, lambda a, b: a[0] - a[1] < b[0] - b[1])
    result = 0
    for i in xrange(len(costs)):
        result += costs[i][0] if i < len(costs) // 2 else costs[i][1]
    return result


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def twoSumBSTs(self, root1, root2, target):

    def inorder_gen(root, asc=True):
        result, stack = [], [(root, False)]
        while stack:
            root, is_visited = stack.pop()
            if root is None:
                continue
            if is_visited:
                yield root.val
            else:
                if asc:
                    stack.append((root.right, False))
                    stack.append((root, True))
                    stack.append((root.left, False))
                else:
                    stack.append((root.left, False))
                    stack.append((root, True))
                    stack.append((root.right, False))

    left_gen, right_gen = inorder_gen(root1, True), inorder_gen(root2, False)
    left, right = next(left_gen), next(right_gen)
    while left is not None and right is not None:
        if left + right < target:
            left = next(left_gen)
        elif left + right > target:
            right = next(right_gen)
        else:
            return True
    return False


class Solution(object):
    def twoSum(self, nums, target):
    start, end = 0, len(nums) - 1

    while start != end:
        sum = nums[start] + nums[end]
        if sum > target:
            end -= 1
        elif sum < target:
            start += 1
        else:
            return [start + 1, end + 1]


from collections import defaultdict


class TwoSum(object):
    def __init__(self):

    self.lookup = defaultdict(int)

    def add(self, number):

    self.lookup[number] += 1

    def find(self, value):

    for key in self.lookup:
        num = value - key
        if num in self.lookup and (num != key or self.lookup[key] > 1):
            return True
    return False


class Solution(object):
    def findTarget(self, root, k):

    class BSTIterator(object):
        def __init__(self, root, forward):
            self.__node = root
            self.__forward = forward
            self.__s = []
            self.__cur = None
            self.next()

        def val(self):
            return self.__cur

        def next(self):
            while self.__node or self.__s:
                if self.__node:
                    self.__s.append(self.__node)
                    self.__node = (
                        self.__node.left if self.__forward else self.__node.right
                    )
                else:
                    self.__node = self.__s.pop()
                    self.__cur = self.__node.val
                    self.__node = (
                        self.__node.right if self.__forward else self.__node.left
                    )
                    break

    if not root:
        return False
    left, right = BSTIterator(root, True), BSTIterator(root, False)
    while left.val() < right.val():
        if left.val() + right.val() == k:
            return True
        elif left.val() + right.val() < k:
            left.next()
        else:
            right.next()
    return False


class Solution(object):
    def twoSumLessThanK(self, A, K):

    A.sort()
    result = -1
    left, right = 0, len(A) - 1
    while left < right:
        if A[left] + A[right] >= K:
            right -= 1
        else:
            result = max(result, A[left] + A[right])
            left += 1
    return result


class Solution(object):
    def twoSum(self, nums, target):

    lookup = {}
    for i, num in enumerate(nums):
        if target - num in lookup:
            return [lookup[target - num], i]
        lookup[num] = i

    def twoSum2(self, nums, target):

    for i in nums:
        j = target - i
        tmp_nums_start_index = nums.index(i) + 1
        tmp_nums = nums[tmp_nums_start_index:]
        if j in tmp_nums:
            return [nums.index(i), tmp_nums_start_index + tmp_nums.index(j)]


import heapq


class Solution(object):

    def nthUglyNumber(self, n):
    ugly_number = 0

    heap = []
    heapq.heappush(heap, 1)
    for _ in xrange(n):
        ugly_number = heapq.heappop(heap)
        if ugly_number % 2 == 0:
            heapq.heappush(heap, ugly_number * 2)
        elif ugly_number % 3 == 0:
            heapq.heappush(heap, ugly_number * 2)
            heapq.heappush(heap, ugly_number * 3)
        else:
            heapq.heappush(heap, ugly_number * 2)
            heapq.heappush(heap, ugly_number * 3)
            heapq.heappush(heap, ugly_number * 5)

    return ugly_number

    def nthUglyNumber2(self, n):
    ugly = [1]
    i2 = i3 = i5 = 0
    while len(ugly) < n:
        while ugly[i2] * 2 <= ugly[-1]:
            i2 += 1
        while ugly[i3] * 3 <= ugly[-1]:
            i3 += 1
        while ugly[i5] * 5 <= ugly[-1]:
            i5 += 1
        ugly.append(min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5))
    return ugly[-1]

    def nthUglyNumber3(self, n):
    q2, q3, q5 = [2], [3], [5]
    ugly = 1
    for u in heapq.merge(q2, q3, q5):
        if n == 1:
            return ugly
        if u > ugly:
            ugly = u
            n -= 1
            q2 += (2 * u,)
            q3 += (3 * u,)
            q5 += (5 * u,)


class Solution2(object):
    ugly = sorted(
        2 ** a * 3 ** b * 5 ** c
        for a in range(32)
        for b in range(20)
        for c in range(14)
    )

    def nthUglyNumber(self, n):
    return self.ugly[n - 1]


class Solution(object):
    def nthUglyNumber(self, n, a, b, c):

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    def lcm(x, y):
        return x // gcd(x, y) * y

    def count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c):
        return (
            x // a
            + x // b
            + x // c
            - (x // lcm_a_b + x // lcm_b_c + x // lcm_c_a)
            + x // lcm_a_b_c
        )

    lcm_a_b, lcm_b_c, lcm_c_a = lcm(a, b), lcm(b, c), lcm(c, a)
    lcm_a_b_c = lcm(lcm_a_b, lcm_b_c)

    left, right = 1, 2 * 10 ** 9
    while left <= right:
        mid = left + (right - left) // 2
        if count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) >= n:
            right = mid - 1
        else:
            left = mid + 1
    return left


class Solution(object):

    def isUgly(self, num):
    if num == 0:
        return False
    for i in [2, 3, 5]:
        while num % i == 0:
            num /= i
    return num == 1


import collections


class Solution(object):
    def uncommonFromSentences(self, A, B):

    count = collections.Counter(A.split())
    count += collections.Counter(B.split())
    return [word for word in count if count[word] == 1]


class Solution(object):
    def maxUncrossedLines(self, A, B):

    if len(A) < len(B):
        return self.maxUncrossedLines(B, A)

    dp = [[0 for _ in xrange(len(B) + 1)] for _ in xrange(2)]
    for i in xrange(len(A)):
        for j in xrange(len(B)):
            dp[(i + 1) % 2][j + 1] = max(
                dp[i % 2][j] + int(A[i] == B[j]),
                dp[i % 2][j + 1],
                dp[(i + 1) % 2][j],
            )
    return dp[len(A) % 2][len(B)]


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None

    def __repr__(self):
    if self:
        serial = []
        queue = [self]

        while queue:
            cur = queue[0]

            if cur:
                serial.append(cur.val)
                queue.append(cur.left)
                queue.append(cur.right)
            else:
                serial.append("#")

            queue = queue[1:]

        while serial[-1] == "#":
            serial.pop()

        return repr(serial)

    else:
        return None


class Solution(object):

    def generateTrees(self, n):
    return self.generateTreesRecu(1, n)

    def generateTreesRecu(self, low, high):
    result = []
    if low > high:
        result.append(None)
    for i in xrange(low, high + 1):
        left = self.generateTreesRecu(low, i - 1)
        right = self.generateTreesRecu(i + 1, high)
        for j in left:
            for k in right:
                cur = TreeNode(i)
                cur.left = j
                cur.right = k
                result.append(cur)
    return result


class Solution(object):
    def numTrees(self, n):

    if n == 0:
        return 1

    def combination(n, k):
        count = 1

        for i in xrange(1, k + 1):
            count = count * (n - i + 1) / i
        return count

    return combination(2 * n, n) - combination(2 * n, n - 1)


class Solution2(object):

    def numTrees(self, n):
    counts = [1, 1]
    for i in xrange(2, n + 1):
        count = 0
        for j in xrange(i):
            count += counts[j] * counts[i - j - 1]
        counts.append(count)
    return counts[-1]


class Solution(object):
    def numUniqueEmails(self, emails):

    def convert(email):
        name, domain = email.split("@")
        name = name[: name.index("+")]
        return "".join(["".join(name.split(".")), "@", domain])

    lookup = set()
    for email in emails:
        lookup.add(convert(email))
    return len(lookup)


class Solution(object):
    def uniqueMorseRepresentations(self, words):

    MORSE = [
        ".-",
        "-...",
        "-.-.",
        "-..",
        ".",
        "..-.",
        "--.",
        "....",
        "..",
        ".---",
        "-.-",
        ".-..",
        "--",
        "-.",
        "---",
        ".--.",
        "--.-",
        ".-.",
        "...",
        "-",
        "..-",
        "...-",
        ".--",
        "-..-",
        "-.--",
        "--..",
    ]

    lookup = {"".join(MORSE[ord(c) - ord("a")]
                      for c in word) for word in words}
    return len(lookup)


import collections


class Solution(object):
    def uniqueOccurrences(self, arr):

    count = collections.Counter(arr)
    lookup = set()
    for v in count.itervalues():
        if v in lookup:
            return False
        lookup.add(v)
    return True


class Solution2(object):
    def uniqueOccurrences(self, arr):

    count = collections.Counter(arr)
    return len(count) == len(set(count.itervalues()))


class Solution(object):

    def uniquePathsWithObstacles(self, obstacleGrid):

    m, n = len(obstacleGrid), len(obstacleGrid[0])

    ways = [0] * n
    ways[0] = 1
    for i in xrange(m):
        if obstacleGrid[i][0] == 1:
            ways[0] = 0
        for j in xrange(n):
            if obstacleGrid[i][j] == 1:
                ways[j] = 0
            elif j > 0:
                ways[j] += ways[j - 1]
    return ways[-1]


class Solution(object):
    def uniquePathsIII(self, grid):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def index(grid, r, c):
        return 1 << (r * len(grid[0]) + c)

    def dp(grid, src, dst, todo, lookup):
        if src == dst:
            return int(todo == 0)
        key = (src, todo)
        if key in lookup:
            return lookup[key]

        result = 0
        for d in directions:
            r, c = src[0] + d[0], src[1] + d[1]
            if (
                0 <= r < len(grid)
                and 0 <= c < len(grid[0])
                and grid[r][c] % 2 == 0
                and todo & index(grid, r, c)
            ):
                result += dp(grid, (r, c), dst, todo ^
                             index(grid, r, c), lookup)

        lookup[key] = result
        return lookup[key]

    todo = 0
    src, dst = None, None
    for r, row in enumerate(grid):
        for c, val in enumerate(row):
            if val % 2 == 0:
                todo |= index(grid, r, c)
            if val == 1:
                src = (r, c)
            elif val == 2:
                dst = (r, c)
    return dp(grid, src, dst, todo, {})


class Solution(object):

    def uniquePaths(self, m, n):
    if m < n:
        return self.uniquePaths(n, m)
    ways = [1] * n

    for i in xrange(1, m):
        for j in xrange(1, n):
            ways[j] += ways[j - 1]

    return ways[n - 1]


class Solution(object):
    def findSubstringInWraproundString(self, p):

    letters = [0] * 26
    result, length = 0, 0
    for i in xrange(len(p)):
        curr = ord(p[i]) - ord("a")
        if i > 0 and ord(p[i - 1]) != (curr - 1) % 26 + ord("a"):
            length = 0
        length += 1
        if length > letters[curr]:
            result += length - letters[curr]
            letters[curr] = length
    return result


import collections


class ValidWordAbbr(object):
    def __init__(self, dictionary):

    self.lookup_ = collections.defaultdict(set)
    for word in dictionary:
        abbr = self.abbreviation(word)
        self.lookup_[abbr].add(word)

    def isUnique(self, word):

    abbr = self.abbreviation(word)
    return self.lookup_[abbr] <= {word}

    def abbreviation(self, word):
    if len(word) <= 2:
        return word
    return word[0] + str(len(word) - 2) + word[-1]


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def isUnivalTree(self, root):

    s = [root]
    while s:
        node = s.pop()
        if not node:
            continue
        if node.val != root.val:
            return False
        s.append(node.left)
        s.append(node.right)
    return True


class Solution2(object):
    def isUnivalTree(self, root):

    return (
        not root.left
        or (root.left.val == root.val and self.isUnivalTree(root.left))
    ) and (
        not root.right
        or (root.right.val == root.val and self.isUnivalTree(root.right))
    )


class Solution(object):
    def validUtf8(self, data):

    count = 0
    for c in data:
        if count == 0:
            if (c >> 5) == 0b110:
                count = 1
            elif (c >> 4) == 0b1110:
                count = 2
            elif (c >> 3) == 0b11110:
                count = 3
            elif c >> 7:
                return False
        else:
            if (c >> 6) != 0b10:
                return False
            count -= 1
    return count == 0


import collections


class Solution(object):
    def isAnagram(self, s, t):

    if len(s) != len(t):
        return False
    count = collections.defaultdict(int)
    for c in s:
        count[c] += 1
    for c in t:
        count[c] -= 1
        if count[c] < 0:
            return False
    return True


class Solution2(object):
    def isAnagram(self, s, t):

    return collections.Counter(s) == collections.Counter(t)


class Solution3(object):
    def isAnagram(self, s, t):

    return sorted(s) == sorted(t)


class Solution(object):
    def isBoomerang(self, points):

    return (points[0][0] - points[1][0]) * (points[0][1] - points[2][1]) - (
        points[0][0] - points[2][0]
    ) * (points[0][1] - points[1][1]) != 0


class Solution(object):
    def validMountainArray(self, A):

    i = 0
    while i + 1 < len(A) and A[i] < A[i + 1]:
        i += 1
    j = len(A) - 1
    while j - 1 >= 0 and A[j - 1] > A[j]:
        j -= 1
    return 0 < i == j < len(A) - 1


class InputType(object):
    INVALID = 0
    SPACE = 1
    SIGN = 2
    DIGIT = 3
    DOT = 4
    EXPONENT = 5


class Solution(object):
    def isNumber(self, s):

    transition_table = [
        [-1, 0, 3, 1, 2, -1],
        [-1, 8, -1, 1, 4, 5],
        [-1, -1, -1, 4, -1, -1],
        [-1, -1, -1, 1, 2, -1],
        [-1, 8, -1, 4, -1, 5],
        [-1, -1, 6, 7, -1, -1],
        [-1, -1, -1, 7, -1, -1],
        [-1, 8, -1, 7, -1, -1],
        [-1, 8, -1, -1, -1, -1],
    ]

    state = 0
    for char in s:
        inputType = InputType.INVALID
        if char.isspace():
            inputType = InputType.SPACE
        elif char == "+" or char == "-":
            inputType = InputType.SIGN
        elif char.isdigit():
            inputType = InputType.DIGIT
        elif char == ".":
            inputType = InputType.DOT
        elif char == "e" or char == "E":
            inputType = InputType.EXPONENT

        state = transition_table[state][inputType]

        if state == -1:
            return False

    return state == 1 or state == 4 or state == 7 or state == 8


class Solution2(object):
    def isNumber(self, s):

    import re

    return bool(re.match("^\s*[\+-]?((\d+(\.\d*)?)|\.\d+)([eE][\+-]?\d+)?\s*$", s))


class Solution(object):
    def validPalindrome(self, s):

    def validPalindrome(s, left, right):
        while left < right:
            if s[left] != s[right]:
                return False
            left, right = left + 1, right - 1
        return True

    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return validPalindrome(s, left, right - 1) or validPalindrome(
                s, left + 1, right
            )
        left, right = left + 1, right - 1
    return True


class Solution(object):
    def isValidPalindrome(self, s, k):

    if s == s[::-1]:
        return True

    dp = [[1] * len(s) for _ in xrange(2)]
    for i in reversed(xrange(len(s))):
        for j in xrange(i + 1, len(s)):
            if s[i] == s[j]:
                dp[i % 2][j] = 2 + dp[(i + 1) %
                                      2][j - 1] if i + 1 <= j - 1 else 2
            else:
                dp[i % 2][j] = max(dp[(i + 1) % 2][j], dp[i % 2][j - 1])
    return len(s) <= k + dp[0][-1]


class Solution(object):

    def isPalindrome(self, s):
    i, j = 0, len(s) - 1
    while i < j:
        while i < j and not s[i].isalnum():
            i += 1
        while i < j and not s[j].isalnum():
            j -= 1
        if s[i].lower() != s[j].lower():
            return False
        i, j = i + 1, j - 1
    return True


class Solution(object):

    def isValid(self, s):
    stack, lookup = [], {"(": ")", "{": "}", "[": "]"}
    for parenthese in s:
        if parenthese in lookup:
            stack.append(parenthese)
        elif len(stack) == 0 or lookup[stack.pop()] != parenthese:
            return False
    return len(stack) == 0


class Solution(object):
    def checkValidString(self, s):

    lower, upper = 0, 0
    for c in s:
        lower += 1 if c == "(" else -1
        upper -= 1 if c == ")" else -1
        if upper < 0:
            break
        lower = max(lower, 0)
    return lower == 0


class Solution(object):
    def isPerfectSquare(self, num):

    left, right = 1, num
    while left <= right:
        mid = left + (right - left) / 2
        if mid >= num / mid:
            right = mid - 1
        else:
            left = mid + 1
    return left == num / left and num % left == 0


class Solution(object):
    def numPermsDISequence(self, S):

    dp = [1] * (len(S) + 1)
    for c in S:
        if c == "I":
            dp = dp[:-1]
            for i in xrange(1, len(dp)):
                dp[i] += dp[i - 1]
        else:
            dp = dp[1:]
            for i in reversed(xrange(len(dp) - 1)):
                dp[i] += dp[i + 1]
    return dp[0] % (10 ** 9 + 7)


class Solution(object):
    def validSquare(self, p1, p2, p3, p4):

    def dist(p1, p2):
        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2

    lookup = set(
        [
            dist(p1, p2),
            dist(p1, p3),
            dist(p1, p4),
            dist(p2, p3),
            dist(p2, p4),
            dist(p3, p4),
        ]
    )
    return 0 not in lookup and len(lookup) == 2


class Solution(object):
    def isValidSudoku(self, board):

    for i in xrange(9):
        if not self.isValidList(
            [board[i][j] for j in xrange(9)]
        ) or not self.isValidList([board[j][i] for j in xrange(9)]):
            return False
    for i in xrange(3):
        for j in xrange(3):
            if not self.isValidList(
                [
                    board[m][n]
                    for n in xrange(3 * j, 3 * j + 3)
                    for m in xrange(3 * i, 3 * i + 3)
                ]
            ):
                return False
    return True

    def isValidList(self, xs):
    xs = filter(lambda x: x != ".", xs)
    return len(set(xs)) == len(xs)


class Solution(object):
    def validTicTacToe(self, board):

    def win(board, player):
        for i in xrange(3):
            if all(board[i][j] == player for j in xrange(3)):
                return True
            if all(board[j][i] == player for j in xrange(3)):
                return True

        return (
            player == board[1][1] == board[0][0] == board[2][2]
            or player == board[1][1] == board[0][2] == board[2][0]
        )

    FIRST, SECOND = ("X", "O")
    x_count = sum(row.count(FIRST) for row in board)
    o_count = sum(row.count(SECOND) for row in board)
    if o_count not in {x_count - 1, x_count}:
        return False
    if win(board, FIRST) and x_count - 1 != o_count:
        return False
    if win(board, SECOND) and x_count != o_count:
        return False

    return True


class Solution(object):
    def triangleNumber(self, nums):

    result = 0
    nums.sort()
    for i in reversed(xrange(2, len(nums))):
        left, right = 0, i - 1
        while left < right:
            if nums[left] + nums[right] > nums[i]:
                result += right - left
                right -= 1
            else:
                left += 1
    return result


class Solution2(object):
    def triangleNumber(self, nums):

    result = 0
    nums.sort()
    for i in xrange(len(nums) - 2):
        if nums[i] == 0:
            continue
        k = i + 2
        for j in xrange(i + 1, len(nums) - 1):
            while k < len(nums) and nums[i] + nums[j] > nums[k]:
                k += 1
            result += k - j - 1
    return result


class Solution(object):
    def validWordAbbreviation(self, word, abbr):

    i, digit = 0, 0
    for c in abbr:
        if c.isdigit():
            if digit == 0 and c == "0":
                return False
            digit *= 10
            digit += int(c)
        else:
            if digit:
                i += digit
                digit = 0
            if i >= len(word) or word[i] != c:
                return False
            i += 1
    if digit:
        i += digit

    return i == len(word)


class Solution(object):
    def validWordSquare(self, words):

    for i in xrange(len(words)):
        for j in xrange(len(words[i])):
            if j >= len(words) or i >= len(words[j]) or words[j][i] != words[i][j]:
                return False
    return True


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):

    def isValidBST(self, root):
    prev, cur = None, root
    while cur:
        if cur.left is None:
            if prev and prev.val >= cur.val:
                return False
            prev = cur
            cur = cur.right
        else:
            node = cur.left
            while node.right and node.right != cur:
                node = node.right

            if node.right is None:
                node.right = cur
                cur = cur.left
            else:
                if prev and prev.val >= cur.val:
                    return False
                node.right = None
                prev = cur
                cur = cur.right

    return True


class Solution2(object):

    def isValidBST(self, root):
    return self.isValidBSTRecu(root, float("-inf"), float("inf"))

    def isValidBSTRecu(self, root, low, high):
    if root is None:
        return True

    return (
        low < root.val
        and root.val < high
        and self.isValidBSTRecu(root.left, low, root.val)
        and self.isValidBSTRecu(root.right, root.val, high)
    )


class Solution(object):
    def validateBinaryTreeNodes(self, n, leftChild, rightChild):

    roots = set(range(n)) - set(leftChild) - set(rightChild)
    if len(roots) != 1:
        return False
    (root,) = roots
    stk = [root]
    lookup = set([root])
    while stk:
        node = stk.pop()
        for c in (leftChild[node], rightChild[node]):
            if c < 0:
                continue
            if c in lookup:
                return False
            lookup.add(c)
            stk.append(c)
    return len(lookup) == n


import string


class Solution(object):
    def validIPAddress(self, IP):

    blocks = IP.split(".")
    if len(blocks) == 4:
        for i in xrange(len(blocks)):
            if (
                not blocks[i].isdigit()
                or not 0 <= int(blocks[i]) < 256
                or (blocks[i][0] == "0" and len(blocks[i]) > 1)
            ):
                return "Neither"
        return "IPv4"

    blocks = IP.split(":")
    if len(blocks) == 8:
        for i in xrange(len(blocks)):
            if not (1 <= len(blocks[i]) <= 4) or not all(
                c in string.hexdigits for c in blocks[i]
            ):
                return "Neither"
        return "IPv6"
    return "Neither"


class Solution(object):
    def validateStackSequences(self, pushed, popped):

    i = 0
    s = []
    for v in pushed:
        s.append(v)
        while s and i < len(popped) and s[-1] == popped[i]:
            s.pop()
            i += 1
    return i == len(popped)


import collections


class Solution(object):
    def isSolvable(self, words, result):

    def backtracking(words, result, i, j, carry, lookup, used):
        if j == len(result):
            return carry == 0

        if i != len(words):
            if j >= len(words[i]) or words[i][j] in lookup:
                return backtracking(words, result, i + 1, j, carry, lookup, used)
            for val in xrange(10):
                if val in used or (val == 0 and j == len(words[i]) - 1):
                    continue
                lookup[words[i][j]] = val
                used.add(val)
                if backtracking(words, result, i + 1, j, carry, lookup, used):
                    return True
                used.remove(val)
                del lookup[words[i][j]]
            return False

        carry, val = divmod(
            carry + sum(lookup[w[j]] for w in words if j < len(w)), 10
        )
        if result[j] in lookup:
            return val == lookup[result[j]] and backtracking(
                words, result, 0, j + 1, carry, lookup, used
            )
        if val in used or (val == 0 and j == len(result) - 1):
            return False
        lookup[result[j]] = val
        used.add(val)
        if backtracking(words, result, 0, j + 1, carry, lookup, used):
            return True
        used.remove(val)
        del lookup[result[j]]
        return False

    return backtracking([w[::-1] for w in words], result[::-1], 0, 0, 0, {}, set())


class Solution(object):

    def verifyPreorder(self, preorder):
    low, i = float("-inf"), -1
    for p in preorder:
        if p < low:
            return False
        while i >= 0 and p > preorder[i]:
            low = preorder[i]
            i -= 1
        i += 1
        preorder[i] = p
    return True


class Solution2(object):

    def verifyPreorder(self, preorder):
    low = float("-inf")
    path = []
    for p in preorder:
        if p < low:
            return False
        while path and p > path[-1]:
            low = path[-1]
            path.pop()
        path.append(p)
    return True


class Solution(object):
    def isValidSerialization(self, preorder):

    def split_iter(s, tok):
        start = 0
        for i in xrange(len(s)):
            if s[i] == tok:
                yield s[start:i]
                start = i + 1
        yield s[start:]

    if not preorder:
        return False

    depth, cnt = 0, preorder.count(",") + 1
    for tok in split_iter(preorder, ","):
        cnt -= 1
        if tok == "#":
            depth -= 1
            if depth < 0:
                break
        else:
            depth += 1
    return cnt == 0 and depth < 0


class Solution(object):
    def isAlienSorted(self, words, order):

    lookup = {c: i for i, c in enumerate(order)}
    for i in xrange(len(words) - 1):
        word1 = words[i]
        word2 = words[i + 1]
        for k in xrange(min(len(word1), len(word2))):
            if word1[k] != word2[k]:
                if lookup[word1[k]] > lookup[word2[k]]:
                    return False
                break
        else:
            if len(word1) > len(word2):
                return False
    return True


import collections


class TreeNode(object):
    def __init__(self, x):
    self.val = x
    self.left = None
    self.right = None


class Solution(object):
    def verticalTraversal(self, root):

    def dfs(node, lookup, x, y):
        if not node:
            return
        lookup[x][y].append(node)
        dfs(node.left, lookup, x - 1, y + 1)
        dfs(node.right, lookup, x + 1, y + 1)

    lookup = collections.defaultdict(lambda: collections.defaultdict(list))
    dfs(root, lookup, 0, 0)

    result = []
    for x in sorted(lookup):
        report = []
        for y in sorted(lookup[x]):
            report.extend(sorted(node.val for node in lookup[x][y]))
        result.append(report)
    return result


class Solution(object):
    def videoStitching(self, clips, T):

    if T == 0:
        return 0
    result = 1
    curr_reachable, reachable = 0, 0
    clips.sort()
    for left, right in clips:
        if left > reachable:
            break
        elif left > curr_reachable:
            curr_reachable = reachable
            result += 1
        reachable = max(reachable, right)
        if reachable >= T:
            return result
    return -1


class Solution(object):
    def spellchecker(self, wordlist, queries):

    vowels = set(["a", "e", "i", "o", "u"])

    def todev(word):
        return "".join("*" if c.lower() in vowels else c.lower() for c in word)

    words = set(wordlist)
    caps = {}
    vows = {}

    for word in wordlist:
        caps.setdefault(word.lower(), word)
        vows.setdefault(todev(word), word)

    def check(query):
        if query in words:
            return query
        lower = query.lower()
        if lower in caps:
            return caps[lower]
        devow = todev(lower)
        if devow in vows:
            return vows[devow]
        return ""

    return map(check, queries)


class Solution(object):
    def robotSim(self, commands, obstacles):

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    x, y, i = 0, 0, 0
    lookup = set(map(tuple, obstacles))
    result = 0
    for cmd in commands:
        if cmd == -2:
            i = (i - 1) % 4
        elif cmd == -1:
            i = (i + 1) % 4
        else:
            for k in xrange(cmd):
                if (x + directions[i][0], y + directions[i][1]) not in lookup:
                    x += directions[i][0]
                    y += directions[i][1]
                    result = max(result, x * x + y * y)
    return result


from collections import deque


class Solution(object):
    def wallsAndGates(self, rooms):

    INF = 2147483647
    q = deque(
        [(i, j) for i, row in enumerate(rooms)
         for j, r in enumerate(row) if not r]
    )
    while q:
        (i, j) = q.popleft()
        for I, J in (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1):
            if (
                0 <= I < len(rooms)
                and 0 <= J < len(rooms[0])
                and rooms[I][J] == INF
            ):
                rooms[I][J] = rooms[i][j] + 1
                q.append((I, J))


class Solution(object):
    def canMeasureWater(self, x, y, z):

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    return z == 0 or ((z <= x + y) and (z % gcd(x, y) == 0))


class Solution(object):
    def numWaterBottles(self, numBottles, numExchange):

    result = numBottles
    while numBottles >= numExchange:
        numBottles, remainder = divmod(numBottles, numExchange)
        result += numBottles
        numBottles += remainder
    return result


class Solution(object):
    def waysToMakeFair(self, nums):

    prefix = [0] * 2
    suffix = [sum(nums[i] for i in xrange(k, len(nums), 2)) for k in xrange(2)]
    result = 0
    for i, num in enumerate(nums):
        suffix[i % 2] -= num
        result += int(prefix[0] + suffix[1] == prefix[1] + suffix[0])
        prefix[i % 2] += num
    return result


class Solution(object):
    def waysToSplit(self, nums):

    MOD = 10 ** 9 + 7

    prefix = [0]
    for x in nums:
        prefix.append(prefix[-1] + x)

    result = left = right = 0
    for i in xrange(len(nums)):
        left = max(left, i + 1)
        while (
            left + 1 < len(nums)
            and prefix[i + 1] > prefix[left + 1] - prefix[i + 1]
        ):
            left += 1
        right = max(right, left)
        while (
            right + 1 < len(nums)
            and prefix[right + 1] - prefix[i + 1] <= prefix[-1] - prefix[right + 1]
        ):
            right += 1
        result = (result + (right - left)) % MOD
    return result


import threading
import Queue


class HtmlParser(object):
    def getUrls(self, url):

    pass


class Solution(object):
    NUMBER_OF_WORKERS = 8

    def __init__(self):
    self.__cv = threading.Condition()
    self.__q = Queue.Queue()

    def crawl(self, startUrl, htmlParser):

    SCHEME = "http://"

    def hostname(url):
        pos = url.find("/", len(SCHEME))
        if pos == -1:
            return url
        return url[:pos]

    def worker(htmlParser, lookup):
        while True:
            from_url = self.__q.get()
            if from_url is None:
                break
            name = hostname(from_url)
            for to_url in htmlParser.getUrls(from_url):
                if name != hostname(to_url):
                    continue
                with self.__cv:
                    if to_url not in lookup:
                        lookup.add(to_url)
                        self.__q.put(to_url)
            self.__q.task_done()

    workers = []
    self.__q = Queue.Queue()
    self.__q.put(startUrl)
    lookup = set([startUrl])
    for i in xrange(self.NUMBER_OF_WORKERS):
        t = threading.Thread(target=worker, args=(htmlParser, lookup))
        t.start()
        workers.append(t)
    self.__q.join()
    for t in workers:
        self.__q.put(None)
    for t in workers:
        t.join()
    return list(lookup)


import threading
import collections


class Solution2(object):
    NUMBER_OF_WORKERS = 8

    def __init__(self):
    self.__cv = threading.Condition()
    self.__q = collections.deque()
    self.__working_count = 0

    def crawl(self, startUrl, htmlParser):

    SCHEME = "http://"

    def hostname(url):
        pos = url.find("/", len(SCHEME))
        if pos == -1:
            return url
        return url[:pos]

    def worker(htmlParser, lookup):
        while True:
            with self.__cv:
                while not self.__q:
                    self.__cv.wait()
                from_url = self.__q.popleft()
                if from_url is None:
                    break
                self.__working_count += 1
            name = hostname(from_url)
            for to_url in htmlParser.getUrls(from_url):
                if name != hostname(to_url):
                    continue
                with self.__cv:
                    if to_url not in lookup:
                        lookup.add(to_url)
                        self.__q.append(to_url)
                        self.__cv.notifyAll()
            with self.__cv:
                self.__working_count -= 1
                if not self.__q and not self.__working_count:
                    self.__cv.notifyAll()

    workers = []
    self.__q = collections.deque([startUrl])
    lookup = set([startUrl])
    for i in xrange(self.NUMBER_OF_WORKERS):
        t = threading.Thread(target=worker, args=(htmlParser, lookup))
        t.start()
        workers.append(t)
    with self.__cv:
        while self.__q or self.__working_count:
            self.__cv.wait()
        for i in xrange(self.NUMBER_OF_WORKERS):
            self.__q.append(None)
        self.__cv.notifyAll()
    for t in workers:
        t.join()
    return list(lookup)


class HtmlParser(object):
    def getUrls(self, url):

    pass


class Solution(object):
    def crawl(self, startUrl, htmlParser):

    SCHEME = "http://"

    def hostname(url):
        pos = url.find("/", len(SCHEME))
        if pos == -1:
            return url
        return url[:pos]

    result = [startUrl]
    lookup = set(result)
    for from_url in result:
        name = hostname(from_url)
        for to_url in htmlParser.getUrls(from_url):
            if to_url not in lookup and name == hostname(to_url):
                result.append(to_url)
                lookup.add(to_url)
    return result


class Solution(object):
    def findBall(self, grid):

    result = []
    for c in xrange(len(grid[0])):
        for r in xrange(len(grid)):
            nc = c + grid[r][c]
            if not (0 <= nc < len(grid[0]) and grid[r][nc] == grid[r][c]):
                c = -1
                break
            c = nc
        result.append(c)
    return result


import itertools


class Solution(object):
    def maxWidthOfVerticalArea(self, points):

    sorted_x = sorted({x for x, y in points})
    return max([b - a for a, b in itertools.izip(sorted_x, sorted_x[1:])] + [0])


class Solution(object):
    def wiggleSort(self, nums):

    nums.sort()
    med = (len(nums) - 1) / 2
    nums[::2], nums[1::2] = nums[med::-1], nums[:med:-1]


from random import randint


class Solution2(object):
    def wiggleSort(self, nums):

    def findKthLargest(nums, k):
        left, right = 0, len(nums) - 1
        while left <= right:
            pivot_idx = randint(left, right)
            new_pivot_idx = partitionAroundPivot(left, right, pivot_idx, nums)
            if new_pivot_idx == k - 1:
                return nums[new_pivot_idx]
            elif new_pivot_idx > k - 1:
                right = new_pivot_idx - 1
            else:
                left = new_pivot_idx + 1

    def partitionAroundPivot(left, right, pivot_idx, nums):
        pivot_value = nums[pivot_idx]
        new_pivot_idx = left
        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
        for i in xrange(left, right):
            if nums[i] > pivot_value:
                nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                new_pivot_idx += 1
        nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
        return new_pivot_idx

    def reversedTriPartitionWithVI(nums, val):
        def idx(i, N):
            return (1 + 2 * (i)) % N

        N = len(nums) / 2 * 2 + 1
        i, j, n = 0, 0, len(nums) - 1
        while j <= n:
            if nums[idx(j, N)] > val:
                nums[idx(i, N)], nums[idx(j, N)
                                      ] = nums[idx(j, N)], nums[idx(i, N)]
                i += 1
                j += 1
            elif nums[idx(j, N)] < val:
                nums[idx(j, N)], nums[idx(n, N)
                                      ] = nums[idx(n, N)], nums[idx(j, N)]
                n -= 1
            else:
                j += 1

    mid = (len(nums) - 1) / 2
    findKthLargest(nums, mid + 1)
    reversedTriPartitionWithVI(nums, nums[mid])


class Solution(object):
    def wiggleSort(self, nums):

    for i in xrange(1, len(nums)):
        if ((i % 2) and nums[i - 1] > nums[i]) or (
            not (i % 2) and nums[i - 1] < nums[i]
        ):

            nums[i - 1], nums[i] = nums[i], nums[i - 1]


class Solution2(object):
    def wiggleSort(self, nums):

    nums.sort()
    med = (len(nums) - 1) // 2
    nums[::2], nums[1::2] = nums[med::-1], nums[:med:-1]


class Solution(object):
    def wiggleMaxLength(self, nums):

    if len(nums) < 2:
        return len(nums)

    length, up = 1, None

    for i in xrange(1, len(nums)):
        if nums[i - 1] < nums[i] and (up is None or up is False):
            length += 1
            up = True
        elif nums[i - 1] > nums[i] and (up is None or up is True):
            length += 1
            up = False

    return length


class Solution(object):
    def isMatch(self, s, p):

    count = 0
    p_ptr, s_ptr, last_s_ptr, last_p_ptr = 0, 0, -1, -1
    while s_ptr < len(s):
        if p_ptr < len(p) and (s[s_ptr] == p[p_ptr] or p[p_ptr] == "?"):
            s_ptr += 1
            p_ptr += 1
        elif p_ptr < len(p) and p[p_ptr] == "*":
            p_ptr += 1
            last_s_ptr = s_ptr
            last_p_ptr = p_ptr
        elif last_p_ptr != -1:
            last_s_ptr += 1
            s_ptr = last_s_ptr
            p_ptr = last_p_ptr
        else:
            assert count <= (len(p) + 1) * (len(s) + 1)
            return False
        count += 1

    while p_ptr < len(p) and p[p_ptr] == "*":
        p_ptr += 1
        count += 1

    assert count <= (len(p) + 1) * (len(s) + 1)
    return p_ptr == len(p)


class Solution2(object):

    def isMatch(self, s, p):
    k = 2
    result = [[False for j in xrange(len(p) + 1)] for i in xrange(k)]

    result[0][0] = True
    for i in xrange(1, len(p) + 1):
        if p[i - 1] == "*":
            result[0][i] = result[0][i - 1]
    for i in xrange(1, len(s) + 1):
        result[i % k][0] = False
        for j in xrange(1, len(p) + 1):
            if p[j - 1] != "*":
                result[i % k][j] = result[(i - 1) % k][j - 1] and (
                    s[i - 1] == p[j - 1] or p[j - 1] == "?"
                )
            else:
                result[i % k][j] = result[i %
                                          k][j - 1] or result[(i - 1) % k][j]

    return result[len(s) % k][len(p)]


class Solution3(object):

    def isMatch(self, s, p):
    result = [[False for j in xrange(len(p) + 1)] for i in xrange(len(s) + 1)]

    result[0][0] = True
    for i in xrange(1, len(p) + 1):
        if p[i - 1] == "*":
            result[0][i] = result[0][i - 1]
    for i in xrange(1, len(s) + 1):
        result[i][0] = False
        for j in xrange(1, len(p) + 1):
            if p[j - 1] != "*":
                result[i][j] = result[i - 1][j - 1] and (
                    s[i - 1] == p[j - 1] or p[j - 1] == "?"
                )
            else:
                result[i][j] = result[i][j - 1] or result[i - 1][j]

    return result[len(s)][len(p)]


class Solution4(object):

    def isMatch(self, s, p):
    if not p or not s:
        return not s and not p

    if p[0] != "*":
        if p[0] == s[0] or p[0] == "?":
            return self.isMatch(s[1:], p[1:])
        else:
            return False
    else:
        while len(s) > 0:
            if self.isMatch(s, p[1:]):
                return True
            s = s[1:]
        return self.isMatch(s, p[1:])


import collections


class Solution(object):
    def wordsAbbreviation(self, dict):

    def isUnique(prefix, words):
        return sum(word.startswith(prefix) for word in words) == 1

    def toAbbr(prefix, word):
        abbr = prefix + str(len(word) - 1 - len(prefix)) + word[-1]
        return abbr if len(abbr) < len(word) else word

    abbr_to_word = collections.defaultdict(set)
    word_to_abbr = {}

    for word in dict:
        prefix = word[:1]
        abbr_to_word[toAbbr(prefix, word)].add(word)

    for abbr, conflicts in abbr_to_word.iteritems():
        if len(conflicts) > 1:
            for word in conflicts:
                for i in xrange(2, len(word)):
                    prefix = word[:i]
                    if isUnique(prefix, conflicts):
                        word_to_abbr[word] = toAbbr(prefix, word)
                        break
        else:
            word_to_abbr[conflicts.pop()] = abbr

    return [word_to_abbr[word] for word in dict]


class Solution(object):
    def wordBreak(self, s, wordDict):

    n = len(s)

    max_len = 0
    for string in wordDict:
        max_len = max(max_len, len(string))

    can_break = [False for _ in xrange(n + 1)]
    valid = [[False] * n for _ in xrange(n)]
    can_break[0] = True
    for i in xrange(1, n + 1):
        for l in xrange(1, min(i, max_len) + 1):
            if can_break[i - l] and s[i - l: i] in wordDict:
                valid[i - l][i - 1] = True
                can_break[i] = True

    result = []
    if can_break[-1]:
        self.wordBreakHelper(s, valid, 0, [], result)
    return result

    def wordBreakHelper(self, s, valid, start, path, result):
    if start == len(s):
        result.append(" ".join(path))
        return
    for i in xrange(start, len(s)):
        if valid[start][i]:
            path += [s[start: i + 1]]
            self.wordBreakHelper(s, valid, i + 1, path, result)
            path.pop()


class Solution(object):
    def wordBreak(self, s, wordDict):

    n = len(s)

    max_len = 0
    for string in wordDict:
        max_len = max(max_len, len(string))

    can_break = [False for _ in xrange(n + 1)]
    can_break[0] = True
    for i in xrange(1, n + 1):
        for l in xrange(1, min(i, max_len) + 1):
            if can_break[i - l] and s[i - l: i] in wordDict:
                can_break[i] = True
                break

    return can_break[-1]


from collections import defaultdict
from string import ascii_lowercase


class Solution(object):
    def findLadders(self, beginWord, endWord, wordList):

    def backtracking(tree, beginWord, word):
        return (
            [[beginWord]]
            if word == beginWord
            else [
                path + [word]
                for new_word in tree[word]
                for path in backtracking(tree, beginWord, new_word)
            ]
        )

    words = set(wordList)
    if endWord not in words:
        return []
    tree = defaultdict(set)
    is_found, left, right, is_reversed = False, {beginWord}, {endWord}, False
    while left:
        words -= left
        new_left = set()
        for word in left:
            for new_word in (
                word[:i] + c + word[i + 1:]
                for i in xrange(len(beginWord))
                for c in ascii_lowercase
            ):
                if new_word not in words:
                    continue
                if new_word in right:
                    is_found = True
                else:
                    new_left.add(new_word)
                tree[new_word].add(word) if not is_reversed else tree[word].add(
                    new_word
                )
        if is_found:
            break
        left = new_left
        if len(left) > len(right):
            left, right, is_reversed = right, left, not is_reversed
    return backtracking(tree, beginWord, endWord)


class Solution2(object):
    def findLadders(self, beginWord, endWord, wordList):

    dictionary = set(wordList)
    result, cur, visited, found, trace = (
        [],
        [beginWord],
        set([beginWord]),
        False,
        defaultdict(list),
    )

    while cur and not found:
        for word in cur:
            visited.add(word)

        next = set()
        for word in cur:
            for i in xrange(len(word)):
                for c in ascii_lowercase:
                    candidate = word[:i] + c + word[i + 1:]
                    if candidate not in visited and candidate in dictionary:
                        if candidate == endWord:
                            found = True
                        next.add(candidate)
                        trace[candidate].append(word)
        cur = next

    if found:
        self.backtrack(result, trace, [], endWord)

    return result

    def backtrack(self, result, trace, path, word):
    if not trace[word]:
        path.append(word)
        result.append(path[::-1])
        path.pop()
    else:
        for prev in trace[word]:
            path.append(word)
            self.backtrack(result, trace, path, prev)
            path.pop()


from string import ascii_lowercase


class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):

    words = set(wordList)
    if endWord not in words:
        return 0
    left, right = {beginWord}, {endWord}
    ladder = 2
    while left:
        words -= left
        new_left = set()
        for word in left:
            for new_word in (
                word[:i] + c + word[i + 1:]
                for i in xrange(len(beginWord))
                for c in ascii_lowercase
            ):
                if new_word not in words:
                    continue
                if new_word in right:
                    return ladder
                new_left.add(new_word)
        left = new_left
        ladder += 1
        if len(left) > len(right):
            left, right = right, left
    return 0


class Solution2(object):
    def ladderLength(self, beginWord, endWord, wordList):

    lookup = set(wordList)
    if endWord not in lookup:
        return 0
    ladder = 2
    q = [beginWord]
    while q:
        new_q = []
        for word in q:
            for i in xrange(len(word)):
                for j in ascii_lowercase:
                    new_word = word[:i] + j + word[i + 1:]
                    if new_word == endWord:
                        return ladder
                    if new_word in lookup:
                        lookup.remove(new_word)
                        new_q.append(new_word)
        q = new_q
        ladder += 1
    return 0


class Solution(object):
    def wordPatternMatch(self, pattern, str):

    w2p, p2w = {}, {}
    return self.match(pattern, str, 0, 0, w2p, p2w)

    def match(self, pattern, str, i, j, w2p, p2w):
    is_match = False
    if i == len(pattern) and j == len(str):
        is_match = True
    elif i < len(pattern) and j < len(str):
        p = pattern[i]
        if p in p2w:
            w = p2w[p]
            if w == str[j: j + len(w)]:
                is_match = self.match(
                    pattern, str, i + 1, j + len(w), w2p, p2w)

        else:
            for k in xrange(j, len(str)):
                w = str[j: k + 1]
                if w not in w2p:

                    w2p[w], p2w[p] = p, w
                    is_match = self.match(pattern, str, i + 1, k + 1, w2p, p2w)
                    w2p.pop(w), p2w.pop(p)
                if is_match:
                    break
    return is_match


from itertools import izip


class Solution(object):
    def wordPattern(self, pattern, str):

    if len(pattern) != self.wordCount(str):
        return False

    w2p, p2w = {}, {}
    for p, w in izip(pattern, self.wordGenerator(str)):
        if w not in w2p and p not in p2w:

            w2p[w] = p
            p2w[p] = w
        elif w not in w2p or w2p[w] != p:

            return False
    return True

    def wordCount(self, str):
    cnt = 1 if str else 0
    for c in str:
        if c == " ":
            cnt += 1
    return cnt

    def wordGenerator(self, str):
    w = ""
    for c in str:
        if c == " ":
            yield w
            w = ""
        else:
            w += c
    yield w


class Solution2(object):
    def wordPattern(self, pattern, str):

    words = str.split()
    if len(pattern) != len(words):
        return False

    w2p, p2w = {}, {}
    for p, w in izip(pattern, words):
        if w not in w2p and p not in p2w:

            w2p[w] = p
            p2w[p] = w
        elif w not in w2p or w2p[w] != p:

            return False
    return True


class TrieNode(object):

    def __init__(self):
    self.is_string = False
    self.leaves = {}

    def insert(self, word):
    cur = self
    for c in word:
        if not c in cur.leaves:
            cur.leaves[c] = TrieNode()
        cur = cur.leaves[c]
    cur.is_string = True


class Solution(object):
    def findWords(self, board, words):

    visited = [[False for j in xrange(len(board[0]))]
               for i in xrange(len(board))]
    result = {}
    trie = TrieNode()
    for word in words:
        trie.insert(word)

    for i in xrange(len(board)):
        for j in xrange(len(board[0])):
            self.findWordsRecu(board, trie, 0, i, j, visited, [], result)

    return result.keys()

    def findWordsRecu(self, board, trie, cur, i, j, visited, cur_word, result):
    if (
        not trie
        or i < 0
        or i >= len(board)
        or j < 0
        or j >= len(board[0])
        or visited[i][j]
    ):
        return

    if board[i][j] not in trie.leaves:
        return

    cur_word.append(board[i][j])
    next_node = trie.leaves[board[i][j]]
    if next_node.is_string:
        result["".join(cur_word)] = True

    visited[i][j] = True
    self.findWordsRecu(
        board, next_node, cur + 1, i + 1, j, visited, cur_word, result
    )
    self.findWordsRecu(
        board, next_node, cur + 1, i - 1, j, visited, cur_word, result
    )
    self.findWordsRecu(
        board, next_node, cur + 1, i, j + 1, visited, cur_word, result
    )
    self.findWordsRecu(
        board, next_node, cur + 1, i, j - 1, visited, cur_word, result
    )
    visited[i][j] = False
    cur_word.pop()


class Solution(object):

    def exist(self, board, word):
    visited = [[False for j in xrange(len(board[0]))]
               for i in xrange(len(board))]

    for i in xrange(len(board)):
        for j in xrange(len(board[0])):
            if self.existRecu(board, word, 0, i, j, visited):
                return True

    return False

    def existRecu(self, board, word, cur, i, j, visited):
    if cur == len(word):
        return True

    if (
        i < 0
        or i >= len(board)
        or j < 0
        or j >= len(board[0])
        or visited[i][j]
        or board[i][j] != word[cur]
    ):
        return False

    visited[i][j] = True
    result = (
        self.existRecu(board, word, cur + 1, i + 1, j, visited)
        or self.existRecu(board, word, cur + 1, i - 1, j, visited)
        or self.existRecu(board, word, cur + 1, i, j + 1, visited)
        or self.existRecu(board, word, cur + 1, i, j - 1, visited)
    )
    visited[i][j] = False

    return result


class TrieNode(object):
    def __init__(self):
    self.indices = []
    self.children = [None] * 26

    def insert(self, words, i):
    cur = self
    for c in words[i]:
        if not cur.children[ord(c) - ord("a")]:
            cur.children[ord(c) - ord("a")] = TrieNode()
        cur = cur.children[ord(c) - ord("a")]
        cur.indices.append(i)


class Solution(object):
    def wordSquares(self, words):

    result = []

    trie = TrieNode()
    for i in xrange(len(words)):
        trie.insert(words, i)

    curr = []
    for s in words:
        curr.append(s)
        self.wordSquaresHelper(words, trie, curr, result)
        curr.pop()

    return result

    def wordSquaresHelper(self, words, trie, curr, result):
    if len(curr) >= len(words[0]):
        return result.append(list(curr))

    node = trie
    for s in curr:
        node = node.children[ord(s[len(curr)]) - ord("a")]
        if not node:
            return

    for i in node.indices:
        curr.append(words[i])
        self.wordSquaresHelper(words, trie, curr, result)
        curr.pop()


import collections


class Solution(object):
    def wordSubsets(self, A, B):

    count = collections.Counter()
    for b in B:
        for c, n in collections.Counter(b).items():
            count[c] = max(count[c], n)
    result = []
    for a in A:
        count = collections.Counter(a)
        if all(count[c] >= count[c] for c in count):
            result.append(a)
    return result


import collections


class Solution(object):
    def hasGroupsSizeX(self, deck):

    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    vals = collections.Counter(deck).values()
    return reduce(gcd, vals) >= 2


class Solution(object):
    def xorOperation(self, n, start):

    def xorNums(n, start):
        def xorNumsBeginEven(n, start):
            assert start % 2 == 0

            return ((n // 2) % 2) ^ ((start + n - 1) if n % 2 else 0)

        return (
            start ^ xorNumsBeginEven(n - 1, start + 1)
            if start % 2
            else xorNumsBeginEven(n, start)
        )

    return int(n % 2 and start % 2) + 2 * xorNums(n, start // 2)


import operator


class Solution2(object):
    def xorOperation(self, n, start):

    return reduce(operator.xor, (i for i in xrange(start, start + 2 * n, 2)))


class Solution(object):
    def xorQueries(self, arr, queries):

    for i in xrange(1, len(arr)):
        arr[i] ^= arr[i - 1]
    return [
        arr[right] ^ arr[left - 1] if left else arr[right]
        for left, right in queries
    ]


class Solution(object):
    def convert(self, s, numRows):

    if numRows == 1:
        return s
    step, zigzag = 2 * numRows - 2, ""
    for i in xrange(numRows):
        for j in xrange(i, len(s), step):
            zigzag += s[j]
            if 0 < i < numRows - 1 and j + step - 2 * i < len(s):
                zigzag += s[j + step - 2 * i]
    return zigzag


import collections


class ZigzagIterator(object):
    def __init__(self, v1, v2):

    self.q = collections.deque([(len(v), iter(v)) for v in (v1, v2) if v])

    def next(self):

    len, iter = self.q.popleft()
    if len > 1:
        self.q.append((len - 1, iter))
    return next(iter)

    def hasNext(self):

    return bool(self.q)


import collections


class Solution_TLE_BUT_CORRECT(object):
    def findMinStep(self, board, hand):

    def shrink(s):
        stack = []
        start = 0
        for i in xrange(len(s) + 1):
            if i == len(s) or s[i] != s[start]:
                if stack and stack[-1][0] == s[start]:
                    stack[-1][1] += i - start
                    if stack[-1][1] >= 3:
                        stack.pop()
                elif s and i - start < 3:
                    stack += ([s[start], i - start],)
                start = i
        result = []
        for p in stack:
            result += [p[0]] * p[1]
        return result

    def findMinStepHelper(board, hand, lookup):
        if not board:
            return 0
        if not hand:
            return float("inf")
        if tuple(hand) in lookup[tuple(board)]:
            return lookup[tuple(board)][tuple(hand)]

        result = float("inf")
        for i in xrange(len(hand)):
            for j in xrange(len(board) + 1):
                next_board = shrink(board[0:j] + hand[i: i + 1] + board[j:])
                next_hand = hand[0:i] + hand[i + 1:]
                result = min(
                    result, findMinStepHelper(
                        next_board, next_hand, lookup) + 1
                )
        lookup[tuple(board)][tuple(hand)] = result
        return result

    lookup = collections.defaultdict(dict)
    board, hand = list(board), list(hand)
    result = findMinStepHelper(board, hand, lookup)
    return -1 if result == float("inf") else result


class Solution_WRONG_GREEDY_BUT_ACCEPT(object):
    def findMinStep(self, board, hand):

    def shrink(s):
        stack = []
        start = 0
        for i in xrange(len(s) + 1):
            if i == len(s) or s[i] != s[start]:
                if stack and stack[-1][0] == s[start]:
                    stack[-1][1] += i - start
                    if stack[-1][1] >= 3:
                        stack.pop()
                elif s and i - start < 3:
                    stack += ([s[start], i - start],)
                start = i
        result = []
        for p in stack:
            result += [p[0]] * p[1]
        return result

    def find(board, c, j):
        for i in xrange(j, len(board)):
            if board[i] == c:
                return i
        return -1

    def findMinStepHelper(board, hand, lookup):
        if not board:
            return 0
        if not hand:
            return float("inf")
        if tuple(hand) in lookup[tuple(board)]:
            return lookup[tuple(board)][tuple(hand)]

        result = float("inf")
        for i in xrange(len(hand)):
            j = 0
            while j < len(board):
                k = find(board, hand[i], j)
                if k == -1:
                    break

                if k < len(board) - 1 and board[k] == board[k + 1]:
                    next_board = shrink(board[0:k] + board[k + 2:])
                    next_hand = hand[0:i] + hand[i + 1:]
                    result = min(
                        result, findMinStepHelper(
                            next_board, next_hand, lookup) + 1
                    )
                    k += 1
                elif i > 0 and hand[i] == hand[i - 1]:
                    next_board = shrink(board[0:k] + board[k + 1:])
                    next_hand = hand[0: i - 1] + hand[i + 1:]
                    result = min(
                        result, findMinStepHelper(
                            next_board, next_hand, lookup) + 2
                    )
                j = k + 1

        lookup[tuple(board)][tuple(hand)] = result
        return result

    lookup = collections.defaultdict(dict)
    board, hand = list(board), list(hand)
    hand.sort()
    result = findMinStepHelper(board, hand, lookup)
    return -1 if result == float("inf") else result
